<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br></p><p>Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br></p><p>The proposal drafts can be found at the following links:<br></p><p>* Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>* Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>* Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br></p><p>Matthew<br>Parameter Forwarding<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This feature introduces an automatic parameter forwarding mechanism.<br></p><p>Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>Motivation<br></p><p>There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br></p><p>This feature will be especially useful in initializers such as:<br></p><p>Convenience initializers that foward parameters directly to a designated initializer<br>Designated initializers that foward parameters directly to a super initializer<br>Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br></p><p>Proposed solution<br></p><p>The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br></p><p>The basic mechanism looks like this:<br></p><p>func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(i: 32, ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>    foo(i: 32, s: s, f: f, d: d, b: b)<br>}<br>Some things to note about the syntax:<br></p><p>...fooParams is a placeholder introduced with ... and followed by an identifier.<br>In the signature it can be placed anywhere in the parameter list.<br>At the call site, it must appear at the end of the argument list.<br>The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>Additional details will be introduced with a corresponding example.<br></p><p>Omitting the placeholder identifier<br></p><p>The above example can be written more concisely by omitting the placeholder identifier.<br></p><p>func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar(...) {<br>    foo(i: 32, ...)<br>}<br></p><p>// compiler synthesizes:<br>func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>    foo(i: 32, s: s, f: f, d: d, b: b)<br>}<br>NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br></p><p>Multiple forwarded parameter sets<br></p><p>It is possible for a single function to forward more than one set of parameters:<br></p><p>func foo(i i: Int, s: String, f: Float = 42) { }<br>func foo2(d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar(...fooParams, ...foo2Params) {<br>    foo2(...foo2Params)<br>    foo(i: 32, ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>    foo(i: 32, s: s, f: f, d: d, b: b)<br>}<br>Direct arguments<br></p><p>Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br></p><p>func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br></p><p>func bar(...fooParams) {<br>    // error: `i` must precede `s` in the argument list<br>    foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>}<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(i: 32, f: 0, ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar(s s: String, d: Double = 43, b: Bool = false) {<br>    foo(i: 32, s: s, f: 0, d: d, b: b)<br>}<br>Multi-forwarding the same parameters<br></p><p>It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br></p><p>func foo(i i: Int, s: String, d: Double = 43) { }<br>func bar(i i: Int, s: String, d: Double = 43) { }<br></p><p>// user writes:<br>func baz(...fooBarParams) {<br>    foo(...fooBarParams)<br>    bar(...fooBarParams)<br>}<br></p><p>// compiler synthesizes: <br>func baz(i i: Int, s: String, d: Double = 43) {<br>    foo(i: i, s: s, d: d)<br>    bar(i: i, s: s, d: d)<br>}<br>NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br></p><p>Unambiguous call<br></p><p>When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br></p><p>func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    // error: ambiguous use of foo<br>    // foo(i: 32, ...fooParams)<br>    <br>    // ok: `b` makes the call to foo unambiguous<br>    foo(b: true, ...fooParams)<br>    // ok: `f` makes the call to foo unambiguous<br>    foo(f: 24, ...fooParams)<br>}<br></p><p>// compiler synthesizes: <br>func bar(i i: Int, s: String, d: Double = 43) {<br>    foo(i: i, s: s, d: d, b: true)<br>    foo(i: i, s: s, d: d, f: 24)<br>}<br>Default values<br></p><p>When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br></p><p>We can modify the previous example to use the defualt values:<br></p><p>func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    // ok: `b` makes the call to foo unambiguous, still uses default value<br>    foo(b: default, ...fooParams)<br>    // ok: `f` makes the call to foo unambiguous, still uses default value<br>    foo(f: default, ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar(i i: Int, s: String, d: Double = 43) {<br>    foo(i: i, s: s, d: d, b: false)<br>    foo(i: i, s: s, d: d, f: 42)<br>}<br>It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br></p><p>func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(default..., ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar(i i: Int, s: String) {<br>    foo(i: i, s: s, d: 43, b: false)<br>}<br>NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br></p><p>Generic parameters<br></p><p>If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br></p><p>func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>    foo(i: i, s: s, t: t, d: d, b: b)<br>}<br>If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br></p><p>func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>    (s: S, t: T) { }<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(t: [42], ...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>    foo(s: s, t: [42])<br>}<br>Syntheszied internal names<br></p><p>The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br></p><p>func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br></p><p>// user writes:<br>func bar&lt;T&gt;(t: T, ...fooParams) {<br>    // do something with t<br>    foo(...fooParams)<br>}<br></p><p>// compiler synthesizes:<br>func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>    foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>}<br>Detailed design<br></p><p>TODO but should fall out pretty clearly from the proposed solution<br></p><p>Impact on existing code<br></p><p>This is a strictly additive change. It has no impact on existing code.<br></p><p>Alternatives considered<br></p><p>I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br></p><p>The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/86acb19d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 10, 2016 at 11:00:00pm</p></header><div class="content"><p>I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br></p><p>I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br></p><p>I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br></p><p>At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br></p><p>Félix<br></p><p>&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt; <br>&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt; <br>&gt; The proposal drafts can be found at the following links:<br>&gt; <br>&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt; <br>&gt; Matthew<br>&gt; Parameter Forwarding<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt; <br>&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt; Motivation<br>&gt; <br>&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt; <br>&gt; This feature will be especially useful in initializers such as:<br>&gt; <br>&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt; <br>&gt; The basic mechanism looks like this:<br>&gt; <br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(i: 32, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt; Some things to note about the syntax:<br>&gt; <br>&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt; At the call site, it must appear at the end of the argument list.<br>&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt; Additional details will be introduced with a corresponding example.<br>&gt; <br>&gt; Omitting the placeholder identifier<br>&gt; <br>&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt; <br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...) {<br>&gt;     foo(i: 32, ...)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt; <br>&gt; Multiple forwarded parameter sets<br>&gt; <br>&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt; <br>&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;     foo2(...foo2Params)<br>&gt;     foo(i: 32, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt; Direct arguments<br>&gt; <br>&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt; <br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; func bar(...fooParams) {<br>&gt;     // error: `i` must precede `s` in the argument list<br>&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt; }<br>&gt; Multi-forwarding the same parameters<br>&gt; <br>&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt; <br>&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func baz(...fooBarParams) {<br>&gt;     foo(...fooBarParams)<br>&gt;     bar(...fooBarParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes: <br>&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d)<br>&gt;     bar(i: i, s: s, d: d)<br>&gt; }<br>&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt; <br>&gt; Unambiguous call<br>&gt; <br>&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt; <br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     // error: ambiguous use of foo<br>&gt;     // foo(i: 32, ...fooParams)<br>&gt;     <br>&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;     foo(b: true, ...fooParams)<br>&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;     foo(f: 24, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes: <br>&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt; }<br>&gt; Default values<br>&gt; <br>&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt; <br>&gt; We can modify the previous example to use the defualt values:<br>&gt; <br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;     foo(b: default, ...fooParams)<br>&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;     foo(f: default, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt; }<br>&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt; <br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(default..., ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(i i: Int, s: String) {<br>&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt; }<br>&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt; <br>&gt; Generic parameters<br>&gt; <br>&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt; <br>&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt; }<br>&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt; <br>&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;     (s: S, t: T) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(t: [42], ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;     foo(s: s, t: [42])<br>&gt; }<br>&gt; Syntheszied internal names<br>&gt; <br>&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt; <br>&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;     // do something with t<br>&gt;     foo(...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt; }<br>&gt; Detailed design<br>&gt; <br>&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt; <br>&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/9491b1c2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br></p><p>Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br></p><p>For example, most dynamic languages have the ability to pack arguments.  There has been discussion of adding tuple packing and unpacking to Swift but it wouldn’t offer everything it does in dynamic languages (as far as I can tell).<br></p><p>Swift is statically typed so we would have to specify a type for the tuple to pack / unpack.  This means it must be a fixed list of arguments.  This is not the case in dynamic languages, where whatever arguments the caller provides are forwarded.<br></p><p>Also, because the packed tuple parameter is declared manually, there would not be a way to forward a default argument value for specific members of the tuple as far as I can see (I think a default would need to be specified for the entire tuple, not just specific members).  Even if there were a way to specify a value for specific members, I don’t believe it would be possible to “forward” the default value specified by the receiving function, which is actually what is desired.  In dynamic languages, callers can just provide a subset of the tuple arguments and the receiving function detects missing arguments, filling in a default.<br></p><p>Another example is variadic generics in C++, which can also forward an arbitrary set of arguments to a receiving function.  This feature of C++ relies on the fact that the body of a template is not checked until it is expanded.  This allows the caller of the forwarding function to supply any set of parameters that would be valid when calling the forwardee.  <br></p><p>Even if Swift supported variadic generics I don’t think this method of forwarding fits the language as the body of a generic function is checked on its own.  I don’t believe there would be a way to specify constraints that would allow the arguments to be used to call the forwarding function (I may be wrong about that if a new kind of constraint was introduced to support this in the future).<br></p><p>The forwarding mechanism in this proposal supports a couple of things that I think will be quite useful which are not possible under the examples of tuple packing and unpacking in Swift that I have seen shared thus far:<br></p><p>1. Providing default values for specific parameters, not just a whole packed tuple<br>2. Forwarding default parameter values from the forwardee function for said parameters<br>3. Forwarding a subset of the forwarded’s parameters<br>4. Explicitly providing default values for disambiguation and to suppress forwarding of specific parameters where the callee provides a default value<br>5. Forwarding generic parameters<br></p><p>&gt; <br>&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br></p><p>Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br></p><p>More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br></p><p>Here’s an example that takes advantage of the combined power of the three proposals I just posted:<br></p><p>struct S {<br>  var name: String = “&quot;<br>  private let x, y, z: Int<br></p><p>  propertylist args: left x = 0, top y = 0, name<br></p><p>  init(…args) { z = 0 }<br>}<br></p><p>This does several things not possible in the current memberwise init proposal:<br></p><p>1. Supports an arbitrary subset of members<br>2. Supports an arbitrary order for memberwise parameters<br>3. Supports arbitrary labels for memberwise parameters<br>4. Supports arbitrary default values for parameters, including `let` properties<br>5. Allows more-private properties to be exposed by more-public initializer<br></p><p>Here’s how it works: <br></p><p>1. The `propertylist` declaration introduces a partial memberwise initializer corresponding to the properties specified (it also gives you a computed tuple property containing the specified properties).<br>2. The `…args` placeholder causes the primary initializer to forward arguments to the partial initializer introduced in step 1.<br></p><p>The equivalent manually written code would look like this (assuming partial initializers and omitting the  `args` tuple property that would be synthesized):<br></p><p>struct S {<br>  var name: String = “&quot;<br>  private let x, y, z: Int<br></p><p>  partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>    self.x = x<br>    self.y = y<br>    self.name = name<br>  }<br></p><p>  init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>    args.init(left: x, top: y, name: name)<br>    z = 0 <br>  }<br>}<br></p><p>These features work together to support the additional desired use cases for memberwise initialization while remaining concise and arguably more clear (because the property list explicitly states which members participate in the memberwise partial initializer).  <br></p><p>Because the features supporting this are general we also gain:<br></p><p>1. Forwarding in any function, not just initializers (but including concise forwarding of parameters to a super or member initializer, or forwarding from a convenience initializer that just needs to provide a few direct arguments to the designated initializer and forward the rest).<br>2. Partial initialization support for shared, but non-memberwise initialization logic<br>3. Computed tuple properties for each propertylist.  (and possibly additional memberwise features in the future if we identify any that would also be generally useful)<br></p><p>In my opinion this is a huge win for both initialization as well as other parts of our code that might take advantage of these features.<br></p><p>&gt; <br>&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br></p><p>It is a bit more work, sure.  It requires matching the explicitly provided arguments with the parameter list of any callee overloads that are in scope and determining whether: <br></p><p>1. There are no overloads for which the provided arguments could be part of a valid call.  Compiler error.<br>2. There is a single overload for which the provided arguments could be part of a valid call.  Forward the remaining arguments.<br>3. There are more than one overloads for which the provided arguments could be part of a valid call.  Compiler error due to ambiguity.<br></p><p>If we want a forwarding mechanism capable of forwarding default argument values, and possibly (but very desirable IMO) a subset of parameters there is no way to avoid this logic.  I am not an expert at the implementation of such features, but I don’t think it is excessively complex next to other logic implemented in the compiler.<br></p><p>&gt; <br>&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br></p><p>I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br></p><p>I hope you will consider discussing this further.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt; <br>&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt; <br>&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt; <br>&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; Parameter Forwarding<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt; <br>&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt; <br>&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt; <br>&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; Some things to note about the syntax:<br>&gt;&gt; <br>&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt; <br>&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt; <br>&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...) {<br>&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt; <br>&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt; <br>&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; Direct arguments<br>&gt;&gt; <br>&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt; <br>&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes: <br>&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt; }<br>&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt; <br>&gt;&gt; Unambiguous call<br>&gt;&gt; <br>&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;     <br>&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes: <br>&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt; }<br>&gt;&gt; Default values<br>&gt;&gt; <br>&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt; <br>&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt; }<br>&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt; }<br>&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt; <br>&gt;&gt; Generic parameters<br>&gt;&gt; <br>&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt; <br>&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt; }<br>&gt;&gt; Syntheszied internal names<br>&gt;&gt; <br>&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;     // do something with t<br>&gt;&gt;     foo(...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt; <br>&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/04677689/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>I can&#39;t get behind this feature. Beside the lack of payoff for added<br>syntax, the biggest problem is that this is mostly handled by default<br>values. If we had (once we get?) constant expressions, I imagine that we<br>might even be able to reference other parameters in default value method<br>calls–which seems like a more generally useful fix for the issue.<br></p><p>TJ<br></p><p>On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt; I was okay with memberwise initializers but this pushes me beyond my<br>&gt; comfort zone.<br>&gt;<br>&gt;<br>&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to<br>&gt; features in other languages that are generally considered to be quite<br>&gt; useful.<br>&gt;<br>&gt; For example, most dynamic languages have the ability to pack arguments.<br>&gt; There has been discussion of adding tuple packing and unpacking to Swift<br>&gt; but it wouldn’t offer everything it does in dynamic languages (as far as I<br>&gt; can tell).<br>&gt;<br>&gt; Swift is statically typed so we would have to specify a type for the tuple<br>&gt; to pack / unpack.  This means it must be a fixed list of arguments.  This<br>&gt; is not the case in dynamic languages, where whatever arguments the caller<br>&gt; provides are forwarded.<br>&gt;<br>&gt; Also, because the packed tuple parameter is declared manually, there would<br>&gt; not be a way to forward a default argument value for specific members of<br>&gt; the tuple as far as I can see (I think a default would need to be specified<br>&gt; for the entire tuple, not just specific members).  Even if there were a way<br>&gt; to specify a value for specific members, I don’t believe it would be<br>&gt; possible to “forward” the default value specified by the receiving<br>&gt; function, which is actually what is desired.  In dynamic languages, callers<br>&gt; can just provide a subset of the tuple arguments and the receiving function<br>&gt; detects missing arguments, filling in a default.<br>&gt;<br>&gt; Another example is variadic generics in C++, which can also forward an<br>&gt; arbitrary set of arguments to a receiving function.  This feature of C++<br>&gt; relies on the fact that the body of a template is not checked until it is<br>&gt; expanded.  This allows the caller of the forwarding function to supply any<br>&gt; set of parameters that would be valid when calling the forwardee.<br>&gt;<br>&gt; Even if Swift supported variadic generics I don’t think this method of<br>&gt; forwarding fits the language as the body of a generic function is checked<br>&gt; on its own.  I don’t believe there would be a way to specify constraints<br>&gt; that would allow the arguments to be used to call the forwarding function<br>&gt; (I may be wrong about that if a new kind of constraint was introduced to<br>&gt; support this in the future).<br>&gt;<br>&gt; The forwarding mechanism in this proposal supports a couple of things that<br>&gt; I think will be quite useful which are not possible under the examples of<br>&gt; tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;<br>&gt; 1. Providing default values for specific parameters, not just a whole<br>&gt; packed tuple<br>&gt; 2. Forwarding default parameter values from the forwardee function for<br>&gt; said parameters<br>&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt; 4. Explicitly providing default values for disambiguation and to suppress<br>&gt; forwarding of specific parameters where the callee provides a default value<br>&gt; 5. Forwarding generic parameters<br>&gt;<br>&gt;<br>&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers<br>&gt; save you from typing out the init parameters and assignments to each field.<br>&gt; Argument forwarding saves you from spelling out the parameters *more than<br>&gt; once* (because you still need to type them out for the receiving function)<br>&gt; and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think<br>&gt; I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;<br>&gt;<br>&gt; Both features save approximately the same amount of code.  They save<br>&gt; explicit declaration of parameters as well as a single action with the<br>&gt; provided argument.<br>&gt;<br>&gt; More importantly, forwarding is a general purpose feature that when<br>&gt; combined with partial initializers and property lists can support much more<br>&gt; expressive memberwise initialization than contained in the initial<br>&gt; proposal.  There was quite a bit of discussion about both the limitations<br>&gt; of the memberwise initialization proposal as well as the specificity of it<br>&gt; to exactly one use case (memberwise initialization).  Forwarding plays a<br>&gt; role in removing the limitations while building on a more general<br>&gt; foundation.<br>&gt;<br>&gt; Here’s an example that takes advantage of the combined power of the three<br>&gt; proposals I just posted:<br>&gt;<br>&gt; struct S {<br>&gt;   var name: String = “&quot;<br>&gt;   private let x, y, z: Int<br>&gt;<br>&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;<br>&gt;   init(…args) { z = 0 }<br>&gt; }<br>&gt;<br>&gt; This does several things not possible in the current memberwise init<br>&gt; proposal:<br>&gt;<br>&gt; 1. Supports an arbitrary subset of members<br>&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt; 4. Supports arbitrary default values for parameters, including `let`<br>&gt; properties<br>&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt;<br>&gt; Here’s how it works:<br>&gt;<br>&gt; 1. The `propertylist` declaration introduces a partial memberwise<br>&gt; initializer corresponding to the properties specified (it also gives you a<br>&gt; computed tuple property containing the specified properties).<br>&gt; 2. The `…args` placeholder causes the primary initializer to forward<br>&gt; arguments to the partial initializer introduced in step 1.<br>&gt;<br>&gt; The equivalent manually written code would look like this (assuming<br>&gt; partial initializers and omitting the  `args` tuple property that would be<br>&gt; synthesized):<br>&gt;<br>&gt; struct S {<br>&gt;   var name: String = “&quot;<br>&gt;   private let x, y, z: Int<br>&gt;<br>&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;     self.x = x<br>&gt;     self.y = y<br>&gt;     self.name = name<br>&gt;   }<br>&gt;<br>&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;     args.init(left: x, top: y, name: name)<br>&gt;     z = 0<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; These features work together to support the additional desired use cases<br>&gt; for memberwise initialization while remaining concise and arguably more<br>&gt; clear (because the property list explicitly states which members<br>&gt; participate in the memberwise partial initializer).<br>&gt;<br>&gt; Because the features supporting this are general we also gain:<br>&gt;<br>&gt; 1. Forwarding in any function, not just initializers (but including<br>&gt; concise forwarding of parameters to a super or member initializer, or<br>&gt; forwarding from a convenience initializer that just needs to provide a few<br>&gt; direct arguments to the designated initializer and forward the rest).<br>&gt; 2. Partial initialization support for shared, but non-memberwise<br>&gt; initialization logic<br>&gt; 3. Computed tuple properties for each propertylist.  (and possibly<br>&gt; additional memberwise features in the future if we identify any that would<br>&gt; also be generally useful)<br>&gt;<br>&gt; In my opinion this is a huge win for both initialization as well as other<br>&gt; parts of our code that might take advantage of these features.<br>&gt;<br>&gt;<br>&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not,<br>&gt; but if I allow myself to speak outside of my expertise, I imagine that it&#39;s<br>&gt; gonna be a lot more work than memberwise initializers because this requires<br>&gt; inspecting the function body to figure out its parameters.<br>&gt;<br>&gt;<br>&gt; It is a bit more work, sure.  It requires matching the explicitly provided<br>&gt; arguments with the parameter list of any callee overloads that are in scope<br>&gt; and determining whether:<br>&gt;<br>&gt; 1. There are no overloads for which the provided arguments could be part<br>&gt; of a valid call.  Compiler error.<br>&gt; 2. There is a single overload for which the provided arguments could be<br>&gt; part of a valid call.  Forward the remaining arguments.<br>&gt; 3. There are more than one overloads for which the provided arguments<br>&gt; could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;<br>&gt; If we want a forwarding mechanism capable of forwarding default argument<br>&gt; values, and possibly (but very desirable IMO) a subset of parameters there<br>&gt; is no way to avoid this logic.  I am not an expert at the implementation of<br>&gt; such features, but I don’t think it is excessively complex next to other<br>&gt; logic implemented in the compiler.<br>&gt;<br>&gt;<br>&gt; At this point, I feel that a competent macro system is a better investment<br>&gt; than adding distinct bits of automation wherever there appears to be<br>&gt; repetition.<br>&gt;<br>&gt;<br>&gt; I agree that a macro system would be great, but it is explicitly not in<br>&gt; scope for Swift 3.  It would also not be capable of implementing parameter<br>&gt; forwarding as described in this proposal.<br>&gt;<br>&gt; I hope you will consider discussing this further.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I have always considered the Flexible Memberwise Initialization proposal<br>&gt; to be just a first step (as evidenced by the many future enhancements it<br>&gt; discussed).  Its review has inspired new ideas and helped to shape my<br>&gt; vision of the best long-term solution.  My final thoughts about the review<br>&gt; can be found here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br>&gt;<br>&gt; Parameter forwarding is the first in a series of three proposals<br>&gt; describing general features that can work together to form a complete<br>&gt; solution.<br>&gt;<br>&gt; The proposal drafts can be found at the following links:<br>&gt;<br>&gt; * *Parameter forwarding:*<br>&gt; https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>&gt; * *Partial initializers:*<br>&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>&gt; * *Property lists:*<br>&gt; https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br>&gt;<br>&gt; Matthew<br>&gt; Parameter Forwarding<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;    - Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;<br>&gt; Swift-evolution thread: Proposal Draft: parameter forwarding<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt; Motivation<br>&gt;<br>&gt; There are many cases where a function declares parameters simply for the<br>&gt; purpose of forwarding the provided arguments to another function. This<br>&gt; results in reduntant parameter specifications that make code less clear and<br>&gt; less readable by obscuring the simple forwarding that is actually happening.<br>&gt;<br>&gt; This feature will be especially useful in initializers such as:<br>&gt;<br>&gt;    - Convenience initializers that foward parameters directly to a<br>&gt;    designated initializer<br>&gt;    - Designated initializers that foward parameters directly to a super<br>&gt;    initializer<br>&gt;    - Designated initializers that foward parameters directly to a member<br>&gt;    initializer, perhaps in a composition-based design<br>&gt;    - If the partial initilaizer proposal is accepted, designated<br>&gt;    initializers that forward parameters to one or more partial initializers<br>&gt;<br>&gt; NOTE: I haven’t had time to think too much aboue use cases beyond<br>&gt; initialization. Please share examples and I will add them to this proposal.<br>&gt; Proposed solution<br>&gt;<br>&gt; The proposed solution is to introduce an automatic parameter forwarding<br>&gt; mechansim. It allows users to provide direct arguments for some parameters<br>&gt; while forwarding others.<br>&gt;<br>&gt; The basic mechanism looks like this:<br>&gt;<br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     foo(i: 32, ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; Some things to note about the syntax:<br>&gt;<br>&gt;    1. ...fooParams is a placeholder introduced with ... and followed by<br>&gt;    an identifier.<br>&gt;    2. In the signature it can be placed anywhere in the parameter list.<br>&gt;    3. At the call site, it must appear at the end of the argument list.<br>&gt;    4. The placeholder matches the parameters not directly provided<br>&gt;    including their external label and default value if those exist.<br>&gt;    5. Parameters corresponding to the matched parameters are synthesized<br>&gt;    by the compiler where the placeholder exists in the parameter list,<br>&gt;    including the default argument if one exists.<br>&gt;    6. The identifier portion of the placeholder may be omitted if only<br>&gt;    one set of forwarded parameters exist within the function.<br>&gt;<br>&gt; Additional details will be introduced with a corresponding example.<br>&gt; Omitting the placeholder identifier<br>&gt;<br>&gt; The above example can be written more concisely by omitting the<br>&gt; placeholder identifier.<br>&gt;<br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar(...) {<br>&gt;     foo(i: 32, ...)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; NOTE: If the community feels strongly that the identifier should be<br>&gt; required I am willing to do so.<br>&gt; Multiple forwarded parameter sets<br>&gt;<br>&gt; It is possible for a single function to forward more than one set of<br>&gt; parameters:<br>&gt;<br>&gt; func foo(i i: Int, s: String, f: Float = 42) { }func foo2(d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar(...fooParams, ...foo2Params) {<br>&gt;     foo2(...foo2Params)<br>&gt;     foo(i: 32, ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; Direct arguments<br>&gt;<br>&gt; Any direct arguments provided in the forwarding call must follow the usual<br>&gt; argument ordering rules, with the only exception being that it is allowed<br>&gt; to omit some arguments that would normally be required. When the compiler<br>&gt; performs forwarding it will insert forwarded arguments in the correct<br>&gt; location.<br>&gt;<br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; func bar(...fooParams) {<br>&gt;     // error: `i` must precede `s` in the argument list<br>&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt; }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; Multi-forwarding the same parameters<br>&gt;<br>&gt; It is allowed to use the same identifier in multiple forwarding calls as<br>&gt; long as the signature of the matched parameters matches exactly, including<br>&gt; any default values.<br>&gt;<br>&gt; func foo(i i: Int, s: String, d: Double = 43) { }func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt; // user writes:func baz(...fooBarParams) {<br>&gt;     foo(...fooBarParams)<br>&gt;     bar(...fooBarParams)<br>&gt; }<br>&gt; // compiler synthesizes: func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d)<br>&gt;     bar(i: i, s: s, d: d)<br>&gt; }<br>&gt;<br>&gt; NOTE: This provision might be controversial. If the community doesn’t like<br>&gt; it or the implementation is too complex I will remove it.<br>&gt; Unambiguous call<br>&gt;<br>&gt; When forwarding parameters to a function that is overloaded the caller<br>&gt; must provide enough direct arguments to make the call unambiguous.<br>&gt;<br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     // error: ambiguous use of foo<br>&gt;     // foo(i: 32, ...fooParams)<br>&gt;<br>&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;     foo(b: true, ...fooParams)<br>&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;     foo(f: 24, ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes: func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt; }<br>&gt;<br>&gt; Default values<br>&gt;<br>&gt; When forwarding to a function that accepts default values it is possible<br>&gt; to explicitly request the default value. This allows for disambiguation and<br>&gt; also allows the forwarding function to suppress a defaulted parameter from<br>&gt; participating in forwarding without needing to supply a specific value. The<br>&gt; default keyword is used to do this.<br>&gt;<br>&gt; We can modify the previous example to use the defualt values:<br>&gt;<br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;     foo(b: default, ...fooParams)<br>&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;     foo(f: default, ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt; }<br>&gt;<br>&gt; It is also possible to explicitly request all defaults at once using<br>&gt; default.... In this example, foois not overloaded:<br>&gt;<br>&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     foo(default..., ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar(i i: Int, s: String) {<br>&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt; }<br>&gt;<br>&gt; NOTE: The actual implementation of default arguments looks somewhat<br>&gt; different. These examples are intended to communicate the behavior, not the<br>&gt; exact details of implementation.<br>&gt; Generic parameters<br>&gt;<br>&gt; If the types of any matched parameters reference any generic type<br>&gt; parameters of the forwardee the generic type parameters must also be<br>&gt; forwarded, along with any constraints on those generic parameters.<br>&gt;<br>&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     foo(...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; If a generic parameter is referenced in a constraint that also references<br>&gt; a generic parameter that will not be forwarded the constraint is resolved<br>&gt; to a concrete type when possible. This may not be possible in all cases.<br>&gt; When it is not possible a compiler error will be necessary.<br>&gt;<br>&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;     (s: S, t: T) { }<br>&gt; // user writes:func bar(...fooParams) {<br>&gt;     foo(t: [42], ...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;     foo(s: s, t: [42])<br>&gt; }<br>&gt;<br>&gt; Syntheszied internal names<br>&gt;<br>&gt; The compiler must ensure that all synthesized parameters have internal<br>&gt; names that do not conflict with the internal names of any manually declared<br>&gt; parameters. This applies to both generic type parameter names as well as<br>&gt; value arguments in the parameter list of the function.<br>&gt;<br>&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt; // user writes:func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;     // do something with t<br>&gt;     foo(...fooParams)<br>&gt; }<br>&gt; // compiler synthesizes:func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt; }<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt; Alternatives considered<br>&gt;<br>&gt; I believe the forwarding mechanism itself is pretty straightforward and<br>&gt; any alternatives would be lose functionality without good reason.<br>&gt;<br>&gt; The placeholder syntax is of course fair game for bikeshedding. I consider<br>&gt; anything reasonably clear and concise to be acceptable.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/2f7191bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added syntax, the biggest problem is that this is mostly handled by default values. If we had (once we get?) constant expressions, I imagine that we might even be able to reference other parameters in default value method calls–which seems like a more generally useful fix for the issue.<br></p><p>How is this handled by default values?  What you’re saying doesn’t make sense to me.  Can you provide an example of what you have in mind?<br></p><p>Have you used a language with a similar feature?  Did you not find it useful?<br></p><p>Matthew<br></p><p>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt; <br>&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt; <br>&gt; For example, most dynamic languages have the ability to pack arguments.  There has been discussion of adding tuple packing and unpacking to Swift but it wouldn’t offer everything it does in dynamic languages (as far as I can tell).<br>&gt; <br>&gt; Swift is statically typed so we would have to specify a type for the tuple to pack / unpack.  This means it must be a fixed list of arguments.  This is not the case in dynamic languages, where whatever arguments the caller provides are forwarded.<br>&gt; <br>&gt; Also, because the packed tuple parameter is declared manually, there would not be a way to forward a default argument value for specific members of the tuple as far as I can see (I think a default would need to be specified for the entire tuple, not just specific members).  Even if there were a way to specify a value for specific members, I don’t believe it would be possible to “forward” the default value specified by the receiving function, which is actually what is desired.  In dynamic languages, callers can just provide a subset of the tuple arguments and the receiving function detects missing arguments, filling in a default.<br>&gt; <br>&gt; Another example is variadic generics in C++, which can also forward an arbitrary set of arguments to a receiving function.  This feature of C++ relies on the fact that the body of a template is not checked until it is expanded.  This allows the caller of the forwarding function to supply any set of parameters that would be valid when calling the forwardee.  <br>&gt; <br>&gt; Even if Swift supported variadic generics I don’t think this method of forwarding fits the language as the body of a generic function is checked on its own.  I don’t believe there would be a way to specify constraints that would allow the arguments to be used to call the forwarding function (I may be wrong about that if a new kind of constraint was introduced to support this in the future).<br>&gt; <br>&gt; The forwarding mechanism in this proposal supports a couple of things that I think will be quite useful which are not possible under the examples of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt; <br>&gt; 1. Providing default values for specific parameters, not just a whole packed tuple<br>&gt; 2. Forwarding default parameter values from the forwardee function for said parameters<br>&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt; 4. Explicitly providing default values for disambiguation and to suppress forwarding of specific parameters where the callee provides a default value<br>&gt; 5. Forwarding generic parameters<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt; <br>&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br>&gt; <br>&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br>&gt; <br>&gt; Here’s an example that takes advantage of the combined power of the three proposals I just posted:<br>&gt; <br>&gt; struct S {<br>&gt;   var name: String = “&quot;<br>&gt;   private let x, y, z: Int<br>&gt; <br>&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt; <br>&gt;   init(…args) { z = 0 }<br>&gt; }<br>&gt; <br>&gt; This does several things not possible in the current memberwise init proposal:<br>&gt; <br>&gt; 1. Supports an arbitrary subset of members<br>&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt; 4. Supports arbitrary default values for parameters, including `let` properties<br>&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt; <br>&gt; Here’s how it works: <br>&gt; <br>&gt; 1. The `propertylist` declaration introduces a partial memberwise initializer corresponding to the properties specified (it also gives you a computed tuple property containing the specified properties).<br>&gt; 2. The `…args` placeholder causes the primary initializer to forward arguments to the partial initializer introduced in step 1.<br>&gt; <br>&gt; The equivalent manually written code would look like this (assuming partial initializers and omitting the  `args` tuple property that would be synthesized):<br>&gt; <br>&gt; struct S {<br>&gt;   var name: String = “&quot;<br>&gt;   private let x, y, z: Int<br>&gt; <br>&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;     self.x = x<br>&gt;     self.y = y<br>&gt;     self.name &lt;http://self.name/&gt; = name<br>&gt;   }<br>&gt; <br>&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;     args.init(left: x, top: y, name: name)<br>&gt;     z = 0 <br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; These features work together to support the additional desired use cases for memberwise initialization while remaining concise and arguably more clear (because the property list explicitly states which members participate in the memberwise partial initializer).  <br>&gt; <br>&gt; Because the features supporting this are general we also gain:<br>&gt; <br>&gt; 1. Forwarding in any function, not just initializers (but including concise forwarding of parameters to a super or member initializer, or forwarding from a convenience initializer that just needs to provide a few direct arguments to the designated initializer and forward the rest).<br>&gt; 2. Partial initialization support for shared, but non-memberwise initialization logic<br>&gt; 3. Computed tuple properties for each propertylist.  (and possibly additional memberwise features in the future if we identify any that would also be generally useful)<br>&gt; <br>&gt; In my opinion this is a huge win for both initialization as well as other parts of our code that might take advantage of these features.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br>&gt; <br>&gt; It is a bit more work, sure.  It requires matching the explicitly provided arguments with the parameter list of any callee overloads that are in scope and determining whether: <br>&gt; <br>&gt; 1. There are no overloads for which the provided arguments could be part of a valid call.  Compiler error.<br>&gt; 2. There is a single overload for which the provided arguments could be part of a valid call.  Forward the remaining arguments.<br>&gt; 3. There are more than one overloads for which the provided arguments could be part of a valid call.  Compiler error due to ambiguity.<br>&gt; <br>&gt; If we want a forwarding mechanism capable of forwarding default argument values, and possibly (but very desirable IMO) a subset of parameters there is no way to avoid this logic.  I am not an expert at the implementation of such features, but I don’t think it is excessively complex next to other logic implemented in the compiler.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt; <br>&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt; <br>&gt; I hope you will consider discussing this further.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Default values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/2b897706/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>func _computeLastParam() -&gt; String {<br></p><p>    return &quot;I am the last of my line&quot;<br></p><p>}<br></p><p><br>func foo(first: Int, second: String, last: String = _computeLastParam()) {<br></p><p>    print(&quot;first:\(first)&quot;)<br></p><p>    print(&quot;second:\(second)&quot;)<br></p><p>    print(&quot;last:\(last)&quot;)<br></p><p>}<br></p><p><br>foo(1, second: &quot;two!&quot;)<br></p><p><br>&quot;<br></p><p>*first:1*<br></p><p>*second:two!*<br></p><p>*last:I am the last of my line*<br></p><p>&quot;<br></p><p><br></p><p>// hopefully?<br></p><p><br>constexpr func _computeLastParam(input: Int) -&gt; String {<br></p><p>    return &quot;I am the last of my line and you gave me \(input)&quot;<br></p><p>}<br></p><p><br>func foo(first: Int, second: String, last: String =<br>_computeLastParam(first)) {<br></p><p>    print(&quot;first:\(first)&quot;)<br></p><p>    print(&quot;second:\(second)&quot;)<br></p><p>    print(&quot;last:\(last)&quot;)<br></p><p>}<br></p><p><br>foo(1, second: &quot;two!&quot;)<br></p><p><br>&quot;<br></p><p>*first:1*<br></p><p>*second:two!*<br></p><p>*last:I am the last of my line and you gave me 1*<br></p><p>&quot;<br></p><p><br>On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added<br>&gt; syntax, the biggest problem is that this is mostly handled by default<br>&gt; values. If we had (once we get?) constant expressions, I imagine that we<br>&gt; might even be able to reference other parameters in default value method<br>&gt; calls–which seems like a more generally useful fix for the issue.<br>&gt;<br>&gt;<br>&gt; How is this handled by default values?  What you’re saying doesn’t make<br>&gt; sense to me.  Can you provide an example of what you have in mind?<br>&gt;<br>&gt; Have you used a language with a similar feature?  Did you not find it<br>&gt; useful?<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my<br>&gt;&gt; comfort zone.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to<br>&gt;&gt; features in other languages that are generally considered to be quite<br>&gt;&gt; useful.<br>&gt;&gt;<br>&gt;&gt; For example, most dynamic languages have the ability to pack arguments.<br>&gt;&gt; There has been discussion of adding tuple packing and unpacking to Swift<br>&gt;&gt; but it wouldn’t offer everything it does in dynamic languages (as far as I<br>&gt;&gt; can tell).<br>&gt;&gt;<br>&gt;&gt; Swift is statically typed so we would have to specify a type for the<br>&gt;&gt; tuple to pack / unpack.  This means it must be a fixed list of arguments.<br>&gt;&gt; This is not the case in dynamic languages, where whatever arguments the<br>&gt;&gt; caller provides are forwarded.<br>&gt;&gt;<br>&gt;&gt; Also, because the packed tuple parameter is declared manually, there<br>&gt;&gt; would not be a way to forward a default argument value for specific members<br>&gt;&gt; of the tuple as far as I can see (I think a default would need to be<br>&gt;&gt; specified for the entire tuple, not just specific members).  Even if there<br>&gt;&gt; were a way to specify a value for specific members, I don’t believe it<br>&gt;&gt; would be possible to “forward” the default value specified by the receiving<br>&gt;&gt; function, which is actually what is desired.  In dynamic languages, callers<br>&gt;&gt; can just provide a subset of the tuple arguments and the receiving function<br>&gt;&gt; detects missing arguments, filling in a default.<br>&gt;&gt;<br>&gt;&gt; Another example is variadic generics in C++, which can also forward an<br>&gt;&gt; arbitrary set of arguments to a receiving function.  This feature of C++<br>&gt;&gt; relies on the fact that the body of a template is not checked until it is<br>&gt;&gt; expanded.  This allows the caller of the forwarding function to supply any<br>&gt;&gt; set of parameters that would be valid when calling the forwardee.<br>&gt;&gt;<br>&gt;&gt; Even if Swift supported variadic generics I don’t think this method of<br>&gt;&gt; forwarding fits the language as the body of a generic function is checked<br>&gt;&gt; on its own.  I don’t believe there would be a way to specify constraints<br>&gt;&gt; that would allow the arguments to be used to call the forwarding function<br>&gt;&gt; (I may be wrong about that if a new kind of constraint was introduced to<br>&gt;&gt; support this in the future).<br>&gt;&gt;<br>&gt;&gt; The forwarding mechanism in this proposal supports a couple of things<br>&gt;&gt; that I think will be quite useful which are not possible under the examples<br>&gt;&gt; of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt;<br>&gt;&gt; 1. Providing default values for specific parameters, not just a whole<br>&gt;&gt; packed tuple<br>&gt;&gt; 2. Forwarding default parameter values from the forwardee function for<br>&gt;&gt; said parameters<br>&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt; 4. Explicitly providing default values for disambiguation and to suppress<br>&gt;&gt; forwarding of specific parameters where the callee provides a default value<br>&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers<br>&gt;&gt; save you from typing out the init parameters and assignments to each field.<br>&gt;&gt; Argument forwarding saves you from spelling out the parameters *more than<br>&gt;&gt; once* (because you still need to type them out for the receiving function)<br>&gt;&gt; and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think<br>&gt;&gt; I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Both features save approximately the same amount of code.  They save<br>&gt;&gt; explicit declaration of parameters as well as a single action with the<br>&gt;&gt; provided argument.<br>&gt;&gt;<br>&gt;&gt; More importantly, forwarding is a general purpose feature that when<br>&gt;&gt; combined with partial initializers and property lists can support much more<br>&gt;&gt; expressive memberwise initialization than contained in the initial<br>&gt;&gt; proposal.  There was quite a bit of discussion about both the limitations<br>&gt;&gt; of the memberwise initialization proposal as well as the specificity of it<br>&gt;&gt; to exactly one use case (memberwise initialization).  Forwarding plays a<br>&gt;&gt; role in removing the limitations while building on a more general<br>&gt;&gt; foundation.<br>&gt;&gt;<br>&gt;&gt; Here’s an example that takes advantage of the combined power of the three<br>&gt;&gt; proposals I just posted:<br>&gt;&gt;<br>&gt;&gt; struct S {<br>&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;<br>&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt;<br>&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This does several things not possible in the current memberwise init<br>&gt;&gt; proposal:<br>&gt;&gt;<br>&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt; 4. Supports arbitrary default values for parameters, including `let`<br>&gt;&gt; properties<br>&gt;&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt;&gt;<br>&gt;&gt; Here’s how it works:<br>&gt;&gt;<br>&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise<br>&gt;&gt; initializer corresponding to the properties specified (it also gives you a<br>&gt;&gt; computed tuple property containing the specified properties).<br>&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward<br>&gt;&gt; arguments to the partial initializer introduced in step 1.<br>&gt;&gt;<br>&gt;&gt; The equivalent manually written code would look like this (assuming<br>&gt;&gt; partial initializers and omitting the  `args` tuple property that would be<br>&gt;&gt; synthesized):<br>&gt;&gt;<br>&gt;&gt; struct S {<br>&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;<br>&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;     self.x = x<br>&gt;&gt;     self.y = y<br>&gt;&gt;     self.name = name<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;     z = 0<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; These features work together to support the additional desired use cases<br>&gt;&gt; for memberwise initialization while remaining concise and arguably more<br>&gt;&gt; clear (because the property list explicitly states which members<br>&gt;&gt; participate in the memberwise partial initializer).<br>&gt;&gt;<br>&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt;<br>&gt;&gt; 1. Forwarding in any function, not just initializers (but including<br>&gt;&gt; concise forwarding of parameters to a super or member initializer, or<br>&gt;&gt; forwarding from a convenience initializer that just needs to provide a few<br>&gt;&gt; direct arguments to the designated initializer and forward the rest).<br>&gt;&gt; 2. Partial initialization support for shared, but non-memberwise<br>&gt;&gt; initialization logic<br>&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly<br>&gt;&gt; additional memberwise features in the future if we identify any that would<br>&gt;&gt; also be generally useful)<br>&gt;&gt;<br>&gt;&gt; In my opinion this is a huge win for both initialization as well as other<br>&gt;&gt; parts of our code that might take advantage of these features.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not,<br>&gt;&gt; but if I allow myself to speak outside of my expertise, I imagine that it&#39;s<br>&gt;&gt; gonna be a lot more work than memberwise initializers because this requires<br>&gt;&gt; inspecting the function body to figure out its parameters.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly<br>&gt;&gt; provided arguments with the parameter list of any callee overloads that are<br>&gt;&gt; in scope and determining whether:<br>&gt;&gt;<br>&gt;&gt; 1. There are no overloads for which the provided arguments could be part<br>&gt;&gt; of a valid call.  Compiler error.<br>&gt;&gt; 2. There is a single overload for which the provided arguments could be<br>&gt;&gt; part of a valid call.  Forward the remaining arguments.<br>&gt;&gt; 3. There are more than one overloads for which the provided arguments<br>&gt;&gt; could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt;<br>&gt;&gt; If we want a forwarding mechanism capable of forwarding default argument<br>&gt;&gt; values, and possibly (but very desirable IMO) a subset of parameters there<br>&gt;&gt; is no way to avoid this logic.  I am not an expert at the implementation of<br>&gt;&gt; such features, but I don’t think it is excessively complex next to other<br>&gt;&gt; logic implemented in the compiler.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; At this point, I feel that a competent macro system is a better<br>&gt;&gt; investment than adding distinct bits of automation wherever there appears<br>&gt;&gt; to be repetition.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree that a macro system would be great, but it is explicitly not in<br>&gt;&gt; scope for Swift 3.  It would also not be capable of implementing parameter<br>&gt;&gt; forwarding as described in this proposal.<br>&gt;&gt;<br>&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal<br>&gt;&gt; to be just a first step (as evidenced by the many future enhancements it<br>&gt;&gt; discussed).  Its review has inspired new ideas and helped to shape my<br>&gt;&gt; vision of the best long-term solution.  My final thoughts about the review<br>&gt;&gt; can be found here:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br>&gt;&gt;<br>&gt;&gt; Parameter forwarding is the first in a series of three proposals<br>&gt;&gt; describing general features that can work together to form a complete<br>&gt;&gt; solution.<br>&gt;&gt;<br>&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;<br>&gt;&gt; * *Parameter forwarding:*<br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>&gt;&gt; * *Partial initializers:*<br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>&gt;&gt; * *Property lists:*<br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt; Parameter Forwarding<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;    - Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; There are many cases where a function declares parameters simply for the<br>&gt;&gt; purpose of forwarding the provided arguments to another function. This<br>&gt;&gt; results in reduntant parameter specifications that make code less clear and<br>&gt;&gt; less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;<br>&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;<br>&gt;&gt;    - Convenience initializers that foward parameters directly to a<br>&gt;&gt;    designated initializer<br>&gt;&gt;    - Designated initializers that foward parameters directly to a super<br>&gt;&gt;    initializer<br>&gt;&gt;    - Designated initializers that foward parameters directly to a member<br>&gt;&gt;    initializer, perhaps in a composition-based design<br>&gt;&gt;    - If the partial initilaizer proposal is accepted, designated<br>&gt;&gt;    initializers that forward parameters to one or more partial initializers<br>&gt;&gt;<br>&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond<br>&gt;&gt; initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding<br>&gt;&gt; mechansim. It allows users to provide direct arguments for some parameters<br>&gt;&gt; while forwarding others.<br>&gt;&gt;<br>&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;<br>&gt;&gt;    1. ...fooParams is a placeholder introduced with ... and followed by<br>&gt;&gt;    an identifier.<br>&gt;&gt;    2. In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;    3. At the call site, it must appear at the end of the argument list.<br>&gt;&gt;    4. The placeholder matches the parameters not directly provided<br>&gt;&gt;    including their external label and default value if those exist.<br>&gt;&gt;    5. Parameters corresponding to the matched parameters are synthesized<br>&gt;&gt;    by the compiler where the placeholder exists in the parameter list,<br>&gt;&gt;    including the default argument if one exists.<br>&gt;&gt;    6. The identifier portion of the placeholder may be omitted if only<br>&gt;&gt;    one set of forwarded parameters exist within the function.<br>&gt;&gt;<br>&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;<br>&gt;&gt; The above example can be written more concisely by omitting the<br>&gt;&gt; placeholder identifier.<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar(...) {<br>&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; NOTE: If the community feels strongly that the identifier should be<br>&gt;&gt; required I am willing to do so.<br>&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;<br>&gt;&gt; It is possible for a single function to forward more than one set of<br>&gt;&gt; parameters:<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Direct arguments<br>&gt;&gt;<br>&gt;&gt; Any direct arguments provided in the forwarding call must follow the<br>&gt;&gt; usual argument ordering rules, with the only exception being that it is<br>&gt;&gt; allowed to omit some arguments that would normally be required. When the<br>&gt;&gt; compiler performs forwarding it will insert forwarded arguments in the<br>&gt;&gt; correct location.<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;<br>&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as<br>&gt;&gt; long as the signature of the matched parameters matches exactly, including<br>&gt;&gt; any default values.<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt; // user writes:func baz(...fooBarParams) {<br>&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes: func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t<br>&gt;&gt; like it or the implementation is too complex I will remove it.<br>&gt;&gt; Unambiguous call<br>&gt;&gt;<br>&gt;&gt; When forwarding parameters to a function that is overloaded the caller<br>&gt;&gt; must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;<br>&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes: func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Default values<br>&gt;&gt;<br>&gt;&gt; When forwarding to a function that accepts default values it is possible<br>&gt;&gt; to explicitly request the default value. This allows for disambiguation and<br>&gt;&gt; also allows the forwarding function to suppress a defaulted parameter from<br>&gt;&gt; participating in forwarding without needing to supply a specific value. The<br>&gt;&gt; default keyword is used to do this.<br>&gt;&gt;<br>&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It is also possible to explicitly request all defaults at once using<br>&gt;&gt; default.... In this example, foois not overloaded:<br>&gt;&gt;<br>&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String) {<br>&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat<br>&gt;&gt; different. These examples are intended to communicate the behavior, not the<br>&gt;&gt; exact details of implementation.<br>&gt;&gt; Generic parameters<br>&gt;&gt;<br>&gt;&gt; If the types of any matched parameters reference any generic type<br>&gt;&gt; parameters of the forwardee the generic type parameters must also be<br>&gt;&gt; forwarded, along with any constraints on those generic parameters.<br>&gt;&gt;<br>&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     foo(...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; If a generic parameter is referenced in a constraint that also references<br>&gt;&gt; a generic parameter that will not be forwarded the constraint is resolved<br>&gt;&gt; to a concrete type when possible. This may not be possible in all cases.<br>&gt;&gt; When it is not possible a compiler error will be necessary.<br>&gt;&gt;<br>&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Syntheszied internal names<br>&gt;&gt;<br>&gt;&gt; The compiler must ensure that all synthesized parameters have internal<br>&gt;&gt; names that do not conflict with the internal names of any manually declared<br>&gt;&gt; parameters. This applies to both generic type parameter names as well as<br>&gt;&gt; value arguments in the parameter list of the function.<br>&gt;&gt;<br>&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; // user writes:func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;     // do something with t<br>&gt;&gt;     foo(...fooParams)<br>&gt;&gt; }<br>&gt;&gt; // compiler synthesizes:func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and<br>&gt;&gt; any alternatives would be lose functionality without good reason.<br>&gt;&gt;<br>&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I<br>&gt;&gt; consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/bd33ae42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>This example doesn’t have anything to do with forwarding.  Do you have something in mind in the context of parameter forwarding?<br></p><p>Matthew<br></p><p>&gt; On Jan 11, 2016, at 10:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; func _computeLastParam() -&gt; String {<br>&gt;     return &quot;I am the last of my line&quot;<br>&gt; }<br>&gt; <br>&gt; func foo(first: Int, second: String, last: String = _computeLastParam()) {<br>&gt;     print(&quot;first:\(first)&quot;)<br>&gt;     print(&quot;second:\(second)&quot;)<br>&gt;     print(&quot;last:\(last)&quot;)<br>&gt; }<br>&gt; <br>&gt; foo(1, second: &quot;two!&quot;)<br>&gt; <br>&gt; &quot;<br>&gt; first:1<br>&gt; second:two!<br>&gt; last:I am the last of my line<br>&gt; &quot;<br>&gt; <br>&gt; <br>&gt; // hopefully?<br>&gt; <br>&gt; constexpr func _computeLastParam(input: Int) -&gt; String {<br>&gt;     return &quot;I am the last of my line and you gave me \(input)&quot;<br>&gt; }<br>&gt; <br>&gt; func foo(first: Int, second: String, last: String = _computeLastParam(first)) {<br>&gt;     print(&quot;first:\(first)&quot;)<br>&gt;     print(&quot;second:\(second)&quot;)<br>&gt;     print(&quot;last:\(last)&quot;)<br>&gt; }<br>&gt; <br>&gt; foo(1, second: &quot;two!&quot;)<br>&gt; <br>&gt; &quot;<br>&gt; first:1<br>&gt; second:two!<br>&gt; last:I am the last of my line and you gave me 1<br>&gt; &quot;<br>&gt; <br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added syntax, the biggest problem is that this is mostly handled by default values. If we had (once we get?) constant expressions, I imagine that we might even be able to reference other parameters in default value method calls–which seems like a more generally useful fix for the issue.<br>&gt; <br>&gt; How is this handled by default values?  What you’re saying doesn’t make sense to me.  Can you provide an example of what you have in mind?<br>&gt; <br>&gt; Have you used a language with a similar feature?  Did you not find it useful?<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt;&gt; <br>&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt;&gt; <br>&gt;&gt; For example, most dynamic languages have the ability to pack arguments.  There has been discussion of adding tuple packing and unpacking to Swift but it wouldn’t offer everything it does in dynamic languages (as far as I can tell).<br>&gt;&gt; <br>&gt;&gt; Swift is statically typed so we would have to specify a type for the tuple to pack / unpack.  This means it must be a fixed list of arguments.  This is not the case in dynamic languages, where whatever arguments the caller provides are forwarded.<br>&gt;&gt; <br>&gt;&gt; Also, because the packed tuple parameter is declared manually, there would not be a way to forward a default argument value for specific members of the tuple as far as I can see (I think a default would need to be specified for the entire tuple, not just specific members).  Even if there were a way to specify a value for specific members, I don’t believe it would be possible to “forward” the default value specified by the receiving function, which is actually what is desired.  In dynamic languages, callers can just provide a subset of the tuple arguments and the receiving function detects missing arguments, filling in a default.<br>&gt;&gt; <br>&gt;&gt; Another example is variadic generics in C++, which can also forward an arbitrary set of arguments to a receiving function.  This feature of C++ relies on the fact that the body of a template is not checked until it is expanded.  This allows the caller of the forwarding function to supply any set of parameters that would be valid when calling the forwardee.  <br>&gt;&gt; <br>&gt;&gt; Even if Swift supported variadic generics I don’t think this method of forwarding fits the language as the body of a generic function is checked on its own.  I don’t believe there would be a way to specify constraints that would allow the arguments to be used to call the forwarding function (I may be wrong about that if a new kind of constraint was introduced to support this in the future).<br>&gt;&gt; <br>&gt;&gt; The forwarding mechanism in this proposal supports a couple of things that I think will be quite useful which are not possible under the examples of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt; <br>&gt;&gt; 1. Providing default values for specific parameters, not just a whole packed tuple<br>&gt;&gt; 2. Forwarding default parameter values from the forwardee function for said parameters<br>&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt; 4. Explicitly providing default values for disambiguation and to suppress forwarding of specific parameters where the callee provides a default value<br>&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt; <br>&gt;&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br>&gt;&gt; <br>&gt;&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br>&gt;&gt; <br>&gt;&gt; Here’s an example that takes advantage of the combined power of the three proposals I just posted:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;   private let x, y, z: Int<br>&gt;&gt; <br>&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt; <br>&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This does several things not possible in the current memberwise init proposal:<br>&gt;&gt; <br>&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt; 4. Supports arbitrary default values for parameters, including `let` properties<br>&gt;&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt;&gt; <br>&gt;&gt; Here’s how it works: <br>&gt;&gt; <br>&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise initializer corresponding to the properties specified (it also gives you a computed tuple property containing the specified properties).<br>&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward arguments to the partial initializer introduced in step 1.<br>&gt;&gt; <br>&gt;&gt; The equivalent manually written code would look like this (assuming partial initializers and omitting the  `args` tuple property that would be synthesized):<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;   private let x, y, z: Int<br>&gt;&gt; <br>&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;     self.x = x<br>&gt;&gt;     self.y = y<br>&gt;&gt;     self.name &lt;http://self.name/&gt; = name<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;     z = 0 <br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; These features work together to support the additional desired use cases for memberwise initialization while remaining concise and arguably more clear (because the property list explicitly states which members participate in the memberwise partial initializer).  <br>&gt;&gt; <br>&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt; <br>&gt;&gt; 1. Forwarding in any function, not just initializers (but including concise forwarding of parameters to a super or member initializer, or forwarding from a convenience initializer that just needs to provide a few direct arguments to the designated initializer and forward the rest).<br>&gt;&gt; 2. Partial initialization support for shared, but non-memberwise initialization logic<br>&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly additional memberwise features in the future if we identify any that would also be generally useful)<br>&gt;&gt; <br>&gt;&gt; In my opinion this is a huge win for both initialization as well as other parts of our code that might take advantage of these features.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br>&gt;&gt; <br>&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly provided arguments with the parameter list of any callee overloads that are in scope and determining whether: <br>&gt;&gt; <br>&gt;&gt; 1. There are no overloads for which the provided arguments could be part of a valid call.  Compiler error.<br>&gt;&gt; 2. There is a single overload for which the provided arguments could be part of a valid call.  Forward the remaining arguments.<br>&gt;&gt; 3. There are more than one overloads for which the provided arguments could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt; <br>&gt;&gt; If we want a forwarding mechanism capable of forwarding default argument values, and possibly (but very desirable IMO) a subset of parameters there is no way to avoid this logic.  I am not an expert at the implementation of such features, but I don’t think it is excessively complex next to other logic implemented in the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt;&gt; <br>&gt;&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt;&gt; <br>&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/2a5c3c76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>The last bit might not but default values have *everything* to do with<br>parameter forwarding. What do default values afford us in our API?<br></p><p>foo()<br>foo(first: Int)<br>foo(first: Int, second: String)<br></p><p>with &#39;one&#39; implementation.<br></p><p>What does parameter forwarding get us?<br></p><p>foo()<br>foo(first: Int)<br>foo(first: Int, second: String)<br></p><p>with &#39;one&#39; implementation (but maybe in reverse?)<br></p><p><br>On Mon, Jan 11, 2016 at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; This example doesn’t have anything to do with forwarding.  Do you have<br>&gt; something in mind in the context of parameter forwarding?<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; On Jan 11, 2016, at 10:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; func _computeLastParam() -&gt; String {<br>&gt;     return &quot;I am the last of my line&quot;<br>&gt; }<br>&gt;<br>&gt; func foo(first: Int, second: String, last: String = _computeLastParam()) {<br>&gt;     print(&quot;first:\(first)&quot;)<br>&gt;     print(&quot;second:\(second)&quot;)<br>&gt;     print(&quot;last:\(last)&quot;)<br>&gt; }<br>&gt;<br>&gt; foo(1, second: &quot;two!&quot;)<br>&gt;<br>&gt; &quot;<br>&gt; *first:1*<br>&gt; *second:two!*<br>&gt; *last:I am the last of my line*<br>&gt; &quot;<br>&gt;<br>&gt;<br>&gt; // hopefully?<br>&gt;<br>&gt; constexpr func _computeLastParam(input: Int) -&gt; String {<br>&gt;     return &quot;I am the last of my line and you gave me \(input)&quot;<br>&gt; }<br>&gt;<br>&gt; func foo(first: Int, second: String, last: String =<br>&gt; _computeLastParam(first)) {<br>&gt;     print(&quot;first:\(first)&quot;)<br>&gt;     print(&quot;second:\(second)&quot;)<br>&gt;     print(&quot;last:\(last)&quot;)<br>&gt; }<br>&gt;<br>&gt; foo(1, second: &quot;two!&quot;)<br>&gt;<br>&gt; &quot;<br>&gt; *first:1*<br>&gt; *second:two!*<br>&gt; *last:I am the last of my line and you gave me 1*<br>&gt; &quot;<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added<br>&gt;&gt; syntax, the biggest problem is that this is mostly handled by default<br>&gt;&gt; values. If we had (once we get?) constant expressions, I imagine that we<br>&gt;&gt; might even be able to reference other parameters in default value method<br>&gt;&gt; calls–which seems like a more generally useful fix for the issue.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; How is this handled by default values?  What you’re saying doesn’t make<br>&gt;&gt; sense to me.  Can you provide an example of what you have in mind?<br>&gt;&gt;<br>&gt;&gt; Have you used a language with a similar feature?  Did you not find it<br>&gt;&gt; useful?<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; TJ<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my<br>&gt;&gt;&gt; comfort zone.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to<br>&gt;&gt;&gt; features in other languages that are generally considered to be quite<br>&gt;&gt;&gt; useful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, most dynamic languages have the ability to pack arguments.<br>&gt;&gt;&gt; There has been discussion of adding tuple packing and unpacking to Swift<br>&gt;&gt;&gt; but it wouldn’t offer everything it does in dynamic languages (as far as I<br>&gt;&gt;&gt; can tell).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift is statically typed so we would have to specify a type for the<br>&gt;&gt;&gt; tuple to pack / unpack.  This means it must be a fixed list of arguments.<br>&gt;&gt;&gt; This is not the case in dynamic languages, where whatever arguments the<br>&gt;&gt;&gt; caller provides are forwarded.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, because the packed tuple parameter is declared manually, there<br>&gt;&gt;&gt; would not be a way to forward a default argument value for specific members<br>&gt;&gt;&gt; of the tuple as far as I can see (I think a default would need to be<br>&gt;&gt;&gt; specified for the entire tuple, not just specific members).  Even if there<br>&gt;&gt;&gt; were a way to specify a value for specific members, I don’t believe it<br>&gt;&gt;&gt; would be possible to “forward” the default value specified by the receiving<br>&gt;&gt;&gt; function, which is actually what is desired.  In dynamic languages, callers<br>&gt;&gt;&gt; can just provide a subset of the tuple arguments and the receiving function<br>&gt;&gt;&gt; detects missing arguments, filling in a default.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another example is variadic generics in C++, which can also forward an<br>&gt;&gt;&gt; arbitrary set of arguments to a receiving function.  This feature of C++<br>&gt;&gt;&gt; relies on the fact that the body of a template is not checked until it is<br>&gt;&gt;&gt; expanded.  This allows the caller of the forwarding function to supply any<br>&gt;&gt;&gt; set of parameters that would be valid when calling the forwardee.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even if Swift supported variadic generics I don’t think this method of<br>&gt;&gt;&gt; forwarding fits the language as the body of a generic function is checked<br>&gt;&gt;&gt; on its own.  I don’t believe there would be a way to specify constraints<br>&gt;&gt;&gt; that would allow the arguments to be used to call the forwarding function<br>&gt;&gt;&gt; (I may be wrong about that if a new kind of constraint was introduced to<br>&gt;&gt;&gt; support this in the future).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The forwarding mechanism in this proposal supports a couple of things<br>&gt;&gt;&gt; that I think will be quite useful which are not possible under the examples<br>&gt;&gt;&gt; of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Providing default values for specific parameters, not just a whole<br>&gt;&gt;&gt; packed tuple<br>&gt;&gt;&gt; 2. Forwarding default parameter values from the forwardee function for<br>&gt;&gt;&gt; said parameters<br>&gt;&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt;&gt; 4. Explicitly providing default values for disambiguation and to<br>&gt;&gt;&gt; suppress forwarding of specific parameters where the callee provides a<br>&gt;&gt;&gt; default value<br>&gt;&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers<br>&gt;&gt;&gt; save you from typing out the init parameters and assignments to each field.<br>&gt;&gt;&gt; Argument forwarding saves you from spelling out the parameters *more than<br>&gt;&gt;&gt; once* (because you still need to type them out for the receiving function)<br>&gt;&gt;&gt; and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think<br>&gt;&gt;&gt; I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both features save approximately the same amount of code.  They save<br>&gt;&gt;&gt; explicit declaration of parameters as well as a single action with the<br>&gt;&gt;&gt; provided argument.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; More importantly, forwarding is a general purpose feature that when<br>&gt;&gt;&gt; combined with partial initializers and property lists can support much more<br>&gt;&gt;&gt; expressive memberwise initialization than contained in the initial<br>&gt;&gt;&gt; proposal.  There was quite a bit of discussion about both the limitations<br>&gt;&gt;&gt; of the memberwise initialization proposal as well as the specificity of it<br>&gt;&gt;&gt; to exactly one use case (memberwise initialization).  Forwarding plays a<br>&gt;&gt;&gt; role in removing the limitations while building on a more general<br>&gt;&gt;&gt; foundation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here’s an example that takes advantage of the combined power of the<br>&gt;&gt;&gt; three proposals I just posted:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This does several things not possible in the current memberwise init<br>&gt;&gt;&gt; proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt;&gt; 4. Supports arbitrary default values for parameters, including `let`<br>&gt;&gt;&gt; properties<br>&gt;&gt;&gt; 5. Allows more-private properties to be exposed by more-public<br>&gt;&gt;&gt; initializer<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here’s how it works:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise<br>&gt;&gt;&gt; initializer corresponding to the properties specified (it also gives you a<br>&gt;&gt;&gt; computed tuple property containing the specified properties).<br>&gt;&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward<br>&gt;&gt;&gt; arguments to the partial initializer introduced in step 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The equivalent manually written code would look like this (assuming<br>&gt;&gt;&gt; partial initializers and omitting the  `args` tuple property that would be<br>&gt;&gt;&gt; synthesized):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     self.name = name<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;&gt;     z = 0<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These features work together to support the additional desired use cases<br>&gt;&gt;&gt; for memberwise initialization while remaining concise and arguably more<br>&gt;&gt;&gt; clear (because the property list explicitly states which members<br>&gt;&gt;&gt; participate in the memberwise partial initializer).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Forwarding in any function, not just initializers (but including<br>&gt;&gt;&gt; concise forwarding of parameters to a super or member initializer, or<br>&gt;&gt;&gt; forwarding from a convenience initializer that just needs to provide a few<br>&gt;&gt;&gt; direct arguments to the designated initializer and forward the rest).<br>&gt;&gt;&gt; 2. Partial initialization support for shared, but non-memberwise<br>&gt;&gt;&gt; initialization logic<br>&gt;&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly<br>&gt;&gt;&gt; additional memberwise features in the future if we identify any that would<br>&gt;&gt;&gt; also be generally useful)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion this is a huge win for both initialization as well as<br>&gt;&gt;&gt; other parts of our code that might take advantage of these features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not,<br>&gt;&gt;&gt; but if I allow myself to speak outside of my expertise, I imagine that it&#39;s<br>&gt;&gt;&gt; gonna be a lot more work than memberwise initializers because this requires<br>&gt;&gt;&gt; inspecting the function body to figure out its parameters.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly<br>&gt;&gt;&gt; provided arguments with the parameter list of any callee overloads that are<br>&gt;&gt;&gt; in scope and determining whether:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. There are no overloads for which the provided arguments could be part<br>&gt;&gt;&gt; of a valid call.  Compiler error.<br>&gt;&gt;&gt; 2. There is a single overload for which the provided arguments could be<br>&gt;&gt;&gt; part of a valid call.  Forward the remaining arguments.<br>&gt;&gt;&gt; 3. There are more than one overloads for which the provided arguments<br>&gt;&gt;&gt; could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we want a forwarding mechanism capable of forwarding default argument<br>&gt;&gt;&gt; values, and possibly (but very desirable IMO) a subset of parameters there<br>&gt;&gt;&gt; is no way to avoid this logic.  I am not an expert at the implementation of<br>&gt;&gt;&gt; such features, but I don’t think it is excessively complex next to other<br>&gt;&gt;&gt; logic implemented in the compiler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At this point, I feel that a competent macro system is a better<br>&gt;&gt;&gt; investment than adding distinct bits of automation wherever there appears<br>&gt;&gt;&gt; to be repetition.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that a macro system would be great, but it is explicitly not in<br>&gt;&gt;&gt; scope for Swift 3.  It would also not be capable of implementing parameter<br>&gt;&gt;&gt; forwarding as described in this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal<br>&gt;&gt;&gt; to be just a first step (as evidenced by the many future enhancements it<br>&gt;&gt;&gt; discussed).  Its review has inspired new ideas and helped to shape my<br>&gt;&gt;&gt; vision of the best long-term solution.  My final thoughts about the review<br>&gt;&gt;&gt; can be found here:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals<br>&gt;&gt;&gt; describing general features that can work together to form a complete<br>&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * *Parameter forwarding:*<br>&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>&gt;&gt;&gt; * *Partial initializers:*<br>&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>&gt;&gt;&gt; * *Property lists:*<br>&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;    - Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are many cases where a function declares parameters simply for the<br>&gt;&gt;&gt; purpose of forwarding the provided arguments to another function. This<br>&gt;&gt;&gt; results in reduntant parameter specifications that make code less clear and<br>&gt;&gt;&gt; less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Convenience initializers that foward parameters directly to a<br>&gt;&gt;&gt;    designated initializer<br>&gt;&gt;&gt;    - Designated initializers that foward parameters directly to a super<br>&gt;&gt;&gt;    initializer<br>&gt;&gt;&gt;    - Designated initializers that foward parameters directly to a<br>&gt;&gt;&gt;    member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;    - If the partial initilaizer proposal is accepted, designated<br>&gt;&gt;&gt;    initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond<br>&gt;&gt;&gt; initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding<br>&gt;&gt;&gt; mechansim. It allows users to provide direct arguments for some parameters<br>&gt;&gt;&gt; while forwarding others.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    1. ...fooParams is a placeholder introduced with ... and followed by<br>&gt;&gt;&gt;    an identifier.<br>&gt;&gt;&gt;    2. In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;    3. At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;    4. The placeholder matches the parameters not directly provided<br>&gt;&gt;&gt;    including their external label and default value if those exist.<br>&gt;&gt;&gt;    5. Parameters corresponding to the matched parameters are<br>&gt;&gt;&gt;    synthesized by the compiler where the placeholder exists in the parameter<br>&gt;&gt;&gt;    list, including the default argument if one exists.<br>&gt;&gt;&gt;    6. The identifier portion of the placeholder may be omitted if only<br>&gt;&gt;&gt;    one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The above example can be written more concisely by omitting the<br>&gt;&gt;&gt; placeholder identifier.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar(...) {<br>&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be<br>&gt;&gt;&gt; required I am willing to do so.<br>&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is possible for a single function to forward more than one set of<br>&gt;&gt;&gt; parameters:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the<br>&gt;&gt;&gt; usual argument ordering rules, with the only exception being that it is<br>&gt;&gt;&gt; allowed to omit some arguments that would normally be required. When the<br>&gt;&gt;&gt; compiler performs forwarding it will insert forwarded arguments in the<br>&gt;&gt;&gt; correct location.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as<br>&gt;&gt;&gt; long as the signature of the matched parameters matches exactly, including<br>&gt;&gt;&gt; any default values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt; // user writes:func baz(...fooBarParams) {<br>&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes: func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t<br>&gt;&gt;&gt; like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller<br>&gt;&gt;&gt; must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes: func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible<br>&gt;&gt;&gt; to explicitly request the default value. This allows for disambiguation and<br>&gt;&gt;&gt; also allows the forwarding function to suppress a defaulted parameter from<br>&gt;&gt;&gt; participating in forwarding without needing to supply a specific value. The<br>&gt;&gt;&gt; default keyword is used to do this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using<br>&gt;&gt;&gt; default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat<br>&gt;&gt;&gt; different. These examples are intended to communicate the behavior, not the<br>&gt;&gt;&gt; exact details of implementation.<br>&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the types of any matched parameters reference any generic type<br>&gt;&gt;&gt; parameters of the forwardee the generic type parameters must also be<br>&gt;&gt;&gt; forwarded, along with any constraints on those generic parameters.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also<br>&gt;&gt;&gt; references a generic parameter that will not be forwarded the constraint is<br>&gt;&gt;&gt; resolved to a concrete type when possible. This may not be possible in all<br>&gt;&gt;&gt; cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal<br>&gt;&gt;&gt; names that do not conflict with the internal names of any manually declared<br>&gt;&gt;&gt; parameters. This applies to both generic type parameter names as well as<br>&gt;&gt;&gt; value arguments in the parameter list of the function.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; // user writes:func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // compiler synthesizes:func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and<br>&gt;&gt;&gt; any alternatives would be lose functionality without good reason.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I<br>&gt;&gt;&gt; consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/45d7f2f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:13 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; The last bit might not but default values have *everything* to do with parameter forwarding. What do default values afford us in our API?<br>&gt; <br>&gt; foo()<br>&gt; foo(first: Int)<br>&gt; foo(first: Int, second: String)<br>&gt; <br>&gt; with &#39;one&#39; implementation. <br>&gt; <br>&gt; What does parameter forwarding get us?<br>&gt; <br>&gt; foo()<br>&gt; foo(first: Int)<br>&gt; foo(first: Int, second: String)<br>&gt; <br>&gt; with &#39;one&#39; implementation (but maybe in reverse?)<br></p><p>No, that is not the point of parameter forwarding.  Obviously default values are much better in that case.  Parameter forwarding is for use cases where you need to forward to an entirely different function.  Here are the use cases I listed in the proposal:<br></p><p>	• Convenience initializers that foward parameters directly to a designated initializer<br>	• Designated initializers that foward parameters directly to a super initializer<br>	• Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>	• If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br></p><p>None of these use cases are handled by simple default values.<br></p><p>There are use cases, I just haven’t had time to put together a more comprehensive motivation section yet.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; This example doesn’t have anything to do with forwarding.  Do you have something in mind in the context of parameter forwarding?<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 10:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func _computeLastParam() -&gt; String {<br>&gt;&gt;     return &quot;I am the last of my line&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo(first: Int, second: String, last: String = _computeLastParam()) {<br>&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; first:1<br>&gt;&gt; second:two!<br>&gt;&gt; last:I am the last of my line<br>&gt;&gt; &quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // hopefully?<br>&gt;&gt; <br>&gt;&gt; constexpr func _computeLastParam(input: Int) -&gt; String {<br>&gt;&gt;     return &quot;I am the last of my line and you gave me \(input)&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo(first: Int, second: String, last: String = _computeLastParam(first)) {<br>&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; first:1<br>&gt;&gt; second:two!<br>&gt;&gt; last:I am the last of my line and you gave me 1<br>&gt;&gt; &quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added syntax, the biggest problem is that this is mostly handled by default values. If we had (once we get?) constant expressions, I imagine that we might even be able to reference other parameters in default value method calls–which seems like a more generally useful fix for the issue.<br>&gt;&gt; <br>&gt;&gt; How is this handled by default values?  What you’re saying doesn’t make sense to me.  Can you provide an example of what you have in mind?<br>&gt;&gt; <br>&gt;&gt; Have you used a language with a similar feature?  Did you not find it useful?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, most dynamic languages have the ability to pack arguments.  There has been discussion of adding tuple packing and unpacking to Swift but it wouldn’t offer everything it does in dynamic languages (as far as I can tell).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is statically typed so we would have to specify a type for the tuple to pack / unpack.  This means it must be a fixed list of arguments.  This is not the case in dynamic languages, where whatever arguments the caller provides are forwarded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, because the packed tuple parameter is declared manually, there would not be a way to forward a default argument value for specific members of the tuple as far as I can see (I think a default would need to be specified for the entire tuple, not just specific members).  Even if there were a way to specify a value for specific members, I don’t believe it would be possible to “forward” the default value specified by the receiving function, which is actually what is desired.  In dynamic languages, callers can just provide a subset of the tuple arguments and the receiving function detects missing arguments, filling in a default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another example is variadic generics in C++, which can also forward an arbitrary set of arguments to a receiving function.  This feature of C++ relies on the fact that the body of a template is not checked until it is expanded.  This allows the caller of the forwarding function to supply any set of parameters that would be valid when calling the forwardee.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if Swift supported variadic generics I don’t think this method of forwarding fits the language as the body of a generic function is checked on its own.  I don’t believe there would be a way to specify constraints that would allow the arguments to be used to call the forwarding function (I may be wrong about that if a new kind of constraint was introduced to support this in the future).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The forwarding mechanism in this proposal supports a couple of things that I think will be quite useful which are not possible under the examples of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Providing default values for specific parameters, not just a whole packed tuple<br>&gt;&gt;&gt; 2. Forwarding default parameter values from the forwardee function for said parameters<br>&gt;&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt;&gt; 4. Explicitly providing default values for disambiguation and to suppress forwarding of specific parameters where the callee provides a default value<br>&gt;&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s an example that takes advantage of the combined power of the three proposals I just posted:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This does several things not possible in the current memberwise init proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt;&gt; 4. Supports arbitrary default values for parameters, including `let` properties<br>&gt;&gt;&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s how it works: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise initializer corresponding to the properties specified (it also gives you a computed tuple property containing the specified properties).<br>&gt;&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward arguments to the partial initializer introduced in step 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The equivalent manually written code would look like this (assuming partial initializers and omitting the  `args` tuple property that would be synthesized):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     self.name &lt;http://self.name/&gt; = name<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;&gt;     z = 0 <br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These features work together to support the additional desired use cases for memberwise initialization while remaining concise and arguably more clear (because the property list explicitly states which members participate in the memberwise partial initializer).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Forwarding in any function, not just initializers (but including concise forwarding of parameters to a super or member initializer, or forwarding from a convenience initializer that just needs to provide a few direct arguments to the designated initializer and forward the rest).<br>&gt;&gt;&gt; 2. Partial initialization support for shared, but non-memberwise initialization logic<br>&gt;&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly additional memberwise features in the future if we identify any that would also be generally useful)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion this is a huge win for both initialization as well as other parts of our code that might take advantage of these features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly provided arguments with the parameter list of any callee overloads that are in scope and determining whether: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. There are no overloads for which the provided arguments could be part of a valid call.  Compiler error.<br>&gt;&gt;&gt; 2. There is a single overload for which the provided arguments could be part of a valid call.  Forward the remaining arguments.<br>&gt;&gt;&gt; 3. There are more than one overloads for which the provided arguments could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we want a forwarding mechanism capable of forwarding default argument values, and possibly (but very desirable IMO) a subset of parameters there is no way to avoid this logic.  I am not an expert at the implementation of such features, but I don’t think it is excessively complex next to other logic implemented in the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/41317fb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I am not sure that I see the value in *not* explicitly passing those<br>parameters on in a call, then. Needing to l keep track of the parameter<br>list to pass on to an admittedly different method seems *too* implicit.<br></p><p><br></p><p>On Mon, Jan 11, 2016 at 12:17 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 11, 2016, at 11:13 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; The last bit might not but default values have *everything* to do with<br>&gt; parameter forwarding. What do default values afford us in our API?<br>&gt;<br>&gt; foo()<br>&gt; foo(first: Int)<br>&gt; foo(first: Int, second: String)<br>&gt;<br>&gt; with &#39;one&#39; implementation.<br>&gt;<br>&gt; What does parameter forwarding get us?<br>&gt;<br>&gt; foo()<br>&gt; foo(first: Int)<br>&gt; foo(first: Int, second: String)<br>&gt;<br>&gt; with &#39;one&#39; implementation (but maybe in reverse?)<br>&gt;<br>&gt;<br>&gt; No, that is not the point of parameter forwarding.  Obviously default<br>&gt; values are much better in that case.  Parameter forwarding is for use cases<br>&gt; where you need to forward to an entirely different function.  Here are the<br>&gt; use cases I listed in the proposal:<br>&gt;<br>&gt; • Convenience initializers that foward parameters directly to a<br>&gt; designated initializer<br>&gt; • Designated initializers that foward parameters directly to a super<br>&gt; initializer<br>&gt; • Designated initializers that foward parameters directly to a<br>&gt; member initializer, perhaps in a composition-based design<br>&gt; • If the partial initilaizer proposal is accepted, designated initializers<br>&gt; that forward parameters to one or more partial initializers<br>&gt;<br>&gt; None of these use cases are handled by simple default values.<br>&gt;<br>&gt; There are use cases, I just haven’t had time to put together a more<br>&gt; comprehensive motivation section yet.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; This example doesn’t have anything to do with forwarding.  Do you have<br>&gt;&gt; something in mind in the context of parameter forwarding?<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 11, 2016, at 10:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; func _computeLastParam() -&gt; String {<br>&gt;&gt;     return &quot;I am the last of my line&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func foo(first: Int, second: String, last: String = _computeLastParam())<br>&gt;&gt; {<br>&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt;<br>&gt;&gt; &quot;<br>&gt;&gt; *first:1*<br>&gt;&gt; *second:two!*<br>&gt;&gt; *last:I am the last of my line*<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // hopefully?<br>&gt;&gt;<br>&gt;&gt; constexpr func _computeLastParam(input: Int) -&gt; String {<br>&gt;&gt;     return &quot;I am the last of my line and you gave me \(input)&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func foo(first: Int, second: String, last: String =<br>&gt;&gt; _computeLastParam(first)) {<br>&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt;<br>&gt;&gt; &quot;<br>&gt;&gt; *first:1*<br>&gt;&gt; *second:two!*<br>&gt;&gt; *last:I am the last of my line and you gave me 1*<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added<br>&gt;&gt;&gt; syntax, the biggest problem is that this is mostly handled by default<br>&gt;&gt;&gt; values. If we had (once we get?) constant expressions, I imagine that we<br>&gt;&gt;&gt; might even be able to reference other parameters in default value method<br>&gt;&gt;&gt; calls–which seems like a more generally useful fix for the issue.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How is this handled by default values?  What you’re saying doesn’t make<br>&gt;&gt;&gt; sense to me.  Can you provide an example of what you have in mind?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Have you used a language with a similar feature?  Did you not find it<br>&gt;&gt;&gt; useful?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my<br>&gt;&gt;&gt;&gt; comfort zone.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to<br>&gt;&gt;&gt;&gt; features in other languages that are generally considered to be quite<br>&gt;&gt;&gt;&gt; useful.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, most dynamic languages have the ability to pack<br>&gt;&gt;&gt;&gt; arguments.  There has been discussion of adding tuple packing and unpacking<br>&gt;&gt;&gt;&gt; to Swift but it wouldn’t offer everything it does in dynamic languages (as<br>&gt;&gt;&gt;&gt; far as I can tell).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift is statically typed so we would have to specify a type for the<br>&gt;&gt;&gt;&gt; tuple to pack / unpack.  This means it must be a fixed list of arguments.<br>&gt;&gt;&gt;&gt; This is not the case in dynamic languages, where whatever arguments the<br>&gt;&gt;&gt;&gt; caller provides are forwarded.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also, because the packed tuple parameter is declared manually, there<br>&gt;&gt;&gt;&gt; would not be a way to forward a default argument value for specific members<br>&gt;&gt;&gt;&gt; of the tuple as far as I can see (I think a default would need to be<br>&gt;&gt;&gt;&gt; specified for the entire tuple, not just specific members).  Even if there<br>&gt;&gt;&gt;&gt; were a way to specify a value for specific members, I don’t believe it<br>&gt;&gt;&gt;&gt; would be possible to “forward” the default value specified by the receiving<br>&gt;&gt;&gt;&gt; function, which is actually what is desired.  In dynamic languages, callers<br>&gt;&gt;&gt;&gt; can just provide a subset of the tuple arguments and the receiving function<br>&gt;&gt;&gt;&gt; detects missing arguments, filling in a default.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another example is variadic generics in C++, which can also forward an<br>&gt;&gt;&gt;&gt; arbitrary set of arguments to a receiving function.  This feature of C++<br>&gt;&gt;&gt;&gt; relies on the fact that the body of a template is not checked until it is<br>&gt;&gt;&gt;&gt; expanded.  This allows the caller of the forwarding function to supply any<br>&gt;&gt;&gt;&gt; set of parameters that would be valid when calling the forwardee.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Even if Swift supported variadic generics I don’t think this method of<br>&gt;&gt;&gt;&gt; forwarding fits the language as the body of a generic function is checked<br>&gt;&gt;&gt;&gt; on its own.  I don’t believe there would be a way to specify constraints<br>&gt;&gt;&gt;&gt; that would allow the arguments to be used to call the forwarding function<br>&gt;&gt;&gt;&gt; (I may be wrong about that if a new kind of constraint was introduced to<br>&gt;&gt;&gt;&gt; support this in the future).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The forwarding mechanism in this proposal supports a couple of things<br>&gt;&gt;&gt;&gt; that I think will be quite useful which are not possible under the examples<br>&gt;&gt;&gt;&gt; of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Providing default values for specific parameters, not just a whole<br>&gt;&gt;&gt;&gt; packed tuple<br>&gt;&gt;&gt;&gt; 2. Forwarding default parameter values from the forwardee function for<br>&gt;&gt;&gt;&gt; said parameters<br>&gt;&gt;&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt;&gt;&gt; 4. Explicitly providing default values for disambiguation and to<br>&gt;&gt;&gt;&gt; suppress forwarding of specific parameters where the callee provides a<br>&gt;&gt;&gt;&gt; default value<br>&gt;&gt;&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers<br>&gt;&gt;&gt;&gt; save you from typing out the init parameters and assignments to each field.<br>&gt;&gt;&gt;&gt; Argument forwarding saves you from spelling out the parameters *more than<br>&gt;&gt;&gt;&gt; once* (because you still need to type them out for the receiving function)<br>&gt;&gt;&gt;&gt; and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think<br>&gt;&gt;&gt;&gt; I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Both features save approximately the same amount of code.  They save<br>&gt;&gt;&gt;&gt; explicit declaration of parameters as well as a single action with the<br>&gt;&gt;&gt;&gt; provided argument.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; More importantly, forwarding is a general purpose feature that when<br>&gt;&gt;&gt;&gt; combined with partial initializers and property lists can support much more<br>&gt;&gt;&gt;&gt; expressive memberwise initialization than contained in the initial<br>&gt;&gt;&gt;&gt; proposal.  There was quite a bit of discussion about both the limitations<br>&gt;&gt;&gt;&gt; of the memberwise initialization proposal as well as the specificity of it<br>&gt;&gt;&gt;&gt; to exactly one use case (memberwise initialization).  Forwarding plays a<br>&gt;&gt;&gt;&gt; role in removing the limitations while building on a more general<br>&gt;&gt;&gt;&gt; foundation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here’s an example that takes advantage of the combined power of the<br>&gt;&gt;&gt;&gt; three proposals I just posted:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This does several things not possible in the current memberwise init<br>&gt;&gt;&gt;&gt; proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt;&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt;&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt;&gt;&gt; 4. Supports arbitrary default values for parameters, including `let`<br>&gt;&gt;&gt;&gt; properties<br>&gt;&gt;&gt;&gt; 5. Allows more-private properties to be exposed by more-public<br>&gt;&gt;&gt;&gt; initializer<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here’s how it works:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise<br>&gt;&gt;&gt;&gt; initializer corresponding to the properties specified (it also gives you a<br>&gt;&gt;&gt;&gt; computed tuple property containing the specified properties).<br>&gt;&gt;&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward<br>&gt;&gt;&gt;&gt; arguments to the partial initializer introduced in step 1.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The equivalent manually written code would look like this (assuming<br>&gt;&gt;&gt;&gt; partial initializers and omitting the  `args` tuple property that would be<br>&gt;&gt;&gt;&gt; synthesized):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;     self.name = name<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;&gt;&gt;     z = 0<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; These features work together to support the additional desired use<br>&gt;&gt;&gt;&gt; cases for memberwise initialization while remaining concise and arguably<br>&gt;&gt;&gt;&gt; more clear (because the property list explicitly states which members<br>&gt;&gt;&gt;&gt; participate in the memberwise partial initializer).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Forwarding in any function, not just initializers (but including<br>&gt;&gt;&gt;&gt; concise forwarding of parameters to a super or member initializer, or<br>&gt;&gt;&gt;&gt; forwarding from a convenience initializer that just needs to provide a few<br>&gt;&gt;&gt;&gt; direct arguments to the designated initializer and forward the rest).<br>&gt;&gt;&gt;&gt; 2. Partial initialization support for shared, but non-memberwise<br>&gt;&gt;&gt;&gt; initialization logic<br>&gt;&gt;&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly<br>&gt;&gt;&gt;&gt; additional memberwise features in the future if we identify any that would<br>&gt;&gt;&gt;&gt; also be generally useful)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In my opinion this is a huge win for both initialization as well as<br>&gt;&gt;&gt;&gt; other parts of our code that might take advantage of these features.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not,<br>&gt;&gt;&gt;&gt; but if I allow myself to speak outside of my expertise, I imagine that it&#39;s<br>&gt;&gt;&gt;&gt; gonna be a lot more work than memberwise initializers because this requires<br>&gt;&gt;&gt;&gt; inspecting the function body to figure out its parameters.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly<br>&gt;&gt;&gt;&gt; provided arguments with the parameter list of any callee overloads that are<br>&gt;&gt;&gt;&gt; in scope and determining whether:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. There are no overloads for which the provided arguments could be<br>&gt;&gt;&gt;&gt; part of a valid call.  Compiler error.<br>&gt;&gt;&gt;&gt; 2. There is a single overload for which the provided arguments could be<br>&gt;&gt;&gt;&gt; part of a valid call.  Forward the remaining arguments.<br>&gt;&gt;&gt;&gt; 3. There are more than one overloads for which the provided arguments<br>&gt;&gt;&gt;&gt; could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we want a forwarding mechanism capable of forwarding default<br>&gt;&gt;&gt;&gt; argument values, and possibly (but very desirable IMO) a subset of<br>&gt;&gt;&gt;&gt; parameters there is no way to avoid this logic.  I am not an expert at the<br>&gt;&gt;&gt;&gt; implementation of such features, but I don’t think it is excessively<br>&gt;&gt;&gt;&gt; complex next to other logic implemented in the compiler.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; At this point, I feel that a competent macro system is a better<br>&gt;&gt;&gt;&gt; investment than adding distinct bits of automation wherever there appears<br>&gt;&gt;&gt;&gt; to be repetition.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that a macro system would be great, but it is explicitly not in<br>&gt;&gt;&gt;&gt; scope for Swift 3.  It would also not be capable of implementing parameter<br>&gt;&gt;&gt;&gt; forwarding as described in this proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization<br>&gt;&gt;&gt;&gt; proposal to be just a first step (as evidenced by the many future<br>&gt;&gt;&gt;&gt; enhancements it discussed).  Its review has inspired new ideas and helped<br>&gt;&gt;&gt;&gt; to shape my vision of the best long-term solution.  My final thoughts about<br>&gt;&gt;&gt;&gt; the review can be found here:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals<br>&gt;&gt;&gt;&gt; describing general features that can work together to form a complete<br>&gt;&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * *Parameter forwarding:*<br>&gt;&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>&gt;&gt;&gt;&gt; * *Partial initializers:*<br>&gt;&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>&gt;&gt;&gt;&gt; * *Property lists:*<br>&gt;&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;    - Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are many cases where a function declares parameters simply for<br>&gt;&gt;&gt;&gt; the purpose of forwarding the provided arguments to another function. This<br>&gt;&gt;&gt;&gt; results in reduntant parameter specifications that make code less clear and<br>&gt;&gt;&gt;&gt; less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Convenience initializers that foward parameters directly to a<br>&gt;&gt;&gt;&gt;    designated initializer<br>&gt;&gt;&gt;&gt;    - Designated initializers that foward parameters directly to a<br>&gt;&gt;&gt;&gt;    super initializer<br>&gt;&gt;&gt;&gt;    - Designated initializers that foward parameters directly to a<br>&gt;&gt;&gt;&gt;    member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;&gt;    - If the partial initilaizer proposal is accepted, designated<br>&gt;&gt;&gt;&gt;    initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond<br>&gt;&gt;&gt;&gt; initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding<br>&gt;&gt;&gt;&gt; mechansim. It allows users to provide direct arguments for some parameters<br>&gt;&gt;&gt;&gt; while forwarding others.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    1. ...fooParams is a placeholder introduced with ... and followed<br>&gt;&gt;&gt;&gt;    by an identifier.<br>&gt;&gt;&gt;&gt;    2. In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;&gt;    3. At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;&gt;    4. The placeholder matches the parameters not directly provided<br>&gt;&gt;&gt;&gt;    including their external label and default value if those exist.<br>&gt;&gt;&gt;&gt;    5. Parameters corresponding to the matched parameters are<br>&gt;&gt;&gt;&gt;    synthesized by the compiler where the placeholder exists in the parameter<br>&gt;&gt;&gt;&gt;    list, including the default argument if one exists.<br>&gt;&gt;&gt;&gt;    6. The identifier portion of the placeholder may be omitted if only<br>&gt;&gt;&gt;&gt;    one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The above example can be written more concisely by omitting the<br>&gt;&gt;&gt;&gt; placeholder identifier.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be<br>&gt;&gt;&gt;&gt; required I am willing to do so.<br>&gt;&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is possible for a single function to forward more than one set of<br>&gt;&gt;&gt;&gt; parameters:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the<br>&gt;&gt;&gt;&gt; usual argument ordering rules, with the only exception being that it is<br>&gt;&gt;&gt;&gt; allowed to omit some arguments that would normally be required. When the<br>&gt;&gt;&gt;&gt; compiler performs forwarding it will insert forwarded arguments in the<br>&gt;&gt;&gt;&gt; correct location.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls<br>&gt;&gt;&gt;&gt; as long as the signature of the matched parameters matches exactly,<br>&gt;&gt;&gt;&gt; including any default values.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt; // user writes:func baz(...fooBarParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes: func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t<br>&gt;&gt;&gt;&gt; like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller<br>&gt;&gt;&gt;&gt; must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes: func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When forwarding to a function that accepts default values it is<br>&gt;&gt;&gt;&gt; possible to explicitly request the default value. This allows for<br>&gt;&gt;&gt;&gt; disambiguation and also allows the forwarding function to suppress a<br>&gt;&gt;&gt;&gt; defaulted parameter from participating in forwarding without needing to<br>&gt;&gt;&gt;&gt; supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using<br>&gt;&gt;&gt;&gt; default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat<br>&gt;&gt;&gt;&gt; different. These examples are intended to communicate the behavior, not the<br>&gt;&gt;&gt;&gt; exact details of implementation.<br>&gt;&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If the types of any matched parameters reference any generic type<br>&gt;&gt;&gt;&gt; parameters of the forwardee the generic type parameters must also be<br>&gt;&gt;&gt;&gt; forwarded, along with any constraints on those generic parameters.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also<br>&gt;&gt;&gt;&gt; references a generic parameter that will not be forwarded the constraint is<br>&gt;&gt;&gt;&gt; resolved to a concrete type when possible. This may not be possible in all<br>&gt;&gt;&gt;&gt; cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal<br>&gt;&gt;&gt;&gt; names that do not conflict with the internal names of any manually declared<br>&gt;&gt;&gt;&gt; parameters. This applies to both generic type parameter names as well as<br>&gt;&gt;&gt;&gt; value arguments in the parameter list of the function.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; // user writes:func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // compiler synthesizes:func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and<br>&gt;&gt;&gt;&gt; any alternatives would be lose functionality without good reason.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I<br>&gt;&gt;&gt;&gt; consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/13b7d5a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:27 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I am not sure that I see the value in *not* explicitly passing those parameters on in a call, then. Needing to l keep track of the parameter list to pass on to an admittedly different method seems *too* implicit. <br></p><p>That’s a fair perspective, but parameter forwarding has been considered useful and not confusing in other languages by many people.  Knowing when it adds clarity and when it doesn’t is important. <br></p><p>Matthew<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 12:17 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 11:13 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The last bit might not but default values have *everything* to do with parameter forwarding. What do default values afford us in our API?<br>&gt;&gt; <br>&gt;&gt; foo()<br>&gt;&gt; foo(first: Int)<br>&gt;&gt; foo(first: Int, second: String)<br>&gt;&gt; <br>&gt;&gt; with &#39;one&#39; implementation. <br>&gt;&gt; <br>&gt;&gt; What does parameter forwarding get us?<br>&gt;&gt; <br>&gt;&gt; foo()<br>&gt;&gt; foo(first: Int)<br>&gt;&gt; foo(first: Int, second: String)<br>&gt;&gt; <br>&gt;&gt; with &#39;one&#39; implementation (but maybe in reverse?)<br>&gt; <br>&gt; No, that is not the point of parameter forwarding.  Obviously default values are much better in that case.  Parameter forwarding is for use cases where you need to forward to an entirely different function.  Here are the use cases I listed in the proposal:<br>&gt; <br>&gt; 	• Convenience initializers that foward parameters directly to a designated initializer<br>&gt; 	• Designated initializers that foward parameters directly to a super initializer<br>&gt; 	• Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt; 	• If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt; <br>&gt; None of these use cases are handled by simple default values.<br>&gt; <br>&gt; There are use cases, I just haven’t had time to put together a more comprehensive motivation section yet.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 11, 2016 at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; This example doesn’t have anything to do with forwarding.  Do you have something in mind in the context of parameter forwarding?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 10:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func _computeLastParam() -&gt; String {<br>&gt;&gt;&gt;     return &quot;I am the last of my line&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(first: Int, second: String, last: String = _computeLastParam()) {<br>&gt;&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; first:1<br>&gt;&gt;&gt; second:two!<br>&gt;&gt;&gt; last:I am the last of my line<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // hopefully?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; constexpr func _computeLastParam(input: Int) -&gt; String {<br>&gt;&gt;&gt;     return &quot;I am the last of my line and you gave me \(input)&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(first: Int, second: String, last: String = _computeLastParam(first)) {<br>&gt;&gt;&gt;     print(&quot;first:\(first)&quot;)<br>&gt;&gt;&gt;     print(&quot;second:\(second)&quot;)<br>&gt;&gt;&gt;     print(&quot;last:\(last)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(1, second: &quot;two!&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; first:1<br>&gt;&gt;&gt; second:two!<br>&gt;&gt;&gt; last:I am the last of my line and you gave me 1<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 11:05 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can&#39;t get behind this feature. Beside the lack of payoff for added syntax, the biggest problem is that this is mostly handled by default values. If we had (once we get?) constant expressions, I imagine that we might even be able to reference other parameters in default value method calls–which seems like a more generally useful fix for the issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How is this handled by default values?  What you’re saying doesn’t make sense to me.  Can you provide an example of what you have in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have you used a language with a similar feature?  Did you not find it useful?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TJ<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jan 11, 2016 at 10:29 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, most dynamic languages have the ability to pack arguments.  There has been discussion of adding tuple packing and unpacking to Swift but it wouldn’t offer everything it does in dynamic languages (as far as I can tell).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift is statically typed so we would have to specify a type for the tuple to pack / unpack.  This means it must be a fixed list of arguments.  This is not the case in dynamic languages, where whatever arguments the caller provides are forwarded.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, because the packed tuple parameter is declared manually, there would not be a way to forward a default argument value for specific members of the tuple as far as I can see (I think a default would need to be specified for the entire tuple, not just specific members).  Even if there were a way to specify a value for specific members, I don’t believe it would be possible to “forward” the default value specified by the receiving function, which is actually what is desired.  In dynamic languages, callers can just provide a subset of the tuple arguments and the receiving function detects missing arguments, filling in a default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another example is variadic generics in C++, which can also forward an arbitrary set of arguments to a receiving function.  This feature of C++ relies on the fact that the body of a template is not checked until it is expanded.  This allows the caller of the forwarding function to supply any set of parameters that would be valid when calling the forwardee. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even if Swift supported variadic generics I don’t think this method of forwarding fits the language as the body of a generic function is checked on its own.  I don’t believe there would be a way to specify constraints that would allow the arguments to be used to call the forwarding function (I may be wrong about that if a new kind of constraint was introduced to support this in the future).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The forwarding mechanism in this proposal supports a couple of things that I think will be quite useful which are not possible under the examples of tuple packing and unpacking in Swift that I have seen shared thus far:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Providing default values for specific parameters, not just a whole packed tuple<br>&gt;&gt;&gt;&gt; 2. Forwarding default parameter values from the forwardee function for said parameters<br>&gt;&gt;&gt;&gt; 3. Forwarding a subset of the forwarded’s parameters<br>&gt;&gt;&gt;&gt; 4. Explicitly providing default values for disambiguation and to suppress forwarding of specific parameters where the callee provides a default value<br>&gt;&gt;&gt;&gt; 5. Forwarding generic parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s an example that takes advantage of the combined power of the three proposals I just posted:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   propertylist args: left x = 0, top y = 0, name<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(…args) { z = 0 }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This does several things not possible in the current memberwise init proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Supports an arbitrary subset of members<br>&gt;&gt;&gt;&gt; 2. Supports an arbitrary order for memberwise parameters<br>&gt;&gt;&gt;&gt; 3. Supports arbitrary labels for memberwise parameters<br>&gt;&gt;&gt;&gt; 4. Supports arbitrary default values for parameters, including `let` properties<br>&gt;&gt;&gt;&gt; 5. Allows more-private properties to be exposed by more-public initializer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s how it works: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. The `propertylist` declaration introduces a partial memberwise initializer corresponding to the properties specified (it also gives you a computed tuple property containing the specified properties).<br>&gt;&gt;&gt;&gt; 2. The `…args` placeholder causes the primary initializer to forward arguments to the partial initializer introduced in step 1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The equivalent manually written code would look like this (assuming partial initializers and omitting the  `args` tuple property that would be synthesized):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   var name: String = “&quot;<br>&gt;&gt;&gt;&gt;   private let x, y, z: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   partial init args(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;     self.name &lt;http://self.name/&gt; = name<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(left x: Int = 0, top y: Int = 0, name: String = “”) {<br>&gt;&gt;&gt;&gt;     args.init(left: x, top: y, name: name)<br>&gt;&gt;&gt;&gt;     z = 0 <br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These features work together to support the additional desired use cases for memberwise initialization while remaining concise and arguably more clear (because the property list explicitly states which members participate in the memberwise partial initializer).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because the features supporting this are general we also gain:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Forwarding in any function, not just initializers (but including concise forwarding of parameters to a super or member initializer, or forwarding from a convenience initializer that just needs to provide a few direct arguments to the designated initializer and forward the rest).<br>&gt;&gt;&gt;&gt; 2. Partial initialization support for shared, but non-memberwise initialization logic<br>&gt;&gt;&gt;&gt; 3. Computed tuple properties for each propertylist.  (and possibly additional memberwise features in the future if we identify any that would also be generally useful)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my opinion this is a huge win for both initialization as well as other parts of our code that might take advantage of these features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ll let the parser guys say if it&#39;s a lot of work to implement or not, but if I allow myself to speak outside of my expertise, I imagine that it&#39;s gonna be a lot more work than memberwise initializers because this requires inspecting the function body to figure out its parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is a bit more work, sure.  It requires matching the explicitly provided arguments with the parameter list of any callee overloads that are in scope and determining whether: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. There are no overloads for which the provided arguments could be part of a valid call.  Compiler error.<br>&gt;&gt;&gt;&gt; 2. There is a single overload for which the provided arguments could be part of a valid call.  Forward the remaining arguments.<br>&gt;&gt;&gt;&gt; 3. There are more than one overloads for which the provided arguments could be part of a valid call.  Compiler error due to ambiguity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we want a forwarding mechanism capable of forwarding default argument values, and possibly (but very desirable IMO) a subset of parameters there is no way to avoid this logic.  I am not an expert at the implementation of such features, but I don’t think it is excessively complex next to other logic implemented in the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt;&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt;&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/029e1528/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt; <br>&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt; <br>&gt; /* snip */<br></p><p>I don&#39;t find it similar to how dynamic languages do parameter packing, and not useful in the same conditions. In Python, you&#39;ll use parameter packing and unpacking mostly with functions that receive variable parameters. Swift&#39;s variadic functions don&#39;t work like that. It&#39;s strictly less powerful and less needed than C++&#39;s perfect forwarding because Swift doesn&#39;t have lvalue (or rvalue) references. Besides, perfect forwarding is mostly used when you don&#39;t know the call target, and the parameter packing proposal requires you to know it.<br></p><p>The fact that there are forwarding solutions in other languages doesn&#39;t mean that Swift has the problems that these solutions are trying to address.<br></p><p>&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt; <br>&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br></p><p>Here&#39;s a 4-field example for memberwise initializers:<br></p><p>&gt; struct Foo {<br>&gt; 	var bar: Int<br>&gt; 	var baz: Int<br>&gt; 	var frob: Int<br>&gt; 	var nicate: Int<br>&gt; }<br></p><p>it&#39;s either gonna be &quot;memberwise init(...) {}&quot; (23 chars) or:<br></p><p>&gt; 	init(bar: Int, baz: Int, frob: Int, nicate: Int) {<br>&gt; 		self.bar = bar<br>&gt; 		self.baz = baz<br>&gt; 		self.frob = frob<br>&gt; 		self.nicate = nicate<br>&gt; 	}<br></p><p><br>120 characters excluding tabs, and with very short insignificant names. That&#39;s like six times less code for the same thing.<br></p><p>Let&#39;s have a 4-parameter method:<br></p><p>&gt; class Foo {<br>&gt; 	func foo(bar: Int, baz: Int, frob: Int, nicate: Int) { /* snip */ }<br>&gt; }<br></p><p><br>Now this is either going to be &quot;func bar(...fooPack) { foo(bar: 1, ...fooPack) }&quot; (48 chars) or &quot;func bar(baz: Int, frob: Int, nicate: Int) { foo(bar: 1, baz: baz, frob: frob, nicate: nicate) }&quot; (96 chars).<br></p><p>&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br></p><p>I disagree with the critics and I don&#39;t support these other proposals. In my opinion, the objections you&#39;re referring to were theoretical-style &quot;this doesn&#39;t solve the General Problem&quot;. The vast majority of users don&#39;t need the General Problem to be solved, and if a specific solution gets us 95% of the way there with little disturbance, it&#39;s probably best to take it and leave behind the major changes required for the remaining 5%.<br></p><p>The question here is whether memberwise initialization gets us 95% of the way there. I think it does, and I&#39;m gonna need real code and user feedback to change my mind. This is unlikely to happen before memberwise initializers ship.<br></p><p>I really think that we should wait to see how memberwise initialization plays out before laying out plans to extend it.<br></p><p>&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt; <br>&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt; <br>&gt; I hope you will consider discussing this further.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Default values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/5c153f3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I’m already not a huge fan of the complexity introduced with memberwise initializers, but see some usefulness. But I see much less use in parameter forwarding.<br>I’m very afraid of all this &quot;syntactic sugar” and would prefer a simpler language even if it means a little bit more typing.<br></p><p>&gt; On 11 Jan 2016, at 19:26, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 10:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was okay with memberwise initializers but this pushes me beyond my comfort zone.<br>&gt;&gt; <br>&gt;&gt; Hi Felix, can you elaborate on why?  This feature is quite similar to features in other languages that are generally considered to be quite useful.<br>&gt;&gt; <br>&gt;&gt; /* snip */<br>&gt; <br>&gt; I don&#39;t find it similar to how dynamic languages do parameter packing, and not useful in the same conditions. In Python, you&#39;ll use parameter packing and unpacking mostly with functions that receive variable parameters. Swift&#39;s variadic functions don&#39;t work like that. It&#39;s strictly less powerful and less needed than C++&#39;s perfect forwarding because Swift doesn&#39;t have lvalue (or rvalue) references. Besides, perfect forwarding is mostly used when you don&#39;t know the call target, and the parameter packing proposal requires you to know it.<br>&gt; <br>&gt; The fact that there are forwarding solutions in other languages doesn&#39;t mean that Swift has the problems that these solutions are trying to address.<br>&gt; <br>&gt;&gt;&gt; I&#39;m not sold on the usefulness of the feature. Memberwise initializers save you from typing out the init parameters and assignments to each field. Argument forwarding saves you from spelling out the parameters *more than once* (because you still need to type them out for the receiving function) and from *one call*. While I&#39;ve been annoyed at initializers, I don&#39;t think I&#39;ve ever been particularly annoyed at forwarding functions.<br>&gt;&gt; <br>&gt;&gt; Both features save approximately the same amount of code.  They save explicit declaration of parameters as well as a single action with the provided argument.<br>&gt; <br>&gt; Here&#39;s a 4-field example for memberwise initializers:<br>&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt; 	var bar: Int<br>&gt;&gt; 	var baz: Int<br>&gt;&gt; 	var frob: Int<br>&gt;&gt; 	var nicate: Int<br>&gt;&gt; }<br>&gt; <br>&gt; it&#39;s either gonna be &quot;memberwise init(...) {}&quot; (23 chars) or:<br>&gt; <br>&gt;&gt; 	init(bar: Int, baz: Int, frob: Int, nicate: Int) {<br>&gt;&gt; 		self.bar = bar<br>&gt;&gt; 		self.baz = baz<br>&gt;&gt; 		self.frob = frob<br>&gt;&gt; 		self.nicate = nicate<br>&gt;&gt; 	}<br>&gt; <br>&gt; <br>&gt; 120 characters excluding tabs, and with very short insignificant names. That&#39;s like six times less code for the same thing.<br>&gt; <br>&gt; Let&#39;s have a 4-parameter method:<br>&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt; 	func foo(bar: Int, baz: Int, frob: Int, nicate: Int) { /* snip */ }<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; Now this is either going to be &quot;func bar(...fooPack) { foo(bar: 1, ...fooPack) }&quot; (48 chars) or &quot;func bar(baz: Int, frob: Int, nicate: Int) { foo(bar: 1, baz: baz, frob: frob, nicate: nicate) }&quot; (96 chars).<br>&gt; <br>&gt;&gt; More importantly, forwarding is a general purpose feature that when combined with partial initializers and property lists can support much more expressive memberwise initialization than contained in the initial proposal.  There was quite a bit of discussion about both the limitations of the memberwise initialization proposal as well as the specificity of it to exactly one use case (memberwise initialization).  Forwarding plays a role in removing the limitations while building on a more general foundation.<br>&gt; <br>&gt; I disagree with the critics and I don&#39;t support these other proposals. In my opinion, the objections you&#39;re referring to were theoretical-style &quot;this doesn&#39;t solve the General Problem&quot;. The vast majority of users don&#39;t need the General Problem to be solved, and if a specific solution gets us 95% of the way there with little disturbance, it&#39;s probably best to take it and leave behind the major changes required for the remaining 5%.<br>&gt; <br>&gt; The question here is whether memberwise initialization gets us 95% of the way there. I think it does, and I&#39;m gonna need real code and user feedback to change my mind. This is unlikely to happen before memberwise initializers ship.<br>&gt; <br>&gt; I really think that we should wait to see how memberwise initialization plays out before laying out plans to extend it.<br>&gt; <br>&gt;&gt;&gt; At this point, I feel that a competent macro system is a better investment than adding distinct bits of automation wherever there appears to be repetition.<br>&gt;&gt; <br>&gt;&gt; I agree that a macro system would be great, but it is explicitly not in scope for Swift 3.  It would also not be capable of implementing parameter forwarding as described in this proposal.<br>&gt;&gt; <br>&gt;&gt; I hope you will consider discussing this further.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 22:44:36, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.  My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parameter forwarding is the first in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; Parameter Forwarding<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feature introduces an automatic parameter forwarding mechanism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: parameter forwarding &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are many cases where a function declares parameters simply for the purpose of forwarding the provided arguments to another function. This results in reduntant parameter specifications that make code less clear and less readable by obscuring the simple forwarding that is actually happening.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feature will be especially useful in initializers such as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Convenience initializers that foward parameters directly to a designated initializer<br>&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a super initializer<br>&gt;&gt;&gt;&gt; Designated initializers that foward parameters directly to a member initializer, perhaps in a composition-based design<br>&gt;&gt;&gt;&gt; If the partial initilaizer proposal is accepted, designated initializers that forward parameters to one or more partial initializers<br>&gt;&gt;&gt;&gt; NOTE: I haven’t had time to think too much aboue use cases beyond initialization. Please share examples and I will add them to this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Some things to note about the syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...fooParams is a placeholder introduced with ... and followed by an identifier.<br>&gt;&gt;&gt;&gt; In the signature it can be placed anywhere in the parameter list.<br>&gt;&gt;&gt;&gt; At the call site, it must appear at the end of the argument list.<br>&gt;&gt;&gt;&gt; The placeholder matches the parameters not directly provided including their external label and default value if those exist.<br>&gt;&gt;&gt;&gt; Parameters corresponding to the matched parameters are synthesized by the compiler where the placeholder exists in the parameter list, including the default argument if one exists.<br>&gt;&gt;&gt;&gt; The identifier portion of the placeholder may be omitted if only one set of forwarded parameters exist within the function.<br>&gt;&gt;&gt;&gt; Additional details will be introduced with a corresponding example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Omitting the placeholder identifier<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The above example can be written more concisely by omitting the placeholder identifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: If the community feels strongly that the identifier should be required I am willing to do so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Multiple forwarded parameter sets<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is possible for a single function to forward more than one set of parameters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; func foo2(d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams, ...foo2Params) {<br>&gt;&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Direct arguments<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any direct arguments provided in the forwarding call must follow the usual argument ordering rules, with the only exception being that it is allowed to omit some arguments that would normally be required. When the compiler performs forwarding it will insert forwarded arguments in the correct location.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: `i` must precede `s` in the argument list<br>&gt;&gt;&gt;&gt;     foo(s: &quot;hello&quot;, i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, f: 0, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(s s: String, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: 32, s: s, f: 0, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Multi-forwarding the same parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is allowed to use the same identifier in multiple forwarding calls as long as the signature of the matched parameters matches exactly, including any default values. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func baz(...fooBarParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooBarParams)<br>&gt;&gt;&gt;&gt;     bar(...fooBarParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt; func baz(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt;     bar(i: i, s: s, d: d)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: This provision might be controversial. If the community doesn’t like it or the implementation is too complex I will remove it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unambiguous call<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When forwarding parameters to a function that is overloaded the caller must provide enough direct arguments to make the call unambiguous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // error: ambiguous use of foo<br>&gt;&gt;&gt;&gt;     // foo(i: 32, ...fooParams)<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(b: true, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous<br>&gt;&gt;&gt;&gt;     foo(f: 24, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes: <br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: true)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 24)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Default values<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When forwarding to a function that accepts default values it is possible to explicitly request the default value. This allows for disambiguation and also allows the forwarding function to suppress a defaulted parameter from participating in forwarding without needing to supply a specific value. The default keyword is used to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can modify the previous example to use the defualt values:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, f: Float = 42) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     // ok: `b` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(b: default, ...fooParams)<br>&gt;&gt;&gt;&gt;     // ok: `f` makes the call to foo unambiguous, still uses default value<br>&gt;&gt;&gt;&gt;     foo(f: default, ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String, d: Double = 43) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, b: false)<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: d, f: 42)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; It is also possible to explicitly request all defaults at once using default.... In this example, foois not overloaded:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(i i: Int, s: String, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(default..., ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar(i i: Int, s: String) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, d: 43, b: false)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; NOTE: The actual implementation of default arguments looks somewhat different. These examples are intended to communicate the behavior, not the exact details of implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the types of any matched parameters reference any generic type parameters of the forwardee the generic type parameters must also be forwarded, along with any constraints on those generic parameters. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(i: i, s: s, t: t, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; If a generic parameter is referenced in a constraint that also references a generic parameter that will not be forwarded the constraint is resolved to a concrete type when possible. This may not be possible in all cases. When it is not possible a compiler error will be necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;S: SequenceType, T: SequenceType where S.Generator.Element == T.Generator.Element&gt;<br>&gt;&gt;&gt;&gt;     (s: S, t: T) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;&gt;&gt;     foo(t: [42], ...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S) {<br>&gt;&gt;&gt;&gt;     foo(s: s, t: [42])<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Syntheszied internal names<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler must ensure that all synthesized parameters have internal names that do not conflict with the internal names of any manually declared parameters. This applies to both generic type parameter names as well as value arguments in the parameter list of the function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;T&gt;(i i: Int, s: String, t: T, d: Double = 43, b: Bool = false) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // user writes:<br>&gt;&gt;&gt;&gt; func bar&lt;T&gt;(t: T, ...fooParams) {<br>&gt;&gt;&gt;&gt;     // do something with t<br>&gt;&gt;&gt;&gt;     foo(...fooParams)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // compiler synthesizes:<br>&gt;&gt;&gt;&gt; func bar&lt;T, InternalCompilerIdentifier&gt;(t: T, i i: Int, s: String, t internalCompilerIdentifier: InternalCompilerIdentifier, d: Double = 43, b: Bool = false) {<br>&gt;&gt;&gt;&gt;     foo(t: t, i: i, s: s, t: internalCompilerIdentifier, d: d, b: b)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe the forwarding mechanism itself is pretty straightforward and any alternatives would be lose functionality without good reason. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The placeholder syntax is of course fair game for bikeshedding. I consider anything reasonably clear and concise to be acceptable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/26d75596/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt; <br>&gt; The basic mechanism looks like this:<br>&gt; <br>&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt; <br>&gt; // user writes:<br>&gt; func bar(...fooParams) {<br>&gt;     foo(i: 32, ...fooParams)<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt; }<br>This approach is extremely problematic and unlikely to be accepted.<br></p><p>Swift is carefully designed so that the compiler can type check the interface to a function without type checking its body.  This is important for compiler scalability to large projects, IDE tooling, and also because otherwise you can run into circular dependencies to compile the code.<br></p><p>Another major problem with this approach is that it only works if “foo” is unambiguous.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/24af3fdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:53 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to introduce an automatic parameter forwarding mechansim. It allows users to provide direct arguments for some parameters while forwarding others.<br>&gt;&gt; <br>&gt;&gt; The basic mechanism looks like this:<br>&gt;&gt; <br>&gt;&gt; func foo(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) { }<br>&gt;&gt; <br>&gt;&gt; // user writes:<br>&gt;&gt; func bar(...fooParams) {<br>&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; func bar(s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>&gt;&gt;     foo(i: 32, s: s, f: f, d: d, b: b)<br>&gt;&gt; }<br>&gt; This approach is extremely problematic and unlikely to be accepted.<br></p><p>Ok, I won’t pursue it further in that case.  Thanks for calling that out before I spent any further time on it.<br></p><p>&gt; <br>&gt; Swift is carefully designed so that the compiler can type check the interface to a function without type checking its body.  This is important for compiler scalability to large projects, IDE tooling, and also because otherwise you can run into circular dependencies to compile the code.<br></p><p>Good to know.<br></p><p>&gt; <br>&gt; Another major problem with this approach is that it only works if “foo” is unambiguous.<br></p><p>I addressed the fact that the call to foo must be unambiguous further down in the proposal.  Did I miss something important?  (Not that it matters if this approach is a dead end)<br></p><p>Do you have any ideas for a better direction that could handle forwarding of default parameter values and / or a subset of parameters?  Or is tuple packing and unpacking the best we can hope for?<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/faac6c8f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Or is tuple packing and unpacking the best we can hope for?<br></p><p>If we do go the tuple packing/unpacking route, I wonder if we can add syntax that gets the parameter and return types of a function:<br></p><p>	func fooWithLogging(*params: foo.Parameters) -&gt; foo.Return {<br>		print(&quot;Calling foo with \(params)&quot;)<br>		<br>		let value = foo(*params)<br>		<br>		print(&quot;	Returned \(value)&quot;)<br>		return value<br>	}<br></p><p>(Here I&#39;m using a Ruby/Perl 6-style splat, since we&#39;re leaning pretty heavily on `...` already.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jan 12, 2016, at 12:11 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Or is tuple packing and unpacking the best we can hope for?<br>&gt; <br>&gt; If we do go the tuple packing/unpacking route, I wonder if we can add syntax that gets the parameter and return types of a function:<br></p><p>I thought about this last night.  Something like this might also allow the default parameter values the function declares to appear in the forwarding signature.  <br></p><p>With the generalized naming proposal we could get pretty close to forwarding to any function with defaults intact.  But where types are required to disambiguate it would still not be possible.  Maybe that is an acceptable tradeoff though.<br></p><p>Matthew<br></p><p>&gt; <br>&gt;    func fooWithLogging(*params: foo.Parameters) -&gt; foo.Return {<br>&gt;        print(&quot;Calling foo with \(params)&quot;)<br>&gt;        <br>&gt;        let value = foo(*params)<br>&gt;        <br>&gt;        print(&quot;    Returned \(value)&quot;)<br>&gt;        return value<br>&gt;    }<br>&gt; <br>&gt; (Here I&#39;m using a Ruby/Perl 6-style splat, since we&#39;re leaning pretty heavily on `...` already.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>On Jan 11, 2016, at 6:00 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Another major problem with this approach is that it only works if “foo” is unambiguous.<br>&gt; <br>&gt; I addressed the fact that the call to foo must be unambiguous further down in the proposal.  Did I miss something important?  (Not that it matters if this approach is a dead end)<br></p><p>No, you have it covered.  I know you’re interested in initializer forwarding in particular, and overloaded initializers are very common, that’s why I raised it as a potential issue.<br></p><p>&gt; Do you have any ideas for a better direction that could handle forwarding of default parameter values and / or a subset of parameters?  Or is tuple packing and unpacking the best we can hope for?<br></p><p>There is no structural problems with mechanisms that take parameters and forward to other calls, e.g.:<br></p><p><br>func f(a : Int, b : Float, c : String) {<br>   bar(@@@ARGS@@@)   // obviously horrible to get the point across :-)<br>}<br></p><p>Related but different: forwarding of varargs is also a common special case.  People have wanted to do this for a long time, we just haven’t had cycles to implement it:<br></p><p>func f(a : Int, b : Float…) {<br>   g(a, …b)  // unpack the vars array into a list of parameters. <br>}<br></p><p>If we did that, I could see generalizing it to an arbitrary tuple:<br></p><p>g(x, y, …sometuple, z) <br></p><p>where sometuple’s members got passed as arguments.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt;&gt; On Jan 12, 2016, at 12:33 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 6:00 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another major problem with this approach is that it only works if “foo” is unambiguous.<br>&gt;&gt; <br>&gt;&gt; I addressed the fact that the call to foo must be unambiguous further down in the proposal.  Did I miss something important?  (Not that it matters if this approach is a dead end)<br>&gt; <br>&gt; No, you have it covered.  I know you’re interested in initializer forwarding in particular, and overloaded initializers are very common, that’s why I raised it as a potential issue.<br></p><p>Makes sense.  This is one reason I introduced identifiers in the partial initializers proposal, but certainly not the only reason.<br></p><p>It probably seems like I&#39;m obsessed with initialization by now!  I&#39;m really not.  Initialization boilerplate just happens to be the first thing I decided to work on after the open source release.  I like to see something through when I start on it. <br></p><p>&gt; <br>&gt;&gt; Do you have any ideas for a better direction that could handle forwarding of default parameter values and / or a subset of parameters?  Or is tuple packing and unpacking the best we can hope for?<br>&gt; <br>&gt; There is no structural problems with mechanisms that take parameters and forward to other calls, e.g.:<br>&gt; <br>&gt; <br>&gt; func f(a : Int, b : Float, c : String) {<br>&gt;   bar(@@@ARGS@@@)   // obviously horrible to get the point across :-)<br>&gt; }<br>&gt; <br>&gt; Related but different: forwarding of varargs is also a common special case.  People have wanted to do this for a long time, we just haven’t had cycles to implement it:<br>&gt; <br>&gt; func f(a : Int, b : Float…) {<br>&gt;   g(a, …b)  // unpack the vars array into a list of parameters. <br>&gt; }<br></p><p>I could see that being useful.  Would it have to unpack into a varargs argument since the length is not statically knowable? Valued it also work for any array of the correct type?<br></p><p>&gt; <br>&gt; If we did that, I could see generalizing it to an arbitrary tuple:<br>&gt; <br>&gt; g(x, y, …sometuple, z) <br>&gt; <br>&gt; where sometuple’s members got passed as arguments.<br></p><p>That covers cases where the subset of arguments is sequential.  I think that would address the vast majority of cases at the site of the forwarding call.<br></p><p>What do you think of the idea Brent and I discussed about being able to reference a function&#39;s parameters in a signature?  This would allow for a relatively concise way to declare a tuple to forward, and hopefully also include the default arguments.<br></p><p>If we could accomplish both of these it would go pretty far.  Would it be worth rewriting the proposal in this manner?<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 12, 2016, at 7:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Related but different: forwarding of varargs is also a common special case.  People have wanted to do this for a long time, we just haven’t had cycles to implement it:<br>&gt;&gt; <br>&gt;&gt; func f(a : Int, b : Float…) {<br>&gt;&gt;  g(a, …b)  // unpack the vars array into a list of parameters. <br>&gt;&gt; }<br>&gt; <br>&gt; I could see that being useful.  Would it have to unpack into a varargs argument since the length is not statically knowable?<br></p><p>Yes, exactly.<br></p><p>&gt;&gt; If we did that, I could see generalizing it to an arbitrary tuple:<br>&gt;&gt; <br>&gt;&gt; g(x, y, …sometuple, z) <br>&gt;&gt; <br>&gt;&gt; where sometuple’s members got passed as arguments.<br>&gt; <br>&gt; That covers cases where the subset of arguments is sequential.  I think that would address the vast majority of cases at the site of the forwarding call.<br>&gt; <br>&gt; What do you think of the idea Brent and I discussed about being able to reference a function&#39;s parameters in a signature?<br></p><p>I haven’t had a chance to keep up with the thread.  I’m still trying to figure out what to do with memberwise, and you guys are building incredibly intricate castles in the clouds :-)<br></p><p>My one meta-comment is that you should focus on making extensions to swift *small*, *obvious*, *orthogonal* and for them to pay for themselves.  In the partial function proposal for example (which I also haven’t had time to read), I saw a comment go by about parameter forwarding.  I’d strongly recommend *not* baking any notion of parameter forwarding into that proposal.  Doing so makes it more complex and more likely to be rejected.<br></p><p>If you’re interested in building a series of proposals that all work together, then that is great, but it depends on them initial proposals being *accepted* and us getting at least some experience with them first.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 12:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 12, 2016, at 7:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related but different: forwarding of varargs is also a common special case.  People have wanted to do this for a long time, we just haven’t had cycles to implement it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(a : Int, b : Float…) {<br>&gt;&gt;&gt; g(a, …b)  // unpack the vars array into a list of parameters. <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I could see that being useful.  Would it have to unpack into a varargs argument since the length is not statically knowable?<br>&gt; <br>&gt; Yes, exactly.<br>&gt; <br>&gt;&gt;&gt; If we did that, I could see generalizing it to an arbitrary tuple:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; g(x, y, …sometuple, z) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where sometuple’s members got passed as arguments.<br>&gt;&gt; <br>&gt;&gt; That covers cases where the subset of arguments is sequential.  I think that would address the vast majority of cases at the site of the forwarding call.<br>&gt;&gt; <br>&gt;&gt; What do you think of the idea Brent and I discussed about being able to reference a function&#39;s parameters in a signature?<br>&gt; <br>&gt; I haven’t had a chance to keep up with the thread.  I’m still trying to figure out what to do with memberwise, and you guys are building incredibly intricate castles in the clouds :-)<br></p><p>Well that certainly isn’t the intent.  I’m sorry if it seems that way.<br></p><p>Normally I wouldn’t have shared a bunch of early proposal drafts all at once.  I did that because I thought it would be helpful to put together new ideas / approaches that I came up with during the review.  In particular, building on more general underlying features.<br></p><p>&gt; <br>&gt; My one meta-comment is that you should focus on making extensions to swift *small*, *obvious*, *orthogonal* and for them to pay for themselves.  In the partial function proposal for example (which I also haven’t had time to read), I saw a comment go by about parameter forwarding.  I’d strongly recommend *not* baking any notion of parameter forwarding into that proposal.  Doing so makes it more complex and more likely to be rejected.<br></p><p>I included initializer forwarding in there for a couple reasons.  <br></p><p>The primary reason was to show how partial initializers + initializer forwarding + implicit memberwise partial initializers can replace the explicit memberwise initializers with more general initialization features, moving memberwise from special syntax to an identifier for an implicit partial initializer.  This seems like a win and it is hard to demonstrate if it is spread out across several proposals.<br></p><p>Here’s an example in case you didn’t look at that part of the proposal:<br></p><p>// flexibile memberwise initialization proposal:<br>memberwise init(...) {<br>  // init all private props<br>}  <br>// corresponding syntax using implicit partial init and forwarding:<br>init(…memberwise) { // memberwise is an implicit partial initializer with the `memberwise` identifier<br>  // init all private props<br>}<br>// expands to a call to the partial initializer<br>init(arg1: Type1, arg2, Type2, arg3: Type3) {<br>  memberwise.init(arg1, arg2, arg3)<br>  // init all private props<br>}<br></p><p>The secondary reason is that I think partial initializers are far more useful with initializer forwarding than without it.  In many cases the bodies of partial initializers may be relatively simple.  If you have to manually declare forwarding parameters and write the forwarding call simple partial initializers won’t gain you nearly as much.  Even when they are non-trivial, much of the time their parameters will simply be forwarded.  IMO it is a much better feature with support for initializer forwarding.<br></p><p>That said, I will remove that section if it makes the proposal more likely to be rejected.  <br></p><p>In any case, I do think partial initializers + initializer forwarding is the right long-term approach for explicit memberwise initializers as they are more general features and allow for full control over the partial memberwise initializer.<br></p><p><br>&gt; <br>&gt; If you’re interested in building a series of proposals that all work together, then that is great, but it depends on them initial proposals being *accepted* and us getting at least some experience with them first.<br></p><p>Sure.  Like I said, I shared a bunch of ideas at once because they are relevant to the memberwise init review and came out of that discussion.  If that was a mistake I won’t do it again.<br></p><p>Matthew<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal Draft] parameter forwarding</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 12 janv. 2016 à 01:33, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On Jan 11, 2016, at 6:00 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you have any ideas for a better direction that could handle forwarding of default parameter values and / or a subset of parameters?  Or is tuple packing and unpacking the best we can hope for?<br>&gt; <br>&gt; There is no structural problems with mechanisms that take parameters and forward to other calls, e.g.:<br>&gt; <br>&gt; <br>&gt; func f(a : Int, b : Float, c : String) {<br>&gt;   bar(@@@ARGS@@@)   // obviously horrible to get the point across :-)<br>&gt; }<br></p><p>Really horrible indeed, but this kind of forwarding have the advantage of not obfuscating the parameter list.<br></p><p>The magic behind the forwarding may make it faster to write code, and remove some clutter when the parameter list is exhaustive, but it may be slower to read it. Assuming, you are new to a project, and you look at the following function:<br></p><p>&gt;&gt;&gt; func bar(...fooParams, ...foo2Params)<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;     foo2(...foo2Params)<br>&gt;&gt;&gt;     foo(i: 32, ...fooParams)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br></p><p>How long does it take to find out how to invoke it? The auto-completion within Xcode can help, but what if you using a simpler text editor, or even only reading the code on the Web. In the proposal, the definitions of foo() and foo2() are closed by, but since not limitations are specified, the could be anywhere in the project requiring a possibly painful search for each of them.<br></p><p>Dany St-Amant<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
