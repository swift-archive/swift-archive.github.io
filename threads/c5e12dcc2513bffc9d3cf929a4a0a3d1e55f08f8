<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 15, 2016 at 07:00:00pm</p></header><div class="content"><p>This discussion is about a proposal for API to enumerate/count all possible<br>values of a type, particularly enums. The goal is to address potential<br>issues with an old proposal, so it can go up for review soon.<br></p><p>Core Team / Standard Library Team feedback would be particularly welcome<br>here, because we want this feature to mesh well with the goals &amp; future<br>directions that are already in mind for Swift. If any details the core team<br>would like to see are missing from the proposal, please let us know now.<br></p><p>Background reading:<br></p><p>    • 2015-12-08: &quot;List of all Enum values (for simple enums)&quot; —<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/10064<br>    • 2015-12-21: &quot;Proposal: Enum &#39;count&#39; functionality&quot;<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/644<br>    • 2016-01-17: &quot;Draft Proposal: count property for enum types&quot;<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/3678<br>    • 2016-01-18: &quot;Pre-proposal: CaseEnumerable protocol (derived collection<br>of enum cases)&quot; at<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/3701<br>    • 2016-01-20: My subsequent proposal PR #114:<br>https://github.com/apple/swift-evolution/pull/114<br></p><p>A lot has happened since then:<br></p><p>    • 2016-03-03: &quot;[Manifesto] Completing Generics&quot;<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/8484<br>    • 2016-03-03: &quot;[Accepted with modifications] SE-0023 API Design<br>Guidelines&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/8585 &amp;<br>http://apple.github.io/swift-internals/api-design-guidelines/<br>    • 2016-03-09: Brent&#39;s proposal PR #199:<br>https://github.com/apple/swift-evolution/pull/199<br></p><p>Brent brought up some great points in his proposal, but ultimately closed<br>the PR in anticipation of further discussion. I&#39;m sorry I haven&#39;t had much<br>time to put into this until now, but I&#39;d like us to get the discussion<br>going again.<br></p><p>I believe the community is in agreement about the following:<br></p><p>    • The &quot;allValues&quot; behavior should be provided by conformance to some<br>protocol, named ValueEnumerable or ValuesEnumerable or similar.<br>    • The compiler should derive an allValues implementation for &quot;simple&quot;<br>enums (those without associated values).<br></p><p>There are a couple things which we must still decide:<br></p><p>*### Should the ValueEnumerable protocol expose the allValues property, or<br>should it be an empty protocol like ErrorType (ErrorProtocol)? If exposed,<br>what is its type?*<br></p><p>If allValues were exposed as part of the protocol, then the generic<br>constraint &lt;T: ValueEnumerable&gt; could be used meaningfully, i.e. you could<br>write/use &quot;T.allValues&quot;.<br></p><p>On the other hand, the limitations of the current generics system don&#39;t<br>allow &quot;*associatedtype ValueCollection: Collection where<br>ValueCollection.Iterator.Element == Self*&quot;. Doug&#39;s *Completing<br>Generics* manifesto<br>included &quot;*Arbitrary requirements in protocols*&quot;, under the category of<br>&quot;Minor extensions&quot;, which would remove this limitation. If this gets<br>implemented, I think it makes a lot of sense to use it here.<br></p><p>Until then, though, we&#39;d have to pick a concrete type for the collection.<br>Brent proposed that it be an Array, &quot;static var allValues: [Self]&quot;.<br></p><p>The biggest reason I didn&#39;t expose allValues on the protocol was that I<br>figured we&#39;d want to allow for efficient implementations which wouldn&#39;t<br>require allocating storage for *all* the values (just the endpoints, for<br>instance), but could still count and iterate over them.<br></p><p>Another question on the subject of exposing the property as a protocol<br>requirement: What should the diagnostics look like if it&#39;s missing? Maybe<br>something like this:<br></p><p>    struct MyType: ValueEnumerable { }<br>    // error: type &#39;MyType&#39; does not conform to protocol &#39;ValueEnumerable&#39;<br>    // note: protocol requires property &#39;allValues&#39; with type &#39;[MyType]&#39;<br>    // *note: implementation of allValues cannot be automatically derived<br>for a non-enum type*<br></p><p>*### Should allValues implementations be derived for Comparable enums? What<br>if the sorted order does/doesn&#39;t match the source order?*<br></p><p>Brent has suggested the semantics of allValues should be such that for<br>Comparable types, allValues is guaranteed to be ordered. If that were the<br>case, we might not want to require the compiler to derive a ValueEnumerable<br>implementation, since the source order may not match the Comparable-sorted<br>order, and verifying this could overly complicate things. (I think I&#39;m in<br>agreement here: having the values be ordered is a good implementation of<br>the principle of least surprise.)<br></p><p><br>Thoughts welcome.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/c5e108f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 16, 2016 at 12:00:00pm</p></header><div class="content"><p>I would suggest that ValuesEnumerable should expose allValues and the type<br>of allValues should be a custom OptionSet implementation that iterates in<br>declaration order. I base this preference on Java, that does exactly this<br>and it works well in my experience.<br></p><p>On Saturday, 16 April 2016, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This discussion is about a proposal for API to enumerate/count all<br>&gt; possible values of a type, particularly enums. The goal is to address<br>&gt; potential issues with an old proposal, so it can go up for review soon.<br>&gt;<br>&gt; Core Team / Standard Library Team feedback would be particularly welcome<br>&gt; here, because we want this feature to mesh well with the goals &amp; future<br>&gt; directions that are already in mind for Swift. If any details the core team<br>&gt; would like to see are missing from the proposal, please let us know now.<br>&gt;<br>&gt; Background reading:<br>&gt;<br>&gt;     • 2015-12-08: &quot;List of all Enum values (for simple enums)&quot; —<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/10064<br>&gt;     • 2015-12-21: &quot;Proposal: Enum &#39;count&#39; functionality&quot;<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/644<br>&gt;     • 2016-01-17: &quot;Draft Proposal: count property for enum types&quot;<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/3678<br>&gt;     • 2016-01-18: &quot;Pre-proposal: CaseEnumerable protocol (derived collection<br>&gt; of enum cases)&quot; at<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/3701<br>&gt;     • 2016-01-20: My subsequent proposal PR #114:<br>&gt; https://github.com/apple/swift-evolution/pull/114<br>&gt;<br>&gt; A lot has happened since then:<br>&gt;<br>&gt;     • 2016-03-03: &quot;[Manifesto] Completing Generics&quot;<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/8484<br>&gt;     • 2016-03-03: &quot;[Accepted with modifications] SE-0023 API Design<br>&gt; Guidelines&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/8585<br>&gt; &amp; http://apple.github.io/swift-internals/api-design-guidelines/<br>&gt;     • 2016-03-09: Brent&#39;s proposal PR #199:<br>&gt; https://github.com/apple/swift-evolution/pull/199<br>&gt;<br>&gt; Brent brought up some great points in his proposal, but ultimately closed<br>&gt; the PR in anticipation of further discussion. I&#39;m sorry I haven&#39;t had much<br>&gt; time to put into this until now, but I&#39;d like us to get the discussion<br>&gt; going again.<br>&gt;<br>&gt; I believe the community is in agreement about the following:<br>&gt;<br>&gt;     • The &quot;allValues&quot; behavior should be provided by conformance to some<br>&gt; protocol, named ValueEnumerable or ValuesEnumerable or similar.<br>&gt;     • The compiler should derive an allValues implementation for &quot;simple&quot;<br>&gt; enums (those without associated values).<br>&gt;<br>&gt; There are a couple things which we must still decide:<br>&gt;<br>&gt; *### Should the ValueEnumerable protocol expose the allValues property, or<br>&gt; should it be an empty protocol like ErrorType (ErrorProtocol)? If exposed,<br>&gt; what is its type?*<br>&gt;<br>&gt; If allValues were exposed as part of the protocol, then the generic<br>&gt; constraint &lt;T: ValueEnumerable&gt; could be used meaningfully, i.e. you could<br>&gt; write/use &quot;T.allValues&quot;.<br>&gt;<br>&gt; On the other hand, the limitations of the current generics system don&#39;t<br>&gt; allow &quot;*associatedtype ValueCollection: Collection where<br>&gt; ValueCollection.Iterator.Element == Self*&quot;. Doug&#39;s *Completing Generics* manifesto<br>&gt; included &quot;*Arbitrary requirements in protocols*&quot;, under the category of<br>&gt; &quot;Minor extensions&quot;, which would remove this limitation. If this gets<br>&gt; implemented, I think it makes a lot of sense to use it here.<br>&gt;<br>&gt; Until then, though, we&#39;d have to pick a concrete type for the collection.<br>&gt; Brent proposed that it be an Array, &quot;static var allValues: [Self]&quot;.<br>&gt;<br>&gt; The biggest reason I didn&#39;t expose allValues on the protocol was that I<br>&gt; figured we&#39;d want to allow for efficient implementations which wouldn&#39;t<br>&gt; require allocating storage for *all* the values (just the endpoints, for<br>&gt; instance), but could still count and iterate over them.<br>&gt;<br>&gt; Another question on the subject of exposing the property as a protocol<br>&gt; requirement: What should the diagnostics look like if it&#39;s missing? Maybe<br>&gt; something like this:<br>&gt;<br>&gt;     struct MyType: ValueEnumerable { }<br>&gt;     // error: type &#39;MyType&#39; does not conform to protocol &#39;ValueEnumerable&#39;<br>&gt;     // note: protocol requires property &#39;allValues&#39; with type &#39;[MyType]&#39;<br>&gt;     // *note: implementation of allValues cannot be automatically derived<br>&gt; for a non-enum type*<br>&gt;<br>&gt; *### Should allValues implementations be derived for Comparable enums?<br>&gt; What if the sorted order does/doesn&#39;t match the source order?*<br>&gt;<br>&gt; Brent has suggested the semantics of allValues should be such that for<br>&gt; Comparable types, allValues is guaranteed to be ordered. If that were the<br>&gt; case, we might not want to require the compiler to derive a ValueEnumerable<br>&gt; implementation, since the source order may not match the Comparable-sorted<br>&gt; order, and verifying this could overly complicate things. (I think I&#39;m in<br>&gt; agreement here: having the values be ordered is a good implementation of<br>&gt; the principle of least surprise.)<br>&gt;<br>&gt;<br>&gt; Thoughts welcome.<br>&gt;<br>&gt; Jacob<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/578b4043/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; I would suggest that ValuesEnumerable should expose allValues and the type of allValues should be a custom OptionSet implementation that iterates in declaration order.<br></p><p>That would make sense if OptionSet were a generic type which took any integer-ish RawRepresentable (which I&#39;ve advocated before, although I sort of understand why we haven&#39;t gone that route), but it isn&#39;t, so I don&#39;t think that makes a lot of sense for Swift.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 17, 2016 at 09:00:00am</p></header><div class="content"><p>Re. OptionSetType<br></p><p>If you wrote:<br></p><p>    enum Ex { case one, two, three }<br></p><p>The compiler could do:<br></p><p><br>   - struct Ex : OptionSetType<br>   &lt;http://swiftdoc.org/v2.2/protocol/OptionSetType&gt; {<br>   -   private let weight: Int &lt;http://swiftdoc.org/v2.2/type/Int&gt;<br>   -   private init(_ weight: Int &lt;http://swiftdoc.org/v2.2/type/Int&gt;) {<br>   self.weight = weight }<br>   -<br>   -   static let one = Ex(1)<br>   -   static let two = Ex(2)<br>   -   static let three = Ex(4)<br>   -   static let values: Ex = [one, two, three]<br>   - }<br></p><p><br>Plus the compiler would have to allow statics to have their type inferred,<br>i.e. you write .one and the compiler infers Ex.one.<br></p><p>This would allow set behaviour which I found very handy in Java.<br></p><p>PS Int only applicable for &lt; 64 cases. Need BigInt for others.<br></p><p>On Saturday, 16 April 2016, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I would suggest that ValuesEnumerable should expose allValues and the<br>&gt; type of allValues should be a custom OptionSet implementation that iterates<br>&gt; in declaration order.<br>&gt;<br>&gt; That would make sense if OptionSet were a generic type which took any<br>&gt; integer-ish RawRepresentable (which I&#39;ve advocated before, although I sort<br>&gt; of understand why we haven&#39;t gone that route), but it isn&#39;t, so I don&#39;t<br>&gt; think that makes a lot of sense for Swift.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/88f7de3f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 16, 2016 at 03:00:00am</p></header><div class="content"><p>&gt;     • The &quot;allValues&quot; behavior should be provided by conformance to some protocol, named ValueEnumerable or ValuesEnumerable or similar.<br>&gt;     • The compiler should derive an allValues implementation for &quot;simple&quot; enums (those without associated values).<br></p><p>Agreed on my part.<br></p><p>(I favor &quot;Values&quot; because &quot;Value&quot; in the singular implies to me that you can take a single value and enumerate it somehow, which is not what I have in mind.)<br></p><p>&gt; If allValues were exposed as part of the protocol, then the generic constraint &lt;T: ValueEnumerable&gt; could be used meaningfully, i.e. you could write/use &quot;T.allValues&quot;.<br>&gt; <br>&gt; On the other hand, the limitations of the current generics system don&#39;t allow &quot;associatedtype ValueCollection: Collection where ValueCollection.Iterator.Element == Self&quot;. Doug&#39;s Completing Generics manifesto included &quot;Arbitrary requirements in protocols&quot;, under the category of &quot;Minor extensions&quot;, which would remove this limitation. If this gets implemented, I think it makes a lot of sense to use it here.<br></p><p>Yes. I see some metaprogramming potential in being able to pass just a type and enumerate its values. For instance, you could say how far &quot;through&quot; a type that particular value lies, using nothing but an instance of it.<br></p><p>&gt; Until then, though, we&#39;d have to pick a concrete type for the collection. Brent proposed that it be an Array, &quot;static var allValues: [Self]&quot;.<br>&gt; <br>&gt; The biggest reason I didn&#39;t expose allValues on the protocol was that I figured we&#39;d want to allow for efficient implementations which wouldn&#39;t require allocating storage for *all* the values (just the endpoints, for instance), but could still count and iterate over them.<br></p><p>If the Array limitation is truly going to be temporary, I don&#39;t think the need for storage is a serious long-term problem. Especially before we start getting fancy and supporting `ValueEnumerable` associated values, each `allValues` array is going to be small.<br></p><p>(However, see below for another path forward which would allow a much smaller instance.)<br></p><p>&gt; Another question on the subject of exposing the property as a protocol requirement: What should the diagnostics look like if it&#39;s missing? Maybe something like this:<br>&gt; <br>&gt;     struct MyType: ValueEnumerable { }<br>&gt;     // error: type &#39;MyType&#39; does not conform to protocol &#39;ValueEnumerable&#39;<br>&gt;     // note: protocol requires property &#39;allValues&#39; with type &#39;[MyType]&#39;<br>&gt;     // note: implementation of allValues cannot be automatically derived for a non-enum type<br></p><p>If Swift cannot automatically derive an implementation for a particular type, I think having a diagnostic stating that, and preferably saying why, would be a great idea.<br></p><p>&gt; ### Should allValues implementations be derived for Comparable enums? What if the sorted order does/doesn&#39;t match the source order?<br>&gt; <br>&gt; Brent has suggested the semantics of allValues should be such that for Comparable types, allValues is guaranteed to be ordered. If that were the case, we might not want to require the compiler to derive a ValueEnumerable implementation, since the source order may not match the Comparable-sorted order, and verifying this could overly complicate things. (I think I&#39;m in agreement here: having the values be ordered is a good implementation of the principle of least surprise.)<br></p><p>With the impending introduction of a `Comparable` requirement on collection indices, we now have a second good reason for this: the values themselves are good candidates to index into the `allValues` collection, and they will need to be `Comparable`.<br></p><p>Incidentally, one open question is whether enums with raw values should be compared in source order or in raw value order. In other words, in:<br></p><p>	enum Foo: ValuesEnumerable {<br>		case bar = 2<br>		case baz = 1<br>	}<br></p><p>Is `Foo.allValues` equivalent to `[bar, baz]` or `[baz, bar]`? I&#39;m not certain we can always reliably sort raw values at compile time; `String` is particularly worrisome because sort order tends to depend on tables built into the OS, but even integer literals are suspect when you consider that this feature can be used to initialize *any* `IntegerLiteralConvertible` type (or `StringLiteralConvertible`, or I believe `FloatLiteralConvertible` as well). Analyzing a raw value&#39;s sort order eventually becomes equivalent to analyzing a custom Comparable implementation.<br></p><p>* * *<br></p><p>However, the new Collection proposal (SE-0065, https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md) has actually given me an interesting idea about how to build this feature out of smaller pieces.<br></p><p>Suppose we introduce a `ValuesCountable` (or maybe just `Countable`) protocol like this:<br></p><p>	protocol ValuesCountable: Strideable /* implies Comparable and Equatable */ {<br>		associatedtype Stride: SignedInteger<br>		static var allValues: CountableClosedRange&lt;Self&gt; { get }<br>	}<br></p><p>Swift already synthesizes Equatable. We could additionally have it synthesize:<br></p><p>	• A `&lt;` which compares the bit pattern (or perhaps the raw values?) to determine ordering.<br>	• A `distance(to:)` and `advanced(by:)` which operate with knowledge of the known-good values.<br>	• An `allValues` which basically amounts to just `return &lt;first case&gt;...&lt;last case&gt;`.<br></p><p>Small-scale reasons to like this approach:<br></p><p>	• It builds up the feature from individually tractable pieces.<br>	• `allValues` is only the size of the two endpoint elements, which strikes me as close to optimal. For small enums, that might only be a couple bytes.<br>	• `allValues` uses an already-written part of the standard library, so we don&#39;t have to write (or worse, synthesize) an entire collection implementation to get an efficient representation.<br></p><p>Implementation reasons to like this approach:<br></p><p>	• Derived `Comparable` is a highly desired feature in its own right. Derived `Strideable` is not as highly desired, but seems like it could be useful in some cases. Even if we don&#39;t finish `ValuesCountable` before Swift 3, those will still be on that WWDC slide with the Swift logo and forty little feature names.<br>	• We can start with really simple, really awful implementations of these derivations (for instance, `Comparable` and `Strideable` which are backed by a linearly-searched array) and improve them over time. Because they are hidden behind an API, we can continue to refine them even after Swift 3 is released.<br></p><p>Language design reasons to like it:<br></p><p>	• There is very little to this feature; it is mostly built out of other features with other uses.<br>	• It lends itself to being split up into several separate proposals, which is usually a favored approach.<br>	• `ValuesCountable` may be a good protocol for representing the bounds of other `SignedInteger`-`Strideable` types, like `Integer`. That would mean that *every* part of this (well, except the `allValues` synthesis) would have another purpose in Swift.<br></p><p>Future expansion reasons to like it:<br></p><p>	• Associated value support is *relatively* straightforward to implement; you just need more complicated `distance(to:)` and `advanced(by:)` implementations.<br>	• If we eventually gain `where` clauses on associated values, we can then choose to give `ValuesCountable` a `ValuesEnumerable` super-protocol with a broader type, like `Collection where Iterator.Element == Self`. This would allow us to represent, for instance, non-`Comparable` types without imposing an order on them (or at least, one that&#39;s only visible on an opaque index type).<br>	• If `ValuesCountable` becomes the way `Integer` expresses the range of its type, we could add a `ValuesBounded` super-protocol with a plain old `ClosedRange` for continuous types like `FloatingPoint`. (And `FloatingPoint`&#39;s `ValuesBounded` can be `-Inf...Inf`, since `nan`s never compare equal to anything anyway.)<br></p><p>To be evenhanded, here are some reasons to dislike it:<br></p><p>	• It is pretty complex, arguably even overengineered. Some people may not like the design because of this.<br>	• It lends itself to being split up into several separate proposals, which is more complex to manage; it is also possible that some proposals will pass but not others.<br>	• `ValuesCountable` is probably not the API you would design for `Integer` if you had a completely free hand. (That would probably be something simpler, like `min` and `max` static members.)<br>	• It requires you to make your type `Comparable` and `Strideable`, even if these behaviors don&#39;t make much sense for your type other than for `allValues`. That limitation will stay until associated types become more expressive.<br>	• Since `CountableClosedRange` cannot represent an empty range, you would not be able to conform a caseless enum to `ValuesCountable`, even with a custom implementation. (Caseless enums do have a couple of bizarre uses.)<br>	• We might have to bikeshed everything again.<br></p><p>(And here&#39;s one esoteric alternative which is maddeningly out of reach:<br></p><p>	• If `Foo.Type` could be conformed to `CountableClosedRangeProtocol` (or at least to a subprotocol of `Collection` which filled in the necessary implementation), you could give it `lowerBound` and `upperBound` members and then do all this without an actual `allValues` property. Instead, the type *itself* would fill the role of the range; you would say (for instance) `for value in MyEnum { ... }` and it would loop through the values of `MyEnum`.<br></p><p>However, that would require conforming the metatype to a protocol, which is not something Swift lets you do; it&#39;s such an odd feature that I don&#39;t think I&#39;ve even seen it *suggested* before. It would also populate the static namespace with all sorts of oddities from `Collection` and `Sequence`. Some (like `count`) might actually be useful in and of themselves; others (like `map`) are a little odd, but on balance sensible; a few (like `contains(_:)`, which would always be `true`) are kind of useless; and some (like the `subscript`s) are currently not allowed as static members in Swift. Not to mention the weirdness of having associated types on the metatype, and the &quot;turtles all the way down&quot; nature of the whole thing…)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Sat, Apr 16, 2016 at 3:56 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; (I favor &quot;Values&quot; because &quot;Value&quot; in the singular implies to me that you<br>&gt; can take a single value and enumerate it somehow, which is not what I have<br>&gt; in mind.)<br>&gt;<br></p><p>OK, after reading it this way long enough, I&#39;m on board with that. Anyway,<br>if this ever gets into review, it&#39;ll be subject to internal bikeshedding.<br></p><p><br>&gt;<br>&gt;<br>&gt; &gt; ### Should allValues implementations be derived for Comparable enums?<br>&gt; What if the sorted order does/doesn&#39;t match the source order?<br>&gt; &gt;<br>&gt; &gt; Brent has suggested the semantics of allValues should be such that for<br>&gt; Comparable types, allValues is guaranteed to be ordered. If that were the<br>&gt; case, we might not want to require the compiler to derive a ValueEnumerable<br>&gt; implementation, since the source order may not match the Comparable-sorted<br>&gt; order, and verifying this could overly complicate things. (I think I&#39;m in<br>&gt; agreement here: having the values be ordered is a good implementation of<br>&gt; the principle of least surprise.)<br>&gt;<br>&gt; With the impending introduction of a `Comparable` requirement on<br>&gt; collection indices, we now have a second good reason for this: the values<br>&gt; themselves are good candidates to index into the `allValues` collection,<br>&gt; and they will need to be `Comparable`.<br>&gt;<br>&gt; Incidentally, one open question is whether enums with raw values should be<br>&gt; compared in source order or in raw value order. In other words, in:<br>&gt;<br>&gt;         enum Foo: ValuesEnumerable {<br>&gt;                 case bar = 2<br>&gt;                 case baz = 1<br>&gt;         }<br>&gt;<br>&gt; Is `Foo.allValues` equivalent to `[bar, baz]` or `[baz, bar]`? I&#39;m not<br>&gt; certain we can always reliably sort raw values at compile time; `String` is<br>&gt; particularly worrisome because sort order tends to depend on tables built<br>&gt; into the OS, but even integer literals are suspect when you consider that<br>&gt; this feature can be used to initialize *any* `IntegerLiteralConvertible`<br>&gt; type (or `StringLiteralConvertible`, or I believe `FloatLiteralConvertible`<br>&gt; as well). Analyzing a raw value&#39;s sort order eventually becomes equivalent<br>&gt; to analyzing a custom Comparable implementation.<br>&gt;<br></p><p>Good questions. Although I said I liked the idea of having allValues be in<br>Comparable order, I&#39;m now leaning towards source order. It avoids extra<br>burden on the derived implementation (or on the documentation of the<br>protocol), and the user can get them in sorted() order easily if desired.<br>(However, we need to consider effects on the library evolution/resilience<br>support.)<br></p><p><br>&gt;<br>&gt; Suppose we introduce a `ValuesCountable` (or maybe just `Countable`)<br>&gt; protocol like this:<br>&gt;<br>&gt;         protocol ValuesCountable: Strideable /* implies Comparable and<br>&gt; Equatable */ {<br>&gt;                 associatedtype Stride: SignedInteger<br>&gt;                 static var allValues: CountableClosedRange&lt;Self&gt; { get }<br>&gt;         }<br>&gt;<br>&gt; Swift already synthesizes Equatable. We could additionally have it<br>&gt; synthesize:<br>&gt;<br>&gt;         • A `&lt;` which compares the bit pattern (or perhaps the raw<br>&gt; values?) to determine ordering.<br>&gt;         • A `distance(to:)` and `advanced(by:)` which operate with<br>&gt; knowledge of the known-good values.<br>&gt;         • An `allValues` which basically amounts to just `return &lt;first<br>&gt; case&gt;...&lt;last case&gt;`.<br>&gt;<br></p><p>This is an interesting idea. It&#39;s nice to think that the whole thing could<br>be built on the existing range/interval types, and I appreciate your<br>thinking through it with consideration for upcoming features/changes.<br></p><p>However, requiring (and/or synthesizing) a Comparable and Strideable<br>implementation seems like it would be overkill for most use cases, and for<br>some enums it may not be appropriate to require either one.<br></p><p>I&#39;d like to see these ideas (or this whole feature) revisited after the<br>Swift 3 changes to collections/iterators and generics have settled down,<br>but IMO this is beyond what we should be shooting for as an initial version.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/fac9c98e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 16, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 9:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This discussion is about a proposal for API to enumerate/count all possible values of a type, particularly enums. The goal is to address potential issues with an old proposal, so it can go up for review soon.<br>&gt; <br>&gt; Core Team / Standard Library Team feedback would be particularly welcome here, because we want this feature to mesh well with the goals &amp; future directions that are already in mind for Swift. If any details the core team would like to see are missing from the proposal, please let us know now.<br>&gt; <br>&gt; Background reading:<br>&gt; <br>&gt;     • 2015-12-08: &quot;List of all Enum values (for simple enums)&quot; — http://thread.gmane.org/gmane.comp.lang.swift.evolution/10064 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10064&gt;<br>&gt;     • 2015-12-21: &quot;Proposal: Enum &#39;count&#39; functionality&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/644 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/644&gt;<br>&gt;     • 2016-01-17: &quot;Draft Proposal: count property for enum types&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/3678 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/3678&gt;<br>&gt;     • 2016-01-18: &quot;Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)&quot; at http://thread.gmane.org/gmane.comp.lang.swift.evolution/3701 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/3701&gt;<br>&gt;     • 2016-01-20: My subsequent proposal PR #114: https://github.com/apple/swift-evolution/pull/114 &lt;https://github.com/apple/swift-evolution/pull/114&gt;<br>&gt; <br>&gt; A lot has happened since then:<br>&gt; <br>&gt;     • 2016-03-03: &quot;[Manifesto] Completing Generics&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/8484 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8484&gt;<br>&gt;     • 2016-03-03: &quot;[Accepted with modifications] SE-0023 API Design Guidelines&quot; http://thread.gmane.org/gmane.comp.lang.swift.evolution/8585 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8585&gt; &amp; http://apple.github.io/swift-internals/api-design-guidelines/ &lt;http://apple.github.io/swift-internals/api-design-guidelines/&gt;<br>&gt;     • 2016-03-09: Brent&#39;s proposal PR #199: https://github.com/apple/swift-evolution/pull/199 &lt;https://github.com/apple/swift-evolution/pull/199&gt;<br>&gt; <br>&gt; Brent brought up some great points in his proposal, but ultimately closed the PR in anticipation of further discussion. I&#39;m sorry I haven&#39;t had much time to put into this until now, but I&#39;d like us to get the discussion going again.<br>&gt; <br>&gt; I believe the community is in agreement about the following:<br>&gt; <br>&gt;     • The &quot;allValues&quot; behavior should be provided by conformance to some protocol, named ValueEnumerable or ValuesEnumerable or similar.<br>&gt;     • The compiler should derive an allValues implementation for &quot;simple&quot; enums (those without associated values).<br>&gt; <br>&gt; There are a couple things which we must still decide:<br>&gt; <br>&gt; ### Should the ValueEnumerable protocol expose the allValues property, or should it be an empty protocol like ErrorType (ErrorProtocol)? If exposed, what is its type?<br></p><p># General Remarks<br></p><p>My 2c is that if this is to go in the standard library, it should be done “right”, which would be more like this version of it:<br></p><p>protocol ValueEnumerable {<br>  associatedtype ValueCollection : Collection where ValueCollection.Iterator.Element == Self<br>  static var allValues: ValueCollection<br>}<br></p><p>…and that this concept should simply *wait* for that feature to be available before going into the standard library. <br></p><p>The reason I say this is simply b/c it sounds like this proposal wants to be able to support more than simple enumerations, in which case having some flexibility in the representation seems appropriate. Consider e.g.:<br></p><p>  struct AxisPolicy3D&lt;Policy:protocol&lt;Equatable,ValueEnumerable&gt;&gt; {<br>    var x: Policy<br>    var y: Policy<br>    var z: Policy<br>  }<br></p><p>  extension AxisPolicy3D : ValueEnumerable {<br></p><p>    static let allValues: ValueCollection = product(Policy.allValues,Policy.allValues,Policy.allValues).lazy.map() { <br>        (x,y,z) <br>        in<br>        AxisPolicy3D(x: x, y: y, z: z)<br>    }<br></p><p>  }<br></p><p>…and similar, wherein the cost of *requiring* an array here could become rather large.<br></p><p>But I have a couple general concerns here:<br></p><p># Resiliency <br></p><p>My understanding is that the design for resiliency vis-a-vis enumerations is meant to allow enumerations to have cases added in future revisions (and perhaps also private cases? I didn’t follow resiliency closely). <br></p><p>If that’s right, and this protocol is supposed to go into the standard library, it might also need to address such issues. I have no help to offer and would love to be wrong about this point.<br></p><p># Scope (or: Beyond Simple Enumerations?)<br></p><p>On the one hand, I don’t see any reason *not* to design the protocol so that it *could* be adopted by types other than simple enumerations. <br></p><p>On the other hand, I think the value of having this in place for simple-enumerations is huge, and I’m more than a bit skeptical how often it’ll actually make sense for anything other than simple-enumerations—it’s easy to come with other types that could support it, I just think they’re somewhat rare in practice! <br></p><p>To me, this leaves me thinking that trying to support non-simple enumerations is a nice-to-have, but something I’d be willing to drop if it posed any real difficulties.<br></p><p># Ordering<br></p><p>I have mixed feelings here. For comparable values I think it’d be nice if `allValues` was ordered, but I think that gets in the way of synthesis if you also support types other than simple-enumerations; I am admittedly skeptical about trying to support such types, but there you have it.<br></p><p>If you are willing to go there, you can include something like <br></p><p>  protocol ComparableValueEnumerable : Comparable, ValueEnumerable {<br></p><p>    associatedtype OrderedValueCollection: Collection where OrderedValueCollection.Iterator.Element == Self<br>    static var allValuesInOrder: OrderedValueCollection { get }<br>  }<br></p><p>…which would be the same as the basic protocol but guarantees the values are enumerated in order.<br></p><p>For compiler-synthesized enumerations for suitable types this could simply return `allValues`.<br></p><p># Synthesis<br></p><p>Related to the above, compiler synthesis is great, but given the lack of similar synthesis for other types I wouldn’t want to require—or expect—too much here.<br></p><p>EG if limited to simple enumerations I could easily see the compiler’s synthesis rule be:<br></p><p>- user supplied `allValues`? go with that!<br>- otherwise:<br>  - define `allValues` to be equivalent-to `Range&lt;RawValue&gt;.lazy.map() { Self(rawValue: $0)! }` when possible (*)<br>  - otherwise, define `allValues` as an array<br></p><p>…as something along those lines seems reasonable to implement and to understand as a user.<br></p><p>(*) “Possible” is something like `RawRepresentable`, the `RawValue` type is `Comparable`, the enumeration cases occupy a contiguous range of `RawValue` values, and (trickier!) if comparable, `Comparable` ordering is the same as the ordering derived-from the raw values.<br></p><p># Other Remarks<br></p><p>I see the `CaseEnumerable` discussion in the other discussion. It’s certainly related, but it’s something with enough independent utility I wouldn’t want it to get “lost” in this topic (especially since I think this topic is a great feature for the language, but one that may be awhile coming). <br></p><p>&gt; <br>&gt; If allValues were exposed as part of the protocol, then the generic constraint &lt;T: ValueEnumerable&gt; could be used meaningfully, i.e. you could write/use &quot;T.allValues&quot;.<br>&gt; <br>&gt; On the other hand, the limitations of the current generics system don&#39;t allow &quot;associatedtype ValueCollection: Collection where ValueCollection.Iterator.Element == Self&quot;. Doug&#39;s Completing Generics manifesto included &quot;Arbitrary requirements in protocols&quot;, under the category of &quot;Minor extensions&quot;, which would remove this limitation. If this gets implemented, I think it makes a lot of sense to use it here.<br>&gt; <br>&gt; Until then, though, we&#39;d have to pick a concrete type for the collection. Brent proposed that it be an Array, &quot;static var allValues: [Self]&quot;.<br>&gt; <br>&gt; The biggest reason I didn&#39;t expose allValues on the protocol was that I figured we&#39;d want to allow for efficient implementations which wouldn&#39;t require allocating storage for *all* the values (just the endpoints, for instance), but could still count and iterate over them.<br>&gt; <br>&gt; Another question on the subject of exposing the property as a protocol requirement: What should the diagnostics look like if it&#39;s missing? Maybe something like this:<br>&gt; <br>&gt;     struct MyType: ValueEnumerable { }<br>&gt;     // error: type &#39;MyType&#39; does not conform to protocol &#39;ValueEnumerable&#39;<br>&gt;     // note: protocol requires property &#39;allValues&#39; with type &#39;[MyType]&#39;<br>&gt;     // note: implementation of allValues cannot be automatically derived for a non-enum type<br>&gt; <br>&gt; ### Should allValues implementations be derived for Comparable enums? What if the sorted order does/doesn&#39;t match the source order?<br>&gt; <br>&gt; Brent has suggested the semantics of allValues should be such that for Comparable types, allValues is guaranteed to be ordered. If that were the case, we might not want to require the compiler to derive a ValueEnumerable implementation, since the source order may not match the Comparable-sorted order, and verifying this could overly complicate things. (I think I&#39;m in agreement here: having the values be ordered is a good implementation of the principle of least surprise.)<br>&gt; <br>&gt; <br>&gt; Thoughts welcome.<br>&gt; <br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/6ed37a4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 22, 2016 at 10:00:00pm</p></header><div class="content"><p>On Sat, Apr 16, 2016 at 5:20 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; My 2c is that if this is to go in the standard library, it should be done<br>&gt; “right”, which would be more like this version of it:<br>&gt;<br>&gt; protocol ValueEnumerable {<br>&gt;   associatedtype ValueCollection : Collection where<br>&gt; ValueCollection.Iterator.Element == Self<br>&gt;   static var allValues: ValueCollection<br>&gt; }<br>&gt;<br>&gt; …and that this concept should simply *wait* for that feature to be<br>&gt; available before going into the standard library.<br>&gt;<br>&gt; The reason I say this is simply b/c it sounds like this proposal wants to<br>&gt; be able to support more than simple enumerations, in which case having some<br>&gt; flexibility in the representation seems appropriate. Consider e.g.:<br>&gt;<br>&gt;   struct AxisPolicy3D&lt;Policy:protocol&lt;Equatable,ValueEnumerable&gt;&gt; {<br>&gt;     var x: Policy<br>&gt;     var y: Policy<br>&gt;     var z: Policy<br>&gt;   }<br>&gt;<br>&gt;   extension AxisPolicy3D : ValueEnumerable {<br>&gt;<br>&gt;     static let allValues: ValueCollection =<br>&gt; product(Policy.allValues,Policy.allValues,Policy.allValues).lazy.map() {<br>&gt;         (x,y,z)<br>&gt;         in<br>&gt;         AxisPolicy3D(x: x, y: y, z: z)<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; …and similar, wherein the cost of *requiring* an array here could become<br>&gt; rather large.<br>&gt;<br>&gt; But I have a couple general concerns here:<br>&gt;<br>&gt; # Resiliency<br>&gt;<br>&gt; My understanding is that the design for resiliency vis-a-vis enumerations<br>&gt; is meant to allow enumerations to have cases added in future revisions (and<br>&gt; perhaps also private cases? I didn’t follow resiliency closely).<br>&gt;<br>&gt; If that’s right, and this protocol is supposed to go into the standard<br>&gt; library, it might also need to address such issues. I have no help to offer<br>&gt; and would love to be wrong about this point.<br>&gt;<br></p><p>Thank you for bringing this up; I hadn&#39;t thought about it. Indeed, the<br>library evolution design document &lt;<br>http://jrose-apple.github.io/swift-library-evolution/#enums&gt; states that<br>adding new cases, adding raw types, and reordering cases should be<br>binary-compatible changes.<br></p><p>I hope someone who knows more about the resilience design can weigh in<br>here. I&#39;ll CC Jordan Rose and John McCall, authors of that document, on<br>this email.<br></p><p>I think you&#39;re right that the implications of requiring an array might be<br>significant, if this array is exported as public API in a module which<br>other binaries depend on. So I wonder if it might be possible to pursue a<br>solution which *doesn&#39;t* export any additional public API in a module.<br></p><p>Recall that we&#39;d like to be able to add ValuesEnumerable support in an<br>extension, both on Swift enums and on enums imported from Obj-C. Seems like<br>you might *not* want those conformances to be exported, so that future<br>changes in the type of allValues wouldn&#39;t have to break existing compiled<br>binaries. (But currently, IIUC, extensions which add protocol conformances<br>must be public.)<br></p><p>I&#39;m almost wondering whether we should be doing something like<br>*#allValues(MyEnum)*, which uses # to indicate &quot;compiler magic&quot; (for now it<br>would produce an Array&lt;MyEnum&gt;), gathering the available cases from the<br>module at compile time. At some time in the future, when reflection is much<br>more mature, perhaps this could be replaced with a standard library<br>function.<br></p><p>---<br></p><p>This also prompted me to research Java&#39;s implementation a bit more. I&#39;m not<br>a Java user, let alone expert, but here&#39;s what I found:<br></p><p>Class.getEnumConstants() returns the values *in source order*.  &lt;<br>https://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html&gt;<br>The page also says the following:<br></p><p>*Note: For various reasons, including support for evolution of the enum<br>type, the declaration order of enum constants is important.<br>Class.getFields() and Class.getDeclaredFields() do not make any guarantee<br>that the order of the returned values matches the order in the declaring<br>source code. If ordering is required by an application, use<br>Class.getEnumConstants().*<br></p><p>There&#39;s also a section on &quot;Evolution of Enums&quot; in this page about Binary<br>Compatibility: &lt;<br>https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.26&gt;<br> *&quot;Adding<br>or reordering constants in an enum type will not break compatibility with<br>pre-existing binaries.&quot;*<br></p><p>Point being that getEnumConstants() always returns an array, it just might<br>have different things in it depending on the version of the class you&#39;re<br>interrogating.<br></p><p><br># Other Remarks<br>&gt;<br>&gt; I see the `CaseEnumerable` discussion in the other discussion. It’s<br>&gt; certainly related, but it’s something with enough independent utility I<br>&gt; wouldn’t want it to get “lost” in this topic (especially since I think this<br>&gt; topic is a great feature for the language, but one that may be awhile<br>&gt; coming).<br>&gt;<br></p><p>CaseEnumerable was just an earlier name for Value(s)Enumerable. The stuff<br>in the &quot;Future directions&quot; section remains speculative. I think we should<br>keep the proposal focused if we want it to ever happen; improvements can<br>come later.<br></p><p><br>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/3bce9fb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 10:18 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; On Sat, Apr 16, 2016 at 5:20 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; My 2c is that if this is to go in the standard library, it should be done “right”, which would be more like this version of it:<br>&gt; <br>&gt; protocol ValueEnumerable {<br>&gt;   associatedtype ValueCollection : Collection where ValueCollection.Iterator.Element == Self<br>&gt;   static var allValues: ValueCollection<br>&gt; }<br>&gt; <br>&gt; …and that this concept should simply *wait* for that feature to be available before going into the standard library. <br>&gt; <br>&gt; The reason I say this is simply b/c it sounds like this proposal wants to be able to support more than simple enumerations, in which case having some flexibility in the representation seems appropriate. Consider e.g.:<br>&gt; <br>&gt;   struct AxisPolicy3D&lt;Policy:protocol&lt;Equatable,ValueEnumerable&gt;&gt; {<br>&gt;     var x: Policy<br>&gt;     var y: Policy<br>&gt;     var z: Policy<br>&gt;   }<br>&gt; <br>&gt;   extension AxisPolicy3D : ValueEnumerable {<br>&gt; <br>&gt;     static let allValues: ValueCollection = product(Policy.allValues,Policy.allValues,Policy.allValues).lazy.map() { <br>&gt;         (x,y,z) <br>&gt;         in<br>&gt;         AxisPolicy3D(x: x, y: y, z: z)<br>&gt;     }<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …and similar, wherein the cost of *requiring* an array here could become rather large.<br>&gt; <br>&gt; But I have a couple general concerns here:<br>&gt; <br>&gt; # Resiliency <br>&gt; <br>&gt; My understanding is that the design for resiliency vis-a-vis enumerations is meant to allow enumerations to have cases added in future revisions (and perhaps also private cases? I didn’t follow resiliency closely). <br>&gt; <br>&gt; If that’s right, and this protocol is supposed to go into the standard library, it might also need to address such issues. I have no help to offer and would love to be wrong about this point.<br>&gt; <br>&gt; Thank you for bringing this up; I hadn&#39;t thought about it. Indeed, the library evolution design document &lt;http://jrose-apple.github.io/swift-library-evolution/#enums &lt;http://jrose-apple.github.io/swift-library-evolution/#enums&gt;&gt; states that adding new cases, adding raw types, and reordering cases should be binary-compatible changes.<br>&gt; <br>&gt; I hope someone who knows more about the resilience design can weigh in here. I&#39;ll CC Jordan Rose and John McCall, authors of that document, on this email.<br>&gt; <br>&gt; I think you&#39;re right that the implications of requiring an array might be significant, if this array is exported as public API in a module which other binaries depend on. So I wonder if it might be possible to pursue a solution which doesn&#39;t export any additional public API in a module.<br>&gt; <br>&gt; Recall that we&#39;d like to be able to add ValuesEnumerable support in an extension, both on Swift enums and on enums imported from Obj-C. Seems like you might not want those conformances to be exported, so that future changes in the type of allValues wouldn&#39;t have to break existing compiled binaries. (But currently, IIUC, extensions which add protocol conformances must be public.)<br>&gt; <br>&gt; I&#39;m almost wondering whether we should be doing something like #allValues(MyEnum), which uses # to indicate &quot;compiler magic&quot; (for now it would produce an Array&lt;MyEnum&gt;), gathering the available cases from the module at compile time. At some time in the future, when reflection is much more mature, perhaps this could be replaced with a standard library function.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; This also prompted me to research Java&#39;s implementation a bit more. I&#39;m not a Java user, let alone expert, but here&#39;s what I found:<br>&gt; <br>&gt; Class.getEnumConstants() returns the values in source order.  &lt;https://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html &lt;https://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html&gt;&gt; The page also says the following: <br>&gt; <br>&gt; Note: For various reasons, including support for evolution of the enum type, the declaration order of enum constants is important. Class.getFields() and Class.getDeclaredFields() do not make any guarantee that the order of the returned values matches the order in the declaring source code. If ordering is required by an application, use Class.getEnumConstants().<br>&gt;  <br>&gt; There&#39;s also a section on &quot;Evolution of Enums&quot; in this page about Binary Compatibility: &lt;https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.26 &lt;https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.26&gt;&gt;  &quot;Adding or reordering constants in an enum type will not break compatibility with pre-existing binaries.&quot;<br>&gt; <br>&gt; Point being that getEnumConstants() always returns an array, it just might have different things in it depending on the version of the class you&#39;re interrogating.<br>&gt;  <br>&gt; <br>&gt; # Other Remarks<br>&gt; <br>&gt; I see the `CaseEnumerable` discussion in the other discussion. It’s certainly related, but it’s something with enough independent utility I wouldn’t want it to get “lost” in this topic (especially since I think this topic is a great feature for the language, but one that may be awhile coming). <br>&gt; <br>&gt; CaseEnumerable was just an earlier name for Value(s)Enumerable. The stuff in the &quot;Future directions&quot; section remains speculative. I think we should keep the proposal focused if we want it to ever happen; improvements can come later.<br></p><p>I have not been following this discussion, but I would be extremely antsy about guaranteeing any particular representation for the set of values.  Guaranteeing a contiguous array implementation seems like a really bad idea, especially if that&#39;s taken to mean that we&#39;re going to actually provide a static global array.  But there&#39;s no way to avoid providing a public API, because a public conformance itself implies a public API with some level of corresponding overhead.<br></p><p>I don&#39;t remember the details of Java enums from my days as a Java programmer, but reading between the lines of your description, it sounds to me like Java originally made overly-strong guarantees that it decided to walk back in a later release.  That&#39;s a lesson we should heed.<br></p><p>The interaction of resilience with enums is in principle quite straightforward: you ought to be able to arbitrarily change the set of stored cases for a resilient enum.  That includes adding cases, changing existing cases to be &quot;computed&quot;, and so on.  (We haven&#39;t yet designed what it ought to mean for a case to be computed, but I assume it at least means providing an injector (Payload -&gt; Enum) and a projector (Enum -&gt; Payload?); whether and how to allow computed cases to factor into exhaustiveness checking is a separate but crucial question.)  The fundamental problem for features like this is that adding a case with a payload is not compatible with actually being enumerable, outside of special cases and/or some formal-but-useless notion of recursive enumerability.  But even if you couldn&#39;t add new cases with payloads (which is something we might consider adding as an intermediate opt-in constraint), and thus the type was necessarily finite, I can&#39;t imagine wanting to promise to return a static global array.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/b8bf642f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 22, 2016 at 11:00:00pm</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 10:50 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; I have not been following this discussion, but I would be extremely antsy<br>&gt; about guaranteeing any particular representation for the set of values.<br>&gt; Guaranteeing a contiguous array implementation seems like a really bad<br>&gt; idea, especially if that&#39;s taken to mean that we&#39;re going to actually<br>&gt; provide a static global array.  But there&#39;s no way to avoid providing a<br>&gt; public API, because a public conformance itself implies a public API with<br>&gt; some level of corresponding overhead.<br>&gt;<br></p><p>A &quot;compiler magic&quot; version of the feature, like #allValues(MyEnum), could<br>generate a static array *internal* to the caller&#39;s module, but I&#39;m sure<br>there are implications or details of this which I&#39;m not aware of.<br></p><p><br>&gt;<br>&gt; I don&#39;t remember the details of Java enums from my days as a Java<br>&gt; programmer, but reading between the lines of your description, it sounds to<br>&gt; me like Java originally made overly-strong guarantees that it decided to<br>&gt; walk back in a later release.  That&#39;s a lesson we should heed.<br>&gt;<br></p><p>Maybe I missed something, but that&#39;s not how I interpreted it. The<br>guarantee was/is simply that getEnumConstants() returns the values in<br>source order. If the class being loaded changes (excuse my Java ignorance<br>if that&#39;s the wrong terminology), you may end up with different results at<br>runtime, but it&#39;s still an array of the values in the order they&#39;re defined<br>in the class. Of course, Java enums seem to be much simpler (they can have<br>payloads/members, but the values are fixed for the cases you define at<br>compile-time).<br></p><p>I just noticed there&#39;s a MyEnum.values() method too, but it seems to do the<br>same thing as getEnumConstants(). &lt;<br>http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html&gt;<br></p><p><br>&gt;<br>&gt; The interaction of resilience with enums is in principle quite<br>&gt; straightforward: you ought to be able to arbitrarily change the set of<br>&gt; stored cases for a resilient enum.  That includes adding cases, changing<br>&gt; existing cases to be &quot;computed&quot;, and so on.  (We haven&#39;t yet designed what<br>&gt; it ought to mean for a case to be computed, but I assume it at least means<br>&gt; providing an injector (Payload -&gt; Enum) and a projector (Enum -&gt; Payload?);<br>&gt; whether and how to allow computed cases to factor into exhaustiveness<br>&gt; checking is a separate but crucial question.)  The fundamental problem for<br>&gt; features like this is that adding a case with a payload is not compatible<br>&gt; with actually being enumerable, outside of special cases and/or some<br>&gt; formal-but-useless notion of recursive enumerability.  But even if you<br>&gt; couldn&#39;t add new cases with payloads (which is something we might consider<br>&gt; adding as an intermediate opt-in constraint), and thus the type was<br>&gt; necessarily finite, I can&#39;t imagine wanting to promise to return a static<br>&gt; global array.<br>&gt;<br></p><p>Non-&quot;simple&quot; enums (those with cases with payloads, generic enums, etc.)<br>are out of scope for this proposal. There are multiple ways in which you<br>might want them to be &quot;enumerable&quot;, and anyway, it seems like a job for<br>better reflection. There&#39;s some discussion in the &quot;Future directions&quot;<br>section at the bottom (which I&#39;ll probably remove): &lt;<br>https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;<br> For now we&#39;d like to start with something simple but functional.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/20a788a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 11:11 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 10:50 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; I have not been following this discussion, but I would be extremely antsy about guaranteeing any particular representation for the set of values.  Guaranteeing a contiguous array implementation seems like a really bad idea, especially if that&#39;s taken to mean that we&#39;re going to actually provide a static global array.  But there&#39;s no way to avoid providing a public API, because a public conformance itself implies a public API with some level of corresponding overhead.<br>&gt; <br>&gt; A &quot;compiler magic&quot; version of the feature, like #allValues(MyEnum), could generate a static array *internal* to the caller&#39;s module, but I&#39;m sure there are implications or details of this which I&#39;m not aware of.<br></p><p>That cannot be reconciled with resilience.  The caller cannot reliably know the set of stored cases; only the defining module can.<br></p><p>For similar reasons, only the defining module can be allowed to magically derive a conformance to your protocol, if indeed it&#39;s done with a protocol.<br></p><p>&gt; I don&#39;t remember the details of Java enums from my days as a Java programmer, but reading between the lines of your description, it sounds to me like Java originally made overly-strong guarantees that it decided to walk back in a later release.  That&#39;s a lesson we should heed.<br>&gt; <br>&gt; Maybe I missed something, but that&#39;s not how I interpreted it. The guarantee was/is simply that getEnumConstants() returns the values in source order. If the class being loaded changes (excuse my Java ignorance if that&#39;s the wrong terminology), you may end up with different results at runtime, but it&#39;s still an array of the values in the order they&#39;re defined in the class. Of course, Java enums seem to be much simpler (they can have payloads/members, but the values are fixed for the cases you define at compile-time).<br></p><p>I see.  Yes, they&#39;re just saying that getEnumConstants makes a stronger guarantee.<br></p><p>&gt; I just noticed there&#39;s a MyEnum.values() method too, but it seems to do the same thing as getEnumConstants(). &lt;http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html &lt;http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html&gt;&gt;<br></p><p>Note that getEnumConstants() has to create a new array every time, since Java arrays are mutable and have reference semantics.<br></p><p>&gt; The interaction of resilience with enums is in principle quite straightforward: you ought to be able to arbitrarily change the set of stored cases for a resilient enum.  That includes adding cases, changing existing cases to be &quot;computed&quot;, and so on.  (We haven&#39;t yet designed what it ought to mean for a case to be computed, but I assume it at least means providing an injector (Payload -&gt; Enum) and a projector (Enum -&gt; Payload?); whether and how to allow computed cases to factor into exhaustiveness checking is a separate but crucial question.)  The fundamental problem for features like this is that adding a case with a payload is not compatible with actually being enumerable, outside of special cases and/or some formal-but-useless notion of recursive enumerability.  But even if you couldn&#39;t add new cases with payloads (which is something we might consider adding as an intermediate opt-in constraint), and thus the type was necessarily finite, I can&#39;t imagine wanting to promise to return a static global array.<br>&gt; <br>&gt; Non-&quot;simple&quot; enums (those with cases with payloads, generic enums, etc.) are out of scope for this proposal. There are multiple ways in which you might want them to be &quot;enumerable&quot;, and anyway, it seems like a job for better reflection. There&#39;s some discussion in the &quot;Future directions&quot; section at the bottom (which I&#39;ll probably remove): &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;&gt;  For now we&#39;d like to start with something simple but functional.<br></p><p>I have no idea why you&#39;re ruling out generic enums if you&#39;re ruling out enums with payloads.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/72d41e4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 22, 2016 at 11:00:00pm</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 11:34 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Apr 22, 2016, at 11:11 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 10:50 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I have not been following this discussion, but I would be extremely antsy<br>&gt;&gt; about guaranteeing any particular representation for the set of values.<br>&gt;&gt; Guaranteeing a contiguous array implementation seems like a really bad<br>&gt;&gt; idea, especially if that&#39;s taken to mean that we&#39;re going to actually<br>&gt;&gt; provide a static global array.  But there&#39;s no way to avoid providing a<br>&gt;&gt; public API, because a public conformance itself implies a public API with<br>&gt;&gt; some level of corresponding overhead.<br>&gt;&gt;<br>&gt;<br>&gt; A &quot;compiler magic&quot; version of the feature, like #allValues(MyEnum), could<br>&gt; generate a static array *internal* to the caller&#39;s module, but I&#39;m sure<br>&gt; there are implications or details of this which I&#39;m not aware of.<br>&gt;<br>&gt;<br>&gt; That cannot be reconciled with resilience.  The caller cannot reliably<br>&gt; know the set of stored cases; only the defining module can.<br>&gt;<br>&gt; For similar reasons, only the defining module can be allowed to magically<br>&gt; derive a conformance to your protocol, if indeed it&#39;s done with a protocol.<br>&gt;<br></p><p>What should/can this mean for enums imported from Obj-C, via other modules,<br>or bridging headers / custom module maps? In these cases, the defining<br>module has no Swift code. Is there a way to do it with pre-existing<br>metadata in the module?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/11f45350/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 11:48 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 11:34 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Apr 22, 2016, at 11:11 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Fri, Apr 22, 2016 at 10:50 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have not been following this discussion, but I would be extremely antsy about guaranteeing any particular representation for the set of values.  Guaranteeing a contiguous array implementation seems like a really bad idea, especially if that&#39;s taken to mean that we&#39;re going to actually provide a static global array.  But there&#39;s no way to avoid providing a public API, because a public conformance itself implies a public API with some level of corresponding overhead.<br>&gt;&gt; <br>&gt;&gt; A &quot;compiler magic&quot; version of the feature, like #allValues(MyEnum), could generate a static array *internal* to the caller&#39;s module, but I&#39;m sure there are implications or details of this which I&#39;m not aware of.<br>&gt; <br>&gt; That cannot be reconciled with resilience.  The caller cannot reliably know the set of stored cases; only the defining module can.<br>&gt; <br>&gt; For similar reasons, only the defining module can be allowed to magically derive a conformance to your protocol, if indeed it&#39;s done with a protocol.<br>&gt; <br>&gt; What should/can this mean for enums imported from Obj-C, via other modules, or bridging headers / custom module maps? In these cases, the defining module has no Swift code. Is there a way to do it with pre-existing metadata in the module?<br></p><p>Imported declarations are always something of a special case for this sort of thing.<br></p><p>It is possible to import an enum as &quot;open&quot;, meaning that the library reserves the right to add new enumerators; it would never be possible to make such a type ValuesEnumerable, at least via the built-in magic.  But otherwise we could certainly give imported enums this conformance by default if we wanted to.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/a6b75296/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 24, 2016 at 07:00:00am</p></header><div class="content"><p>If you wrote:<br></p><p>    enum Ex { case one, two, three }<br></p><p>And the compiler translated that into the equivalent of:<br></p><p><br>   - struct Ex : OptionSetType<br>   &lt;http://swiftdoc.org/v2.2/protocol/OptionSetType&gt; {<br>   -   let rawValue: UInt &lt;http://swiftdoc.org/v2.2/type/Int&gt;<br>   -   init(rawValue: UInt &lt;http://swiftdoc.org/v2.2/type/Int&gt;) { self<br>   .rawValue = rawValue }<br>   -<br>   -   static let one = Ex(rawValue: 1)<br>   -   static let two = Ex(rawValue: 2)<br>   -   static let three = Ex(rawValue: 4)<br>   -   static let values: Ex = [one, two, three]<br>   - }<br></p><p><br>This would allow set behaviour which I found very handy in Java and be as<br>robust as any other option set.<br></p><p>PS Int only applicable for &lt; 64 cases. Need BigInt for others.<br></p><p>On Sunday, 24 April 2016, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Apr 22, 2016, at 11:48 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jtbandes at gmail.com&#39;);&gt;&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 11:34 PM, John McCall &lt;rjmccall at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rjmccall at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; On Apr 22, 2016, at 11:11 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jtbandes at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt; On Fri, Apr 22, 2016 at 10:50 PM, John McCall &lt;rjmccall at apple.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rjmccall at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have not been following this discussion, but I would be extremely<br>&gt;&gt;&gt; antsy about guaranteeing any particular representation for the set of<br>&gt;&gt;&gt; values.  Guaranteeing a contiguous array implementation seems like a really<br>&gt;&gt;&gt; bad idea, especially if that&#39;s taken to mean that we&#39;re going to actually<br>&gt;&gt;&gt; provide a static global array.  But there&#39;s no way to avoid providing a<br>&gt;&gt;&gt; public API, because a public conformance itself implies a public API with<br>&gt;&gt;&gt; some level of corresponding overhead.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A &quot;compiler magic&quot; version of the feature, like #allValues(MyEnum), could<br>&gt;&gt; generate a static array *internal* to the caller&#39;s module, but I&#39;m sure<br>&gt;&gt; there are implications or details of this which I&#39;m not aware of.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That cannot be reconciled with resilience.  The caller cannot reliably<br>&gt;&gt; know the set of stored cases; only the defining module can.<br>&gt;&gt;<br>&gt;&gt; For similar reasons, only the defining module can be allowed to magically<br>&gt;&gt; derive a conformance to your protocol, if indeed it&#39;s done with a protocol.<br>&gt;&gt;<br>&gt;<br>&gt; What should/can this mean for enums imported from Obj-C, via other<br>&gt; modules, or bridging headers / custom module maps? In these cases, the<br>&gt; defining module has no Swift code. Is there a way to do it with<br>&gt; pre-existing metadata in the module?<br>&gt;<br>&gt;<br>&gt; Imported declarations are always something of a special case for this sort<br>&gt; of thing.<br>&gt;<br>&gt; It is possible to import an enum as &quot;open&quot;, meaning that the library<br>&gt; reserves the right to add new enumerators; it would never be possible to<br>&gt; make such a type ValuesEnumerable, at least via the built-in magic.  But<br>&gt; otherwise we could certainly give imported enums this conformance by<br>&gt; default if we wanted to.<br>&gt;<br>&gt; John.<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/d687759e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On 16.04.2016 5:00, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; I believe the community is in agreement about the following:<br>&gt;<br>&gt;     • The &quot;allValues&quot; behavior should be provided by conformance to some<br>&gt; protocol, named ValueEnumerable or ValuesEnumerable or similar.<br>&gt;     • The compiler should derive an allValues implementation for &quot;simple&quot;<br>&gt; enums (those without associated values).<br></p><p>Please let me add my 2 cents. (Unfortunately can&#39;t support discussion on <br>suggested level, sorry for some simplicity)<br></p><p>I believe first of all we need a easy to use method to iterate enum cases <br>_without_ the need of manually specify each of case value in code for this.<br></p><p>I believe this is a huge problem we have now with enums. Ar at least Swift <br>compiler should force us to specify each of case values in such array.<br></p><p>I mean that we can now implement this allValues by just introduce an array <br>constant in enum{} declaration &quot;manually&quot;. _But_ we need to change this <br>array accordingly each time we add new or change order of &#39;cases&#39;  in our <br>enum. And right now this is the place where we most likely will have errors <br>with forgotten values/wrong order.<br></p><p>Should we add extra complexity to Swift to implement the solution? I&#39;m not <br>sure.<br>Can&#39;t compiler &quot;just&quot; generate some kind of<br>static let allValues : [Self] = [firstCase, secondCase, ..]<br>for each enum(and only enum)? Should we introduce a dozen of <br>protocols,extensions etc to implement such a solution just for enums?<br></p><p>enum ZZZ {<br>     case One, Two<br></p><p>     // this can be auto-generated<br>     static let allValues: [ZZZ] = [.One, .Two]<br>}<br></p><p>As for generic enums, the best I can implement right now, is calculated <br>property:<br></p><p>enum AAA&lt;T,Z&gt; {<br>     case One, Two   // somehow T,Z is used here, not important<br></p><p>     // I believe this could be also auto-generated<br>     static var allValues : [AAA&lt;T,Z&gt;]  { return [.One, .Two] }<br>}<br></p><p>As for the order of elements in allValues, IMO this order should be exactly <br>as defined in enum. We can know the Raw value for specified enum case <br>value, when we have it. But we can&#39;t say the defined position/index of enum <br>case if we&#39;ll have allValues ordered by raw value.<br></p><p>enum ZZZ: Int {<br>     case One = 3, Two = 1<br></p><p>     // autogenerated:<br>     //static let allValues: [ZZZ] = [.One, .Two]<br>}<br></p><p>print(ZZZ.allValues) =&gt; [One, Two]<br>print(ZZZ.allValues[0].rawValue)  =&gt; 3<br></p><p>if allValues will return [Two, One], we can&#39;t find out how these cases was <br>declared in our enum. I.e. in first case we have a solution(sort by <br>rawValue), in second case - we have no solution.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry, if was discussed earlier, tried to find in conversations in this <br>thread but didn&#39;t find:<br></p><p>Could someone please briefly describe why &quot;community is in agreement&quot; - <br>&quot;The &quot;allValues&quot; behavior should be provided by conformance to some protocol&quot; ?<br>I mean, what is purpose of the protocol? What else, other than allValues <br>for enums, could be implemented with such protocol? How it will be <br>used?(Like to see a possible code sample)<br></p><p>How I think about this feature: we have &quot;simple&quot; enums(.First, .Second, <br>.Third), we have enums with &quot;raw&quot; values(.First = 1) and we have &quot;complex&quot; <br>enums like<br>enum E&lt;T&gt; {<br>     case First(Int,T)<br>     case Second(SomeStruct)<br>}<br></p><p>What we need? We need to be able to iterate over all declared cases in <br>enum. Often we needs to pre-create some resources depending on what &#39;kind&#39; <br>of values(and their count) could be in enum.<br></p><p>Let&#39;s take this &quot;complex&quot; E&lt;T&gt; enum.<br>IMO we need to be able to have such code:<br></p><p>let columns = Columns(count: E&lt;Int&gt;.allValues.count)<br></p><p>for e in E&lt;Int&gt;.allValues {<br>   switch e { // &lt;&lt; here is a problem for complex enums, it can&#39;t return <br>actial enum value as assotiated values are not known (Int,T)/SomeStruct<br>// but there is no problem for &quot;simple&quot; enums to return actual value here<br></p><p>     case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>     case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br></p><p>     // !!! no &#39;default:&#39; here : this will protect us if E is changed<br>   }<br>}<br></p><p>As I understand, to be able to iterate &#39;complex&#39; enums we need some new <br>type related to enum. I mean what exactly are &quot;.First&quot; and &quot;.Second&quot; that <br>are specified inside &#39;switch&#39;? I.e. what is placed by compiler inside <br>&#39;switch&#39; as &quot;.First&quot; and as &quot;.Second&quot;? What hidden property of e is <br>compared with these &quot;.First&quot; and &quot;.Second&quot; ?<br></p><p>Here is the code:<br></p><p>var e : E&lt;String&gt; = .First(1, &quot;str&quot;)<br>switch e { // e is compared in run-time<br>     case .First : print(&quot;first&quot;)   // e is a concrete value of &#39;complex&#39; <br>enum, but we can compare just &#39;.First&#39; about it. So, .First does not create <br>an instance of E&lt;String&gt;, it is some &#39;special&#39; value<br></p><p>     case .Second : print(&quot;second&quot;)<br>}<br></p><p>It seems like we need some &#39;magic&#39; EnumCase type and some compiler changes <br>to be able to write some kind of this:<br></p><p>for e in E&lt;Int&gt;.allCases { // e is EnumCase, we have need .allCases<br>   switch e {<br></p><p>// here compiler allows to use our EnumCase to get a general &#39;kind&#39; of<br>defined cases in enum<br>// i.e. &#39;e&#39; contains the same value(and only this value) that compiler <br>internally stores in &#39;switch&#39; now (in code above)<br></p><p>     case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>     case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br></p><p>     // !!! no &#39;default&#39; here, it is important!<br>     // because of this we need compiler magic insted of checking some<br>     // function like E&lt;Int&gt;.caseIf(from: .First) as function will require<br>     // a &#39;default:&#39; clause.<br>   }<br>}<br></p><p>As for &#39;simple&#39; enums - they can be iterated without such special <br>&#39;EnumCase&#39; type, but for consistency probably could be implemented in the <br>same way. Or for &#39;complex&#39; enums we need such a special case.<br></p><p>As for ordering, it is clear for me that we need order items in allValues <br>exactly as defined in code. We always can have rawValue from enum, but <br>can&#39;t get enum definition order by rawValue.<br></p><p>Opinions?<br>Please let me know if something is incorrect in my reasoning<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>...1 month passes...<br></p><p>On Mon, Apr 25, 2016 at 8:31 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry, if was discussed earlier, tried to find in conversations in this<br>&gt; thread but didn&#39;t find:<br>&gt;<br>&gt; Could someone please briefly describe why &quot;community is in agreement&quot; -<br>&gt; &quot;The &quot;allValues&quot; behavior should be provided by conformance to some<br>&gt; protocol&quot; ?<br>&gt; I mean, what is purpose of the protocol? What else, other than allValues<br>&gt; for enums, could be implemented with such protocol? How it will be<br>&gt; used?(Like to see a possible code sample)<br>&gt;<br></p><p>Whether the `allValues` property should be exposed as a protocol<br>requirement was one of the main questions I brought up at the beginning of<br>this thread.<br></p><p>Personally, I&#39;m fine with ValuesEnumerable being a &quot;magic protocol&quot; like<br>ErrorProtocol, because the most important use case is being able to write<br>e.g. `NSTextAlignment.allValues` with a compiler-provided implementation. A<br>proper associatedtype declaration can come later, once generics are mature<br>enough.<br></p><p><br>&gt; How I think about this feature: we have &quot;simple&quot; enums(.First, .Second,<br>&gt; .Third), we have enums with &quot;raw&quot; values(.First = 1) and we have &quot;complex&quot;<br>&gt; enums like<br>&gt; enum E&lt;T&gt; {<br>&gt;     case First(Int,T)<br>&gt;     case Second(SomeStruct)<br>&gt; }<br>&gt;<br>&gt; What we need? We need to be able to iterate over all declared cases in<br>&gt; enum. Often we needs to pre-create some resources depending on what &#39;kind&#39;<br>&gt; of values(and their count) could be in enum.<br>&gt;<br>&gt; Let&#39;s take this &quot;complex&quot; E&lt;T&gt; enum.<br>&gt; IMO we need to be able to have such code:<br>&gt;<br>&gt; let columns = Columns(count: E&lt;Int&gt;.allValues.count)<br>&gt;<br>&gt; for e in E&lt;Int&gt;.allValues {<br>&gt;   switch e { // &lt;&lt; here is a problem for complex enums, it can&#39;t return<br>&gt; actial enum value as assotiated values are not known (Int,T)/SomeStruct<br>&gt; // but there is no problem for &quot;simple&quot; enums to return actual value here<br>&gt;<br>&gt;     case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>&gt;     case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br>&gt;<br>&gt;     // !!! no &#39;default:&#39; here : this will protect us if E is changed<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; As I understand, to be able to iterate &#39;complex&#39; enums we need some new<br>&gt; type related to enum. I mean what exactly are &quot;.First&quot; and &quot;.Second&quot; that<br>&gt; are specified inside &#39;switch&#39;? I.e. what is placed by compiler inside<br>&gt; &#39;switch&#39; as &quot;.First&quot; and as &quot;.Second&quot;? What hidden property of e is<br>&gt; compared with these &quot;.First&quot; and &quot;.Second&quot; ?<br>&gt;<br>&gt; Here is the code:<br>&gt;<br>&gt; var e : E&lt;String&gt; = .First(1, &quot;str&quot;)<br>&gt; switch e { // e is compared in run-time<br>&gt;     case .First : print(&quot;first&quot;)   // e is a concrete value of &#39;complex&#39;<br>&gt; enum, but we can compare just &#39;.First&#39; about it. So, .First does not create<br>&gt; an instance of E&lt;String&gt;, it is some &#39;special&#39; value<br>&gt;<br>&gt;     case .Second : print(&quot;second&quot;)<br>&gt; }<br>&gt;<br>&gt; It seems like we need some &#39;magic&#39; EnumCase type and some compiler changes<br>&gt; to be able to write some kind of this:<br>&gt;<br>&gt; for e in E&lt;Int&gt;.allCases { // e is EnumCase, we have need .allCases<br>&gt;   switch e {<br>&gt;<br>&gt; // here compiler allows to use our EnumCase to get a general &#39;kind&#39; of<br>&gt; defined cases in enum<br>&gt; // i.e. &#39;e&#39; contains the same value(and only this value) that compiler<br>&gt; internally stores in &#39;switch&#39; now (in code above)<br>&gt;<br>&gt;     case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>&gt;     case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br>&gt;<br>&gt;     // !!! no &#39;default&#39; here, it is important!<br>&gt;     // because of this we need compiler magic insted of checking some<br>&gt;     // function like E&lt;Int&gt;.caseIf(from: .First) as function will require<br>&gt;     // a &#39;default:&#39; clause.<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; As for &#39;simple&#39; enums - they can be iterated without such special<br>&gt; &#39;EnumCase&#39; type, but for consistency probably could be implemented in the<br>&gt; same way. Or for &#39;complex&#39; enums we need such a special case.<br>&gt;<br>&gt; As for ordering, it is clear for me that we need order items in allValues<br>&gt; exactly as defined in code. We always can have rawValue from enum, but<br>&gt; can&#39;t get enum definition order by rawValue.<br>&gt;<br>&gt; Opinions?<br>&gt; Please let me know if something is incorrect in my reasoning<br></p><p><br>Your reasoning is correct. This proposal was only intended to handle the<br>&quot;simple&quot; case, because having a good solution for the simple case sooner,<br>rather than waiting for a *perfect* solution much later, seems like a good<br>idea to me.<br></p><p><br>To me, it seems that a &quot;magic protocol&quot; with no public requirements,<br>producing an internal (non-resilient) static array, is a reasonable<br>solution that *might* be able to fit into the Swift 3 timeframe, and I<br>think that&#39;d be a huge boon to language users. I also don&#39;t think it<br>precludes further improvements.<br></p><p>Do others agree? Disagree? Is it definitely out of scope for Swift 3<br>regardless of the approach we choose?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/cf8ad024/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Personally, I&#39;m fine with ValuesEnumerable being a &quot;magic protocol&quot; like<br> &gt; ErrorProtocol, because the most important use case is being able to write<br> &gt; e.g. `NSTextAlignment.allValues` with a compiler-provided implementation. A<br> &gt; proper associatedtype declaration can come later, once generics are mature<br> &gt; enough.<br></p><p>OK. Agree.<br></p><p> &gt; Your reasoning is correct. This proposal was only intended to handle the<br> &gt; &quot;simple&quot; case, because having a good solution for the simple case sooner,<br> &gt; rather than waiting for a *perfect* solution much later, seems like a good<br> &gt; idea to me.<br></p><p>Support this opinion. We can introduce such a protocol now in 3.0 and <br>implementation for &#39;simple&#39; enums and then (3.x or 4) extent it to <br>&#39;complex&#39; enums.<br></p><p><br>Btw, I also think we need some .next/.prev properties for cases(i.e. var <br>emotion = Emotions.sad; emotion = emotion.next // will be &#39;.neutral&#39;, then <br>`.happy`). As even with `.allValues` you need to write a code to find <br>current case in that array, then return next case. But probably this could <br>be introduced later.<br></p><p><br>On 24.05.2016 9:37, Jacob Bandes-Storch wrote:<br>&gt; ...1 month passes...<br>&gt;<br>&gt; On Mon, Apr 25, 2016 at 8:31 AM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Sorry, if was discussed earlier, tried to find in conversations in this<br>&gt;     thread but didn&#39;t find:<br>&gt;<br>&gt;     Could someone please briefly describe why &quot;community is in agreement&quot; -<br>&gt;     &quot;The &quot;allValues&quot; behavior should be provided by conformance to some<br>&gt;     protocol&quot; ?<br>&gt;     I mean, what is purpose of the protocol? What else, other than<br>&gt;     allValues for enums, could be implemented with such protocol? How it<br>&gt;     will be used?(Like to see a possible code sample)<br>&gt;<br>&gt;<br>&gt; Whether the `allValues` property should be exposed as a protocol<br>&gt; requirement was one of the main questions I brought up at the beginning of<br>&gt; this thread.<br>&gt;<br>&gt; Personally, I&#39;m fine with ValuesEnumerable being a &quot;magic protocol&quot; like<br>&gt; ErrorProtocol, because the most important use case is being able to write<br>&gt; e.g. `NSTextAlignment.allValues` with a compiler-provided implementation. A<br>&gt; proper associatedtype declaration can come later, once generics are mature<br>&gt; enough.<br>&gt;<br>&gt;<br>&gt;     How I think about this feature: we have &quot;simple&quot; enums(.First, .Second,<br>&gt;     .Third), we have enums with &quot;raw&quot; values(.First = 1) and we have<br>&gt;     &quot;complex&quot; enums like<br>&gt;     enum E&lt;T&gt; {<br>&gt;         case First(Int,T)<br>&gt;         case Second(SomeStruct)<br>&gt;     }<br>&gt;<br>&gt;     What we need? We need to be able to iterate over all declared cases in<br>&gt;     enum. Often we needs to pre-create some resources depending on what<br>&gt;     &#39;kind&#39; of values(and their count) could be in enum.<br>&gt;<br>&gt;     Let&#39;s take this &quot;complex&quot; E&lt;T&gt; enum.<br>&gt;     IMO we need to be able to have such code:<br>&gt;<br>&gt;     let columns = Columns(count: E&lt;Int&gt;.allValues.count)<br>&gt;<br>&gt;     for e in E&lt;Int&gt;.allValues {<br>&gt;       switch e { // &lt;&lt; here is a problem for complex enums, it can&#39;t return<br>&gt;     actial enum value as assotiated values are not known (Int,T)/SomeStruct<br>&gt;     // but there is no problem for &quot;simple&quot; enums to return actual value here<br>&gt;<br>&gt;         case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>&gt;         case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br>&gt;<br>&gt;         // !!! no &#39;default:&#39; here : this will protect us if E is changed<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;     As I understand, to be able to iterate &#39;complex&#39; enums we need some new<br>&gt;     type related to enum. I mean what exactly are &quot;.First&quot; and &quot;.Second&quot;<br>&gt;     that are specified inside &#39;switch&#39;? I.e. what is placed by compiler<br>&gt;     inside &#39;switch&#39; as &quot;.First&quot; and as &quot;.Second&quot;? What hidden property of e<br>&gt;     is compared with these &quot;.First&quot; and &quot;.Second&quot; ?<br>&gt;<br>&gt;     Here is the code:<br>&gt;<br>&gt;     var e : E&lt;String&gt; = .First(1, &quot;str&quot;)<br>&gt;     switch e { // e is compared in run-time<br>&gt;         case .First : print(&quot;first&quot;)   // e is a concrete value of<br>&gt;     &#39;complex&#39; enum, but we can compare just &#39;.First&#39; about it. So, .First<br>&gt;     does not create an instance of E&lt;String&gt;, it is some &#39;special&#39; value<br>&gt;<br>&gt;         case .Second : print(&quot;second&quot;)<br>&gt;     }<br>&gt;<br>&gt;     It seems like we need some &#39;magic&#39; EnumCase type and some compiler<br>&gt;     changes to be able to write some kind of this:<br>&gt;<br>&gt;     for e in E&lt;Int&gt;.allCases { // e is EnumCase, we have need .allCases<br>&gt;       switch e {<br>&gt;<br>&gt;     // here compiler allows to use our EnumCase to get a general &#39;kind&#39; of<br>&gt;     defined cases in enum<br>&gt;     // i.e. &#39;e&#39; contains the same value(and only this value) that compiler<br>&gt;     internally stores in &#39;switch&#39; now (in code above)<br>&gt;<br>&gt;         case .First : columns.newColumn(titled: &quot;First&quot;, color: red)<br>&gt;         case .Second : columns.newColumn(titled: &quot;Second&quot;, color: blue)<br>&gt;<br>&gt;         // !!! no &#39;default&#39; here, it is important!<br>&gt;         // because of this we need compiler magic insted of checking some<br>&gt;         // function like E&lt;Int&gt;.caseIf(from: .First) as function will require<br>&gt;         // a &#39;default:&#39; clause.<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;     As for &#39;simple&#39; enums - they can be iterated without such special<br>&gt;     &#39;EnumCase&#39; type, but for consistency probably could be implemented in<br>&gt;     the same way. Or for &#39;complex&#39; enums we need such a special case.<br>&gt;<br>&gt;     As for ordering, it is clear for me that we need order items in<br>&gt;     allValues exactly as defined in code. We always can have rawValue from<br>&gt;     enum, but can&#39;t get enum definition order by rawValue.<br>&gt;<br>&gt;     Opinions?<br>&gt;     Please let me know if something is incorrect in my reasoning<br>&gt;<br>&gt;<br>&gt; Your reasoning is correct. This proposal was only intended to handle the<br>&gt; &quot;simple&quot; case, because having a good solution for the simple case sooner,<br>&gt; rather than waiting for a *perfect* solution much later, seems like a good<br>&gt; idea to me.<br>&gt;<br>&gt;<br>&gt; To me, it seems that a &quot;magic protocol&quot; with no public requirements,<br>&gt; producing an internal (non-resilient) static array, is a reasonable<br>&gt; solution that *might* be able to fit into the Swift 3 timeframe, and I<br>&gt; think that&#39;d be a huge boon to language users. I also don&#39;t think it<br>&gt; precludes further improvements.<br>&gt;<br>&gt; Do others agree? Disagree? Is it definitely out of scope for Swift 3<br>&gt; regardless of the approach we choose?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ValueEnumerable protocol with derived implementation for enums</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; To me, it seems that a &quot;magic protocol&quot; with no public requirements, producing an internal (non-resilient) static array, is a reasonable solution that might be able to fit into the Swift 3 timeframe, and I think that&#39;d be a huge boon to language users. I also don&#39;t think it precludes further improvements.<br></p><p>On the other hand, since resilience has been deferred, this also weakens the case for not using a tight type now, like:<br></p><p>	protocol ValuesEnumerable {<br>		static var allValues: [Self]<br>	}<br></p><p>Or:<br></p><p>	protocol ValuesEnumerable {<br>		static var allValues: AnyForwardCollection&lt;Self&gt;<br>	}<br></p><p>And then loosening the requirement once we have the generic features we need to do it. The pull request for `where` clauses on associated types has already been submitted, so if we&#39;re lucky, we might even get it by Swift 3. &lt;https://github.com/apple/swift-evolution/pull/284&gt;<br></p><p>&gt; Do others agree? Disagree? Is it definitely out of scope for Swift 3 regardless of the approach we choose?<br></p><p>I stopped thinking about this because I assumed it was now out of scope, but that is a mere assumption. If the core team thinks they can fit it in, I&#39;m all for it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
