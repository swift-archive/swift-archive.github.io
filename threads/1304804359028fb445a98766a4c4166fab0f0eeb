<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Everyone,<br></p><p>As we get deeper into the Swift 3 release cycle, we’re beginning to have a more precise understanding about what the release will shape up to be.  Ted posted details of the Swift 3 release process last week (https://swift.org/blog/swift-3-0-release-process/) and I just updated the main swift-evolution README.md file (https://github.com/apple/swift-evolution) with some updated details about the goals of Swift 3.<br></p><p>This release is shaping up to be a really phenomenal release that will redefine the feel of Swift and make a major leap towards maturing the Swift language and development experience.  We have had a focus on getting to source stability, with the forward-looking goal of making Swift 4 as source compatible with Swift 3 as we can reasonably accomplish.  It tackled API naming head on (which is one of the hardest problems in computer science [1]), made major improvements to the consistency and feel of the language, and has several nice across the board additions.<br></p><p>That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br></p><p>I expect discussion and planning for Swift 3.x and Swift 4 to start sometime around August of this year.  Until then, it is very important that we as a community stay focused on the goals of Swift 3: I’d really prefer us all to resist the urge to discuss major blue sky features for future releases.  We would also like to put a significant amount of effort into bug fixing and quality refinements as well, which means that the core team will be proactively deferring evolution proposals to later releases that don’t align with the Swift 3 goals, especially those that are strictly additive.<br></p><p>Thank you for all of the amazing community that has developed on this list, it is great to work with you all!  Let us know if you have any questions,<br></p><p>-Chris<br></p><p>[1] It is well known that the two hard problems in Computer Science are naming, cache invalidation, and off-by-one errors.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 10:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br></p><p>Oh, good! I was getting worried about that. Are there any particular topics that we should drop or discuss?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 9:29 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 16, 2016, at 10:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br>&gt; <br>&gt; Oh, good! I was getting worried about that. Are there any particular topics that we should drop or discuss?<br></p><p>The highest priority to me is to get the “little syntactic stuff” done that we want to nail down because it affects source stability.  A recent thing that came up was @noescape -&gt; @nonescaping and whether to make it the default, for example.<br></p><p>As for dropping, it is pretty clear that we are out of time for large-scope additions.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 16 May 2016, at 17:43, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 16, 2016, at 9:29 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 16, 2016, at 10:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br>&gt;&gt; <br>&gt;&gt; Oh, good! I was getting worried about that. Are there any particular topics that we should drop or discuss?<br>&gt; <br>&gt; The highest priority to me is to get the “little syntactic stuff” done that we want to nail down because it affects source stability.  A recent thing that came up was @noescape -&gt; @nonescaping and whether to make it the default, for example.<br>&gt; <br>&gt; As for dropping, it is pretty clear that we are out of time for large-scope additions.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>On May 16, 2016, at 10:38 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br></p><p>We’ll start discussing post-3.0 releases in August.  Until Swift 3 is really wound down, it is almost impossible to make forward looking plans.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 16 May 2016, at 17:43, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 16, 2016, at 9:29 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 16, 2016, at 10:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, good! I was getting worried about that. Are there any particular topics that we should drop or discuss?<br>&gt;&gt; <br>&gt;&gt; The highest priority to me is to get the “little syntactic stuff” done that we want to nail down because it affects source stability.  A recent thing that came up was @noescape -&gt; @nonescaping and whether to make it the default, for example.<br>&gt;&gt; <br>&gt;&gt; As for dropping, it is pretty clear that we are out of time for large-scope additions.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>May 17, 2016 at 02:00:00am</p></header><div class="content"><p>At what point would you consider the Linux product to be viable for<br>production server side application development. Do you think that goal has<br>been achieved in swift 3.0. Or is it going to have to wait for the ABI lock<br>down.<br></p><p>I&#39;m weighting the wisdom of possibly using Swift on linux for<br>microservices, we are comming from a modernPHP and OOP environment, and<br>many of the alternatives such as go and rust have higher impedance<br>mismatches than swift,  given the skills I have available in the<br>organisation.<br></p><p>I&#39;m interested in cross platform app development down the line, but for<br>now, I&#39;m only really interested in building out APIs with it.<br>On 17 May 2016 02:14, &quot;Chris Lattner via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On May 16, 2016, at 10:38 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; &gt; Quite sad we could not get into ABI stability for Swift 3... but are we<br>&gt; talking Swift 3.1 or 4.0?<br>&gt;<br>&gt; We’ll start discussing post-3.0 releases in August.  Until Swift 3 is<br>&gt; really wound down, it is almost impossible to make forward looking plans.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt;&gt; On 16 May 2016, at 17:43, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 16, 2016, at 9:29 AM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On May 16, 2016, at 10:18 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; That said, it is also clear at this point that some of the loftier<br>&gt; goals that we started out with aren’t going to fit into the release -<br>&gt; including some of the most important generics features needed in order to<br>&gt; lock down the ABI of the standard library. As such, the generics and ABI<br>&gt; stability goals will roll into a future release of Swift, where I expect<br>&gt; them to be the *highest* priority features to get done.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Oh, good! I was getting worried about that. Are there any particular<br>&gt; topics that we should drop or discuss?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The highest priority to me is to get the “little syntactic stuff” done<br>&gt; that we want to nail down because it affects source stability.  A recent<br>&gt; thing that came up was @noescape -&gt; @nonescaping and whether to make it the<br>&gt; default, for example.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As for dropping, it is pretty clear that we are out of time for<br>&gt; large-scope additions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/97a935a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 16, 2016, at 11:33 AM, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br>&gt; <br>&gt; At what point would you consider the Linux product to be viable for production server side application development. Do you think that goal has been achieved in swift 3.0. Or is it going to have to wait for the ABI lock down. <br>&gt; <br>I&#39;m not an expert in the Linux communities needs and desires.  That said, from what I understand, they don’t care at all about ABI stability, since everything is typically built from source.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/97edc10a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6c3c6af3a3702ecbe5bfa02e3d89aca?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Eric Wing</string> &lt;ewmailing at gmail.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not an expert in the Linux communities needs and desires.  That said,<br>&gt; from what I understand, they don’t care at all about ABI stability, since<br>&gt; everything is typically built from source.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br></p><p>Not exactly true. (I care.)<br></p><p>Video games (e.g. Steam/Linux) care deeply about ABI stability. And<br>Android cares deeply about ABI stability. Also, kind of emergent<br>behavior, Raspberry Pi Raspbian has kind of built a platform that<br>happens to have some ABI stability for now.<br></p><p>Thanks,<br>Eric<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 16, 2016, at 4:27 PM, Eric Wing via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m not an expert in the Linux communities needs and desires.  That said,<br>&gt;&gt; from what I understand, they don’t care at all about ABI stability, since<br>&gt;&gt; everything is typically built from source.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; Not exactly true. (I care.)<br>&gt; <br>&gt; Video games (e.g. Steam/Linux) care deeply about ABI stability. And<br>&gt; Android cares deeply about ABI stability. Also, kind of emergent<br>&gt; behavior, Raspberry Pi Raspbian has kind of built a platform that<br>&gt; happens to have some ABI stability for now.<br>&gt; <br>&gt; Thanks,<br>&gt; Eric<br></p><p>ABI stability is also central to eventually removing the need to always ship the runtime along with our binaries.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/67c904eb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 06:00:00pm</p></header><div class="content"><p>On May 16, 2016, at 2:27 PM, Eric Wing via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;m not an expert in the Linux communities needs and desires.  That said,<br>&gt;&gt; from what I understand, they don’t care at all about ABI stability, since<br>&gt;&gt; everything is typically built from source.<br>&gt; <br>&gt; Not exactly true. (I care.)<br>&gt; <br>&gt; Video games (e.g. Steam/Linux) care deeply about ABI stability. And<br>&gt; Android cares deeply about ABI stability. Also, kind of emergent<br>&gt; behavior, Raspberry Pi Raspbian has kind of built a platform that<br>&gt; happens to have some ABI stability for now.<br></p><p>Great to know, and good point.  From that perspective, a Steam/Linux project would be in the same category as an iOS or Mac app: ABI stability doesn’t matter, so long as you include a copy of the swift standard library along with the steam app itself.  I know nothing about Steam, but it seems likely that this would have been a requirement anyway, because you can’t count on the standard library already existing.<br></p><p>ABI stability starts to matter when you’re interested in combining precompiled libraries built by different parties, which are only distributed in binary form.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6c3c6af3a3702ecbe5bfa02e3d89aca?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Eric Wing</string> &lt;ewmailing at gmail.com&gt;<p>May 16, 2016 at 10:00:00pm</p></header><div class="content"><p>On 5/16/16, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On May 16, 2016, at 2:27 PM, Eric Wing via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I&#39;m not an expert in the Linux communities needs and desires.  That<br>&gt;&gt;&gt; said,<br>&gt;&gt;&gt; from what I understand, they don’t care at all about ABI stability,<br>&gt;&gt;&gt; since<br>&gt;&gt;&gt; everything is typically built from source.<br>&gt;&gt;<br>&gt;&gt; Not exactly true. (I care.)<br>&gt;&gt;<br>&gt;&gt; Video games (e.g. Steam/Linux) care deeply about ABI stability. And<br>&gt;&gt; Android cares deeply about ABI stability. Also, kind of emergent<br>&gt;&gt; behavior, Raspberry Pi Raspbian has kind of built a platform that<br>&gt;&gt; happens to have some ABI stability for now.<br>&gt;<br>&gt; Great to know, and good point.  From that perspective, a Steam/Linux project<br>&gt; would be in the same category as an iOS or Mac app: ABI stability doesn’t<br>&gt; matter, so long as you include a copy of the swift standard library along<br>&gt; with the steam app itself.  I know nothing about Steam, but it seems likely<br>&gt; that this would have been a requirement anyway, because you can’t count on<br>&gt; the standard library already existing.<br>&gt;<br></p><p>Yes. I actually filed some bug reports a few weeks ago for<br>thoughts/concerns/issues related to this.<br></p><p>&gt; ABI stability starts to matter when you’re interested in combining<br>&gt; precompiled libraries built by different parties, which are only distributed<br>&gt; in binary form.<br>&gt;<br></p><p>That is what I’m working on. I also care about Mac and iOS.<br></p><p>Thanks,<br>Eric<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 16, 2016, at 2:06 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On May 16, 2016, at 11:33 AM, Tim Hawkins &lt;tim.thawkins at gmail.com &lt;mailto:tim.thawkins at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; At what point would you consider the Linux product to be viable for production server side application development. Do you think that goal has been achieved in swift 3.0. Or is it going to have to wait for the ABI lock down. <br>&gt;&gt; <br>&gt; I&#39;m not an expert in the Linux communities needs and desires.  That said, from what I understand, they don’t care at all about ABI stability, since everything is typically built from source.<br></p><p>I think it would be more appropriate to say that the server development community generally doesn&#39;t care deeply about ABI stability (although even there I&#39;m sure there are exceptions).  There are a lot of client-side efforts that have very different requirements from that, though.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/f50dae0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 16, 2016, at 2:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 16, 2016, at 2:06 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On May 16, 2016, at 11:33 AM, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At what point would you consider the Linux product to be viable for production server side application development. Do you think that goal has been achieved in swift 3.0. Or is it going to have to wait for the ABI lock down. <br>&gt;&gt;&gt; <br>&gt;&gt; I&#39;m not an expert in the Linux communities needs and desires.  That said, from what I understand, they don’t care at all about ABI stability, since everything is typically built from source.<br>&gt; <br>&gt; I think it would be more appropriate to say that the server development community generally doesn&#39;t care deeply about ABI stability (although even there I&#39;m sure there are exceptions).  There are a lot of client-side efforts that have very different requirements from that, though.<br></p><p>Our ABI considerations are also undeniably going to be Apple-focused. Anyone serious about building a client-side Swift platform on Linux should probably vet our decisions to ensure they make sense for their purposes too.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 17, 2016 at 07:00:00am</p></header><div class="content"><p>I&#39;m speaking for myself here but I&#39;m already working independent projects in Linux here. The only missing feature to my current needs it&#39;s the implementation of NSBundle methods like load(). Any idea when we&#39;ll get those implemented?<br></p><p>- Leonardo<br></p><p>-----Original Message-----<br>From: &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎16/‎05/‎2016 06:07 PM<br>To: &quot;Tim Hawkins&quot; &lt;tim.thawkins at gmail.com&gt;<br>Cc: &quot;Tino Heth via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Winding down the Swift 3 release<br></p><p><br></p><p>On May 16, 2016, at 11:33 AM, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br></p><p><br>At what point would you consider the Linux product to be viable for production server side application development. Do you think that goal has been achieved in swift 3.0. Or is it going to have to wait for the ABI lock down.  <br>I&#39;m not an expert in the Linux communities needs and desires.  That said, from what I understand, they don’t care at all about ABI stability, since everything is typically built from source.<br></p><p><br>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/82bbb043/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br></p><p><br>Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br></p><p>Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br></p><p>I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br></p><p><br>[1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br></p><p><br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 17, 2016 at 11:00:00pm</p></header><div class="content"><p>While on the face of it, you are correct, the goals have changed dramatically, I think you are being unfair.<br></p><p>Swift 3 initial scope was determined prior to the input of the Swift Evolution community, just as it was being Open Sourced. As we have explored the language in many discussions, it has been clear there are other areas of the language that needed clean and polish before a stable ABI can be established.<br></p><p>It appears that this work is more involved than the Swift Team initially envisioned. The fact they are open to changing timelines and ensuring we get fundamentals of the language sorted is a testament to their commitment to the quality of Swift as a whole.<br></p><p>Looking at Swift 3 as compared to Swift 2, there are massive changes in the pipeline that both break source and change the language fundamentally. I think it&#39;s far too much to ask that they get this work done rushed, and also pile on ABI compatibility goals at the last minute. Do we really want to rush this and get it wrong?<br></p><p>I applaud the team in making a tough decision that these changes should come before we start working on the ABI.<br></p><p>- Rod<br></p><p>&gt; On 17 May 2016, at 10:35 PM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br>&gt; <br>&gt; <br>&gt; Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br>&gt; <br>&gt; Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br>&gt; <br>&gt; I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br>&gt; <br>&gt; <br>&gt; [1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 17, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten <br></p><p>&gt; Am 17.05.2016 um 15:38 schrieb Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; While on the face of it, you are correct, the goals have changed dramatically, I think you are being unfair.<br>&gt; <br>&gt; Swift 3 initial scope was determined prior to the input of the Swift Evolution community, just as it was being Open Sourced. As we have explored the language in many discussions, it has been clear there are other areas of the language that needed clean and polish before a stable ABI can be established.<br>&gt; <br>&gt; It appears that this work is more involved than the Swift Team initially envisioned. The fact they are open to changing timelines and ensuring we get fundamentals of the language sorted is a testament to their commitment to the quality of Swift as a whole.<br>&gt; <br>&gt; Looking at Swift 3 as compared to Swift 2, there are massive changes in the pipeline that both break source and change the language fundamentally. I think it&#39;s far too much to ask that they get this work done rushed, and also pile on ABI compatibility goals at the last minute. Do we really want to rush this and get it wrong?<br>&gt; <br>&gt; I applaud the team in making a tough decision that these changes should come before we start working on the ABI.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt;&gt; On 17 May 2016, at 10:35 PM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br>&gt;&gt; <br>&gt;&gt; Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br>&gt;&gt; <br>&gt;&gt; I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; [1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I do agree with what you are saying, but in a way it seems to also be saying that the version number set by Apple is a bit rushed. A language reaching 3.0 state and not having nailed down ABI stability sounds a lot different than Swift 0.95 or Swift 1.5 being at the same state and I do not think it would say anything bad about the language if it only hit 1.0 when it reaches ABI stability. <br></p><p>It would be sad if the argument were &quot;people would not use Swift if it were still v0.9&quot; as it brings back memories of the KDE 4.0 jump (Swift is nowhere near the unstable mess KDE 4.0 was, but they had that very same justification for using the 4.0 version number).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 17 May 2016, at 14:38, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; While on the face of it, you are correct, the goals have changed dramatically, I think you are being unfair.<br>&gt; <br>&gt; Swift 3 initial scope was determined prior to the input of the Swift Evolution community, just as it was being Open Sourced. As we have explored the language in many discussions, it has been clear there are other areas of the language that needed clean and polish before a stable ABI can be established.<br>&gt; <br>&gt; It appears that this work is more involved than the Swift Team initially envisioned. The fact they are open to changing timelines and ensuring we get fundamentals of the language sorted is a testament to their commitment to the quality of Swift as a whole.<br>&gt; <br>&gt; Looking at Swift 3 as compared to Swift 2, there are massive changes in the pipeline that both break source and change the language fundamentally. I think it&#39;s far too much to ask that they get this work done rushed, and also pile on ABI compatibility goals at the last minute. Do we really want to rush this and get it wrong?<br>&gt; <br>&gt; I applaud the team in making a tough decision that these changes should come before we start working on the ABI.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt;&gt; On 17 May 2016, at 10:35 PM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br>&gt;&gt; <br>&gt;&gt; Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br>&gt;&gt; <br>&gt;&gt; I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; [1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 17, 2016 at 12:00:00pm</p></header><div class="content"><p>With semantic versioning, the API changes would require the next version to be called 3.0. The challenge is to not attach stability/maturity ‘feelings’ to semantic version numbers.<br></p><p>I don’t think people should attach meaning to Swift being 3.0 any more than they do to Chrome being 50.0<br></p><p>If we insist 3.0 is not just a sign of an incompatible API but a sign of maturity, then we will have no releases until the “maturity” feature-set gets in. Which means we will lose a great deal of real world use and feedback into language design and evolution.<br></p><p>-DW<br></p><p>&gt; On May 17, 2016, at 12:05 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do agree with what you are saying, but in a way it seems to also be saying that the version number set by Apple is a bit rushed. A language reaching 3.0 state and not having nailed down ABI stability sounds a lot different than Swift 0.95 or Swift 1.5 being at the same state and I do not think it would say anything bad about the language if it only hit 1.0 when it reaches ABI stability. <br>&gt; <br>&gt; It would be sad if the argument were &quot;people would not use Swift if it were still v0.9&quot; as it brings back memories of the KDE 4.0 jump (Swift is nowhere near the unstable mess KDE 4.0 was, but they had that very same justification for using the 4.0 version number).<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 17 May 2016, at 14:38, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While on the face of it, you are correct, the goals have changed dramatically, I think you are being unfair.<br>&gt;&gt; <br>&gt;&gt; Swift 3 initial scope was determined prior to the input of the Swift Evolution community, just as it was being Open Sourced. As we have explored the language in many discussions, it has been clear there are other areas of the language that needed clean and polish before a stable ABI can be established.<br>&gt;&gt; <br>&gt;&gt; It appears that this work is more involved than the Swift Team initially envisioned. The fact they are open to changing timelines and ensuring we get fundamentals of the language sorted is a testament to their commitment to the quality of Swift as a whole.<br>&gt;&gt; <br>&gt;&gt; Looking at Swift 3 as compared to Swift 2, there are massive changes in the pipeline that both break source and change the language fundamentally. I think it&#39;s far too much to ask that they get this work done rushed, and also pile on ABI compatibility goals at the last minute. Do we really want to rush this and get it wrong?<br>&gt;&gt; <br>&gt;&gt; I applaud the team in making a tough decision that these changes should come before we start working on the ABI.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt;&gt; On 17 May 2016, at 10:35 PM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6c3c6af3a3702ecbe5bfa02e3d89aca?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Eric Wing</string> &lt;ewmailing at gmail.com&gt;<p>May 17, 2016 at 03:00:00pm</p></header><div class="content"><p>So I don’t mind (too much) if it takes longer to get a stable ABI. It<br>makes my life harder, but on the flip-side, I don’t want to be stuck<br>with yet another broken language and ABI. I want this done right<br>because it will be almost impossible to fix later.<br></p><p>Here’s a simple, yet tragic example: BOOL in Objective-C. We were<br>stuck with signed char instead of getting a real boolean. Back in 10.4<br>Tiger when the Intel migration was announced, I filed a bug report<br>reminding them that this was the chance to fix this. They didn’t fix<br>it, so we were stuck. Then I filed again in the 10.5 beta Leopard time<br>frame during the 64-bit transition, I filed again reminding them that<br>this should be fixed before the 64-bit ABI gets locked down. Again, it<br>wasn’t fixed so we were stuck. Then when the iOS SDK was going to<br>become public, I filed again. Still not fixed. Then armv7, still<br>nothing. Finally, for arm64, this was finally fixed. Too bad we’re<br>stuck on Mac with this probably forever.<br></p><p>Anyway, I don’t want to deal with another monstrous broken language.<br>We have enough of those already. I actually consider it a good sign<br>when languages remove features instead of add them even if it causes<br>some migration pain. And I appreciate caution about making sure things<br>are correct and good before locking down an ABI we’re probably going<br>to be stuck with for at least another decade.<br></p><p>I assume that Apple still understands the importance of ABI<br>compatibility due to the Mac heritage and now that iOS has enabled 3rd<br>party framework support. So I’m fairly confident they will eventually<br>nail down a stable ABI. I just don’t want the Swift team to forget<br>that a stable ABI is important for all the other platforms too (even<br>if those platforms are terrible at delivering this themselves).<br></p><p>Thanks,<br>Eric<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>May 17, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 3:45 PM, Eric Wing via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So I don’t mind (too much) if it takes longer to get a stable ABI. It<br>&gt; makes my life harder, but on the flip-side, I don’t want to be stuck<br>&gt; with yet another broken language and ABI. I want this done right<br>&gt; because it will be almost impossible to fix later.<br>&gt; <br>&gt; Here’s a simple, yet tragic example: BOOL in Objective-C. We were<br>&gt; stuck with signed char instead of getting a real boolean. Back in 10.4<br>&gt; Tiger when the Intel migration was announced, I filed a bug report<br>&gt; reminding them that this was the chance to fix this. They didn’t fix<br>&gt; it, so we were stuck. Then I filed again in the 10.5 beta Leopard time<br>&gt; frame during the 64-bit transition, I filed again reminding them that<br>&gt; this should be fixed before the 64-bit ABI gets locked down. Again, it<br>&gt; wasn’t fixed so we were stuck. Then when the iOS SDK was going to<br>&gt; become public, I filed again. Still not fixed. Then armv7, still<br>&gt; nothing. Finally, for arm64, this was finally fixed. Too bad we’re<br>&gt; stuck on Mac with this probably forever.<br></p><p>We apologize for the inconvenience.<br></p><p>The OS X and iOS architecture transitions demonstrate the two fundamental laws of ABI changes:<br>1. Opportunities to break ABI compatibility are rare.<br>2. Any opportunity to break ABI compatibility will suffer from severe schedule pressure.<br></p><p>The Objective-C ABIs have many problems that would have been improved with more time.<br>* We tried to get a &quot;modern&quot; ABI into i386, but the schedule was too tight and we lost time with some initial design ideas that didn&#39;t pan out. x86_64 was also a tight schedule, but much of the work was already in place from the i386 attempt so we were able to get it done.<br>* Fixing BOOL was repeatedly not quite high enough priority. <br>* The 64-bit metadata structures have at least one field that is 64-bit by accident (protocol_list_t.count). There was miscommunication between the compiler and the runtime when the design was specified, and then it was never high enough priority to coordinate a fix later.<br>* armv7 uses setjmp-longjmp exceptions instead of &quot;zero-cost&quot; exceptions because that&#39;s what GCC&#39;s arm compiler used then and we didn&#39;t have time to change it.<br>* The very first iPhone did not use a &quot;modern&quot; ABI. We knew we could break ABI compatibility at any time before 3rd party apps were supported, so we punted ABI modernization until after 1.0.<br>* Non-fragile ivars on iPhone had a fragility bug in the compiler. (You don&#39;t see non-fragile ivars doing their thing until the *second* release, except for deliberate testing. We didn&#39;t test enough.) Luckily the bad case was narrow and the miscompiled code was detectable by inspecting binaries in the App Store, so we were able to ask all of the affected apps to recompile with a fixed compiler before the next iPhoneOS version shipped.<br></p><p>If we tried to rush Swift ABI stability out the door for Swift 3 we would certainly end up with deliberate or accidental flaws like the above. Being able to take the time to get it right is a rare luxury.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/aad8f235/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 17 May 2016, at 23:45, Eric Wing via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So I don’t mind (too much) if it takes longer to get a stable ABI. It<br>&gt; makes my life harder, but on the flip-side, I don’t want to be stuck<br>&gt; with yet another broken language and ABI. I want this done right<br>&gt; because it will be almost impossible to fix later.<br>&gt; <br>&gt; Here’s a simple, yet tragic example: BOOL in Objective-C. We were<br>&gt; stuck with signed char instead of getting a real boolean. Back in 10.4<br>&gt; Tiger when the Intel migration was announced, I filed a bug report<br>&gt; reminding them that this was the chance to fix this. They didn’t fix<br>&gt; it, so we were stuck. Then I filed again in the 10.5 beta Leopard time<br>&gt; frame during the 64-bit transition, I filed again reminding them that<br>&gt; this should be fixed before the 64-bit ABI gets locked down. Again, it<br>&gt; wasn’t fixed so we were stuck. Then when the iOS SDK was going to<br>&gt; become public, I filed again. Still not fixed. Then armv7, still<br>&gt; nothing. Finally, for arm64, this was finally fixed. Too bad we’re<br>&gt; stuck on Mac with this probably forever.<br></p><p>Objective-C had a real boolean type as soon as the compiler was C99 compatible and that’s when I started using it. BOOL is a typedef that is part of the Foundation/Cocoa API, not the Objective-C ABI.<br></p><p><br>&gt; <br>&gt; Anyway, I don’t want to deal with another monstrous broken language.<br></p><p>Objective-C is not broken. It’s a fine language that has served the Apple development community for at least 15 years. It has quirks and problems but it is fit for purpose. The first binary I compiled in 64 bit mode will still run on my current OS X 10.11 laptop. Swift is already vastly nicer to program in but if I was a PHB trying to decide whether to invest in Swift skills for the future, things like “unstable ABI” and “source code breaking changes for Swift 3” would be colouring my opinion now and not in a good way.<br></p><p>I’d rather have a good language that is fit for production than one that is promised to be theoretically perfect at some as yet undefined future date.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 19, 2016 at 07:00:00am</p></header><div class="content"><p>On Thu, May 19, 2016, at 02:33 AM, Jeremy Pereira via swift-evolution<br>wrote:<br>&gt; <br>&gt; &gt; On 17 May 2016, at 23:45, Eric Wing via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; So I don’t mind (too much) if it takes longer to get a stable ABI. It<br>&gt; &gt; makes my life harder, but on the flip-side, I don’t want to be stuck<br>&gt; &gt; with yet another broken language and ABI. I want this done right<br>&gt; &gt; because it will be almost impossible to fix later.<br>&gt; &gt; <br>&gt; &gt; Here’s a simple, yet tragic example: BOOL in Objective-C. We were<br>&gt; &gt; stuck with signed char instead of getting a real boolean. Back in 10.4<br>&gt; &gt; Tiger when the Intel migration was announced, I filed a bug report<br>&gt; &gt; reminding them that this was the chance to fix this. They didn’t fix<br>&gt; &gt; it, so we were stuck. Then I filed again in the 10.5 beta Leopard time<br>&gt; &gt; frame during the 64-bit transition, I filed again reminding them that<br>&gt; &gt; this should be fixed before the 64-bit ABI gets locked down. Again, it<br>&gt; &gt; wasn’t fixed so we were stuck. Then when the iOS SDK was going to<br>&gt; &gt; become public, I filed again. Still not fixed. Then armv7, still<br>&gt; &gt; nothing. Finally, for arm64, this was finally fixed. Too bad we’re<br>&gt; &gt; stuck on Mac with this probably forever.<br>&gt; <br>&gt; Objective-C had a real boolean type as soon as the compiler was C99<br>&gt; compatible and that’s when I started using it. BOOL is a typedef that is<br>&gt; part of the Foundation/Cocoa API, not the Objective-C ABI.<br>&gt; <br>&gt; <br>&gt; &gt; <br>&gt; &gt; Anyway, I don’t want to deal with another monstrous broken language.<br>&gt; <br>&gt; Objective-C is not broken. It’s a fine language that has served the Apple<br>&gt; development community for at least 15 years. It has quirks and problems<br>&gt; but it is fit for purpose. The first binary I compiled in 64 bit mode<br>&gt; will still run on my current OS X 10.11 laptop. Swift is already vastly<br>&gt; nicer to program in but if I was a PHB trying to decide whether to invest<br>&gt; in Swift skills for the future, things like “unstable ABI” and “source<br>&gt; code breaking changes for Swift 3” would be colouring my opinion now and<br>&gt; not in a good way.<br>&gt; <br>&gt; I’d rather have a good language that is fit for production than one that<br>&gt; is promised to be theoretically perfect at some as yet undefined future<br>&gt; date.<br></p><p>Much like people are expressing relief that the compatibility goals for<br>the language are not being dictated by specific timelines, I would be<br>wholly concerned if any of Swift&#39;s goals were being defined by winning<br>the short-term favor of business people.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>In the end it is just a version number.<br></p><p>I don&#39;t think anyone would want to stop official releases of Swift while<br>the rather long list of work items - let alone outstanding evolution<br>discussions/reviews - get worked thru towards the goal of having strong<br>source compatibility and stable ABI. It is obvious that the Swift community<br>- including Apple - want to push the language farther forward then is<br>possible in the original mindset for Swift 3.<br></p><p>So the line won&#39;t be drawn in 3.0 but some future release... It likely<br>won&#39;t change when that line will be drawn since that is being driven by the<br>remaining work and evolution topics, it just changes what version number we<br>associated with that line.<br></p><p>I do think some more progress could be made by the larger community if a<br>better way of engaging and maintaining non-Apple interested help while<br>avoiding conflicts with unseen changes / decisions and reduce bottlenecks<br>getting design and code reviews done in a more timely fashion. I know folks<br>are very busy and it makes it difficult so I suggest additional staffing<br>(could come from outside) to help support the community outside of Apple.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/21b0df58/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 19 May 2016, at 15:44, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Much like people are expressing relief that the compatibility goals for<br>&gt; the language are not being dictated by specific timelines, I would be<br>&gt; wholly concerned if any of Swift&#39;s goals were being defined by winning<br>&gt; the short-term favor of business people.<br></p><p>The success of Swift as a language depends on the favour (short medium and long term) of business people. We have a choice here: we can either build the perfect ivory tower language that nobody uses outside of this group, or we can build a pragmatic language that is great for building real World applications in. I’d prefer we did the latter.<br></p><p>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6c3c6af3a3702ecbe5bfa02e3d89aca?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Eric Wing</string> &lt;ewmailing at gmail.com&gt;<p>May 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt;<br>&gt;&gt; Here’s a simple, yet tragic example: BOOL in Objective-C. We were<br>&gt;&gt; stuck with signed char instead of getting a real boolean. Back in 10.4<br>&gt;&gt; Tiger when the Intel migration was announced, I filed a bug report<br>&gt;&gt; reminding them that this was the chance to fix this. They didn’t fix<br>&gt;&gt; it, so we were stuck. Then I filed again in the 10.5 beta Leopard time<br>&gt;&gt; frame during the 64-bit transition, I filed again reminding them that<br>&gt;&gt; this should be fixed before the 64-bit ABI gets locked down. Again, it<br>&gt;&gt; wasn’t fixed so we were stuck. Then when the iOS SDK was going to<br>&gt;&gt; become public, I filed again. Still not fixed. Then armv7, still<br>&gt;&gt; nothing. Finally, for arm64, this was finally fixed. Too bad we’re<br>&gt;&gt; stuck on Mac with this probably forever.<br>&gt;<br>&gt; Objective-C had a real boolean type as soon as the compiler was C99<br>&gt; compatible and that’s when I started using it. BOOL is a typedef that is<br>&gt; part of the Foundation/Cocoa API, not the Objective-C ABI.<br>&gt;<br></p><p>I’m well aware of C99 _Bool. However, this was a discussion of ABIs,<br>and my point was how hard it is to change after the fact. And if you<br>are going to nitpick, BOOL is defined in objc.h, not Foundation, AND<br>it is now defined as C99 bool on arm64. The fact that Cocoa was unable<br>to migrate to this repeatedly for about a decade proves my point.<br></p><p>I also said booleans were a *simple* example of this. Greg Parker’s<br>revelations of the lack of zero-cost exceptions on armv7 is something<br>I completely forgot about reminded me of a low-level project I was I<br>participated in a few years back where this implementation detail has<br>terrible consequences for it. Getting the ABI right matters for so<br>many reasons and percolates into everything.<br></p><p><br>&gt;&gt; Anyway, I don’t want to deal with another monstrous broken language.<br>&gt;<br>&gt; Objective-C is not broken.<br></p><p>I actually wasn’t referring to Objective-C nor accusing anybody at<br>Apple or Swift of creating a monster. But I want to keep it that way,<br>thus my support for delaying the stable ABI decision for Swift.<br></p><p><br>-Eric<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 17 May 2016, at 14:38, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; While on the face of it, you are correct, the goals have changed dramatically, I think you are being unfair.<br></p><p><br>The goals changed dramatically last week. It’s there in the git history. Last week was *after* the first developer preview of Swift 3.<br></p><p>I’m not being unfair, I’m being realistic. <br></p><p>&gt; <br>&gt; Swift 3 initial scope was determined prior to the input of the Swift Evolution community, just as it was being Open Sourced. As we have explored the language in many discussions, it has been clear there are other areas of the language that needed clean and polish before a stable ABI can be established.<br></p><p><br>I have no objection to having changed priorities, but these need to be communicated at the time the priorities change. When exactly was the stable ABI priority dropped? Was it last week, or was it months ago? Looking at the git history it was last week and the Swift community was not consulted in that change AFAIK. <br></p><p>Nobody outside of the development team knew that all this debate about relatively minor language features was going to prevent us from meeting the goals for Swift 3. If we had known, maybe a lot of the issues that we did talk about would have been deferred instead of completing generics and a stable ABI. If somebody had said to you “we can make all these relatively minor changes to the language or we can complete generics, but not both” which would  you have chosen? <br></p><p><br>&gt; <br>&gt; It appears that this work is more involved than the Swift Team initially envisioned. The fact they are open to changing timelines and ensuring we get fundamentals of the language sorted is a testament to their commitment to the quality of Swift as a whole.<br></p><p>Is completing the generic system fundamental or not? I’d say it is vastly more fundamental than removing C style for loops, wouldn’t you?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Is completing the generic system fundamental or not? I’d say it is vastly more fundamental than removing C style for loops, wouldn’t you?<br></p><p>Oh, come on. Removing the C-style for loop is not what took up time in this release cycle. What took up time is the API guidelines, the new collection model, and other standard library quality work—things which, in hindsight, are prerequisites for binary compatibility anyway, because linking against a different version doesn&#39;t count for much when all the names and calls have changed anyway.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 19 May 2016, at 10:47, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Is completing the generic system fundamental or not? I’d say it is vastly more fundamental than removing C style for loops, wouldn’t you?<br>&gt; <br>&gt; Oh, come on. Removing the C-style for loop is not what took up time in this release cycle. What took up time is the API guidelines, the new collection model, and other standard library quality work—things which, in hindsight, are prerequisites for binary compatibility anyway, because linking against a different version doesn&#39;t count for much when all the names and calls have changed anyway.<br></p><p>It is one of many things that have been done instead of concentrating on the goals as originally stated, five of which will not be met.<br></p><p>The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 23, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br></p><p>I understand that. What I&#39;m saying is, if we&#39;d gotten a stable ABI in Swift 3 and a redesigned standard library in Swift 4 instead of the other way around, the standard library changes would&#39;ve broken a lot of that &quot;ABI-compatible&quot; code anyway. (That, or we simply would&#39;ve been stuck with the old, unimproved standard library.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 23, 2016 at 04:00:00pm</p></header><div class="content"><p>On May 23, 2016, at 2:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br></p><p>I’m not sure what you’re saying.  If you change the API shipped by the standard library, it obviously breaks anything that links to it.<br></p><p>The whole point of ABI stability is to not break apps built with old versions of Swift compiler / standard library.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 24, 2016, at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 23, 2016, at 2:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br>&gt; <br>&gt; I’m not sure what you’re saying.  If you change the API shipped by the standard library, it obviously breaks anything that links to it.<br>&gt; <br>&gt; The whole point of ABI stability is to not break apps built with old versions of Swift compiler / standard library.<br>&gt; <br>&gt; -Chris<br></p><p>I regularly read see how stability is a high prioriy goal going forward. But what I have not found yet what the plan is going to be to achieve it without stiffling the standard library? Are there constructs, or rules is place/planned that map how changes of kind A versus B level changes will be keeping/breaking compatibility? (I have not finished all the docs)<br></p><p><br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:00 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 2:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you’re saying.  If you change the API shipped by the standard library, it obviously breaks anything that links to it.<br>&gt;&gt; <br>&gt;&gt; The whole point of ABI stability is to not break apps built with old versions of Swift compiler / standard library.<br></p><p>&gt; I regularly read see how stability is a high prioriy goal going forward. But what I have not found yet what the plan is going to be to achieve it without stiffling the standard library? Are there constructs, or rules is place/planned that map how changes of kind A versus B level changes will be keeping/breaking compatibility? (I have not finished all the docs)<br></p><p>Once ABI stability is established, functionality can only be added to the standard library, not removed or have a significant behavior change.  For example, fundamentally changing the index model for collections would be impossible, but adding a new kind of collection would be fine.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 7:56 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 12:00 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 2:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; The collection model, API guidelines and standard library are actually irrelevant to the ABI. The standard library API and the Swift ABI are distinct orthogonal concepts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what you’re saying.  If you change the API shipped by the standard library, it obviously breaks anything that links to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The whole point of ABI stability is to not break apps built with old versions of Swift compiler / standard library.<br>&gt; <br>&gt;&gt; I regularly read see how stability is a high prioriy goal going forward. But what I have not found yet what the plan is going to be to achieve it without stiffling the standard library? Are there constructs, or rules is place/planned that map how changes of kind A versus B level changes will be keeping/breaking compatibility? (I have not finished all the docs)<br>&gt; <br>&gt; Once ABI stability is established, functionality can only be added to the standard library, not removed or have a significant behavior change.  For example, fundamentally changing the index model for collections would be impossible, but adding a new kind of collection would be fine.<br>&gt; <br></p><p>Thank you for taking the time to reply. <br>I am interested in understanding how finer granularity changes like adding methods to protocols, or adding new conformance requirements to existing types will or not impact compatibility. For eg I read about the possibility of upcoming default implementations in protocol. Is that part of the long term binary compatibility plans, or unrelated? I do realize many answers are in the compiler dev-list (read most but not all), the docs and the source code (have yet to read what&#39;s loaded at runtime from the binary) but any pointers would be appreciated.<br>Thank you again.<br></p><p>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>On May 24, 2016, at 1:28 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I regularly read see how stability is a high prioriy goal going forward. But what I have not found yet what the plan is going to be to achieve it without stiffling the standard library? Are there constructs, or rules is place/planned that map how changes of kind A versus B level changes will be keeping/breaking compatibility? (I have not finished all the docs)<br>&gt;&gt; <br>&gt;&gt; Once ABI stability is established, functionality can only be added to the standard library, not removed or have a significant behavior change.  For example, fundamentally changing the index model for collections would be impossible, but adding a new kind of collection would be fine.<br>&gt; Thank you for taking the time to reply. <br>&gt; I am interested in understanding how finer granularity changes like adding methods to protocols, or adding new conformance requirements to existing types will or not impact compatibility. For eg I read about the possibility of upcoming default implementations in protocol. Is that part of the long term binary compatibility plans, or unrelated? I do realize many answers are in the compiler dev-list (read most but not all), the docs and the source code (have yet to read what&#39;s loaded at runtime from the binary) but any pointers would be appreciated.<br>&gt; Thank you again.<br></p><p>This is a nuanced topic.  Jordan and John have started working on a document to describe our “resilience” design, a draft is available here:<br>https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>May 17, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 17, 2016, at 5:35 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 May 2016, at 18:38, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Quite sad we could not get into ABI stability for Swift 3... but are we talking Swift 3.1 or 4.0?<br>&gt; <br>&gt; <br>&gt; Disappointing is my first thought, in fact worrying. Two years after the language was announced, the ABI is still not stable.<br>&gt; <br>&gt; Of the original Swift 3 goals, it looks like many will not be met. There were seven goals and only two are still in the Readme file[1]. On the assumption that the other five were all dropped because they will not be achieved in Swift 3, this looks like failure.<br>&gt; <br>&gt; I’ve been following the evolution list on and off since it started and it hasn’t felt like failure. In fact, it felt like important progress has been made and the language will be hugely better for it, but I do hope that the development team does take the opportunity to review the release in light of the original goals to see if there are any opportunities to improve the development process for the next release.<br></p><p>https://en.wikipedia.org/wiki/Hofstadter%27s_law<br></p><p>&gt; [1] https://github.com/apple/swift-evolution/blob/d6e62467b03435bdc4b3bd473c3dcffb9fdd6a71/README.md compared to https://github.com/apple/swift-evolution/blob/f11d2e970521f5df0f7510f89ee9c7decb3fa394/README.md<br></p><p><br>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/e75c86e0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>On Mon, May 16, 2016, at 11:18 AM, Chris Lattner via swift-evolution<br>wrote:<br>&gt; Hi Everyone,<br>&gt; <br>&gt; As we get deeper into the Swift 3 release cycle, we’re beginning to have<br>&gt; a more precise understanding about what the release will shape up to be. <br>&gt; Ted posted details of the Swift 3 release process last week<br>&gt; (https://swift.org/blog/swift-3-0-release-process/) and I just updated<br>&gt; the main swift-evolution README.md file<br>&gt; (https://github.com/apple/swift-evolution) with some updated details<br>&gt; about the goals of Swift 3.<br></p><p>I noticed this comment on Hacker News:<br>https://news.ycombinator.com/item?id=11708052<br></p><p>The comment brought up a question about the &quot;Portability&quot; section<br>disappearing from the README. Until reading that comment I had not<br>noticed the removal of the goal. But upon examination I would like to<br>know what the implication of that removal is.<br></p><p>Would you mind expanding on the implications of that section<br>disappearing? Just an accidental omission? Is portability now considered<br>done/achieved? Or are the core team members throwing in the towel on<br>that goal? (Perhaps it is some variation on those themes or something<br>completely different)<br></p><p>&gt; <br>&gt; This release is shaping up to be a really phenomenal release that will<br>&gt; redefine the feel of Swift and make a major leap towards maturing the<br>&gt; Swift language and development experience.  We have had a focus on<br>&gt; getting to source stability, with the forward-looking goal of making<br>&gt; Swift 4 as source compatible with Swift 3 as we can reasonably<br>&gt; accomplish.  It tackled API naming head on (which is one of the hardest<br>&gt; problems in computer science [1]), made major improvements to the<br>&gt; consistency and feel of the language, and has several nice across the<br>&gt; board additions.<br>&gt; <br>&gt; That said, it is also clear at this point that some of the loftier goals<br>&gt; that we started out with aren’t going to fit into the release - including<br>&gt; some of the most important generics features needed in order to lock down<br>&gt; the ABI of the standard library. As such, the generics and ABI stability<br>&gt; goals will roll into a future release of Swift, where I expect them to be<br>&gt; the *highest* priority features to get done.<br>&gt; <br>&gt; I expect discussion and planning for Swift 3.x and Swift 4 to start<br>&gt; sometime around August of this year.  Until then, it is very important<br>&gt; that we as a community stay focused on the goals of Swift 3: I’d really<br>&gt; prefer us all to resist the urge to discuss major blue sky features for<br>&gt; future releases.  We would also like to put a significant amount of<br>&gt; effort into bug fixing and quality refinements as well, which means that<br>&gt; the core team will be proactively deferring evolution proposals to later<br>&gt; releases that don’t align with the Swift 3 goals, especially those that<br>&gt; are strictly additive.<br>&gt; <br>&gt; Thank you for all of the amazing community that has developed on this<br>&gt; list, it is great to work with you all!  Let us know if you have any<br>&gt; questions,<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; [1] It is well known that the two hard problems in Computer Science are<br>&gt; naming, cache invalidation, and off-by-one errors.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 16, 2016, at 11:53 AM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; On Mon, May 16, 2016, at 11:18 AM, Chris Lattner via swift-evolution<br>&gt; wrote:<br>&gt;&gt; Hi Everyone,<br>&gt;&gt; <br>&gt;&gt; As we get deeper into the Swift 3 release cycle, we’re beginning to have<br>&gt;&gt; a more precise understanding about what the release will shape up to be. <br>&gt;&gt; Ted posted details of the Swift 3 release process last week<br>&gt;&gt; (https://swift.org/blog/swift-3-0-release-process/) and I just updated<br>&gt;&gt; the main swift-evolution README.md file<br>&gt;&gt; (https://github.com/apple/swift-evolution) with some updated details<br>&gt;&gt; about the goals of Swift 3.<br>&gt; <br>&gt; I noticed this comment on Hacker News:<br>&gt; https://news.ycombinator.com/item?id=11708052<br>&gt; <br>&gt; The comment brought up a question about the &quot;Portability&quot; section<br>&gt; disappearing from the README. Until reading that comment I had not<br>&gt; noticed the removal of the goal. But upon examination I would like to<br>&gt; know what the implication of that removal is.<br>&gt; <br>&gt; Would you mind expanding on the implications of that section<br>&gt; disappearing? Just an accidental omission? Is portability now considered<br>&gt; done/achieved? Or are the core team members throwing in the towel on<br>&gt; that goal? (Perhaps it is some variation on those themes or something<br>&gt; completely different)<br></p><p>Portability is still a strong goal, I will add it back, thank you for raising this!<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>May 16, 2016 at 12:00:00pm</p></header><div class="content"><p>With the generics and ABI stability goals getting pushed out to a future release, how does that affect the plans for Swift concurrency features?  Will the topic still be explored in the Swift 4 timeframe, or do you expect that discussion be deferred to 5 or beyond?<br></p><p>Dan<br></p><p>&gt; On May 16, 2016, at 8:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Everyone,<br>&gt; <br>&gt; As we get deeper into the Swift 3 release cycle, we’re beginning to have a more precise understanding about what the release will shape up to be.  Ted posted details of the Swift 3 release process last week (https://swift.org/blog/swift-3-0-release-process/) and I just updated the main swift-evolution README.md file (https://github.com/apple/swift-evolution) with some updated details about the goals of Swift 3.<br>&gt; <br>&gt; This release is shaping up to be a really phenomenal release that will redefine the feel of Swift and make a major leap towards maturing the Swift language and development experience.  We have had a focus on getting to source stability, with the forward-looking goal of making Swift 4 as source compatible with Swift 3 as we can reasonably accomplish.  It tackled API naming head on (which is one of the hardest problems in computer science [1]), made major improvements to the consistency and feel of the language, and has several nice across the board additions.<br>&gt; <br>&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br>&gt; <br>&gt; I expect discussion and planning for Swift 3.x and Swift 4 to start sometime around August of this year.  Until then, it is very important that we as a community stay focused on the goals of Swift 3: I’d really prefer us all to resist the urge to discuss major blue sky features for future releases.  We would also like to put a significant amount of effort into bug fixing and quality refinements as well, which means that the core team will be proactively deferring evolution proposals to later releases that don’t align with the Swift 3 goals, especially those that are strictly additive.<br>&gt; <br>&gt; Thank you for all of the amazing community that has developed on this list, it is great to work with you all!  Let us know if you have any questions,<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; [1] It is well known that the two hard problems in Computer Science are naming, cache invalidation, and off-by-one errors.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>On May 16, 2016, at 12:29 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; With the generics and ABI stability goals getting pushed out to a future release, how does that affect the plans for Swift concurrency features?  Will the topic still be explored in the Swift 4 timeframe, or do you expect that discussion be deferred to 5 or beyond?<br></p><p>I expect us to discuss what goes into post-Swift-3.0 release in ~August this year.  I’m sure that many folks will be interested in this and many other topics.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>Winding down the Swift 3 release</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>May 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I&#39;m curious, has the Swift team considered not having a public stable <br>ABI for Swift at all, and instead only define some kind of versioned <br>low-level bitcode for packaging purposes which then would be compiled <br>and linked by a system/package repository/App Store service?<br></p><p>This would allow the ABI to evolve with the compiler and would provide <br>more flexibility for e.g. the compilation of generic code and the <br>implementation of shared libraries.<br></p><p>- Stephan<br></p><p>On 2016-05-16, Chris Lattner via swift-evolution wrote:<br>&gt; That said, it is also clear at this point that some of the loftier goals that we started out with aren’t going to fit into the release - including some of the most important generics features needed in order to lock down the ABI of the standard library. As such, the generics and ABI stability goals will roll into a future release of Swift, where I expect them to be the *highest* priority features to get done.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
