<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Advice dealing with SILGen for switch statements w/ multiple binding patterns</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>October 22, 2016 at 10:00:00am</p></header><div class="content"><p>Hey All,<br></p><p>I’m not sure what to try next here, and could use some advice. For some time — off and on as I have time to get back to it — I’ve been working on switch statements with multiple binding patterns, e.g.:<br></p><p>enum A&lt;T&gt; {<br>  case left(a: T, b: T)<br>  case right(a: T, b: T)<br>  <br>  var foo: T {<br>    switch self {<br>    case let .left(a, _), let .right(_, a):<br>      return a<br>    }<br>  }<br>}<br></p><p>At some point I’d love to also get to allowing fall through between case blocks with bound variables as well, but first things first. My initial approach was to construct the body of these case blocks as a single basic block with incoming arguments for each bound variable, e.g.:<br></p><p>bb0:<br>	switch_enum : $A, case .left: bb1, case .right: bb2<br>bb1:<br>	%a1 = tuple_extract $(a: T, b: T), 0<br>	br bb3(%a1)<br>bb2:<br>	%a2 = tuple_extract $(a: T, b: T), 1<br>	br bb3(%a2)<br>bb3(%a: $T):<br>	// use %a<br></p><p>This is great unless T is an address-only type (like an unknown generic, as it is in this example code). A stack allocation happens, the actual value is copied in, and then (in bb1 and bb2) that stack value was deallocated, which means passing the value to bb3 breaks the memory management with use-after-free, ick. This was bug SR-2555. <br></p><p>So my next attempt was to pass the address of the value for address-only types:<br></p><p>bb0:<br>	switch_enum_address : $*A, case .left: bb1, case .right: bb2<br>bb1:<br>	%a1 = tuple_element_addr $(a: T, b: T), 0<br>	%s1 = alloc_stack $T<br>	copy_addr [take] %a1 to [initialization] %s1<br>	br bb3(%s1)<br>bb2:<br>	%a2 = tuple_element_addr $(a: T, b: T), 1<br>	%s2 = alloc_stack $T<br>	copy_addr [take] %a2 to [initialization] %s2<br>	br bb3(%s2)<br>bb3(%s: $*T):<br>	// use %s as address<br>	destroy_addr %s<br>	dealloc_stack %s<br></p><p>This requires careful ordering of the stack allocations in each pattern block so that the stack FILO invariant is maintained (in this example there is only one variable “a” but if we needed “b” instead of “_” then we’d have to be sure that each of bb1, bb2 alloc’d stack space for a and b in the same order even though they are in a different order in their respective tuples). But is doable.<br></p><p>Unfortunately, although the result looks like it might be valid SIL, this won’t work. I extended the SILVerifier to deal with stack allocations that were aliased due to being passed as parameters between basic blocks (so that it would know that %s1 and %s were the same and match the allocation of the former to the deallocation of the latter), and that makes SILGen happy.<br></p><p>But this causes IRGen to complain that in the bb3 phi “address has no container” while it is trying to generate IR for the dealloc_stack instruction. If anyone wants to see this the changes are here &lt;https://github.com/gregomni/swift/tree/switch &lt;https://github.com/gregomni/swift/tree/switch&gt;&gt;.<br></p><p>So I backed off, for the moment, to some code which emits the case contents statement(s) multiple times, once for each pattern, as if the programmer had written:<br></p><p>  var foo: T {<br>    switch self {<br>    case let .left(a, _):<br>      return a<br>    case let .right(_, a):<br>      return a<br>    }<br>  }<br></p><p>This is okay for this example, but obviously isn’t ideal with larger block contents. That got merged to trunk in pull #5094 to fix the bug for now, and that’s where I am today.<br></p><p>Should I:<br></p><p>- Continue down the aliased alloc_stack path and figure out how to make IRGen happy with stack addresses passed as args to BBs? I am - thus far - unfamiliar with IRGen. Any guesses how difficult this would be?<br></p><p>- Hoist stack allocations out of the individual pattern BBs (promising looking in this example, but super messy with lots of cases with differing tuple contents)? This makes the setup easier - alloc_stack the superset of needed things at the top, but the control flow for cleanup potentially hard. Although it seems like SILGen’s Cleanups machinery might actually work for me instead of my having to fight it, as has unfortunately seemed the case so far. <br></p><p>- Try changing over to allocing a box for each address-only arg that I want to pass between BBs? Seems unfortunate to make heap allocations for this (could they be optimized out?), and I’m worried about whether I’d run into further problems continuing to try to ‘join’ multiple allocs to single deallocs this way.<br></p><p>- Use separate strategies for switches containing address-only pattern variables and those which don’t (so that the body block can be shared in the simpler cases but leave the address-only case alone)?<br></p><p>- I keep having the nagging feeling that I’m overlooking some easier solution here.<br></p><p>Any thoughts greatly appreciated!<br></p><p>Thanks,<br>	- Greg<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161022/85dd4bdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Advice dealing with SILGen for switch statements w/ multiple binding patterns</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 22, 2016, at 10:32 AM, Greg Titus via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey All,<br>&gt; <br>&gt; I’m not sure what to try next here, and could use some advice. For some time — off and on as I have time to get back to it — I’ve been working on switch statements with multiple binding patterns, e.g.:<br>&gt; <br>&gt; enum A&lt;T&gt; {<br>&gt;   case left(a: T, b: T)<br>&gt;   case right(a: T, b: T)<br>&gt;   <br>&gt;   var foo: T {<br>&gt;     switch self {<br>&gt;     case let .left(a, _), let .right(_, a):<br>&gt;       return a<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; At some point I’d love to also get to allowing fall through between case blocks with bound variables as well, but first things first. My initial approach was to construct the body of these case blocks as a single basic block with incoming arguments for each bound variable, e.g.:<br>&gt; <br>&gt; bb0:<br>&gt; 	switch_enum : $A, case .left: bb1, case .right: bb2<br>&gt; bb1:<br>&gt; 	%a1 = tuple_extract $(a: T, b: T), 0<br>&gt; 	br bb3(%a1)<br>&gt; bb2:<br>&gt; 	%a2 = tuple_extract $(a: T, b: T), 1<br>&gt; 	br bb3(%a2)<br>&gt; bb3(%a: $T):<br>&gt; 	// use %a<br>&gt; <br>&gt; This is great unless T is an address-only type (like an unknown generic, as it is in this example code). A stack allocation happens, the actual value is copied in, and then (in bb1 and bb2) that stack value was deallocated, which means passing the value to bb3 breaks the memory management with use-after-free, ick. This was bug SR-2555. <br>&gt; <br>&gt; So my next attempt was to pass the address of the value for address-only types:<br>&gt; <br>&gt; bb0:<br>&gt; 	switch_enum_address : $*A, case .left: bb1, case .right: bb2<br>&gt; bb1:<br>&gt; 	%a1 = tuple_element_addr $(a: T, b: T), 0<br>&gt; 	%s1 = alloc_stack $T<br>&gt; 	copy_addr [take] %a1 to [initialization] %s1<br>&gt; 	br bb3(%s1)<br>&gt; bb2:<br>&gt; 	%a2 = tuple_element_addr $(a: T, b: T), 1<br>&gt; 	%s2 = alloc_stack $T<br>&gt; 	copy_addr [take] %a2 to [initialization] %s2<br>&gt; 	br bb3(%s2)<br>&gt; bb3(%s: $*T):<br>&gt; 	// use %s as address<br>&gt; 	destroy_addr %s<br>&gt; 	dealloc_stack %s<br>&gt; <br>&gt; This requires careful ordering of the stack allocations in each pattern block so that the stack FILO invariant is maintained (in this example there is only one variable “a” but if we needed “b” instead of “_” then we’d have to be sure that each of bb1, bb2 alloc’d stack space for a and b in the same order even though they are in a different order in their respective tuples). But is doable.<br>&gt; <br>&gt; Unfortunately, although the result looks like it might be valid SIL, this won’t work. I extended the SILVerifier to deal with stack allocations that were aliased due to being passed as parameters between basic blocks (so that it would know that %s1 and %s were the same and match the allocation of the former to the deallocation of the latter), and that makes SILGen happy.<br>&gt; <br>&gt; But this causes IRGen to complain that in the bb3 phi “address has no container” while it is trying to generate IR for the dealloc_stack instruction. If anyone wants to see this the changes are here &lt;https://github.com/gregomni/swift/tree/switch &lt;https://github.com/gregomni/swift/tree/switch&gt;&gt;.<br>&gt; <br>&gt; So I backed off, for the moment, to some code which emits the case contents statement(s) multiple times, once for each pattern, as if the programmer had written:<br>&gt; <br>&gt;   var foo: T {<br>&gt;     switch self {<br>&gt;     case let .left(a, _):<br>&gt;       return a<br>&gt;     case let .right(_, a):<br>&gt;       return a<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt; This is okay for this example, but obviously isn’t ideal with larger block contents. That got merged to trunk in pull #5094 to fix the bug for now, and that’s where I am today.<br>&gt; <br>&gt; Should I:<br>&gt; <br>&gt; - Continue down the aliased alloc_stack path and figure out how to make IRGen happy with stack addresses passed as args to BBs? I am - thus far - unfamiliar with IRGen. Any guesses how difficult this would be?<br></p><p>This seems like the right thing to do. It shouldn&#39;t be too hard to set up IRGen to support this. In the same way you needed to extend SIL&#39;s verifier to handle joined stack allocations, you should be able to change BB arg emission in IRGen to plumb the &quot;container&quot; part of stack allocations through as another phi node when we see that all of the predecessor values of a bb arg are alloc_stacks.<br></p><p>-Joe<br></p><p>&gt; - Hoist stack allocations out of the individual pattern BBs (promising looking in this example, but super messy with lots of cases with differing tuple contents)? This makes the setup easier - alloc_stack the superset of needed things at the top, but the control flow for cleanup potentially hard. Although it seems like SILGen’s Cleanups machinery might actually work for me instead of my having to fight it, as has unfortunately seemed the case so far. <br>&gt; <br>&gt; - Try changing over to allocing a box for each address-only arg that I want to pass between BBs? Seems unfortunate to make heap allocations for this (could they be optimized out?), and I’m worried about whether I’d run into further problems continuing to try to ‘join’ multiple allocs to single deallocs this way.<br>&gt; <br>&gt; - Use separate strategies for switches containing address-only pattern variables and those which don’t (so that the body block can be shared in the simpler cases but leave the address-only case alone)?<br>&gt; <br>&gt; - I keep having the nagging feeling that I’m overlooking some easier solution here.<br>&gt; <br>&gt; Any thoughts greatly appreciated!<br>&gt; <br>&gt; Thanks,<br>&gt; 	- Greg<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/66081334/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Advice dealing with SILGen for switch statements w/ multiple binding patterns</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Excellent, that was what I needed - some indication that I wasn’t completely off-base and doing something that ought not be done. :-)<br></p><p>Thanks!<br>	- Greg<br></p><p>&gt; On Oct 24, 2016, at 11:17 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 22, 2016, at 10:32 AM, Greg Titus via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey All,<br>&gt;&gt; <br>&gt;&gt; I’m not sure what to try next here, and could use some advice. For some time — off and on as I have time to get back to it — I’ve been working on switch statements with multiple binding patterns, e.g.:<br>&gt;&gt; <br>&gt;&gt; enum A&lt;T&gt; {<br>&gt;&gt;   case left(a: T, b: T)<br>&gt;&gt;   case right(a: T, b: T)<br>&gt;&gt;   <br>&gt;&gt;   var foo: T {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case let .left(a, _), let .right(_, a):<br>&gt;&gt;       return a<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; At some point I’d love to also get to allowing fall through between case blocks with bound variables as well, but first things first. My initial approach was to construct the body of these case blocks as a single basic block with incoming arguments for each bound variable, e.g.:<br>&gt;&gt; <br>&gt;&gt; bb0:<br>&gt;&gt; 	switch_enum : $A, case .left: bb1, case .right: bb2<br>&gt;&gt; bb1:<br>&gt;&gt; 	%a1 = tuple_extract $(a: T, b: T), 0<br>&gt;&gt; 	br bb3(%a1)<br>&gt;&gt; bb2:<br>&gt;&gt; 	%a2 = tuple_extract $(a: T, b: T), 1<br>&gt;&gt; 	br bb3(%a2)<br>&gt;&gt; bb3(%a: $T):<br>&gt;&gt; 	// use %a<br>&gt;&gt; <br>&gt;&gt; This is great unless T is an address-only type (like an unknown generic, as it is in this example code). A stack allocation happens, the actual value is copied in, and then (in bb1 and bb2) that stack value was deallocated, which means passing the value to bb3 breaks the memory management with use-after-free, ick. This was bug SR-2555. <br>&gt;&gt; <br>&gt;&gt; So my next attempt was to pass the address of the value for address-only types:<br>&gt;&gt; <br>&gt;&gt; bb0:<br>&gt;&gt; 	switch_enum_address : $*A, case .left: bb1, case .right: bb2<br>&gt;&gt; bb1:<br>&gt;&gt; 	%a1 = tuple_element_addr $(a: T, b: T), 0<br>&gt;&gt; 	%s1 = alloc_stack $T<br>&gt;&gt; 	copy_addr [take] %a1 to [initialization] %s1<br>&gt;&gt; 	br bb3(%s1)<br>&gt;&gt; bb2:<br>&gt;&gt; 	%a2 = tuple_element_addr $(a: T, b: T), 1<br>&gt;&gt; 	%s2 = alloc_stack $T<br>&gt;&gt; 	copy_addr [take] %a2 to [initialization] %s2<br>&gt;&gt; 	br bb3(%s2)<br>&gt;&gt; bb3(%s: $*T):<br>&gt;&gt; 	// use %s as address<br>&gt;&gt; 	destroy_addr %s<br>&gt;&gt; 	dealloc_stack %s<br>&gt;&gt; <br>&gt;&gt; This requires careful ordering of the stack allocations in each pattern block so that the stack FILO invariant is maintained (in this example there is only one variable “a” but if we needed “b” instead of “_” then we’d have to be sure that each of bb1, bb2 alloc’d stack space for a and b in the same order even though they are in a different order in their respective tuples). But is doable.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, although the result looks like it might be valid SIL, this won’t work. I extended the SILVerifier to deal with stack allocations that were aliased due to being passed as parameters between basic blocks (so that it would know that %s1 and %s were the same and match the allocation of the former to the deallocation of the latter), and that makes SILGen happy.<br>&gt;&gt; <br>&gt;&gt; But this causes IRGen to complain that in the bb3 phi “address has no container” while it is trying to generate IR for the dealloc_stack instruction. If anyone wants to see this the changes are here &lt;https://github.com/gregomni/swift/tree/switch &lt;https://github.com/gregomni/swift/tree/switch&gt;&gt;.<br>&gt;&gt; <br>&gt;&gt; So I backed off, for the moment, to some code which emits the case contents statement(s) multiple times, once for each pattern, as if the programmer had written:<br>&gt;&gt; <br>&gt;&gt;   var foo: T {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case let .left(a, _):<br>&gt;&gt;       return a<br>&gt;&gt;     case let .right(_, a):<br>&gt;&gt;       return a<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; This is okay for this example, but obviously isn’t ideal with larger block contents. That got merged to trunk in pull #5094 to fix the bug for now, and that’s where I am today.<br>&gt;&gt; <br>&gt;&gt; Should I:<br>&gt;&gt; <br>&gt;&gt; - Continue down the aliased alloc_stack path and figure out how to make IRGen happy with stack addresses passed as args to BBs? I am - thus far - unfamiliar with IRGen. Any guesses how difficult this would be?<br>&gt; <br>&gt; This seems like the right thing to do. It shouldn&#39;t be too hard to set up IRGen to support this. In the same way you needed to extend SIL&#39;s verifier to handle joined stack allocations, you should be able to change BB arg emission in IRGen to plumb the &quot;container&quot; part of stack allocations through as another phi node when we see that all of the predecessor values of a bb arg are alloc_stacks.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; - Hoist stack allocations out of the individual pattern BBs (promising looking in this example, but super messy with lots of cases with differing tuple contents)? This makes the setup easier - alloc_stack the superset of needed things at the top, but the control flow for cleanup potentially hard. Although it seems like SILGen’s Cleanups machinery might actually work for me instead of my having to fight it, as has unfortunately seemed the case so far. <br>&gt;&gt; <br>&gt;&gt; - Try changing over to allocing a box for each address-only arg that I want to pass between BBs? Seems unfortunate to make heap allocations for this (could they be optimized out?), and I’m worried about whether I’d run into further problems continuing to try to ‘join’ multiple allocs to single deallocs this way.<br>&gt;&gt; <br>&gt;&gt; - Use separate strategies for switches containing address-only pattern variables and those which don’t (so that the body block can be shared in the simpler cases but leave the address-only case alone)?<br>&gt;&gt; <br>&gt;&gt; - I keep having the nagging feeling that I’m overlooking some easier solution here.<br>&gt;&gt; <br>&gt;&gt; Any thoughts greatly appreciated!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; 	- Greg<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/d8daa430/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
