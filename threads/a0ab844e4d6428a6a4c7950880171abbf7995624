<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>IndexPath performance</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>August  1, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>IndexPath is currently implemented using an [Int] array that is bridged to<br>an NSIndexPath only on demand. Since IndexPath values are primarily used<br>together with Objective-C APIs, wouldn&#39;t it be better to implement<br>IndexPath directly as an NSIndexPath wrapper, in order to avoid the<br>overhead of temporary array instances?<br></p><p>- Stephan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160801/a0ab5624/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>IndexPath performance</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Stephan,<br></p><p>Do you have some benchmarks that you could share? That would help us focus performance work in the right area.<br></p><p>I know that 2-item IndexPaths are super common with UIKit collection view and friends, so we may just want to special case those. Unfortunately, NSIndexPath is not abstract, so subclassing it in the same way that we do for a few of the other bridged types (to use native Swift refcounting) is not easy. On the other hand, the ObjC implementation does use tagged pointers, so some NSIndexPaths are really cheap to create.<br></p><p>- Tony<br></p><p>&gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; IndexPath is currently implemented using an [Int] array that is bridged to an NSIndexPath only on demand. Since IndexPath values are primarily used together with Objective-C APIs, wouldn&#39;t it be better to implement IndexPath directly as an NSIndexPath wrapper, in order to avoid the overhead of temporary array instances?<br>&gt; <br>&gt; - Stephan<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>IndexPath performance</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>August  2, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Parker,<br></p><p>I noticed the IndexPath overhead when I investigated why a Swift 3<br>implementation of UICollectionViewLayout.layoutAttributesForElementsInRect<br>spent more time in malloc, free and related methods, but I don&#39;t have a<br>benchmark.<br></p><p>Is it important that IndexPath uses native Swift refcounting? It seems to<br>me that this type is mainly used in ObjC interop code. In native Swift code<br>I would always try to avoid using a dynamically sized, heap allocated array<br>as a data structure index. If NSIndexPath can&#39;t be bridged to a native<br>Swift type without introducing additional overhead, then maybe it shouldn&#39;t<br>be bridged at all?<br></p><p>- Stephan<br></p><p>On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br></p><p>&gt; Hi Stephan,<br>&gt;<br>&gt; Do you have some benchmarks that you could share? That would help us focus<br>&gt; performance work in the right area.<br>&gt;<br>&gt; I know that 2-item IndexPaths are super common with UIKit collection view<br>&gt; and friends, so we may just want to special case those. Unfortunately,<br>&gt; NSIndexPath is not abstract, so subclassing it in the same way that we do<br>&gt; for a few of the other bridged types (to use native Swift refcounting) is<br>&gt; not easy. On the other hand, the ObjC implementation does use tagged<br>&gt; pointers, so some NSIndexPaths are really cheap to create.<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-dev &lt;<br>&gt; swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; IndexPath is currently implemented using an [Int] array that is bridged<br>&gt; to an NSIndexPath only on demand. Since IndexPath values are primarily used<br>&gt; together with Objective-C APIs, wouldn&#39;t it be better to implement<br>&gt; IndexPath directly as an NSIndexPath wrapper, in order to avoid the<br>&gt; overhead of temporary array instances?<br>&gt; &gt;<br>&gt; &gt; - Stephan<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-corelibs-dev mailing list<br>&gt; &gt; swift-corelibs-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/762a40f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>IndexPath performance</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>August  2, 2016 at 12:00:00pm</p></header><div class="content"><p>Oh, I&#39;m sorry, Tony, I was too hasty and mistook your last name for your<br>first name :-(<br></p><p>- Stephan<br></p><p>On 2 August 2016 at 12:04, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br></p><p>&gt; Hi Parker,<br>&gt;<br>&gt; I noticed the IndexPath overhead when I investigated why a Swift 3<br>&gt; implementation of UICollectionViewLayout.layoutAttributesForElementsInRect<br>&gt; spent more time in malloc, free and related methods, but I don&#39;t have a<br>&gt; benchmark.<br>&gt;<br>&gt; Is it important that IndexPath uses native Swift refcounting? It seems to<br>&gt; me that this type is mainly used in ObjC interop code. In native Swift code<br>&gt; I would always try to avoid using a dynamically sized, heap allocated array<br>&gt; as a data structure index. If NSIndexPath can&#39;t be bridged to a native<br>&gt; Swift type without introducing additional overhead, then maybe it shouldn&#39;t<br>&gt; be bridged at all?<br>&gt;<br>&gt; - Stephan<br>&gt;<br>&gt; On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Stephan,<br>&gt;&gt;<br>&gt;&gt; Do you have some benchmarks that you could share? That would help us<br>&gt;&gt; focus performance work in the right area.<br>&gt;&gt;<br>&gt;&gt; I know that 2-item IndexPaths are super common with UIKit collection view<br>&gt;&gt; and friends, so we may just want to special case those. Unfortunately,<br>&gt;&gt; NSIndexPath is not abstract, so subclassing it in the same way that we do<br>&gt;&gt; for a few of the other bridged types (to use native Swift refcounting) is<br>&gt;&gt; not easy. On the other hand, the ObjC implementation does use tagged<br>&gt;&gt; pointers, so some NSIndexPaths are really cheap to create.<br>&gt;&gt;<br>&gt;&gt; - Tony<br>&gt;&gt;<br>&gt;&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-dev &lt;<br>&gt;&gt; swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; IndexPath is currently implemented using an [Int] array that is bridged<br>&gt;&gt; to an NSIndexPath only on demand. Since IndexPath values are primarily used<br>&gt;&gt; together with Objective-C APIs, wouldn&#39;t it be better to implement<br>&gt;&gt; IndexPath directly as an NSIndexPath wrapper, in order to avoid the<br>&gt;&gt; overhead of temporary array instances?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Stephan<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-corelibs-dev mailing list<br>&gt;&gt; &gt; swift-corelibs-dev at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/7e197a3e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>IndexPath performance</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>August  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Stephan,<br></p><p>&gt; On Aug 2, 2016, at 6:04 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br>&gt; <br>&gt; Hi Parker,<br>&gt; <br>&gt; I noticed the IndexPath overhead when I investigated why a Swift 3 implementation of UICollectionViewLayout.layoutAttributesForElementsInRect spent more time in malloc, free and related methods, but I don&#39;t have a benchmark.<br>&gt; <br>&gt; Is it important that IndexPath uses native Swift refcounting? It seems to me that this type is mainly used in ObjC interop code. In native Swift code I would always try to avoid using a dynamically sized, heap allocated array as a data structure index. If NSIndexPath can&#39;t be bridged to a native Swift type without introducing additional overhead, then maybe it shouldn&#39;t be bridged at all?<br>&gt; <br>&gt; - Stephan<br></p><p><br>I do think it is likely we could figure out some improvements here, but I’d like to start with a concrete test (and something that is representative of real world use cases). If it’s possible to extract something out of what you’ve already done, that would be really helpful. We can also file a bug on bugs.swift.org as a call for help designing a better perf test suite (we need this for all of the types, frankly).<br></p><p>Once we know we’re measuring the right thing, there are all kinds of interesting things we can do. If (when?) we have ABI stability in Swift 4, we may be able to also change the ObjC Foundation.framework to better cooperate with the Swift side, as we’ll be able to tie the current overlay code to a specific OS instead of having to run back several releases.<br></p><p>Thanks,<br>- Tony<br></p><p>&gt; <br>&gt; On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt; Hi Stephan,<br>&gt; <br>&gt; Do you have some benchmarks that you could share? That would help us focus performance work in the right area.<br>&gt; <br>&gt; I know that 2-item IndexPaths are super common with UIKit collection view and friends, so we may just want to special case those. Unfortunately, NSIndexPath is not abstract, so subclassing it in the same way that we do for a few of the other bridged types (to use native Swift refcounting) is not easy. On the other hand, the ObjC implementation does use tagged pointers, so some NSIndexPaths are really cheap to create.<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; IndexPath is currently implemented using an [Int] array that is bridged to an NSIndexPath only on demand. Since IndexPath values are primarily used together with Objective-C APIs, wouldn&#39;t it be better to implement IndexPath directly as an NSIndexPath wrapper, in order to avoid the overhead of temporary array instances?<br>&gt; &gt;<br>&gt; &gt; - Stephan<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-corelibs-dev mailing list<br>&gt; &gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/e67c8967/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>IndexPath performance</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Tony,<br></p><p>I understand why you&#39;d ideally want to have a real-world benchmark to guide<br>performance optimisations, but if you require that for every<br>performance-related change, you set a very high bar, and that bar will<br>probably have the effect of biasing performance downwards, since if there<br>is no existing benchmark, changes that worsen performance might not get<br>flagged.<br></p><p>The fact that NSIndexPath got the tagged pointer treatment probably<br>indicates that its implementation has a non-negligible effect on<br>performance (see also<br>https://twitter.com/Catfish_Man/status/393249511075639296).<br></p><p>The current IndexPath implementation in terms of an Int array clearly<br>introduces unnecessary overhead in ObjC interop scenarios, so unless this<br>implementation of IndexPath has some benefit I don&#39;t understand, I&#39;d argue<br>that it should be replaced with a straightforward wrapper around an<br>NSIndexPath value.<br></p><p>- Stephan<br></p><p>On 2 August 2016 at 12:12, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br></p><p>&gt; Hi Stephan,<br>&gt;<br>&gt; On Aug 2, 2016, at 6:04 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br>&gt;<br>&gt; Hi Parker,<br>&gt;<br>&gt; I noticed the IndexPath overhead when I investigated why a Swift 3<br>&gt; implementation of UICollectionViewLayout.layoutAttributesForElementsInRect<br>&gt; spent more time in malloc, free and related methods, but I don&#39;t have a<br>&gt; benchmark.<br>&gt;<br>&gt; Is it important that IndexPath uses native Swift refcounting? It seems to<br>&gt; me that this type is mainly used in ObjC interop code. In native Swift code<br>&gt; I would always try to avoid using a dynamically sized, heap allocated array<br>&gt; as a data structure index. If NSIndexPath can&#39;t be bridged to a native<br>&gt; Swift type without introducing additional overhead, then maybe it shouldn&#39;t<br>&gt; be bridged at all?<br>&gt;<br>&gt; - Stephan<br>&gt;<br>&gt;<br>&gt;<br>&gt; I do think it is likely we could figure out some improvements here, but<br>&gt; I’d like to start with a concrete test (and something that is<br>&gt; representative of real world use cases). If it’s possible to extract<br>&gt; something out of what you’ve already done, that would be really helpful. We<br>&gt; can also file a bug on bugs.swift.org as a call for help designing a<br>&gt; better perf test suite (we need this for all of the types, frankly).<br>&gt;<br>&gt; Once we know we’re measuring the right thing, there are all kinds of<br>&gt; interesting things we can do. If (when?) we have ABI stability in Swift 4,<br>&gt; we may be able to also change the ObjC Foundation.framework to better<br>&gt; cooperate with the Swift side, as we’ll be able to tie the current overlay<br>&gt; code to a specific OS instead of having to run back several releases.<br>&gt;<br>&gt; Thanks,<br>&gt; - Tony<br>&gt;<br>&gt;<br>&gt; On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Stephan,<br>&gt;&gt;<br>&gt;&gt; Do you have some benchmarks that you could share? That would help us<br>&gt;&gt; focus performance work in the right area.<br>&gt;&gt;<br>&gt;&gt; I know that 2-item IndexPaths are super common with UIKit collection view<br>&gt;&gt; and friends, so we may just want to special case those. Unfortunately,<br>&gt;&gt; NSIndexPath is not abstract, so subclassing it in the same way that we do<br>&gt;&gt; for a few of the other bridged types (to use native Swift refcounting) is<br>&gt;&gt; not easy. On the other hand, the ObjC implementation does use tagged<br>&gt;&gt; pointers, so some NSIndexPaths are really cheap to create.<br>&gt;&gt;<br>&gt;&gt; - Tony<br>&gt;&gt;<br>&gt;&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-dev &lt;<br>&gt;&gt; swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; IndexPath is currently implemented using an [Int] array that is bridged<br>&gt;&gt; to an NSIndexPath only on demand. Since IndexPath values are primarily used<br>&gt;&gt; together with Objective-C APIs, wouldn&#39;t it be better to implement<br>&gt;&gt; IndexPath directly as an NSIndexPath wrapper, in order to avoid the<br>&gt;&gt; overhead of temporary array instances?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Stephan<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-corelibs-dev mailing list<br>&gt;&gt; &gt; swift-corelibs-dev at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/6435e297/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>IndexPath performance</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree with Stephan, NSIndexPath performance is important and we should<br>avoid the overhead of allocating/freeing an array for the common case.<br>Instead of just always wrapping NSIndexPath, maybe we should just switch<br>the internal representation to something like<br></p><p>enum Indices {<br>    case one(Int)<br>    case two(Int, Int)<br>    // case three?<br>    case many([Int])<br>}<br></p><p>Yeah it complicates the methods a bit, and we&#39;d have to have a custom<br>index instead of just using Array&#39;s index, but it avoids heap allocation<br>for the extremely common case of a 2-element index path (it&#39;s so common,<br>I don&#39;t think I&#39;ve *ever* seen an NSIndexPath that didn&#39;t contain<br>exactly 2 indices).<br></p><p>-Kevin Ballard<br></p><p>On Tue, Aug 2, 2016, at 04:24 AM, Stephan Tolksdorf via swift-corelibs-dev wrote:<br>&gt; Tony,<br>&gt;<br>&gt; I understand why you&#39;d ideally want to have a real-world benchmark to<br>&gt; guide performance optimisations, but if you require that for every performance-<br>&gt; related change, you set a very high bar, and that bar will probably<br>&gt; have the effect of biasing performance downwards, since if there is no<br>&gt; existing benchmark, changes that worsen performance might not get<br>&gt; flagged.<br>&gt;<br>&gt; The fact that NSIndexPath got the tagged pointer treatment probably<br>&gt; indicates that its implementation has a non-negligible effect on<br>&gt; performance (see also<br>&gt; https://twitter.com/Catfish_Man/status/393249511075639296).<br>&gt;<br>&gt; The current IndexPath implementation in terms of an Int array clearly<br>&gt; introduces unnecessary overhead in ObjC interop scenarios, so unless<br>&gt; this implementation of IndexPath has some benefit I don&#39;t understand,<br>&gt; I&#39;d argue that it should be replaced with a straightforward wrapper<br>&gt; around an NSIndexPath value.<br>&gt;<br>&gt; - Stephan<br>&gt;<br>&gt; On 2 August 2016 at 12:12, Tony Parker<br>&gt; &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt; Hi Stephan,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 2, 2016, at 6:04 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Parker,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I noticed the IndexPath overhead when I investigated why a Swift 3<br>&gt;&gt;&gt; implementation of<br>&gt;&gt;&gt; UICollectionViewLayout.layoutAttributesForElementsInRect spent more<br>&gt;&gt;&gt; time in malloc, free and related methods, but I don&#39;t have a<br>&gt;&gt;&gt; benchmark.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is it important that IndexPath uses native Swift refcounting? It<br>&gt;&gt;&gt; seems to me that this type is mainly used in ObjC interop code. In<br>&gt;&gt;&gt; native Swift code I would always try to avoid using a dynamically<br>&gt;&gt;&gt; sized, heap allocated array as a data structure index. If<br>&gt;&gt;&gt; NSIndexPath can&#39;t be bridged to a native Swift type without<br>&gt;&gt;&gt; introducing additional overhead, then maybe it shouldn&#39;t be bridged<br>&gt;&gt;&gt; at all?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Stephan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I do think it is likely we could figure out some improvements here,<br>&gt;&gt; but I’d like to start with a concrete test (and something that is<br>&gt;&gt; representative of real world use cases). If it’s possible to extract<br>&gt;&gt; something out of what you’ve already done, that would be really<br>&gt;&gt; helpful. We can also file a bug on bugs.swift.org as a call for help<br>&gt;&gt; designing a better perf test suite (we need this for all of the<br>&gt;&gt; types, frankly).<br>&gt;&gt;<br>&gt;&gt; Once we know we’re measuring the right thing, there are all kinds of<br>&gt;&gt; interesting things we can do. If (when?) we have ABI stability in<br>&gt;&gt; Swift 4, we may be able to also change the ObjC Foundation.framework<br>&gt;&gt; to better cooperate with the Swift side, as we’ll be able to tie the<br>&gt;&gt; current overlay code to a specific OS instead of having to run back<br>&gt;&gt; several releases.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi Stephan,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  Do you have some benchmarks that you could share? That would help<br>&gt;&gt;&gt;&gt;  us focus performance work in the right area.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  I know that 2-item IndexPaths are super common with UIKit<br>&gt;&gt;&gt;&gt;  collection view and friends, so we may just want to special case<br>&gt;&gt;&gt;&gt;  those. Unfortunately, NSIndexPath is not abstract, so subclassing<br>&gt;&gt;&gt;&gt;  it in the same way that we do for a few of the other bridged types<br>&gt;&gt;&gt;&gt;  (to use native Swift refcounting) is not easy. On the other hand,<br>&gt;&gt;&gt;&gt;  the ObjC implementation does use tagged pointers, so some<br>&gt;&gt;&gt;&gt;  NSIndexPaths are really cheap to create.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  - Tony<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-<br>&gt;&gt;&gt;&gt; &gt; dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; Hi,<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; IndexPath is currently implemented using an [Int] array that is<br>&gt;&gt;&gt;&gt;  &gt; bridged to an NSIndexPath only on demand. Since IndexPath values<br>&gt;&gt;&gt;&gt;  &gt; are primarily used together with Objective-C APIs, wouldn&#39;t it<br>&gt;&gt;&gt;&gt;  &gt; be better to implement IndexPath directly as an NSIndexPath<br>&gt;&gt;&gt;&gt;  &gt; wrapper, in order to avoid the overhead of temporary array<br>&gt;&gt;&gt;&gt;  &gt; instances?<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; - Stephan<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;  &gt; swift-corelibs-dev mailing list swift-corelibs-dev at swift.org<br>&gt;&gt;&gt;&gt;  &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _________________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/df4013df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>IndexPath performance</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>FWIW, if you agree that this approach is reasonable, I would be willing<br>to write the patch for it.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Aug 2, 2016, at 05:46 PM, Kevin Ballard wrote:<br>&gt; I agree with Stephan, NSIndexPath performance is important and we<br>&gt; should avoid the overhead of allocating/freeing an array for the<br>&gt; common case. Instead of just always wrapping NSIndexPath, maybe we<br>&gt; should just switch the internal representation to something like<br>&gt;<br>&gt; enum Indices {<br>&gt;     case one(Int)<br>&gt;     case two(Int, Int)<br>&gt;     // case three?<br>&gt;     case many([Int])<br>&gt; }<br>&gt;<br>&gt; Yeah it complicates the methods a bit, and we&#39;d have to have a custom<br>&gt; index instead of just using Array&#39;s index, but it avoids heap<br>&gt; allocation for the extremely common case of a 2-element index path<br>&gt; (it&#39;s so common, I don&#39;t think I&#39;ve *ever* seen an NSIndexPath that<br>&gt; didn&#39;t contain exactly 2 indices).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Tue, Aug 2, 2016, at 04:24 AM, Stephan Tolksdorf via swift-corelibs-<br>&gt; dev wrote:<br>&gt;&gt; Tony,<br>&gt;&gt;<br>&gt;&gt; I understand why you&#39;d ideally want to have a real-world benchmark to<br>&gt;&gt; guide performance optimisations, but if you require that for every<br>&gt;&gt; performance-related change, you set a very high bar, and that bar<br>&gt;&gt; will probably have the effect of biasing performance downwards, since<br>&gt;&gt; if there is no existing benchmark, changes that worsen performance<br>&gt;&gt; might not get flagged.<br>&gt;&gt;<br>&gt;&gt; The fact that NSIndexPath got the tagged pointer treatment probably<br>&gt;&gt; indicates that its implementation has a non-negligible effect on<br>&gt;&gt; performance (see also<br>&gt;&gt; https://twitter.com/Catfish_Man/status/393249511075639296).<br>&gt;&gt;<br>&gt;&gt; The current IndexPath implementation in terms of an Int array clearly<br>&gt;&gt; introduces unnecessary overhead in ObjC interop scenarios, so unless<br>&gt;&gt; this implementation of IndexPath has some benefit I don&#39;t understand,<br>&gt;&gt; I&#39;d argue that it should be replaced with a straightforward wrapper<br>&gt;&gt; around an NSIndexPath value.<br>&gt;&gt;<br>&gt;&gt; - Stephan<br>&gt;&gt;<br>&gt;&gt; On 2 August 2016 at 12:12, Tony Parker<br>&gt;&gt; &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt;&gt; Hi Stephan,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 6:04 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Parker,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I noticed the IndexPath overhead when I investigated why a Swift 3<br>&gt;&gt;&gt;&gt; implementation of<br>&gt;&gt;&gt;&gt; UICollectionViewLayout.layoutAttributesForElementsInRect spent more<br>&gt;&gt;&gt;&gt; time in malloc, free and related methods, but I don&#39;t have a<br>&gt;&gt;&gt;&gt; benchmark.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Is it important that IndexPath uses native Swift refcounting? It<br>&gt;&gt;&gt;&gt; seems to me that this type is mainly used in ObjC interop code. In<br>&gt;&gt;&gt;&gt; native Swift code I would always try to avoid using a dynamically<br>&gt;&gt;&gt;&gt; sized, heap allocated array as a data structure index. If<br>&gt;&gt;&gt;&gt; NSIndexPath can&#39;t be bridged to a native Swift type without<br>&gt;&gt;&gt;&gt; introducing additional overhead, then maybe it shouldn&#39;t be bridged<br>&gt;&gt;&gt;&gt; at all?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Stephan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I do think it is likely we could figure out some improvements here,<br>&gt;&gt;&gt; but I’d like to start with a concrete test (and something that is<br>&gt;&gt;&gt; representative of real world use cases). If it’s possible to extract<br>&gt;&gt;&gt; something out of what you’ve already done, that would be really<br>&gt;&gt;&gt; helpful. We can also file a bug on bugs.swift.org as a call for help<br>&gt;&gt;&gt; designing a better perf test suite (we need this for all of the<br>&gt;&gt;&gt; types, frankly).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Once we know we’re measuring the right thing, there are all kinds of<br>&gt;&gt;&gt; interesting things we can do. If (when?) we have ABI stability in<br>&gt;&gt;&gt; Swift 4, we may be able to also change the ObjC Foundation.framework<br>&gt;&gt;&gt; to better cooperate with the Swift side, as we’ll be able to tie the<br>&gt;&gt;&gt; current overlay code to a specific OS instead of having to run back<br>&gt;&gt;&gt; several releases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 2 August 2016 at 11:09, Tony Parker &lt;anthony.parker at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi Stephan,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  Do you have some benchmarks that you could share? That would help<br>&gt;&gt;&gt;&gt;&gt;  us focus performance work in the right area.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  I know that 2-item IndexPaths are super common with UIKit<br>&gt;&gt;&gt;&gt;&gt;  collection view and friends, so we may just want to special case<br>&gt;&gt;&gt;&gt;&gt;  those. Unfortunately, NSIndexPath is not abstract, so subclassing<br>&gt;&gt;&gt;&gt;&gt;  it in the same way that we do for a few of the other bridged<br>&gt;&gt;&gt;&gt;&gt;  types (to use native Swift refcounting) is not easy. On the other<br>&gt;&gt;&gt;&gt;&gt;  hand, the ObjC implementation does use tagged pointers, so some<br>&gt;&gt;&gt;&gt;&gt;  NSIndexPaths are really cheap to create.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  - Tony<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Aug 1, 2016, at 11:44 PM, Stephan Tolksdorf via swift-corelibs-<br>&gt;&gt;&gt;&gt;&gt; &gt; dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;&gt;  &gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;&gt;  &gt; IndexPath is currently implemented using an [Int] array that is<br>&gt;&gt;&gt;&gt;&gt;  &gt; bridged to an NSIndexPath only on demand. Since IndexPath<br>&gt;&gt;&gt;&gt;&gt;  &gt; values are primarily used together with Objective-C APIs,<br>&gt;&gt;&gt;&gt;&gt;  &gt; wouldn&#39;t it be better to implement IndexPath directly as an<br>&gt;&gt;&gt;&gt;&gt;  &gt; NSIndexPath wrapper, in order to avoid the overhead of<br>&gt;&gt;&gt;&gt;&gt;  &gt; temporary array instances?<br>&gt;&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;&gt;  &gt; - Stephan<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;  &gt; swift-corelibs-dev mailing list swift-corelibs-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;  &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _________________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160802/cbbbdaa1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
