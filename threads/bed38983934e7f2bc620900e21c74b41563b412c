<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85d9971b4047fb2f720357fee59a5f98?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Pedro Vieira</string> &lt;pedrovieira.swift at gmail.com&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Swift developers,<br>I hereby present my first Swift proposal regarding the endIndex on<br>`Collections` and closed `Ranges`. I‚Äôve searched the mailing list archives<br>for something similar to this but couldn‚Äôt find it, so I decided to come<br>forward.<br></p><p>*The problem:*<br>I was recently working on a library and used a closed Range to define the<br>bounds of a board game and the tests that used its endIndex were all<br>failing. Started debugging it around and, to my complete surprise, found<br>out that the endIndex of the closed Ranges was always +1 from the value I<br>initially set. With this, I decided to dive into the Range source code and<br>discovered that all closed ranges are converted to half-open ones when<br>initialized:<br>a) 1..&lt;10 stays 1..&lt;10 (endIndex = 10)<br>b) 1...10 is converted to 1..&lt;11 (endIndex = 11)<br></p><p>To work around this behavior I had to subtract 1 every time I checked for<br>the endIndex, since I didn&#39;t want to use last! (force unwrapping) or<br>if-let, which ultimately polluted my code. You could argue that changing<br>from 1...10 to 1...9 would get rid of all of this, since it gets translated<br>to 1..&lt;10 with endIndex being 10 (which is the value I expect), but I think<br>it‚Äôs just not worth it to ‚Äúobscure‚Äù that way.<br></p><p>I‚Äôve asked some fellow developer friends their thoughts having the value 11<br>when accessing endIndex on b) and a lot of them were confused and did not<br>expect the outcome, and I totally agree, it‚Äôs not intuitive at all. To me,<br>endIndex implies that the returned value is the last valid and accessible<br>index of a Collection, not its size/count or any other value that is<br>outside the collection‚Äôs bounds.<br></p><p>*The solution:*<br>Add an optional boolean parameter, `closed`, to the Range init method with<br>the default value of false (instead of `closed` there‚Äôs always the<br>`halfOpen` alternative):<br>   init(_start: Element, end: Element, closed: Bool = false)<br>The parameter is an optional parameter to minimize the impact on existing<br>code that is currently initializing Ranges using the init method directly.<br>This parameter would also be a public property.<br></p><p>Then, the ... constructor would become:<br></p><p>public func ... &lt;Pos : ForwardIndex&gt; (minimum: Pos, maximum: Pos) -&gt; Range&lt;<br>Pos&gt; {<br></p><p>  - return Range(_start: minimum, end: maximum.successor())<br></p><p>  + return Range(_start: minimum, end: maximum, closed: true)<br></p><p>}<br></p><p>Also, the next() method from the RangeGenerator would become:<br></p><p>public mutating func next() -&gt; Element? {<br></p><p>  - if startIndex == endIndex.successor() { return nil }<br></p><p>  + if startIndex == (isClosed ? endIndex.successor() : endIndex) { return<br>nil }<br></p><p>  let element = startIndex<br></p><p>  startIndex._successorInPlace()<br></p><p>  return element<br></p><p>}<br></p><p>Performing this change has 2 main benefits:<br>1 ‚Äî The Range description and debugDescription properties would finally<br>return a *true* self String representation. So, for instance, the<br>description property would become:<br></p><p>public var description: String {<br></p><p>  - return &quot;\(startIndex)..&lt;\(endIndex)&quot;<br></p><p>  + return &quot;\(startIndex)..\(isClosed ? &quot;.&quot; : &quot;&lt;&quot;)\(endIndex)&quot;<br></p><p>}<br></p><p>2 ‚Äî It becomes a lot more intuitive. WYSIWYG. Also, by having the `closed`<br>parameter in the init method, developers that create Ranges directly from<br>the init method will actually know what type of Range they‚Äôre getting<br>straight away:<br>- currently: Range(start: 1, end: 10) ==&gt; is it 1...10 or 1..&lt;10?<br>- proposed: Range(start: 1, end: 10, closed: true) ==&gt; 1...10<br></p><p><br>This behavior is also present in Swift Collections:<br></p><p>let array = [5, 10, 15]<br></p><p>array.count // 3<br></p><p>array.endIndex // 3 (should be 2)<br></p><p>array.last! // 15 (apologies for the force unwrap ü§ì)<br></p><p>Again, the endIndex returns an index that is outside the array bounds,<br>which, in fact, acts as the array count. Instead, it should have returned<br>the index of the last element.<br>I know that, in the comments, it‚Äôs explicit: ‚ÄúA &#39;past-the-end&#39; element<br>index; the successor of the last valid subscript argument.‚Äù, but, in the<br>end, it all comes down to readability.<br></p><p><br>What are your thoughts on this? Let me know.<br></p><p>Cheers,<br></p><p>-- <br>Pedro Vieira<br>http://pedrovieira.me<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/bed3412c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>Pedro,<br></p><p>endIndex is exclusive by definition. You can iterate over any collection by going from startIndex until you reach endIndex.<br></p><p>If we change endIndex on ranges, *all* generic iteration code will be broken when dealing with ranges, even the for statement.<br></p><p><br>I understand that there are two concerns here:<br></p><p>1) The desire to keep the semantics of 1...10 intact, so that you can access that 10 somehow (perhaps something like lastValidIndex?), the description returns the expected value, etc. To achieve this, a different class (ClosedRange) would probably make more sense, because there&#39;s no need to make this decision at runtime.<br></p><p>2) The desire to change endIndex specifically. This is a no-go.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>PS:<br></p><p>&gt; endIndex is exclusive by definition<br></p><p>If you want a rationale on this...<br></p><p>1) It&#39;s how cursors typically work, and people familiar with the concept already expect this.<br></p><p>2) It&#39;s often the most convenient choice. Back in the day, you would write C code like this:<br></p><p>	for (int *cur = array, *end = array + size; cur &lt; end; ++cur) {<br>            process(*cur);<br>        }<br></p><p>    Similarly, you can compute the number of elements by just getting the distance between startIndex and endIndex (or end - cur in the C example above).<br></p><p>    Making the upper boundary inclusive would require explicit &#39;- 1&#39; and &#39;+ 1&#39; in quite a few places, which is ugly and unnecessary.<br></p><p>3) The upper bound is almost always excluded in programming, in many unrelated APIs (e.g. arc4random_uniform), so it&#39;s a good default choice.<br></p><p>A.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
