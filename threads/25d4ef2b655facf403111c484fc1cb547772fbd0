<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0a88a27755600d9f1c1ce00e3c209a38?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Brad Hilton</string> &lt;brad.hilton.nw at gmail.com&gt;<p>April  4, 2016 at 02:00:00pm</p></header><div class="content"><p>The Completing Generics Manifesto suggests a more universal solution with generic value parameters which is my vote:<br>Generic value parameters<br></p><p>Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br></p><p>struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>  subscript (indices: Int...) -&gt; T {<br>    get {<br>      require(indices.count == Dimensions)<br>      // ...<br>    }<br>}<br></p><p>A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br></p><p>&gt; To better support interfacing with lower level systems, like graphics<br>&gt; libraries for example, it would be helpful to support the concept of<br>&gt; contiguous variables. The most common use case for this would be to create<br>&gt; a Matrix struct that can be passed as data into something like Metal. This<br>&gt; can be accomplished now, using something like the following:<br>&gt; <br>&gt; Current Option 1:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt; var m00: Float<br>&gt; var m01: Float<br>&gt; var m10: Float<br>&gt; var m11: Float<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 2:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt; var m: (Float, Float, Float, Float)<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 3:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt; var m: [Float]<br>&gt; }<br>&gt; <br>&gt; Options 1&amp;2 allow for the compiler to enforce the fixed number of<br>&gt; elements and also for the data to be easily passed into graphics libraries<br>&gt; as their memory layout is somewhat predictable using sizeof, strideof, and<br>&gt; alignof. The downside is that you lose the ability to easily subscript or<br>&gt; iterate the elements.<br>&gt; <br>&gt; Option 3 does allow subscripting and iteration, but does not at compile<br>&gt; time enforce a fixed number of elements and is not as easily passed into a<br>&gt; library that expects to receive the raw data of the matrix.<br>&gt; <br>&gt; <br>&gt; Contiguous Variables:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt; var m: Float:2*2<br>&gt; }<br>&gt; <br>&gt; The variable `m` represents a series of 4 contiguous Float values. The<br>&gt; specific number of values must be a compile time constant. The only needed<br>&gt; functionality includes `count`, `subscript`, and iteration. To make things<br>&gt; easier to implement and to help avoid confusion and more complex<br>&gt; documentation, multiple dimensions are not allowed. To define multiple<br>&gt; dimensions you must provide your own ordering by wrapping this type in<br>&gt; another type and providing a custom subscript implementation. For example:<br>&gt; <br>&gt; struct RowMajorMatrix2x2 {<br>&gt; var m: Float:2*2<br>&gt; <br>&gt; static let rows = 2<br>&gt; static let columns = 2<br>&gt; <br>&gt; subscript(row: Int, column: Int) -&gt;Float {<br>&gt; return m[column * Matrix2x2.rows + row]<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; sizeof(Matrix2x2) is 16<br>&gt; strideof(Matrix2x2) is 16<br>&gt; <br>&gt; m.count is essentially a compile time constant and is not stored with the<br>&gt; rest of the data but is available and can also be used to do runtime bounds<br>&gt; checking.<br>&gt; <br>&gt; struct Vector3 {<br>&gt; var v: Float:3<br>&gt; }<br>&gt; <br>&gt; sizeof(Vector3) is 12<br>&gt; strideof(Vector3) is 12<br>&gt; <br>&gt; C code should also now be able to expose data types that contain fixed<br>&gt; sized arrays within them.<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/25d4fbd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  5, 2016 at 03:00:00pm</p></header><div class="content"><p>This could potentially convert to Swift many library developers whose sanity depends on type guaranteed sequence sizes. I was just playing with Swift 2.2 along these lines, and got surprised how far I could get towards that ideal, see: http://codereview.stackexchange.com/q/124797/54297 &lt;http://codereview.stackexchange.com/q/124797/54297&gt; <br></p><p>For example, I got this to compile:<br></p><p>    let v = Vector&lt;__&lt;_4,_2&gt;,Int&gt;(0)<br>    v.elements.count // 42<br></p><p>    let w = Vector&lt;_3,Int&gt;(0)<br>    w.elements // [0, 0, 0]<br>    w[2].value = 5<br></p><p>    for x in w {<br>        x // 0, 0, 5<br>    }<br></p><p>Once created, `v` and `w` here can never change size, not even from within the implementation.<br></p><p>milos<br></p><p>&gt; On 4 Apr 2016, at 21:10, Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The Completing Generics Manifesto suggests a more universal solution with generic value parameters which is my vote:<br>&gt; Generic value parameters<br>&gt; <br>&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt; <br>&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == Dimensions)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt; <br>&gt; &gt; To better support interfacing with lower level systems, like graphics<br>&gt; &gt; libraries for example, it would be helpful to support the concept of<br>&gt; &gt; contiguous variables. The most common use case for this would be to create<br>&gt; &gt; a Matrix struct that can be passed as data into something like Metal. This<br>&gt; &gt; can be accomplished now, using something like the following:<br>&gt; &gt; <br>&gt; &gt; Current Option 1:<br>&gt; &gt; <br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt; var m00: Float<br>&gt; &gt; var m01: Float<br>&gt; &gt; var m10: Float<br>&gt; &gt; var m11: Float<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; OR<br>&gt; &gt; Current Option 2:<br>&gt; &gt; <br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt; var m: (Float, Float, Float, Float)<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; OR<br>&gt; &gt; Current Option 3:<br>&gt; &gt; <br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt; var m: [Float]<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; Options 1&amp;2 allow for the compiler to enforce the fixed number of<br>&gt; &gt; elements and also for the data to be easily passed into graphics libraries<br>&gt; &gt; as their memory layout is somewhat predictable using sizeof, strideof, and<br>&gt; &gt; alignof. The downside is that you lose the ability to easily subscript or<br>&gt; &gt; iterate the elements.<br>&gt; &gt; <br>&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile<br>&gt; &gt; time enforce a fixed number of elements and is not as easily passed into a<br>&gt; &gt; library that expects to receive the raw data of the matrix.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Contiguous Variables:<br>&gt; &gt; <br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt; var m: Float:2*2<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The<br>&gt; &gt; specific number of values must be a compile time constant. The only needed<br>&gt; &gt; functionality includes `count`, `subscript`, and iteration. To make things<br>&gt; &gt; easier to implement and to help avoid confusion and more complex<br>&gt; &gt; documentation, multiple dimensions are not allowed. To define multiple<br>&gt; &gt; dimensions you must provide your own ordering by wrapping this type in<br>&gt; &gt; another type and providing a custom subscript implementation. For example:<br>&gt; &gt; <br>&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt; &gt; var m: Float:2*2<br>&gt; &gt; <br>&gt; &gt; static let rows = 2<br>&gt; &gt; static let columns = 2<br>&gt; &gt; <br>&gt; &gt; subscript(row: Int, column: Int) -&gt;Float {<br>&gt; &gt; return m[column * Matrix2x2.rows + row]<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt; &gt; strideof(Matrix2x2) is 16<br>&gt; &gt; <br>&gt; &gt; m.count is essentially a compile time constant and is not stored with the<br>&gt; &gt; rest of the data but is available and can also be used to do runtime bounds<br>&gt; &gt; checking.<br>&gt; &gt; <br>&gt; &gt; struct Vector3 {<br>&gt; &gt; var v: Float:3<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; sizeof(Vector3) is 12<br>&gt; &gt; strideof(Vector3) is 12<br>&gt; &gt; <br>&gt; &gt; C code should also now be able to expose data types that contain fixed<br>&gt; &gt; sized arrays within them.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/68447df0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
