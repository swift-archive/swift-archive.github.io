<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>New GCD API change: DispatchWorkItems should be retained by their groups</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I’d like to propose a change to the new GCD API; that DispatchWorkItems be retained by their groups (and in turn, for them to be retained by their queues). This allows for whoever created the work item to create a weak reference to it, as an indicator for whether or not it has finished executing.<br></p><p>For example, let’s say I have some kind of class which manages a library of files. I want to have a refresh operation which runs on a background queue, enumerating the documents and perhaps even opening them and extracting some metadata:<br></p><p>class DocumentLibrary {<br></p><p>    weak var refreshOperation : DispatchWorkItem?<br></p><p>    func refresh(force:Bool = false) {<br></p><p>        If let ongoingOperation = refreshOperation {<br>	    if force == true {<br>                ongoingOperation.cancel()  // force an update<br>            }<br>            else {<br>                return  // already refreshing<br>            }<br>        }<br></p><p>        refreshOperation = DispatchWorkItem(….)  // processes the files, returns the results on the main queue<br>        DispatchQueue.global().async(refreshOperation)<br>    }<br>}<br></p><p>This relies on the fact that weak references are thread-safe, and avoids the need for an explicit completion handler which nils the variable.<br></p><p>Thoughts?<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/562c2299436b75df013fb428ddf90ce6?s=50"></div><header><strong>New GCD API change: DispatchWorkItems should be retained by their groups</strong> from <string>Pierre Habouzit</string> &lt;pierre at habouzit.net&gt;<p>July  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 10:01 AM, Karl via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I’d like to propose a change to the new GCD API; that DispatchWorkItems be retained by their groups (and in turn, for them to be retained by their queues). This allows for whoever created the work item to create a weak reference to it, as an indicator for whether or not it has finished executing.<br>&gt; <br>&gt; For example, let’s say I have some kind of class which manages a library of files. I want to have a refresh operation which runs on a background queue, enumerating the documents and perhaps even opening them and extracting some metadata:<br>&gt; <br>&gt; class DocumentLibrary {<br>&gt; <br>&gt;    weak var refreshOperation : DispatchWorkItem?<br>&gt; <br>&gt;    func refresh(force:Bool = false) {<br>&gt; <br>&gt;        If let ongoingOperation = refreshOperation {<br>&gt; 	    if force == true {<br>&gt;                ongoingOperation.cancel()  // force an update<br>&gt;            }<br>&gt;            else {<br>&gt;                return  // already refreshing<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        refreshOperation = DispatchWorkItem(….)  // processes the files, returns the results on the main queue<br>&gt;        DispatchQueue.global().async(refreshOperation)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; This relies on the fact that weak references are thread-safe, and avoids the need for an explicit completion handler which nils the variable.<br>&gt; <br>&gt; Thoughts?<br></p><p>DispatchWorkItem.init() taking a group was a mistake and we are preparing an updated proposal to remove this and instead have a queue.async() overload that can take both a WorkItem and a group. The reason why is that the semantics of having a group attached to a DispatchWorkItem() is not useful, you most of the time want to enter() the group when the WorkItem is created, and have it consumed when it has run, but that not what the implementation does, it instead will enter the group at async() time.<br></p><p>However, if we changed the semantics to enter() at creation time, it would mean that the WorkItem could be asynced only once, which is a huge pitfall and design issue too.<br></p><p><br>As far as your proposal goes:<br>- dispatch groups are a single atomic counter and have no storage to own a reference on the WorkItem, changing this would dramatically change the performance profile of that existing API which is a non starter<br>- anything could still have references on the DispatchWorkItem and using weak references to poll for completion is both a bad design (IMO) and fraught with peril<br></p><p>DispatchWorkItem come with .notify() and .wait() which are the things you should use for this. You should have a .notify() block that sets a boolean, on your class to track this.<br></p><p>Also using the global() queues is also fraught with another peril: thread explosion, but that’s probably outside of the scope of your feature request.<br></p><p>-Pierre<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160707/4fa64a7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/562c2299436b75df013fb428ddf90ce6?s=50"></div><header><strong>New GCD API change: DispatchWorkItems should be retained by their groups</strong> from <string>Pierre Habouzit</string> &lt;pierre at habouzit.net&gt;<p>July  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 11:03 AM, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 7, 2016, at 10:01 AM, Karl via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I’d like to propose a change to the new GCD API; that DispatchWorkItems be retained by their groups (and in turn, for them to be retained by their queues). This allows for whoever created the work item to create a weak reference to it, as an indicator for whether or not it has finished executing.<br></p><p>Oh also, and that is a common misconception, groups have absolutely no ownership information so this “(… to be retained by their queues)” is not something that exists or is a thing.<br></p><p>What does exist is that a group is never destroyed while it has unbalanced enter/leaves, and the DispatchWorkItem is definitely retained by any queue it has been async()ed to (you can async a single WorkItem to several places, however that precludes you from using .notify() or .wait()).<br></p><p>&gt;&gt; For example, let’s say I have some kind of class which manages a library of files. I want to have a refresh operation which runs on a background queue, enumerating the documents and perhaps even opening them and extracting some metadata:<br>&gt;&gt; <br>&gt;&gt; class DocumentLibrary {<br>&gt;&gt; <br>&gt;&gt;    weak var refreshOperation : DispatchWorkItem?<br>&gt;&gt; <br>&gt;&gt;    func refresh(force:Bool = false) {<br>&gt;&gt; <br>&gt;&gt;        If let ongoingOperation = refreshOperation {<br>&gt;&gt; 	    if force == true {<br>&gt;&gt;                ongoingOperation.cancel()  // force an update<br>&gt;&gt;            }<br>&gt;&gt;            else {<br>&gt;&gt;                return  // already refreshing<br>&gt;&gt;            }<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        refreshOperation = DispatchWorkItem(….)  // processes the files, returns the results on the main queue<br>&gt;&gt;        DispatchQueue.global().async(refreshOperation)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This relies on the fact that weak references are thread-safe, and avoids the need for an explicit completion handler which nils the variable.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; DispatchWorkItem.init() taking a group was a mistake and we are preparing an updated proposal to remove this and instead have a queue.async() overload that can take both a WorkItem and a group. The reason why is that the semantics of having a group attached to a DispatchWorkItem() is not useful, you most of the time want to enter() the group when the WorkItem is created, and have it consumed when it has run, but that not what the implementation does, it instead will enter the group at async() time.<br>&gt; <br>&gt; However, if we changed the semantics to enter() at creation time, it would mean that the WorkItem could be asynced only once, which is a huge pitfall and design issue too.<br>&gt; <br>&gt; <br>&gt; As far as your proposal goes:<br>&gt; - dispatch groups are a single atomic counter and have no storage to own a reference on the WorkItem, changing this would dramatically change the performance profile of that existing API which is a non starter<br>&gt; - anything could still have references on the DispatchWorkItem and using weak references to poll for completion is both a bad design (IMO) and fraught with peril<br>&gt; <br>&gt; DispatchWorkItem come with .notify() and .wait() which are the things you should use for this. You should have a .notify() block that sets a boolean, on your class to track this.<br>&gt; <br>&gt; Also using the global() queues is also fraught with another peril: thread explosion, but that’s probably outside of the scope of your feature request.<br></p><p><br>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160707/b4b49b30/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
