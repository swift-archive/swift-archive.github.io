<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>Following on from discussion about stored properties for enums, I&#39;ve decided to split off discussion about the possibility of enabling tuples as raw values.<br></p><p>Currently to enable multi-part raw values we need to define a struct that conforms to RawRepresentable; this involves a lot of boilerplate however, and seems like exactly the kind of thing that tuples are ideally suited towards simplifying.<br></p><p>To make tuples automatically conform to RawRepresentable will likely require some compiler magic, but I think it&#39;s worth doing, and should be doable with the following additions:<br></p><p>A TupleType protocol (uncertain of correct name for it) to which all specific tuple types will automatically conform, and to which user-defined types may not. This is simply a marker type for now (no methods etc.), as it is essentially just to enable the following:<br>An ExpressableAsTuple protocol, following the same style as other ExpressableAs* protocols, with the associated type conforming to TupleType, thus requiring that it be a specific tuple definition. All specific tuple types are automatically expressible as themselves.<br>All tuples will then conform to RawRepresentable, simply returning themselves as their raw value. This may require some magic as well, since I don&#39;t know if we want tuples to gain a .rawValue property or not, so could be exposed only when handling them as RawRepresentable specifically?<br></p><p>With ExpressableAsTuple recognised as RawRepresentable, I believe this should satisfy all requirements such that enums, and other types requiring literals, will be able to accept tuples in addition to the types that they currently do.<br></p><p>I think I&#39;ve covered the requirements here, and I&#39;m hoping someone can confirm if this looks correct. Of course I&#39;m open to any other suggestions on how we might enable tuples as literals, especially if there&#39;s an easier way!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/8067a433/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 14, 2016 at 03:00:00am</p></header><div class="content"><p>I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br></p><p>- Dave Sweeris <br></p><p>&gt; On Oct 14, 2016, at 03:24, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Following on from discussion about stored properties for enums, I&#39;ve decided to split off discussion about the possibility of enabling tuples as raw values.<br>&gt; <br>&gt; Currently to enable multi-part raw values we need to define a struct that conforms to RawRepresentable; this involves a lot of boilerplate however, and seems like exactly the kind of thing that tuples are ideally suited towards simplifying.<br>&gt; <br>&gt; To make tuples automatically conform to RawRepresentable will likely require some compiler magic, but I think it&#39;s worth doing, and should be doable with the following additions:<br>&gt; <br>&gt; A TupleType protocol (uncertain of correct name for it) to which all specific tuple types will automatically conform, and to which user-defined types may not. This is simply a marker type for now (no methods etc.), as it is essentially just to enable the following:<br>&gt; An ExpressableAsTuple protocol, following the same style as other ExpressableAs* protocols, with the associated type conforming to TupleType, thus requiring that it be a specific tuple definition. All specific tuple types are automatically expressible as themselves.<br>&gt; All tuples will then conform to RawRepresentable, simply returning themselves as their raw value. This may require some magic as well, since I don&#39;t know if we want tuples to gain a .rawValue property or not, so could be exposed only when handling them as RawRepresentable specifically?<br>&gt; <br>&gt; With ExpressableAsTuple recognised as RawRepresentable, I believe this should satisfy all requirements such that enums, and other types requiring literals, will be able to accept tuples in addition to the types that they currently do.<br>&gt; <br>&gt; I think I&#39;ve covered the requirements here, and I&#39;m hoping someone can confirm if this looks correct. Of course I&#39;m open to any other suggestions on how we might enable tuples as literals, especially if there&#39;s an easier way!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/e3167e2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 09:49, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br>&gt; <br>&gt; - Dave Sweeris <br></p><p>Well it&#39;s not too much in the way of magic really, more just that we need Swift to see tuples as conforming to RawRepresentable and ExpressableAsTuple, although they currently aren&#39;t types in the normal sense. So the protocols being used will be the same as you might use yourself, they&#39;ll just be applied automatically for tuples.<br></p><p>It&#39;d be neat if it could be done properly, but that could involve even more work, but doing this automatically for now should be fairly simple (though I say that as a person who wouldn&#39;t be the one doing it ;)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>You can already do this; you just need to implement RawRep manually.<br></p><p>What I think you mean to propose is that the compiler shorthand we have (which synthesises the conformance if you use the equal signs next to the cases) be extended to support tuples of the types it currently supports. That&#39;s a relatively simple, non-source-breaking additive change. It likely doesn&#39;t fit in the scope of swift 4 phase 1, though (sorry, I&#39;ve been guilty of chatting about non-abi stuff too as I encounter things which irritate me; trying to be more disciplined)<br></p><p>Karl<br></p><p>Sent from my iPad<br></p><p>&gt; On 14 Oct 2016, at 12:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 09:49, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris <br>&gt; <br>&gt; Well it&#39;s not too much in the way of magic really, more just that we need Swift to see tuples as conforming to RawRepresentable and ExpressableAsTuple, although they currently aren&#39;t types in the normal sense. So the protocols being used will be the same as you might use yourself, they&#39;ll just be applied automatically for tuples.<br>&gt; <br>&gt; It&#39;d be neat if it could be done properly, but that could involve even more work, but doing this automatically for now should be fairly simple (though I say that as a person who wouldn&#39;t be the one doing it ;)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/377369d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Example:<br></p><p><br>enum something {<br>    case onething<br>    case anotherthing<br>}<br>extension something : RawRepresentable {<br>    typealias RawValue = (Int, Int)<br>    <br>    init?(rawValue: something.RawValue) {<br>        switch rawValue {<br>        case (1, 1):<br>            self = .onething <br>        case (2, _):<br>            self = .anotherthing<br>        default:<br>            return  nil <br>        }<br>    }<br>    <br>    var rawValue: (Int, Int) {<br>        switch self {<br>        case .onething: return (1, 1)<br>        case .anotherthing: return (2, 0)<br>        }<br>    }<br>}<br></p><p>let whatisit = something(rawValue: (1, 1))<br>something.onething.rawValue<br></p><p>Karl<br></p><p>Sent from my iPad<br></p><p>&gt; On 14 Oct 2016, at 19:04, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; You can already do this; you just need to implement RawRep manually.<br>&gt; <br>&gt; What I think you mean to propose is that the compiler shorthand we have (which synthesises the conformance if you use the equal signs next to the cases) be extended to support tuples of the types it currently supports. That&#39;s a relatively simple, non-source-breaking additive change. It likely doesn&#39;t fit in the scope of swift 4 phase 1, though (sorry, I&#39;ve been guilty of chatting about non-abi stuff too as I encounter things which irritate me; trying to be more disciplined)<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 12:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 09:49, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris <br>&gt;&gt; <br>&gt;&gt; Well it&#39;s not too much in the way of magic really, more just that we need Swift to see tuples as conforming to RawRepresentable and ExpressableAsTuple, although they currently aren&#39;t types in the normal sense. So the protocols being used will be the same as you might use yourself, they&#39;ll just be applied automatically for tuples.<br>&gt;&gt; <br>&gt;&gt; It&#39;d be neat if it could be done properly, but that could involve even more work, but doing this automatically for now should be fairly simple (though I say that as a person who wouldn&#39;t be the one doing it ;)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/ac768cb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Huh, see, that&#39;s why I posted the thread; I didn&#39;t know you could do it that way (I&#39;ve been trying the RawRepresentable part as its own type).<br>In that case yes, it seems like all that&#39;s need is an expansion of what&#39;s allowable on the rhs of raw value enum cases.<br></p><p>&gt; On 14 Oct 2016, at 18:11, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; <br>&gt; enum something {<br>&gt;     case onething<br>&gt;     case anotherthing<br>&gt; }<br>&gt; extension something : RawRepresentable {<br>&gt;     typealias RawValue = (Int, Int)<br>&gt;     <br>&gt;     init?(rawValue: something.RawValue) {<br>&gt;         switch rawValue {<br>&gt;         case (1, 1):<br>&gt;             self = .onething <br>&gt;         case (2, _):<br>&gt;             self = .anotherthing<br>&gt;         default:<br>&gt;             return  nil <br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var rawValue: (Int, Int) {<br>&gt;         switch self {<br>&gt;         case .onething: return (1, 1)<br>&gt;         case .anotherthing: return (2, 0)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let whatisit = something(rawValue: (1, 1))<br>&gt; something.onething.rawValue<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 14 Oct 2016, at 19:04, Karl Wagner &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; You can already do this; you just need to implement RawRep manually.<br>&gt;&gt; <br>&gt;&gt; What I think you mean to propose is that the compiler shorthand we have (which synthesises the conformance if you use the equal signs next to the cases) be extended to support tuples of the types it currently supports. That&#39;s a relatively simple, non-source-breaking additive change. It likely doesn&#39;t fit in the scope of swift 4 phase 1, though (sorry, I&#39;ve been guilty of chatting about non-abi stuff too as I encounter things which irritate me; trying to be more disciplined)<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 14 Oct 2016, at 12:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 09:49, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well it&#39;s not too much in the way of magic really, more just that we need Swift to see tuples as conforming to RawRepresentable and ExpressableAsTuple, although they currently aren&#39;t types in the normal sense. So the protocols being used will be the same as you might use yourself, they&#39;ll just be applied automatically for tuples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;d be neat if it could be done properly, but that could involve even more work, but doing this automatically for now should be fairly simple (though I say that as a person who wouldn&#39;t be the one doing it ;)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/d3cd5a97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 19:56, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; Huh, see, that&#39;s why I posted the thread; I didn&#39;t know you could do it that way (I&#39;ve been trying the RawRepresentable part as its own type).<br>&gt; In that case yes, it seems like all that&#39;s need is an expansion of what&#39;s allowable on the rhs of raw value enum cases.<br>&gt; <br></p><p>And that’s why I come here - to share the little bits that I’ve learned :)<br></p><p>I think a lot of people have misconceptions about what RawRep is, and the inheritance syntax for enums doesn’t much help that. It doesn’t affect the storage or layout of the enum whatsoever; it’s just a protocol conformance. The compiler generates these same kind of switch statements, and that’s really the only reason AFAIK that we have the limitations (e.g. int/string literal) that we do.<br></p><p>There are no restrictions on what can be RawRepresentable (structs and classes can also conform), and no limitation on the type of RawType (can also be a struct or a class). You just need to implement it yourself in those cases; I’m guessing because there are complex edge-cases which we don’t want hidden away in a location you can’t easily debug.<br></p><p>Tuples of Ints and Strings, however, seem like they could easily be supported. For example, we could check that there are no overlapping cases.<br></p><p>- Karl<br></p><p>&gt;&gt; On 14 Oct 2016, at 18:11, Karl Wagner &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; enum something {<br>&gt;&gt;     case onething<br>&gt;&gt;     case anotherthing<br>&gt;&gt; }<br>&gt;&gt; extension something : RawRepresentable {<br>&gt;&gt;     typealias RawValue = (Int, Int)<br>&gt;&gt;     <br>&gt;&gt;     init?(rawValue: something.RawValue) {<br>&gt;&gt;         switch rawValue {<br>&gt;&gt;         case (1, 1):<br>&gt;&gt;             self = .onething <br>&gt;&gt;         case (2, _):<br>&gt;&gt;             self = .anotherthing<br>&gt;&gt;         default:<br>&gt;&gt;             return  nil <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var rawValue: (Int, Int) {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .onething: return (1, 1)<br>&gt;&gt;         case .anotherthing: return (2, 0)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let whatisit = something(rawValue: (1, 1))<br>&gt;&gt; something.onething.rawValue<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 14 Oct 2016, at 19:04, Karl Wagner &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; You can already do this; you just need to implement RawRep manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I think you mean to propose is that the compiler shorthand we have (which synthesises the conformance if you use the equal signs next to the cases) be extended to support tuples of the types it currently supports. That&#39;s a relatively simple, non-source-breaking additive change. It likely doesn&#39;t fit in the scope of swift 4 phase 1, though (sorry, I&#39;ve been guilty of chatting about non-abi stuff too as I encounter things which irritate me; trying to be more disciplined)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 12:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 14 Oct 2016, at 09:49, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m very much in favor of the functionality, but I don&#39;t think the implementation should rely on compiler magic.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well it&#39;s not too much in the way of magic really, more just that we need Swift to see tuples as conforming to RawRepresentable and ExpressableAsTuple, although they currently aren&#39;t types in the normal sense. So the protocols being used will be the same as you might use yourself, they&#39;ll just be applied automatically for tuples.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;d be neat if it could be done properly, but that could involve even more work, but doing this automatically for now should be fairly simple (though I say that as a person who wouldn&#39;t be the one doing it ;)<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/956a6b80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 15, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 19:11, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 19:56, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Huh, see, that&#39;s why I posted the thread; I didn&#39;t know you could do it that way (I&#39;ve been trying the RawRepresentable part as its own type).<br>&gt;&gt; In that case yes, it seems like all that&#39;s need is an expansion of what&#39;s allowable on the rhs of raw value enum cases.<br>&gt;&gt; <br>&gt; <br>&gt; And that’s why I come here - to share the little bits that I’ve learned :)<br>&gt; <br>&gt; I think a lot of people have misconceptions about what RawRep is, and the inheritance syntax for enums doesn’t much help that. It doesn’t affect the storage or layout of the enum whatsoever; it’s just a protocol conformance. The compiler generates these same kind of switch statements, and that’s really the only reason AFAIK that we have the limitations (e.g. int/string literal) that we do.<br>&gt; <br>&gt; There are no restrictions on what can be RawRepresentable (structs and classes can also conform), and no limitation on the type of RawType (can also be a struct or a class). You just need to implement it yourself in those cases; I’m guessing because there are complex edge-cases which we don’t want hidden away in a location you can’t easily debug.<br>&gt; <br>&gt; Tuples of Ints and Strings, however, seem like they could easily be supported. For example, we could check that there are no overlapping cases.<br></p><p>Does the type of the tuples really matter? For equality it should be sufficient just to compare them directly as bytes; since they will be of the same tuple type this should either result in equality or not without too much complexity, otherwise we&#39;d need to require the types are Equatable or Hashable but that seems a bit like overkill.<br></p><p>I&#39;ve started a preliminary proposal for tuples as enum raw value types; it&#39;s pretty straightforward so far as I&#39;m not sure what more detail is really needed, except perhaps for this equality issue:<br>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-allow-tuples-as-enum-raw-values.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/e696ffdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes it absolutely matters what the types are. Two floating point values can<br>compare equal when their raw bytes differ and they can compare not equal<br>even when their raw bytes are the same, and it would be absolutely<br>necessary that a tuple of two floating point values behaves the same way.<br></p><p>Moreover, if a value is not equatable, it&#39;s nonsense to ask if tuples of<br>two of them are equal. Otherwise, you&#39;ve effectively forced every value<br>type to be equatable, since it&#39;d be ridiculous if (a, a) == (b, b) didn&#39;t<br>imply a == b.<br></p><p>On Sat, Oct 15, 2016 at 19:44 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 14 Oct 2016, at 19:11, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 14 Oct 2016, at 19:56, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; Huh, see, that&#39;s why I posted the thread; I didn&#39;t know you could do it<br>&gt; that way (I&#39;ve been trying the RawRepresentable part as its own type).<br>&gt; In that case yes, it seems like all that&#39;s need is an expansion of what&#39;s<br>&gt; allowable on the rhs of raw value enum cases.<br>&gt;<br>&gt;<br>&gt; And that’s why I come here - to share the little bits that I’ve learned :)<br>&gt;<br>&gt; I think a lot of people have misconceptions about what RawRep is, and the<br>&gt; inheritance syntax for enums doesn’t much help that. It doesn’t affect the<br>&gt; storage or layout of the enum whatsoever; it’s just a protocol conformance.<br>&gt; The compiler generates these same kind of switch statements, and that’s<br>&gt; really the only reason AFAIK that we have the limitations (e.g. int/string<br>&gt; literal) that we do.<br>&gt;<br>&gt; There are no restrictions on what can be RawRepresentable (structs and<br>&gt; classes can also conform), and no limitation on the type of RawType (can<br>&gt; also be a struct or a class). You just need to implement it yourself in<br>&gt; those cases; I’m guessing because there are complex edge-cases which we<br>&gt; don’t want hidden away in a location you can’t easily debug.<br>&gt;<br>&gt; Tuples of Ints and Strings, however, seem like they could easily be<br>&gt; supported. For example, we could check that there are no overlapping cases.<br>&gt;<br>&gt;<br>&gt; Does the type of the tuples really matter? For equality it should be<br>&gt; sufficient just to compare them directly as bytes; since they will be of<br>&gt; the same tuple type this should either result in equality or not without<br>&gt; too much complexity, otherwise we&#39;d need to require the types are Equatable<br>&gt; or Hashable but that seems a bit like overkill.<br>&gt;<br>&gt; I&#39;ve started a preliminary proposal for tuples as enum raw value types;<br>&gt; it&#39;s pretty straightforward so far as I&#39;m not sure what more detail is<br>&gt; really needed, except perhaps for this equality issue:<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-allow-tuples-as-enum-raw-values.md<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/66331c21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 15 Oct 2016, at 16:04, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes it absolutely matters what the types are. Two floating point values can compare equal when their raw bytes differ and they can compare not equal even when their raw bytes are the same, and it would be absolutely necessary that a tuple of two floating point values behaves the same way.<br>&gt; <br>&gt; Moreover, if a value is not equatable, it&#39;s nonsense to ask if tuples of two of them are equal. Otherwise, you&#39;ve effectively forced every value type to be equatable, since it&#39;d be ridiculous if (a, a) == (b, b) didn&#39;t imply a == b.<br></p><p>All I meant really is that you can always compare equality at the memory level, regardless of Equatable conformance; the type checker ensures the tuples being compared can only contain the same types in the same order, at which point a bitwise memory comparison can determine they are equal in the strictest possible sense, much like comparing whether two object references point to the same object (you&#39;re comparing the pointers).<br></p><p>But actually it doesn&#39;t seem to even matter; tuples are already Equatable if all of their components are (again, something I don&#39;t seem to actually use), so that should be more than sufficient for using them as enum raw values, we can just ignore tuples that aren&#39;t/require the developer to add Equatable to any components that aren&#39;t.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/02645fccf0e885c607f3d07a4abf4f95?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Saagar Jha</string> &lt;saagar at saagarjha.com&gt;<p>October 15, 2016 at 05:00:00pm</p></header><div class="content"><p>If you&#39;re looking for a use case for tuple equality, I often pack a bunch<br>of values in a tuple and check it with another, which makes it easy to<br>compare a multiple values at once and perform something only if all of them<br>are equal.<br></p><p>On Sat, Oct 15, 2016 at 09:28 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 15 Oct 2016, at 16:04, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes it absolutely matters what the types are. Two floating point values<br>&gt; can compare equal when their raw bytes differ and they can compare not<br>&gt; equal even when their raw bytes are the same, and it would be absolutely<br>&gt; necessary that a tuple of two floating point values behaves the same way.<br>&gt; &gt;<br>&gt; &gt; Moreover, if a value is not equatable, it&#39;s nonsense to ask if tuples of<br>&gt; two of them are equal. Otherwise, you&#39;ve effectively forced every value<br>&gt; type to be equatable, since it&#39;d be ridiculous if (a, a) == (b, b) didn&#39;t<br>&gt; imply a == b.<br>&gt;<br>&gt; All I meant really is that you can always compare equality at the memory<br>&gt; level, regardless of Equatable conformance; the type checker ensures the<br>&gt; tuples being compared can only contain the same types in the same order, at<br>&gt; which point a bitwise memory comparison can determine they are equal in the<br>&gt; strictest possible sense, much like comparing whether two object references<br>&gt; point to the same object (you&#39;re comparing the pointers).<br>&gt;<br>&gt; But actually it doesn&#39;t seem to even matter; tuples are already Equatable<br>&gt; if all of their components are (again, something I don&#39;t seem to actually<br>&gt; use), so that should be more than sufficient for using them as enum raw<br>&gt; values, we can just ignore tuples that aren&#39;t/require the developer to add<br>&gt; Equatable to any components that aren&#39;t.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/053fda50/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Tuples cannot conform to protocols, so despite the existence of an “==”<br>operator for certain tuples, no tuple conforms to Equatable.<br></p><p>This is problematic, because it means that a function which takes a generic<br>Equatable parameter cannot be called with a tuple argument, even though an<br>applicable “==” operator exists.<br></p><p>(Ditto for “Comparable”, *mutatis mutandis*.)<br></p><p>Nevin<br></p><p><br></p><p>On Sat, Oct 15, 2016 at 12:28 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 15 Oct 2016, at 16:04, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes it absolutely matters what the types are. Two floating point values<br>&gt; can compare equal when their raw bytes differ and they can compare not<br>&gt; equal even when their raw bytes are the same, and it would be absolutely<br>&gt; necessary that a tuple of two floating point values behaves the same way.<br>&gt; &gt;<br>&gt; &gt; Moreover, if a value is not equatable, it&#39;s nonsense to ask if tuples of<br>&gt; two of them are equal. Otherwise, you&#39;ve effectively forced every value<br>&gt; type to be equatable, since it&#39;d be ridiculous if (a, a) == (b, b) didn&#39;t<br>&gt; imply a == b.<br>&gt;<br>&gt; All I meant really is that you can always compare equality at the memory<br>&gt; level, regardless of Equatable conformance; the type checker ensures the<br>&gt; tuples being compared can only contain the same types in the same order, at<br>&gt; which point a bitwise memory comparison can determine they are equal in the<br>&gt; strictest possible sense, much like comparing whether two object references<br>&gt; point to the same object (you&#39;re comparing the pointers).<br>&gt;<br>&gt; But actually it doesn&#39;t seem to even matter; tuples are already Equatable<br>&gt; if all of their components are (again, something I don&#39;t seem to actually<br>&gt; use), so that should be more than sufficient for using them as enum raw<br>&gt; values, we can just ignore tuples that aren&#39;t/require the developer to add<br>&gt; Equatable to any components that aren&#39;t.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/6a490a15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 15 Oct 2016, at 18:21, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; Tuples cannot conform to protocols, so despite the existence of an “==” operator for certain tuples, no tuple conforms to Equatable.<br>&gt; <br>&gt; This is problematic, because it means that a function which takes a generic Equatable parameter cannot be called with a tuple argument, even though an applicable “==” operator exists.<br>&gt; <br>&gt; (Ditto for “Comparable”, mutatis mutandis.)<br>&gt; <br>&gt; Nevin<br></p><p>Yeah, since the operators are implemented though perhaps some kind of magic can be used? It seems strange that the following is valid:<br></p><p>	struct Foo : Equatable { let value:(Int, Int) }<br>	func == (lhs:Foo, rhs:Foo) -&gt; Bool { return lhs.value == rhs.value }<br></p><p>Yet tuples can&#39;t just be Equatable etc. But I&#39;m wondering whether that falls into separate issue territory, such that it should be done first as its own proposal?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/e797139a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 16 Oct 2016, at 00:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 15 Oct 2016, at 18:21, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com &lt;mailto:nevin.brackettrozinsky at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Tuples cannot conform to protocols, so despite the existence of an “==” operator for certain tuples, no tuple conforms to Equatable.<br>&gt;&gt; <br>&gt;&gt; This is problematic, because it means that a function which takes a generic Equatable parameter cannot be called with a tuple argument, even though an applicable “==” operator exists.<br>&gt;&gt; <br>&gt;&gt; (Ditto for “Comparable”, mutatis mutandis.)<br>&gt;&gt; <br>&gt;&gt; Nevin<br>&gt; <br>&gt; Yeah, since the operators are implemented though perhaps some kind of magic can be used? It seems strange that the following is valid:<br>&gt; <br>&gt; 	struct Foo : Equatable { let value:(Int, Int) }<br>&gt; 	func == (lhs:Foo, rhs:Foo) -&gt; Bool { return lhs.value == rhs.value }<br>&gt; <br>&gt; Yet tuples can&#39;t just be Equatable etc. But I&#39;m wondering whether that falls into separate issue territory, such that it should be done first as its own proposal?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Tuples are non-nominal (named) types, and that’s why they can’t conform to protocols. There is something in the generics manifesto about possibly allowing them to do that in the future, though: <br></p><p>https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br>&gt; Extensions of structural types<br>&gt; <br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express &quot;a tuple type is Equatable if all of its element types are Equatable&quot;:<br>&gt; <br>&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type &quot;(Elements...)&quot; to be Equatable<br>&gt; }<br></p><p><br>- Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/90739701/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 16 Oct 2016, at 11:55, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Oct 2016, at 00:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Oct 2016, at 18:21, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com &lt;mailto:nevin.brackettrozinsky at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tuples cannot conform to protocols, so despite the existence of an “==” operator for certain tuples, no tuple conforms to Equatable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is problematic, because it means that a function which takes a generic Equatable parameter cannot be called with a tuple argument, even though an applicable “==” operator exists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Ditto for “Comparable”, mutatis mutandis.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nevin<br>&gt;&gt; <br>&gt;&gt; Yeah, since the operators are implemented though perhaps some kind of magic can be used? It seems strange that the following is valid:<br>&gt;&gt; <br>&gt;&gt; 	struct Foo : Equatable { let value:(Int, Int) }<br>&gt;&gt; 	func == (lhs:Foo, rhs:Foo) -&gt; Bool { return lhs.value == rhs.value }<br>&gt;&gt; <br>&gt;&gt; Yet tuples can&#39;t just be Equatable etc. But I&#39;m wondering whether that falls into separate issue territory, such that it should be done first as its own proposal?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Tuples are non-nominal (named) types, and that’s why they can’t conform to protocols. There is something in the generics manifesto about possibly allowing them to do that in the future, though: <br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br>&gt;&gt; Extensions of structural types<br>&gt;&gt; <br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express &quot;a tuple type is Equatable if all of its element types are Equatable&quot;:<br>&gt;&gt; <br>&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type &quot;(Elements...)&quot; to be Equatable<br>&gt;&gt; }<br>&gt; <br>&gt; - Karl<br></p><p>Yeah, but that&#39;s much further reaching overall; I&#39;m wondering whether it&#39;s okay to just call tuples of Equatable types Equatable for the purposes of getting them as enum raw values? I&#39;ll maybe put some discussion of timing and other issues into the proposal for this, to keep it open ended.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/3b2b68e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Tuples as RawRepresentable</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 16, 2016 at 01:00:00pm</p></header><div class="content"><p>It may be farther reaching, but it&#39;s quite salient. Completing genetics is<br>a Swift 4 focus, and protocol conformance and extensions of structural<br>types may well have ABI implications, which would make it a phase 1<br>priority.<br></p><p>Recall that equality for tuples of Equatables is only defined up to an<br>arity of 6, and that it was implemented in that way as a stopgap. With a<br>plausible definitive solution in scope for Swift 4, it seems less than<br>ideal to propose entrenching the stopgap measure by making it even more<br>elaborate.<br></p><p>On Sun, Oct 16, 2016 at 19:47 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 16 Oct 2016, at 11:55, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 16 Oct 2016, at 00:33, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Oct 2016, at 18:21, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt; Tuples cannot conform to protocols, so despite the existence of an “==”<br>&gt; operator for certain tuples, no tuple conforms to Equatable.<br>&gt;<br>&gt; This is problematic, because it means that a function which takes a<br>&gt; generic Equatable parameter cannot be called with a tuple argument, even<br>&gt; though an applicable “==” operator exists.<br>&gt;<br>&gt; (Ditto for “Comparable”, *mutatis mutandis*.)<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; Yeah, since the operators are implemented though perhaps some kind of<br>&gt; magic can be used? It seems strange that the following is valid:<br>&gt;<br>&gt; struct Foo : Equatable { let value:(Int, Int) }<br>&gt; func == (lhs:Foo, rhs:Foo) -&gt; Bool { return lhs.value == rhs.value }<br>&gt;<br>&gt; Yet tuples can&#39;t just be Equatable etc. But I&#39;m wondering whether that<br>&gt; falls into separate issue territory, such that it should be done first as<br>&gt; its own proposal?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; Tuples are non-nominal (named) types, and that’s why they can’t conform to<br>&gt; protocols. There is something in the generics manifesto about possibly<br>&gt; allowing them to do that in the future, though:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types<br>&gt;<br>&gt; Extensions of structural types<br>&gt;<br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be<br>&gt; extended. One could imagine extending structural types—particularly tuple<br>&gt; types—to allow them to, e.g., conform to protocols. For example, pulling<br>&gt; together variadic generics, parameterized extensions, and conditional<br>&gt; conformances, one could express &quot;a tuple type is Equatable if all of its<br>&gt; element types are Equatable&quot;:<br>&gt;<br>&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type &quot;(Elements...)&quot; to be Equatable<br>&gt; }<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt; Yeah, but that&#39;s much further reaching overall; I&#39;m wondering whether it&#39;s<br>&gt; okay to just call tuples of Equatable types Equatable for the purposes of<br>&gt; getting them as enum raw values? I&#39;ll maybe put some discussion of timing<br>&gt; and other issues into the proposal for this, to keep it open ended.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/3b0b6c0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
