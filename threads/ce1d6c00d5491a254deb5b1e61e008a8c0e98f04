<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April 17, 2016 at 11:00:00am</p></header><div class="content"><p>I have a class that is conforming to a protocol with a method that requires a specific return type.<br>In case I want to return a subclass of the return type I am forced to use an associatedtype that feels like a hack.<br></p><p>As an example:<br></p><p>protocol MyShapeProtocol {<br>    func make() -&gt; Shape?<br>}<br></p><p>class Circle : Shape {}<br></p><p>class CircleMaker : MyShapeProtocol{<br>    func make() -&gt; Circle? {<br>        return Circle()<br>    }<br>}<br></p><p>This will not work.<br>For that to work I’ll need to use toe associatedtype “hack”:<br></p><p>protocol MyShapeProtocol {<br>    associatedtype ShapeReturnType : Shape<br>    func make() -&gt; ShapeReturnType?<br>}<br></p><p>class Circle : Shape {}<br></p><p>class CircleMaker : MyShapeProtocol{<br>    func make() -&gt; Circle? {<br>        return Circle()<br>    }<br>}<br></p><p>Is there a real value in adding the associatedtype line?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/ce1d8f04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 18, 2016 at 08:00:00am</p></header><div class="content"><p>I think this should be part of completing generics.<br></p><p>On Sunday, 17 April 2016, Yogev Sitton via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I have a class that is conforming to a protocol with a method that<br>&gt; requires a specific return type.<br>&gt; In case I want to return a subclass of the return type I am forced to use<br>&gt; an associatedtype that feels like a hack.<br>&gt;<br>&gt; As an example:<br>&gt;<br>&gt; *protocol MyShapeProtocol {*<br>&gt; *    func make() -&gt; Shape?*<br>&gt; *}*<br>&gt;<br>&gt; *class Circle : Shape {}*<br>&gt;<br>&gt; *class CircleMaker : MyShapeProtocol{*<br>&gt; *    func make() -&gt; Circle? {*<br>&gt; *        return Circle()*<br>&gt; *    }*<br>&gt; *}*<br>&gt;<br>&gt; This will not work.<br>&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt;<br>&gt; *protocol MyShapeProtocol {*<br>&gt; *    associatedtype ShapeReturnType : Shape*<br>&gt; *    func make() -&gt; ShapeReturnType?*<br>&gt; *}*<br>&gt;<br>&gt; *class Circle : Shape {}*<br>&gt;<br>&gt; *class CircleMaker : MyShapeProtocol{*<br>&gt; *    func make() -&gt; Circle? {*<br>&gt; *        return Circle()*<br>&gt; *    }*<br>&gt; *}*<br>&gt;<br>&gt; Is there a real value in adding the associatedtype line?<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/b0921323/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April 17, 2016 at 11:00:00pm</p></header><div class="content"><p>In what way?<br></p><p><br></p><p><br></p><p>On Sun, Apr 17, 2016 at 3:53 PM -0700, &quot;Howard Lovatt&quot; &lt;howard.lovatt at gmail.com&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>I think this should be part of completing generics.<br></p><p>On Sunday, 17 April 2016, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>I have a class that is conforming to a protocol with a method that requires a specific return type.In case I want to return a subclass of the return type I am forced to use an associatedtype that feels like a hack.<br>As an example:<br>protocol MyShapeProtocol {    func make() -&gt; Shape?}<br>class Circle : Shape {}<br>class CircleMaker : MyShapeProtocol{    func make() -&gt; Circle? {        return Circle()    }}<br>This will not work.For that to work I’ll need to use toe associatedtype “hack”:<br>protocol MyShapeProtocol {    associatedtype ShapeReturnType : Shape    func make() -&gt; ShapeReturnType?}<br>class Circle : Shape {}<br>class CircleMaker : MyShapeProtocol{    func make() -&gt; Circle? {        return Circle()    }}<br>Is there a real value in adding the associatedtype line?<br></p><p>-- <br>-- Howard.<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/bb8feda9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April 18, 2016 at 10:00:00am</p></header><div class="content"><p>As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a<br>closure of type () -&gt; Circle would be considered a match.  If a class<br>implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt;<br>Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt;<br>Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be<br>conforming. That does seem strange.<br></p><p>On Mon, Apr 18, 2016 at 12:55 AM, Yogev Sitton via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In what way?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Apr 17, 2016 at 3:53 PM -0700, &quot;Howard Lovatt&quot; &lt;<br>&gt; howard.lovatt at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think this should be part of completing generics.<br>&gt;&gt;<br>&gt;&gt; On Sunday, 17 April 2016, Yogev Sitton via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I have a class that is conforming to a protocol with a method that<br>&gt;&gt;&gt; requires a specific return type.<br>&gt;&gt;&gt; In case I want to return a subclass of the return type I am forced to<br>&gt;&gt;&gt; use an associatedtype that feels like a hack.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol MyShapeProtocol {*<br>&gt;&gt;&gt; *    func make() -&gt; Shape?*<br>&gt;&gt;&gt; *}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *class Circle : Shape {}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *class CircleMaker : MyShapeProtocol{*<br>&gt;&gt;&gt; *    func make() -&gt; Circle? {*<br>&gt;&gt;&gt; *        return Circle()*<br>&gt;&gt;&gt; *    }*<br>&gt;&gt;&gt; *}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will not work.<br>&gt;&gt;&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol MyShapeProtocol {*<br>&gt;&gt;&gt; *    associatedtype ShapeReturnType : Shape*<br>&gt;&gt;&gt; *    func make() -&gt; ShapeReturnType?*<br>&gt;&gt;&gt; *}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *class Circle : Shape {}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *class CircleMaker : MyShapeProtocol{*<br>&gt;&gt;&gt; *    func make() -&gt; Circle? {*<br>&gt;&gt;&gt; *        return Circle()*<br>&gt;&gt;&gt; *    }*<br>&gt;&gt;&gt; *}*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there a real value in adding the associatedtype line?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -- Howard.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/c771765b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>That’s exactly my point - thank you for the quick summary Ross.<br>Protocols behaves differently than closures and classes.<br></p><p>&gt; On Apr 18, 2016, at 12:40 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a closure of type () -&gt; Circle would be considered a match.  If a class implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be conforming. That does seem strange.<br>&gt; <br>&gt; On Mon, Apr 18, 2016 at 12:55 AM, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; In what way?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Apr 17, 2016 at 3:53 PM -0700, &quot;Howard Lovatt&quot; &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; I think this should be part of completing generics.<br>&gt; <br>&gt; On Sunday, 17 April 2016, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I have a class that is conforming to a protocol with a method that requires a specific return type.<br>&gt; In case I want to return a subclass of the return type I am forced to use an associatedtype that feels like a hack.<br>&gt; <br>&gt; As an example:<br>&gt; <br>&gt; protocol MyShapeProtocol {<br>&gt;     func make() -&gt; Shape?<br>&gt; }<br>&gt; <br>&gt; class Circle : Shape {}<br>&gt; <br>&gt; class CircleMaker : MyShapeProtocol{<br>&gt;     func make() -&gt; Circle? {<br>&gt;         return Circle()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This will not work.<br>&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt; <br>&gt; protocol MyShapeProtocol {<br>&gt;     associatedtype ShapeReturnType : Shape<br>&gt;     func make() -&gt; ShapeReturnType?<br>&gt; }<br>&gt; <br>&gt; class Circle : Shape {}<br>&gt; <br>&gt; class CircleMaker : MyShapeProtocol{<br>&gt;     func make() -&gt; Circle? {<br>&gt;         return Circle()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is there a real value in adding the associatedtype line?<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/e8457533/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 18, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Yogev,<br></p><p>I think your question belongs to the swift-users mailing list (quoting https://lists.swift.org/mailman/listinfo):<br></p><p>- swift-evolution: Discussion of the evolution of Swift, including new language features and new APIs.<br>- swift-users: For users to get help with or ask questions about Swift or its related tools<br></p><p>Gwendal Roué<br></p><p>&gt; Le 17 avr. 2016 à 10:52, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I have a class that is conforming to a protocol with a method that requires a specific return type.<br>&gt; In case I want to return a subclass of the return type I am forced to use an associatedtype that feels like a hack.<br>&gt; <br>&gt; As an example:<br>&gt; <br>&gt; protocol MyShapeProtocol {<br>&gt;     func make() -&gt; Shape?<br>&gt; }<br>&gt; <br>&gt; class Circle : Shape {}<br>&gt; <br>&gt; class CircleMaker : MyShapeProtocol{<br>&gt;     func make() -&gt; Circle? {<br>&gt;         return Circle()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This will not work.<br>&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt; <br>&gt; protocol MyShapeProtocol {<br>&gt;     associatedtype ShapeReturnType : Shape<br>&gt;     func make() -&gt; ShapeReturnType?<br>&gt; }<br>&gt; <br>&gt; class Circle : Shape {}<br>&gt; <br>&gt; class CircleMaker : MyShapeProtocol{<br>&gt;     func make() -&gt; Circle? {<br>&gt;         return Circle()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is there a real value in adding the associatedtype line?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Gwendal,<br></p><p>I’m actually trying to start a discussion that will change the current behavior of the language.<br>That’s why I posted this on the swift-evolution mailing list and not swift-users.<br></p><p>Yogev<br></p><p>&gt; On Apr 18, 2016, at 12:48 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Yogev,<br>&gt; <br>&gt; I think your question belongs to the swift-users mailing list (quoting https://lists.swift.org/mailman/listinfo):<br>&gt; <br>&gt; - swift-evolution: Discussion of the evolution of Swift, including new language features and new APIs.<br>&gt; - swift-users: For users to get help with or ask questions about Swift or its related tools<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 17 avr. 2016 à 10:52, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I have a class that is conforming to a protocol with a method that requires a specific return type.<br>&gt;&gt; In case I want to return a subclass of the return type I am forced to use an associatedtype that feels like a hack.<br>&gt;&gt; <br>&gt;&gt; As an example:<br>&gt;&gt; <br>&gt;&gt; protocol MyShapeProtocol {<br>&gt;&gt;    func make() -&gt; Shape?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Circle : Shape {}<br>&gt;&gt; <br>&gt;&gt; class CircleMaker : MyShapeProtocol{<br>&gt;&gt;    func make() -&gt; Circle? {<br>&gt;&gt;        return Circle()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This will not work.<br>&gt;&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt;&gt; <br>&gt;&gt; protocol MyShapeProtocol {<br>&gt;&gt;    associatedtype ShapeReturnType : Shape<br>&gt;&gt;    func make() -&gt; ShapeReturnType?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Circle : Shape {}<br>&gt;&gt; <br>&gt;&gt; class CircleMaker : MyShapeProtocol{<br>&gt;&gt;    func make() -&gt; Circle? {<br>&gt;&gt;        return Circle()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is there a real value in adding the associatedtype line?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 18 avr. 2016 à 11:53, Yogev Sitton &lt;yogev.sitton at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Hi Gwendal,<br>&gt; <br>&gt; I’m actually trying to start a discussion that will change the current behavior of the language.<br>&gt; That’s why I posted this on the swift-evolution mailing list and not swift-users.<br></p><p>OK Yogev. But what is the problem actually? If some of your code does not do what you want, is it because of the language, or is it because you still have to learn something about the language?<br></p><p>Associated types are not a &quot;hack&quot;, they are a feature. Maybe you are not using it properly, you see?<br></p><p>If you would tell how those MyShapeProtocol objects are used, it may get clearer.<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April 18, 2016 at 01:00:00pm</p></header><div class="content"><p>I’m referring you to Ross O’Brien’s post:<br>As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a closure of type () -&gt; Circle would be considered a match.  If a class implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be conforming. That does seem strange.<br></p><p>Protocols behaves differently than closures and classes and I think they should behave the same.<br></p><p>&gt; On Apr 18, 2016, at 1:00 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 18 avr. 2016 à 11:53, Yogev Sitton &lt;yogev.sitton at gmail.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi Gwendal,<br>&gt;&gt; <br>&gt;&gt; I’m actually trying to start a discussion that will change the current behavior of the language.<br>&gt;&gt; That’s why I posted this on the swift-evolution mailing list and not swift-users.<br>&gt; <br>&gt; OK Yogev. But what is the problem actually? If some of your code does not do what you want, is it because of the language, or is it because you still have to learn something about the language?<br>&gt; <br>&gt; Associated types are not a &quot;hack&quot;, they are a feature. Maybe you are not using it properly, you see?<br>&gt; <br>&gt; If you would tell how those MyShapeProtocol objects are used, it may get clearer.<br>&gt; <br>&gt; Gwendal<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/ca444bf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 18 avr. 2016 à 12:01, Yogev Sitton &lt;yogev.sitton at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I’m referring you to Ross O’Brien’s post:<br>&gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a closure of type () -&gt; Circle would be considered a match.  If a class implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be conforming. That does seem strange.<br>&gt; <br>&gt; Protocols behaves differently than closures and classes and I think they should behave the same.<br></p><p>All right, I get it.<br></p><p>Shape, as a return type, is &quot;trampoline&quot; data that wraps any Shape value, when Circle is just a Circle. That&#39;s why the two functions () -&gt; Shape? and () -&gt; Circle? don&#39;t match today.<br></p><p>But maybe they will eventually, thanks to your request!<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April 18, 2016 at 11:00:00am</p></header><div class="content"><p>You may have to explain that metaphor (or link to an explanation) - what is<br>&#39;trampoline&#39; data?<br></p><p>On Mon, Apr 18, 2016 at 11:11 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; Le 18 avr. 2016 à 12:01, Yogev Sitton &lt;yogev.sitton at gmail.com&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; I’m referring you to Ross O’Brien’s post:<br>&gt; &gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a<br>&gt; closure of type () -&gt; Circle would be considered a match.  If a class<br>&gt; implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt;<br>&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt;<br>&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be<br>&gt; conforming. That does seem strange.<br>&gt; &gt;<br>&gt; &gt; Protocols behaves differently than closures and classes and I think they<br>&gt; should behave the same.<br>&gt;<br>&gt; All right, I get it.<br>&gt;<br>&gt; Shape, as a return type, is &quot;trampoline&quot; data that wraps any Shape value,<br>&gt; when Circle is just a Circle. That&#39;s why the two functions () -&gt; Shape? and<br>&gt; () -&gt; Circle? don&#39;t match today.<br>&gt;<br>&gt; But maybe they will eventually, thanks to your request!<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/1a1a9ecd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Those &quot;trampolines&quot; are visible in debugger stack traces, or in Instruments, as &quot;protocol witness&quot; function calls. You may have seen them already.<br></p><p>You see, a variable of type SomeProtocol, or the result of a method that returns a protocol, does not contain a value of any concrete type that adopts the protocol.<br></p><p>Instead, it contains a description of what should happen when a protocol method is called. It&#39;s an indirection. An indirection that happens at runtime. The compiler says: &quot;I have to store a value of type T in a variable declared as protocol P. I&#39;ll actually store the fact that when the function f() of the protocol is called, it will actually call the function f() of the type T.&quot; And those redirections are visible as &quot;protocol witness&quot; in our stack traces.<br></p><p>This allows a function that uses a Swift protocols to be used with types that are not known yet by the compiler, such as the types defined by the user that use a framework. Compile once, and run later, through the indirection.<br></p><p>This also explains why it&#39;s not trivial to implement Yogev&#39;s request: a value of type Circle (concrete type) has not the same memory layout than a value of type Shape (a protocol trampoline). The same for functions that involve those types. Some conversion has to happen, and this conversion must happen at runtime, as we&#39;ve seen above. Such support is not implemented (yet ?).<br></p><p>I hope I was clear :-)<br>Gwendal<br></p><p><br>&gt; Le 18 avr. 2016 à 12:19, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; a écrit :<br>&gt; <br>&gt; You may have to explain that metaphor (or link to an explanation) - what is &#39;trampoline&#39; data?<br>&gt; <br>&gt; On Mon, Apr 18, 2016 at 11:11 AM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Le 18 avr. 2016 à 12:01, Yogev Sitton &lt;yogev.sitton at gmail.com &lt;mailto:yogev.sitton at gmail.com&gt;&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; I’m referring you to Ross O’Brien’s post:<br>&gt; &gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a closure of type () -&gt; Circle would be considered a match.  If a class implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be conforming. That does seem strange.<br>&gt; &gt;<br>&gt; &gt; Protocols behaves differently than closures and classes and I think they should behave the same.<br>&gt; <br>&gt; All right, I get it.<br>&gt; <br>&gt; Shape, as a return type, is &quot;trampoline&quot; data that wraps any Shape value, when Circle is just a Circle. That&#39;s why the two functions () -&gt; Shape? and () -&gt; Circle? don&#39;t match today.<br>&gt; <br>&gt; But maybe they will eventually, thanks to your request!<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/cb47a637/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April 18, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks Gwendal, that makes sense - for the case where Shape is a protocol.<br></p><p>Since the OP wasn&#39;t clear about it, I tried the original example with both<br>the cases where Shape was declared as a protocol (i.e. Circle conforms) and<br>where Shape was declared as a class (i.e. Circle inherits). The same<br>problem occurs when Shape is a concrete type. Does the same explanation<br>apply? i.e. the &#39;MyShapeProtocol&#39; trampoline has the same problem you&#39;ve<br>described?<br></p><p>Yogev: this is the first stage - discussion on the list. The formal next<br>stage, assuming that there&#39;s some list support and the idea isn&#39;t on the<br>list of &#39;commonly rejected ideas&#39; (I&#39;ve been burned by this) is to write a<br>proposal using the draft proposal document in the Swift Evolution github<br>repository, and make a pull request. In due course proposals will be<br>scheduled for review. If a pull request for an implementation of an<br>acceptable proposal exists, the review may happen that much faster.<br></p><p>On Mon, Apr 18, 2016 at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt;<br>wrote:<br></p><p>&gt; Those &quot;trampolines&quot; are visible in debugger stack traces, or in<br>&gt; Instruments, as &quot;protocol witness&quot; function calls. You may have seen them<br>&gt; already.<br>&gt;<br>&gt; You see, a variable of type SomeProtocol, or the result of a method that<br>&gt; returns a protocol, does not contain a value of any concrete type that<br>&gt; adopts the protocol.<br>&gt;<br>&gt; Instead, it contains a description of what should happen when a protocol<br>&gt; method is called. It&#39;s an indirection. An indirection that happens at<br>&gt; runtime. The compiler says: &quot;I have to store a value of type T in a<br>&gt; variable declared as protocol P. I&#39;ll actually store the fact that when the<br>&gt; function f() of the protocol is called, it will actually call the function<br>&gt; f() of the type T.&quot; And those redirections are visible as &quot;protocol<br>&gt; witness&quot; in our stack traces.<br>&gt;<br>&gt; This allows a function that uses a Swift protocols to be used with types<br>&gt; that are not known yet by the compiler, such as the types defined by the<br>&gt; user that use a framework. Compile once, and run later, through the<br>&gt; indirection.<br>&gt;<br>&gt; This also explains why it&#39;s not trivial to implement Yogev&#39;s request: a<br>&gt; value of type Circle (concrete type) has not the same memory layout than a<br>&gt; value of type Shape (a protocol trampoline). The same for functions that<br>&gt; involve those types. Some conversion has to happen, and this conversion<br>&gt; must happen at runtime, as we&#39;ve seen above. Such support is not<br>&gt; implemented (yet ?).<br>&gt;<br>&gt; I hope I was clear :-)<br>&gt; Gwendal<br>&gt;<br>&gt;<br>&gt; Le 18 avr. 2016 à 12:19, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt; You may have to explain that metaphor (or link to an explanation) - what<br>&gt; is &#39;trampoline&#39; data?<br>&gt;<br>&gt; On Mon, Apr 18, 2016 at 11:11 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Le 18 avr. 2016 à 12:01, Yogev Sitton &lt;yogev.sitton at gmail.com&gt; a écrit<br>&gt;&gt; :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’m referring you to Ross O’Brien’s post:<br>&gt;&gt; &gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape,<br>&gt;&gt; a closure of type () -&gt; Circle would be considered a match.  If a class<br>&gt;&gt; implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt;<br>&gt;&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt;<br>&gt;&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be<br>&gt;&gt; conforming. That does seem strange.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Protocols behaves differently than closures and classes and I think<br>&gt;&gt; they should behave the same.<br>&gt;&gt;<br>&gt;&gt; All right, I get it.<br>&gt;&gt;<br>&gt;&gt; Shape, as a return type, is &quot;trampoline&quot; data that wraps any Shape value,<br>&gt;&gt; when Circle is just a Circle. That&#39;s why the two functions () -&gt; Shape? and<br>&gt;&gt; () -&gt; Circle? don&#39;t match today.<br>&gt;&gt;<br>&gt;&gt; But maybe they will eventually, thanks to your request!<br>&gt;&gt;<br>&gt;&gt; Gwendal<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/646996f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[PROPOSAL]Return subclass type to a protocol where a superclass is defined without the need for associatedtype</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>Discussion has stopped on this topic.<br>Should I submit a proposal?<br></p><p>&gt; On Apr 18, 2016, at 1:55 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks Gwendal, that makes sense - for the case where Shape is a protocol.<br>&gt; <br>&gt; Since the OP wasn&#39;t clear about it, I tried the original example with both the cases where Shape was declared as a protocol (i.e. Circle conforms) and where Shape was declared as a class (i.e. Circle inherits). The same problem occurs when Shape is a concrete type. Does the same explanation apply? i.e. the &#39;MyShapeProtocol&#39; trampoline has the same problem you&#39;ve described?<br>&gt; <br>&gt; Yogev: this is the first stage - discussion on the list. The formal next stage, assuming that there&#39;s some list support and the idea isn&#39;t on the list of &#39;commonly rejected ideas&#39; (I&#39;ve been burned by this) is to write a proposal using the draft proposal document in the Swift Evolution github repository, and make a pull request. In due course proposals will be scheduled for review. If a pull request for an implementation of an acceptable proposal exists, the review may happen that much faster.<br>&gt; <br>&gt; On Mon, Apr 18, 2016 at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; wrote:<br>&gt; Those &quot;trampolines&quot; are visible in debugger stack traces, or in Instruments, as &quot;protocol witness&quot; function calls. You may have seen them already.<br>&gt; <br>&gt; You see, a variable of type SomeProtocol, or the result of a method that returns a protocol, does not contain a value of any concrete type that adopts the protocol.<br>&gt; <br>&gt; Instead, it contains a description of what should happen when a protocol method is called. It&#39;s an indirection. An indirection that happens at runtime. The compiler says: &quot;I have to store a value of type T in a variable declared as protocol P. I&#39;ll actually store the fact that when the function f() of the protocol is called, it will actually call the function f() of the type T.&quot; And those redirections are visible as &quot;protocol witness&quot; in our stack traces.<br>&gt; <br>&gt; This allows a function that uses a Swift protocols to be used with types that are not known yet by the compiler, such as the types defined by the user that use a framework. Compile once, and run later, through the indirection.<br>&gt; <br>&gt; This also explains why it&#39;s not trivial to implement Yogev&#39;s request: a value of type Circle (concrete type) has not the same memory layout than a value of type Shape (a protocol trampoline). The same for functions that involve those types. Some conversion has to happen, and this conversion must happen at runtime, as we&#39;ve seen above. Such support is not implemented (yet ?).<br>&gt; <br>&gt; I hope I was clear :-)<br>&gt; Gwendal<br>&gt; <br>&gt; <br>&gt;&gt; Le 18 avr. 2016 à 12:19, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; You may have to explain that metaphor (or link to an explanation) - what is &#39;trampoline&#39; data?<br>&gt;&gt; <br>&gt;&gt; On Mon, Apr 18, 2016 at 11:11 AM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Le 18 avr. 2016 à 12:01, Yogev Sitton &lt;yogev.sitton at gmail.com &lt;mailto:yogev.sitton at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’m referring you to Ross O’Brien’s post:<br>&gt;&gt; &gt; As of Swift 2.2, if a variable has a closure type of e.g. () -&gt; Shape, a closure of type () -&gt; Circle would be considered a match.  If a class implements &#39;func make() -&gt; Shape&#39;, a subclass implementing &#39;func make() -&gt; Circle&#39; has to override. However, if a protocol requires a &#39;func make() -&gt; Shape&#39;, a type implementing &#39;func make() -&gt; Circle&#39; isn&#39;t considered to be conforming. That does seem strange.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Protocols behaves differently than closures and classes and I think they should behave the same.<br>&gt;&gt; <br>&gt;&gt; All right, I get it.<br>&gt;&gt; <br>&gt;&gt; Shape, as a return type, is &quot;trampoline&quot; data that wraps any Shape value, when Circle is just a Circle. That&#39;s why the two functions () -&gt; Shape? and () -&gt; Circle? don&#39;t match today.<br>&gt;&gt; <br>&gt;&gt; But maybe they will eventually, thanks to your request!<br>&gt;&gt; <br>&gt;&gt; Gwendal<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/cb9bde85/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
