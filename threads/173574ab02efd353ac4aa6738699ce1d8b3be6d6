<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 12, 2016 at 10:00:00pm</p></header><div class="content"><p>So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br></p><p>In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br></p><p>Thanks,<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt; <br>&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br></p><p>Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt; <br>&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt; <br>&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br></p><p>Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt; <br>&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt; <br>&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br></p><p>Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br></p><p>There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>class MyAwesomeSuperClass { required init() {} }<br>class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>class Whatever : MyAwesomeSuperClass {}<br>class Etc : Whatever {}<br>enum ClassNames : String {<br>    //Unfortunately the value of each case has to be a literal, so<br>    //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>    case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>    case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>    case whatever = &quot;Whatever&quot;<br>    case etc = &quot;Etc&quot;<br>    init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>    init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>    var type: MyAwesomeSuperClass.Type {<br>        switch self {<br>        case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>        case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>        case .whatever:             return Whatever.self<br>        case .etc:                  return Etc.self<br>        }<br>   }<br>}<br>var etc = Etc()<br>var className = ClassNames(etc)<br>var newEtc = className.type.init()<br></p><p>The same trick works if all the types in question conform to the same protocol, too:<br>protocol MyAwesomeProtocol {<br>    init()<br>    func toIntMax() -&gt; IntMax<br>}<br>extension Int : MyAwesomeProtocol {}<br>struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>enum ProtocolNames : String {<br>    case five = &quot;Five&quot;<br>    case int = &quot;Int&quot;<br>    init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>    init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>    var type: MyAwesomeProtocol.Type {<br>        switch self {<br>        case .five: return Five.self<br>        case .int:  return Int.self<br>        }<br>    }<br>}<br>var five = Five()<br>var fiveName = ProtocolNames(five)<br>var newFive = fiveName.type.init()<br></p><p>Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br></p><p>It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161113/f0aa3365/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks, David. That&#39;s interesting as a thought exercise, but doesn&#39;t really get me away from having switch statements. I&#39;ll probably end up just &quot;slightly polluting&quot; my classes by adding extension methods to create the appropriate auxiliary classes. Sure wish Swift supported optional methods without @objc (I guess it&#39;s not that big a deal to use @objc).<br></p><p>&gt; On Nov 13, 2016, at 11:19 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt;&gt; <br>&gt;&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br>&gt; <br>&gt; Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br>&gt; <br>&gt; There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>&gt; class MyAwesomeSuperClass { required init() {} }<br>&gt; class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>&gt; class Whatever : MyAwesomeSuperClass {}<br>&gt; class Etc : Whatever {}<br>&gt; enum ClassNames : String {<br>&gt;     //Unfortunately the value of each case has to be a literal, so<br>&gt;     //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>&gt;     case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>&gt;     case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>&gt;     case whatever = &quot;Whatever&quot;<br>&gt;     case etc = &quot;Etc&quot;<br>&gt;     init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>&gt;     init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;     var type: MyAwesomeSuperClass.Type {<br>&gt;         switch self {<br>&gt;         case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>&gt;         case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>&gt;         case .whatever:             return Whatever.self<br>&gt;         case .etc:                  return Etc.self<br>&gt;         }<br>&gt;    }<br>&gt; }<br>&gt; var etc = Etc()<br>&gt; var className = ClassNames(etc)<br>&gt; var newEtc = className.type.init()<br>&gt; <br>&gt; The same trick works if all the types in question conform to the same protocol, too:<br>&gt; protocol MyAwesomeProtocol {<br>&gt;     init()<br>&gt;     func toIntMax() -&gt; IntMax<br>&gt; }<br>&gt; extension Int : MyAwesomeProtocol {}<br>&gt; struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>&gt; enum ProtocolNames : String {<br>&gt;     case five = &quot;Five&quot;<br>&gt;     case int = &quot;Int&quot;<br>&gt;     init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>&gt;     init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;     var type: MyAwesomeProtocol.Type {<br>&gt;         switch self {<br>&gt;         case .five: return Five.self<br>&gt;         case .int:  return Int.self<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; var five = Five()<br>&gt; var fiveName = ProtocolNames(five)<br>&gt; var newFive = fiveName.type.init()<br>&gt; <br>&gt; Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br>&gt; <br>&gt; It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br>&gt; <br>&gt; - Dave Sweeris<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>November 15, 2016 at 09:00:00am</p></header><div class="content"><p>Perhaps I’m missing something here, but why not use a map?<br></p><p>    let factoryMap = [ String : () -&gt; SuperClassOrCommonProtocol ] = [ “MySubClass&quot; : { return MySubClass() }, … ]<br></p><p>    …<br></p><p>    guard let factoryMethod = factoryMap[theClassName] else { /* error */ }<br>    return factoryMethod()<br></p><p>This is an approach I always ended up taking in Objective-C anyway, because, if you don’t know what’s in the string, you need to validate it (imagine if the user of your app finds out that they can cause you to instantiate any arbitrary class) and if you do know what’s in the string, why are you not creating the instance directly?<br></p><p> <br>&gt; On 14 Nov 2016, at 23:48, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks, David. That&#39;s interesting as a thought exercise, but doesn&#39;t really get me away from having switch statements. I&#39;ll probably end up just &quot;slightly polluting&quot; my classes by adding extension methods to create the appropriate auxiliary classes. Sure wish Swift supported optional methods without @objc (I guess it&#39;s not that big a deal to use @objc).<br>&gt; <br>&gt;&gt; On Nov 13, 2016, at 11:19 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br>&gt;&gt; <br>&gt;&gt; Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br>&gt;&gt; <br>&gt;&gt; There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>&gt;&gt; class MyAwesomeSuperClass { required init() {} }<br>&gt;&gt; class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>&gt;&gt; class Whatever : MyAwesomeSuperClass {}<br>&gt;&gt; class Etc : Whatever {}<br>&gt;&gt; enum ClassNames : String {<br>&gt;&gt;    //Unfortunately the value of each case has to be a literal, so<br>&gt;&gt;    //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>&gt;&gt;    case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>&gt;&gt;    case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>&gt;&gt;    case whatever = &quot;Whatever&quot;<br>&gt;&gt;    case etc = &quot;Etc&quot;<br>&gt;&gt;    init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>&gt;&gt;    init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;    var type: MyAwesomeSuperClass.Type {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>&gt;&gt;        case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>&gt;&gt;        case .whatever:             return Whatever.self<br>&gt;&gt;        case .etc:                  return Etc.self<br>&gt;&gt;        }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; var etc = Etc()<br>&gt;&gt; var className = ClassNames(etc)<br>&gt;&gt; var newEtc = className.type.init()<br>&gt;&gt; <br>&gt;&gt; The same trick works if all the types in question conform to the same protocol, too:<br>&gt;&gt; protocol MyAwesomeProtocol {<br>&gt;&gt;    init()<br>&gt;&gt;    func toIntMax() -&gt; IntMax<br>&gt;&gt; }<br>&gt;&gt; extension Int : MyAwesomeProtocol {}<br>&gt;&gt; struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>&gt;&gt; enum ProtocolNames : String {<br>&gt;&gt;    case five = &quot;Five&quot;<br>&gt;&gt;    case int = &quot;Int&quot;<br>&gt;&gt;    init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>&gt;&gt;    init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;    var type: MyAwesomeProtocol.Type {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .five: return Five.self<br>&gt;&gt;        case .int:  return Int.self<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; var five = Five()<br>&gt;&gt; var fiveName = ProtocolNames(five)<br>&gt;&gt; var newFive = fiveName.type.init()<br>&gt;&gt; <br>&gt;&gt; Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br>&gt;&gt; <br>&gt;&gt; It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 15, 2016 at 02:00:00am</p></header><div class="content"><p>Well, that&#39;s not really any different than a switch statement, in that it has to be maintained.<br></p><p>&gt; On Nov 15, 2016, at 01:50 , Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; Perhaps I’m missing something here, but why not use a map?<br>&gt; <br>&gt;    let factoryMap = [ String : () -&gt; SuperClassOrCommonProtocol ] = [ “MySubClass&quot; : { return MySubClass() }, … ]<br>&gt; <br>&gt;    …<br>&gt; <br>&gt;    guard let factoryMethod = factoryMap[theClassName] else { /* error */ }<br>&gt;    return factoryMethod()<br>&gt; <br>&gt; This is an approach I always ended up taking in Objective-C anyway, because, if you don’t know what’s in the string, you need to validate it (imagine if the user of your app finds out that they can cause you to instantiate any arbitrary class) and if you do know what’s in the string, why are you not creating the instance directly?<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Nov 2016, at 23:48, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks, David. That&#39;s interesting as a thought exercise, but doesn&#39;t really get me away from having switch statements. I&#39;ll probably end up just &quot;slightly polluting&quot; my classes by adding extension methods to create the appropriate auxiliary classes. Sure wish Swift supported optional methods without @objc (I guess it&#39;s not that big a deal to use @objc).<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 13, 2016, at 11:19 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>&gt;&gt;&gt; class MyAwesomeSuperClass { required init() {} }<br>&gt;&gt;&gt; class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>&gt;&gt;&gt; class Whatever : MyAwesomeSuperClass {}<br>&gt;&gt;&gt; class Etc : Whatever {}<br>&gt;&gt;&gt; enum ClassNames : String {<br>&gt;&gt;&gt;   //Unfortunately the value of each case has to be a literal, so<br>&gt;&gt;&gt;   //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>&gt;&gt;&gt;   case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>&gt;&gt;&gt;   case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>&gt;&gt;&gt;   case whatever = &quot;Whatever&quot;<br>&gt;&gt;&gt;   case etc = &quot;Etc&quot;<br>&gt;&gt;&gt;   init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>&gt;&gt;&gt;   init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;   var type: MyAwesomeSuperClass.Type {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>&gt;&gt;&gt;       case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>&gt;&gt;&gt;       case .whatever:             return Whatever.self<br>&gt;&gt;&gt;       case .etc:                  return Etc.self<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var etc = Etc()<br>&gt;&gt;&gt; var className = ClassNames(etc)<br>&gt;&gt;&gt; var newEtc = className.type.init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same trick works if all the types in question conform to the same protocol, too:<br>&gt;&gt;&gt; protocol MyAwesomeProtocol {<br>&gt;&gt;&gt;   init()<br>&gt;&gt;&gt;   func toIntMax() -&gt; IntMax<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Int : MyAwesomeProtocol {}<br>&gt;&gt;&gt; struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>&gt;&gt;&gt; enum ProtocolNames : String {<br>&gt;&gt;&gt;   case five = &quot;Five&quot;<br>&gt;&gt;&gt;   case int = &quot;Int&quot;<br>&gt;&gt;&gt;   init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>&gt;&gt;&gt;   init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;   var type: MyAwesomeProtocol.Type {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .five: return Five.self<br>&gt;&gt;&gt;       case .int:  return Int.self<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var five = Five()<br>&gt;&gt;&gt; var fiveName = ProtocolNames(five)<br>&gt;&gt;&gt; var newFive = fiveName.type.init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>November 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 10:33, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; Well, that&#39;s not really any different than a switch statement, in that it has to be maintained.<br></p><p>Yes, but I would argue that it is a good thing because you need to do some validation before you instantiate the class anyway.<br></p><p>Furthermore, it gives you more flexibility in terms of initialisation because the closure can invoke any initialiser regardless of parameters and can do other processing as well.<br></p><p>&gt; <br>&gt;&gt; On Nov 15, 2016, at 01:50 , Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Perhaps I’m missing something here, but why not use a map?<br>&gt;&gt; <br>&gt;&gt;   let factoryMap = [ String : () -&gt; SuperClassOrCommonProtocol ] = [ “MySubClass&quot; : { return MySubClass() }, … ]<br>&gt;&gt; <br>&gt;&gt;   …<br>&gt;&gt; <br>&gt;&gt;   guard let factoryMethod = factoryMap[theClassName] else { /* error */ }<br>&gt;&gt;   return factoryMethod()<br>&gt;&gt; <br>&gt;&gt; This is an approach I always ended up taking in Objective-C anyway, because, if you don’t know what’s in the string, you need to validate it (imagine if the user of your app finds out that they can cause you to instantiate any arbitrary class) and if you do know what’s in the string, why are you not creating the instance directly?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Nov 2016, at 23:48, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks, David. That&#39;s interesting as a thought exercise, but doesn&#39;t really get me away from having switch statements. I&#39;ll probably end up just &quot;slightly polluting&quot; my classes by adding extension methods to create the appropriate auxiliary classes. Sure wish Swift supported optional methods without @objc (I guess it&#39;s not that big a deal to use @objc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 13, 2016, at 11:19 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>&gt;&gt;&gt;&gt; class MyAwesomeSuperClass { required init() {} }<br>&gt;&gt;&gt;&gt; class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>&gt;&gt;&gt;&gt; class Whatever : MyAwesomeSuperClass {}<br>&gt;&gt;&gt;&gt; class Etc : Whatever {}<br>&gt;&gt;&gt;&gt; enum ClassNames : String {<br>&gt;&gt;&gt;&gt;  //Unfortunately the value of each case has to be a literal, so<br>&gt;&gt;&gt;&gt;  //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>&gt;&gt;&gt;&gt;  case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>&gt;&gt;&gt;&gt;  case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>&gt;&gt;&gt;&gt;  case whatever = &quot;Whatever&quot;<br>&gt;&gt;&gt;&gt;  case etc = &quot;Etc&quot;<br>&gt;&gt;&gt;&gt;  init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>&gt;&gt;&gt;&gt;  init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;&gt;  var type: MyAwesomeSuperClass.Type {<br>&gt;&gt;&gt;&gt;      switch self {<br>&gt;&gt;&gt;&gt;      case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>&gt;&gt;&gt;&gt;      case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>&gt;&gt;&gt;&gt;      case .whatever:             return Whatever.self<br>&gt;&gt;&gt;&gt;      case .etc:                  return Etc.self<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; var etc = Etc()<br>&gt;&gt;&gt;&gt; var className = ClassNames(etc)<br>&gt;&gt;&gt;&gt; var newEtc = className.type.init()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The same trick works if all the types in question conform to the same protocol, too:<br>&gt;&gt;&gt;&gt; protocol MyAwesomeProtocol {<br>&gt;&gt;&gt;&gt;  init()<br>&gt;&gt;&gt;&gt;  func toIntMax() -&gt; IntMax<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Int : MyAwesomeProtocol {}<br>&gt;&gt;&gt;&gt; struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>&gt;&gt;&gt;&gt; enum ProtocolNames : String {<br>&gt;&gt;&gt;&gt;  case five = &quot;Five&quot;<br>&gt;&gt;&gt;&gt;  case int = &quot;Int&quot;<br>&gt;&gt;&gt;&gt;  init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>&gt;&gt;&gt;&gt;  init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;&gt;  var type: MyAwesomeProtocol.Type {<br>&gt;&gt;&gt;&gt;      switch self {<br>&gt;&gt;&gt;&gt;      case .five: return Five.self<br>&gt;&gt;&gt;&gt;      case .int:  return Int.self<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; var five = Five()<br>&gt;&gt;&gt;&gt; var fiveName = ProtocolNames(five)<br>&gt;&gt;&gt;&gt; var newFive = fiveName.type.init()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Reflection in Swift 3?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 05:24 , Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 15 Nov 2016, at 10:33, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, that&#39;s not really any different than a switch statement, in that it has to be maintained.<br>&gt; <br>&gt; Yes, but I would argue that it is a good thing because you need to do some validation before you instantiate the class anyway.<br>&gt; <br>&gt; Furthermore, it gives you more flexibility in terms of initialisation because the closure can invoke any initialiser regardless of parameters and can do other processing as well.<br></p><p>Yeah, but that&#39;s not the flexibility I need. And with good reflection/introspection, I can do all the validation I need dynamically. In an ideal world, I could do something like this:<br></p><p>let pathRenderers = classesThatImplement(protocol: Renderer)<br>for pr in pathRenderers {<br>    for ini in pr.initializers {<br>        if ini.has(signature: (Path))<br>        {<br>            let renderer = pr.instantiate(aPath)<br>            return<br>        }<br>    }<br>}<br></p><p>Obviously more complicated than this, but you get the idea.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 15, 2016, at 01:50 , Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps I’m missing something here, but why not use a map?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let factoryMap = [ String : () -&gt; SuperClassOrCommonProtocol ] = [ “MySubClass&quot; : { return MySubClass() }, … ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  guard let factoryMethod = factoryMap[theClassName] else { /* error */ }<br>&gt;&gt;&gt;  return factoryMethod()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an approach I always ended up taking in Objective-C anyway, because, if you don’t know what’s in the string, you need to validate it (imagine if the user of your app finds out that they can cause you to instantiate any arbitrary class) and if you do know what’s in the string, why are you not creating the instance directly?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Nov 2016, at 23:48, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks, David. That&#39;s interesting as a thought exercise, but doesn&#39;t really get me away from having switch statements. I&#39;ll probably end up just &quot;slightly polluting&quot; my classes by adding extension methods to create the appropriate auxiliary classes. Sure wish Swift supported optional methods without @objc (I guess it&#39;s not that big a deal to use @objc).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 11:19 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 1:55 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 12, 2016, at 22:47 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 13, 2016, at 00:38, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, it seems there&#39;s still no way to do something like instantiate a class given only its name (as a String)?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my situation, I have a number of subclasses (or protocol implementations), which parallel some other class hierarchy. I need to dynamically create one based on the name of another. I don&#39;t want the latter classes to &quot;know&quot; anything about the former.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not that I know of... If this is all your code, can you fake it by switching over the type&#39;s name?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, it just happens in a few places, would be nice to write the code once and then just ensure classes exist. I know I could do it subclassing NSObject, but Swift really ought to have proper reflection.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reflection is on the todo list (although I can’t recall if it’s in-scope for Swift 4).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also the possibility of putting the names of the classes you want to instantiate into an enum. In fact, if all the classes in question have a common superclass, you could this:<br>&gt;&gt;&gt;&gt;&gt; class MyAwesomeSuperClass { required init() {} }<br>&gt;&gt;&gt;&gt;&gt; class MyAwesomeSubClass : MyAwesomeSuperClass {}<br>&gt;&gt;&gt;&gt;&gt; class Whatever : MyAwesomeSuperClass {}<br>&gt;&gt;&gt;&gt;&gt; class Etc : Whatever {}<br>&gt;&gt;&gt;&gt;&gt; enum ClassNames : String {<br>&gt;&gt;&gt;&gt;&gt; //Unfortunately the value of each case has to be a literal, so<br>&gt;&gt;&gt;&gt;&gt; //you can’t just say `case etc = &quot;\(Etc.self)&quot;`<br>&gt;&gt;&gt;&gt;&gt; case myAwesomeSuperClass = &quot;MyAwesomeSuperClass&quot;<br>&gt;&gt;&gt;&gt;&gt; case myAwesomeSubClass = &quot;MyAwesomeSubClass&quot;<br>&gt;&gt;&gt;&gt;&gt; case whatever = &quot;Whatever&quot;<br>&gt;&gt;&gt;&gt;&gt; case etc = &quot;Etc&quot;<br>&gt;&gt;&gt;&gt;&gt; init(_ instance: MyAwesomeSuperClass) { self = ClassNames.init(rawValue: &quot;\(type(of: instance))&quot;)! }<br>&gt;&gt;&gt;&gt;&gt; init(_ type: MyAwesomeSuperClass.Type) { self = ClassNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;&gt;&gt; var type: MyAwesomeSuperClass.Type {<br>&gt;&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;&gt;     case .myAwesomeSuperClass:  return MyAwesomeSuperClass.self<br>&gt;&gt;&gt;&gt;&gt;     case .myAwesomeSubClass:    return MyAwesomeSubClass.self<br>&gt;&gt;&gt;&gt;&gt;     case .whatever:             return Whatever.self<br>&gt;&gt;&gt;&gt;&gt;     case .etc:                  return Etc.self<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; var etc = Etc()<br>&gt;&gt;&gt;&gt;&gt; var className = ClassNames(etc)<br>&gt;&gt;&gt;&gt;&gt; var newEtc = className.type.init()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The same trick works if all the types in question conform to the same protocol, too:<br>&gt;&gt;&gt;&gt;&gt; protocol MyAwesomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; init()<br>&gt;&gt;&gt;&gt;&gt; func toIntMax() -&gt; IntMax<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; extension Int : MyAwesomeProtocol {}<br>&gt;&gt;&gt;&gt;&gt; struct Five : MyAwesomeProtocol { func toIntMax() -&gt; IntMax { return 5 } }<br>&gt;&gt;&gt;&gt;&gt; enum ProtocolNames : String {<br>&gt;&gt;&gt;&gt;&gt; case five = &quot;Five&quot;<br>&gt;&gt;&gt;&gt;&gt; case int = &quot;Int&quot;<br>&gt;&gt;&gt;&gt;&gt; init(_ instance: MyAwesomeProtocol) { self = ProtocolNames.init(rawValue: &quot;\(type(of: instance))”)! }<br>&gt;&gt;&gt;&gt;&gt; init(_ type: MyAwesomeProtocol.Type) { self = ProtocolNames.init(rawValue: &quot;\(type)&quot;)! }<br>&gt;&gt;&gt;&gt;&gt; var type: MyAwesomeProtocol.Type {<br>&gt;&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;&gt;     case .five: return Five.self<br>&gt;&gt;&gt;&gt;&gt;     case .int:  return Int.self<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; var five = Five()<br>&gt;&gt;&gt;&gt;&gt; var fiveName = ProtocolNames(five)<br>&gt;&gt;&gt;&gt;&gt; var newFive = fiveName.type.init()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Either way, though, you’ll have to do something like if let nf = newFive as? Int {…} if you want to use any functionality that isn’t explicitly in the superclass or protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It certainly involves some boilerplate code, but it also has the advantages of validating the name before you try to use it and ensuring that any switch statements can actually handle all the classes. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
