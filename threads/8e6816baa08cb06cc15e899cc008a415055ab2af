<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January 14, 2016 at 04:00:00pm</p></header><div class="content"><p>There hasn&#39;t been a major Lens thread on the list so far, but I&#39;m intrigued<br>by the idea and was tinkering with a related proposal until I stumbled<br>across Brandon William&#39;s &quot;Lenses in Swift&quot; video and discovered that Lenses<br>cover everything I wanted to do and more.<br></p><p>The one thing that stuck with me, though, is the question of syntax. If<br>Lenses are to be a native part of the Swift language, how would one declare<br>them?<br></p><p>We&#39;ve currently got not-so-secret methods at the type level of Structs and<br>Classes for every member function:<br></p><p>class Example {<br>    func action() {}<br>}<br></p><p>let example = Example()<br>example.action // () -&gt; Void<br>Example.action // (Example) -&gt; Void<br></p><p>That looks a lot like a Lens on the member function, though if I understand<br>correctly the current plan is for those to go away in a future version.<br></p><p>We also have to deal with Type-level members and functions:<br></p><p>class Example {<br>   static action() {}<br>   static name: String<br>}<br></p><p>Example.action() // () -&gt; Void<br>Example.name // String<br></p><p>So, using a dot-operator as the way to get a Lens could be problematic due<br>to name collisions.<br></p><p>The Proposal:<br></p><p>Use the &#39;#&#39; character in place of the dot operator to retrieve a Lens for a<br>Type/member pair:<br></p><p>Example#action() // (Example) -&gt; Void<br>Example#name    // Lens&lt;Example,String&gt;, autogenerated to work on the<br>&#39;name&#39; member<br></p><p>Member function names should be fully-specified with the mechanism from<br>Doug Gregor&#39;s method naming proposal.<br></p><p>Some notes:<br>* A specific operator stands out and is easier to scan for as a code reader.<br>* The octothorpe seems to be available in Swift.<br>* It also has a current meaning in a technology familiar to most everyone -<br>the Document Fragment in HTML - which could make the idea easier to explain<br>to newcomers, by analogy.<br></p><p>What about Lenses on Type-level members? My first thought is that we don&#39;t<br>have to support that because they&#39;re more like namespaced globals rather<br>than parts of a data type. They can always be referenced directly. That<br>might be a vacuous observation to people more familiar with the Lens<br>concept, but I noted it for completeness.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/8e68b2af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>January 15, 2016 at 06:00:00am</p></header><div class="content"><p>Could you please explain what a lens is/means? I only found [1], but quick skimming didn&#39;t reveal any lenses.<br></p><p>[1] https://www.youtube.com/watch?v=estNbh2TF3E<br></p><p>A.<br></p><p><br>&gt; On Jan 15, 2016, at 6:10 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There hasn&#39;t been a major Lens thread on the list so far, but I&#39;m intrigued by the idea and was tinkering with a related proposal until I stumbled across Brandon William&#39;s &quot;Lenses in Swift&quot; video and discovered that Lenses cover everything I wanted to do and more.<br>&gt; <br>&gt; The one thing that stuck with me, though, is the question of syntax. If Lenses are to be a native part of the Swift language, how would one declare them?<br>&gt; <br>&gt; We&#39;ve currently got not-so-secret methods at the type level of Structs and Classes for every member function:<br>&gt; <br>&gt; class Example {<br>&gt;     func action() {}<br>&gt; }<br>&gt; <br>&gt; let example = Example()<br>&gt; example.action // () -&gt; Void<br>&gt; Example.action // (Example) -&gt; Void<br>&gt; <br>&gt; That looks a lot like a Lens on the member function, though if I understand correctly the current plan is for those to go away in a future version.<br>&gt; <br>&gt; We also have to deal with Type-level members and functions:<br>&gt; <br>&gt; class Example {<br>&gt;    static action() {}<br>&gt;    static name: String<br>&gt; }<br>&gt; <br>&gt; Example.action() // () -&gt; Void<br>&gt; Example.name // String<br>&gt; <br>&gt; So, using a dot-operator as the way to get a Lens could be problematic due to name collisions.<br>&gt; <br>&gt; The Proposal:<br>&gt; <br>&gt; Use the &#39;#&#39; character in place of the dot operator to retrieve a Lens for a Type/member pair:<br>&gt; <br>&gt; Example#action() // (Example) -&gt; Void<br>&gt; Example#name    // Lens&lt;Example,String&gt;, autogenerated to work on the &#39;name&#39; member<br>&gt; <br>&gt; Member function names should be fully-specified with the mechanism from Doug Gregor&#39;s method naming proposal.<br>&gt; <br>&gt; Some notes:<br>&gt; * A specific operator stands out and is easier to scan for as a code reader.<br>&gt; * The octothorpe seems to be available in Swift.<br>&gt; * It also has a current meaning in a technology familiar to most everyone - the Document Fragment in HTML - which could make the idea easier to explain to newcomers, by analogy.<br>&gt; <br>&gt; What about Lenses on Type-level members? My first thought is that we don&#39;t have to support that because they&#39;re more like namespaced globals rather than parts of a data type. They can always be referenced directly. That might be a vacuous observation to people more familiar with the Lens concept, but I noted it for completeness.<br>&gt; <br>&gt; Mike<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/776736dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January 14, 2016 at 05:00:00pm</p></header><div class="content"><p>It&#39;s a way of referring to a specific member of a type with a data<br>structure that, when given an instance of the type, behaves as if it&#39;s<br>actually a direct reference to that member on that instance.<br></p><p>If you have:<br></p><p>struct Example {<br>    let name: String<br>}<br></p><p>If you have a Lens for the &#39;name&#39; member of the &#39;Example&#39; type:<br></p><p>let nameLens = Example#name // assume this generates a Lens, for this<br>example<br></p><p>then you can hold on to that, pass it around, etc. and apply it to any<br>Example instance you might encounter later on.<br></p><p>The idea comes primarily from Functional Programming. I&#39;m not familiar<br>enough with FP concepts to go into depth about the ways it&#39;s useful in that<br>field, but it has come up in Swift because there isn&#39;t currently a way to<br>refer to getters and setters on data properties in the same way that you<br>might be able to directly refer to a member function. The Lens approach<br>seems to be the current front-runner for Swift&#39;s answer to that problem.<br></p><p>Mike<br></p><p>On Thu, Jan 14, 2016 at 4:44 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>wrote:<br></p><p>&gt; Could you please explain what a lens is/means? I only found [1], but quick<br>&gt; skimming didn&#39;t reveal any lenses.<br>&gt;<br>&gt; [1] https://www.youtube.com/watch?v=estNbh2TF3E<br>&gt;<br>&gt; A.<br>&gt;<br>&gt;<br>&gt; On Jan 15, 2016, at 6:10 AM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There hasn&#39;t been a major Lens thread on the list so far, but I&#39;m<br>&gt; intrigued by the idea and was tinkering with a related proposal until I<br>&gt; stumbled across Brandon William&#39;s &quot;Lenses in Swift&quot; video and discovered<br>&gt; that Lenses cover everything I wanted to do and more.<br>&gt;<br>&gt; The one thing that stuck with me, though, is the question of syntax. If<br>&gt; Lenses are to be a native part of the Swift language, how would one declare<br>&gt; them?<br>&gt;<br>&gt; We&#39;ve currently got not-so-secret methods at the type level of Structs and<br>&gt; Classes for every member function:<br>&gt;<br>&gt; class Example {<br>&gt;     func action() {}<br>&gt; }<br>&gt;<br>&gt; let example = Example()<br>&gt; example.action // () -&gt; Void<br>&gt; Example.action // (Example) -&gt; Void<br>&gt;<br>&gt; That looks a lot like a Lens on the member function, though if I<br>&gt; understand correctly the current plan is for those to go away in a future<br>&gt; version.<br>&gt;<br>&gt; We also have to deal with Type-level members and functions:<br>&gt;<br>&gt; class Example {<br>&gt;    static action() {}<br>&gt;    static name: String<br>&gt; }<br>&gt;<br>&gt; Example.action() // () -&gt; Void<br>&gt; Example.name // String<br>&gt;<br>&gt; So, using a dot-operator as the way to get a Lens could be problematic due<br>&gt; to name collisions.<br>&gt;<br>&gt; The Proposal:<br>&gt;<br>&gt; Use the &#39;#&#39; character in place of the dot operator to retrieve a Lens for<br>&gt; a Type/member pair:<br>&gt;<br>&gt; Example#action() // (Example) -&gt; Void<br>&gt; Example#name    // Lens&lt;Example,String&gt;, autogenerated to work on the<br>&gt; &#39;name&#39; member<br>&gt;<br>&gt; Member function names should be fully-specified with the mechanism from<br>&gt; Doug Gregor&#39;s method naming proposal.<br>&gt;<br>&gt; Some notes:<br>&gt; * A specific operator stands out and is easier to scan for as a code<br>&gt; reader.<br>&gt; * The octothorpe seems to be available in Swift.<br>&gt; * It also has a current meaning in a technology familiar to most everyone<br>&gt; - the Document Fragment in HTML - which could make the idea easier to<br>&gt; explain to newcomers, by analogy.<br>&gt;<br>&gt; What about Lenses on Type-level members? My first thought is that we don&#39;t<br>&gt; have to support that because they&#39;re more like namespaced globals rather<br>&gt; than parts of a data type. They can always be referenced directly. That<br>&gt; might be a vacuous observation to people more familiar with the Lens<br>&gt; concept, but I noted it for completeness.<br>&gt;<br>&gt; Mike<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/3996b136/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 15, 2016 at 08:00:00am</p></header><div class="content"><p>If I read this right, things like “withFilter” in Scala could be considered a lens on the original collection.  In that it does not actually perform any function on the collection, but the following function call on the views the data through that lens.<br></p><p>Scala<br></p><p>val a = List(1,2,3,4,5)<br></p><p>&gt;&gt; a: List[Int] = List(1, 2, 3, 4, 5)<br></p><p>val b = a.withFilter(x =&gt; x % 2 == 0 )<br></p><p>&gt;&gt; scala.collection.generic.FilterMonadic[Int,List[Int]] = scala.collection.TraversableLike$WithFilter at 77f0d43c<br></p><p>val c = b.map(x =&gt; x)<br></p><p>&gt;&gt; c: List[Int] = List(2, 4)<br></p><p>&gt; On 2016-01-15, at 8:11:56, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s a way of referring to a specific member of a type with a data structure that, when given an instance of the type, behaves as if it&#39;s actually a direct reference to that member on that instance.<br>&gt; <br>&gt; If you have:<br>&gt; <br>&gt; struct Example {<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; If you have a Lens for the &#39;name&#39; member of the &#39;Example&#39; type:<br>&gt; <br>&gt; let nameLens = Example#name // assume this generates a Lens, for this example<br>&gt; <br>&gt; then you can hold on to that, pass it around, etc. and apply it to any Example instance you might encounter later on.<br>&gt; <br>&gt; The idea comes primarily from Functional Programming. I&#39;m not familiar enough with FP concepts to go into depth about the ways it&#39;s useful in that field, but it has come up in Swift because there isn&#39;t currently a way to refer to getters and setters on data properties in the same way that you might be able to directly refer to a member function. The Lens approach seems to be the current front-runner for Swift&#39;s answer to that problem.<br>&gt; <br>&gt; Mike<br>&gt; <br>&gt; On Thu, Jan 14, 2016 at 4:44 PM, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt; Could you please explain what a lens is/means? I only found [1], but quick skimming didn&#39;t reveal any lenses.<br>&gt; <br>&gt; [1] https://www.youtube.com/watch?v=estNbh2TF3E &lt;https://www.youtube.com/watch?v=estNbh2TF3E&gt;<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 6:10 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There hasn&#39;t been a major Lens thread on the list so far, but I&#39;m intrigued by the idea and was tinkering with a related proposal until I stumbled across Brandon William&#39;s &quot;Lenses in Swift&quot; video and discovered that Lenses cover everything I wanted to do and more.<br>&gt;&gt; <br>&gt;&gt; The one thing that stuck with me, though, is the question of syntax. If Lenses are to be a native part of the Swift language, how would one declare them?<br>&gt;&gt; <br>&gt;&gt; We&#39;ve currently got not-so-secret methods at the type level of Structs and Classes for every member function:<br>&gt;&gt; <br>&gt;&gt; class Example {<br>&gt;&gt;     func action() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let example = Example()<br>&gt;&gt; example.action // () -&gt; Void<br>&gt;&gt; Example.action // (Example) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; That looks a lot like a Lens on the member function, though if I understand correctly the current plan is for those to go away in a future version.<br>&gt;&gt; <br>&gt;&gt; We also have to deal with Type-level members and functions:<br>&gt;&gt; <br>&gt;&gt; class Example {<br>&gt;&gt;    static action() {}<br>&gt;&gt;    static name: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Example.action() // () -&gt; Void<br>&gt;&gt; Example.name // String<br>&gt;&gt; <br>&gt;&gt; So, using a dot-operator as the way to get a Lens could be problematic due to name collisions.<br>&gt;&gt; <br>&gt;&gt; The Proposal:<br>&gt;&gt; <br>&gt;&gt; Use the &#39;#&#39; character in place of the dot operator to retrieve a Lens for a Type/member pair:<br>&gt;&gt; <br>&gt;&gt; Example#action() // (Example) -&gt; Void<br>&gt;&gt; Example#name    // Lens&lt;Example,String&gt;, autogenerated to work on the &#39;name&#39; member<br>&gt;&gt; <br>&gt;&gt; Member function names should be fully-specified with the mechanism from Doug Gregor&#39;s method naming proposal.<br>&gt;&gt; <br>&gt;&gt; Some notes:<br>&gt;&gt; * A specific operator stands out and is easier to scan for as a code reader.<br>&gt;&gt; * The octothorpe seems to be available in Swift.<br>&gt;&gt; * It also has a current meaning in a technology familiar to most everyone - the Document Fragment in HTML - which could make the idea easier to explain to newcomers, by analogy.<br>&gt;&gt; <br>&gt;&gt; What about Lenses on Type-level members? My first thought is that we don&#39;t have to support that because they&#39;re more like namespaced globals rather than parts of a data type. They can always be referenced directly. That might be a vacuous observation to people more familiar with the Lens concept, but I noted it for completeness.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/05ebb97c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 14, 2016 at 08:00:00pm</p></header><div class="content"><p>Speaking as a co-author of a Lens library, the need is far greater for richer data types, typing schemes, and Metaprogramming in general than for first-class lens support.  Currently, you can only get to about the level of `Optional` (lens&#39; Optional, not Swift) before the language falls out from under you and you lose generality of implementation.  If anything, this proposal could be the start of a great standalone mogenerator-esque tool.<br></p><p>~Robert Widmann<br></p><p>2016/01/14 20:11、Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; It&#39;s a way of referring to a specific member of a type with a data structure that, when given an instance of the type, behaves as if it&#39;s actually a direct reference to that member on that instance.<br>&gt; <br>&gt; If you have:<br>&gt; <br>&gt; struct Example {<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; If you have a Lens for the &#39;name&#39; member of the &#39;Example&#39; type:<br>&gt; <br>&gt; let nameLens = Example#name // assume this generates a Lens, for this example<br>&gt; <br>&gt; then you can hold on to that, pass it around, etc. and apply it to any Example instance you might encounter later on.<br>&gt; <br>&gt; The idea comes primarily from Functional Programming. I&#39;m not familiar enough with FP concepts to go into depth about the ways it&#39;s useful in that field, but it has come up in Swift because there isn&#39;t currently a way to refer to getters and setters on data properties in the same way that you might be able to directly refer to a member function. The Lens approach seems to be the current front-runner for Swift&#39;s answer to that problem.<br>&gt; <br>&gt; Mike<br>&gt; <br>&gt;&gt; On Thu, Jan 14, 2016 at 4:44 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; Could you please explain what a lens is/means? I only found [1], but quick skimming didn&#39;t reveal any lenses.<br>&gt;&gt; <br>&gt;&gt; [1] https://www.youtube.com/watch?v=estNbh2TF3E<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 6:10 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There hasn&#39;t been a major Lens thread on the list so far, but I&#39;m intrigued by the idea and was tinkering with a related proposal until I stumbled across Brandon William&#39;s &quot;Lenses in Swift&quot; video and discovered that Lenses cover everything I wanted to do and more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one thing that stuck with me, though, is the question of syntax. If Lenses are to be a native part of the Swift language, how would one declare them?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve currently got not-so-secret methods at the type level of Structs and Classes for every member function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Example {<br>&gt;&gt;&gt;     func action() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let example = Example()<br>&gt;&gt;&gt; example.action // () -&gt; Void<br>&gt;&gt;&gt; Example.action // (Example) -&gt; Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That looks a lot like a Lens on the member function, though if I understand correctly the current plan is for those to go away in a future version.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We also have to deal with Type-level members and functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Example {<br>&gt;&gt;&gt;    static action() {}<br>&gt;&gt;&gt;    static name: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example.action() // () -&gt; Void<br>&gt;&gt;&gt; Example.name // String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, using a dot-operator as the way to get a Lens could be problematic due to name collisions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use the &#39;#&#39; character in place of the dot operator to retrieve a Lens for a Type/member pair:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example#action() // (Example) -&gt; Void<br>&gt;&gt;&gt; Example#name    // Lens&lt;Example,String&gt;, autogenerated to work on the &#39;name&#39; member<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Member function names should be fully-specified with the mechanism from Doug Gregor&#39;s method naming proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some notes:<br>&gt;&gt;&gt; * A specific operator stands out and is easier to scan for as a code reader.<br>&gt;&gt;&gt; * The octothorpe seems to be available in Swift.<br>&gt;&gt;&gt; * It also has a current meaning in a technology familiar to most everyone - the Document Fragment in HTML - which could make the idea easier to explain to newcomers, by analogy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about Lenses on Type-level members? My first thought is that we don&#39;t have to support that because they&#39;re more like namespaced globals rather than parts of a data type. They can always be referenced directly. That might be a vacuous observation to people more familiar with the Lens concept, but I noted it for completeness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mike<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/6c88b3a2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Could you please explain what a lens is/means? I only found [1], but quick skimming didn&#39;t reveal any lenses.<br>&gt; <br>&gt; [1] https://www.youtube.com/watch?v=estNbh2TF3E<br></p><p>In pure functional programming languages, where you can&#39;t mutate existing instances, a lens is a function which takes an instance and a new value for some field inside the instance—sometimes deep inside it—and returns a copy of the original instance with that new value in place. So, for instance, if you have a `User` type which has a `name` property:<br></p><p>	let nameLens = User.name<br>	let currentName = nameLens.get(originalUser)			// get the name from originalUser<br>	let modifiedUser = nameLens.set(originalUser, to: &quot;Joe&quot;)	// return a copy of originalUser with name set to &quot;Joe&quot;<br></p><p>In functional programming, you can easily chain lenses together, so that you could create a lens for, say, `User.creditCards[0].billingAddress.houseNumber`—and the setter on that lens will actually take a house number and return a whole different `User` instance with that house number applied.<br></p><p>Now, Swift is a little different from a pure functional language. It doesn&#39;t have the limitation that functional languages do—it&#39;s perfectly fine to modify existing instances—so a Swift lens&#39;s setter would probably actually modify the existing instance. On the other hand, Swift often modifies an existing value inside a property instead of creating a whole new one, so the &quot;setter&quot; is better modeled as a read-modify-write operation:<br></p><p>	let nameLens = User.name<br>	let currentName = nameLens.get(originalUser)<br>	nameLens.modify(originalUser) { (inout name: String) in<br>		name = &quot;Joe&quot;<br>	}<br></p><p>Finally, there&#39;s the question of how you should *access* a lens. `User.name`—that is, a lens that can be used with any instance of `User`—is good for some things, but you&#39;d also like to be able to get a lens that&#39;s already bound to a particular instance.<br></p><p>Michael Henson is basically proposing syntaxes to retrieve a lens for a particular instance, but personally, I think this is putting the cart before the horse a bit. Right now, I&#39;m personally more interested in finding out what a lens *is* in Swift. What can it do? How is it expressed? What can you use it for?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Preemptive Proposal] Operator for Lenses</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Mutability issues aside, isn’t this kinda the same thing?<br>let nameLens: (_: User)-&gt;String = {$0.name}<br>let currentName = nameLens(originalUser)<br></p><p>&gt; On Jan 14, 2016, at 17:30, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Could you please explain what a lens is/means? I only found [1], but quick skimming didn&#39;t reveal any lenses.<br>&gt;&gt; <br>&gt;&gt; [1] https://www.youtube.com/watch?v=estNbh2TF3E<br>&gt; <br>&gt; In pure functional programming languages, where you can&#39;t mutate existing instances, a lens is a function which takes an instance and a new value for some field inside the instance—sometimes deep inside it—and returns a copy of the original instance with that new value in place. So, for instance, if you have a `User` type which has a `name` property:<br>&gt; <br>&gt; 	let nameLens = User.name<br>&gt; 	let currentName = nameLens.get(originalUser)			// get the name from originalUser<br>&gt; 	let modifiedUser = nameLens.set(originalUser, to: &quot;Joe&quot;)	// return a copy of originalUser with name set to &quot;Joe&quot;<br>&gt; <br>&gt; In functional programming, you can easily chain lenses together, so that you could create a lens for, say, `User.creditCards[0].billingAddress.houseNumber`—and the setter on that lens will actually take a house number and return a whole different `User` instance with that house number applied.<br>&gt; <br>&gt; Now, Swift is a little different from a pure functional language. It doesn&#39;t have the limitation that functional languages do—it&#39;s perfectly fine to modify existing instances—so a Swift lens&#39;s setter would probably actually modify the existing instance. On the other hand, Swift often modifies an existing value inside a property instead of creating a whole new one, so the &quot;setter&quot; is better modeled as a read-modify-write operation:<br>&gt; <br>&gt; 	let nameLens = User.name<br>&gt; 	let currentName = nameLens.get(originalUser)<br>&gt; 	nameLens.modify(originalUser) { (inout name: String) in<br>&gt; 		name = &quot;Joe&quot;<br>&gt; 	}<br>&gt; <br>&gt; Finally, there&#39;s the question of how you should *access* a lens. `User.name`—that is, a lens that can be used with any instance of `User`—is good for some things, but you&#39;d also like to be able to get a lens that&#39;s already bound to a particular instance.<br>&gt; <br>&gt; Michael Henson is basically proposing syntaxes to retrieve a lens for a particular instance, but personally, I think this is putting the cart before the horse a bit. Right now, I&#39;m personally more interested in finding out what a lens *is* in Swift. What can it do? How is it expressed? What can you use it for?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
