<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;d like to discuss adding a @pure keyword, and see what it requires and<br>how possible it is to  include.<br></p><p>I&#39;d like to use the annotation @pure on functions, methods and closures.<br></p><p>This will allow us to make more guarantees about what a protocol does, and<br>what it cannot do. It will also allow APIs like `.map` and `.forEach` to<br>have a meaningful distinction. It could also allow for something like an<br>assert to be removed as an optimisation with no side-effects in a release<br>build.<br></p><p>If something is pure it can be annotated with @pure, if it is not-pure this<br>will be a compile-time error. The compiler could automatically add this<br>annotation in the interface.<br></p><p>A function, method or closure is pure if:<br> * all functions, methods and closures it calls are also pure (this<br>includes referencing self from a method or property)<br> * it only externally references let variables of pure type, let properties<br>on those variables, and methods/computer-properties marked as pure.<br></p><p>A computed property can be marked as pure like this:<br></p><p>@pure var test: A<br></p><p><br>A function/method/closure signature is marked as pure like this:<br></p><p>(a: A, b: A -&gt; B) @pure -&gt; B<br></p><p><br>If the function/method/closure is only pure if an argument is pure (similar<br>to @rethrows), then you could do this:<br></p><p>(start: A, a: A -&gt; B) @pure(b) -&gt; B<br></p><p><br>Potentially this could be extended to allow a pure closure to be composed<br>of other pure closures:<br></p><p>func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br></p><p>    return { b(a($0)) }<br></p><p>}<br></p><p><br>Of course this doesn&#39;t preclude you from requiring some of those closures<br>to be pure:<br></p><p>func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br></p><p>    return { b(a($0)) }<br></p><p>}<br></p><p><br>Impact on existing code:<br></p><p>No negative impact as if automatic annotation was allowed it would only<br>happen where it was safe to do so. If it was not allowed then libraries<br>could be slowly annotated to be marked as pure.<br></p><p>c and objective-c would not be marked as pure.<br></p><p>Pure functions can be safely removed by the optimiser if their result is<br>not used. From this perspective assert and print should not be marked as<br>pure (they would have to be an exception anyway).<br></p><p>Ideally existing libraries would be annotated, the more the better, but<br>this can be a gradual process.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/d38e19c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I would rather you mark a function as impure and have the default as pure!<br></p><p><br></p><p><br>&gt; On 9 Jan 2016, at 7:53 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and how possible it is to  include.<br>&gt; <br>&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt; <br>&gt; This will allow us to make more guarantees about what a protocol does, and what it cannot do. It will also allow APIs like `.map` and `.forEach` to have a meaningful distinction. It could also allow for something like an assert to be removed as an optimisation with no side-effects in a release build.<br>&gt; <br>&gt; If something is pure it can be annotated with @pure, if it is not-pure this will be a compile-time error. The compiler could automatically add this annotation in the interface.<br>&gt; <br>&gt; A function, method or closure is pure if:<br>&gt;  * all functions, methods and closures it calls are also pure (this includes referencing self from a method or property)<br>&gt;  * it only externally references let variables of pure type, let properties on those variables, and methods/computer-properties marked as pure.<br>&gt; <br>&gt; A computed property can be marked as pure like this:<br>&gt; @pure var test: A<br>&gt; <br>&gt; A function/method/closure signature is marked as pure like this:<br>&gt; (a: A, b: A -&gt; B) @pure -&gt; B<br>&gt; <br>&gt; If the function/method/closure is only pure if an argument is pure (similar to @rethrows), then you could do this:<br>&gt; (start: A, a: A -&gt; B) @pure(b) -&gt; B<br>&gt; <br>&gt; Potentially this could be extended to allow a pure closure to be composed of other pure closures:<br>&gt; func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br>&gt;     return { b(a($0)) }<br>&gt; }<br>&gt; <br>&gt; Of course this doesn&#39;t preclude you from requiring some of those closures to be pure:<br>&gt; func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br>&gt;     return { b(a($0)) }<br>&gt; }<br>&gt; <br>&gt; Impact on existing code:<br>&gt; No negative impact as if automatic annotation was allowed it would only happen where it was safe to do so. If it was not allowed then libraries could be slowly annotated to be marked as pure.<br>&gt; <br>&gt; c and objective-c would not be marked as pure.<br>&gt; <br>&gt; Pure functions can be safely removed by the optimiser if their result is not used. From this perspective assert and print should not be marked as pure (they would have to be an exception anyway).<br>&gt; <br>&gt; Ideally existing libraries would be annotated, the more the better, but this can be a gradual process.<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/502ed499/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  9, 2016 at 08:00:00pm</p></header><div class="content"><p>That would be nice, although I&#39;m not sure how practical that is in current<br>swift usage. I imagine it would require a lot of changes to existing code<br>and libraries.<br></p><p>Is a method impure if it uses self? I suppose it could be. I guess self is<br>an inout parameter. I presume an inout parameter is a known expected<br>side-effect.<br></p><p>Closures would probably be the largest impact if things were pure by<br>default.<br></p><p>It would be interesting though to do a code survey and see what portion<br>would need to be marked as @impure, and what conditions lead them to that<br>requirement.<br></p><p>I&#39;m happy to discuss @impure too, but my focus is still @pure, as I think<br>it is a more attainable target, at the moment.<br></p><p>Perhaps after everything is annotated, impure functions are minimised, and<br>if swift is streamlined for pure function use, then we can introduce<br>@impure and deprecate @pure.<br></p><p><br></p><p><br>On Sat, Jan 9, 2016 at 7:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>wrote:<br></p><p>&gt; I would rather you mark a function as impure and have the default as pure!<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 9 Jan 2016, at 7:53 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and<br>&gt; how possible it is to  include.<br>&gt;<br>&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt;<br>&gt; This will allow us to make more guarantees about what a protocol does, and<br>&gt; what it cannot do. It will also allow APIs like `.map` and `.forEach` to<br>&gt; have a meaningful distinction. It could also allow for something like an<br>&gt; assert to be removed as an optimisation with no side-effects in a release<br>&gt; build.<br>&gt;<br>&gt; If something is pure it can be annotated with @pure, if it is not-pure<br>&gt; this will be a compile-time error. The compiler could automatically add<br>&gt; this annotation in the interface.<br>&gt;<br>&gt; A function, method or closure is pure if:<br>&gt;  * all functions, methods and closures it calls are also pure (this<br>&gt; includes referencing self from a method or property)<br>&gt;  * it only externally references let variables of pure type, let<br>&gt; properties on those variables, and methods/computer-properties marked as<br>&gt; pure.<br>&gt;<br>&gt; A computed property can be marked as pure like this:<br>&gt;<br>&gt; @pure var test: A<br>&gt;<br>&gt;<br>&gt; A function/method/closure signature is marked as pure like this:<br>&gt;<br>&gt; (a: A, b: A -&gt; B) @pure -&gt; B<br>&gt;<br>&gt;<br>&gt; If the function/method/closure is only pure if an argument is pure<br>&gt; (similar to @rethrows), then you could do this:<br>&gt;<br>&gt; (start: A, a: A -&gt; B) @pure(b) -&gt; B<br>&gt;<br>&gt;<br>&gt; Potentially this could be extended to allow a pure closure to be composed<br>&gt; of other pure closures:<br>&gt;<br>&gt; func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br>&gt;<br>&gt;     return { b(a($0)) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Of course this doesn&#39;t preclude you from requiring some of those closures<br>&gt; to be pure:<br>&gt;<br>&gt; func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br>&gt;<br>&gt;     return { b(a($0)) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Impact on existing code:<br>&gt;<br>&gt; No negative impact as if automatic annotation was allowed it would only<br>&gt; happen where it was safe to do so. If it was not allowed then libraries<br>&gt; could be slowly annotated to be marked as pure.<br>&gt;<br>&gt; c and objective-c would not be marked as pure.<br>&gt;<br>&gt; Pure functions can be safely removed by the optimiser if their result is<br>&gt; not used. From this perspective assert and print should not be marked as<br>&gt; pure (they would have to be an exception anyway).<br>&gt;<br>&gt; Ideally existing libraries would be annotated, the more the better, but<br>&gt; this can be a gradual process.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/c79d5e11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Comment in-line below.<br></p><p>&gt; On 9 Jan 2016, at 8:04 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; That would be nice, although I&#39;m not sure how practical that is in current swift usage. I imagine it would require a lot of changes to existing code and libraries.<br></p><p>Not sure how hard this would be or if a migration tool and enhanced Obj-C importer would be good enough.<br></p><p>&gt; Is a method impure if it uses self? I suppose it could be. I guess self is an inout parameter. I presume an inout parameter is a known expected side-effect.<br></p><p>If it doesn’t change self then it is pure.<br></p><p>&gt; Closures would probably be the largest impact if things were pure by default.<br></p><p>I think this would be a great change. We are part way there with @noescape and @autoclosure already<br></p><p>&gt; It would be interesting though to do a code survey and see what portion would need to be marked as @impure, and what conditions lead them to that requirement.<br>&gt; <br>&gt; I&#39;m happy to discuss @impure too, but my focus is still @pure, as I think it is a more attainable target, at the moment.<br>&gt; <br>&gt; Perhaps after everything is annotated, impure functions are minimised, and if swift is streamlined for pure function use, then we can introduce @impure and deprecate @pure.<br></p><p>Not sure either will happen any time soon :(. Therefore the most useful thing would be the survey you suggest.<br></p><p>&gt; On Sat, Jan 9, 2016 at 7:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt; I would rather you mark a function as impure and have the default as pure!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 9 Jan 2016, at 7:53 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and how possible it is to  include.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt;&gt; <br>&gt;&gt; This will allow us to make more guarantees about what a protocol does, and what it cannot do. It will also allow APIs like `.map` and `.forEach` to have a meaningful distinction. It could also allow for something like an assert to be removed as an optimisation with no side-effects in a release build.<br>&gt;&gt; <br>&gt;&gt; If something is pure it can be annotated with @pure, if it is not-pure this will be a compile-time error. The compiler could automatically add this annotation in the interface.<br>&gt;&gt; <br>&gt;&gt; A function, method or closure is pure if:<br>&gt;&gt;  * all functions, methods and closures it calls are also pure (this includes referencing self from a method or property)<br>&gt;&gt;  * it only externally references let variables of pure type, let properties on those variables, and methods/computer-properties marked as pure.<br>&gt;&gt; <br>&gt;&gt; A computed property can be marked as pure like this:<br>&gt;&gt; @pure var test: A<br>&gt;&gt; <br>&gt;&gt; A function/method/closure signature is marked as pure like this:<br>&gt;&gt; (a: A, b: A -&gt; B) @pure -&gt; B<br>&gt;&gt; <br>&gt;&gt; If the function/method/closure is only pure if an argument is pure (similar to @rethrows), then you could do this:<br>&gt;&gt; (start: A, a: A -&gt; B) @pure(b) -&gt; B<br>&gt;&gt; <br>&gt;&gt; Potentially this could be extended to allow a pure closure to be composed of other pure closures:<br>&gt;&gt; func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br>&gt;&gt;     return { b(a($0)) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course this doesn&#39;t preclude you from requiring some of those closures to be pure:<br>&gt;&gt; func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br>&gt;&gt;     return { b(a($0)) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Impact on existing code:<br>&gt;&gt; No negative impact as if automatic annotation was allowed it would only happen where it was safe to do so. If it was not allowed then libraries could be slowly annotated to be marked as pure.<br>&gt;&gt; <br>&gt;&gt; c and objective-c would not be marked as pure.<br>&gt;&gt; <br>&gt;&gt; Pure functions can be safely removed by the optimiser if their result is not used. From this perspective assert and print should not be marked as pure (they would have to be an exception anyway).<br>&gt;&gt; <br>&gt;&gt; Ideally existing libraries would be annotated, the more the better, but this can be a gradual process.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/d365f423/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>So what&#39;s the semantic difference between @pure and @impure type?<br></p><p>&quot;c and objective-c would not be marked as pure.&quot; It sounds like pure swift.<br></p><p>&quot;Pure functions can be safely removed by the optimizer if their result is<br>not used. &quot; It sounds like no-side-effects or immutable.<br></p><p><br>On Sat, Jan 9, 2016 at 5:14 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Comment in-line below.<br>&gt;<br>&gt; On 9 Jan 2016, at 8:04 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; That would be nice, although I&#39;m not sure how practical that is in current<br>&gt; swift usage. I imagine it would require a lot of changes to existing code<br>&gt; and libraries.<br>&gt;<br>&gt;<br>&gt; Not sure how hard this would be or if a migration tool and enhanced Obj-C<br>&gt; importer would be good enough.<br>&gt;<br>&gt; Is a method impure if it uses self? I suppose it could be. I guess self is<br>&gt; an inout parameter. I presume an inout parameter is a known expected<br>&gt; side-effect.<br>&gt;<br>&gt;<br>&gt; If it doesn’t change self then it is pure.<br>&gt;<br>&gt; Closures would probably be the largest impact if things were pure by<br>&gt; default.<br>&gt;<br>&gt;<br>&gt; I think this would be a great change. We are part way there with @noescape<br>&gt; and @autoclosure already<br>&gt;<br>&gt; It would be interesting though to do a code survey and see what portion<br>&gt; would need to be marked as @impure, and what conditions lead them to that<br>&gt; requirement.<br>&gt;<br>&gt; I&#39;m happy to discuss @impure too, but my focus is still @pure, as I think<br>&gt; it is a more attainable target, at the moment.<br>&gt;<br>&gt; Perhaps after everything is annotated, impure functions are minimised, and<br>&gt; if swift is streamlined for pure function use, then we can introduce<br>&gt; @impure and deprecate @pure.<br>&gt;<br>&gt;<br>&gt; Not sure either will happen any time soon :(. Therefore the most useful<br>&gt; thing would be the survey you suggest.<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 7:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I would rather you mark a function as impure and have the default as pure!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 9 Jan 2016, at 7:53 PM, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and<br>&gt;&gt; how possible it is to  include.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt;&gt;<br>&gt;&gt; This will allow us to make more guarantees about what a protocol does,<br>&gt;&gt; and what it cannot do. It will also allow APIs like `.map` and `.forEach`<br>&gt;&gt; to have a meaningful distinction. It could also allow for something like an<br>&gt;&gt; assert to be removed as an optimisation with no side-effects in a release<br>&gt;&gt; build.<br>&gt;&gt;<br>&gt;&gt; If something is pure it can be annotated with @pure, if it is not-pure<br>&gt;&gt; this will be a compile-time error. The compiler could automatically add<br>&gt;&gt; this annotation in the interface.<br>&gt;&gt;<br>&gt;&gt; A function, method or closure is pure if:<br>&gt;&gt;  * all functions, methods and closures it calls are also pure (this<br>&gt;&gt; includes referencing self from a method or property)<br>&gt;&gt;  * it only externally references let variables of pure type, let<br>&gt;&gt; properties on those variables, and methods/computer-properties marked as<br>&gt;&gt; pure.<br>&gt;&gt;<br>&gt;&gt; A computed property can be marked as pure like this:<br>&gt;&gt;<br>&gt;&gt; @pure var test: A<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A function/method/closure signature is marked as pure like this:<br>&gt;&gt;<br>&gt;&gt; (a: A, b: A -&gt; B) @pure -&gt; B<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If the function/method/closure is only pure if an argument is pure<br>&gt;&gt; (similar to @rethrows), then you could do this:<br>&gt;&gt;<br>&gt;&gt; (start: A, a: A -&gt; B) @pure(b) -&gt; B<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Potentially this could be extended to allow a pure closure to be composed<br>&gt;&gt; of other pure closures:<br>&gt;&gt;<br>&gt;&gt; func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br>&gt;&gt;<br>&gt;&gt;     return { b(a($0)) }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Of course this doesn&#39;t preclude you from requiring some of those closures<br>&gt;&gt; to be pure:<br>&gt;&gt;<br>&gt;&gt; func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br>&gt;&gt;<br>&gt;&gt;     return { b(a($0)) }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Impact on existing code:<br>&gt;&gt;<br>&gt;&gt; No negative impact as if automatic annotation was allowed it would only<br>&gt;&gt; happen where it was safe to do so. If it was not allowed then libraries<br>&gt;&gt; could be slowly annotated to be marked as pure.<br>&gt;&gt;<br>&gt;&gt; c and objective-c would not be marked as pure.<br>&gt;&gt;<br>&gt;&gt; Pure functions can be safely removed by the optimiser if their result is<br>&gt;&gt; not used. From this perspective assert and print should not be marked as<br>&gt;&gt; pure (they would have to be an exception anyway).<br>&gt;&gt;<br>&gt;&gt; Ideally existing libraries would be annotated, the more the better, but<br>&gt;&gt; this can be a gradual process.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/1e525c42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 10, 2016 at 12:00:00am</p></header><div class="content"><p>Hi 品雪,<br></p><p>As I understand Howard&#39;s intentions @pure and @impure are just antonyms,<br>like true versus false. The important distinction is that if we only had a<br>@pure keyword then functions are allowed to be impure by default, which is<br>easier for existing code and probably beginner programmers. Functions are<br>not checked for purity unless annotated.<br></p><p>C and Objective-C may be able to be marked as pure in future, but I think<br>it&#39;s too difficult to do so at the moment. It&#39;s probably the case that<br>there will be some kind of import attribute that could allow c functions to<br>be marked as pure for the standard library, however I doubt there will be<br>any automated checking.<br></p><p>&quot;no-side-effects&quot; is essentially the same. It&#39;s mainly a matter of defining<br>what side-effects are and are not allowed. Side-effects could mean that it<br>doesn&#39;t take any processor time, or it doesn&#39;t change registers, or cannot<br>abort execution, allocate memory, etc.<br></p><p>Andrew<br></p><p><br>On Sat, Jan 9, 2016 at 8:59 PM, 品雪 &lt;pinxue at gmail.com&gt; wrote:<br></p><p>&gt; So what&#39;s the semantic difference between @pure and @impure type?<br>&gt;<br>&gt; &quot;c and objective-c would not be marked as pure.&quot; It sounds like pure<br>&gt; swift.<br>&gt;<br>&gt; &quot;Pure functions can be safely removed by the optimizer if their result is<br>&gt; not used. &quot; It sounds like no-side-effects or immutable.<br>&gt;<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 5:14 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Comment in-line below.<br>&gt;&gt;<br>&gt;&gt; On 9 Jan 2016, at 8:04 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; That would be nice, although I&#39;m not sure how practical that is in<br>&gt;&gt; current swift usage. I imagine it would require a lot of changes to<br>&gt;&gt; existing code and libraries.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Not sure how hard this would be or if a migration tool and enhanced Obj-C<br>&gt;&gt; importer would be good enough.<br>&gt;&gt;<br>&gt;&gt; Is a method impure if it uses self? I suppose it could be. I guess self<br>&gt;&gt; is an inout parameter. I presume an inout parameter is a known expected<br>&gt;&gt; side-effect.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If it doesn’t change self then it is pure.<br>&gt;&gt;<br>&gt;&gt; Closures would probably be the largest impact if things were pure by<br>&gt;&gt; default.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would be a great change. We are part way there with<br>&gt;&gt; @noescape and @autoclosure already<br>&gt;&gt;<br>&gt;&gt; It would be interesting though to do a code survey and see what portion<br>&gt;&gt; would need to be marked as @impure, and what conditions lead them to that<br>&gt;&gt; requirement.<br>&gt;&gt;<br>&gt;&gt; I&#39;m happy to discuss @impure too, but my focus is still @pure, as I think<br>&gt;&gt; it is a more attainable target, at the moment.<br>&gt;&gt;<br>&gt;&gt; Perhaps after everything is annotated, impure functions are minimised,<br>&gt;&gt; and if swift is streamlined for pure function use, then we can introduce<br>&gt;&gt; @impure and deprecate @pure.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Not sure either will happen any time soon :(. Therefore the most useful<br>&gt;&gt; thing would be the survey you suggest.<br>&gt;&gt;<br>&gt;&gt; On Sat, Jan 9, 2016 at 7:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I would rather you mark a function as impure and have the default as<br>&gt;&gt;&gt; pure!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 9 Jan 2016, at 7:53 PM, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and<br>&gt;&gt;&gt; how possible it is to  include.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will allow us to make more guarantees about what a protocol does,<br>&gt;&gt;&gt; and what it cannot do. It will also allow APIs like `.map` and `.forEach`<br>&gt;&gt;&gt; to have a meaningful distinction. It could also allow for something like an<br>&gt;&gt;&gt; assert to be removed as an optimisation with no side-effects in a release<br>&gt;&gt;&gt; build.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If something is pure it can be annotated with @pure, if it is not-pure<br>&gt;&gt;&gt; this will be a compile-time error. The compiler could automatically add<br>&gt;&gt;&gt; this annotation in the interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A function, method or closure is pure if:<br>&gt;&gt;&gt;  * all functions, methods and closures it calls are also pure (this<br>&gt;&gt;&gt; includes referencing self from a method or property)<br>&gt;&gt;&gt;  * it only externally references let variables of pure type, let<br>&gt;&gt;&gt; properties on those variables, and methods/computer-properties marked as<br>&gt;&gt;&gt; pure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A computed property can be marked as pure like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @pure var test: A<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A function/method/closure signature is marked as pure like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (a: A, b: A -&gt; B) @pure -&gt; B<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the function/method/closure is only pure if an argument is pure<br>&gt;&gt;&gt; (similar to @rethrows), then you could do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (start: A, a: A -&gt; B) @pure(b) -&gt; B<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Potentially this could be extended to allow a pure closure to be<br>&gt;&gt;&gt; composed of other pure closures:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     return { b(a($0)) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course this doesn&#39;t preclude you from requiring some of those<br>&gt;&gt;&gt; closures to be pure:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     return { b(a($0)) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Impact on existing code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No negative impact as if automatic annotation was allowed it would only<br>&gt;&gt;&gt; happen where it was safe to do so. If it was not allowed then libraries<br>&gt;&gt;&gt; could be slowly annotated to be marked as pure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; c and objective-c would not be marked as pure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Pure functions can be safely removed by the optimiser if their result is<br>&gt;&gt;&gt; not used. From this perspective assert and print should not be marked as<br>&gt;&gt;&gt; pure (they would have to be an exception anyway).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ideally existing libraries would be annotated, the more the better, but<br>&gt;&gt;&gt; this can be a gradual process.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Best Regards!<br>&gt;<br>&gt; Yang Wu<br>&gt; --------------------------------------------------------<br>&gt; Location: Pudong, Shanghai, China.<br>&gt; EMail    : pinxue at gmail.com<br>&gt; Website: http://www.time2change.mobi http://rockplayer.com<br>&gt; Twitter/Weibo : @pinxue<br>&gt; &lt;http://www.pinxue.net&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/422c5bb2/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>On Sat, Jan 9, 2016 at 10:53 AM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A function, method or closure is pure if:<br>&gt;  * all functions, methods and closures it calls are also pure (this<br>&gt; includes referencing self from a method or property)<br>&gt;  * it only externally references let variables of pure type, let<br>&gt; properties on those variables, and methods/computer-properties marked as<br>&gt; pure.<br>&gt;<br></p><p>I&#39;m concerned that with this definition we won&#39;t be able to mark many APIs<br>as pure, even though they actually are pure.  The issue is that this<br>definition disallows local mutation.  Consider CollectionType.sort() -- the<br>way it is implemented is that it first copies the collection into an array,<br>and then sorts that array in-place.  sortInPlace() isn&#39;t pure, but because<br>the mutation happens on local state, the whole operation is pure.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/1d5ad8f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  9, 2016 at 11:00:00pm</p></header><div class="content"><p>Dmitri,<br></p><p>Thanks, that&#39;s a good point. That&#39;s related to why I was wondering about<br>self as inout in my reply to Howard. My rules were a starting point, I&#39;m<br>sure there&#39;s things that can be improved. I&#39;m glad we&#39;ve got the<br>conversation started :)<br></p><p>The type of Array&lt;Int&gt;.sort is (Array&lt;Int&gt;) -&gt; () -&gt; Array&lt;Int&gt;<br></p><p>This type could be marked as pure like this:<br></p><p>(Array&lt;Int&gt;) @pure -&gt; () @pure -&gt; Array&lt;Int&gt;<br></p><p>The partial application of the function captures the current state of the<br>input array (value type), then the full application of the function sorts<br>and returns that array. I don&#39;t think there&#39;s a problem with purity here,<br>there&#39;s on *external* references.<br></p><p>It gets more interesting with a mutating function, Array&lt;Int&gt;.sortInPlace<br>is potentially pure as well:<br></p><p>(inout Array&lt;Int&gt;) @pure -&gt; Void<br></p><p><br>This type signature could be considered equivalent to the type of<br>Array&lt;Int&gt;.sort. You&#39;re taking an array in, and sending an array out. It&#39;s<br>replacing the in array with the out one.<br></p><p>I think the important thing is that everything affected by the function is<br>in the type signature.<br></p><p>Andrew<br></p><p><br></p><p><br></p><p>On Sat, Jan 9, 2016 at 9:29 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Sat, Jan 9, 2016 at 10:53 AM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; A function, method or closure is pure if:<br>&gt;&gt;  * all functions, methods and closures it calls are also pure (this<br>&gt;&gt; includes referencing self from a method or property)<br>&gt;&gt;  * it only externally references let variables of pure type, let<br>&gt;&gt; properties on those variables, and methods/computer-properties marked as<br>&gt;&gt; pure.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m concerned that with this definition we won&#39;t be able to mark many APIs<br>&gt; as pure, even though they actually are pure.  The issue is that this<br>&gt; definition disallows local mutation.  Consider CollectionType.sort() -- the<br>&gt; way it is implemented is that it first copies the collection into an array,<br>&gt; and then sorts that array in-place.  sortInPlace() isn&#39;t pure, but because<br>&gt; the mutation happens on local state, the whole operation is pure.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/c20aeb38/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  9, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 4:29 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Jan 9, 2016 at 10:53 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; A function, method or closure is pure if:<br>&gt;  * all functions, methods and closures it calls are also pure (this includes referencing self from a method or property)<br>&gt;  * it only externally references let variables of pure type, let properties on those variables, and methods/computer-properties marked as pure.<br>&gt; <br>&gt; I&#39;m concerned that with this definition we won&#39;t be able to mark many APIs as pure, even though they actually are pure.  The issue is that this definition disallows local mutation.  Consider CollectionType.sort() -- the way it is implemented is that it first copies the collection into an array, and then sorts that array in-place.  sortInPlace() isn&#39;t pure, but because the mutation happens on local state, the whole operation is pure.<br></p><p>The way I ready it is &quot;it only externally references let variables of pure type, let properties on those variables, and methods/computer-properties marked as pure.<br></p><p>Externally is the key word here, which would allow for internal / local mutation.  Note: properties of self would be an external reference.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/b602453f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>January  9, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m not yet really familiar with this term but correct me if I&#39;m wrong, &quot;pure&quot; (function wise) means functions won&#39;t have access to global or static, and mutable variables through their arguments, right?<br></p><p><br></p><p><br>On Sat, Jan 9, 2016 at 12:54 AM -0800, &quot;Andrew Bennett via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>I&#39;d like to discuss adding a @pure keyword, and see what it requires and how possible it is to  include.<br>I&#39;d like to use the annotation @pure on functions, methods and closures.<br>This will allow us to make more guarantees about what a protocol does, and what it cannot do. It will also allow APIs like `.map` and `.forEach` to have a meaningful distinction. It could also allow for something like an assert to be removed as an optimisation with no side-effects in a release build.<br>If something is pure it can be annotated with @pure, if it is not-pure this will be a compile-time error. The compiler could automatically add this annotation in the interface.<br>A function, method or closure is pure if: * all functions, methods and closures it calls are also pure (this includes referencing self from a method or property) * it only externally references let variables of pure type, let properties on those variables, and methods/computer-properties marked as pure.<br>A computed property can be marked as pure like this:@pure var test: A<br>A function/method/closure signature is marked as pure like this:(a: A, b: A -&gt; B) @pure -&gt; B<br>If the function/method/closure is only pure if an argument is pure (similar to @rethrows), then you could do this:(start: A, a: A -&gt; B) @pure(b) -&gt; B<br>Potentially this could be extended to allow a pure closure to be composed of other pure closures:func compose(a: A -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(a,b) -&gt; C {    return { b(a($0)) }}<br>Of course this doesn&#39;t preclude you from requiring some of those closures to be pure:func compose(a: A @pure -&gt; B, b: B -&gt; C) @pure -&gt; A @pure(b) -&gt; C {    return { b(a($0)) }}<br>Impact on existing code:No negative impact as if automatic annotation was allowed it would only happen where it was safe to do so. If it was not allowed then libraries could be slowly annotated to be marked as pure.<br></p><p>c and objective-c would not be marked as pure.<br></p><p>Pure functions can be safely removed by the optimiser if their result is not used. From this perspective assert and print should not be marked as pure (they would have to be an exception anyway).<br></p><p>Ideally existing libraries would be annotated, the more the better, but this can be a gradual process.<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/ee69187b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January  9, 2016 at 10:00:00am</p></header><div class="content"><p>Le 9 janv. 2016 à 8:16, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; I&#39;m not yet really familiar with this term but correct me if I&#39;m wrong, &quot;pure&quot; (function wise) means functions won&#39;t have access to global or static, and mutable variables through their arguments, right?<br></p><p>This is actually the most important part to define. There are many ways to define it, each with different tradeoffs. Here are the two base ones:<br></p><p>1. Pure means that the function always return the same value given the same arguments, and has no side effects (it purely computes a result from its inputs), making it possible for the compiler, or a cache, to reuse the result from a previous call. This is the simplest definition, and it provide strong guaranties. Let&#39;s call that &quot;strongly pure&quot;.<br></p><p>2. Pure just mean that the function has no access to global variables. It can only mutate &quot;outside&quot; things through inout parameters or pointers (including class references) passed to it by the caller. So in the general case you can&#39;t reuse the results. But you can use this function to mutate the state inside a strongly pure one. A strongly pure function in this case is one with no inout or pointer in the signature.<br></p><p>It makes more sense to use (2) to define `@pure` in my opinion. Note that this is what the D language has done, after noticing it to be much more useful than what they had before before, which was (1).<br></p><p>All that&#39;s good in theory, but there is a major detail that needs addressing. Memory allocation breaks the guaranties of a &quot;strongly pure&quot; function. For instance, if you return a newly allocated object, or a struct with a pointer to an object, the object is going to be a different one every time. That object is mutable memory, and returning a different chunk of mutable memory is quite different in semantics from returning the same one. If you want strong purity guaranties when returning objects (and thus be able to optimize by reusing the result from a previous call), there needs to be a way to return objects that have a language-enforced guaranty of immutability... same for structs that can have a pointer to an object or other memory. Without immutability guaranties, `@pure` has almost no optimization value.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January  9, 2016 at 11:00:00pm</p></header><div class="content"><p>So you are talking about idempotence.<br></p><p>HTTP/1.1 defined it as:<br></p><p>Methods can also have the property of &quot;idempotence&quot; in that (aside from<br>error or expiration issues) the side-effects of N &gt; 0 identical requests is<br>the same as for a single request.<br></p><p>On Sat, Jan 9, 2016 at 11:01 PM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Le 9 janv. 2016 à 8:16, Angelo Villegas via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; &gt; I&#39;m not yet really familiar with this term but correct me if I&#39;m wrong,<br>&gt; &quot;pure&quot; (function wise) means functions won&#39;t have access to global or<br>&gt; static, and mutable variables through their arguments, right?<br>&gt;<br>&gt; This is actually the most important part to define. There are many ways to<br>&gt; define it, each with different tradeoffs. Here are the two base ones:<br>&gt;<br>&gt; 1. Pure means that the function always return the same value given the<br>&gt; same arguments, and has no side effects (it purely computes a result from<br>&gt; its inputs), making it possible for the compiler, or a cache, to reuse the<br>&gt; result from a previous call. This is the simplest definition, and it<br>&gt; provide strong guaranties. Let&#39;s call that &quot;strongly pure&quot;.<br>&gt;<br>&gt; 2. Pure just mean that the function has no access to global variables. It<br>&gt; can only mutate &quot;outside&quot; things through inout parameters or pointers<br>&gt; (including class references) passed to it by the caller. So in the general<br>&gt; case you can&#39;t reuse the results. But you can use this function to mutate<br>&gt; the state inside a strongly pure one. A strongly pure function in this case<br>&gt; is one with no inout or pointer in the signature.<br>&gt;<br>&gt; It makes more sense to use (2) to define `@pure` in my opinion. Note that<br>&gt; this is what the D language has done, after noticing it to be much more<br>&gt; useful than what they had before before, which was (1).<br>&gt;<br>&gt; All that&#39;s good in theory, but there is a major detail that needs<br>&gt; addressing. Memory allocation breaks the guaranties of a &quot;strongly pure&quot;<br>&gt; function. For instance, if you return a newly allocated object, or a struct<br>&gt; with a pointer to an object, the object is going to be a different one<br>&gt; every time. That object is mutable memory, and returning a different chunk<br>&gt; of mutable memory is quite different in semantics from returning the same<br>&gt; one. If you want strong purity guaranties when returning objects (and thus<br>&gt; be able to optimize by reusing the result from a previous call), there<br>&gt; needs to be a way to return objects that have a language-enforced guaranty<br>&gt; of immutability... same for structs that can have a pointer to an object or<br>&gt; other memory. Without immutability guaranties, `@pure` has almost no<br>&gt; optimization value.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/44e0820f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>Le 9 janv. 2016 à 10:09, 品雪 &lt;pinxue at gmail.com&gt; a écrit :<br></p><p>&gt; So you are talking about idempotence.<br>&gt; <br>&gt; HTTP/1.1 defined it as:<br>&gt; <br>&gt; Methods can also have the property of &quot;idempotence&quot; in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.<br></p><p>I&#39;m not so sure about this. By the above definition, making one request is the same thing as making two requests, but not necessarily the same as making zero requests. <br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 7:01 AM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 9 janv. 2016 à 8:16, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; I&#39;m not yet really familiar with this term but correct me if I&#39;m wrong, &quot;pure&quot; (function wise) means functions won&#39;t have access to global or static, and mutable variables through their arguments, right?<br>&gt; <br>&gt; This is actually the most important part to define. There are many ways to define it, each with different tradeoffs. Here are the two base ones:<br>&gt; <br>&gt; 1. Pure means that the function always return the same value given the same arguments, and has no side effects (it purely computes a result from its inputs), making it possible for the compiler, or a cache, to reuse the result from a previous call. This is the simplest definition, and it provide strong guaranties. Let&#39;s call that &quot;strongly pure&quot;.<br>&gt; <br>&gt; 2. Pure just mean that the function has no access to global variables. It can only mutate &quot;outside&quot; things through inout parameters or pointers (including class references) passed to it by the caller. So in the general case you can&#39;t reuse the results. But you can use this function to mutate the state inside a strongly pure one. A strongly pure function in this case is one with no inout or pointer in the signature.<br></p><p>On a related note, I can imagine a circumstance where a function might not meet the first definition here of “pure”, but I would still want the compiler to go ahead reuse the result of the first call it gets, throughout a given scope.  Say for example that I want to expensively look up some user info, and I can rely on that not changing during a single run of my app.<br></p><p>Qualifying a method with something like @resultsReusable would cover the situation I have in mind.<br></p><p>-jcr<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 12:53 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and how possible it is to  include.<br>&gt; <br>&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br></p><p>FYI, this has come up before, please catch up on the thread:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003684.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003684.html&gt;<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003900.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003900.html&gt;<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/e3eb60bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal proposal: @pure keyword</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks Chris, I&#39;ve caught up on that thread now. Somehow between then and<br>new-years I&#39;d forgotten about it (I didn&#39;t party *that* hard). I think I<br>searched the December archive but it seems to only be two days of December<br>so far.<br></p><p>I&#39;m not sure if there&#39;s a good way to merge threads, but I suggest we move<br>the conversation there. I&#39;m not sure how to reference this thread from that<br>one though as it&#39;s not yet archived.<br></p><p><br>On Sun, Jan 10, 2016 at 12:31 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 9, 2016, at 12:53 AM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d like to discuss adding a @pure keyword, and see what it requires and<br>&gt; how possible it is to  include.<br>&gt;<br>&gt; I&#39;d like to use the annotation @pure on functions, methods and closures.<br>&gt;<br>&gt;<br>&gt; FYI, this has come up before, please catch up on the thread:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003684.html<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003900.html<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/877e21bb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
