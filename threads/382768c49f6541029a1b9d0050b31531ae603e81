<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/864e2a768b89d0a553043c6a149502a2?s=50"></div><header><strong>Strategy for building libraries supporting multiple platforms or flavors</strong> from <string>Dan Thorpe</string> &lt;dan at blindingskies.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi<br></p><p>First of all - congratulations to the Swift team for all their work, it’s really exciting times, and Swift Package Manager especially is a welcome surprise. I don’t think anyone saw this coming. <br></p><p>I have a question about cross platform packaging, as I’ve recently been struggling the best way to figure this out with current technologies, and I think it brings up some interesting things to consider when addressing the convention vs configuration balance. If this is the wrong list, or not something that you’re interested in, I apologize.  <br></p><p>Are they any plans or strategies yet how cross platform libraries will be packaged? I think I’ve read through all the docs, but not seen anything on this, except referent to an target array in Package.swift.<br></p><p>The situation is that often a different set of source files is required when targeting say iOS, watchOS, tvOS, OS X, and I guess Linux. Because the available system frameworks on those platforms are not the same. Similarly, a library may offer a different flavor for the same platform, for example a library suitable for use in an application versus an extension API compatible version.<br></p><p>An example of such a framework is here: https://github.com/danthorpe/Operations/blob/development/Operations.podspec (linking to the podspec, and it’s the easiest way to see how much configuration is needed). In this particular case, it’s not possible at the moment to integrate the iOS extension compatible framework via Carthage because Xcode cannot produce different named products for different targets if the module name has been manually set. And in these situations I think the module name would need to be the same across all platforms.<br></p><p>So, for SPM and a file system based configuration - I’m wondering how this kind of thing would work. Xcode’s little checkboxes solve this problem quite neatly. I don’t really have any answers, just a few ideas.<br></p><p>1. A judicious use of files aliases so that the directory listing contains all the appropriate files? - Pro: avoids text based configuration a-la podspec, Con: this could be tricky to maintain, hard to visualize (but could be solved with tooling).<br></p><p>2. Files are named using a pattern which indicate which targets they should be included in? e.g. Sources/_Shared/iOS_Foo.swift, Sources/_Shared/iOS_watchOS_Foo.swift - Pro: can tell from looking at the file name what platform it would be included in. Con: Incredibly ugly, doesn’t scale, might not play nicely with Git which tracks content not files.<br></p><p>3. Some kind of source code annotation. i.e. annotate the source files in a comment block in such as way that their platform/target membership match up to what is defined in Package.swift - Pro: probably the most flexible, Changing targets/configuration can be tracked in SCM. - Con: still hard to visualize (but could be solved with tooling), introduces configuration which isn’t in Package.swift? <br></p><p>4. Just use a lowest common denominator approach to build trees of nested modules? - Pro: can keep to minimal configuration, no need to duplicate or alias files. Con: not sure how scalable this would be - at the worst case you might end up having to create many modules which are just single swift files.<br></p><p>Other thoughts would be how to include groupings of files which are common across multiple targets/platforms, could perhaps prefix the folder to indicate that SPM should not generate a build target using it?<br></p><p>Anyway, I’m really excited to see how SPM progresses, and would be interested in knowing the SPM teams&#39; current thoughts on this.<br></p><p>Cheers,<br>Dan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Strategy for building libraries supporting multiple platforms or flavors</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi Dan,<br></p><p>I think I can express our approach here by saying: we want to build something where 90% of the work is easy and the remaining 10% is possible.<br></p><p>Also I want to say: we hope all packages (not apps) will be made to be cross-platform from the outset.<br></p><p>Currently we don’t support these kinds of configurable excludes/includes. But this is how I expect it will work in your Package.swift:<br></p><p>#if os(Linux)<br>targets[&quot;foo&quot;].sources.remove(&quot;foo/bar.swift&quot;)<br>#endif<br></p><p>I have talked at length with other people here about potentially having directories for each platform, and ultimately we decided this leads to source layouts that are difficult to read and maintain. We feel that you are better served by writing modules that are cross-platform and then having apps that have a target per platform with some sources added and removed.<br></p><p>However, because our manifest is Swift you can easily cater to layouts that use a pattern of your choosing:<br></p><p>#if os(Linux)<br>targets[&quot;foo&quot;].sources = targets[&quot;foo&quot;].sources.filter {<br>   return $0.hasSuffix(&quot;.linux.swift&quot;)<br>}<br>#endif<br></p><p>I don’t think we should encourage excessive nesting of modules for platforms. It is just not practical. We aim for a sensible, pragmatic solution that caters to majority usage but is flexible enough to provide the features people need.<br></p><p>&gt; On Dec 7, 2015, at 1:09 PM, Dan Thorpe via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi<br>&gt; <br>&gt; First of all - congratulations to the Swift team for all their work, it’s really exciting times, and Swift Package Manager especially is a welcome surprise. I don’t think anyone saw this coming. <br>&gt; <br>&gt; I have a question about cross platform packaging, as I’ve recently been struggling the best way to figure this out with current technologies, and I think it brings up some interesting things to consider when addressing the convention vs configuration balance. If this is the wrong list, or not something that you’re interested in, I apologize.  <br>&gt; <br>&gt; Are they any plans or strategies yet how cross platform libraries will be packaged? I think I’ve read through all the docs, but not seen anything on this, except referent to an target array in Package.swift.<br>&gt; <br>&gt; The situation is that often a different set of source files is required when targeting say iOS, watchOS, tvOS, OS X, and I guess Linux. Because the available system frameworks on those platforms are not the same. Similarly, a library may offer a different flavor for the same platform, for example a library suitable for use in an application versus an extension API compatible version.<br>&gt; <br>&gt; An example of such a framework is here: https://github.com/danthorpe/Operations/blob/development/Operations.podspec (linking to the podspec, and it’s the easiest way to see how much configuration is needed). In this particular case, it’s not possible at the moment to integrate the iOS extension compatible framework via Carthage because Xcode cannot produce different named products for different targets if the module name has been manually set. And in these situations I think the module name would need to be the same across all platforms.<br>&gt; <br>&gt; So, for SPM and a file system based configuration - I’m wondering how this kind of thing would work. Xcode’s little checkboxes solve this problem quite neatly. I don’t really have any answers, just a few ideas.<br>&gt; <br>&gt; 1. A judicious use of files aliases so that the directory listing contains all the appropriate files? - Pro: avoids text based configuration a-la podspec, Con: this could be tricky to maintain, hard to visualize (but could be solved with tooling).<br>&gt; <br>&gt; 2. Files are named using a pattern which indicate which targets they should be included in? e.g. Sources/_Shared/iOS_Foo.swift, Sources/_Shared/iOS_watchOS_Foo.swift - Pro: can tell from looking at the file name what platform it would be included in. Con: Incredibly ugly, doesn’t scale, might not play nicely with Git which tracks content not files.<br>&gt; <br>&gt; 3. Some kind of source code annotation. i.e. annotate the source files in a comment block in such as way that their platform/target membership match up to what is defined in Package.swift - Pro: probably the most flexible, Changing targets/configuration can be tracked in SCM. - Con: still hard to visualize (but could be solved with tooling), introduces configuration which isn’t in Package.swift? <br>&gt; <br>&gt; 4. Just use a lowest common denominator approach to build trees of nested modules? - Pro: can keep to minimal configuration, no need to duplicate or alias files. Con: not sure how scalable this would be - at the worst case you might end up having to create many modules which are just single swift files.<br>&gt; <br>&gt; Other thoughts would be how to include groupings of files which are common across multiple targets/platforms, could perhaps prefix the folder to indicate that SPM should not generate a build target using it?<br>&gt; <br>&gt; Anyway, I’m really excited to see how SPM progresses, and would be interested in knowing the SPM teams&#39; current thoughts on this.<br>&gt; <br>&gt; Cheers,<br>&gt; Dan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151207/df852ad1/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
