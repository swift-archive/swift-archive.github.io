<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 19, 2016 at 07:00:00pm</p></header><div class="content"><p>On 2016-07-19 11:35:03 +0000, Brent Royal-Gordon via swift-evolution said:<br></p><p>&gt;&gt; <br>&gt;&gt; On Jul 19, 2016, at 4:00 AM, Károly Lőrentey via swift-evolution <br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;dynamic final&quot; is prohibited by the current version of compiler.<br>&gt; <br>&gt; Huh, I didn&#39;t know that. I don&#39;t agree with that design.<br>&gt; <br>&gt; (However, I do notice that a `final` class can have `dynamic` members.)<br></p><p>I&#39;m very very far from understanding how Swift interacts with the Obj-C <br>runtime, but I believe that might be a bug. I do not expect e.g. KVO to <br>work correctly on these. I don&#39;t think the Objective-C runtime <br>understands or enforces final (at neither class nor member level), and <br>I expect abusing it to break out of &quot;final&quot; (at either level) could <br>violate critical compile-time assumptions and cause deep problems. I <br>think this also applies to anything with @objc that isn&#39;t also declared <br>dynamic -- even &quot;@objc open&quot; members aren&#39;t necessarily dispatched via <br>message passing, are they?<br></p><p>&gt;&gt; Can you provide an example of a problem that would be solved by allowing it?<br>&gt; <br>&gt; In our current Objective-C world, the obvious example would be an <br>&gt; NSObject subclass with a property that should not be overridden (so you <br>&gt; want to mark it `final`), but which participates in KVO (so in fact <br>&gt; Foundation will use the Objective-C runtime to invisibly subclass the <br>&gt; class, override the setter, and change the type of the instance to the <br>&gt; subclass). I believe it makes perfect sense to declare such a property <br>&gt; `dynamic final`; the Objective-C-level overriding performed by <br>&gt; Foundation is an implementation detail, and does not change the fact <br>&gt; that you should never declare an override of that property.<br></p><p>To me, it doesn&#39;t make much sense to declare that a property must not <br>be overridden, then expect KVO to be able to override it anyway. <br>&quot;dynamic&quot; clearly does allow overriding (and more); it just adds <br>supports for a less convenient syntax. AFAIK KVO isn&#39;t using secret <br>APIs that aren&#39;t also available to my API clients. If I choose to use <br>&quot;dynamic&quot; in my API, then I have to design for whatever the Objective-C <br>runtime supports, and that includes overrides. Only disallowing <br>overrides with Swift syntax doesn&#39;t seem to be much of a win here.<br></p><p>I&#39;m not saying we couldn&#39;t come up with some coherent definition for a <br>hypothetical &quot;final dynamic&quot;; I just really don&#39;t see what would be the <br>point of it, besides making the language more complicated.<br></p><p>&gt; It&#39;s not really clear how `dynamic` would be used without Objective-C, <br>&gt; but I could imagine analogous situations, like an ORM implementing Core <br>&gt; Data-style faults using dirty, low-level class-changing hacks. A class <br>&gt; that was *semantically* `final`, and thus ought to be eligible for <br>&gt; static dispatch, might thus require dynamic dispatch anyway.<br></p><p>It is nice (and critically important) that we can keep using Cocoa in <br>Swift; but supposing we wanted to create a brand new ORM for a <br>hypothetical &quot;Swifty Cocoa&quot;, it wouldn&#39;t make much sense to do it using <br>the same runtime techniques as Core Data. (After all, we already have <br>such a framework in Swift; it&#39;s called Core Data.) I&#39;d prefer to choose <br>a swiftier approach, like generating the equivalent of <br>NSManagedObject&#39;s model-specific boilerplate at compile time.<br></p><p>&lt;off-topic&gt;<br>Cocoa currently hides the boilerplate for all of these wonderful <br>constructs behind amazingly effective runtime acrobatics. This fits <br>perfectly into Objective-C, and it also works very well in Swift. But <br>such features could be in better harmony with Swift&#39;s unique set of <br>language constructs if their boilerplate was hidden behind amazingly <br>effective **compile-time** acrobatics instead.<br></p><p>Such compile-time acrobatics are hard to perform today, and it is <br>possible that the ability to create such systems will forever remain an <br>advanced skill, just like forging runtime magic requires advanced <br>skills in Objective-C.<br></p><p>But Swift doesn&#39;t have an analogue to objc/runtime.h yet. What will <br>such a thing look like? A general metaprogramming/DSL subsystem (like <br>some form of hygienic macro engine)? A family of narrowly scoped <br>language/compiler features that provide extensible syntactic sugar to <br>get rid of specific kinds of boilerplate (like property behaviors or <br>coroutines)? A set of standalone tools for generating Swift source code <br>(like mogenerator)? Something else? Some combination of these?<br></p><p>I&#39;d like to move on from the Objective-C runtime and start exploring <br>this rich new frontier; I think it&#39;s awesome that Swift isn&#39;t *just* a <br>bracket-free dialect of Objective-C.<br></p><p>I&#39;m sorry for derailing the discussion. I think we agree on most of <br>this, anyway.<br>&lt;/off-topic&gt;<br></p><p>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; &lt;off-topic&gt;<br>&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt; <br>&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br></p><p>... rantish...<br></p><p>I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time... unless that work essentially replaces the runtime. Do we want to help coders with a great compiler and static analysis tools? Yes! Do we need to castrate the runtime to achieve this making it physically impossible for developers to escape the controlled environment we strictly want them to live in? I do not think so and we may regret the results once everything including UI and app frameworks are all Swifty™ (it is starting to get marketing firm icky when a discussion is stopped when this word is invoked or inflamed by a disagreement on who is more swiftly orthodox). I think that without holding technology back due to fear, we should not proceed only with the assumption that old way == worst thing ever  while  new way == it is new and young, it must be good.<br></p><p>Objective-C did not survive and thrive in Cocoa for so many years completely in spite of its many many deficiencies as sometimes it seems on this list (Objective-C being put down more than necessary IMHO... Swift does not need this kind of sometimes slightly biased comparison to be appreciated in full, but it can stand on its own merits). <br></p><p>Maybe the reason we like Cocoa/Cocoa Touck/AppKit/UIKit/etc... is precisely because of the beautiful balance it strikes between (sometimes leaning more on developers opting-in) safety and versatility allowing good code to be produced and tested quickly thus allowing easier prototyping, refactoring, and iterative development.<br></p><p>Sorry for the even more off topic bit and thank you to those people who read this.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/6701bc7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 19, 2016 at 08:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt; <br>&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt; <br>&gt; ... rantish...<br>&gt; <br>&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br></p><p>That is a fact back by some interesting papers. By it is also true that one cannot always be used in place of the other.<br></p><p>&gt; ... unless that work essentially replaces the runtime. Do we want to help coders with a great compiler and static analysis tools? Yes! Do we need to castrate the runtime to achieve this making it physically impossible for developers to escape the controlled environment we strictly want them to live in? I do not think so and we may regret the results once everything including UI and app frameworks are all Swifty™ (it is starting to get marketing firm icky when a discussion is stopped when this word is invoked or inflamed by a disagreement on who is more swiftly orthodox). I think that without holding technology back due to fear, we should not proceed only with the assumption that old way == worst thing ever  while  new way == it is new and young, it must be good.<br>&gt; <br>&gt; Objective-C did not survive and thrive in Cocoa for so many years completely in spite of its many many deficiencies as sometimes it seems on this list (Objective-C being put down more than necessary IMHO... Swift does not need this kind of sometimes slightly biased comparison to be appreciated in full, but it can stand on its own merits). <br>&gt; <br>&gt; Maybe the reason we like Cocoa/Cocoa Touck/AppKit/UIKit/etc... is precisely because of the beautiful balance it strikes between (sometimes leaning more on developers opting-in) safety and versatility allowing good code to be produced and tested quickly thus allowing easier prototyping, refactoring, and iterative development.<br>&gt; <br>&gt; Sorry for the even more off topic bit and thank you to those people who read this.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/b94de216/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 19, 2016, at 11:37 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt;&gt; <br>&gt;&gt; ... rantish...<br>&gt;&gt; <br>&gt;&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br>&gt; <br>&gt; That is a fact back by some interesting papers. By it is also true that one cannot always be used in place of the other.<br></p><p>While it is true that the compiler cannot fully replace everything, it can help with many types of errors that are hard to catch at runtime.<br></p><p>I’ll reiterate this again: this proposal does *not* prevent Swift from building language mechanism to allow for this type of behavior though. The fact is, Swift APIs are heavily value or value semantics so the lack of inheritance on classes is not going to be the primary reason you cannot monkey patch something.<br></p><p>What this proposal does say is this: there is no “safe” way to achieve this type of behavior that the API authors either intentionally left out or left out because of an omission. <br></p><p>If you are subclassing a class in Swift, under this proposal, you can be sure of one thing: the author explicitly made it so you’d be able to. We can argue if they did so with diligence, but that’s mostly immaterial to the discussion.<br></p><p>The fact is, in order to allow monkey patching, Swift is going to need to answer many questions that it still has yet to answer, such as how reflection is really going to work. However, with these more restrictive defaults, it’s possible to extend the language to provide runtime monkey patching that can be more easily audited both in source code and at runtime. Instead of API authors just seeing crashes in their libraries and not realizing that someone swizzled a method, we would now be able to mark who did the swizzling and which functions were actually swizzled.<br></p><p>An example of how this *could* look would be something like this:<br></p><p>struct Person { /* This is defined in module A */<br>    // a bunch of fields<br>    var birthDate: Date { get set }<br></p><p>    func calculateAge() -&gt; Int { return 12; }<br>}<br></p><p>Obviously there is a bug in `calculateAge`. How could we fix it? Well, in your app framework (or some other target as needed) as we don’t have the ability to fix module A directly:<br></p><p>extension Person {<br>    @replaceMethodImplementation func calculateAge() -&gt; Int { /* better implementation */ }<br>}<br></p><p>This would require support within the Swift language and tooling. For one, we’d need the non-optimized code to be distributed so that code within module A used this new implementation of `calculateAge`. However, this is the direction I’d much rather see Swift go. The ability to annotate code properly as monkey patches so we can audit them, track them, version them, and identify them clearly both at compile time and runtime.<br></p><p>I’m all for Swift getting the right underlying model. After that, we can address a better way to provide the necessary means to monkey patch and change behavior, but first the fundamentals need to be nailed properly.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/5b25e885/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 19 Jul 2016, at 21:41, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 11:37 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ... rantish...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br>&gt;&gt; <br>&gt;&gt; That is a fact back by some interesting papers. By it is also true that one cannot always be used in place of the other.<br>&gt; <br>&gt; While it is true that the compiler cannot fully replace everything, it can help with many types of errors that are hard to catch at runtime.<br>&gt; <br>&gt; I’ll reiterate this again: this proposal does *not* prevent Swift from building language mechanism to allow for this type of behavior though. The fact is, Swift APIs are heavily value or value semantics so the lack of inheritance on classes is not going to be the primary reason you cannot monkey patch something.<br>&gt; <br>&gt; What this proposal does say is this: there is no “safe” way to achieve this type of behavior that the API authors either intentionally left out or left out because of an omission. <br>&gt; <br>&gt; If you are subclassing a class in Swift, under this proposal, you can be sure of one thing: the author explicitly made it so you’d be able to. We can argue if they did so with diligence, but that’s mostly immaterial to the discussion.<br>&gt; <br>&gt; The fact is, in order to allow monkey patching, Swift is going to need to answer many questions that it still has yet to answer, such as how reflection is really going to work. However, with these more restrictive defaults, it’s possible to extend the language to provide runtime monkey patching that can be more easily audited both in source code and at runtime. Instead of API authors just seeing crashes in their libraries and not realizing that someone swizzled a method, we would now be able to mark who did the swizzling and which functions were actually swizzled.<br>&gt; <br>&gt; An example of how this *could* look would be something like this:<br>&gt; <br>&gt; struct Person { /* This is defined in module A */<br>&gt;     // a bunch of fields<br>&gt;     var birthDate: Date { get set }<br>&gt; <br>&gt;     func calculateAge() -&gt; Int { return 12; }<br>&gt; }<br>&gt; <br>&gt; Obviously there is a bug in `calculateAge`. How could we fix it? Well, in your app framework (or some other target as needed) as we don’t have the ability to fix module A directly:<br>&gt; <br>&gt; extension Person {<br>&gt;     @replaceMethodImplementation func calculateAge() -&gt; Int { /* better implementation */ }<br>&gt; }<br>&gt; <br>&gt; This would require support within the Swift language and tooling. For one, we’d need the non-optimized code to be distributed so that code within module A used this new implementation of `calculateAge`. However, this is the direction I’d much rather see Swift go. The ability to annotate code properly as monkey patches so we can audit them, track them, version them, and identify them clearly both at compile time and runtime.<br>&gt; <br>&gt; I’m all for Swift getting the right underlying model. After that, we can address a better way to provide the necessary means to monkey patch and change behavior, but first the fundamentals need to be nailed properly.<br></p><p>Agreed, but we need to get ourselves some metrics and not to be afraid to considered annoying non true believers :). As more coders use Swift in their apps for some portions or the entirety of their codebase, are we seeing less bugs? When will it be proper to collect the data in a productive non biased way? I think it&#39;ll be very interesting as more stats are available other than LOC ones.<br></p><p>We desire to have Swift run in all possible scenarios, complex video games included, and being a heavily value type based language with many built-in components using CoW semantics (sizeable in memory copies when some coders may forget it will happen). There is a reason why academia and a lot of coders back then we&#39;re pushing people towards reference types and pass by reference semantics and away from how C dealt with big structs and function pointers to achieve similar features.<br></p><p>&gt; <br>&gt; -David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/e71a091e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m new to this thread, but I&#39;ve read every email so far. There are a few<br>things I find confusing with the proposal, so I&#39;ll try to sum up what I see<br>so far:<br></p><p>1. I don&#39;t understand what problem this solves?<br></p><p>It seems like for 3rd party libraries only, we are afraid that people will<br>subclass things when they shouldn&#39;t? Is this a real problem? I&#39;ve honestly<br>never seen anyone incorrectly subclass something in a 3rd party library<br>when there was a good alternative. Maybe I have and I forget, but it<br>happens so rarely that I don&#39;t think it&#39;s a real problem to fix.<br></p><p>What are people frustrated by? Are 3rd party developers frustrated that<br>they can&#39;t specify this? But they can already - with final? Are consumers<br>frustrated that they&#39;re allowed to subclass when they shouldn&#39;t? I can&#39;t<br>imagine anyone wanting either of these things.<br></p><p>2. It seems that a consistent argument is that this &#39;forces developers to<br>think about it&#39;.<br></p><p>I don&#39;t understand this at all. It&#39;s not a required keyword, so why does it<br>force me to do anything? I leave it out - there&#39;s no error, no reminder, no<br>forcing.<br></p><p>3. It&#39;s a crazy specific and complex rule:<br></p><p>&quot;You can&#39;t subclass it only if it&#39;s public and only if it&#39;s in a different<br>module. Unless it&#39;s testable, then it&#39;s ok.&quot; Not only does this make many<br>assumptions about the roles of modules (not all modules are 3rd party<br>libraries), but it&#39;s a crazy rule for people to memorize. It definitely<br>violates the rule of least surprise in my opinion and I bet most people<br>running into this error will think: &quot;What is this?&quot;.<br></p><p>4. Please can we keep swift simple<br></p><p>Swift has ~94 keywords so far (I know, that&#39;s not the best way to measure<br>complexity of a language), but does this problem really warrant it&#39;s own<br>keyword? Swift is beautiful because of how it balances power and<br>complexity. These types of rules add so much complexity for very little<br>benefit.<br></p><p>5. If you think subclassing is dangerous by default, turn it off by default.<br></p><p>Why are we special casing 3rd party libraries? Since when does a language<br>assume how it&#39;s being consumed? Again, this goes back to the assumption<br>that all modules are 3rd party libraries with well thought out APIs. I<br>don&#39;t think this is true at all and don&#39;t think it&#39;s the languages role to<br>force this model. If we truly believe that subclassing is dangerous unless<br>the class is designed for it, then lets do it everywhere, not just for<br>public classes. I don&#39;t think I&#39;d vote for this, but I will admit it at<br>least has consistency and simplicity.<br></p><p><br>Summary<br></p><p>I think it&#39;s dangerous for a language to assume how code is written and<br>used. This proposal assumes that classes are written in a certain way, and<br>code is consumed in a certain way. I think Swift should stay flexible while<br>allowing for people to be expressive (e.g. the final keyword is AWESOME).<br>The pros here seem to suggest that we&#39;ll fix a bunch of bugs where<br>subclassing was done by mistake. The cons seem to be that it shackles<br>developers when people forget to add this keyword (which will happen a<br>lot...because there are 94 others to remember how to use correctly).<br></p><p><br>On Tue, Jul 19, 2016 at 2:17 PM Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 19 Jul 2016, at 21:41, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 19, 2016, at 11:37 AM, L. Mihalkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &lt;off-topic&gt;<br>&gt; Cocoa currently hides the boilerplate for all of these wonderful<br>&gt; constructs behind amazingly effective runtime acrobatics. This fits<br>&gt; perfectly into Objective-C, and it also works very well in Swift. But such<br>&gt; features could be in better harmony with Swift&#39;s unique set of language<br>&gt; constructs if their boilerplate was hidden behind amazingly effective<br>&gt; **compile-time** acrobatics instead.<br>&gt;<br>&gt; Such compile-time acrobatics are hard to perform today, and it is possible<br>&gt; that the ability to create such systems will forever remain an advanced<br>&gt; skill, just like forging runtime magic requires advanced skills in<br>&gt; Objective-C.<br>&gt;<br>&gt;<br>&gt; ... rantish...<br>&gt;<br>&gt; I am still not convinced that even the best compiler can fully replace<br>&gt; what a powerful runtime can provide no matter the acrobatics you put in in<br>&gt; terms of compiler introduced utility code/constructs or the code analysis<br>&gt; efforts you can put in at compile time<br>&gt;<br>&gt;<br>&gt; That is a fact back by some interesting papers. By it is also true that<br>&gt; one cannot always be used in place of the other.<br>&gt;<br>&gt;<br>&gt; While it is true that the compiler cannot fully replace everything, it can<br>&gt; help with many types of errors that are hard to catch at runtime.<br>&gt;<br>&gt; I’ll reiterate this again: this proposal does *not* prevent Swift from<br>&gt; building language mechanism to allow for this type of behavior though. The<br>&gt; fact is, Swift APIs are heavily value or value semantics so the lack of<br>&gt; inheritance on classes is not going to be the primary reason you cannot<br>&gt; monkey patch something.<br>&gt;<br>&gt; What this proposal does say is this: there is no “safe” way to achieve<br>&gt; this type of behavior that the API authors either intentionally left out or<br>&gt; left out because of an omission.<br>&gt;<br>&gt; If you are subclassing a class in Swift, under this proposal, you can be<br>&gt; sure of one thing: the author explicitly made it so you’d be able to. We<br>&gt; can argue if they did so with diligence, but that’s mostly immaterial to<br>&gt; the discussion.<br>&gt;<br>&gt; The fact is, in order to allow monkey patching, Swift is going to need to<br>&gt; answer many questions that it still has yet to answer, such as how<br>&gt; reflection is really going to work. However, with these more restrictive<br>&gt; defaults, it’s possible to extend the language to provide runtime monkey<br>&gt; patching that can be more easily audited both in source code and at<br>&gt; runtime. Instead of API authors just seeing crashes in their libraries and<br>&gt; not realizing that someone swizzled a method, we would now be able to mark<br>&gt; who did the swizzling and which functions were actually swizzled.<br>&gt;<br>&gt; An example of how this *could* look would be something like this:<br>&gt;<br>&gt; struct Person { /* This is defined in module A */<br>&gt;     // a bunch of fields<br>&gt;     var birthDate: Date { get set }<br>&gt;<br>&gt;     func calculateAge() -&gt; Int { return 12; }<br>&gt; }<br>&gt;<br>&gt; Obviously there is a bug in `calculateAge`. How could we fix it? Well, in<br>&gt; your app framework (or some other target as needed) as we don’t have the<br>&gt; ability to fix module A directly:<br>&gt;<br>&gt; extension Person {<br>&gt;     @replaceMethodImplementation func calculateAge() -&gt; Int { /* better<br>&gt; implementation */ }<br>&gt; }<br>&gt;<br>&gt; This would require support within the Swift language and tooling. For one,<br>&gt; we’d need the non-optimized code to be distributed so that code within<br>&gt; module A used this new implementation of `calculateAge`. However, this is<br>&gt; the direction I’d much rather see Swift go. The ability to annotate code<br>&gt; properly as monkey patches so we can audit them, track them, version them,<br>&gt; and identify them clearly both at compile time and runtime.<br>&gt;<br>&gt; I’m all for Swift getting the right underlying model. After that, we can<br>&gt; address a better way to provide the necessary means to monkey patch and<br>&gt; change behavior, but first the fundamentals need to be nailed properly.<br>&gt;<br>&gt;<br>&gt; Agreed, but we need to get ourselves some metrics and not to be afraid to<br>&gt; considered annoying non true believers :). As more coders use Swift in<br>&gt; their apps for some portions or the entirety of their codebase, are we<br>&gt; seeing less bugs? When will it be proper to collect the data in a<br>&gt; productive non biased way? I think it&#39;ll be very interesting as more stats<br>&gt; are available other than LOC ones.<br>&gt;<br>&gt; We desire to have Swift run in all possible scenarios, complex video games<br>&gt; included, and being a heavily value type based language with many built-in<br>&gt; components using CoW semantics (sizeable in memory copies when some coders<br>&gt; may forget it will happen). There is a reason why academia and a lot of<br>&gt; coders back then we&#39;re pushing people towards reference types and pass by<br>&gt; reference semantics and away from how C dealt with big structs and function<br>&gt; pointers to achieve similar features.<br>&gt;<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/93f42f18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 19, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Jul 19, 2016 at 6:26 PM, Peter Livesey via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m new to this thread, but I&#39;ve read every email so far. There are a few<br>&gt; things I find confusing with the proposal, so I&#39;ll try to sum up what I see<br>&gt; so far:<br>&gt;<br>&gt; 1. I don&#39;t understand what problem this solves?<br>&gt;<br>&gt; It seems like for 3rd party libraries only, we are afraid that people will<br>&gt; subclass things when they shouldn&#39;t? Is this a real problem?<br>&gt;<br>Yes. It is a real problem. If you vend a library for long enough and make<br>some change to a class that you never intended to be subclassed,  you are<br>likely to find out that you have broken client code.<br></p><p><br>&gt;<br>&gt; What are people frustrated by? Are 3rd party developers frustrated that<br>&gt; they can&#39;t specify this? But they can already - with final?<br>&gt;<br></p><p>`final` is not the same as sealed. `final` classes are sealed but sealed<br>classes are not necessarily final.<br></p><p><br>&gt; Are consumers frustrated that they&#39;re allowed to subclass when they<br>&gt; shouldn&#39;t? I can&#39;t imagine anyone wanting either of these things.<br>&gt;<br></p><p>I have been frustrated by having trouble correctly subclassing something<br>only to find out that I shouldn&#39;t have tried. Yes, read the documentation,<br>but documentation can often be subtle with &#39;don&#39;t  subclass this&#39;<br></p><p><br>&gt;<br>&gt; 2. It seems that a consistent argument is that this &#39;forces developers to<br>&gt; think about it&#39;.<br>&gt;<br>&gt; I don&#39;t understand this at all. It&#39;s not a required keyword, so why does<br>&gt; it force me to do anything? I leave it out - there&#39;s no error, no reminder,<br>&gt; no forcing.<br>&gt;<br></p><p>What happens when you ship the library and no-one can subclass anything,<br>even the types you intended for them to subclass? Do you not have or ship<br>any tests or demo code which uses the library as a dependency?<br></p><p><br>&gt; 3. It&#39;s a crazy specific and complex rule:<br>&gt;<br>&gt; &quot;You can&#39;t subclass it only if it&#39;s public and only if it&#39;s in a different<br>&gt; module. Unless it&#39;s testable, then it&#39;s ok.&quot; Not only does this make many<br>&gt; assumptions about the roles of modules (not all modules are 3rd party<br>&gt; libraries), but it&#39;s a crazy rule for people to memorize. It definitely<br>&gt; violates the rule of least surprise in my opinion and I bet most people<br>&gt; running into this error will think: &quot;What is this?&quot;.<br>&gt;<br></p><p>I memorized it from the first. Foreign public code must explicitly trust me<br>for this to happen.<br></p><p>`@testable` is it&#39;s own skeleton key. This is not new. Why can I see<br>`internal members? `@testable`.<br></p><p><br></p><p><br>&gt;<br>&gt; 4. Please can we keep swift simple<br>&gt;<br>&gt; Swift has ~94 keywords so far (I know, that&#39;s not the best way to measure<br>&gt; complexity of a language), but does this problem really warrant it&#39;s own<br>&gt; keyword? Swift is beautiful because of how it balances power and<br>&gt; complexity. These types of rules add so much complexity for very little<br>&gt; benefit.<br>&gt;<br></p><p>The core of swift is simple. You can teach basics up to intermediate<br>concepts pretty quickly. Advanced swift is already complex for great<br>reason. The added complexity especially beneficial because it will force a<br>conversation about this decision.<br>relatively new swift developer: &quot;Why can&#39;t I subclass anything from this<br>module that I wrote?&quot;<br>me: &quot;because you haven&#39;t explicitly stated what should be subclassed and<br>what shouldn&#39;t&quot;<br>This speaks directly to point #2.<br></p><p><br></p><p><br></p><p><br>&gt;<br>&gt; 5. If you think subclassing is dangerous by default, turn it off by<br>&gt; default.<br>&gt;<br>&gt; Why are we special casing 3rd party libraries?<br>&gt;<br>Because it is  foreign code. Code that you don&#39;t control. You say &#39;not<br>every module is 3rd party.&#39; true. You control that and can easily open<br>classes in the module because you control it. In opening it yourself, you<br>are deciding and explicitly stating that it should be open. This again<br>speaks to point #2.<br></p><p><br></p><p>&gt; Since when does a language assume how it&#39;s being consumed?<br>&gt;<br>Choosing to make something a module is an attempt to separate off some bit<br>of logic. The walls are a decision. If you control it all and you are<br>bothered by the wall, put it in the same module.<br></p><p><br>&gt; Again, this goes back to the assumption that all modules are 3rd party<br>&gt; libraries with well thought out APIs. I don&#39;t think this is true at all…<br>&gt;<br>&quot;Abandon all hope, ye who enter?&quot; How is it wrong to try to make this a<br>reality?<br></p><p><br>&gt; If we truly believe that subclassing is dangerous unless the class is<br>&gt; designed for it, then lets do it everywhere, not just for public classes. I<br>&gt; don&#39;t think I&#39;d vote for this, but I will admit it at least has consistency<br>&gt; and simplicity.<br>&gt;<br></p><p>So… the only way that you would consider this change is if we changed it to<br>be obviously less useful and, because it wouldn&#39;t be useful with that<br>change, it is not a good change?<br></p><p><br>&gt; Summary<br>&gt;<br>&gt; I think it&#39;s dangerous for a language to assume how code is written and<br>&gt; used.<br>&gt;<br></p><p>I think that it is the job of the language&#39;s maintainers to guide use of<br>the language.<br></p><p><br>&gt; This proposal assumes that classes are written in a certain way, and code<br>&gt; is consumed in a certain way.<br>&gt;<br></p><p>This proposal steers the writers and consumers of code written toward an<br>envisioned &#39;golden path&#39;.<br></p><p><br>&gt; I think Swift should stay flexible while allowing for people to be<br>&gt; expressive (e.g. the final keyword is AWESOME).<br>&gt;<br>sealed-by-default does not reduce that flexibility. It increases it.<br>&quot;oops, I have to open a class that I already shipped &quot; &lt;- entirely possible<br>to do without breaking compatibility after adoption of this proposal<br>&quot;oops. I have to seal a class that I already shipped&quot; &lt;- not possible to do<br>without breaking compatibility.<br></p><p><br></p><p>&gt; The pros here seem to suggest that we&#39;ll fix a bunch of bugs where<br>&gt; subclassing was done by mistake. The cons seem to be that it shackles<br>&gt; developers when people forget to add this keyword (which will happen a<br>&gt; lot...because there are 94 others to remember how to use correctly).<br>&gt;<br></p><p>Do we really believe that we cannot and will not teach our developers to do<br>something? &quot;abandon all hope&quot; indeed. Developers who ship APIs without<br>audits, without demo code or tests which call this out, and–finally–without<br>listening to clients who complain about this are not really a great metric,<br>are they?<br></p><p><br></p><p><br>&gt;<br>&gt;<br>&gt; On Tue, Jul 19, 2016 at 2:17 PM Goffredo Marocchi via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 19 Jul 2016, at 21:41, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 19, 2016, at 11:37 AM, L. Mihalkovic via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt;<br>&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful<br>&gt;&gt; constructs behind amazingly effective runtime acrobatics. This fits<br>&gt;&gt; perfectly into Objective-C, and it also works very well in Swift. But such<br>&gt;&gt; features could be in better harmony with Swift&#39;s unique set of language<br>&gt;&gt; constructs if their boilerplate was hidden behind amazingly effective<br>&gt;&gt; **compile-time** acrobatics instead.<br>&gt;&gt;<br>&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is<br>&gt;&gt; possible that the ability to create such systems will forever remain an<br>&gt;&gt; advanced skill, just like forging runtime magic requires advanced skills in<br>&gt;&gt; Objective-C.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ... rantish...<br>&gt;&gt;<br>&gt;&gt; I am still not convinced that even the best compiler can fully replace<br>&gt;&gt; what a powerful runtime can provide no matter the acrobatics you put in in<br>&gt;&gt; terms of compiler introduced utility code/constructs or the code analysis<br>&gt;&gt; efforts you can put in at compile time<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That is a fact back by some interesting papers. By it is also true that<br>&gt;&gt; one cannot always be used in place of the other.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; While it is true that the compiler cannot fully replace everything, it<br>&gt;&gt; can help with many types of errors that are hard to catch at runtime.<br>&gt;&gt;<br>&gt;&gt; I’ll reiterate this again: this proposal does *not* prevent Swift from<br>&gt;&gt; building language mechanism to allow for this type of behavior though. The<br>&gt;&gt; fact is, Swift APIs are heavily value or value semantics so the lack of<br>&gt;&gt; inheritance on classes is not going to be the primary reason you cannot<br>&gt;&gt; monkey patch something.<br>&gt;&gt;<br>&gt;&gt; What this proposal does say is this: there is no “safe” way to achieve<br>&gt;&gt; this type of behavior that the API authors either intentionally left out or<br>&gt;&gt; left out because of an omission.<br>&gt;&gt;<br>&gt;&gt; If you are subclassing a class in Swift, under this proposal, you can be<br>&gt;&gt; sure of one thing: the author explicitly made it so you’d be able to. We<br>&gt;&gt; can argue if they did so with diligence, but that’s mostly immaterial to<br>&gt;&gt; the discussion.<br>&gt;&gt;<br>&gt;&gt; The fact is, in order to allow monkey patching, Swift is going to need to<br>&gt;&gt; answer many questions that it still has yet to answer, such as how<br>&gt;&gt; reflection is really going to work. However, with these more restrictive<br>&gt;&gt; defaults, it’s possible to extend the language to provide runtime monkey<br>&gt;&gt; patching that can be more easily audited both in source code and at<br>&gt;&gt; runtime. Instead of API authors just seeing crashes in their libraries and<br>&gt;&gt; not realizing that someone swizzled a method, we would now be able to mark<br>&gt;&gt; who did the swizzling and which functions were actually swizzled.<br>&gt;&gt;<br>&gt;&gt; An example of how this *could* look would be something like this:<br>&gt;&gt;<br>&gt;&gt; struct Person { /* This is defined in module A */<br>&gt;&gt;     // a bunch of fields<br>&gt;&gt;     var birthDate: Date { get set }<br>&gt;&gt;<br>&gt;&gt;     func calculateAge() -&gt; Int { return 12; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Obviously there is a bug in `calculateAge`. How could we fix it? Well, in<br>&gt;&gt; your app framework (or some other target as needed) as we don’t have the<br>&gt;&gt; ability to fix module A directly:<br>&gt;&gt;<br>&gt;&gt; extension Person {<br>&gt;&gt;     @replaceMethodImplementation func calculateAge() -&gt; Int { /* better<br>&gt;&gt; implementation */ }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would require support within the Swift language and tooling. For<br>&gt;&gt; one, we’d need the non-optimized code to be distributed so that code within<br>&gt;&gt; module A used this new implementation of `calculateAge`. However, this is<br>&gt;&gt; the direction I’d much rather see Swift go. The ability to annotate code<br>&gt;&gt; properly as monkey patches so we can audit them, track them, version them,<br>&gt;&gt; and identify them clearly both at compile time and runtime.<br>&gt;&gt;<br>&gt;&gt; I’m all for Swift getting the right underlying model. After that, we can<br>&gt;&gt; address a better way to provide the necessary means to monkey patch and<br>&gt;&gt; change behavior, but first the fundamentals need to be nailed properly.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Agreed, but we need to get ourselves some metrics and not to be afraid to<br>&gt;&gt; considered annoying non true believers :). As more coders use Swift in<br>&gt;&gt; their apps for some portions or the entirety of their codebase, are we<br>&gt;&gt; seeing less bugs? When will it be proper to collect the data in a<br>&gt;&gt; productive non biased way? I think it&#39;ll be very interesting as more stats<br>&gt;&gt; are available other than LOC ones.<br>&gt;&gt;<br>&gt;&gt; We desire to have Swift run in all possible scenarios, complex video<br>&gt;&gt; games included, and being a heavily value type based language with many<br>&gt;&gt; built-in components using CoW semantics (sizeable in memory copies when<br>&gt;&gt; some coders may forget it will happen). There is a reason why academia and<br>&gt;&gt; a lot of coders back then we&#39;re pushing people towards reference types and<br>&gt;&gt; pass by reference semantics and away from how C dealt with big structs and<br>&gt;&gt; function pointers to achieve similar features.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/b3f87b56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>July 19, 2016 at 11:00:00pm</p></header><div class="content"><p>---- &quot;Yes. It is a real problem. If you vend a library for long enough and<br>make some change to a class that you never intended to be subclassed,  you<br>are likely to find out that you have broken client code.&quot;<br></p><p>Ok, so the problem here is that you forgot to think if this makes sense to<br>subclass or not. I don&#39;t see how this proposal makes people do this? This<br>proposal doesn&#39;t fix this bug? It just changes a default.<br></p><p>---- `final` is not the same as sealed. `final` classes are sealed but<br>sealed classes are not necessarily final.<br></p><p>This highlights my point. Why? Why do we need this distinction? If a class<br>can be subclassed, then it can. If it can&#39;t, it can&#39;t.<br></p><p>----- What happens when you ship the library and no-one can subclass<br>anything, even the types you intended for them to subclass? Do you not have<br>or ship any tests or demo code which uses the library as a dependency?<br></p><p>I feel like this boils down to - if someone finds a bug, you&#39;re forced to<br>fix it. Yes, that&#39;s true. But again, this happens with or without this<br>proposal. It seems like this proposal is then saying:<br>Let&#39;s make things as restrictive as possible by default so that when<br>developers make mistakes, their APIs will be backwards compatible? As in,<br>adding final isn&#39;t backwards compatible, but adding open is?<br>This maybe leads to your last point. I just think this is such a narrow use<br>case for the language.<br></p><p>---- &quot;Because it is  foreign code. Code that you don&#39;t control. You say<br>&#39;not every module is 3rd party.&#39; true. You control that and can easily open<br>classes in the module because you control it. In opening it yourself, you<br>are deciding and explicitly stating that it should be open. This again<br>speaks to point #2.&quot;<br></p><p>This I think is the big one. Currently, we put the responsibility on the<br>API developer to remember to use final. If they forget, then developers<br>have their options open. With the new model, if they forget, developers<br>have no options. It seems to me like:<br></p><p>1. If developers remember to write good APIs every time, then both models<br>are equivalent.<br>2. If developers forget then:<br></p><p>With this proposal: consumers are screwed until the library is fixed, but<br>the change is backwards compatible.<br>Without this proposal: consumers are fine to choose what to do (and maybe<br>make mistakes), but the change could be backwards incompatible.<br></p><p>To me, consumers not being screwed &gt; changes being backwards compatible. If<br>the API designer has a bad API, then sure, some backwards incompatible<br>things may happen. I don&#39;t think we should design for APIs being<br>incorrectly written, which I think we are doing.<br></p><p>On Tue, Jul 19, 2016 at 4:12 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Jul 19, 2016 at 6:26 PM, Peter Livesey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;m new to this thread, but I&#39;ve read every email so far. There are a few<br>&gt;&gt; things I find confusing with the proposal, so I&#39;ll try to sum up what I see<br>&gt;&gt; so far:<br>&gt;&gt;<br>&gt;&gt; 1. I don&#39;t understand what problem this solves?<br>&gt;&gt;<br>&gt;&gt; It seems like for 3rd party libraries only, we are afraid that people<br>&gt;&gt; will subclass things when they shouldn&#39;t? Is this a real problem?<br>&gt;&gt;<br>&gt; Yes. It is a real problem. If you vend a library for long enough and make<br>&gt; some change to a class that you never intended to be subclassed,  you are<br>&gt; likely to find out that you have broken client code.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; What are people frustrated by? Are 3rd party developers frustrated that<br>&gt;&gt; they can&#39;t specify this? But they can already - with final?<br>&gt;&gt;<br>&gt;<br>&gt; `final` is not the same as sealed. `final` classes are sealed but sealed<br>&gt; classes are not necessarily final.<br>&gt;<br>&gt;<br>&gt;&gt; Are consumers frustrated that they&#39;re allowed to subclass when they<br>&gt;&gt; shouldn&#39;t? I can&#39;t imagine anyone wanting either of these things.<br>&gt;&gt;<br>&gt;<br>&gt; I have been frustrated by having trouble correctly subclassing something<br>&gt; only to find out that I shouldn&#39;t have tried. Yes, read the documentation,<br>&gt; but documentation can often be subtle with &#39;don&#39;t  subclass this&#39;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 2. It seems that a consistent argument is that this &#39;forces developers to<br>&gt;&gt; think about it&#39;.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand this at all. It&#39;s not a required keyword, so why does<br>&gt;&gt; it force me to do anything? I leave it out - there&#39;s no error, no reminder,<br>&gt;&gt; no forcing.<br>&gt;&gt;<br>&gt;<br>&gt; What happens when you ship the library and no-one can subclass anything,<br>&gt; even the types you intended for them to subclass? Do you not have or ship<br>&gt; any tests or demo code which uses the library as a dependency?<br>&gt;<br>&gt;<br>&gt;&gt; 3. It&#39;s a crazy specific and complex rule:<br>&gt;&gt;<br>&gt;&gt; &quot;You can&#39;t subclass it only if it&#39;s public and only if it&#39;s in a<br>&gt;&gt; different module. Unless it&#39;s testable, then it&#39;s ok.&quot; Not only does this<br>&gt;&gt; make many assumptions about the roles of modules (not all modules are 3rd<br>&gt;&gt; party libraries), but it&#39;s a crazy rule for people to memorize. It<br>&gt;&gt; definitely violates the rule of least surprise in my opinion and I bet most<br>&gt;&gt; people running into this error will think: &quot;What is this?&quot;.<br>&gt;&gt;<br>&gt;<br>&gt; I memorized it from the first. Foreign public code must explicitly trust<br>&gt; me for this to happen.<br>&gt;<br>&gt; `@testable` is it&#39;s own skeleton key. This is not new. Why can I see<br>&gt; `internal members? `@testable`.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 4. Please can we keep swift simple<br>&gt;&gt;<br>&gt;&gt; Swift has ~94 keywords so far (I know, that&#39;s not the best way to measure<br>&gt;&gt; complexity of a language), but does this problem really warrant it&#39;s own<br>&gt;&gt; keyword? Swift is beautiful because of how it balances power and<br>&gt;&gt; complexity. These types of rules add so much complexity for very little<br>&gt;&gt; benefit.<br>&gt;&gt;<br>&gt;<br>&gt; The core of swift is simple. You can teach basics up to intermediate<br>&gt; concepts pretty quickly. Advanced swift is already complex for great<br>&gt; reason. The added complexity especially beneficial because it will force a<br>&gt; conversation about this decision.<br>&gt; relatively new swift developer: &quot;Why can&#39;t I subclass anything from this<br>&gt; module that I wrote?&quot;<br>&gt; me: &quot;because you haven&#39;t explicitly stated what should be subclassed and<br>&gt; what shouldn&#39;t&quot;<br>&gt; This speaks directly to point #2.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 5. If you think subclassing is dangerous by default, turn it off by<br>&gt;&gt; default.<br>&gt;&gt;<br>&gt;&gt; Why are we special casing 3rd party libraries?<br>&gt;&gt;<br>&gt; Because it is  foreign code. Code that you don&#39;t control. You say &#39;not<br>&gt; every module is 3rd party.&#39; true. You control that and can easily open<br>&gt; classes in the module because you control it. In opening it yourself, you<br>&gt; are deciding and explicitly stating that it should be open. This again<br>&gt; speaks to point #2.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Since when does a language assume how it&#39;s being consumed?<br>&gt;&gt;<br>&gt; Choosing to make something a module is an attempt to separate off some bit<br>&gt; of logic. The walls are a decision. If you control it all and you are<br>&gt; bothered by the wall, put it in the same module.<br>&gt;<br>&gt;<br>&gt;&gt; Again, this goes back to the assumption that all modules are 3rd party<br>&gt;&gt; libraries with well thought out APIs. I don&#39;t think this is true at all…<br>&gt;&gt;<br>&gt; &quot;Abandon all hope, ye who enter?&quot; How is it wrong to try to make this a<br>&gt; reality?<br>&gt;<br>&gt;<br>&gt;&gt; If we truly believe that subclassing is dangerous unless the class is<br>&gt;&gt; designed for it, then lets do it everywhere, not just for public classes. I<br>&gt;&gt; don&#39;t think I&#39;d vote for this, but I will admit it at least has consistency<br>&gt;&gt; and simplicity.<br>&gt;&gt;<br>&gt;<br>&gt; So… the only way that you would consider this change is if we changed it<br>&gt; to be obviously less useful and, because it wouldn&#39;t be useful with that<br>&gt; change, it is not a good change?<br>&gt;<br>&gt;<br>&gt;&gt; Summary<br>&gt;&gt;<br>&gt;&gt; I think it&#39;s dangerous for a language to assume how code is written and<br>&gt;&gt; used.<br>&gt;&gt;<br>&gt;<br>&gt; I think that it is the job of the language&#39;s maintainers to guide use of<br>&gt; the language.<br>&gt;<br>&gt;<br>&gt;&gt; This proposal assumes that classes are written in a certain way, and code<br>&gt;&gt; is consumed in a certain way.<br>&gt;&gt;<br>&gt;<br>&gt; This proposal steers the writers and consumers of code written toward an<br>&gt; envisioned &#39;golden path&#39;.<br>&gt;<br>&gt;<br>&gt;&gt; I think Swift should stay flexible while allowing for people to be<br>&gt;&gt; expressive (e.g. the final keyword is AWESOME).<br>&gt;&gt;<br>&gt; sealed-by-default does not reduce that flexibility. It increases it.<br>&gt; &quot;oops, I have to open a class that I already shipped &quot; &lt;- entirely<br>&gt; possible to do without breaking compatibility after adoption of this<br>&gt; proposal<br>&gt; &quot;oops. I have to seal a class that I already shipped&quot; &lt;- not possible to<br>&gt; do without breaking compatibility.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; The pros here seem to suggest that we&#39;ll fix a bunch of bugs where<br>&gt;&gt; subclassing was done by mistake. The cons seem to be that it shackles<br>&gt;&gt; developers when people forget to add this keyword (which will happen a<br>&gt;&gt; lot...because there are 94 others to remember how to use correctly).<br>&gt;&gt;<br>&gt;<br>&gt; Do we really believe that we cannot and will not teach our developers to<br>&gt; do something? &quot;abandon all hope&quot; indeed. Developers who ship APIs without<br>&gt; audits, without demo code or tests which call this out, and–finally–without<br>&gt; listening to clients who complain about this are not really a great metric,<br>&gt; are they?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Jul 19, 2016 at 2:17 PM Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 19 Jul 2016, at 21:41, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 19, 2016, at 11:37 AM, L. Mihalkovic via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful<br>&gt;&gt;&gt; constructs behind amazingly effective runtime acrobatics. This fits<br>&gt;&gt;&gt; perfectly into Objective-C, and it also works very well in Swift. But such<br>&gt;&gt;&gt; features could be in better harmony with Swift&#39;s unique set of language<br>&gt;&gt;&gt; constructs if their boilerplate was hidden behind amazingly effective<br>&gt;&gt;&gt; **compile-time** acrobatics instead.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is<br>&gt;&gt;&gt; possible that the ability to create such systems will forever remain an<br>&gt;&gt;&gt; advanced skill, just like forging runtime magic requires advanced skills in<br>&gt;&gt;&gt; Objective-C.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ... rantish...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am still not convinced that even the best compiler can fully replace<br>&gt;&gt;&gt; what a powerful runtime can provide no matter the acrobatics you put in in<br>&gt;&gt;&gt; terms of compiler introduced utility code/constructs or the code analysis<br>&gt;&gt;&gt; efforts you can put in at compile time<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is a fact back by some interesting papers. By it is also true that<br>&gt;&gt;&gt; one cannot always be used in place of the other.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While it is true that the compiler cannot fully replace everything, it<br>&gt;&gt;&gt; can help with many types of errors that are hard to catch at runtime.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ll reiterate this again: this proposal does *not* prevent Swift from<br>&gt;&gt;&gt; building language mechanism to allow for this type of behavior though. The<br>&gt;&gt;&gt; fact is, Swift APIs are heavily value or value semantics so the lack of<br>&gt;&gt;&gt; inheritance on classes is not going to be the primary reason you cannot<br>&gt;&gt;&gt; monkey patch something.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What this proposal does say is this: there is no “safe” way to achieve<br>&gt;&gt;&gt; this type of behavior that the API authors either intentionally left out or<br>&gt;&gt;&gt; left out because of an omission.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you are subclassing a class in Swift, under this proposal, you can be<br>&gt;&gt;&gt; sure of one thing: the author explicitly made it so you’d be able to. We<br>&gt;&gt;&gt; can argue if they did so with diligence, but that’s mostly immaterial to<br>&gt;&gt;&gt; the discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The fact is, in order to allow monkey patching, Swift is going to need<br>&gt;&gt;&gt; to answer many questions that it still has yet to answer, such as how<br>&gt;&gt;&gt; reflection is really going to work. However, with these more restrictive<br>&gt;&gt;&gt; defaults, it’s possible to extend the language to provide runtime monkey<br>&gt;&gt;&gt; patching that can be more easily audited both in source code and at<br>&gt;&gt;&gt; runtime. Instead of API authors just seeing crashes in their libraries and<br>&gt;&gt;&gt; not realizing that someone swizzled a method, we would now be able to mark<br>&gt;&gt;&gt; who did the swizzling and which functions were actually swizzled.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An example of how this *could* look would be something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Person { /* This is defined in module A */<br>&gt;&gt;&gt;     // a bunch of fields<br>&gt;&gt;&gt;     var birthDate: Date { get set }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func calculateAge() -&gt; Int { return 12; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Obviously there is a bug in `calculateAge`. How could we fix it? Well,<br>&gt;&gt;&gt; in your app framework (or some other target as needed) as we don’t have the<br>&gt;&gt;&gt; ability to fix module A directly:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Person {<br>&gt;&gt;&gt;     @replaceMethodImplementation func calculateAge() -&gt; Int { /* better<br>&gt;&gt;&gt; implementation */ }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would require support within the Swift language and tooling. For<br>&gt;&gt;&gt; one, we’d need the non-optimized code to be distributed so that code within<br>&gt;&gt;&gt; module A used this new implementation of `calculateAge`. However, this is<br>&gt;&gt;&gt; the direction I’d much rather see Swift go. The ability to annotate code<br>&gt;&gt;&gt; properly as monkey patches so we can audit them, track them, version them,<br>&gt;&gt;&gt; and identify them clearly both at compile time and runtime.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m all for Swift getting the right underlying model. After that, we can<br>&gt;&gt;&gt; address a better way to provide the necessary means to monkey patch and<br>&gt;&gt;&gt; change behavior, but first the fundamentals need to be nailed properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Agreed, but we need to get ourselves some metrics and not to be afraid<br>&gt;&gt;&gt; to considered annoying non true believers :). As more coders use Swift in<br>&gt;&gt;&gt; their apps for some portions or the entirety of their codebase, are we<br>&gt;&gt;&gt; seeing less bugs? When will it be proper to collect the data in a<br>&gt;&gt;&gt; productive non biased way? I think it&#39;ll be very interesting as more stats<br>&gt;&gt;&gt; are available other than LOC ones.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We desire to have Swift run in all possible scenarios, complex video<br>&gt;&gt;&gt; games included, and being a heavily value type based language with many<br>&gt;&gt;&gt; built-in components using CoW semantics (sizeable in memory copies when<br>&gt;&gt;&gt; some coders may forget it will happen). There is a reason why academia and<br>&gt;&gt;&gt; a lot of coders back then we&#39;re pushing people towards reference types and<br>&gt;&gt;&gt; pass by reference semantics and away from how C dealt with big structs and<br>&gt;&gt;&gt; function pointers to achieve similar features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/a4c18a73/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Peter,<br></p><p>&gt; Am 20.07.2016 um 00:26 schrieb Peter Livesey via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; 1. I don&#39;t understand what problem this solves?<br></p><p>That&#39;s just natural — most likely you have just a different mindset.<br></p><p>There are already several cases where &quot;bureaucrats try to constrict freedom&quot; (sorry, it&#39;s hard to come up with neutral words here... but on the other hand: a bureaucrat may have a much more positive interpretation of this term than I ;-), and when I noticed it for the first time, I was really baffled why someone tries hard to push a change that creates limitations without offering any significant benefit…<br>I found the missing piece to understand the situation here<br>http://martinfowler.com/bliki/DirectingAttitude.html &lt;http://martinfowler.com/bliki/DirectingAttitude.html&gt;<br>Fowler did a great job, and with this hint I realized why I couldn&#39;t find any good arguments for the other side: There is none — at least for me, as It is all only a matter of perspective.<br>The only thing missing in Fowlers three articles are good designations for members of the two camps (I personally refer to my side as the &quot;hackers&quot;, and I already mentioned the &quot;bureaucrats&quot; ;-)<br>Imho the discussion would greatly improve if everybody accepted this model of two contrary attitudes.<br></p><p>This insight really helped me to keep my sanity in the face of many others acting absolutely &quot;nuts&quot;, fighting for a change with nothing but downsides and not even a single example that there are situations where it would be beneficial for me.<br></p><p>So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br></p><p>- Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e311e103/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 20, 2016, at 9:54 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Peter,<br>&gt; <br>&gt;&gt; Am 20.07.2016 um 00:26 schrieb Peter Livesey via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; 1. I don&#39;t understand what problem this solves?<br>&gt; <br>&gt; That&#39;s just natural — most likely you have just a different mindset.<br>&gt; <br>&gt; There are already several cases where &quot;bureaucrats try to constrict freedom&quot; (sorry, it&#39;s hard to come up with neutral words here... but on the other hand: a bureaucrat may have a much more positive interpretation of this term than I ;-), and when I noticed it for the first time, I was really baffled why someone tries hard to push a change that creates limitations without offering any significant benefit…<br>&gt; I found the missing piece to understand the situation here<br>&gt; http://martinfowler.com/bliki/DirectingAttitude.html<br>&gt; Fowler did a great job, and with this hint I realized why I couldn&#39;t find any good arguments for the other side: There is none — at least for me, as It is all only a matter of perspective.<br>&gt; The only thing missing in Fowlers three articles are good designations for members of the two camps (I personally refer to my side as the &quot;hackers&quot;, and I already mentioned the &quot;bureaucrats&quot; ;-)<br>&gt; Imho the discussion would greatly improve if everybody accepted this model of two contrary attitudes.<br>&gt; <br>&gt; This insight really helped me to keep my sanity in the face of many others acting absolutely &quot;nuts&quot;, fighting for a change with nothing but downsides and not even a single example that there are situations where it would be beneficial for me.<br>&gt; <br>&gt; So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br></p><p>That ship has sailed... it is now just a matter of the implementation details... My hopes are now on google forking swift like they did to webkit and dalvik. It won&#39;t save the apps, bug it would the servers.<br></p><p>&gt; <br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e17e0597/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 20.07.2016 um 18:20 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt;&gt; So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br>&gt; <br>&gt; That ship has sailed... it is now just a matter of the implementation details... My hopes are now on google forking swift like they did to webkit and dalvik. It won&#39;t save the apps, bug it would the servers.<br>;-) nay, that&#39;s a little bit to pessimistic for me:<br>After all, even with SE-0117, you can still write nice code with Swift — it just will be less fun :(<br></p><p>Afaics, there is constant pressure to turn Swift into a language for fools, rather than a language that helps us avoiding foolish mistakes… but so far, Swift got more things right for me than any of the alternatives.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/13b3e575/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 12:44 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 20.07.2016 um 18:20 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br>&gt;&gt; <br>&gt;&gt; That ship has sailed... it is now just a matter of the implementation details... My hopes are now on google forking swift like they did to webkit and dalvik. It won&#39;t save the apps, bug it would the servers.<br>&gt; ;-) nay, that&#39;s a little bit to pessimistic for me:<br>&gt; After all, even with SE-0117, you can still write nice code with Swift — it just will be less fun :(<br>&gt; <br>&gt; Afaics, there is constant pressure to turn Swift into a language for fools, rather than a language that helps us avoiding foolish mistakes… but so far, Swift got more things right for me than any of the alternatives.<br></p><p>I think we’ve all had some disappointments in at least some part of the evolution of Swift - it is only natural, as the difference of opinions and perspectives is why this mailing list exists.<br></p><p>I for one was very disappointed at the addition of the new “private” visibility - I didn’t see a real-world need for smaller-than-file scope, it made ‘fileprivate&#39;  be spelled ugly and I felt it was too early to expand visibility features before we had established whether submodules or multi-module frameworks would be evolution targets. But in the words of a former coworker, it hardly seems a hill worth dying on.<br></p><p>In the end, design is all about trade-offs. I still think Swift has a decent and consistent design and design evolution, and I look forward to see what we enable in the Swift 4/5 timeframe.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/7f5d82d2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 11:44 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 20.07.2016 um 18:20 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br>&gt;&gt; <br>&gt;&gt; That ship has sailed... it is now just a matter of the implementation details... My hopes are now on google forking swift like they did to webkit and dalvik. It won&#39;t save the apps, bug it would the servers.<br>&gt; ;-) nay, that&#39;s a little bit to pessimistic for me:<br>&gt; After all, even with SE-0117, you can still write nice code with Swift — it just will be less fun :(<br>&gt; <br>&gt; Afaics, there is constant pressure to turn Swift into a language for fools,<br>“<br> Because the people who are crazy enough to think they can change the world, are the ones who do.<br></p><p>&quot;<br></p><p>&gt; rather than a language that helps us avoiding foolish mistakes… but so far, Swift got more things right for me than any of the alternatives.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/4242cd9c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 20, 2016, at 8:44 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 20.07.2016 um 18:20 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So my advice: Be glad that you don&#39;t see such problems in your real work life, and hope that the extremists who would like to completely remove classic object orientation and cripple Swift to fully match their ideals don&#39;t prevail ;-)<br>&gt;&gt; <br>&gt;&gt; That ship has sailed... it is now just a matter of the implementation details... My hopes are now on google forking swift like they did to webkit and dalvik. It won&#39;t save the apps, bug it would the servers.<br>&gt; ;-) nay, that&#39;s a little bit to pessimistic for me:<br>&gt; After all, even with SE-0117, you can still write nice code with Swift — it just will be less fun :(<br></p><p>Give typescript a shot... It is a very entertaining and increadibly productive language. <br>For the most part of this past year i was entertaining the idea that we could eventually use swift to write the next generation of the planet&#39;s servers, even sharing object model and some of the business logic with the client side, and that swift would be partially designed for this task in mind (even to write their own servers). But I finally accepted that Apple is not the software company to bet-on for cloud servers work anytime soon. Some of the arguments i have read over the past few months show that this is truly just about finding a very effective and practical replacement for objc. I&#39;ve been working with cloud foundry codebase (golang), and today i needed a small command line tool. Swift is just not ready for that today.<br>Have fun.<br></p><p>&gt; <br>&gt; Afaics, there is constant pressure to turn Swift into a language for fools, rather than a language that helps us avoiding foolish mistakes… but so far, Swift got more things right for me than any of the alternatives.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/2a599fee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 19 Jul 2016, at 19:37, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt;&gt; <br>&gt;&gt; ... rantish...<br>&gt;&gt; <br>&gt;&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br>&gt; <br>&gt; That is a fact back by some interesting papers.<br></p><p>It would be interesting if this is practical or a theoretical you could, but would you? Can such a compiler exist and if it does what is preventing it from being the standard way we build software with? Recursion only languages are possible and a fact too. Do you have some links btw?<br></p><p>All the magic comes with a price ;), what is the price of only relying on static code analysis? How much do we pay in productivity? Nothing is free.<br></p><p>How much would we pay in performance if one day the CPU takes the same approach and throws branch predictors, prefetchers, register renaming and reorder buffers, store-load forwarding, etc... (I am also insanely convinced that given proper funds and a modern manufacturing process IA-64 had a chance to prove itself and kick some ass ;)) and we have another go at VLIW?<br></p><p>&gt; By it is also true that one cannot always be used in place of the other.<br>&gt; <br>&gt;&gt; ... unless that work essentially replaces the runtime. Do we want to help coders with a great compiler and static analysis tools? Yes! Do we need to castrate the runtime to achieve this making it physically impossible for developers to escape the controlled environment we strictly want them to live in? I do not think so and we may regret the results once everything including UI and app frameworks are all Swifty™ (it is starting to get marketing firm icky when a discussion is stopped when this word is invoked or inflamed by a disagreement on who is more swiftly orthodox). I think that without holding technology back due to fear, we should not proceed only with the assumption that old way == worst thing ever  while  new way == it is new and young, it must be good.<br>&gt;&gt; <br>&gt;&gt; Objective-C did not survive and thrive in Cocoa for so many years completely in spite of its many many deficiencies as sometimes it seems on this list (Objective-C being put down more than necessary IMHO... Swift does not need this kind of sometimes slightly biased comparison to be appreciated in full, but it can stand on its own merits). <br>&gt;&gt; <br>&gt;&gt; Maybe the reason we like Cocoa/Cocoa Touck/AppKit/UIKit/etc... is precisely because of the beautiful balance it strikes between (sometimes leaning more on developers opting-in) safety and versatility allowing good code to be produced and tested quickly thus allowing easier prototyping, refactoring, and iterative development.<br>&gt;&gt; <br>&gt;&gt; Sorry for the even more off topic bit and thank you to those people who read this.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/fe3f9a94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 20, 2016 at 12:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 19, 2016, at 11:05 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 19 Jul 2016, at 19:37, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ... rantish...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br>&gt;&gt; <br>&gt;&gt; That is a fact back by some interesting papers.<br>&gt; <br>&gt; It would be interesting if this is practical or a theoretical you could, but would you? Can such a compiler exist and if it does what is preventing it from being the standard way we build software with? Recursion only languages are possible and a fact too. Do you have some links btw?<br>&gt; <br>&gt; All the magic comes with a price ;), what is the price of only relying on static code analysis? How much do we pay in productivity? Nothing is free.<br></p><p>Runtime optimization beats compiler hands down on long running code. Don&#39;t think swift will ever be as good as java on servers, but I don&#39;t think it is their target either, so all&#39;s well. I wish google would fork swift next year to make it more credible on servers. Don&#39;t get me wrong, swift is great.. as a successor to objc. I had high hopes when it came out, but at the moment i take far more pleasure in writting generic code in typescript. This is quite disapointing so far, and 3 is just differently unfinished than 2 was, but not fundamentally enhanced.<br></p><p>&gt; <br>&gt; How much would we pay in performance if one day the CPU takes the same approach and throws branch predictors, prefetchers, register renaming and reorder buffers, store-load forwarding, etc... (I am also insanely convinced that given proper funds and a modern manufacturing process IA-64 had a chance to prove itself and kick some ass ;))<br></p><p>At what power cost?  In the end arm is showing that simplicity works.<br></p><p><br>&gt; and we have another go at VLIW?<br>&gt; <br>&gt;&gt; By it is also true that one cannot always be used in place of the other.<br>&gt;&gt; <br>&gt;&gt;&gt; ... unless that work essentially replaces the runtime. Do we want to help coders with a great compiler and static analysis tools? Yes! Do we need to castrate the runtime to achieve this making it physically impossible for developers to escape the controlled environment we strictly want them to live in? I do not think so and we may regret the results once everything including UI and app frameworks are all Swifty™ (it is starting to get marketing firm icky when a discussion is stopped when this word is invoked or inflamed by a disagreement on who is more swiftly orthodox). I think that without holding technology back due to fear, we should not proceed only with the assumption that old way == worst thing ever  while  new way == it is new and young, it must be good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Objective-C did not survive and thrive in Cocoa for so many years completely in spite of its many many deficiencies as sometimes it seems on this list (Objective-C being put down more than necessary IMHO... Swift does not need this kind of sometimes slightly biased comparison to be appreciated in full, but it can stand on its own merits). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe the reason we like Cocoa/Cocoa Touck/AppKit/UIKit/etc... is precisely because of the beautiful balance it strikes between (sometimes leaning more on developers opting-in) safety and versatility allowing good code to be produced and tested quickly thus allowing easier prototyping, refactoring, and iterative development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry for the even more off topic bit and thank you to those people who read this.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/d9065c44/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 20, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 19 Jul 2016, at 23:36, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 11:05 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 19 Jul 2016, at 19:37, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 19, 2016, at 8:19 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;off-topic&gt;<br>&gt;&gt;&gt;&gt;&gt; Cocoa currently hides the boilerplate for all of these wonderful constructs behind amazingly effective runtime acrobatics. This fits perfectly into Objective-C, and it also works very well in Swift. But such features could be in better harmony with Swift&#39;s unique set of language constructs if their boilerplate was hidden behind amazingly effective **compile-time** acrobatics instead.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Such compile-time acrobatics are hard to perform today, and it is possible that the ability to create such systems will forever remain an advanced skill, just like forging runtime magic requires advanced skills in Objective-C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ... rantish...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am still not convinced that even the best compiler can fully replace what a powerful runtime can provide no matter the acrobatics you put in in terms of compiler introduced utility code/constructs or the code analysis efforts you can put in at compile time<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a fact back by some interesting papers.<br>&gt;&gt; <br>&gt;&gt; It would be interesting if this is practical or a theoretical you could, but would you? Can such a compiler exist and if it does what is preventing it from being the standard way we build software with? Recursion only languages are possible and a fact too. Do you have some links btw?<br>&gt;&gt; <br>&gt;&gt; All the magic comes with a price ;), what is the price of only relying on static code analysis? How much do we pay in productivity? Nothing is free.<br>&gt; <br>&gt; Runtime optimization beats compiler hands down on long running code. Don&#39;t think swift will ever be as good as java on servers, but I don&#39;t think it is their target either, so all&#39;s well. I wish google would fork swift next year to make it more credible on servers. Don&#39;t get me wrong, swift is great.. as a successor to objc. I had high hopes when it came out, but at the moment i take far more pleasure in writting generic code in typescript. This is quite disapointing so far, and 3 is just differently unfinished than 2 was, but not fundamentally enhanced.<br>&gt; <br></p><p>I think we were not in disagreement :).<br></p><p>&gt;&gt; <br>&gt;&gt; How much would we pay in performance if one day the CPU takes the same approach and throws branch predictors, prefetchers, register renaming and reorder buffers, store-load forwarding, etc... (I am also insanely convinced that given proper funds and a modern manufacturing process IA-64 had a chance to prove itself and kick some ass ;))<br>&gt; <br>&gt; At what power cost?  In the end arm is showing that simplicity works.<br>&gt; <br></p><p>ARM has cleverly added a lot of runtime HW enhancements over the years: wider SIMD, it used to offer predication on every instruction essentially, it added out of order execution, I would be surprised if they did not properly address Load-Hit-Store stalls by doing clever pipeline stage data forwarding, etc... but still, we agree that the simplicity of their overall approach yielded awesome results (like Alpha was having on servers).<br></p><p>&gt; <br>&gt;&gt; and we have another go at VLIW?<br>&gt;&gt; <br>&gt;&gt;&gt; By it is also true that one cannot always be used in place of the other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ... unless that work essentially replaces the runtime. Do we want to help coders with a great compiler and static analysis tools? Yes! Do we need to castrate the runtime to achieve this making it physically impossible for developers to escape the controlled environment we strictly want them to live in? I do not think so and we may regret the results once everything including UI and app frameworks are all Swifty™ (it is starting to get marketing firm icky when a discussion is stopped when this word is invoked or inflamed by a disagreement on who is more swiftly orthodox). I think that without holding technology back due to fear, we should not proceed only with the assumption that old way == worst thing ever  while  new way == it is new and young, it must be good.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Objective-C did not survive and thrive in Cocoa for so many years completely in spite of its many many deficiencies as sometimes it seems on this list (Objective-C being put down more than necessary IMHO... Swift does not need this kind of sometimes slightly biased comparison to be appreciated in full, but it can stand on its own merits). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe the reason we like Cocoa/Cocoa Touck/AppKit/UIKit/etc... is precisely because of the beautiful balance it strikes between (sometimes leaning more on developers opting-in) safety and versatility allowing good code to be produced and tested quickly thus allowing easier prototyping, refactoring, and iterative development.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry for the even more off topic bit and thank you to those people who read this.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/7c7377d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
