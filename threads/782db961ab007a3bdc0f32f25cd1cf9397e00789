<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>ADD AN @RESTRICTED DECLARATION ATTRIBUTE<br></p><p>Proposal: SE-NNNN<br>Author: Stuart Breckenridge<br>Status: DRAFT<br>Review Manager: TBD<br>Introduction<br></p><p>Adapted from the Swift 2.2 Programming Guide:<br>The @available attribute indicates a declaration’s life cycle relative to certain platforms and operating systems. Today’s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form approach.<br>Motivation<br></p><p>When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>@available(iOS, unavailable)<br>@available(tvOS, unavailable)<br>@available(watchOS, unavailable)<br>@available(OSX 10.8, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn’t specified, then the attribute defaults to available.<br>Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>Proposal<br></p><p>Implement an @restricted attribute which is the inverse of @available. The effect would be that the compiler would use @restricted to limit the declaration to be available on the platform(s) specified in the attribute. Similar to @available, multiple @restricted attributes can be added to a declaration. <br>Therefore, where @restricted attribute(s) are present and target platform is not specified, the declaration is not available on the unspecified target platform. In addition, where a @restricted attribute has been applied to a declaration, it should not be commingled with @available on the same declaration (it would lead to intense confusion).<br>Design<br></p><p>From a syntax perspective, it would follow @available:<br>@restricted(platform name version number, *)<br>or<br>@restricted(platform name, introduced=version number)<br>Similarly, all @available arguments would be available to @restricted. <br>Examples<br></p><p>Using the previous example, instead of using @available to specify unavailability, we use @restricted to scope the declarations availability:<br>Single Platform Restriction<br>@restricted(OSX 10.8, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: only available on OS X 10.8 or newer.<br>Multiple Platform Restriction<br>@restricted(OSX 10.8, iOS 9.4, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OSX 10.8 or newer, and iOS 9.4 or newer.<br>Restricted within Version Bounds<br>@restricted(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OS X from 10.8 through 10.11 only.<br>Restricted with Renamed Case<br>// Initial Release<br>@restricted(OSX 10.10, *)<br>case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br></p><p>// Second Release<br>@restricted(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;)<br>case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br></p><p>@restricted(OSX 10.11) case Weibo = &quot;com.apple.social.weibo&quot;<br>Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>Benefits &amp; Impact on existing code<br></p><p>@restricted has the benefit of reducing the amount code while maintaining clarity of purpose: it is obvious based on the attribute name what the intent is. <br>@restricted is purely additive, and therefore has no impact on existing code that makes use of @available. <br>Alternatives<br></p><p>An alternative, though not a strict replacement of @restricted, could be to extract the unavailableargument and use it as an attribute (@unavailable). In use:<br>@available(OSX 10.8, *)<br>@unavailable(iOS, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OS X but not iOS.<br>@unavailable is worthy of further discussion as using an unavailable argument inside an @availableattribute seems counterintuitive. <br>However, this proposal is limited to the consideration of @restricted.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/782d0789/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3138 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/782d0789/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>With the alternatives, I&#39;d mention @deprecated as well.<br></p><p>Charlie<br></p><p>&gt; On May 26, 2016, at 3:25 PM, Stuart Breckenridge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ADD AN @RESTRICTED DECLARATION ATTRIBUTE<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Stuart Breckenridge<br>&gt; Status: DRAFT<br>&gt; Review Manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt; The @available attribute indicates a declaration’s life cycle relative to certain platforms and operating systems. Today’s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>&gt; In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form approach.<br>&gt; Motivation<br>&gt; <br>&gt; When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>&gt; @available(iOS, unavailable)<br>&gt; @available(tvOS, unavailable)<br>&gt; @available(watchOS, unavailable)<br>&gt; @available(OSX 10.8, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn’t specified, then the attribute defaults to available.<br>&gt; Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>&gt; Proposal<br>&gt; <br>&gt; Implement an @restricted attribute which is the inverse of @available. The effect would be that the compiler would use @restricted to limit the declaration to be available on the platform(s) specified in the attribute. Similar to @available, multiple @restricted attributes can be added to a declaration. <br>&gt; Therefore, where @restricted attribute(s) are present and target platform is not specified, the declaration is not available on the unspecified target platform. In addition, where a @restricted attribute has been applied to a declaration, it should not be commingled with @available on the same declaration (it would lead to intense confusion).<br>&gt; Design<br>&gt; <br>&gt; From a syntax perspective, it would follow @available:<br>&gt; @restricted(platform name version number, *)<br>&gt; or<br>&gt; @restricted(platform name, introduced=version number)<br>&gt; Similarly, all @available arguments would be available to @restricted. <br>&gt; Examples<br>&gt; <br>&gt; Using the previous example, instead of using @available to specify unavailability, we use @restricted to scope the declarations availability:<br>&gt; Single Platform Restriction<br>&gt; @restricted(OSX 10.8, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: only available on OS X 10.8 or newer.<br>&gt; Multiple Platform Restriction<br>&gt; @restricted(OSX 10.8, iOS 9.4, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.4 or newer.<br>&gt; Restricted within Version Bounds<br>&gt; @restricted(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt; Restricted with Renamed Case<br>&gt; // Initial Release<br>&gt; @restricted(OSX 10.10, *)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt; <br>&gt; // Second Release<br>&gt; @restricted(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt; <br>&gt; @restricted(OSX 10.11) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt; Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>&gt; Benefits &amp; Impact on existing code<br>&gt; <br>&gt; @restricted has the benefit of reducing the amount code while maintaining clarity of purpose: it is obvious based on the attribute name what the intent is. <br>&gt; @restricted is purely additive, and therefore has no impact on existing code that makes use of @available. <br>&gt; Alternatives<br>&gt; <br>&gt; An alternative, though not a strict replacement of @restricted, could be to extract the unavailableargument and use it as an attribute (@unavailable). In use:<br>&gt; @available(OSX 10.8, *)<br>&gt; @unavailable(iOS, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OS X but not iOS.<br>&gt; @unavailable is worthy of further discussion as using an unavailable argument inside an @availableattribute seems counterintuitive. <br>&gt; However, this proposal is limited to the consideration of @restricted.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/99a77e16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I thought about including @deprecated as an alternative, but it needs some addition tweaking outside of @unavailable and @restricted.<br></p><p>For example, would arguments like introduced and obsoleted still be available for use, or would they need to be separated out? <br></p><p>@introduced(iOS 9.0)<br>@deprecated(iOS 9.1, message=&quot;Use a.n.other protocol&quot;)<br>@obsoleted(iOS 9.2, message=&quot;Use a.n.other protocol&quot;)<br>protocol MyProtocol { }<br></p><p>I think @unavailable and @restricted lend themselves to the existing syntax.<br></p><p>Stuart <br></p><p>&gt; On 26 May 2016, at 21:48, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; With the alternatives, I&#39;d mention @deprecated as well.<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt;&gt; On May 26, 2016, at 3:25 PM, Stuart Breckenridge via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ADD AN @RESTRICTED DECLARATION ATTRIBUTE<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Stuart Breckenridge<br>&gt;&gt; Status: DRAFT<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt;&gt; The @available attribute indicates a declaration’s life cycle relative to certain platforms and operating systems. Today’s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>&gt;&gt; In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form approach.<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>&gt;&gt; @available(iOS, unavailable)<br>&gt;&gt; @available(tvOS, unavailable)<br>&gt;&gt; @available(watchOS, unavailable)<br>&gt;&gt; @available(OSX 10.8, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn’t specified, then the attribute defaults to available.<br>&gt;&gt; Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>&gt;&gt; Proposal<br>&gt;&gt; <br>&gt;&gt; Implement an @restricted attribute which is the inverse of @available. The effect would be that the compiler would use @restricted to limit the declaration to be available on the platform(s) specified in the attribute. Similar to @available, multiple @restricted attributes can be added to a declaration. <br>&gt;&gt; Therefore, where @restricted attribute(s) are present and target platform is not specified, the declaration is not available on the unspecified target platform. In addition, where a @restricted attribute has been applied to a declaration, it should not be commingled with @available on the same declaration (it would lead to intense confusion).<br>&gt;&gt; Design<br>&gt;&gt; <br>&gt;&gt; From a syntax perspective, it would follow @available:<br>&gt;&gt; @restricted(platform name version number, *)<br>&gt;&gt; or<br>&gt;&gt; @restricted(platform name, introduced=version number)<br>&gt;&gt; Similarly, all @available arguments would be available to @restricted. <br>&gt;&gt; Examples<br>&gt;&gt; <br>&gt;&gt; Using the previous example, instead of using @available to specify unavailability, we use @restricted to scope the declarations availability:<br>&gt;&gt; Single Platform Restriction<br>&gt;&gt; @restricted(OSX 10.8, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: only available on OS X 10.8 or newer.<br>&gt;&gt; Multiple Platform Restriction<br>&gt;&gt; @restricted(OSX 10.8, iOS 9.4, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.4 or newer.<br>&gt;&gt; Restricted within Version Bounds<br>&gt;&gt; @restricted(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt;&gt; Restricted with Renamed Case<br>&gt;&gt; // Initial Release<br>&gt;&gt; @restricted(OSX 10.10, *)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt; <br>&gt;&gt; // Second Release<br>&gt;&gt; @restricted(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt; <br>&gt;&gt; @restricted(OSX 10.11) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt;&gt; Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>&gt;&gt; Benefits &amp; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; @restricted has the benefit of reducing the amount code while maintaining clarity of purpose: it is obvious based on the attribute name what the intent is. <br>&gt;&gt; @restricted is purely additive, and therefore has no impact on existing code that makes use of @available. <br>&gt;&gt; Alternatives<br>&gt;&gt; <br>&gt;&gt; An alternative, though not a strict replacement of @restricted, could be to extract the unavailableargument and use it as an attribute (@unavailable). In use:<br>&gt;&gt; @available(OSX 10.8, *)<br>&gt;&gt; @unavailable(iOS, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OS X but not iOS.<br>&gt;&gt; @unavailable is worthy of further discussion as using an unavailable argument inside an @availableattribute seems counterintuitive. <br>&gt;&gt; However, this proposal is limited to the consideration of @restricted.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/52cb5baa/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3138 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/52cb5baa/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Do we then need @restricted? It could be done like this using @available:<br></p><p>@available(only OS X 10.9, iOS 9.1, message=&quot;123&quot;)<br>@available(restricted OS X 10.9)<br>@available(OS X 10.9, restricted)<br></p><p>It would make sense either to split all the availability annotations (deprecated, unavailable, ...), or make the restricted somehow part of @available.<br></p><p>&gt; On May 26, 2016, at 4:14 PM, Stuart Breckenridge &lt;stuart.breckenridge at icloud.com&gt; wrote:<br>&gt; <br>&gt; I thought about including @deprecated as an alternative, but it needs some addition tweaking outside of @unavailable and @restricted.<br>&gt; <br>&gt; For example, would arguments like introduced and obsoleted still be available for use, or would they need to be separated out? <br>&gt; <br>&gt; @introduced(iOS 9.0)<br>&gt; @deprecated(iOS 9.1, message=&quot;Use a.n.other protocol&quot;)<br>&gt; @obsoleted(iOS 9.2, message=&quot;Use a.n.other protocol&quot;)<br>&gt; protocol MyProtocol { }<br>&gt; <br>&gt; I think @unavailable and @restricted lend themselves to the existing syntax.<br>&gt; <br>&gt; Stuart <br>&gt; <br>&gt;&gt; On 26 May 2016, at 21:48, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; With the alternatives, I&#39;d mention @deprecated as well.<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 3:25 PM, Stuart Breckenridge via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ADD AN @RESTRICTED DECLARATION ATTRIBUTE<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author: Stuart Breckenridge<br>&gt;&gt;&gt; Status: DRAFT<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt;&gt;&gt; The @available attribute indicates a declaration’s life cycle relative to certain platforms and operating systems. Today’s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>&gt;&gt;&gt; In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form approach.<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>&gt;&gt;&gt; @available(iOS, unavailable)<br>&gt;&gt;&gt; @available(tvOS, unavailable)<br>&gt;&gt;&gt; @available(watchOS, unavailable)<br>&gt;&gt;&gt; @available(OSX 10.8, *)<br>&gt;&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;&gt; The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn’t specified, then the attribute defaults to available.<br>&gt;&gt;&gt; Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>&gt;&gt;&gt; Proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implement an @restricted attribute which is the inverse of @available. The effect would be that the compiler would use @restricted to limit the declaration to be available on the platform(s) specified in the attribute. Similar to @available, multiple @restricted attributes can be added to a declaration. <br>&gt;&gt;&gt; Therefore, where @restricted attribute(s) are present and target platform is not specified, the declaration is not available on the unspecified target platform. In addition, where a @restricted attribute has been applied to a declaration, it should not be commingled with @available on the same declaration (it would lead to intense confusion).<br>&gt;&gt;&gt; Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From a syntax perspective, it would follow @available:<br>&gt;&gt;&gt; @restricted(platform name version number, *)<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; @restricted(platform name, introduced=version number)<br>&gt;&gt;&gt; Similarly, all @available arguments would be available to @restricted. <br>&gt;&gt;&gt; Examples<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using the previous example, instead of using @available to specify unavailability, we use @restricted to scope the declarations availability:<br>&gt;&gt;&gt; Single Platform Restriction<br>&gt;&gt;&gt; @restricted(OSX 10.8, *)<br>&gt;&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;&gt; Effect: only available on OS X 10.8 or newer.<br>&gt;&gt;&gt; Multiple Platform Restriction<br>&gt;&gt;&gt; @restricted(OSX 10.8, iOS 9.4, *)<br>&gt;&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.4 or newer.<br>&gt;&gt;&gt; Restricted within Version Bounds<br>&gt;&gt;&gt; @restricted(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt;&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt;&gt;&gt; Restricted with Renamed Case<br>&gt;&gt;&gt; // Initial Release<br>&gt;&gt;&gt; @restricted(OSX 10.10, *)<br>&gt;&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Second Release<br>&gt;&gt;&gt; @restricted(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;)<br>&gt;&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @restricted(OSX 10.11) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt;&gt;&gt; Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>&gt;&gt;&gt; Benefits &amp; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @restricted has the benefit of reducing the amount code while maintaining clarity of purpose: it is obvious based on the attribute name what the intent is. <br>&gt;&gt;&gt; @restricted is purely additive, and therefore has no impact on existing code that makes use of @available. <br>&gt;&gt;&gt; Alternatives<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative, though not a strict replacement of @restricted, could be to extract the unavailableargument and use it as an attribute (@unavailable). In use:<br>&gt;&gt;&gt; @available(OSX 10.8, *)<br>&gt;&gt;&gt; @unavailable(iOS, *)<br>&gt;&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;&gt; Effect: Available on OS X but not iOS.<br>&gt;&gt;&gt; @unavailable is worthy of further discussion as using an unavailable argument inside an @availableattribute seems counterintuitive. <br>&gt;&gt;&gt; However, this proposal is limited to the consideration of @restricted.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/4001eac0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; @available(OS X 10.9, restricted)<br></p><p>Personally, I would prefer something like this, perhaps spelled:<br></p><p>	@available(OS X 10.9, only)<br></p><p>When using shorthand form, you would have to write either `*` or `only` as the last element. `*` means &quot;and any other platforms&quot;, while `only` means &quot;only the listed platforms&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>On reflection, I think the introduction of a new argument to limit platform scope is superior — one less attribute to know about.<br></p><p>I&#39;ve revised the proposal draft: https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md&gt; and would welcome further comments.<br></p><p>Add An only Declaration Argument<br></p><p>Proposal: SE-NNNN<br>Author: Stuart Breckenridge<br>Status: DRAFT<br>Review Manager: TBD<br> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#introduction&gt;Introduction<br></p><p>Adapted from the Swift 2.2 Programming Guide:<br></p><p>The @available attribute indicates a declaration&#39;s life cycle relative to certain platforms and operating systems. Today&#39;s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form @available approach. <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#motivation&gt;Motivation<br></p><p>When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br></p><p>@available(iOS, unavailable)<br>@available(tvOS, unavailable)<br>@available(watchOS, unavailable)<br>@available(OSX, introduced=10.8)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn&#39;t specified, then the attribute defaults to available.<br></p><p>Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#proposal&gt;Proposal<br></p><p>Implement an only attribute argument. The effect would be that the compiler would use only to limit the declaration to be available on the target platform(s) specified in the attribute. Similar to existing @available attributes, multiple platforms can be specified in an single declaration and multiple @available attributes can applied to a single declaration. <br></p><p>Therefore, where only arguments(s) are present and the target platform is not specified, the declaration is not available on the unspecified target platform(s). <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#design&gt;Design<br></p><p>From a design perspective, only would be a new argument for use with @available. It would replace the trailing * that denotes all other platforms: only and * cannot be used on the same declaration. <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#syntnax&gt;Syntnax<br></p><p>@available(platform name version number, only) or @available(platform name, introduced=version number, only)<br></p><p>No changes would be required to other @available arguments. <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#examples&gt;Examples<br></p><p>Using the previous example, we use only to scope the declarations availability:<br></p><p>Single Platform Restriction<br></p><p>@available(OSX 10.8, only)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: only available on OS X 10.8 or newer.<br></p><p>Multiple Platform Restriction<br></p><p>@available(OSX 10.8, only)<br>@available(iOS 9.3, only)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OSX 10.8 or newer, and iOS 9.3 or newer.<br></p><p>Restricted within Version Bounds<br></p><p>@available(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OS X from 10.8 through 10.11 only.<br></p><p>Restricted with Renamed Case<br></p><p>// Initial Release<br>@available(OSX 10.10, only)<br>case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br></p><p>// Second Release<br>@available(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;, only)<br>case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br></p><p>@available(OSX 10.11, only) case Weibo = &quot;com.apple.social.weibo&quot;<br>Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br></p><p>Illegal Usage<br></p><p>@available(OSX 10.8, only)<br>@available(iOS 9.3, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Reason: * and only are mutually exclusive. <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#benefits--impact-on-existing-code&gt;Benefits &amp; Impact on existing code<br></p><p>only has the benefit of reducing the amount of attribute code, while maintaining clarity of purpose: it is obvious based on the argument name what the intent is. <br></p><p>only is purely additive, and therefore has no impact on existing declarations that make use of @available. <br></p><p> &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#alternatives&gt;Alternatives<br></p><p>An alternative considered was the introduction of an @restricted attribute that would be used in place of @available. In use:<br></p><p>@restricted(OSX 10.8, *)<br>case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>Effect: Available on OS X 10.8 and newer.<br></p><p>@restricted and only achieve the same goal of providing a simple way of scoping a declaration&#39;s availability to specific platform(s) while reducing the amount of code required to do so. The general feedback from the initial proprosal was that an introduction of a new argument (only) was preferred over the introduction of a new attribute @restricted.<br></p><p><br></p><p><br></p><p><br>&gt; On 27 May 2016, at 05:14, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; @available(OS X 10.9, restricted)<br>&gt; <br>&gt; Personally, I would prefer something like this, perhaps spelled:<br>&gt; <br>&gt; 	@available(OS X 10.9, only)<br>&gt; <br>&gt; When using shorthand form, you would have to write either `*` or `only` as the last element. `*` means &quot;and any other platforms&quot;, while `only` means &quot;only the listed platforms&quot;.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b5e59615/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3138 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b5e59615/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, May 26, 2016 at 7:37 PM, Stuart Breckenridge via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On reflection, I think the introduction of a new argument to limit<br>&gt; platform scope is superior — one less attribute to know about.<br>&gt;<br>&gt; I&#39;ve revised the proposal draft:<br>&gt; https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md and<br>&gt; would welcome further comments.<br>&gt;<br>&gt; Add An only Declaration Argument<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Stuart Breckenridge<br>&gt;    - Status: DRAFT<br>&gt;    - Review Manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt;<br>&gt; The @available attribute indicates a declaration&#39;s life cycle relative to<br>&gt; certain platforms and operating systems. Today&#39;s functionality allows you<br>&gt; to add multiple @available attributes on a declaration to specify its<br>&gt; availability on different platforms.<br>&gt;<br>&gt; In a related Swift Evolution discussion examining the @available attribute,<br>&gt; it was confirmed that there is currently no way to limit availability to<br>&gt; specific platform without using the long form @available approach.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; When a declaration is only available on a certain platform, it requires<br>&gt; multiple @available attributes to restrict its availability to that<br>&gt; platform. Consider the following example using SLServiceType like<br>&gt; constants:<br>&gt;<br>&gt; @available(iOS, unavailable)<br>&gt; @available(tvOS, unavailable)<br>&gt; @available(watchOS, unavailable)<br>&gt; @available(OSX, introduced=10.8)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; The compiler will only use an @available attribute when the attribute<br>&gt; specifies a platform that matches the current target platform. The<br>&gt; implication being that if the target platform isn&#39;t specified, then the<br>&gt; attribute defaults to available.<br>&gt;<br>&gt; Thus, while it is clear that the above is restricting availability to OS X<br>&gt; 10.8 and later, it is verbose and can be simplified.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#proposal&gt;<br>&gt; Proposal<br>&gt;<br>&gt; Implement an only attribute argument. The effect would be that the<br>&gt; compiler would use only to limit the declaration to be available on the<br>&gt; target platform(s) specified in the attribute. Similar to existing<br>&gt; @available attributes, multiple platforms can be specified in an single<br>&gt; declaration and multiple @available attributes can applied to a single<br>&gt; declaration.<br>&gt;<br>&gt; Therefore, where only arguments(s) are present and the target platform *is<br>&gt; not* specified, the declaration is not available on the unspecified<br>&gt; target platform(s).<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#design&gt;<br>&gt; Design<br>&gt;<br>&gt; From a design perspective, only would be a new argument for use with<br>&gt; @available. It would replace the trailing * that denotes all other<br>&gt; platforms: only and * cannot be used on the same declaration.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#syntnax&gt;<br>&gt; Syntnax<br>&gt;<br>&gt; @available(platform name version number, only) or @available(platform name<br>&gt; , introduced=version number, only)<br>&gt;<br>&gt; No changes would be required to other @available arguments.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#examples&gt;<br>&gt; Examples<br>&gt;<br>&gt; Using the previous example, we use only to scope the declarations<br>&gt; availability:<br>&gt;<br>&gt; *Single Platform Restriction*<br>&gt;<br>&gt; @available(OSX 10.8, only)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; Effect: only available on OS X 10.8 or newer.<br>&gt;<br>&gt; *Multiple Platform Restriction*<br>&gt;<br>&gt; @available(OSX 10.8, only)<br>&gt; @available(iOS 9.3, only)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.3 or newer.<br>&gt;<br>&gt; *Restricted within Version Bounds*<br>&gt;<br>&gt; @available(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt;<br>&gt; *Restricted with Renamed Case*<br>&gt;<br>&gt; // Initial Release<br>&gt; @available(OSX 10.10, only)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;<br>&gt; // Second Release<br>&gt; @available(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;, only)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;<br>&gt; @available(OSX 10.11, only) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt;<br>&gt; Effect: Initial release case is restricted to 10.10 and newer; second<br>&gt; release has the original case deprecated from 10.11, with a new case<br>&gt; introduced which is available on OS X 10.11 and newer only.<br>&gt;<br>&gt; *Illegal Usage*<br>&gt;<br>&gt; @available(OSX 10.8, only)<br>&gt; @available(iOS 9.3, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; Reason: * and only are mutually exclusive.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#benefits--impact-on-existing-code&gt;Benefits<br>&gt; &amp; Impact on existing code<br>&gt;<br>&gt; only has the benefit of reducing the amount of attribute code, while<br>&gt; maintaining clarity of purpose: it is obvious based on the argument name<br>&gt; what the intent is.<br>&gt;<br>I see what you&#39;re going for, but it is not at all obvious what the word<br>&quot;only&quot; means. In fact, the intuitive interpretation of `@available(OSX<br>10.8, only)` is that &quot;only&quot; applies to the version number and not the<br>platform--i.e. the feature is available only in OS X 10.8 and not in<br>earlier or later versions; that interpretation is only reinforced by your<br>proposed syntax allowing &quot;only&quot; to be written multiple times, once for each<br>platform. The only intuitive interpretation of `@available(OSX 10.8, only)`<br>followed by `@available(iOS 9.3, only)` is that the feature is available<br>only in version 10.8 of OS X and only in version 9.3 of iOS, not that you<br>are restricting availability on other platforms. By contrast, the current<br>syntax is verbose but unambiguous.<br></p><p><br>&gt; only is purely additive, and therefore has no impact on existing<br>&gt; declarations that make use of @available.<br>&gt;<br>&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#alternatives&gt;<br>&gt; Alternatives<br>&gt;<br>&gt; An alternative considered was the introduction of an @restricted attribute<br>&gt; that would be used in place of @available. In use:<br>&gt;<br>&gt; @restricted(OSX 10.8, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;<br>&gt; Effect: Available on OS X 10.8 and newer.<br>&gt; @restricted and only achieve the same goal of providing a simple way of<br>&gt; scoping a declaration&#39;s availability to specific platform(s) while reducing<br>&gt; the amount of code required to do so. The general feedback from the initial<br>&gt; proprosal was that an introduction of a new argument (only) was preferred<br>&gt; over the introduction of a new attribute @restricted.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 27 May 2016, at 05:14, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; @available(OS X 10.9, restricted)<br>&gt;<br>&gt;<br>&gt; Personally, I would prefer something like this, perhaps spelled:<br>&gt;<br>&gt; @available(OS X 10.9, only)<br>&gt;<br>&gt; When using shorthand form, you would have to write either `*` or `only` as<br>&gt; the last element. `*` means &quot;and any other platforms&quot;, while `only` means<br>&gt; &quot;only the listed platforms&quot;.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/a863db1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>I disagree. If you look the S<br>wift 2.2 guide:<br></p><p>&quot;You can also use an asterisk (*) to indicate availability of the declaration on all of the platform names listed above.&quot;<br></p><p>What this proposal would add is:<br></p><p>&quot;Alternatively, you can use the word &#39;only&#39; to indicate that the declaration is only available on the platform name(s) listed in the attribute.&quot;<br></p><p>Sent from my iPhone<br></p><p>&gt; On 27 May 2016, at 09:09, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 7:37 PM, Stuart Breckenridge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On reflection, I think the introduction of a new argument to limit platform scope is superior — one less attribute to know about.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve revised the proposal draft: https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md and would welcome further comments.<br>&gt;&gt; <br>&gt;&gt; Add An only Declaration Argument<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Stuart Breckenridge<br>&gt;&gt; Status: DRAFT<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt;&gt; <br>&gt;&gt; The @available attribute indicates a declaration&#39;s life cycle relative to certain platforms and operating systems. Today&#39;s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>&gt;&gt; In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form @available approach. <br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>&gt;&gt; <br>&gt;&gt; @available(iOS, unavailable)<br>&gt;&gt; @available(tvOS, unavailable)<br>&gt;&gt; @available(watchOS, unavailable)<br>&gt;&gt; @available(OSX, introduced=10.8)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn&#39;t specified, then the attribute defaults to available.<br>&gt;&gt; <br>&gt;&gt; Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>&gt;&gt; <br>&gt;&gt; Proposal<br>&gt;&gt; <br>&gt;&gt; Implement an only attribute argument. The effect would be that the compiler would use only to limit the declaration to be available on the target platform(s) specified in the attribute. Similar to existing @available attributes, multiple platforms can be specified in an single declaration and multiple @available attributes can applied to a single declaration. <br>&gt;&gt; <br>&gt;&gt; Therefore, where only arguments(s) are present and the target platform is not specified, the declaration is not available on the unspecified target platform(s). <br>&gt;&gt; <br>&gt;&gt; Design<br>&gt;&gt; <br>&gt;&gt; From a design perspective, only would be a new argument for use with @available. It would replace the trailing * that denotes all other platforms: only and * cannot be used on the same declaration. <br>&gt;&gt; <br>&gt;&gt; Syntnax<br>&gt;&gt; <br>&gt;&gt; @available(platform name version number, only) or @available(platform name, introduced=version number, only)<br>&gt;&gt; <br>&gt;&gt; No changes would be required to other @available arguments. <br>&gt;&gt; <br>&gt;&gt; Examples<br>&gt;&gt; <br>&gt;&gt; Using the previous example, we use only to scope the declarations availability:<br>&gt;&gt; <br>&gt;&gt; Single Platform Restriction<br>&gt;&gt; <br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: only available on OS X 10.8 or newer.<br>&gt;&gt; <br>&gt;&gt; Multiple Platform Restriction<br>&gt;&gt; <br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; @available(iOS 9.3, only)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.3 or newer.<br>&gt;&gt; <br>&gt;&gt; Restricted within Version Bounds<br>&gt;&gt; <br>&gt;&gt; @available(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt;&gt; <br>&gt;&gt; Restricted with Renamed Case<br>&gt;&gt; <br>&gt;&gt; // Initial Release<br>&gt;&gt; @available(OSX 10.10, only)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt; <br>&gt;&gt; // Second Release<br>&gt;&gt; @available(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;, only)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt; <br>&gt;&gt; @available(OSX 10.11, only) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt;&gt; Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>&gt;&gt; <br>&gt;&gt; Illegal Usage<br>&gt;&gt; <br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; @available(iOS 9.3, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Reason: * and only are mutually exclusive. <br>&gt;&gt; <br>&gt;&gt; Benefits &amp; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; only has the benefit of reducing the amount of attribute code, while maintaining clarity of purpose: it is obvious based on the argument name what the intent is. <br>&gt;&gt; <br>&gt; I see what you&#39;re going for, but it is not at all obvious what the word &quot;only&quot; means. In fact, the intuitive interpretation of `@available(OSX 10.8, only)` is that &quot;only&quot; applies to the version number and not the platform--i.e. the feature is available only in OS X 10.8 and not in earlier or later versions; that interpretation is only reinforced by your proposed syntax allowing &quot;only&quot; to be written multiple times, once for each platform. The only intuitive interpretation of `@available(OSX 10.8, only)` followed by `@available(iOS 9.3, only)` is that the feature is available only in version 10.8 of OS X and only in version 9.3 of iOS, not that you are restricting availability on other platforms. By contrast, the current syntax is verbose but unambiguous.<br>&gt;  <br>&gt;&gt; only is purely additive, and therefore has no impact on existing declarations that make use of @available. <br>&gt;&gt; <br>&gt;&gt; Alternatives<br>&gt;&gt; <br>&gt;&gt; An alternative considered was the introduction of an @restricted attribute that would be used in place of @available. In use:<br>&gt;&gt; <br>&gt;&gt; @restricted(OSX 10.8, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt; Effect: Available on OS X 10.8 and newer.<br>&gt;&gt; <br>&gt;&gt; @restricted and only achieve the same goal of providing a simple way of scoping a declaration&#39;s availability to specific platform(s) while reducing the amount of code required to do so. The general feedback from the initial proprosal was that an introduction of a new argument (only) was preferred over the introduction of a new attribute @restricted.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 May 2016, at 05:14, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @available(OS X 10.9, restricted)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I would prefer something like this, perhaps spelled:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OS X 10.9, only)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When using shorthand form, you would have to write either `*` or `only` as the last element. `*` means &quot;and any other platforms&quot;, while `only` means &quot;only the listed platforms&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/16b8129f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4005 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/16b8129f/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, May 26, 2016 at 8:37 PM, Stuart Breckenridge &lt;<br>stuart.breckenridge at icloud.com&gt; wrote:<br></p><p>&gt; I disagree. If you look the S<br>&gt; wift 2.2 guide:<br>&gt;<br>&gt; &quot;You can also use an asterisk (*) to indicate availability of the<br>&gt; declaration on all of the platform names listed above.&quot;<br>&gt;<br>&gt; What this proposal would add is:<br>&gt;<br>&gt; &quot;Alternatively, you can use the word &#39;only&#39; to indicate that the<br>&gt; declaration is only available on the platform name(s) listed in the<br>&gt; attribute.&quot;<br>&gt;<br></p><p><br>We&#39;ll leave aside that the asterisk isn&#39;t exactly intuitive in the first<br>place.<br></p><p>What I&#39;m saying here is that even if you accept that the asterisk means all<br>platforms, it does not follow that another argument in the same place<br>should refer to the platform names *listed in the attribute*. That&#39;s not at<br>all precedented in the meaning of the asterisk.<br></p><p>Furthermore, the asterisk is put after a list of things *only in the<br>shorthand syntax*, whereas you are proposing that &quot;only&quot; should be usable<br>in the full syntax as well, in a position where the asterisk is not<br>allowed. It is something else entirely to say that a feature is available<br>in OSX version so-and-so only and then to say it&#39;s available in iOS version<br>so-and-so only, when in fact you mean that it&#39;s not available *on other<br>platforms*.<br></p><p>What makes more sense to me would be allowing (if it isn&#39;t already allowed)<br>`@available(*, unavailable)` to follow a previous @available declaration in<br>order to mean that the feature is unavailable on all platforms not<br>otherwise specified.<br></p><p><br>Sent from my iPhone<br>&gt;<br>&gt; On 27 May 2016, at 09:09, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, May 26, 2016 at 7:37 PM, Stuart Breckenridge via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On reflection, I think the introduction of a new argument to limit<br>&gt;&gt; platform scope is superior — one less attribute to know about.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve revised the proposal draft:<br>&gt;&gt; https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md and<br>&gt;&gt; would welcome further comments.<br>&gt;&gt;<br>&gt;&gt; Add An only Declaration Argument<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    - Author: Stuart Breckenridge<br>&gt;&gt;    - Status: DRAFT<br>&gt;&gt;    - Review Manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt;&gt;<br>&gt;&gt; The @available attribute indicates a declaration&#39;s life cycle relative<br>&gt;&gt; to certain platforms and operating systems. Today&#39;s functionality allows<br>&gt;&gt; you to add multiple @available attributes on a declaration to specify<br>&gt;&gt; its availability on different platforms.<br>&gt;&gt;<br>&gt;&gt; In a related Swift Evolution discussion examining the @available attribute,<br>&gt;&gt; it was confirmed that there is currently no way to limit availability to<br>&gt;&gt; specific platform without using the long form @available approach.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; When a declaration is only available on a certain platform, it requires<br>&gt;&gt; multiple @available attributes to restrict its availability to that<br>&gt;&gt; platform. Consider the following example using SLServiceType like<br>&gt;&gt; constants:<br>&gt;&gt;<br>&gt;&gt; @available(iOS, unavailable)<br>&gt;&gt; @available(tvOS, unavailable)<br>&gt;&gt; @available(watchOS, unavailable)<br>&gt;&gt; @available(OSX, introduced=10.8)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; The compiler will only use an @available attribute when the attribute<br>&gt;&gt; specifies a platform that matches the current target platform. The<br>&gt;&gt; implication being that if the target platform isn&#39;t specified, then the<br>&gt;&gt; attribute defaults to available.<br>&gt;&gt;<br>&gt;&gt; Thus, while it is clear that the above is restricting availability to OS<br>&gt;&gt; X 10.8 and later, it is verbose and can be simplified.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#proposal&gt;<br>&gt;&gt; Proposal<br>&gt;&gt;<br>&gt;&gt; Implement an only attribute argument. The effect would be that the<br>&gt;&gt; compiler would use only to limit the declaration to be available on the<br>&gt;&gt; target platform(s) specified in the attribute. Similar to existing<br>&gt;&gt; @available attributes, multiple platforms can be specified in an single<br>&gt;&gt; declaration and multiple @available attributes can applied to a single<br>&gt;&gt; declaration.<br>&gt;&gt;<br>&gt;&gt; Therefore, where only arguments(s) are present and the target platform *is<br>&gt;&gt; not* specified, the declaration is not available on the unspecified<br>&gt;&gt; target platform(s).<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#design&gt;<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; From a design perspective, only would be a new argument for use with<br>&gt;&gt; @available. It would replace the trailing * that denotes all other<br>&gt;&gt; platforms: only and * cannot be used on the same declaration.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#syntnax&gt;<br>&gt;&gt; Syntnax<br>&gt;&gt;<br>&gt;&gt; @available(platform name version number, only) or @available(platform<br>&gt;&gt; name, introduced=version number, only)<br>&gt;&gt;<br>&gt;&gt; No changes would be required to other @available arguments.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#examples&gt;<br>&gt;&gt; Examples<br>&gt;&gt;<br>&gt;&gt; Using the previous example, we use only to scope the declarations<br>&gt;&gt; availability:<br>&gt;&gt;<br>&gt;&gt; *Single Platform Restriction*<br>&gt;&gt;<br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; Effect: only available on OS X 10.8 or newer.<br>&gt;&gt;<br>&gt;&gt; *Multiple Platform Restriction*<br>&gt;&gt;<br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; @available(iOS 9.3, only)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.3 or newer.<br>&gt;&gt;<br>&gt;&gt; *Restricted within Version Bounds*<br>&gt;&gt;<br>&gt;&gt; @available(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt;&gt;<br>&gt;&gt; *Restricted with Renamed Case*<br>&gt;&gt;<br>&gt;&gt; // Initial Release<br>&gt;&gt; @available(OSX 10.10, only)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt;<br>&gt;&gt; // Second Release<br>&gt;&gt; @available(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;, only)<br>&gt;&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt;&gt;<br>&gt;&gt; @available(OSX 10.11, only) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt;&gt;<br>&gt;&gt; Effect: Initial release case is restricted to 10.10 and newer; second<br>&gt;&gt; release has the original case deprecated from 10.11, with a new case<br>&gt;&gt; introduced which is available on OS X 10.11 and newer only.<br>&gt;&gt;<br>&gt;&gt; *Illegal Usage*<br>&gt;&gt;<br>&gt;&gt; @available(OSX 10.8, only)<br>&gt;&gt; @available(iOS 9.3, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; Reason: * and only are mutually exclusive.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#benefits--impact-on-existing-code&gt;Benefits<br>&gt;&gt; &amp; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; only has the benefit of reducing the amount of attribute code, while<br>&gt;&gt; maintaining clarity of purpose: it is obvious based on the argument name<br>&gt;&gt; what the intent is.<br>&gt;&gt;<br>&gt; I see what you&#39;re going for, but it is not at all obvious what the word<br>&gt; &quot;only&quot; means. In fact, the intuitive interpretation of `@available(OSX<br>&gt; 10.8, only)` is that &quot;only&quot; applies to the version number and not the<br>&gt; platform--i.e. the feature is available only in OS X 10.8 and not in<br>&gt; earlier or later versions; that interpretation is only reinforced by your<br>&gt; proposed syntax allowing &quot;only&quot; to be written multiple times, once for each<br>&gt; platform. The only intuitive interpretation of `@available(OSX 10.8, only)`<br>&gt; followed by `@available(iOS 9.3, only)` is that the feature is available<br>&gt; only in version 10.8 of OS X and only in version 9.3 of iOS, not that you<br>&gt; are restricting availability on other platforms. By contrast, the current<br>&gt; syntax is verbose but unambiguous.<br>&gt;<br>&gt;<br>&gt;&gt; only is purely additive, and therefore has no impact on existing<br>&gt;&gt; declarations that make use of @available.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/stuartbreckenridge/swift-evolution/blob/master/proposals/NNNN-add-only-declaration-argument.md#alternatives&gt;<br>&gt;&gt; Alternatives<br>&gt;&gt;<br>&gt;&gt; An alternative considered was the introduction of an @restricted attribute<br>&gt;&gt; that would be used in place of @available. In use:<br>&gt;&gt;<br>&gt;&gt; @restricted(OSX 10.8, *)<br>&gt;&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt;&gt;<br>&gt;&gt; Effect: Available on OS X 10.8 and newer.<br>&gt;&gt; @restricted and only achieve the same goal of providing a simple way of<br>&gt;&gt; scoping a declaration&#39;s availability to specific platform(s) while reducing<br>&gt;&gt; the amount of code required to do so. The general feedback from the initial<br>&gt;&gt; proprosal was that an introduction of a new argument (only) was<br>&gt;&gt; preferred over the introduction of a new attribute @restricted.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 27 May 2016, at 05:14, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; @available(OS X 10.9, restricted)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Personally, I would prefer something like this, perhaps spelled:<br>&gt;&gt;<br>&gt;&gt; @available(OS X 10.9, only)<br>&gt;&gt;<br>&gt;&gt; When using shorthand form, you would have to write either `*` or `only`<br>&gt;&gt; as the last element. `*` means &quot;and any other platforms&quot;, while `only`<br>&gt;&gt; means &quot;only the listed platforms&quot;.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b1c84116/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; What I&#39;m saying here is that even if you accept that the asterisk means all platforms, it does not follow that another argument in the same place should refer to the platform names *listed in the attribute*. That&#39;s not at all precedented in the meaning of the asterisk.<br></p><p>The problem is, the most natural way to express this is absolutely this:<br></p><p>	@available(OSX 10.8, iOS 8, *)	// includes other platforms<br>	@available(OSX 10.8, iOS 8)		// excludes other platforms<br></p><p>But we don&#39;t want to do that because we want people to use `*` by default. You could maybe do something like:<br></p><p>	@available(OSX 10.8, iOS 8, * unavailable)<br></p><p>But I think that reads very strangely, and it doesn&#39;t seem consistent with the other parameters. (Well, unless you can write `OSX unavailable`, which would actually be kind of convenient, but would still read oddly in a declaration named `@available`.) Hence my suggestion:<br></p><p>	@available(OSX 10.8, iOS 8, only)<br></p><p>Which is meant to be read as &quot;Available in OS X (starting in 10.8) and iOS (starting in 8) only&quot;.<br></p><p>(It would be nice if the syntax actually said &quot;OSX 10.8+&quot;, and maybe even permitted a range for things that have been retired, like `OSX 10.8..&lt;10.10`. The main problem I see with supporting a range is that the most natural interpretation of the right end is an unavailability version, but the most useful thing to have there would be a deprecation version.)<br></p><p>&gt; Furthermore, the asterisk is put after a list of things *only in the shorthand syntax*, whereas you are proposing that &quot;only&quot; should be usable in the full syntax as well, in a position where the asterisk is not allowed. It is something else entirely to say that a feature is available in OSX version so-and-so only and then to say it&#39;s available in iOS version so-and-so only, when in fact you mean that it&#39;s not available *on other platforms*.<br></p><p>Yes, that was not what I intended when I suggested `only`.<br></p><p>&gt; What makes more sense to me would be allowing (if it isn&#39;t already allowed) `@available(*, unavailable)` to follow a previous @available declaration in order to mean that the feature is unavailable on all platforms not otherwise specified.<br></p><p>Yes, something like this makes sense to me too. Basically, I think the shorthand form should look like:<br></p><p>	@available(OSX 10.8, iOS 9.4, only)<br></p><p>And the longhand form like:<br></p><p>	@available(OSX, introduced: 10.8)<br>	@available(iOS, introduced: 9.4)<br>	@available(*, unavailable)<br></p><p>(The switch from `introduced=` to `introduced:` is an already-approved Swift 3 change.)<br></p><p>Perhaps you should even be required to say either `@available(*)` or `@available(*, unavailable)` if there are longhand `@available` attributes on the type. <br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Are we back in a position where a different attribute (back to @restricted or similar keyword) would clear up the readability concerns?<br></p><p>The current equivalent in @available terms:<br></p><p>Short form:<br>	@available(OSX 10.8, iOS 8.0, *)<br>	@available(tvOS, unavailable)<br>	@available(watchOS, unavailable)<br></p><p>Long form:<br>	@available(OSX, introduced: 10.8, deprecated: 10.10)<br>	@available(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br>	@available(tvOS, unavailable)<br>	@available(watchOS, unavailable)<br></p><p>Short form replacement:<br>	@restricted(OSX 10.8, iOS 8.0) // Restricted to OSX, iOS from 10.8 and 8.0, respectively.<br></p><p>Long form replacement:<br>	@restricted(OSX, introduced: 10.8, deprecated: 10.10)<br>        @restricted(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br></p><p><br>I would amend the draft proposal: * would not be permitted with @restricted. The rationale being that if you are restricting to everything, or marking everything as unavailable, @available(*,unavailable) is a better candidate.<br></p><p>Stuart<br></p><p>&gt; On 27 May 2016, at 11:06, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; What I&#39;m saying here is that even if you accept that the asterisk means all platforms, it does not follow that another argument in the same place should refer to the platform names *listed in the attribute*. That&#39;s not at all precedented in the meaning of the asterisk.<br>&gt; <br>&gt; The problem is, the most natural way to express this is absolutely this:<br>&gt; <br>&gt; 	@available(OSX 10.8, iOS 8, *)	// includes other platforms<br>&gt; 	@available(OSX 10.8, iOS 8)		// excludes other platforms<br>&gt; <br>&gt; But we don&#39;t want to do that because we want people to use `*` by default. You could maybe do something like:<br>&gt; <br>&gt; 	@available(OSX 10.8, iOS 8, * unavailable)<br>&gt; <br>&gt; But I think that reads very strangely, and it doesn&#39;t seem consistent with the other parameters. (Well, unless you can write `OSX unavailable`, which would actually be kind of convenient, but would still read oddly in a declaration named `@available`.) Hence my suggestion:<br>&gt; <br>&gt; 	@available(OSX 10.8, iOS 8, only)<br>&gt; <br>&gt; Which is meant to be read as &quot;Available in OS X (starting in 10.8) and iOS (starting in 8) only&quot;.<br>&gt; <br>&gt; (It would be nice if the syntax actually said &quot;OSX 10.8+&quot;, and maybe even permitted a range for things that have been retired, like `OSX 10.8..&lt;10.10`. The main problem I see with supporting a range is that the most natural interpretation of the right end is an unavailability version, but the most useful thing to have there would be a deprecation version.)<br>&gt; <br>&gt;&gt; Furthermore, the asterisk is put after a list of things *only in the shorthand syntax*, whereas you are proposing that &quot;only&quot; should be usable in the full syntax as well, in a position where the asterisk is not allowed. It is something else entirely to say that a feature is available in OSX version so-and-so only and then to say it&#39;s available in iOS version so-and-so only, when in fact you mean that it&#39;s not available *on other platforms*.<br>&gt; <br>&gt; Yes, that was not what I intended when I suggested `only`.<br>&gt; <br>&gt;&gt; What makes more sense to me would be allowing (if it isn&#39;t already allowed) `@available(*, unavailable)` to follow a previous @available declaration in order to mean that the feature is unavailable on all platforms not otherwise specified.<br>&gt; <br>&gt; Yes, something like this makes sense to me too. Basically, I think the shorthand form should look like:<br>&gt; <br>&gt; 	@available(OSX 10.8, iOS 9.4, only)<br>&gt; <br>&gt; And the longhand form like:<br>&gt; <br>&gt; 	@available(OSX, introduced: 10.8)<br>&gt; 	@available(iOS, introduced: 9.4)<br>&gt; 	@available(*, unavailable)<br>&gt; <br>&gt; (The switch from `introduced=` to `introduced:` is an already-approved Swift 3 change.)<br>&gt; <br>&gt; Perhaps you should even be required to say either `@available(*)` or `@available(*, unavailable)` if there are longhand `@available` attributes on the type. <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/d48d8a69/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3138 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/d48d8a69/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 27, 2016 at 02:00:00am</p></header><div class="content"><p>I dislike `@restricted` for several reasons. First of all, but for a desire<br>for brevity, @available and @restricted would do the same thing. I don&#39;t<br>think that&#39;s justifiable or intuitive. Second, I don&#39;t think it&#39;s at all<br>readable: are the named platforms restricted from using the function, or is<br>the function restricted to those platforms? The name could equally mean<br>either one.<br></p><p>Brent&#39;s suggestion is perfectly cogent:<br></p><p>```<br>@available(OSX, introduced: 10.8)<br>@available(iOS, introduced: 9.4)<br>@available(*, unavailable)<br>```<br></p><p>I would even go so far as to say that neither `only` nor `@restricted` are<br>needed. By that I mean, if you type this:<br></p><p>```<br>@available(OSX 10.8, iOS 9.4)<br>```<br></p><p>That&#39;s not valid. You&#39;ll be prompted to write this:<br></p><p>```<br>@available(OSX 10.8, iOS 9.4, *)<br>```<br></p><p>I&#39;d propose to give the user the additional option of writing this:<br></p><p>```<br>@available(OSX 10.8, iOS 9.4)<br>@available(*, unavailable)<br>```<br></p><p>In other words, the rule for using the @available shorthand would be that<br>you must mention * somewhere; it can be at the end of the shorthand, or it<br>can be on its own line. This would maintain the desired verbosity so that<br>the latter option is not as accessible as the preferred one, but it avoids<br>the recitation of all unavailable platforms currently required.<br></p><p><br>On Thu, May 26, 2016 at 11:59 PM, Stuart Breckenridge &lt;<br>stuart.breckenridge at icloud.com&gt; wrote:<br></p><p>&gt; Are we back in a position where a different attribute (back to @restricted or<br>&gt; similar keyword) would clear up the readability concerns?<br>&gt;<br>&gt; The current equivalent in @available terms:<br>&gt;<br>&gt; Short form:<br>&gt; @available(OSX 10.8, iOS 8.0, *)<br>&gt; @available(tvOS, unavailable)<br>&gt; @available(watchOS, unavailable)<br>&gt;<br>&gt; Long form:<br>&gt; @available(OSX, introduced: 10.8, deprecated: 10.10)<br>&gt; @available(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br>&gt; @available(tvOS, unavailable)<br>&gt; @available(watchOS, unavailable)<br>&gt;<br>&gt; Short form replacement:<br>&gt; @restricted(OSX 10.8, iOS 8.0) // Restricted to OSX, iOS from 10.8 and<br>&gt; 8.0, respectively.<br>&gt;<br>&gt; Long form replacement:<br>&gt; @restricted(OSX, introduced: 10.8, deprecated: 10.10)<br>&gt;         @restricted(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br>&gt;<br>&gt;<br>&gt; I would amend the draft proposal: * would not be permitted with<br>&gt; @restricted. The rationale being that if you are restricting to *everything,<br>&gt; *or marking everything as unavailable, @available(*,unavailable) is a<br>&gt; better candidate.<br>&gt;<br>&gt; Stuart<br>&gt;<br>&gt; On 27 May 2016, at 11:06, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; What I&#39;m saying here is that even if you accept that the asterisk means<br>&gt; all platforms, it does not follow that another argument in the same place<br>&gt; should refer to the platform names *listed in the attribute*. That&#39;s not at<br>&gt; all precedented in the meaning of the asterisk.<br>&gt;<br>&gt;<br>&gt; The problem is, the most natural way to express this is absolutely this:<br>&gt;<br>&gt; @available(OSX 10.8, iOS 8, *) // includes other platforms<br>&gt; @available(OSX 10.8, iOS 8) // excludes other platforms<br>&gt;<br>&gt; But we don&#39;t want to do that because we want people to use `*` by default.<br>&gt; You could maybe do something like:<br>&gt;<br>&gt; @available(OSX 10.8, iOS 8, * unavailable)<br>&gt;<br>&gt; But I think that reads very strangely, and it doesn&#39;t seem consistent with<br>&gt; the other parameters. (Well, unless you can write `OSX unavailable`, which<br>&gt; would actually be kind of convenient, but would still read oddly in a<br>&gt; declaration named `@available`.) Hence my suggestion:<br>&gt;<br>&gt; @available(OSX 10.8, iOS 8, only)<br>&gt;<br>&gt; Which is meant to be read as &quot;Available in OS X (starting in 10.8) and iOS<br>&gt; (starting in 8) only&quot;.<br>&gt;<br>&gt; (It would be nice if the syntax actually said &quot;OSX 10.8+&quot;, and maybe even<br>&gt; permitted a range for things that have been retired, like `OSX<br>&gt; 10.8..&lt;10.10`. The main problem I see with supporting a range is that the<br>&gt; most natural interpretation of the right end is an unavailability version,<br>&gt; but the most useful thing to have there would be a deprecation version.)<br>&gt;<br>&gt; Furthermore, the asterisk is put after a list of things *only in the<br>&gt; shorthand syntax*, whereas you are proposing that &quot;only&quot; should be usable<br>&gt; in the full syntax as well, in a position where the asterisk is not<br>&gt; allowed. It is something else entirely to say that a feature is available<br>&gt; in OSX version so-and-so only and then to say it&#39;s available in iOS version<br>&gt; so-and-so only, when in fact you mean that it&#39;s not available *on other<br>&gt; platforms*.<br>&gt;<br>&gt;<br>&gt; Yes, that was not what I intended when I suggested `only`.<br>&gt;<br>&gt; What makes more sense to me would be allowing (if it isn&#39;t already<br>&gt; allowed) `@available(*, unavailable)` to follow a previous @available<br>&gt; declaration in order to mean that the feature is unavailable on all<br>&gt; platforms not otherwise specified.<br>&gt;<br>&gt;<br>&gt; Yes, something like this makes sense to me too. Basically, I think the<br>&gt; shorthand form should look like:<br>&gt;<br>&gt; @available(OSX 10.8, iOS 9.4, only)<br>&gt;<br>&gt; And the longhand form like:<br>&gt;<br>&gt; @available(OSX, introduced: 10.8)<br>&gt; @available(iOS, introduced: 9.4)<br>&gt; @available(*, unavailable)<br>&gt;<br>&gt; (The switch from `introduced=` to `introduced:` is an already-approved<br>&gt; Swift 3 change.)<br>&gt;<br>&gt; Perhaps you should even be required to say either `@available(*)` or<br>&gt; `@available(*, unavailable)` if there are longhand `@available` attributes<br>&gt; on the type.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/acd83eb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b4cb21e7820c14a4044e4706757da83?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Stuart Breckenridge</string> &lt;stuart.breckenridge at icloud.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Named platforms always take precedence over the *, in essence.  <br></p><p>Sent from my iPad<br></p><p>&gt; On 27 May 2016, at 15:44, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I dislike `@restricted` for several reasons. First of all, but for a desire for brevity, @available and @restricted would do the same thing. I don&#39;t think that&#39;s justifiable or intuitive. Second, I don&#39;t think it&#39;s at all readable: are the named platforms restricted from using the function, or is the function restricted to those platforms? The name could equally mean either one.<br>&gt; <br>&gt; Brent&#39;s suggestion is perfectly cogent:<br>&gt; <br>&gt; ```<br>&gt; @available(OSX, introduced: 10.8)<br>&gt; @available(iOS, introduced: 9.4)<br>&gt; @available(*, unavailable)<br>&gt; ```<br>&gt; <br>&gt; I would even go so far as to say that neither `only` nor `@restricted` are needed. By that I mean, if you type this:<br>&gt; <br>&gt; ```<br>&gt; @available(OSX 10.8, iOS 9.4)<br>&gt; ```<br>&gt; <br>&gt; That&#39;s not valid. You&#39;ll be prompted to write this:<br>&gt; <br>&gt; ```<br>&gt; @available(OSX 10.8, iOS 9.4, *)<br>&gt; ```<br>&gt; <br>&gt; I&#39;d propose to give the user the additional option of writing this:<br>&gt; <br>&gt; ```<br>&gt; @available(OSX 10.8, iOS 9.4)<br>&gt; @available(*, unavailable)<br>&gt; ```<br>&gt; <br>&gt; In other words, the rule for using the @available shorthand would be that you must mention * somewhere; it can be at the end of the shorthand, or it can be on its own line. This would maintain the desired verbosity so that the latter option is not as accessible as the preferred one, but it avoids the recitation of all unavailable platforms currently required.<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 11:59 PM, Stuart Breckenridge &lt;stuart.breckenridge at icloud.com&gt; wrote:<br>&gt;&gt; Are we back in a position where a different attribute (back to @restricted or similar keyword) would clear up the readability concerns?<br>&gt;&gt; <br>&gt;&gt; The current equivalent in @available terms:<br>&gt;&gt; <br>&gt;&gt; Short form:<br>&gt;&gt; 	@available(OSX 10.8, iOS 8.0, *)<br>&gt;&gt; 	@available(tvOS, unavailable)<br>&gt;&gt; 	@available(watchOS, unavailable)<br>&gt;&gt; <br>&gt;&gt; Long form:<br>&gt;&gt; 	@available(OSX, introduced: 10.8, deprecated: 10.10)<br>&gt;&gt; 	@available(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br>&gt;&gt; 	@available(tvOS, unavailable)<br>&gt;&gt; 	@available(watchOS, unavailable)<br>&gt;&gt; <br>&gt;&gt; Short form replacement:<br>&gt;&gt; 	@restricted(OSX 10.8, iOS 8.0) // Restricted to OSX, iOS from 10.8 and 8.0, respectively.<br>&gt;&gt; <br>&gt;&gt; Long form replacement:<br>&gt;&gt; 	@restricted(OSX, introduced: 10.8, deprecated: 10.10)<br>&gt;&gt;         @restricted(iOS, introduced: 8.0, deprecated: 8.4, obsoleted: 9.0)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would amend the draft proposal: * would not be permitted with @restricted. The rationale being that if you are restricting to everything, or marking everything as unavailable, @available(*,unavailable) is a better candidate.<br>&gt;&gt; <br>&gt;&gt; Stuart<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 May 2016, at 11:06, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I&#39;m saying here is that even if you accept that the asterisk means all platforms, it does not follow that another argument in the same place should refer to the platform names *listed in the attribute*. That&#39;s not at all precedented in the meaning of the asterisk.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is, the most natural way to express this is absolutely this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OSX 10.8, iOS 8, *)	// includes other platforms<br>&gt;&gt;&gt; 	@available(OSX 10.8, iOS 8)		// excludes other platforms<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But we don&#39;t want to do that because we want people to use `*` by default. You could maybe do something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OSX 10.8, iOS 8, * unavailable)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I think that reads very strangely, and it doesn&#39;t seem consistent with the other parameters. (Well, unless you can write `OSX unavailable`, which would actually be kind of convenient, but would still read oddly in a declaration named `@available`.) Hence my suggestion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OSX 10.8, iOS 8, only)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which is meant to be read as &quot;Available in OS X (starting in 10.8) and iOS (starting in 8) only&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (It would be nice if the syntax actually said &quot;OSX 10.8+&quot;, and maybe even permitted a range for things that have been retired, like `OSX 10.8..&lt;10.10`. The main problem I see with supporting a range is that the most natural interpretation of the right end is an unavailability version, but the most useful thing to have there would be a deprecation version.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Furthermore, the asterisk is put after a list of things *only in the shorthand syntax*, whereas you are proposing that &quot;only&quot; should be usable in the full syntax as well, in a position where the asterisk is not allowed. It is something else entirely to say that a feature is available in OSX version so-and-so only and then to say it&#39;s available in iOS version so-and-so only, when in fact you mean that it&#39;s not available *on other platforms*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that was not what I intended when I suggested `only`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What makes more sense to me would be allowing (if it isn&#39;t already allowed) `@available(*, unavailable)` to follow a previous @available declaration in order to mean that the feature is unavailable on all platforms not otherwise specified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, something like this makes sense to me too. Basically, I think the shorthand form should look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OSX 10.8, iOS 9.4, only)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the longhand form like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@available(OSX, introduced: 10.8)<br>&gt;&gt;&gt; 	@available(iOS, introduced: 9.4)<br>&gt;&gt;&gt; 	@available(*, unavailable)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (The switch from `introduced=` to `introduced:` is an already-approved Swift 3 change.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps you should even be required to say either `@available(*)` or `@available(*, unavailable)` if there are longhand `@available` attributes on the type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/9ec9aeab/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4005 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/9ec9aeab/attachment.p7s&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[PITCH] ADD AN @RESTRICTED DECLARATION ATTRIBUTE</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>I’m not sure about this, as restricting anything by OS generally makes me uneasy; where possible we should always try to restrict code by availability and version of modules, as these will indicate the actual features that a platform should support. Part of the problem is that we can’t guarantee what new OSes will be supported in future, in your example you’ve already only covered Apple OSes, but Linux support is on its way, and Windows support may come (Visual Studio may already support it).<br></p><p>I mean, it’s no more or less prone to issues than @available I suppose, but I’m not a fan of limiting features and support in this way to begin with.<br></p><p>&gt; On 26 May 2016, at 14:25, Stuart Breckenridge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ADD AN @RESTRICTED DECLARATION ATTRIBUTE<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Stuart Breckenridge<br>&gt; Status: DRAFT<br>&gt; Review Manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Adapted from the Swift 2.2 Programming Guide:<br>&gt; The @available attribute indicates a declaration’s life cycle relative to certain platforms and operating systems. Today’s functionality allows you to add multiple @available attributes on a declaration to specify its availability on different platforms.<br>&gt; In a related Swift Evolution discussion examining the @available attribute, it was confirmed that there is currently no way to limit availability to specific platform without using the long form approach.<br>&gt; Motivation<br>&gt; <br>&gt; When a declaration is only available on a certain platform, it requires multiple @available attributes to restrict its availability to that platform. Consider the following example using SLServiceType like constants:<br>&gt; @available(iOS, unavailable)<br>&gt; @available(tvOS, unavailable)<br>&gt; @available(watchOS, unavailable)<br>&gt; @available(OSX 10.8, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; The compiler will only use an @available attribute when the attribute specifies a platform that matches the current target platform. The implication being that if the target platform isn’t specified, then the attribute defaults to available.<br>&gt; Thus, while it is clear that the above is restricting availability to OS X 10.8 and later, it is verbose and can be simplified.<br>&gt; Proposal<br>&gt; <br>&gt; Implement an @restricted attribute which is the inverse of @available. The effect would be that the compiler would use @restricted to limit the declaration to be available on the platform(s) specified in the attribute. Similar to @available, multiple @restricted attributes can be added to a declaration. <br>&gt; Therefore, where @restricted attribute(s) are present and target platform is not specified, the declaration is not available on the unspecified target platform. In addition, where a @restricted attribute has been applied to a declaration, it should not be commingled with @available on the same declaration (it would lead to intense confusion).<br>&gt; Design<br>&gt; <br>&gt; From a syntax perspective, it would follow @available:<br>&gt; @restricted(platform name version number, *)<br>&gt; or<br>&gt; @restricted(platform name, introduced=version number)<br>&gt; Similarly, all @available arguments would be available to @restricted. <br>&gt; Examples<br>&gt; <br>&gt; Using the previous example, instead of using @available to specify unavailability, we use @restricted to scope the declarations availability:<br>&gt; Single Platform Restriction<br>&gt; @restricted(OSX 10.8, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: only available on OS X 10.8 or newer.<br>&gt; Multiple Platform Restriction<br>&gt; @restricted(OSX 10.8, iOS 9.4, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OSX 10.8 or newer, and iOS 9.4 or newer.<br>&gt; Restricted within Version Bounds<br>&gt; @restricted(OSX, introduced=10.8, deprecated=10.10, obsoleted=10.11, message=&quot;No longer available.&quot;)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OS X from 10.8 through 10.11 only.<br>&gt; Restricted with Renamed Case<br>&gt; // Initial Release<br>&gt; @restricted(OSX 10.10, *)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt; <br>&gt; // Second Release<br>&gt; @restricted(OSX, introduced=10.10, deprecated=10.11, renamed=&quot;Weibo&quot;)<br>&gt; case TencentWeibo = &quot;com.apple.social.tencentweibo&quot;<br>&gt; <br>&gt; @restricted(OSX 10.11) case Weibo = &quot;com.apple.social.weibo&quot;<br>&gt; Effect: Initial release case is restricted to 10.10 and newer; second release has the original case deprecated from 10.11, with a new case introduced which is available on OS X 10.11 and newer only. <br>&gt; Benefits &amp; Impact on existing code<br>&gt; <br>&gt; @restricted has the benefit of reducing the amount code while maintaining clarity of purpose: it is obvious based on the attribute name what the intent is. <br>&gt; @restricted is purely additive, and therefore has no impact on existing code that makes use of @available. <br>&gt; Alternatives<br>&gt; <br>&gt; An alternative, though not a strict replacement of @restricted, could be to extract the unavailableargument and use it as an attribute (@unavailable). In use:<br>&gt; @available(OSX 10.8, *)<br>&gt; @unavailable(iOS, *)<br>&gt; case LinkedIn = &quot;com.apple.social.linkedin&quot;<br>&gt; Effect: Available on OS X but not iOS.<br>&gt; @unavailable is worthy of further discussion as using an unavailable argument inside an @availableattribute seems counterintuitive. <br>&gt; However, this proposal is limited to the consideration of @restricted.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/38c2f998/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
