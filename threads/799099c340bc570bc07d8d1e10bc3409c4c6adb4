<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2250d6c1b0ce837a63362ffd21e73176?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Mike Lewis</string> &lt;mikelikespie at gmail.com&gt;<p>June 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I&#39;ve recently open sourced a dependency injection framework for Swift<br>called Cleanse. https://github.com/square/cleanse<br></p><p>It does a couple things I&#39;d consider novel with the type system to make<br>wiring up functions easy without having to use reflection or other runtime<br>or compile-time hacks (I tried elaborating on it in this part of the README<br>here<br>https://github.com/square/Cleanse#dependency-requesting-terminating-methods)<br></p><p>Anyways, I&#39;m looking for feedback on the design and use of this library,<br>and maybe strike up a discussion on language features that may make writing<br>a library such as this be able to be &quot;cleaner&quot; in the future. Couple things<br>that come to mind are custom annotations for qualifying types (instead of<br>what we call &quot;type tags&quot;), variadic generic arguments (which we work around<br>by code generating the various arities), or even a plugin architecture to<br>achieve things similar to what can be done with Java annotation processors.<br></p><p>I&#39;d also be interested in feedback on some more of the implementation<br>details. e.g. is using this to key objects by type a good thing or a<br>terrible thing?<br>https://github.com/square/Cleanse/blob/master/Cleanse/TypeKeyProtocol.swift<br></p><p>Since Swift generics don&#39;t seem to be completely understood by the general<br>population, was hoping I could get some concrete feedback here. Even would<br>be stoked with a response to the tune of &quot;You don&#39;t need DI in Swift for<br>reasons X, Y, and Z.&quot;<br></p><p>Thanks!<br>Mike Lewis<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160614/7990adb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d159199cf75f783132c7274752896e3?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Ian Terrell</string> &lt;ian.terrell at gmail.com&gt;<p>June 15, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Mike,<br></p><p>Thanks for the library. It looks like you&#39;ve done a lot of great hacking on<br>it:<br></p><p>Dependency injection is a topic near and dear to me. :) I&#39;m very curious<br>about this pattern and its libraries and have been investigating them more<br>deeply lately. I haven&#39;t yet seen the value in this approach (not just in<br>Swift, but in any language), but if you have time and interest I&#39;d be very<br>happy to learn your thoughts (and others&#39;) on why it&#39;s superior to manual<br>dependency injection. I wouldn&#39;t normally do this :), but I&#39;m responding to<br>your invitation:<br></p><p>Even would be stoked with a response to the tune of &quot;You don&#39;t need DI in<br>&gt; Swift for reasons X, Y, and Z.&quot;<br></p><p><br>As an aside, I tried to peek at your example app<br>&lt;https://github.com/square/Cleanse/tree/github-initial-version/Examples/CleanseGithubBrowser&gt;<br>to get more context (it&#39;s linked at the bottom of the &quot;Satisfying<br>Dependencies&quot; section of your README), but it appears missing.<br></p><p>My first point of confusion is that these libraries seem to be less about<br>dependency injection and more about service location. For instance, in your<br>GitHub example in the playground, we see the following:<br></p><p>struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;     let githubURL: TaggedProvider&lt;GithubBaseURL&gt;<br></p><p><br>&gt;<br>    func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;         let url = githubURL<br>&gt;             .get()<br>&gt;<br>&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br></p><p><br>To my mind it doesn&#39;t look like githubURL was injected. It looks like it<br>was looked up in a service locator. In fact, it appears that the Binder is<br>a service locator, and you can simply set up multiple service locators for<br>multiple environments (with the added flexibility of multiple types via<br>tags). I call this solving the problem of inflexible global state (usually<br>singletons) by making it a flexible global state (a global service locator).<br></p><p>I&#39;ve always thought of dependency injection as being a tool for avoiding<br>global state. But in this case it seems to me like the service locator is<br>globally managed. The language of service locators is even present in<br>Guice&#39;s excellent motivation page<br>&lt;https://github.com/google/guice/wiki/Motivation&gt; (my emphasis):<br></p><p>Guice will inspect the annotated constructor, and *lookup* values for each<br>&gt; parameter.<br>&gt;<br></p><p>Another point I&#39;ve heard people talk about is that these libraries help as<br>dependencies grow. I hope this isn&#39;t a straw man, as I interpret the<br>following line in your README in that way.<br></p><p>As the functionality of this app grows, one may add arguments to<br>&gt; RootViewController and its dependencies as well as more modules to satisfy<br>&gt; them.<br>&gt;<br></p><p>The argument seems to go that this is easy to maintain:<br></p><p>init(a: A)<br></p><p><br>But this is difficult:<br></p><p>init(a: A, b: B, c: C, d: D, e: E, ...)<br></p><p><br>The argument goes further by saying that it becomes especially difficult as<br>you may need to pass the dependencies through the some nodes of the object<br>graph that seem not to need them. For instance, in the object graph A -&gt; B<br>-&gt; C, if C has a dependency on Foo but B does not, why should B know about<br>Foo?<br></p><p>But I find that argument unconvincing on two grounds. First, I believe an<br>object&#39;s dependencies are the union of its and its children&#39;s dependencies.<br>In the example above, B has an implicit dependency on Foo. &quot;Skipping&quot;<br>passing them around or instantiating them in the owning class is actually<br>only hiding an object&#39;s true dependencies by using global state. Second, as<br>a single object&#39;s dependencies become more unwieldy it seems in practice to<br>indicate an architectural problem where objects are doing too much. These<br>problems are related, as the architectural problem may not be as visible<br>when the true dependencies are hidden!<br></p><p>So to me — and with great respect for the work you&#39;ve done! I know a lot of<br>people (even some of my teammates with Dagger) value this approach<br>immensely — I don&#39;t personally see how the approach adds value over manual<br>injection, and I think the complexity is a negative.<br></p><p>I do think there is value in aiding with property injection for the cases<br>where we can&#39;t use initializer injection (we do often use storyboards at my<br>company, although we try to keep them small and unwieldy!), but I think<br>those cases are solved with a few clever extensions. See post-script if<br>you&#39;re curious.<br></p><p>So: I&#39;d love to know what sorts of use cases you find where this sort of<br>library is very helpful.<br></p><p>Thanks,<br>Ian<br></p><p>For contrast, I&#39;ve been handling property injection on iOS with a few<br>helpers, depending on how I want to do it.<br></p><p>For segues identified by identifier (at my company we do tend to use<br>storyboards with medium frequency; although we keep them separated into<br>small collections of scenes rather than large unwieldy ones), extensions<br>help create code like this:<br></p><p>let dependency: Dependency       // itself injected, or<br></p><p>// var dependency: Dependency! // if it could not be injected at<br>&gt; instantiation<br></p><p><br></p><p>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)<br>&gt; {<br>&gt;     switch segueFromStoryboardSegue(segue) {<br>&gt;     case .GoToCustomViewController(let custom):<br>&gt;         custom.inject(dependency: dependency)<br>&gt;     }<br>&gt; }<br></p><p><br>That&#39;s taken from some experiments I did at<br>https://github.com/willowtreeapps/segue_handler<br></p><p>Or in simple cases where I mostly care about type, I can do things like<br>this:<br></p><p>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)<br>&gt; {<br>&gt;     if let custom: CustomViewController =<br>&gt; segue.destinationViewController.injectable() {<br>&gt;         custom.inject(dependency: dependency)<br>&gt;     }<br>&gt; }<br></p><p><br>With the extension here:<br>https://gist.github.com/ianterrell/5aa139ab4b835b85cfee8e0f4430b863<br></p><p>Finally, for that style of property injection a precondition in viewDidLoad<br>or before usage in other types can ensure that the inject method was called.<br></p><p>In my mind the AppDelegate represents the root of my graph, and is<br>generally responsible for setting up all the dependencies it needs to care<br>about. For integration tests or XCUITests (such as I&#39;ve done, which is<br>limited, which might be skewing my opinion), I use environment variables or<br>launch options.<br></p><p><br></p><p><br>On Tue, Jun 14, 2016 at 7:55 PM, Mike Lewis via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I&#39;ve recently open sourced a dependency injection framework for Swift<br>&gt; called Cleanse. https://github.com/square/cleanse<br>&gt;<br>&gt; It does a couple things I&#39;d consider novel with the type system to make<br>&gt; wiring up functions easy without having to use reflection or other runtime<br>&gt; or compile-time hacks (I tried elaborating on it in this part of the README<br>&gt; here<br>&gt; https://github.com/square/Cleanse#dependency-requesting-terminating-methods<br>&gt; )<br>&gt;<br>&gt; Anyways, I&#39;m looking for feedback on the design and use of this library,<br>&gt; and maybe strike up a discussion on language features that may make writing<br>&gt; a library such as this be able to be &quot;cleaner&quot; in the future. Couple things<br>&gt; that come to mind are custom annotations for qualifying types (instead of<br>&gt; what we call &quot;type tags&quot;), variadic generic arguments (which we work around<br>&gt; by code generating the various arities), or even a plugin architecture to<br>&gt; achieve things similar to what can be done with Java annotation processors.<br>&gt;<br>&gt; I&#39;d also be interested in feedback on some more of the implementation<br>&gt; details. e.g. is using this to key objects by type a good thing or a<br>&gt; terrible thing?<br>&gt; https://github.com/square/Cleanse/blob/master/Cleanse/TypeKeyProtocol.swift<br>&gt;<br>&gt; Since Swift generics don&#39;t seem to be completely understood by the general<br>&gt; population, was hoping I could get some concrete feedback here. Even would<br>&gt; be stoked with a response to the tune of &quot;You don&#39;t need DI in Swift for<br>&gt; reasons X, Y, and Z.&quot;<br>&gt;<br>&gt; Thanks!<br>&gt; Mike Lewis<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160615/547534d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2250d6c1b0ce837a63362ffd21e73176?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Mike Lewis</string> &lt;mikelikespie at gmail.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Ian,<br></p><p>Thanks for your insightful feedback. First, apologies for the broken link<br>in the README. I just updated it (I accidentally linked to the wrong<br>branch). (the actual demo can be found here:<br>https://github.com/square/Cleanse/tree/master/Examples/CleanseGithubBrowser)<br></p><p>Anyways, you bring up some good points. I think Cleanse may actually solve<br>a lot of your concerns, but it may be a symptom of my slapdash README. I&#39;m<br>going to take a good documentation pass in the coming week and incorporate<br>your feedback and others.<br></p><p>Going to try to address some of your concerns.<br></p><p><br>&gt; My first point of confusion is that these libraries seem to be less about<br>&gt; dependency injection and more about service location. For instance, in your<br>&gt; GitHub example in the playground, we see the following:<br>&gt;<br>&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;     let githubURL: TaggedProvider&lt;GithubBaseURL&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;&gt;         let url = githubURL<br>&gt;&gt;             .get()<br>&gt;&gt;<br>&gt;&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br>&gt;<br>&gt;<br>&gt; To my mind it doesn&#39;t look like githubURL was injected. It looks like it<br>&gt; was looked up in a service locator. In fact, it appears that the Binder is<br>&gt; a service locator, and you can simply set up multiple service locators for<br>&gt; multiple environments (with the added flexibility of multiple types via<br>&gt; tags). I call this solving the problem of inflexible global state (usually<br>&gt; singletons) by making it a flexible global state (a global service locator).<br>&gt;<br></p><p>I&#39;m not very familiar with the service locator pattern to be honest,<br>however, I can assure you that the base URL is being injected. I think<br>there may be some confusion on either how the GithubListMembersServiceImpl<br>is being constructed, or tagged providers in general.<br></p><p>For the former, there was feedback regarding the constructors being<br>implicitly made for structs in this reddit thread<br>&lt;https://www.reddit.com/r/swift/comments/4o2lno/squarecleanse_swift_dependency_injection/d49pu6c&gt;<br>.<br></p><p>As far as the TaggedProvider part, they&#39;re essentially a workaround for not<br>being able to have Binding/Qualifier annotations<br>&lt;https://github.com/google/guice/wiki/BindingAnnotations&gt; in swift<br></p><p>In java/Guice githubURL, would be probably be request as either<br>&quot;@GithubBaseURL URL&quot; or &quot;@GithubBaseURL Provider&lt;URL&gt;&quot;.<br></p><p>In the playground example, one could easily change the service<br>implementation to be<br></p><p>struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;     let githubURL: *NSURL*<br></p><p><br>&gt;<br>    func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;         let url = githubURL<br>&gt;<br>&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br></p><p><br>and then change the binding statement to be<br></p><p><br>&gt;       binder<br>&gt;        .bind()<br>&gt;        .to(value: NSURL(string: &quot;https://api.github.com&quot;)!)<br></p><p><br>The downside of this in an actual application is that you may want to<br>inject other URLs. These &quot;Type Tags<br>&lt;file:///Users/lewis/Development/appointments-cleansed/Frameworks/Cleanse/Documentation/_build/html/README.html#type-tags&gt;&quot;<br> TaggedProviders are essentially just a way of wrapping a type (e.g. NSURL)<br>and giving it a unique key. A lot of the necessity for TaggedProviders<br>should go away once Cleanse has a concept of Subcomponents<br>&lt;http://google.github.io/dagger/subcomponents.html&gt; and Scopes like in<br>Dagger 2.<br></p><p><br>&gt; I&#39;ve always thought of dependency injection as being a tool for avoiding<br>&gt; global state. But in this case it seems to me like the service locator is<br>&gt; globally managed. The language of service locators is even present in<br>&gt; Guice&#39;s excellent motivation page<br>&gt; &lt;https://github.com/google/guice/wiki/Motivation&gt; (my emphasis):<br>&gt;<br>&gt;<br>The only &quot;global&quot; state are things that are declared singletons. (which are<br>still only singletons in the scope of each time one calls build). They have<br>very similar semantics to singletons in Guice<br>&lt;https://github.com/google/guice/wiki/Scopes&gt; (however no custom scopes yet<br>as mentioned above).<br></p><p><br>&gt; Guice will inspect the annotated constructor, and *lookup* values for<br>&gt;&gt; each parameter.<br>&gt;&gt;<br>&gt;<br>Cleanse actually achieves the same thing, but without reflection. I<br>attempted to explain it in this part of the README<br>&lt;https://github.com/square/Cleanse/blob/master/README.rst#terminating-methods-top1factory-p1---e-1st-arity&gt;,<br>but I&#39;ll be honest, I struggled while attempting to make it both simple and<br>detailed enough to convey what&#39;s going on.<br></p><p><br>&gt; Another point I&#39;ve heard people talk about is that these libraries help as<br>&gt; dependencies grow. I hope this isn&#39;t a straw man, as I interpret the<br>&gt; following line in your README in that way.<br>&gt;<br>&gt; As the functionality of this app grows, one may add arguments to<br>&gt;&gt; RootViewController and its dependencies as well as more modules to satisfy<br>&gt;&gt; them.<br>&gt;&gt;<br>&gt;<br>&gt; The argument seems to go that this is easy to maintain:<br>&gt;<br>&gt; init(a: A)<br>&gt;<br>&gt;<br>&gt; But this is difficult:<br>&gt;<br>&gt; init(a: A, b: B, c: C, d: D, e: E, ...)<br>&gt;<br>&gt;<br>&gt; The argument goes further by saying that it becomes especially difficult<br>&gt; as you may need to pass the dependencies through the some nodes of the<br>&gt; object graph that seem not to need them. For instance, in the object graph<br>&gt; A -&gt; B -&gt; C, if C has a dependency on Foo but B does not, why should B know<br>&gt; about Foo?<br>&gt;<br>&gt; But I find that argument unconvincing on two grounds. First, I believe an<br>&gt; object&#39;s dependencies are the union of its and its children&#39;s dependencies.<br>&gt; In the example above, B has an implicit dependency on Foo. &quot;Skipping&quot;<br>&gt; passing them around or instantiating them in the owning class is actually<br>&gt; only hiding an object&#39;s true dependencies by using global state. Second, as<br>&gt; a single object&#39;s dependencies become more unwieldy it seems in practice to<br>&gt; indicate an architectural problem where objects are doing too much. These<br>&gt; problems are related, as the architectural problem may not be as visible<br>&gt; when the true dependencies are hidden!<br>&gt;<br></p><p>So this is an interesting point. I&#39;m a strong believer that DI solves this<br>issue really well.<br></p><p>Let&#39;s take this example (I think its similar to the straw man you are<br>referring to):<br></p><p>https://gist.github.com/mikelikespie/c54a017677265322df7eb785d9f36345<br></p><p>Basically, VC_A, needs serviceA, and a VC_B to do its job, however, for it<br>to create VC_B it needs VC_B&#39;s dependencies + its transitive dependencies<br>which happen to be serviceA, serviceB, serviceC.<br></p><p>So I agree with the arguments made in the straw man, e.g. don&#39;t need to<br>change the constructor hierarchy all the way down when VC_D needs a new<br>service or needs to start depending on something. It takes a pretty large<br>example to start to see these benefits, but its kind of like how you don&#39;t<br>really see a benefit from a quicksort over a bubble sort until you have a<br>lot of items to sort.<br></p><p>So if we refactor as is (without turning anything into protocols) to use<br>Cleanse, we come up with something like:<br></p><p>https://gist.github.com/mikelikespie/3abe371bf7f7ab67f71d6cfa22c0145d<br></p><p>Now, say serviceD incurred a new dependency, one would just add it to its<br>constructor and make sure the dependency is configured... don&#39;t have to<br>change any of the other view controllers in the hierarchy.<br></p><p>This gets me to the next point, testing. VC_A&#39;s purpose is to call serviceA<br>and present a view controller. To properly unit test its functionality, it<br>may not be necessary to provide a concrete implementation of the VC it<br>wants to present. In general if one can test a component and its<br>functionality correctly with less dependencies that&#39;s better.<br></p><p>&gt;<br>&gt; So to me — and with great respect for the work you&#39;ve done! I know a lot<br>&gt; of people (even some of my teammates with Dagger) value this approach<br>&gt; immensely — I don&#39;t personally see how the approach adds value over manual<br>&gt; injection, and I think the complexity is a negative.<br>&gt;<br></p><p>I appreciate your feedback too! Hopefully will be able to reduce complexity<br>with iterations and improve documentation.<br></p><p><br></p><p>&gt; I do think there is value in aiding with property injection for the cases<br>&gt; where we can&#39;t use initializer injection (we do often use storyboards at my<br>&gt; company, although we try to keep them small and unwieldy!), but I think<br>&gt; those cases are solved with a few clever extensions. See post-script if<br>&gt; you&#39;re curious.<br>&gt;<br></p><p>Cleanse does support property injection<br>&lt;https://github.com/square/Cleanse#property-injection&gt;. My examples in the<br>readme only really demonstrate using it for the AppDelegate, but it also<br>makes sense for storyboard injection. It is very explicit though (less<br>magic than other DI frameworks). I also think there would be room for a<br>cleanse extension that specifically deals with storyboards. (I kinda like<br>what RxSwift did with RxCocoa).<br></p><p>Here&#39;s what the previous example could look like using Storyboards + segues:<br></p><p>https://gist.github.com/mikelikespie/db480360fe9b261cd3441c18a14bcbc9<br></p><p>Its definitely not terse and magical, but I think it is pretty explicit.<br></p><p>I&#39;ll check out post-script to see if there&#39;s anything to be learned though.<br>I also plan on including an example app using storyboard in the future.<br></p><p><br>Thanks for your other examples too! I think we may be on the page on some<br>of the property injection stuff, but it definitely shows some weakness in<br>my documentation.<br></p><p><br>&gt; So: I&#39;d love to know what sorts of use cases you find where this sort of<br>&gt; library is very helpful.<br>&gt;<br>&gt; Thanks,<br>&gt; Ian<br>&gt;<br>&gt; For contrast, I&#39;ve been handling property injection on iOS with a few<br>&gt; helpers, depending on how I want to do it.<br>&gt;<br>&gt; For segues identified by identifier (at my company we do tend to use<br>&gt; storyboards with medium frequency; although we keep them separated into<br>&gt; small collections of scenes rather than large unwieldy ones), extensions<br>&gt; help create code like this:<br>&gt;<br>&gt; let dependency: Dependency       // itself injected, or<br>&gt;<br>&gt; // var dependency: Dependency! // if it could not be injected at<br>&gt;&gt; instantiation<br>&gt;<br>&gt;<br>&gt;<br>&gt; override func prepareForSegue(segue: UIStoryboardSegue, sender:<br>&gt;&gt; AnyObject?) {<br>&gt;&gt;     switch segueFromStoryboardSegue(segue) {<br>&gt;&gt;     case .GoToCustomViewController(let custom):<br>&gt;&gt;         custom.inject(dependency: dependency)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;<br>&gt;<br>&gt; That&#39;s taken from some experiments I did at<br>&gt; https://github.com/willowtreeapps/segue_handler<br>&gt;<br>&gt; Or in simple cases where I mostly care about type, I can do things like<br>&gt; this:<br>&gt;<br>&gt; override func prepareForSegue(segue: UIStoryboardSegue, sender:<br>&gt;&gt; AnyObject?) {<br>&gt;&gt;     if let custom: CustomViewController =<br>&gt;&gt; segue.destinationViewController.injectable() {<br>&gt;&gt;         custom.inject(dependency: dependency)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;<br>&gt;<br>&gt; With the extension here:<br>&gt; https://gist.github.com/ianterrell/5aa139ab4b835b85cfee8e0f4430b863<br>&gt;<br>&gt; Finally, for that style of property injection a precondition in<br>&gt; viewDidLoad or before usage in other types can ensure that the inject<br>&gt; method was called.<br>&gt;<br>&gt; In my mind the AppDelegate represents the root of my graph, and is<br>&gt; generally responsible for setting up all the dependencies it needs to care<br>&gt; about. For integration tests or XCUITests (such as I&#39;ve done, which is<br>&gt; limited, which might be skewing my opinion), I use environment variables or<br>&gt; launch options.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Jun 14, 2016 at 7:55 PM, Mike Lewis via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I&#39;ve recently open sourced a dependency injection framework for Swift<br>&gt;&gt; called Cleanse. https://github.com/square/cleanse<br>&gt;&gt;<br>&gt;&gt; It does a couple things I&#39;d consider novel with the type system to make<br>&gt;&gt; wiring up functions easy without having to use reflection or other runtime<br>&gt;&gt; or compile-time hacks (I tried elaborating on it in this part of the README<br>&gt;&gt; here<br>&gt;&gt; https://github.com/square/Cleanse#dependency-requesting-terminating-methods<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; Anyways, I&#39;m looking for feedback on the design and use of this library,<br>&gt;&gt; and maybe strike up a discussion on language features that may make writing<br>&gt;&gt; a library such as this be able to be &quot;cleaner&quot; in the future. Couple things<br>&gt;&gt; that come to mind are custom annotations for qualifying types (instead of<br>&gt;&gt; what we call &quot;type tags&quot;), variadic generic arguments (which we work around<br>&gt;&gt; by code generating the various arities), or even a plugin architecture to<br>&gt;&gt; achieve things similar to what can be done with Java annotation processors.<br>&gt;&gt;<br>&gt;&gt; I&#39;d also be interested in feedback on some more of the implementation<br>&gt;&gt; details. e.g. is using this to key objects by type a good thing or a<br>&gt;&gt; terrible thing?<br>&gt;&gt; https://github.com/square/Cleanse/blob/master/Cleanse/TypeKeyProtocol.swift<br>&gt;&gt;<br>&gt;&gt; Since Swift generics don&#39;t seem to be completely understood by the<br>&gt;&gt; general population, was hoping I could get some concrete feedback here.<br>&gt;&gt; Even would be stoked with a response to the tune of &quot;You don&#39;t need DI in<br>&gt;&gt; Swift for reasons X, Y, and Z.&quot;<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt; Mike Lewis<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160616/94ee094b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d159199cf75f783132c7274752896e3?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Ian Terrell</string> &lt;ian.terrell at gmail.com&gt;<p>June 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Mike,<br></p><p>Thanks for your response. :) Let me address your points. I apologize for<br>the length; this is a topic I care about and I know my co-workers are<br>reading it. :)<br></p><p>I&#39;m going to edit the message history for brevity.<br></p><p>My first point of confusion is that these libraries seem to be less about<br>&gt;&gt; dependency injection and more about service location. For instance, in your<br>&gt;&gt; GitHub example in the playground, we see the following:<br>&gt;&gt;<br>&gt;&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;&gt;     let githubURL: TaggedProvider&lt;GithubBaseURL&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;&gt;&gt;         let url = githubURL.get()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To my mind it doesn&#39;t look like githubURL was injected. It looks like it<br>&gt;&gt; was looked up in a service locator.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not very familiar with the service locator pattern to be honest,<br>&gt; however, I can assure you that the base URL is being injected. I think<br>&gt; there may be some confusion on either how the GithubListMembersServiceImpl<br>&gt; is being constructed, or tagged providers in general.<br>&gt;<br></p><p>I don&#39;t believe I&#39;m confused over those features, and I do understand that<br>githubURL is being injected from your point of view. What I mean though is<br>that it&#39;s being injected from a global location, not from the main call<br>site.<br></p><p>In service location code that needs a service asks for it, and the service<br>locator provides it. In this case you are asking for a GithubBaseURL. The<br>(in my opinion problematic) pattern occurs even if you rewrite the service<br>implementation as you did:<br></p><p>struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;     let githubURL: *NSURL*<br></p><p><br>&gt;<br>    func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;         let url = githubURL<br>&gt;<br>&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br></p><p><br>Definitely from the perspective of GithubListMembersServiceImpl the<br>githubURL is injected. That makes it nicely testable and well designed.<br>However in this case the service location is merely once removed (and is<br>already present in the prior version as well): now your code is asking a<br>service locator for the GithubListMembersService (client code will now have<br>to call GithubListMembersService.get()).<br></p><p>I see dependency injection as being given your dependencies. I see service<br>location as asking for your dependencies. In Cleanse and Dagger and Guice I<br>feel like the dependencies are being asked for (the get() method is *asking<br>something else* to be provided the call site with an instance).<br></p><p>In this case, I believe your &quot;component&quot; is the service locator.<br></p><p>and then change the binding statement to be<br>&gt;<br>&gt;<br>&gt;&gt;       binder<br>&gt;&gt;        .bind()<br>&gt;&gt;        .to(value: NSURL(string: &quot;https://api.github.com&quot;)!)<br>&gt;<br>&gt;<br>&gt; The downside of this in an actual application is that you may want to<br>&gt; inject other URLs. These &quot;Type Tags&quot;  TaggedProviders are essentially<br>&gt; just a ...<br>&gt;<br></p><p>And this is why I think Dagger and Guice and Cleanse are improperly<br>categorized as dependency injection frameworks. I think in reality they are<br>service locators and factories. Dependency injection needs no framework!<br></p><p>With manual dependency injection, when different services want different<br>URLs you simply inject them normally.<br></p><p>call site A: MembersServiceImpl(baseURL: productionURL)<br>call site B: MembersServiceImpl(baseURL: stagingURL)<br></p><p>That requires that the call sites manage that dependency in order to know<br>what to pass (feature not a bug).<br></p><p><br>&gt; I&#39;ve always thought of dependency injection as being a tool for avoiding<br>&gt;&gt; global state. But in this case it seems to me like the service locator is<br>&gt;&gt; globally managed. The language of service locators is even present in<br>&gt;&gt; Guice&#39;s excellent motivation page<br>&gt;&gt; &lt;https://github.com/google/guice/wiki/Motivation&gt; (my emphasis):<br>&gt;&gt;<br>&gt;&gt;<br>&gt; The only &quot;global&quot; state are things that are declared singletons. (which<br>&gt; are still only singletons in the scope of each time one calls build). They<br>&gt; have very similar semantics to singletons in Guice<br>&gt; &lt;https://github.com/google/guice/wiki/Scopes&gt; (however no custom scopes<br>&gt; yet as mentioned above).<br>&gt;<br></p><p>Global is not quite accurate, but it is not terribly close. Your Component<br>object tree is what I mean, and I view it (perhaps wrongly) as<br>&quot;semi-global.&quot; I get the sense that in most applications there will end up<br>being exactly one. A better word is &quot;external&quot;. Now your objects rely on<br>external state, whether it is global or semi-global.<br></p><p><br>&gt; For the former, there was feedback regarding the constructors being<br>&gt; implicitly made for structs in this reddit thread<br>&gt; &lt;https://www.reddit.com/r/swift/comments/4o2lno/squarecleanse_swift_dependency_injection/d49pu6c&gt;<br>&gt; .<br>&gt;<br></p><p>You pointed out in that thread that these frameworks make it easier to keep<br>up with new dependencies, reordered initializer parameters, etc — but all<br>that hiding I fear would lead to poor architectural decisions in practice.<br>Too many objects end up depending on too many things, because those<br>dependencies are hidden from them. That means that real refactors (trying<br>to use these objects in un-forethought contexts, etc) become more<br>difficult, and your app actually becomes more tightly coupled (it&#39;s so easy<br>to .get() that other object!).<br></p><p> Guice will inspect the annotated constructor, and *lookup* values for each<br>&gt; parameter.<br>&gt;<br>&gt; Cleanse actually achieves the same thing, but without reflection. I<br>&gt; attempted to explain it in this part of the README<br>&gt; &lt;https://github.com/square/Cleanse/blob/master/README.rst#terminating-methods-top1factory-p1---e-1st-arity&gt;,<br>&gt; but I&#39;ll be honest, I struggled while attempting to make it both simple and<br>&gt; detailed enough to convey what&#39;s going on.<br>&gt;<br></p><p>I think I get what&#39;s going on. I only meant that the words &quot;look up&quot; imply<br>service location to me. In my mind you&#39;re registering (via bind()) service<br>factory instructions to the service locator. At runtime, the service<br>locator/factory *looks up *how to build it and returns you an instance.<br></p><p>Big snippet below for all the context:<br></p><p>Another point I&#39;ve heard people talk about is that these libraries help as<br>&gt; dependencies grow. I hope this isn&#39;t a straw man, as I interpret the<br>&gt; following line in your README in that way.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; As the functionality of this app grows, one may add arguments to<br>&gt;&gt;&gt; RootViewController and its dependencies as well as more modules to satisfy<br>&gt;&gt;&gt; them.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The argument seems to go that this is easy to maintain:<br>&gt;&gt;<br>&gt;&gt; init(a: A)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But this is difficult:<br>&gt;&gt;<br>&gt;&gt; init(a: A, b: B, c: C, d: D, e: E, ...)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The argument goes further by saying that it becomes especially difficult<br>&gt;&gt; as you may need to pass the dependencies through the some nodes of the<br>&gt;&gt; object graph that seem not to need them. For instance, in the object graph<br>&gt;&gt; A -&gt; B -&gt; C, if C has a dependency on Foo but B does not, why should B know<br>&gt;&gt; about Foo?<br>&gt;&gt;<br>&gt;&gt; But I find that argument unconvincing on two grounds. First, I believe an<br>&gt;&gt; object&#39;s dependencies are the union of its and its children&#39;s dependencies.<br>&gt;&gt; In the example above, B has an implicit dependency on Foo. &quot;Skipping&quot;<br>&gt;&gt; passing them around or instantiating them in the owning class is actually<br>&gt;&gt; only hiding an object&#39;s true dependencies by using global state. Second, as<br>&gt;&gt; a single object&#39;s dependencies become more unwieldy it seems in practice to<br>&gt;&gt; indicate an architectural problem where objects are doing too much. These<br>&gt;&gt; problems are related, as the architectural problem may not be as visible<br>&gt;&gt; when the true dependencies are hidden!<br>&gt;&gt;<br>&gt;<br>&gt; So this is an interesting point. I&#39;m a strong believer that DI solves this<br>&gt; issue really well.<br>&gt;<br>&gt; Let&#39;s take this example (I think its similar to the straw man you are<br>&gt; referring to):<br>&gt;<br>&gt; https://gist.github.com/mikelikespie/c54a017677265322df7eb785d9f36345<br>&gt;<br>&gt; Basically, VC_A, needs serviceA, and a VC_B to do its job, however, for it<br>&gt; to create VC_B it needs VC_B&#39;s dependencies + its transitive dependencies<br>&gt; which happen to be serviceA, serviceB, serviceC.<br>&gt;<br>&gt; So I agree with the arguments made in the straw man, e.g. don&#39;t need to<br>&gt; change the constructor hierarchy all the way down when VC_D needs a new<br>&gt; service or needs to start depending on something. It takes a pretty large<br>&gt; example to start to see these benefits, but its kind of like how you don&#39;t<br>&gt; really see a benefit from a quicksort over a bubble sort until you have a<br>&gt; lot of items to sort.<br>&gt;<br>&gt; So if we refactor as is (without turning anything into protocols) to use<br>&gt; Cleanse, we come up with something like:<br>&gt;<br>&gt; https://gist.github.com/mikelikespie/3abe371bf7f7ab67f71d6cfa22c0145d<br>&gt;<br>&gt; Now, say serviceD incurred a new dependency, one would just add it to its<br>&gt; constructor and make sure the dependency is configured... don&#39;t have to<br>&gt; change any of the other view controllers in the hierarchy.<br>&gt;<br></p><p>Ok! So, we&#39;re on the exact same page with the code and the problem, and<br>perhaps even the same conclusion, but the exact opposite solutions.<br></p><p>I&#39;m a strong believer that DI solves this issue really well. ... It takes a<br>&gt; pretty large example to start to see these benefits<br>&gt;<br></p><p>I believe that true dependency injection is the solution, but I think that<br>Cleanse/Dagger/Guice aren&#39;t really providing that in a useful way. I think<br>the refactored version using Cleanse is significantly worse than the<br>non-refactored version. Additionally, I think the larger the project (in<br>your view where it shines), the worse the problem gets (in my view where it<br>hinders).<br></p><p>Concretely: In both examples, ViewController_A has dependencies on services<br>A, B, C, and D. But only in the non-Cleanse version is that visible. This<br>means that it has hidden, non-explicit dependencies, that have to be looked<br>up somewhere else. And they&#39;re looked up from the service locator/factory<br>VC_A_Component. We cannot use ViewController_A outside of the context of<br>that special knowledge and setup.<br></p><p>These frameworks aren&#39;t removing dependencies, they&#39;re hiding them. This<br>makes it less easy to reason about the code.<br></p><p>As an example of reasoning, a reader of the component/service locator setup<br>in the Cleanse example has to wonder: Why am I binding Services A, B, C,<br>and D and VCs A, B, C, and D just to create a single VC_A? Now the reader<br>has to inspect all of the view controllers to find out! After which she<br>learns, well, VC_A uses S_A and can create a VC_B, which uses S_B and can<br>create a VC_C, which uses S_C and can create a VC_D, and VC_D uses S_D. All<br>of that information must be discovered and tied together just to get() a<br>single VC_A!<br></p><p>In the non-Cleanse example, the question is: Why do I need to instantiate<br>VC_A with Services A, B, C, and D? And the answer is simple and comes from<br>a single view controller (the one we care about): because VC_A uses S_A can<br>create a VC_B and VC_B uses services B, C, and D.<br></p><p>That&#39;s a huge contrast in reasoning, and it&#39;s because Cleanse/Dagger/Guice<br>are hiding information in external service locators.<br></p><p>I suppose I might phrase my point of view as saying that I don&#39;t believe in<br>transitive dependencies; and definitely not in treating them differently.<br>You have your dependencies, and by depending on something else that has<br>dependencies, those transitive dependencies are de facto yours, directly.<br>They get no special treatment, because they cannot; treating them specially<br>relies on external state. That is breaking encapsulation.<br></p><p><br>&gt; This gets me to the next point, testing. VC_A&#39;s purpose is to call<br>&gt; serviceA and present a view controller. To properly unit test its<br>&gt; functionality, it may not be necessary to provide a concrete implementation<br>&gt; of the VC it wants to present. In general if one can test a component and<br>&gt; its functionality correctly with less dependencies that&#39;s better.<br>&gt;<br></p><p>I would never advocate anything that wasn&#39;t properly and nicely testable. I<br>take your point that it seems simpler to test in this setup, but I don&#39;t<br>really believe it&#39;s simpler. Again, that&#39;s because the true dependencies<br>are hidden.<br></p><p>In the case of manual dependency injection as I advocate, the solution is<br>protocols and empty implementations. I agree that empty implementations of<br>protocols can be annoying to maintain, but I find they solve the problem<br>very well in a clean and &quot;dumb&quot; manner.<br></p><p>For instance, to test VC_A, assuming all the services were protocols, you<br>could create an instance solely to test its service A functionality like so:<br></p><p>let testedVC = ViewController_A(serviceA: TestingServiceA(), serviceB:<br>DummyServiceB(),<br>                                                     serviceC:<br>DummyServiceC(), serviceD: DummyServiceD())<br></p><p>https://gist.github.com/ianterrell/c86aa1ad64453a214966ac81b31f75e9<br></p><p>I do think there is value in aiding with property injection for the cases<br>&gt;&gt; where we can&#39;t use initializer injection (we do often use storyboards at my<br>&gt;&gt; company, although we try to keep them small and unwieldy!), but I think<br>&gt;&gt; those cases are solved with a few clever extensions. See post-script if<br>&gt;&gt; you&#39;re curious.<br>&gt;&gt;<br>&gt;<br>&gt; Cleanse does support property injection<br>&gt; &lt;https://github.com/square/Cleanse#property-injection&gt;. My examples in<br>&gt; the readme only really demonstrate using it for the AppDelegate, but it<br>&gt; also makes sense for storyboard injection. It is very explicit though (less<br>&gt; magic than other DI frameworks). I also think there would be room for a<br>&gt; cleanse extension that specifically deals with storyboards. (I kinda like<br>&gt; what RxSwift did with RxCocoa).<br>&gt;<br></p><p>Yes, I saw it. I think I only meant that I do see manual property injection<br>with UIKit classes as sometimes cumbersome, but I believe there are better<br>solutions than frameworks like these.<br></p><p>I don&#39;t believe I&#39;ve misinterpreted your project or it&#39;s documentation. I<br>anticipate that we may simply believe in different solutions to the hard<br>problem or dependency management. In that case I leave this conversation<br>happily agreeing to disagree, just as I do with some of my other colleagues<br>here. :) But at least I hope I&#39;ve well explained why I personally view<br>these solutions as detrimental.<br></p><p>Thanks,<br>Ian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160616/4d5268b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/960ce0d42ca874f25b0b58904d3f941b?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Tadeas Kriz</string> &lt;tadeas at brightify.org&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Ian,<br></p><p>Shouldn&#39;t the `ViewController_B` be a dependency and not be instantiated<br>inside a `ViewController_A`? Or ViewControllers/Controllers are not<br>considered dependencies?<br></p><p>Thanks,<br>Tadeas<br></p><p>On Thu, Jun 16, 2016 at 10:50 PM Ian Terrell via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi Mike,<br>&gt;<br>&gt; Thanks for your response. :) Let me address your points. I apologize for<br>&gt; the length; this is a topic I care about and I know my co-workers are<br>&gt; reading it. :)<br>&gt;<br>&gt; I&#39;m going to edit the message history for brevity.<br>&gt;<br>&gt; My first point of confusion is that these libraries seem to be less about<br>&gt;&gt;&gt; dependency injection and more about service location. For instance, in your<br>&gt;&gt;&gt; GitHub example in the playground, we see the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;&gt;&gt;     let githubURL: TaggedProvider&lt;GithubBaseURL&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;&gt;&gt;&gt;         let url = githubURL.get()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To my mind it doesn&#39;t look like githubURL was injected. It looks like it<br>&gt;&gt;&gt; was looked up in a service locator.<br>&gt;&gt;&gt;<br>&gt;&gt; I&#39;m not very familiar with the service locator pattern to be honest,<br>&gt;&gt; however, I can assure you that the base URL is being injected. I think<br>&gt;&gt; there may be some confusion on either how the GithubListMembersServiceImpl<br>&gt;&gt; is being constructed, or tagged providers in general.<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t believe I&#39;m confused over those features, and I do understand that<br>&gt; githubURL is being injected from your point of view. What I mean though is<br>&gt; that it&#39;s being injected from a global location, not from the main call<br>&gt; site.<br>&gt;<br>&gt; In service location code that needs a service asks for it, and the service<br>&gt; locator provides it. In this case you are asking for a GithubBaseURL. The<br>&gt; (in my opinion problematic) pattern occurs even if you rewrite the service<br>&gt; implementation as you did:<br>&gt;<br>&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;     let githubURL: *NSURL*<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;&gt;         let url = githubURL<br>&gt;&gt;<br>&gt;&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br>&gt;<br>&gt;<br>&gt; Definitely from the perspective of GithubListMembersServiceImpl the<br>&gt; githubURL is injected. That makes it nicely testable and well designed.<br>&gt; However in this case the service location is merely once removed (and is<br>&gt; already present in the prior version as well): now your code is asking a<br>&gt; service locator for the GithubListMembersService (client code will now have<br>&gt; to call GithubListMembersService.get()).<br>&gt;<br>&gt; I see dependency injection as being given your dependencies. I see service<br>&gt; location as asking for your dependencies. In Cleanse and Dagger and Guice I<br>&gt; feel like the dependencies are being asked for (the get() method is *asking<br>&gt; something else* to be provided the call site with an instance).<br>&gt;<br>&gt; In this case, I believe your &quot;component&quot; is the service locator.<br>&gt;<br>&gt; and then change the binding statement to be<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;       binder<br>&gt;&gt;&gt;        .bind()<br>&gt;&gt;&gt;        .to(value: NSURL(string: &quot;https://api.github.com&quot;)!)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The downside of this in an actual application is that you may want to<br>&gt;&gt; inject other URLs. These &quot;Type Tags&quot;  TaggedProviders are essentially<br>&gt;&gt; just a ...<br>&gt;&gt;<br>&gt;<br>&gt; And this is why I think Dagger and Guice and Cleanse are improperly<br>&gt; categorized as dependency injection frameworks. I think in reality they are<br>&gt; service locators and factories. Dependency injection needs no framework!<br>&gt;<br>&gt; With manual dependency injection, when different services want different<br>&gt; URLs you simply inject them normally.<br>&gt;<br>&gt; call site A: MembersServiceImpl(baseURL: productionURL)<br>&gt; call site B: MembersServiceImpl(baseURL: stagingURL)<br>&gt;<br>&gt; That requires that the call sites manage that dependency in order to know<br>&gt; what to pass (feature not a bug).<br>&gt;<br>&gt;<br>&gt;&gt; I&#39;ve always thought of dependency injection as being a tool for avoiding<br>&gt;&gt;&gt; global state. But in this case it seems to me like the service locator is<br>&gt;&gt;&gt; globally managed. The language of service locators is even present in<br>&gt;&gt;&gt; Guice&#39;s excellent motivation page<br>&gt;&gt;&gt; &lt;https://github.com/google/guice/wiki/Motivation&gt; (my emphasis):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; The only &quot;global&quot; state are things that are declared singletons. (which<br>&gt;&gt; are still only singletons in the scope of each time one calls build). They<br>&gt;&gt; have very similar semantics to singletons in Guice<br>&gt;&gt; &lt;https://github.com/google/guice/wiki/Scopes&gt; (however no custom scopes<br>&gt;&gt; yet as mentioned above).<br>&gt;&gt;<br>&gt;<br>&gt; Global is not quite accurate, but it is not terribly close. Your Component<br>&gt; object tree is what I mean, and I view it (perhaps wrongly) as<br>&gt; &quot;semi-global.&quot; I get the sense that in most applications there will end up<br>&gt; being exactly one. A better word is &quot;external&quot;. Now your objects rely on<br>&gt; external state, whether it is global or semi-global.<br>&gt;<br>&gt;<br>&gt;&gt; For the former, there was feedback regarding the constructors being<br>&gt;&gt; implicitly made for structs in this reddit thread<br>&gt;&gt; &lt;https://www.reddit.com/r/swift/comments/4o2lno/squarecleanse_swift_dependency_injection/d49pu6c&gt;<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;<br>&gt; You pointed out in that thread that these frameworks make it easier to<br>&gt; keep up with new dependencies, reordered initializer parameters, etc — but<br>&gt; all that hiding I fear would lead to poor architectural decisions in<br>&gt; practice. Too many objects end up depending on too many things, because<br>&gt; those dependencies are hidden from them. That means that real refactors<br>&gt; (trying to use these objects in un-forethought contexts, etc) become more<br>&gt; difficult, and your app actually becomes more tightly coupled (it&#39;s so easy<br>&gt; to .get() that other object!).<br>&gt;<br>&gt;  Guice will inspect the annotated constructor, and *lookup* values for<br>&gt;&gt; each parameter.<br>&gt;&gt;<br>&gt;&gt; Cleanse actually achieves the same thing, but without reflection. I<br>&gt;&gt; attempted to explain it in this part of the README<br>&gt;&gt; &lt;https://github.com/square/Cleanse/blob/master/README.rst#terminating-methods-top1factory-p1---e-1st-arity&gt;,<br>&gt;&gt; but I&#39;ll be honest, I struggled while attempting to make it both simple and<br>&gt;&gt; detailed enough to convey what&#39;s going on.<br>&gt;&gt;<br>&gt;<br>&gt; I think I get what&#39;s going on. I only meant that the words &quot;look up&quot; imply<br>&gt; service location to me. In my mind you&#39;re registering (via bind()) service<br>&gt; factory instructions to the service locator. At runtime, the service<br>&gt; locator/factory *looks up *how to build it and returns you an instance.<br>&gt;<br>&gt; Big snippet below for all the context:<br>&gt;<br>&gt; Another point I&#39;ve heard people talk about is that these libraries help as<br>&gt;&gt; dependencies grow. I hope this isn&#39;t a straw man, as I interpret the<br>&gt;&gt; following line in your README in that way.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As the functionality of this app grows, one may add arguments to<br>&gt;&gt;&gt;&gt; RootViewController and its dependencies as well as more modules to satisfy<br>&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The argument seems to go that this is easy to maintain:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; init(a: A)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But this is difficult:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; init(a: A, b: B, c: C, d: D, e: E, ...)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The argument goes further by saying that it becomes especially difficult<br>&gt;&gt;&gt; as you may need to pass the dependencies through the some nodes of the<br>&gt;&gt;&gt; object graph that seem not to need them. For instance, in the object graph<br>&gt;&gt;&gt; A -&gt; B -&gt; C, if C has a dependency on Foo but B does not, why should B know<br>&gt;&gt;&gt; about Foo?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But I find that argument unconvincing on two grounds. First, I believe<br>&gt;&gt;&gt; an object&#39;s dependencies are the union of its and its children&#39;s<br>&gt;&gt;&gt; dependencies. In the example above, B has an implicit dependency on Foo.<br>&gt;&gt;&gt; &quot;Skipping&quot; passing them around or instantiating them in the owning class is<br>&gt;&gt;&gt; actually only hiding an object&#39;s true dependencies by using global state.<br>&gt;&gt;&gt; Second, as a single object&#39;s dependencies become more unwieldy it seems in<br>&gt;&gt;&gt; practice to indicate an architectural problem where objects are doing too<br>&gt;&gt;&gt; much. These problems are related, as the architectural problem may not be<br>&gt;&gt;&gt; as visible when the true dependencies are hidden!<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So this is an interesting point. I&#39;m a strong believer that DI solves<br>&gt;&gt; this issue really well.<br>&gt;&gt;<br>&gt;&gt; Let&#39;s take this example (I think its similar to the straw man you are<br>&gt;&gt; referring to):<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/mikelikespie/c54a017677265322df7eb785d9f36345<br>&gt;&gt;<br>&gt;&gt; Basically, VC_A, needs serviceA, and a VC_B to do its job, however, for<br>&gt;&gt; it to create VC_B it needs VC_B&#39;s dependencies + its transitive<br>&gt;&gt; dependencies which happen to be serviceA, serviceB, serviceC.<br>&gt;&gt;<br>&gt;&gt; So I agree with the arguments made in the straw man, e.g. don&#39;t need to<br>&gt;&gt; change the constructor hierarchy all the way down when VC_D needs a new<br>&gt;&gt; service or needs to start depending on something. It takes a pretty large<br>&gt;&gt; example to start to see these benefits, but its kind of like how you don&#39;t<br>&gt;&gt; really see a benefit from a quicksort over a bubble sort until you have a<br>&gt;&gt; lot of items to sort.<br>&gt;&gt;<br>&gt;&gt; So if we refactor as is (without turning anything into protocols) to use<br>&gt;&gt; Cleanse, we come up with something like:<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/mikelikespie/3abe371bf7f7ab67f71d6cfa22c0145d<br>&gt;&gt;<br>&gt;&gt; Now, say serviceD incurred a new dependency, one would just add it to its<br>&gt;&gt; constructor and make sure the dependency is configured... don&#39;t have to<br>&gt;&gt; change any of the other view controllers in the hierarchy.<br>&gt;&gt;<br>&gt;<br>&gt; Ok! So, we&#39;re on the exact same page with the code and the problem, and<br>&gt; perhaps even the same conclusion, but the exact opposite solutions.<br>&gt;<br>&gt; I&#39;m a strong believer that DI solves this issue really well. ... It takes<br>&gt;&gt; a pretty large example to start to see these benefits<br>&gt;&gt;<br>&gt;<br>&gt; I believe that true dependency injection is the solution, but I think that<br>&gt; Cleanse/Dagger/Guice aren&#39;t really providing that in a useful way. I think<br>&gt; the refactored version using Cleanse is significantly worse than the<br>&gt; non-refactored version. Additionally, I think the larger the project (in<br>&gt; your view where it shines), the worse the problem gets (in my view where it<br>&gt; hinders).<br>&gt;<br>&gt; Concretely: In both examples, ViewController_A has dependencies on<br>&gt; services A, B, C, and D. But only in the non-Cleanse version is that<br>&gt; visible. This means that it has hidden, non-explicit dependencies, that<br>&gt; have to be looked up somewhere else. And they&#39;re looked up from the service<br>&gt; locator/factory VC_A_Component. We cannot use ViewController_A outside of<br>&gt; the context of that special knowledge and setup.<br>&gt;<br>&gt; These frameworks aren&#39;t removing dependencies, they&#39;re hiding them. This<br>&gt; makes it less easy to reason about the code.<br>&gt;<br>&gt; As an example of reasoning, a reader of the component/service locator<br>&gt; setup in the Cleanse example has to wonder: Why am I binding Services A, B,<br>&gt; C, and D and VCs A, B, C, and D just to create a single VC_A? Now the<br>&gt; reader has to inspect all of the view controllers to find out! After which<br>&gt; she learns, well, VC_A uses S_A and can create a VC_B, which uses S_B and<br>&gt; can create a VC_C, which uses S_C and can create a VC_D, and VC_D uses S_D.<br>&gt; All of that information must be discovered and tied together just to get()<br>&gt; a single VC_A!<br>&gt;<br>&gt; In the non-Cleanse example, the question is: Why do I need to instantiate<br>&gt; VC_A with Services A, B, C, and D? And the answer is simple and comes from<br>&gt; a single view controller (the one we care about): because VC_A uses S_A can<br>&gt; create a VC_B and VC_B uses services B, C, and D.<br>&gt;<br>&gt; That&#39;s a huge contrast in reasoning, and it&#39;s because Cleanse/Dagger/Guice<br>&gt; are hiding information in external service locators.<br>&gt;<br>&gt; I suppose I might phrase my point of view as saying that I don&#39;t believe<br>&gt; in transitive dependencies; and definitely not in treating them<br>&gt; differently. You have your dependencies, and by depending on something else<br>&gt; that has dependencies, those transitive dependencies are de facto yours,<br>&gt; directly. They get no special treatment, because they cannot; treating them<br>&gt; specially relies on external state. That is breaking encapsulation.<br>&gt;<br>&gt;<br>&gt;&gt; This gets me to the next point, testing. VC_A&#39;s purpose is to call<br>&gt;&gt; serviceA and present a view controller. To properly unit test its<br>&gt;&gt; functionality, it may not be necessary to provide a concrete implementation<br>&gt;&gt; of the VC it wants to present. In general if one can test a component and<br>&gt;&gt; its functionality correctly with less dependencies that&#39;s better.<br>&gt;&gt;<br>&gt;<br>&gt; I would never advocate anything that wasn&#39;t properly and nicely testable.<br>&gt; I take your point that it seems simpler to test in this setup, but I don&#39;t<br>&gt; really believe it&#39;s simpler. Again, that&#39;s because the true dependencies<br>&gt; are hidden.<br>&gt;<br>&gt; In the case of manual dependency injection as I advocate, the solution is<br>&gt; protocols and empty implementations. I agree that empty implementations of<br>&gt; protocols can be annoying to maintain, but I find they solve the problem<br>&gt; very well in a clean and &quot;dumb&quot; manner.<br>&gt;<br>&gt; For instance, to test VC_A, assuming all the services were protocols, you<br>&gt; could create an instance solely to test its service A functionality like so:<br>&gt;<br>&gt; let testedVC = ViewController_A(serviceA: TestingServiceA(), serviceB:<br>&gt; DummyServiceB(),<br>&gt;                                                      serviceC:<br>&gt; DummyServiceC(), serviceD: DummyServiceD())<br>&gt;<br>&gt; https://gist.github.com/ianterrell/c86aa1ad64453a214966ac81b31f75e9<br>&gt;<br>&gt; I do think there is value in aiding with property injection for the cases<br>&gt;&gt;&gt; where we can&#39;t use initializer injection (we do often use storyboards at my<br>&gt;&gt;&gt; company, although we try to keep them small and unwieldy!), but I think<br>&gt;&gt;&gt; those cases are solved with a few clever extensions. See post-script if<br>&gt;&gt;&gt; you&#39;re curious.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Cleanse does support property injection<br>&gt;&gt; &lt;https://github.com/square/Cleanse#property-injection&gt;. My examples in<br>&gt;&gt; the readme only really demonstrate using it for the AppDelegate, but it<br>&gt;&gt; also makes sense for storyboard injection. It is very explicit though (less<br>&gt;&gt; magic than other DI frameworks). I also think there would be room for a<br>&gt;&gt; cleanse extension that specifically deals with storyboards. (I kinda like<br>&gt;&gt; what RxSwift did with RxCocoa).<br>&gt;&gt;<br>&gt;<br>&gt; Yes, I saw it. I think I only meant that I do see manual property<br>&gt; injection with UIKit classes as sometimes cumbersome, but I believe there<br>&gt; are better solutions than frameworks like these.<br>&gt;<br>&gt; I don&#39;t believe I&#39;ve misinterpreted your project or it&#39;s documentation. I<br>&gt; anticipate that we may simply believe in different solutions to the hard<br>&gt; problem or dependency management. In that case I leave this conversation<br>&gt; happily agreeing to disagree, just as I do with some of my other colleagues<br>&gt; here. :) But at least I hope I&#39;ve well explained why I personally view<br>&gt; these solutions as detrimental.<br>&gt;<br>&gt; Thanks,<br>&gt; Ian<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-- <br>Hello majk!<br>das<br>d<br>asd<br>as<br>dasd<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160616/7a579280/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d159199cf75f783132c7274752896e3?s=50"></div><header><strong>Feedback for Dependency Injection Framework?</strong> from <string>Ian Terrell</string> &lt;ian.terrell at gmail.com&gt;<p>June 17, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Tadeas,<br></p><p>I don&#39;t generally use the word &quot;dependency&quot; to cover types that are used by<br>another type; those are simply implementation details of the outer type.<br>There is no VC_B until VC_A decides to present one, so I do not it a<br>dependency; there&#39;s nothing to inject. The creation and presentation of<br>VC_B is just &quot;what happens&quot; when showNestedViewController() is called.<br></p><p>That is perhaps a better phrasing for my point, thank you. The creation of<br>VC_B is an implementation detail of VC_A, which is why VC_A&#39;s true<br>dependencies are so numerous.<br></p><p>As an aside, in apps I have found that sometimes navigation wants to be<br>considered as a separate concern. In that case injecting a protocol based<br>VC factory or a &quot;router&quot; is the way to go in my opinion.<br></p><p>Thanks,<br>Ian<br></p><p>On Thu, Jun 16, 2016 at 5:10 PM, Tadeas Kriz &lt;tadeas at brightify.org&gt; wrote:<br></p><p>&gt; Hi Ian,<br>&gt;<br>&gt; Shouldn&#39;t the `ViewController_B` be a dependency and not be instantiated<br>&gt; inside a `ViewController_A`? Or ViewControllers/Controllers are not<br>&gt; considered dependencies?<br>&gt;<br>&gt; Thanks,<br>&gt; Tadeas<br>&gt;<br>&gt; On Thu, Jun 16, 2016 at 10:50 PM Ian Terrell via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Mike,<br>&gt;&gt;<br>&gt;&gt; Thanks for your response. :) Let me address your points. I apologize for<br>&gt;&gt; the length; this is a topic I care about and I know my co-workers are<br>&gt;&gt; reading it. :)<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to edit the message history for brevity.<br>&gt;&gt;<br>&gt;&gt; My first point of confusion is that these libraries seem to be less about<br>&gt;&gt;&gt;&gt; dependency injection and more about service location. For instance, in your<br>&gt;&gt;&gt;&gt; GitHub example in the playground, we see the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;&gt;&gt;&gt;     let githubURL: TaggedProvider&lt;GithubBaseURL&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;         let url = githubURL.get()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; To my mind it doesn&#39;t look like githubURL was injected. It looks like<br>&gt;&gt;&gt;&gt; it was looked up in a service locator.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not very familiar with the service locator pattern to be honest,<br>&gt;&gt;&gt; however, I can assure you that the base URL is being injected. I think<br>&gt;&gt;&gt; there may be some confusion on either how the GithubListMembersServiceImpl<br>&gt;&gt;&gt; is being constructed, or tagged providers in general.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t believe I&#39;m confused over those features, and I do understand<br>&gt;&gt; that githubURL is being injected from your point of view. What I mean<br>&gt;&gt; though is that it&#39;s being injected from a global location, not from the<br>&gt;&gt; main call site.<br>&gt;&gt;<br>&gt;&gt; In service location code that needs a service asks for it, and the<br>&gt;&gt; service locator provides it. In this case you are asking for a<br>&gt;&gt; GithubBaseURL. The (in my opinion problematic) pattern occurs even if you<br>&gt;&gt; rewrite the service implementation as you did:<br>&gt;&gt;<br>&gt;&gt; struct GithubListMembersServiceImpl : GithubListMembersService {<br>&gt;&gt;&gt;     let githubURL: *NSURL*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;     func listMembers(organizationName: String, handler: [String] -&gt; ()) {<br>&gt;&gt;&gt;         let url = githubURL<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; .URLByAppendingPathComponent(&quot;orgs/\(organizationName)/public_members&quot;)<br>&gt;&gt;&gt;         let dataTask = urlSession.dataTaskWithURL(url) ...<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Definitely from the perspective of GithubListMembersServiceImpl the<br>&gt;&gt; githubURL is injected. That makes it nicely testable and well designed.<br>&gt;&gt; However in this case the service location is merely once removed (and is<br>&gt;&gt; already present in the prior version as well): now your code is asking a<br>&gt;&gt; service locator for the GithubListMembersService (client code will now have<br>&gt;&gt; to call GithubListMembersService.get()).<br>&gt;&gt;<br>&gt;&gt; I see dependency injection as being given your dependencies. I see<br>&gt;&gt; service location as asking for your dependencies. In Cleanse and Dagger and<br>&gt;&gt; Guice I feel like the dependencies are being asked for (the get() method is *asking<br>&gt;&gt; something else* to be provided the call site with an instance).<br>&gt;&gt;<br>&gt;&gt; In this case, I believe your &quot;component&quot; is the service locator.<br>&gt;&gt;<br>&gt;&gt; and then change the binding statement to be<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       binder<br>&gt;&gt;&gt;&gt;        .bind()<br>&gt;&gt;&gt;&gt;        .to(value: NSURL(string: &quot;https://api.github.com&quot;)!)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The downside of this in an actual application is that you may want to<br>&gt;&gt;&gt; inject other URLs. These &quot;Type Tags&quot;  TaggedProviders are essentially<br>&gt;&gt;&gt; just a ...<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And this is why I think Dagger and Guice and Cleanse are improperly<br>&gt;&gt; categorized as dependency injection frameworks. I think in reality they are<br>&gt;&gt; service locators and factories. Dependency injection needs no framework!<br>&gt;&gt;<br>&gt;&gt; With manual dependency injection, when different services want different<br>&gt;&gt; URLs you simply inject them normally.<br>&gt;&gt;<br>&gt;&gt; call site A: MembersServiceImpl(baseURL: productionURL)<br>&gt;&gt; call site B: MembersServiceImpl(baseURL: stagingURL)<br>&gt;&gt;<br>&gt;&gt; That requires that the call sites manage that dependency in order to know<br>&gt;&gt; what to pass (feature not a bug).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve always thought of dependency injection as being a tool for avoiding<br>&gt;&gt;&gt;&gt; global state. But in this case it seems to me like the service locator is<br>&gt;&gt;&gt;&gt; globally managed. The language of service locators is even present in<br>&gt;&gt;&gt;&gt; Guice&#39;s excellent motivation page<br>&gt;&gt;&gt;&gt; &lt;https://github.com/google/guice/wiki/Motivation&gt; (my emphasis):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; The only &quot;global&quot; state are things that are declared singletons. (which<br>&gt;&gt;&gt; are still only singletons in the scope of each time one calls build). They<br>&gt;&gt;&gt; have very similar semantics to singletons in Guice<br>&gt;&gt;&gt; &lt;https://github.com/google/guice/wiki/Scopes&gt; (however no custom scopes<br>&gt;&gt;&gt; yet as mentioned above).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Global is not quite accurate, but it is not terribly close. Your<br>&gt;&gt; Component object tree is what I mean, and I view it (perhaps wrongly) as<br>&gt;&gt; &quot;semi-global.&quot; I get the sense that in most applications there will end up<br>&gt;&gt; being exactly one. A better word is &quot;external&quot;. Now your objects rely on<br>&gt;&gt; external state, whether it is global or semi-global.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; For the former, there was feedback regarding the constructors being<br>&gt;&gt;&gt; implicitly made for structs in this reddit thread<br>&gt;&gt;&gt; &lt;https://www.reddit.com/r/swift/comments/4o2lno/squarecleanse_swift_dependency_injection/d49pu6c&gt;<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You pointed out in that thread that these frameworks make it easier to<br>&gt;&gt; keep up with new dependencies, reordered initializer parameters, etc — but<br>&gt;&gt; all that hiding I fear would lead to poor architectural decisions in<br>&gt;&gt; practice. Too many objects end up depending on too many things, because<br>&gt;&gt; those dependencies are hidden from them. That means that real refactors<br>&gt;&gt; (trying to use these objects in un-forethought contexts, etc) become more<br>&gt;&gt; difficult, and your app actually becomes more tightly coupled (it&#39;s so easy<br>&gt;&gt; to .get() that other object!).<br>&gt;&gt;<br>&gt;&gt;  Guice will inspect the annotated constructor, and *lookup* values for<br>&gt;&gt;&gt; each parameter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cleanse actually achieves the same thing, but without reflection. I<br>&gt;&gt;&gt; attempted to explain it in this part of the README<br>&gt;&gt;&gt; &lt;https://github.com/square/Cleanse/blob/master/README.rst#terminating-methods-top1factory-p1---e-1st-arity&gt;,<br>&gt;&gt;&gt; but I&#39;ll be honest, I struggled while attempting to make it both simple and<br>&gt;&gt;&gt; detailed enough to convey what&#39;s going on.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think I get what&#39;s going on. I only meant that the words &quot;look up&quot;<br>&gt;&gt; imply service location to me. In my mind you&#39;re registering (via bind())<br>&gt;&gt; service factory instructions to the service locator. At runtime, the<br>&gt;&gt; service locator/factory *looks up *how to build it and returns you an<br>&gt;&gt; instance.<br>&gt;&gt;<br>&gt;&gt; Big snippet below for all the context:<br>&gt;&gt;<br>&gt;&gt; Another point I&#39;ve heard people talk about is that these libraries help<br>&gt;&gt;&gt; as dependencies grow. I hope this isn&#39;t a straw man, as I interpret the<br>&gt;&gt;&gt; following line in your README in that way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As the functionality of this app grows, one may add arguments to<br>&gt;&gt;&gt;&gt;&gt; RootViewController and its dependencies as well as more modules to satisfy<br>&gt;&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The argument seems to go that this is easy to maintain:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; init(a: A)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But this is difficult:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; init(a: A, b: B, c: C, d: D, e: E, ...)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The argument goes further by saying that it becomes especially<br>&gt;&gt;&gt;&gt; difficult as you may need to pass the dependencies through the some nodes<br>&gt;&gt;&gt;&gt; of the object graph that seem not to need them. For instance, in the object<br>&gt;&gt;&gt;&gt; graph A -&gt; B -&gt; C, if C has a dependency on Foo but B does not, why should<br>&gt;&gt;&gt;&gt; B know about Foo?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But I find that argument unconvincing on two grounds. First, I believe<br>&gt;&gt;&gt;&gt; an object&#39;s dependencies are the union of its and its children&#39;s<br>&gt;&gt;&gt;&gt; dependencies. In the example above, B has an implicit dependency on Foo.<br>&gt;&gt;&gt;&gt; &quot;Skipping&quot; passing them around or instantiating them in the owning class is<br>&gt;&gt;&gt;&gt; actually only hiding an object&#39;s true dependencies by using global state.<br>&gt;&gt;&gt;&gt; Second, as a single object&#39;s dependencies become more unwieldy it seems in<br>&gt;&gt;&gt;&gt; practice to indicate an architectural problem where objects are doing too<br>&gt;&gt;&gt;&gt; much. These problems are related, as the architectural problem may not be<br>&gt;&gt;&gt;&gt; as visible when the true dependencies are hidden!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So this is an interesting point. I&#39;m a strong believer that DI solves<br>&gt;&gt;&gt; this issue really well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let&#39;s take this example (I think its similar to the straw man you are<br>&gt;&gt;&gt; referring to):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/mikelikespie/c54a017677265322df7eb785d9f36345<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically, VC_A, needs serviceA, and a VC_B to do its job, however, for<br>&gt;&gt;&gt; it to create VC_B it needs VC_B&#39;s dependencies + its transitive<br>&gt;&gt;&gt; dependencies which happen to be serviceA, serviceB, serviceC.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So I agree with the arguments made in the straw man, e.g. don&#39;t need to<br>&gt;&gt;&gt; change the constructor hierarchy all the way down when VC_D needs a new<br>&gt;&gt;&gt; service or needs to start depending on something. It takes a pretty large<br>&gt;&gt;&gt; example to start to see these benefits, but its kind of like how you don&#39;t<br>&gt;&gt;&gt; really see a benefit from a quicksort over a bubble sort until you have a<br>&gt;&gt;&gt; lot of items to sort.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So if we refactor as is (without turning anything into protocols) to use<br>&gt;&gt;&gt; Cleanse, we come up with something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/mikelikespie/3abe371bf7f7ab67f71d6cfa22c0145d<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now, say serviceD incurred a new dependency, one would just add it to<br>&gt;&gt;&gt; its constructor and make sure the dependency is configured... don&#39;t have to<br>&gt;&gt;&gt; change any of the other view controllers in the hierarchy.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ok! So, we&#39;re on the exact same page with the code and the problem, and<br>&gt;&gt; perhaps even the same conclusion, but the exact opposite solutions.<br>&gt;&gt;<br>&gt;&gt; I&#39;m a strong believer that DI solves this issue really well. ... It takes<br>&gt;&gt;&gt; a pretty large example to start to see these benefits<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I believe that true dependency injection is the solution, but I think<br>&gt;&gt; that Cleanse/Dagger/Guice aren&#39;t really providing that in a useful way. I<br>&gt;&gt; think the refactored version using Cleanse is significantly worse than the<br>&gt;&gt; non-refactored version. Additionally, I think the larger the project (in<br>&gt;&gt; your view where it shines), the worse the problem gets (in my view where it<br>&gt;&gt; hinders).<br>&gt;&gt;<br>&gt;&gt; Concretely: In both examples, ViewController_A has dependencies on<br>&gt;&gt; services A, B, C, and D. But only in the non-Cleanse version is that<br>&gt;&gt; visible. This means that it has hidden, non-explicit dependencies, that<br>&gt;&gt; have to be looked up somewhere else. And they&#39;re looked up from the service<br>&gt;&gt; locator/factory VC_A_Component. We cannot use ViewController_A outside of<br>&gt;&gt; the context of that special knowledge and setup.<br>&gt;&gt;<br>&gt;&gt; These frameworks aren&#39;t removing dependencies, they&#39;re hiding them. This<br>&gt;&gt; makes it less easy to reason about the code.<br>&gt;&gt;<br>&gt;&gt; As an example of reasoning, a reader of the component/service locator<br>&gt;&gt; setup in the Cleanse example has to wonder: Why am I binding Services A, B,<br>&gt;&gt; C, and D and VCs A, B, C, and D just to create a single VC_A? Now the<br>&gt;&gt; reader has to inspect all of the view controllers to find out! After which<br>&gt;&gt; she learns, well, VC_A uses S_A and can create a VC_B, which uses S_B and<br>&gt;&gt; can create a VC_C, which uses S_C and can create a VC_D, and VC_D uses S_D.<br>&gt;&gt; All of that information must be discovered and tied together just to get()<br>&gt;&gt; a single VC_A!<br>&gt;&gt;<br>&gt;&gt; In the non-Cleanse example, the question is: Why do I need to instantiate<br>&gt;&gt; VC_A with Services A, B, C, and D? And the answer is simple and comes from<br>&gt;&gt; a single view controller (the one we care about): because VC_A uses S_A can<br>&gt;&gt; create a VC_B and VC_B uses services B, C, and D.<br>&gt;&gt;<br>&gt;&gt; That&#39;s a huge contrast in reasoning, and it&#39;s because<br>&gt;&gt; Cleanse/Dagger/Guice are hiding information in external service locators.<br>&gt;&gt;<br>&gt;&gt; I suppose I might phrase my point of view as saying that I don&#39;t believe<br>&gt;&gt; in transitive dependencies; and definitely not in treating them<br>&gt;&gt; differently. You have your dependencies, and by depending on something else<br>&gt;&gt; that has dependencies, those transitive dependencies are de facto yours,<br>&gt;&gt; directly. They get no special treatment, because they cannot; treating them<br>&gt;&gt; specially relies on external state. That is breaking encapsulation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; This gets me to the next point, testing. VC_A&#39;s purpose is to call<br>&gt;&gt;&gt; serviceA and present a view controller. To properly unit test its<br>&gt;&gt;&gt; functionality, it may not be necessary to provide a concrete implementation<br>&gt;&gt;&gt; of the VC it wants to present. In general if one can test a component and<br>&gt;&gt;&gt; its functionality correctly with less dependencies that&#39;s better.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I would never advocate anything that wasn&#39;t properly and nicely testable.<br>&gt;&gt; I take your point that it seems simpler to test in this setup, but I don&#39;t<br>&gt;&gt; really believe it&#39;s simpler. Again, that&#39;s because the true dependencies<br>&gt;&gt; are hidden.<br>&gt;&gt;<br>&gt;&gt; In the case of manual dependency injection as I advocate, the solution is<br>&gt;&gt; protocols and empty implementations. I agree that empty implementations of<br>&gt;&gt; protocols can be annoying to maintain, but I find they solve the problem<br>&gt;&gt; very well in a clean and &quot;dumb&quot; manner.<br>&gt;&gt;<br>&gt;&gt; For instance, to test VC_A, assuming all the services were protocols, you<br>&gt;&gt; could create an instance solely to test its service A functionality like so:<br>&gt;&gt;<br>&gt;&gt; let testedVC = ViewController_A(serviceA: TestingServiceA(), serviceB:<br>&gt;&gt; DummyServiceB(),<br>&gt;&gt;                                                      serviceC:<br>&gt;&gt; DummyServiceC(), serviceD: DummyServiceD())<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/ianterrell/c86aa1ad64453a214966ac81b31f75e9<br>&gt;&gt;<br>&gt;&gt; I do think there is value in aiding with property injection for the cases<br>&gt;&gt;&gt;&gt; where we can&#39;t use initializer injection (we do often use storyboards at my<br>&gt;&gt;&gt;&gt; company, although we try to keep them small and unwieldy!), but I think<br>&gt;&gt;&gt;&gt; those cases are solved with a few clever extensions. See post-script if<br>&gt;&gt;&gt;&gt; you&#39;re curious.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cleanse does support property injection<br>&gt;&gt;&gt; &lt;https://github.com/square/Cleanse#property-injection&gt;. My examples in<br>&gt;&gt;&gt; the readme only really demonstrate using it for the AppDelegate, but it<br>&gt;&gt;&gt; also makes sense for storyboard injection. It is very explicit though (less<br>&gt;&gt;&gt; magic than other DI frameworks). I also think there would be room for a<br>&gt;&gt;&gt; cleanse extension that specifically deals with storyboards. (I kinda like<br>&gt;&gt;&gt; what RxSwift did with RxCocoa).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, I saw it. I think I only meant that I do see manual property<br>&gt;&gt; injection with UIKit classes as sometimes cumbersome, but I believe there<br>&gt;&gt; are better solutions than frameworks like these.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t believe I&#39;ve misinterpreted your project or it&#39;s documentation. I<br>&gt;&gt; anticipate that we may simply believe in different solutions to the hard<br>&gt;&gt; problem or dependency management. In that case I leave this conversation<br>&gt;&gt; happily agreeing to disagree, just as I do with some of my other colleagues<br>&gt;&gt; here. :) But at least I hope I&#39;ve well explained why I personally view<br>&gt;&gt; these solutions as detrimental.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Ian<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt; --<br>&gt; Hello majk!<br>&gt; das<br>&gt; d<br>&gt; asd<br>&gt; as<br>&gt; dasd<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160617/82027a2c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
