<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ABI of throwing</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Currently, Swift adds a hidden byref error parameter to propagate thrown errors:<br></p><p>&gt; public func foo() throws {<br>&gt; 	throw FooError.error<br>&gt; }<br>&gt; <br>&gt; define void @_TF4test3fooFzT_T_(%swift.refcounted* nocapture readnone, %swift.error** nocapture) #0 {<br>&gt; entry:<br>&gt;   %2 = tail call { %swift.error*, %swift.opaque* } @swift_allocError(/* snip */)<br>&gt;   %3 = extractvalue { %swift.error*, %swift.opaque* } %2, 0<br>&gt;   store %swift.error* %3, %swift.error** %1, align 8<br>&gt;   ret void<br>&gt; }<br></p><p>This means that call sites for throwing functions must always check if an exception occurred. This makes it essentially equivalent to returning an error code in addition to the function&#39;s actual return type.<br></p><p>On the other hand, there are exception handling mechanisms where the execution time cost in the success case is zero, and the error case is expensive. When you throw, the runtime walks through the return addresses on the stack to find out if there&#39;s an associated catch block that can handle the current exception. Apple uses this mechanism &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#id29&gt; (with the Itanium C++ ABI) for C++ and Objective-C exceptions, at least on x86_64.<br></p><p>Other compiler engineers, like Microsoft&#39;s Joe Duffy &lt;http://joeduffyblog.com/2016/02/07/the-error-model/&gt;, have determined that there actually is a non-trivial cost associated to branching for error codes. In exchange for faster error cases, you get slower success cases. This is mildly unfortunate for throwing functions that overwhelmingly succeed.<br></p><p>As Fernando Rodríguez reports in another thread, you have many options to signal errors right now (I took the liberty to add mechanisms that he didn&#39;t cover):<br></p><p>trapping<br>returning nil<br>returning an enum that contains a success case and a bunch of error cases (which is really just a generalization of &quot;returning nil&quot;)<br>throwing<br></p><p>With the current implementation, it seems to me that the main difference between throwing and returning an enum is that catch works even when you don&#39;t know what you&#39;re catching (but I really hope that we can get typed throws for Swift 4, because unless you actually don&#39;t know what you&#39;re catching, this feels like an anti-feature). However, if throwing and returning an enum had different-enough performance characteristics, the guidance could become:<br></p><p>return an enum value if you expect that the function will fail often or if recovery is expected to be cheap;<br>throw if you expect that the function will rarely fail or if recovery is expected to be expensive for at least one failure reason (for example, if you&#39;d have to re-establish a connection after some network error, or if you&#39;d have to start over some UI process because the user picked a file that was deleted before it could be opened).<br></p><p>Additionally, using the native ABI to throw means that you can throw across language boundaries, which might be useful in the possible but distant future in which Swift interops with C++. Even though catching from the other language will probably be tedious, that would already be useful in language sandwiches to unwind correctly (like in Swift that calls C++ that calls Swift, where the topmost Swift code throws).<br></p><p>I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants&quot; or &quot;the cost of changing this isn&#39;t worth the benefit&quot;. Still, I&#39;d like some more insight into why Swift exceptions don&#39;t use the same mechanism as C++ exceptions and Objective-C exceptions. The error handling rationale document is very terse &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#id62&gt; on the implementation design, especially given the length of the rest of the document:<br></p><p>&gt; Error propagation for the kinds of explicit, typed errors that I&#39;ve been focusing on should be handled by implicit manual propagation. It would be good to bias the implementation somewhat towards the non-error path, perhaps by moving error paths to the ends of functions and so on, and perhaps even by processing cleanups with an interpretive approach instead of directly inlining that code, but we should not bias so heavily as to seriously compromise performance. In other words, we should not use table-based unwinding.<br></p><p>I find the rationale somewhat lacking. I can&#39;t pretend that I&#39;ve measured the impact or frequency of retuning a error objects in Objective-C or Swift, and given my access to source code, I probably couldn&#39;t do a comprehensive study. However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. The way it&#39;s phrased here, it feels like this was chosen as a rule of thumb.<br></p><p>Throwing and unwind tables are all over the place in a lot of languages that have exceptions (C++, Java, C#). They throw for a lot of the same reasons that Objective-C frameworks returns errors, and people usually seem content with the performance. Since Swift is co-opting the exception terminology, I think that developers reasonably expect that exceptions will have about the same performance cost as in these other languages.<br></p><p>For binary size concerns, since Swift functions have to annotate whether they throw or not, unless I&#39;m mistaken, there only needs to be exception handler lookup tables for functions that call functions that throw. Java and C# compilers can&#39;t really decide that because it&#39;s assumed that any call could throw. (C++ has `noexcept` and could do this for the subset of functions that only call `noexcept` functions, but the design requires you to be conscious of what can&#39;t throw instead of what can.)<br></p><p>Finally, that error handling rationale doesn&#39;t really give any strong reason to use one of the two more verbose error handling solutions (throwing vs returning a complex enum value) over the other.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/a4f86b27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>ABI of throwing</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  7, 2016 at 09:00:00pm</p></header><div class="content"><p>On Aug 6, 2016, at 7:25 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; This means that call sites for throwing functions must always check if an exception occurred. This makes it essentially equivalent to returning an error code in addition to the function&#39;s actual return type.<br></p><p>Right.<br></p><p>&gt; On the other hand, there are exception handling mechanisms where the execution time cost in the success case is zero, and the error case is expensive. When you throw, the runtime walks through the return addresses on the stack to find out if there&#39;s an associated catch block that can handle the current exception. Apple uses this mechanism &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#id29&gt; (with the Itanium C++ ABI) for C++ and Objective-C exceptions, at least on x86_64.<br>&gt; <br>&gt; Other compiler engineers, like Microsoft&#39;s Joe Duffy &lt;http://joeduffyblog.com/2016/02/07/the-error-model/&gt;, have determined that there actually is a non-trivial cost associated to branching for error codes. In exchange for faster error cases, you get slower success cases. This is mildly unfortunate for throwing functions that overwhelmingly succeed.<br></p><p>Well sure.  However, if you’re comparing against Objective-C and C++, you have to account for an important structural difference.  The compiler for those languages has to assume that *any function* (to a first order approximation) can throw.  In Swift, the language strongly disincentives developers from marking stuff “throw” that can not actually throw (by requiring calls to be marked with ‘try’).<br></p><p>“Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br></p><p>&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br></p><p>I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br></p><p>&gt; or &quot;the cost of changing this isn&#39;t worth the benefit&quot;. Still, I&#39;d like some more insight into why Swift exceptions don&#39;t use the same mechanism as C++ exceptions and Objective-C exceptions. The error handling rationale document is very terse &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#id62&gt; on the implementation design, especially given the length of the rest of the document.<br></p><p>This is simply because it is of interest to fewer people, and no document can anticipate the interest of all readers.  Ask specific questions and we’ll provide specific answers.<br></p><p>&gt;  However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br></p><p>C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br></p><p>&gt; Throwing and unwind tables are all over the place in a lot of languages that have exceptions (C++, Java, C#).<br></p><p>Yes, and many C++ projects build with -fno-exceptions because of the huge code and metadata bloat associated with them.  This is one of many mistakes in C++/Java/etc that we do not want to repeat with Swift.  Additionally, unlike Java, Swift doesn’t generally have the benefit of a JIT compiler that can lazily create these structures on demand.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160807/e44fd6df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ABI of throwing</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  9, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Aug 7, 2016, at 9:36 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;  However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt; <br>&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br></p><p>I believe the language in question was a native-compiled C# variant, not C++.<br></p><p>However, I suspect the numbers from Midori&#39;s experiment may not hold up in Swift. Midori used a generational mark-and-sweep garbage collector, so it didn&#39;t need to write implicit `finally` blocks to release objects owned by stack frames. Swift would. That could easily eat up the promised 7% code size savings, and the reduced ability to jump past frames could similarly damage the speed improvements.<br></p><p>I&#39;m not saying I have the numbers to prove that it does; I don&#39;t. But given our different constraints, there are good reasons to doubt we&#39;d see the same results.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>ABI of throwing</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>August  9, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On 9 Aug 2016, at 08:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Aug 7, 2016, at 9:36 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt;&gt; <br>&gt;&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br>&gt; <br>&gt; I believe the language in question was a native-compiled C# variant, not C++.<br>&gt; <br>&gt; However, I suspect the numbers from Midori&#39;s experiment may not hold up in Swift.<br></p><p>Ah, there is where the study was from/about. There was actually a great blog by one of the main engineers about Project Midolo and the tales of its Safeties :). The reaction to it and the pushback in the Windows community make me think that either they were theoretical baboons or geniuses as sometimes quoting that project can be so polarising :).<br></p><p>&gt; Midori used a generational mark-and-sweep garbage collector, so it didn&#39;t need to write implicit `finally` blocks to release objects owned by stack frames. Swift would. That could easily eat up the promised 7% code size savings, and the reduced ability to jump past frames could similarly damage the speed improvements.<br>&gt; <br>&gt; I&#39;m not saying I have the numbers to prove that it does; I don&#39;t. But given our different constraints, there are good reasons to doubt we&#39;d see the same results.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/34a9932e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ABI of throwing</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  9, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; “Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br></p><p>Anecdote: I work with a web service that gets several million hits a day. Management loves to use the percentage of succeeding web requests as a measure of overall health. The problem with that metric is that when a web request fails, clients fall in an unhealthy state and stop issuing requests for a while. Therefore, one failing request prevents maybe twenty more that would all have failed if the client hadn&#39;t bailed out, but these don&#39;t show in statistics. This makes us look much better than we actually are.<br></p><p>If I had any amount of experience with DTrace, I&#39;d write a script that logs syscall errors to try and see how the programs that I use react to failures. I&#39;m almost certain that when one thing stops working, most programs backs out of a much bigger process and don&#39;t retry right away. When a program fails to open a file, it&#39;s also failing to read/write to it, or whatever else people normally do after they open files. These things are also expensive, and they&#39;re rarely the type of things that you need to (or even just can) retry in a tight loop. My perception is that the immediate cost of failing, even with expensive throwing, is generally dwarfed by the immediate cost of succeeding, so we&#39;re not necessarily losing out on much.<br></p><p>And if that isn&#39;t the case, there are alternatives to throwing that people are already embracing, to the point where error handling practices seem fractured.<br></p><p>&gt;&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br>&gt; <br>&gt; I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br></p><p>Of course not. All of you have been very nice and patient with us peasants, at least as far as &quot;us&quot; includes me. :) This was meant as a light-hearted reflection on discussing intimate parts of the language, where my best perspective is probably well-understood desktop/server development, whereas the core team has to see that but also needs a high focus on other things that don&#39;t even cross my mind (or at least, that&#39;s the heroic picture I have of you guys).<br></p><p>For instance, my &quot;expensive&quot; stops at &quot;takes a while&quot;. Your &quot;expensive&quot; might mean &quot;takes a while and drains the very finite energy reserves that we have on this tiny device&quot; or something still more expansive. These differences are not always immediately obvious.<br></p><p>&gt;&gt;  However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt; <br>&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br></p><p>The analysis was (probably?) done over C++ and HRESULTs but with the intention of applying it to another language (Midori), and it most likely validated the approach of other languages (essentially everything .NET-based). Several findings of the Midori team are being exported to Microsoft&#39;s new APIs, notably the async everywhere and exceptions everywhere paradigms, and these APIs are callable from both so-called managed programs (GCed) and unmanaged programs (ref-counted).<br></p><p>Swift operations don&#39;t tend to throw very much, which is a net positive, but it seems to me that comparing the impact of Swift throws with another language&#39;s throws is relatively fair. C# isn&#39;t shy of FileNotFoundExceptions, for instance.<br></p><p>&gt; Yes, and many C++ projects build with -fno-exceptions because of the huge code and metadata bloat associated with them.  This is one of many mistakes in C++/Java/etc that we do not want to repeat with Swift.  Additionally, unlike Java, Swift doesn’t generally have the benefit of a JIT compiler that can lazily create these structures on demand.<br></p><p>Yes. I believe that you are familiar with a couple of such C++ projects. :)<br></p><p>As we&#39;ve seemingly agreed, Swift only needs metadata and code for functions that call functions that throw. Also, I understand that we don&#39;t need EH tables with the current approach, but my understanding is that the cleanup code needs to exist regardless of how control is transferred to it. (I have no notion of how big EH table entries have to be, so I won&#39;t attempt any comparison with the size of the equivalent dispatch code. I&#39;m pretty sure that it&#39;s unfavorable.)<br></p><p>All in all, I guess that this is an area of Swift that goes against trends that are overall satisfying in my domain. Of course, I&#39;m writing all of this because I like Swift and I want an ABI that will make it the best choice (or close) for the things that I want to do with it. I&#39;m a little concerned that what&#39;s best for a watch isn&#39;t necessarily what&#39;s best for a server and that what&#39;s best for a compiler back-end isn&#39;t necessarily what&#39;s best for a UI program, but Swift tries position itself for all of these.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>ABI of throwing</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>August  9, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt; “Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br>&gt; <br>&gt; Anecdote: I work with a web service that gets several million hits a day. Management loves to use the percentage of succeeding web requests as a measure of overall health. The problem with that metric is that when a web request fails, clients fall in an unhealthy state and stop issuing requests for a while. Therefore, one failing request prevents maybe twenty more that would all have failed if the client hadn&#39;t bailed out, but these don&#39;t show in statistics. This makes us look much better than we actually are.<br>&gt; <br>&gt; If I had any amount of experience with DTrace, I&#39;d write a script that logs syscall errors to try and see how the programs that I use react to failures. I&#39;m almost certain that when one thing stops working, most programs backs out of a much bigger process and don&#39;t retry right away. When a program fails to open a file, it&#39;s also failing to read/write to it, or whatever else people normally do after they open files. These things are also expensive, and they&#39;re rarely the type of things that you need to (or even just can) retry in a tight loop. My perception is that the immediate cost of failing, even with expensive throwing, is generally dwarfed by the immediate cost of succeeding, so we&#39;re not necessarily losing out on much.<br>&gt; <br>&gt; And if that isn&#39;t the case, there are alternatives to throwing that people are already embracing, to the point where error handling practices seem fractured.<br>&gt; <br>&gt;&gt;&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br>&gt;&gt; <br>&gt;&gt; I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br>&gt; <br>&gt; Of course not. All of you have been very nice and patient with us peasants, at least as far as &quot;us&quot; includes me. :)<br></p><p>Sorry for derailing the actual error handling discussion. I just wanted to say this:<br></p><p>Don&#39;t think less of yourself or devalue your experience and opinions because you don&#39;t write a compiler or a programming language for a living. I don&#39;t do either of those two things either. <br></p><p>A diverse set of perspectives and experiences will only benefit the design of the language and its libraries. <br></p><p>As an example, later when it&#39;s time to discuss concurrency, different contexts and perspectives will have different priorities. For some it will be about responsive UIs, for others it will be parallelism, fault tolerance, distributed programming, and more.<br></p><p>If your perspective isn&#39;t represented in those discussions then that could mean that valuable information isn&#39;t taken into the appropriate consideration. <br></p><p>Even if certain topics can get heated at times, someone&#39;s _idea_ or point of view can be discussed, reasoned about, and be turned down without it in anyway being intended towards that person. <br></p><p>So just like me, try not to get discouraged by all the other smart people on this mailing list that have other experience and know so much about other things than you and I do. :)<br></p><p>That said, back to the discussion about error handling ;)<br></p><p>&gt; This was meant as a light-hearted reflection on discussing intimate parts of the language, where my best perspective is probably well-understood desktop/server development, whereas the core team has to see that but also needs a high focus on other things that don&#39;t even cross my mind (or at least, that&#39;s the heroic picture I have of you guys).<br>&gt; <br>&gt; For instance, my &quot;expensive&quot; stops at &quot;takes a while&quot;. Your &quot;expensive&quot; might mean &quot;takes a while and drains the very finite energy reserves that we have on this tiny device&quot; or something still more expansive. These differences are not always immediately obvious.<br>&gt; <br>&gt;&gt;&gt; However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt;&gt; <br>&gt;&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br>&gt; <br>&gt; The analysis was (probably?) done over C++ and HRESULTs but with the intention of applying it to another language (Midori), and it most likely validated the approach of other languages (essentially everything .NET-based). Several findings of the Midori team are being exported to Microsoft&#39;s new APIs, notably the async everywhere and exceptions everywhere paradigms, and these APIs are callable from both so-called managed programs (GCed) and unmanaged programs (ref-counted).<br>&gt; <br>&gt; Swift operations don&#39;t tend to throw very much, which is a net positive, but it seems to me that comparing the impact of Swift throws with another language&#39;s throws is relatively fair. C# isn&#39;t shy of FileNotFoundExceptions, for instance.<br>&gt; <br>&gt;&gt; Yes, and many C++ projects build with -fno-exceptions because of the huge code and metadata bloat associated with them.  This is one of many mistakes in C++/Java/etc that we do not want to repeat with Swift.  Additionally, unlike Java, Swift doesn’t generally have the benefit of a JIT compiler that can lazily create these structures on demand.<br>&gt; <br>&gt; Yes. I believe that you are familiar with a couple of such C++ projects. :)<br>&gt; <br>&gt; As we&#39;ve seemingly agreed, Swift only needs metadata and code for functions that call functions that throw. Also, I understand that we don&#39;t need EH tables with the current approach, but my understanding is that the cleanup code needs to exist regardless of how control is transferred to it. (I have no notion of how big EH table entries have to be, so I won&#39;t attempt any comparison with the size of the equivalent dispatch code. I&#39;m pretty sure that it&#39;s unfavorable.)<br>&gt; <br>&gt; All in all, I guess that this is an area of Swift that goes against trends that are overall satisfying in my domain. Of course, I&#39;m writing all of this because I like Swift and I want an ABI that will make it the best choice (or close) for the things that I want to do with it. I&#39;m a little concerned that what&#39;s best for a watch isn&#39;t necessarily what&#39;s best for a server and that what&#39;s best for a compiler back-end isn&#39;t necessarily what&#39;s best for a UI program, but Swift tries position itself for all of these.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/77402bd3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ABI of throwing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 8:19 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; “Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br>&gt; <br>&gt; Anecdote: I work with a web service that gets several million hits a day. Management loves to use the percentage of succeeding web requests as a measure of overall health. The problem with that metric is that when a web request fails, clients fall in an unhealthy state and stop issuing requests for a while. Therefore, one failing request prevents maybe twenty more that would all have failed if the client hadn&#39;t bailed out, but these don&#39;t show in statistics. This makes us look much better than we actually are.<br>&gt; <br>&gt; If I had any amount of experience with DTrace, I&#39;d write a script that logs syscall errors to try and see how the programs that I use react to failures. I&#39;m almost certain that when one thing stops working, most programs backs out of a much bigger process and don&#39;t retry right away. When a program fails to open a file, it&#39;s also failing to read/write to it, or whatever else people normally do after they open files. These things are also expensive, and they&#39;re rarely the type of things that you need to (or even just can) retry in a tight loop. My perception is that the immediate cost of failing, even with expensive throwing, is generally dwarfed by the immediate cost of succeeding, so we&#39;re not necessarily losing out on much.<br>&gt; <br>&gt; And if that isn&#39;t the case, there are alternatives to throwing that people are already embracing, to the point where error handling practices seem fractured.<br>&gt; <br>&gt;&gt;&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br>&gt;&gt; <br>&gt;&gt; I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br>&gt; <br>&gt; Of course not. All of you have been very nice and patient with us peasants, at least as far as &quot;us&quot; includes me. :) This was meant as a light-hearted reflection on discussing intimate parts of the language, where my best perspective is probably well-understood desktop/server development, whereas the core team has to see that but also needs a high focus on other things that don&#39;t even cross my mind (or at least, that&#39;s the heroic picture I have of you guys).<br>&gt; <br>&gt; For instance, my &quot;expensive&quot; stops at &quot;takes a while&quot;. Your &quot;expensive&quot; might mean &quot;takes a while and drains the very finite energy reserves that we have on this tiny device&quot; or something still more expansive. These differences are not always immediately obvious.<br>&gt; <br>&gt;&gt;&gt; However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt;&gt; <br>&gt;&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br>&gt; <br>&gt; The analysis was (probably?) done over C++ and HRESULTs but with the intention of applying it to another language (Midori), and it most likely validated the approach of other languages (essentially everything .NET-based). Several findings of the Midori team are being exported to Microsoft&#39;s new APIs, notably the async everywhere and exceptions everywhere paradigms, and these APIs are callable from both so-called managed programs (GCed) and unmanaged programs (ref-counted).<br>&gt; <br>&gt; Swift operations don&#39;t tend to throw very much, which is a net positive, but it seems to me that comparing the impact of Swift throws with another language&#39;s throws is relatively fair. C# isn&#39;t shy of FileNotFoundExceptions, for instance.<br></p><p>I think you may be missing Chris&#39;s point here.<br></p><p>Exception ABIs trade off between two different cases: when the callee throws and when it doesn&#39;t.  (There are multiple dimensions of trade-off here, but let&#39;s just talk about cycle-count performance.)  Suppose that a compiler can implement a call to have cost C if it just &quot;un-implements&quot; exceptions, the way that a C++ compiler does when they&#39;re disabled.  If we hand-wave a bit, we can pretend that all the costs are local and just say that any particular ABI will add cost N to calls that don&#39;t throw and cost Y to calls that do.  Therefore, if calls throw with probability P, ABI 1 will be faster than ABI 2 if:<br>   Y_1 * P +  N_1 * (1 - P) &lt; Y_2 * P +  N_2 * (1 - P)<br></p><p>So what is P?  Well, there&#39;s a really important difference between programming languages.<br></p><p>In C++ or C#, you have to compute P as a proportion of every call made by the program.  (Technically, C++ has a way to annotate that a function doesn&#39;t throw, and it&#39;s possible under very specific circumstances for a C++ or C# implementation to prove that even without an annotation; but for the most part, every call must be assumed to be able to throw.)  Even if exceptions were idiomatically used in C++ for error reporting the way they are in Java and C#, the number of calls to such &quot;failable&quot; functions would still be completely negligible compared to the number of calls to functions that literally cannot throw unless (maybe!) the system runs out of memory.  Therefore, P is tiny — maybe one in a trillion, or one in million in C# if the programmer hasn&#39;t yet discovered the non-throwing APIs for testing file existence.  At that kind of ratio, it becomes imperative to do basically anything you can to move costs out of N.<br></p><p>But in Swift, arbitrary functions can&#39;t throw.  When computing P, the denominator only contains calls to functions that really can report some sort of ordinary semantic failure.  (Unless you&#39;re in something like a rethrows function, but most of those are pretty easy to specialize for non-throwing argument functions.)  So P is a lot higher just to begin with.<br></p><p>Furthermore, there are knock-on effects here.  Error-handling is a really nice way to solve certain kinds of language problem.  (Aside: I keep running into people writing things like JSON deserializers who for some reason insist on making their lives unnecessarily difficult by manually messing around with Optional/Either results or writing their own monad + combinator libraries or what not.  Folks, there&#39;s an error monad built into the language, and it is designed exactly for this kind of error-propagation problem; please just use it.)  But we know from experience that the expense (and other problems) of exception-handling in other languages drives people towards other, much more awkward mechanisms when they expect P to be higher, even if &quot;higher&quot; is still just 1 in 100 or so.  That&#39;s awful; to us, that&#39;s a total language failure.<br></p><p>So the shorter summary of the longer performance argument is that (1) we think that our language choices already make P high enough that the zero-cost trade-offs are questionable and (2) those trade-offs, while completely correct for other languages, are known to severely distort the ways that programmers use exceptions in those languages, leading to worse code and more bugs.  So that&#39;s why we aren&#39;t using zero-cost exceptions in Swift.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/7874c455/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ABI of throwing</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  9, 2016 at 07:00:00pm</p></header><div class="content"><p>No, I fully understand this. My point is that this doesn&#39;t seem to accurately represent the cost of exceptions.<br></p><p>In a JSON parser, since the topic has been brought up, you don&#39;t have Y*P calls that succeed and N*(1-P) calls that fail. You have Y*P calls that succeed and *at most one* call that fails. That&#39;s because once you hit the (1-P), you stop parsing. This heavily biases calls in favor of succeeding, which is what I tried to illustrate with my anecdote.<br></p><p>I haven&#39;t attempted statistics in a while, but that looks like a geometric distribution to me. That would give something like:<br></p><p>Y_1 * (1/P) + N_1 &lt; Y_2 * (1/P) + N_2<br></p><p>in which Y completely dominates N, especially as P goes smaller.<br></p><p>Félix<br></p><p>&gt; Le 9 août 2016 à 16:22:08, John McCall &lt;rjmccall at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 9, 2016, at 8:19 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; “Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br>&gt;&gt; <br>&gt;&gt; Anecdote: I work with a web service that gets several million hits a day. Management loves to use the percentage of succeeding web requests as a measure of overall health. The problem with that metric is that when a web request fails, clients fall in an unhealthy state and stop issuing requests for a while. Therefore, one failing request prevents maybe twenty more that would all have failed if the client hadn&#39;t bailed out, but these don&#39;t show in statistics. This makes us look much better than we actually are.<br>&gt;&gt; <br>&gt;&gt; If I had any amount of experience with DTrace, I&#39;d write a script that logs syscall errors to try and see how the programs that I use react to failures. I&#39;m almost certain that when one thing stops working, most programs backs out of a much bigger process and don&#39;t retry right away. When a program fails to open a file, it&#39;s also failing to read/write to it, or whatever else people normally do after they open files. These things are also expensive, and they&#39;re rarely the type of things that you need to (or even just can) retry in a tight loop. My perception is that the immediate cost of failing, even with expensive throwing, is generally dwarfed by the immediate cost of succeeding, so we&#39;re not necessarily losing out on much.<br>&gt;&gt; <br>&gt;&gt; And if that isn&#39;t the case, there are alternatives to throwing that people are already embracing, to the point where error handling practices seem fractured.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br>&gt;&gt; <br>&gt;&gt; Of course not. All of you have been very nice and patient with us peasants, at least as far as &quot;us&quot; includes me. :) This was meant as a light-hearted reflection on discussing intimate parts of the language, where my best perspective is probably well-understood desktop/server development, whereas the core team has to see that but also needs a high focus on other things that don&#39;t even cross my mind (or at least, that&#39;s the heroic picture I have of you guys).<br>&gt;&gt; <br>&gt;&gt; For instance, my &quot;expensive&quot; stops at &quot;takes a while&quot;. Your &quot;expensive&quot; might mean &quot;takes a while and drains the very finite energy reserves that we have on this tiny device&quot; or something still more expansive. These differences are not always immediately obvious.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br>&gt;&gt; <br>&gt;&gt; The analysis was (probably?) done over C++ and HRESULTs but with the intention of applying it to another language (Midori), and it most likely validated the approach of other languages (essentially everything .NET-based). Several findings of the Midori team are being exported to Microsoft&#39;s new APIs, notably the async everywhere and exceptions everywhere paradigms, and these APIs are callable from both so-called managed programs (GCed) and unmanaged programs (ref-counted).<br>&gt;&gt; <br>&gt;&gt; Swift operations don&#39;t tend to throw very much, which is a net positive, but it seems to me that comparing the impact of Swift throws with another language&#39;s throws is relatively fair. C# isn&#39;t shy of FileNotFoundExceptions, for instance.<br>&gt; <br>&gt; I think you may be missing Chris&#39;s point here.<br>&gt; <br>&gt; Exception ABIs trade off between two different cases: when the callee throws and when it doesn&#39;t.  (There are multiple dimensions of trade-off here, but let&#39;s just talk about cycle-count performance.)  Suppose that a compiler can implement a call to have cost C if it just &quot;un-implements&quot; exceptions, the way that a C++ compiler does when they&#39;re disabled.  If we hand-wave a bit, we can pretend that all the costs are local and just say that any particular ABI will add cost N to calls that don&#39;t throw and cost Y to calls that do.  Therefore, if calls throw with probability P, ABI 1 will be faster than ABI 2 if:<br>&gt;    Y_1 * P +  N_1 * (1 - P) &lt; Y_2 * P +  N_2 * (1 - P)<br>&gt; <br>&gt; So what is P?  Well, there&#39;s a really important difference between programming languages.<br>&gt; <br>&gt; In C++ or C#, you have to compute P as a proportion of every call made by the program.  (Technically, C++ has a way to annotate that a function doesn&#39;t throw, and it&#39;s possible under very specific circumstances for a C++ or C# implementation to prove that even without an annotation; but for the most part, every call must be assumed to be able to throw.)  Even if exceptions were idiomatically used in C++ for error reporting the way they are in Java and C#, the number of calls to such &quot;failable&quot; functions would still be completely negligible compared to the number of calls to functions that literally cannot throw unless (maybe!) the system runs out of memory.  Therefore, P is tiny — maybe one in a trillion, or one in million in C# if the programmer hasn&#39;t yet discovered the non-throwing APIs for testing file existence.  At that kind of ratio, it becomes imperative to do basically anything you can to move costs out of N.<br>&gt; <br>&gt; But in Swift, arbitrary functions can&#39;t throw.  When computing P, the denominator only contains calls to functions that really can report some sort of ordinary semantic failure.  (Unless you&#39;re in something like a rethrows function, but most of those are pretty easy to specialize for non-throwing argument functions.)  So P is a lot higher just to begin with.<br>&gt; <br>&gt; Furthermore, there are knock-on effects here.  Error-handling is a really nice way to solve certain kinds of language problem.  (Aside: I keep running into people writing things like JSON deserializers who for some reason insist on making their lives unnecessarily difficult by manually messing around with Optional/Either results or writing their own monad + combinator libraries or what not.  Folks, there&#39;s an error monad built into the language, and it is designed exactly for this kind of error-propagation problem; please just use it.)  But we know from experience that the expense (and other problems) of exception-handling in other languages drives people towards other, much more awkward mechanisms when they expect P to be higher, even if &quot;higher&quot; is still just 1 in 100 or so.  That&#39;s awful; to us, that&#39;s a total language failure.<br>&gt; <br>&gt; So the shorter summary of the longer performance argument is that (1) we think that our language choices already make P high enough that the zero-cost trade-offs are questionable and (2) those trade-offs, while completely correct for other languages, are known to severely distort the ways that programmers use exceptions in those languages, leading to worse code and more bugs.  So that&#39;s why we aren&#39;t using zero-cost exceptions in Swift.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/fe7647fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ABI of throwing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 7:00 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; No, I fully understand this. My point is that this doesn&#39;t seem to accurately represent the cost of exceptions.<br>&gt; <br>&gt; In a JSON parser, since the topic has been brought up, you don&#39;t have Y*P calls that succeed and N*(1-P) calls that fail. You have Y*P calls that succeed and *at most one* call that fails. That&#39;s because once you hit the (1-P), you stop parsing. This heavily biases calls in favor of succeeding, which is what I tried to illustrate with my anecdote.<br></p><p>This is true of JSON deserialization, where typically you wouldn&#39;t do something like prospectively deserialize a value one way and then try something else if that fails.  But it&#39;s not true of, say, a parser for a more ambiguous language, or for any number of other applications in which non-terminal failures are more common.<br></p><p>As Joe said, our intended ABI here is to get this down to a single branch-on-nonzero-register instruction immediately after the return, which is an overhead we&#39;re pretty comfortable with.<br></p><p>John.<br></p><p><br>&gt; <br>&gt; I haven&#39;t attempted statistics in a while, but that looks like a geometric distribution to me. That would give something like:<br>&gt; <br>&gt; Y_1 * (1/P) + N_1 &lt; Y_2 * (1/P) + N_2<br>&gt; <br>&gt; in which Y completely dominates N, especially as P goes smaller.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 9 août 2016 à 16:22:08, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 9, 2016, at 8:19 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Zero cost” EH is also *extremely* expensive in the case where an error is actually throw in normal use cases.  This makes it completely inappropriate for use in APIs where errors are expected in edge cases (e.g. file not found errors).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anecdote: I work with a web service that gets several million hits a day. Management loves to use the percentage of succeeding web requests as a measure of overall health. The problem with that metric is that when a web request fails, clients fall in an unhealthy state and stop issuing requests for a while. Therefore, one failing request prevents maybe twenty more that would all have failed if the client hadn&#39;t bailed out, but these don&#39;t show in statistics. This makes us look much better than we actually are.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I had any amount of experience with DTrace, I&#39;d write a script that logs syscall errors to try and see how the programs that I use react to failures. I&#39;m almost certain that when one thing stops working, most programs backs out of a much bigger process and don&#39;t retry right away. When a program fails to open a file, it&#39;s also failing to read/write to it, or whatever else people normally do after they open files. These things are also expensive, and they&#39;re rarely the type of things that you need to (or even just can) retry in a tight loop. My perception is that the immediate cost of failing, even with expensive throwing, is generally dwarfed by the immediate cost of succeeding, so we&#39;re not necessarily losing out on much.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And if that isn&#39;t the case, there are alternatives to throwing that people are already embracing, to the point where error handling practices seem fractured.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure why you think the Swift team would say something that derogatory.  I hope there is no specific action that has led to this belief. If there is, then please let me know.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course not. All of you have been very nice and patient with us peasants, at least as far as &quot;us&quot; includes me. :) This was meant as a light-hearted reflection on discussing intimate parts of the language, where my best perspective is probably well-understood desktop/server development, whereas the core team has to see that but also needs a high focus on other things that don&#39;t even cross my mind (or at least, that&#39;s the heroic picture I have of you guys).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, my &quot;expensive&quot; stops at &quot;takes a while&quot;. Your &quot;expensive&quot; might mean &quot;takes a while and drains the very finite energy reserves that we have on this tiny device&quot; or something still more expansive. These differences are not always immediately obvious.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C++ and Swift are completely different languages in this respect, so the analysis doesn’t translate over.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The analysis was (probably?) done over C++ and HRESULTs but with the intention of applying it to another language (Midori), and it most likely validated the approach of other languages (essentially everything .NET-based). Several findings of the Midori team are being exported to Microsoft&#39;s new APIs, notably the async everywhere and exceptions everywhere paradigms, and these APIs are callable from both so-called managed programs (GCed) and unmanaged programs (ref-counted).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift operations don&#39;t tend to throw very much, which is a net positive, but it seems to me that comparing the impact of Swift throws with another language&#39;s throws is relatively fair. C# isn&#39;t shy of FileNotFoundExceptions, for instance.<br>&gt;&gt; <br>&gt;&gt; I think you may be missing Chris&#39;s point here.<br>&gt;&gt; <br>&gt;&gt; Exception ABIs trade off between two different cases: when the callee throws and when it doesn&#39;t.  (There are multiple dimensions of trade-off here, but let&#39;s just talk about cycle-count performance.)  Suppose that a compiler can implement a call to have cost C if it just &quot;un-implements&quot; exceptions, the way that a C++ compiler does when they&#39;re disabled.  If we hand-wave a bit, we can pretend that all the costs are local and just say that any particular ABI will add cost N to calls that don&#39;t throw and cost Y to calls that do.  Therefore, if calls throw with probability P, ABI 1 will be faster than ABI 2 if:<br>&gt;&gt;    Y_1 * P +  N_1 * (1 - P) &lt; Y_2 * P +  N_2 * (1 - P)<br>&gt;&gt; <br>&gt;&gt; So what is P?  Well, there&#39;s a really important difference between programming languages.<br>&gt;&gt; <br>&gt;&gt; In C++ or C#, you have to compute P as a proportion of every call made by the program.  (Technically, C++ has a way to annotate that a function doesn&#39;t throw, and it&#39;s possible under very specific circumstances for a C++ or C# implementation to prove that even without an annotation; but for the most part, every call must be assumed to be able to throw.)  Even if exceptions were idiomatically used in C++ for error reporting the way they are in Java and C#, the number of calls to such &quot;failable&quot; functions would still be completely negligible compared to the number of calls to functions that literally cannot throw unless (maybe!) the system runs out of memory.  Therefore, P is tiny — maybe one in a trillion, or one in million in C# if the programmer hasn&#39;t yet discovered the non-throwing APIs for testing file existence.  At that kind of ratio, it becomes imperative to do basically anything you can to move costs out of N.<br>&gt;&gt; <br>&gt;&gt; But in Swift, arbitrary functions can&#39;t throw.  When computing P, the denominator only contains calls to functions that really can report some sort of ordinary semantic failure.  (Unless you&#39;re in something like a rethrows function, but most of those are pretty easy to specialize for non-throwing argument functions.)  So P is a lot higher just to begin with.<br>&gt;&gt; <br>&gt;&gt; Furthermore, there are knock-on effects here.  Error-handling is a really nice way to solve certain kinds of language problem.  (Aside: I keep running into people writing things like JSON deserializers who for some reason insist on making their lives unnecessarily difficult by manually messing around with Optional/Either results or writing their own monad + combinator libraries or what not.  Folks, there&#39;s an error monad built into the language, and it is designed exactly for this kind of error-propagation problem; please just use it.)  But we know from experience that the expense (and other problems) of exception-handling in other languages drives people towards other, much more awkward mechanisms when they expect P to be higher, even if &quot;higher&quot; is still just 1 in 100 or so.  That&#39;s awful; to us, that&#39;s a total language failure.<br>&gt;&gt; <br>&gt;&gt; So the shorter summary of the longer performance argument is that (1) we think that our language choices already make P high enough that the zero-cost trade-offs are questionable and (2) those trade-offs, while completely correct for other languages, are known to severely distort the ways that programmers use exceptions in those languages, leading to worse code and more bugs.  So that&#39;s why we aren&#39;t using zero-cost exceptions in Swift.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/713affa6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>ABI of throwing</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>August 10, 2016 at 08:00:00am</p></header><div class="content"><p>I laughed! I&#39;ve had the same thoughts.<br></p><p>Sent from my iPhone<br>&gt; On 10 Aug 2016, at 01:22, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Aside: I keep running into people writing things like JSON deserializers who for some reason insist on making their lives unnecessarily difficult by manually messing around with Optional/Either results or writing their own monad + combinator libraries or what not.  Folks, there&#39;s an error monad built into the language, and it is designed exactly for this kind of error-propagation problem; please just use it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/0ec8033f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>ABI of throwing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 6, 2016, at 7:25 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, Swift adds a hidden byref error parameter to propagate thrown errors:<br>&gt; <br>&gt;&gt; public func foo() throws {<br>&gt;&gt; 	throw FooError.error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; define void @_TF4test3fooFzT_T_(%swift.refcounted* nocapture readnone, %swift.error** nocapture) #0 {<br>&gt;&gt; entry:<br>&gt;&gt;   %2 = tail call { %swift.error*, %swift.opaque* } @swift_allocError(/* snip */)<br>&gt;&gt;   %3 = extractvalue { %swift.error*, %swift.opaque* } %2, 0<br>&gt;&gt;   store %swift.error* %3, %swift.error** %1, align 8<br>&gt;&gt;   ret void<br>&gt;&gt; }<br>&gt; <br>&gt; This means that call sites for throwing functions must always check if an exception occurred. This makes it essentially equivalent to returning an error code in addition to the function&#39;s actual return type.<br></p><p>Note that we don&#39;t currently implement the error handling ABI as we eventually envision it. The plan is for LLVM to eventually lower that %swift.error** parameter to a normally callee-preserved register, which is set to zero by the caller before the call. That way, nonthrowing and &#39;rethrows&#39; functions can cheaply be used where throwing functions are expected, since a nonthrowing callee will just preserve the zero the caller put in the register. And since ARM64 has a handy &#39;branch if nonzero&#39; instruction, this means that a throwing call would only cost two instructions on the success path:<br></p><p>	movz wError, #0<br>	bl _function_that_may_throw<br>	cbnz wError, catch<br>	; happy path continues<br></p><p>Non-taken branches are practically free with modern predictors, and (as Chris noted in his reply) there&#39;s no need for the compiler to emit massive unwind metadata or the runtime to interpret that metadata, so the impact on the success path is small and the error path is still only a branch away. As Chris also noted, we only want people using &#39;throw&#39; in places where errors are expected as part of normal operation, such as file IO or network failures, so we don&#39;t *want* to overly pessimize failure branches.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; On the other hand, there are exception handling mechanisms where the execution time cost in the success case is zero, and the error case is expensive. When you throw, the runtime walks through the return addresses on the stack to find out if there&#39;s an associated catch block that can handle the current exception. Apple uses this mechanism (with the Itanium C++ ABI) for C++ and Objective-C exceptions, at least on x86_64.<br>&gt; <br>&gt; Other compiler engineers, like Microsoft&#39;s Joe Duffy, have determined that there actually is a non-trivial cost associated to branching for error codes. In exchange for faster error cases, you get slower success cases. This is mildly unfortunate for throwing functions that overwhelmingly succeed.<br>&gt; <br>&gt; As Fernando Rodríguez reports in another thread, you have many options to signal errors right now (I took the liberty to add mechanisms that he didn&#39;t cover):<br>&gt; <br>&gt; 	• trapping<br>&gt; 	• returning nil<br>&gt; 	• returning an enum that contains a success case and a bunch of error cases (which is really just a generalization of &quot;returning nil&quot;)<br>&gt; 	• throwing<br>&gt; <br>&gt; With the current implementation, it seems to me that the main difference between throwing and returning an enum is that catch works even when you don&#39;t know what you&#39;re catching (but I really hope that we can get typed throws for Swift 4, because unless you actually don&#39;t know what you&#39;re catching, this feels like an anti-feature). However, if throwing and returning an enum had different-enough performance characteristics, the guidance could become:<br>&gt; <br>&gt; 	• return an enum value if you expect that the function will fail often or if recovery is expected to be cheap;<br>&gt; 	• throw if you expect that the function will rarely fail or if recovery is expected to be expensive for at least one failure reason (for example, if you&#39;d have to re-establish a connection after some network error, or if you&#39;d have to start over some UI process because the user picked a file that was deleted before it could be opened).<br>&gt; <br>&gt; Additionally, using the native ABI to throw means that you can throw across language boundaries, which might be useful in the possible but distant future in which Swift interops with C++. Even though catching from the other language will probably be tedious, that would already be useful in language sandwiches to unwind correctly (like in Swift that calls C++ that calls Swift, where the topmost Swift code throws).<br>&gt; <br>&gt; I don&#39;t really know what to expect in terms of discussion, especially since it may boil down to &quot;we&#39;re experts in this fields and you&#39;re just peasants&quot; or &quot;the cost of changing this isn&#39;t worth the benefit&quot;. Still, I&#39;d like some more insight into why Swift exceptions don&#39;t use the same mechanism as C++ exceptions and Objective-C exceptions. The error handling rationale document is very terse on the implementation design, especially given the length of the rest of the document:<br>&gt; <br>&gt;&gt; Error propagation for the kinds of explicit, typed errors that I&#39;ve been focusing on should be handled by implicit manual propagation. It would be good to bias the implementation somewhat towards the non-error path, perhaps by moving error paths to the ends of functions and so on, and perhaps even by processing cleanups with an interpretive approach instead of directly inlining that code, but we should not bias so heavily as to seriously compromise performance. In other words, we should not use table-based unwinding.<br>&gt; <br>&gt; I find the rationale somewhat lacking. I can&#39;t pretend that I&#39;ve measured the impact or frequency of retuning a error objects in Objective-C or Swift, and given my access to source code, I probably couldn&#39;t do a comprehensive study. However, as linked above, someone did for Microsoft platforms (for Microsoft-platform-style errors) and found that there is an impact. The way it&#39;s phrased here, it feels like this was chosen as a rule of thumb.<br>&gt; <br>&gt; Throwing and unwind tables are all over the place in a lot of languages that have exceptions (C++, Java, C#). They throw for a lot of the same reasons that Objective-C frameworks returns errors, and people usually seem content with the performance. Since Swift is co-opting the exception terminology, I think that developers reasonably expect that exceptions will have about the same performance cost as in these other languages.<br>&gt; <br>&gt; For binary size concerns, since Swift functions have to annotate whether they throw or not, unless I&#39;m mistaken, there only needs to be exception handler lookup tables for functions that call functions that throw. Java and C# compilers can&#39;t really decide that because it&#39;s assumed that any call could throw. (C++ has `noexcept` and could do this for the subset of functions that only call `noexcept` functions, but the design requires you to be conscious of what can&#39;t throw instead of what can.)<br>&gt; <br>&gt; Finally, that error handling rationale doesn&#39;t really give any strong reason to use one of the two more verbose error handling solutions (throwing vs returning a complex enum value) over the other.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
