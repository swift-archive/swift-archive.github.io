<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Which is the more idiomatic approach for pinning down the type of a generic parameter?</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>I want to write an extension on SequenceType that contains a set of methods named findFirst() that should return the first element that matches the given predicate.<br></p><p>For heterogeneous sequences where the caller is only interested in a specific subtype of elements, it is useful to have a variant of findFirst() that allows somehow specifying the type the caller is interested in so the predicate closure only gets called with that specific type.<br></p><p>That was probably not very easy to understand, but this example hopefully explains it clearly:<br>In an NSView’s subviews array (which are NSViews), find the first NSButton whose state is NSOnState. It would be neat if the predicate closure that checks the state property only gets passed NSButtons and no NSViews because that eliminates type checks in the closure.<br></p><p>I have two candidates for the implementation of this method and I’m looking for the more idiomatic one.<br></p><p>The examples work with a variable called containerView, which is of type NSView.<br></p><p>First try:<br></p><p>extension SequenceType {<br></p><p>    @warn_unused_result<br>    func findFirst&lt;T&gt;(_: T.Type, @noescape matching predicate: T throws -&gt; Bool) rethrows -&gt; T? {<br>        for case let element as T in self where try predicate(element) {<br>            return element<br>        }<br>        return nil<br>    }<br></p><p>}<br></p><p>let result1 = containerView.subviews.findFirst(NSButton.self, matching: { $0.state == NSOnState })<br></p><p>Here, the first parameter (which is ignored in the implementation) pins down the type of the generic parameter. Note that the predicate’s parameter is of type NSButton so there’s no as? or something like that necessary.<br></p><p>But there’s another way to pin down the generic parameter:<br></p><p>extension SequenceType {<br></p><p>    @warn_unused_result<br>    func findFirst&lt;T&gt;(@noescape matching predicate: T throws -&gt; Bool) rethrows -&gt; T? {<br>        for case let element as T in self where try predicate(element) {<br>            return element<br>        }<br>        return nil<br>    }<br></p><p>}<br></p><p>let result2: NSButton? = containerView.subviews.findFirst { $0.state == NSOnState }<br></p><p>This time, the generic parameter is inferred at call site by explicitly specifying the type of the result2 variable.<br></p><p>Note that with this implementation of findFirst() it’s also possible to pin down the generic parameter by giving the closure parameter a specific type:<br></p><p>let result3 = containerView.subviews.findFirst { (button: NSButton) in button.state == NSOnState }<br></p><p><br>The first implementation seems nice to me at the call site because users of the API can’t miss specifying the type of T. But I don’t really like the way NSButton.self looks and from a language standpoint, the first parameter is redundant. It’s even ignored in the implementation!<br></p><p>The second implementation seems more correct to me, but at the call site, it may be easy to miss specifying the resulting variable’s type, which leads to a compiler error that is not 100% obvious to newcomers (“Type of expression is ambiguous without more context” pointing at the $0), which leads to users thinking about what they did wrong, which leads to them coming to me asking how to use this method.<br></p><p><br>I’d love to hear comments on this and what you think is the better way to implement this. If that were a method in the Swift Standard Library, how would you expect it to work?<br></p><p>(Bonus question: Why isn’t there a method like this in the Standard Library?)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160120/d9140306/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Which is the more idiomatic approach for pinning down the type of a generic parameter?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 20, 2016 at 06:00:00pm</p></header><div class="content"><p>What about dropping T, just using Element, and converting Element to the<br>type in your predicate?<br></p><p>zhaoxin<br></p><p>On Wed, Jan 20, 2016 at 6:09 PM, Marco Masser via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I want to write an extension on SequenceType that contains a set of<br>&gt; methods named findFirst() that should return the first element that<br>&gt; matches the given predicate.<br>&gt;<br>&gt; For heterogeneous sequences where the caller is only interested in a<br>&gt; specific subtype of elements, it is useful to have a variant of<br>&gt; findFirst() that allows somehow specifying the type the caller is<br>&gt; interested in so the predicate closure only gets called with that specific<br>&gt; type.<br>&gt;<br>&gt; That was probably not very easy to understand, but this example hopefully<br>&gt; explains it clearly:<br>&gt; In an NSView’s subviews array (which are NSViews), find the first NSButton<br>&gt;  whose state is NSOnState. It would be neat if the predicate closure that<br>&gt; checks the state property only gets passed NSButtons and no NSViews<br>&gt; because that eliminates type checks in the closure.<br>&gt;<br>&gt; I have two candidates for the implementation of this method and I’m<br>&gt; looking for the more idiomatic one.<br>&gt;<br>&gt; The examples work with a variable called containerView, which is of type<br>&gt; NSView.<br>&gt;<br>&gt; First try:<br>&gt;<br>&gt; extension SequenceType {<br>&gt;<br>&gt;     @warn_unused_result<br>&gt;     func findFirst&lt;T&gt;(_: T.Type, @noescape matching predicate: T throws<br>&gt; -&gt; Bool) rethrows -&gt; T? {<br>&gt;         for case let element as T in self where try predicate(element) {<br>&gt;             return element<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let result1 = containerView.subviews.findFirst(NSButton.self, matching: {<br>&gt; $0.state == NSOnState })<br>&gt;<br>&gt; Here, the first parameter (which is ignored in the implementation) pins<br>&gt; down the type of the generic parameter. Note that the predicate’s parameter<br>&gt; is of type NSButton so there’s no as? or something like that necessary.<br>&gt;<br>&gt; But there’s another way to pin down the generic parameter:<br>&gt;<br>&gt; extension SequenceType {<br>&gt;<br>&gt;     @warn_unused_result<br>&gt;     func findFirst&lt;T&gt;(@noescape matching predicate: T throws -&gt; Bool)<br>&gt; rethrows -&gt; T? {<br>&gt;         for case let element as T in self where try predicate(element) {<br>&gt;             return element<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let result2: NSButton? = containerView.subviews.findFirst { $0.state ==<br>&gt; NSOnState }<br>&gt;<br>&gt; This time, the generic parameter is inferred at call site by explicitly<br>&gt; specifying the type of the result2 variable.<br>&gt;<br>&gt; Note that with this implementation of findFirst() it’s also possible to<br>&gt; pin down the generic parameter by giving the closure parameter a specific<br>&gt; type:<br>&gt;<br>&gt; let result3 = containerView.subviews.findFirst { (button: NSButton) in<br>&gt; button.state == NSOnState }<br>&gt;<br>&gt;<br>&gt; The first implementation seems nice to me at the call site because users<br>&gt; of the API can’t miss specifying the type of T. But I don’t really like<br>&gt; the way NSButton.self looks and from a language standpoint, the first<br>&gt; parameter is redundant. It’s even ignored in the implementation!<br>&gt;<br>&gt; The second implementation seems more correct to me, but at the call site,<br>&gt; it may be easy to miss specifying the resulting variable’s type, which<br>&gt; leads to a compiler error that is not 100% obvious to newcomers (“Type of<br>&gt; expression is ambiguous without more context” pointing at the $0), which<br>&gt; leads to users thinking about what they did wrong, which leads to them<br>&gt; coming to me asking how to use this method.<br>&gt;<br>&gt;<br>&gt; I’d love to hear comments on this and what you think is the better way to<br>&gt; implement this. If that were a method in the Swift Standard Library, how<br>&gt; would you expect it to work?<br>&gt;<br>&gt; (Bonus question: Why isn’t there a method like this in the Standard<br>&gt; Library?)<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160120/bacff639/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Which is the more idiomatic approach for pinning down the type of a generic parameter?</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 2016-01-20, at 11:25, zhaoxin肇鑫 &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; What about dropping T, just using Element, and converting Element to the type in your predicate?<br></p><p>As I wrote in my original message, I’m writing a whole set of findFirst() methods and one of them simply takes a predicate and returns an Element:<br></p><p>@warn_unused_result<br>func findFirst(@noescape predicate: Self.Generator.Element throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>    for element in self where try predicate(element) {<br>        return element<br>    }<br>    return nil<br>}<br></p><p>If I understand correctly, you propose to check the type of the passed-in Element in the predicate, like this:<br></p><p>let result1 = containerView.subviews.findFirst { ($0 as? NSButton)?.state == NSOnState }<br></p><p>But that is cumbersome and has a very significant drawback: The type of result1 is now NSView, not NSButton.<br>That’s the whole point for the generic version of the method in my original message: the predicate doesn’t have to check the type, and the result of findFirst() has the type the caller specifies.<br>So to get the same result as with my generic method (but uglier and slower due to more type casts) you’d have to do this:<br></p><p>let result2 = containerView.subviews.findFirst { ($0 as? NSButton)?.state == NSOnState } as? NSButton<br></p><p>I think that’s not very nice compared to how the two generic versions in question look:<br></p><p>let result3 = containerView.subviews.findFirst(NSButton.self, matching: { $0.state == NSOnState })<br>or:<br>let result4: NSButton? = containerView.subviews.findFirst { $0.state == NSOnState }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160120/43a0f0c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Which is the more idiomatic approach for pinning down the type of a generic parameter?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Then I think the function with NSButton.self is the best. It makes least<br>efforts for a programmer to get no mistakes.<br></p><p>zhaoxin<br></p><p>On Wed, Jan 20, 2016 at 7:25 PM, Marco Masser &lt;lists at duckcode.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 2016-01-20, at 11:25, zhaoxin肇鑫 &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; What about dropping T, just using Element, and converting Element to the<br>&gt; type in your predicate?<br>&gt;<br>&gt;<br>&gt; As I wrote in my original message, I’m writing a whole set of findFirst() methods<br>&gt; and one of them simply takes a predicate and returns an Element:<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func findFirst(@noescape predicate: Self.Generator.Element throws -&gt; Bool)<br>&gt; rethrows -&gt; Self.Generator.Element? {<br>&gt;     for element in self where try predicate(element) {<br>&gt;         return element<br>&gt;     }<br>&gt;     return nil<br>&gt; }<br>&gt;<br>&gt; If I understand correctly, you propose to check the type of the passed-in<br>&gt; Element in the predicate, like this:<br>&gt;<br>&gt; let result1 = containerView.subviews.findFirst { ($0 as? NSButton)?.state<br>&gt; == NSOnState }<br>&gt;<br>&gt; But that is cumbersome and has a very significant drawback: The type of<br>&gt; result1 is now NSView, not NSButton.<br>&gt; That’s the whole point for the generic version of the method in my<br>&gt; original message: the predicate doesn’t have to check the type, and the<br>&gt; result of findFirst() has the type the caller specifies.<br>&gt; So to get the same result as with my generic method (but uglier and slower<br>&gt; due to more type casts) you’d have to do this:<br>&gt;<br>&gt; let result2 = containerView.subviews.findFirst { ($0 as? NSButton)?.state<br>&gt; == NSOnState } as? NSButton<br>&gt;<br>&gt; I think that’s not very nice compared to how the two generic versions in<br>&gt; question look:<br>&gt;<br>&gt; let result3 = containerView.subviews.findFirst(NSButton.self, matching: {<br>&gt; $0.state == NSOnState })<br>&gt; or:<br>&gt; let result4: NSButton? = containerView.subviews.findFirst { $0.state ==<br>&gt; NSOnState }<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160120/1d368995/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Which is the more idiomatic approach for pinning down the type of a generic parameter?</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>January 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 2016-01-20, at 13:23, zhaoxin肇鑫 &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; Then I think the function with NSButton.self is the best. It makes least efforts for a programmer to get no mistakes.<br></p><p><br>OK, thank you for your thoughts on this!<br></p><p><br>I thought I’d mention that I got the idea for dropping the type parameter and shifting that to the caller by reading a blog post by Guille Gonzalez:<br>https://medium.com/@gonzalezreal/ios-cell-registration-reusing-with-swift-protocol-extensions-and-generics-c5ac4fb5b75e &lt;https://medium.com/@gonzalezreal/ios-cell-registration-reusing-with-swift-protocol-extensions-and-generics-c5ac4fb5b75e&gt;<br></p><p>The very last code snippet in that blog post does exactly that:<br></p><p>let cell: BookCell = collectionView.dequeueReusableCell(forIndexPath: indexPath)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160120/b5639d98/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
