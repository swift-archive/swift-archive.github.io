<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>Okay, now I&#39;m finally giving this its due—sorry, too much pressure<br>earlier in the day...<br></p><p>on Wed Feb 03 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt; see some consideration given to argument labeling.<br>&gt;<br>&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt; expressed very straightforwardly much more can be made much A minor<br>&gt; point, but I think it’s important to distinguish between<br>&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt; to simplify the rules (even if there are more of them).<br>&gt;<br>&gt; Everything that follows is my preferences, but I generally agree with<br>&gt; Erica’s suggestions in the concrete cases. <br></p><p>I&#39;ll have to go back and have a look at that<br>*goes back to have a look*<br></p><p>Are there cases that add something significant to what I&#39;ve already<br>written?  I didn&#39;t see any.  If you&#39;re saying what I wrote can be<br>improved by covering specific examples, please tell me which ones.<br></p><p>&gt; I also think the emphasis on quasi-grammatical rules-and-roles is<br>&gt; something of a dead-end for design guidelines and won’t include such<br>&gt; considerations in what follows.<br></p><p>Characterizing what we&#39;ve done in the proposed guidelines as emphasizing<br>“quasi-grammatical rules-and-roles” seems like an unnecessary and<br>slightly muddled potshot.  The grammatical stuff in the current document<br>is not in any sense “quasi” and has no connection to the admonition to<br>clarify roles, which I consider to be important.  That said, I&#39;m not at<br>all attached to presenting the guidelines in terms of grammar, so I&#39;m<br>happy to see how your approach works.<br></p><p>&gt; ## RULES<br>&gt;<br>&gt; ### I. Single-Argument Functions:<br>&gt;<br>&gt; #### RULES:<br>&gt;<br>&gt; - general rule: don’t label the first argument<br>&gt; - exceptions:<br>&gt;   - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;   - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;   - (c) the “ecosystem rule” (see section III)<br>&gt;   - (d) the semantics of the argument are non-obvious (see below)<br>&gt;<br>&gt; #### REMARKS:<br>&gt;<br>&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt; for rules (b) and (c)).<br>&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt; would be unclear which of N plausible implementation choices <br></p><p>I think/hope you mean “semantic” rather than “implementation” here.<br></p><p>&gt; you are making, you may wish to label the argument, even if you only<br>&gt; have a single such function”…but, again, it’s hard to find any<br>&gt; examples for (d) that aren’t also some mixture of (b) and/or (c).<br></p><p>Okay, well the fewer (ahem) guidelines, the better.  Let&#39;s pretend you<br>didn&#39;t propose (d) and see how well it works.<br></p><p>&gt; ### II. Multi-Argument Functions:<br>&gt;<br>&gt; #### RULES:<br>&gt;<br>&gt; - general rule: label all arguments<br>&gt; - exceptions:<br>&gt;   - (a) omit the first label whenever the first argument is the<br>&gt;     semantic focus, and the other arguments are some mix of “details,<br>&gt;     adjustments, or modifiers”<br></p><p>This seems to be a different way of expressing something I was getting<br>at with the guidelines I posted to start this thread.  I worry that what<br>it means for an argument to be “the semantic focus” is too vague.  Why<br>is it an improvement over what I wrote?<br></p><p>&gt;   - (b) omit labels entirely whenever argument-ordering is irrelevant<br>&gt;     to the output (see below)<br></p><p>I don&#39;t think you mean this case:<br></p><p>func f(answer answer: Int = 42, message: String = &quot;Hello, world&quot;) {       <br>  print(&quot;\(message)! The answer is \(answer)&quot;)                                  <br>}<br></p><p>Why is this an improvement over the way it&#39;s phrased in the original<br>guidelines proposal: “when the arguments are peers that can&#39;t be<br>usefully distinguished”?<br></p><p>&gt; #### REMARKS:<br>&gt;<br>&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt; methods for which one of the arguments is the semantic focus, that<br>&gt; argument should be the first argument”; this seems pretty widely<br>&gt; followed.<br></p><p>I think using known and well-defined terms like “sentence” (or even<br>lesser-known but well-defined terms like “clause”) is probably much<br>better than using an ill-defined concept like “argument is the semantic<br>focus.”  Even if you can define this concept clearly, it would have to<br>offer some very compelling advantages to be an improvement over<br>something that is already well-established.  What are those?<br></p><p>&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt; and `present(_:animated:completion:)` (née<br>&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;<br>&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt; name would be different: the just-so story for how<br>&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt; name”; that is, the assumption is that functions like<br>&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt; &quot;base convention” and need to be justified.<br></p><p>Okay, I understand it, but I&#39;m not sure why it&#39;s better.  Please explain<br>why this is an improvement over the other approach.<br></p><p>&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;<br>&gt; EG, in a function like:<br>&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt; were.<br>&gt;<br>&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt; arguments should be unlabelled; thus e.g.:<br>&gt;<br>&gt; - min/max: don’t label the arguments<br>&gt; - hypot: don’t label the arguments<br>&gt; - copysign: ideally, label the arguments<br>&gt; - atan2: ideally, label the arguments<br></p><p>Those last two may draw some quibbles from the math domain experts, but<br>I agree with the spirit.<br></p><p>&gt;<br>&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt; functions. <br></p><p>  colorMixer.blend(color1, color2)<br>  track.fade(from: initialVolume, to: targetVolume)<br></p><p><br>&gt; Also, please don’t be mislead by your familiarity with<br>&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt; general principle (argument-ordering) only, but in practice such<br>&gt; highly-familiar “legacy functions” might be best-off given<br>&gt; special-case handling.<br></p><p>Right, so we&#39;d want different examples.<br></p><p>&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;<br>&gt; The previous sections essentially assumed the function names are<br>&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt; argument-labeling preferences.<br>&gt;<br>&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;<br>&gt; The over-arching consideration is what I’ve been calling the<br>&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt; could foreseeably become a member of such—one should aim for<br>&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt; note that method families need not *require* argument labels:<br>&gt;<br>&gt; `contains(_: Point)`<br>&gt; `contains(_: Line)`<br>&gt; `contains(_: Shape)`<br>&gt;<br>&gt; …but they *may* require them, as for example in the `login` function<br>&gt; that has already been discussed.<br>&gt;<br>&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt; consider the following name suggestions:<br>&gt;<br>&gt; `animate(duration:animations:)`<br>&gt; `animate(duration:animations:completion:)`<br>&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;<br>&gt; …where the first three form an obvious family, and the next two are<br>&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;<br>&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt; will be somewhat rare in practice.<br>&gt;<br>&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;<br>&gt; // solo method (not part of any family)<br>&gt; asset.trackWith(trackID)<br>&gt;<br>&gt; // family<br>&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt; asset.allTracksWith(mediaType: ...<br>&gt;<br>&gt; // the below, instead of `trackWith` or `track(<br>&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt; asset.firstTrackWith(mediaType: …)<br>&gt;<br>&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;<br>&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt; similar things should be named similarly, and when semantic<br>&gt; differences are small-enough it makes sense to use argument labels to<br>&gt; make distinctions; different base names should be for functions that<br>&gt; are at least a little different from each other.<br></p><p>This “rule” seems pretty darned vague, even after all this explanation.<br>I don&#39;t see how it could possibly be stated succinctly,<br></p><p>Furthermore, as I wrote to Erica, I have concerns about anything that<br>gives special treatment to method families, specifically:<br></p><p>* I&#39;m wary of adding anything that encourages the creation of<br>  “method families,” which have a higher cognitive overhead than many of<br>  the alternatives.<br>* A guideline that forces you to change an existing non-overloaded API,<br>  just because you are adding an overload, is problematic.<br></p><p><br>&gt; ## GENERAL REMARKS<br>&gt;<br>&gt; Note that with the way I’ve tried to formulate these rules the Swift<br>&gt; standard library should largely stay as-is. In particular:<br>&gt;<br>&gt; - methods without an identifiable “semantic focus” seem rare in a<br>&gt; standard-library context; IMHO they occur naturally, but only really<br>&gt; within UI/application-level code, not “basic building blocks” code<br>&gt; - &quot;method families” seem somewhat unnatural in “Swift-y” code outside<br>&gt; of a small number of special-case scenarios (`contains`, various<br>&gt; `init` families, etc.); they seem more common in UI/application-level<br>&gt; code (e.g. for Objective-C interoperation), as default arguments cover<br>&gt; most of the motivating use-cases<br>&gt;<br>&gt; …and most of the intent in these rules is to free up some room in the<br>&gt; guidelines so that application-level code can be written to the<br>&gt; guidelines without going through bizarre contortions (e.g. no one<br>&gt; would ever have *chosen* `func<br>&gt; dismissViewControllerAnimated(_:completion:)`, and we shouldn’t have<br>&gt; to chose between either (a) using equally-awkward constructs in our<br>&gt; own code or (b) being “non-guideline-compliant”).<br></p><p>I think we can achieve that goal with succinct, well-defined<br>guidelines... provided we choose them correctly.  That&#39;s why I started<br>the thread.<br></p><p>&gt; ## REMARKS ON RULE 3<br>&gt;<br>&gt; Separately, I think rule 3 is a hair too coarse to be a good guideline as-stated.<br>&gt;<br>&gt; I would split the “asking for X by name/identifier/etc.” into two cases:<br>&gt;<br>&gt; - (a) asking for X by some well-known/canonical $ID (e.g., such that<br>&gt; it is a *major* error if no X is found for $ID)<br>&gt; - (b) asking for X by some identifier (without a strong expectation as<br>&gt; to whether or not such an X will or won’t be found)<br>&gt;<br>&gt; …and at least as a code-reader:<br>&gt;<br>&gt; - I have no objection to the proposed rule (3) in scenario (a)<br>&gt; - I find rule (3) very odd in scenario (b)<br>&gt; - I think very differently about scenario (a) and scenario (b), and<br>&gt; would thus prefer that they look different<br></p><p>I see your point, here.  For me, the most obvious way to distinguish<br>these would be by using a verb like “find,” “search,” or “seek” for<br>scenario (b).  I&#39;m not sure the difference needs to be expressed by<br>a different argument labeling choice—but I see how it could be.  Will<br>have to give this one some more thought, thanks.<br></p><p>&gt;&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt; <br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt; <br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;   beginning in the base name and describing the primary semantics of<br>&gt;&gt;   the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                              // but doesn&#39;t describe the primary <br>&gt;&gt;                              // semantics, which are to move in both<br>&gt;&gt;                              // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // the primary semantics, so u gets no<br>&gt;&gt;                              // label. b is an<br>&gt;&gt;                              // option that tunes the primary<br>&gt;&gt;                              // semantics<br>&gt;&gt; <br>&gt;&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;&gt;   conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;   first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                       // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;  universally-understood term.<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;   describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 12:17 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Okay, now I&#39;m finally giving this its due—sorry, too much pressure<br>&gt; earlier in the day…<br></p><p>No need to apologize, you have a commendable dedication to replies.<br></p><p>Especially now that the disagreements are getting to be increasingly-minor.<br></p><p>&gt; on Wed Feb 03 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt;&gt; see some consideration given to argument labeling.<br>&gt;&gt; <br>&gt;&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt;&gt; expressed very straightforwardly much more can be made much A minor<br>&gt;&gt; point, but I think it’s important to distinguish between<br>&gt;&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt;&gt; to simplify the rules (even if there are more of them).<br>&gt;&gt; <br>&gt;&gt; Everything that follows is my preferences, but I generally agree with<br>&gt;&gt; Erica’s suggestions in the concrete cases. <br>&gt; <br>&gt; I&#39;ll have to go back and have a look at that<br>&gt; *goes back to have a look*<br>&gt; <br>&gt; Are there cases that add something significant to what I&#39;ve already<br>&gt; written?  I didn&#39;t see any.  If you&#39;re saying what I wrote can be<br>&gt; improved by covering specific examples, please tell me which ones.<br>&gt; <br>&gt;&gt; I also think the emphasis on quasi-grammatical rules-and-roles is<br>&gt;&gt; something of a dead-end for design guidelines and won’t include such<br>&gt;&gt; considerations in what follows.<br>&gt; <br>&gt; Characterizing what we&#39;ve done in the proposed guidelines as emphasizing<br>&gt; “quasi-grammatical rules-and-roles” seems like an unnecessary and<br>&gt; slightly muddled potshot.  The grammatical stuff in the current document<br>&gt; is not in any sense “quasi” and has no connection to the admonition to<br>&gt; clarify roles, which I consider to be important.  That said, I&#39;m not at<br>&gt; all attached to presenting the guidelines in terms of grammar, so I&#39;m<br>&gt; happy to see how your approach works.<br></p><p>On a re-read your thread-starter has been toned-down enough from before it’s a lot less in that direction, but see the main response below.<br></p><p>&gt; <br>&gt;&gt; ## RULES<br>&gt;&gt; <br>&gt;&gt; ### I. Single-Argument Functions:<br>&gt;&gt; <br>&gt;&gt; #### RULES:<br>&gt;&gt; <br>&gt;&gt; - general rule: don’t label the first argument<br>&gt;&gt; - exceptions:<br>&gt;&gt;  - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;&gt;  - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;&gt;  - (c) the “ecosystem rule” (see section III)<br>&gt;&gt;  - (d) the semantics of the argument are non-obvious (see below)<br>&gt;&gt; <br>&gt;&gt; #### REMARKS:<br>&gt;&gt; <br>&gt;&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt;&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt;&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt;&gt; for rules (b) and (c)).<br>&gt;&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt;&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt;&gt; would be unclear which of N plausible implementation choices <br>&gt; <br>&gt; I think/hope you mean “semantic” rather than “implementation” here.<br>&gt; <br>&gt;&gt; you are making, you may wish to label the argument, even if you only<br>&gt;&gt; have a single such function”…but, again, it’s hard to find any<br>&gt;&gt; examples for (d) that aren’t also some mixture of (b) and/or (c).<br>&gt; <br>&gt; Okay, well the fewer (ahem) guidelines, the better.  Let&#39;s pretend you<br>&gt; didn&#39;t propose (d) and see how well it works.<br>&gt; <br>&gt;&gt; ### II. Multi-Argument Functions:<br>&gt;&gt; <br>&gt;&gt; #### RULES:<br>&gt;&gt; <br>&gt;&gt; - general rule: label all arguments<br>&gt;&gt; - exceptions:<br>&gt;&gt;  - (a) omit the first label whenever the first argument is the<br>&gt;&gt;    semantic focus, and the other arguments are some mix of “details,<br>&gt;&gt;    adjustments, or modifiers”<br>&gt; <br>&gt; This seems to be a different way of expressing something I was getting<br>&gt; at with the guidelines I posted to start this thread.  I worry that what<br>&gt; it means for an argument to be “the semantic focus” is too vague.  Why<br>&gt; is it an improvement over what I wrote?<br></p><p>I address this in the main response.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  - (b) omit labels entirely whenever argument-ordering is irrelevant<br>&gt;&gt;    to the output (see below)<br>&gt; <br>&gt; I don&#39;t think you mean this case:<br>&gt; <br>&gt; func f(answer answer: Int = 42, message: String = &quot;Hello, world&quot;) {       <br>&gt;  print(&quot;\(message)! The answer is \(answer)&quot;)                                  <br>&gt; }<br>&gt; <br>&gt; Why is this an improvement over the way it&#39;s phrased in the original<br>&gt; guidelines proposal: “when the arguments are peers that can&#39;t be<br>&gt; usefully distinguished”?<br></p><p>My framing made more sense to me because “peers” and “can’t easily be distinguished” seemed vaguer than what I *meant*, but based on the counterexample you supplied my phrasing must indeed be too awful to use.<br></p><p>I was trying to replace “peers that can’t usefully be distinguished” (what are peers? what does “can’t be usefully distinguished” actually mean?) with something stronger (perhaps &quot;any permutation of arguments produces indistinguishable results”), but that wouldn’t actually cover all cases either (e.b. `isLessThan`). <br></p><p>&gt; <br>&gt;&gt; #### REMARKS:<br>&gt;&gt; <br>&gt;&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt;&gt; methods for which one of the arguments is the semantic focus, that<br>&gt;&gt; argument should be the first argument”; this seems pretty widely<br>&gt;&gt; followed.<br>&gt; <br>&gt; I think using known and well-defined terms like “sentence” (or even<br>&gt; lesser-known but well-defined terms like “clause”) is probably much<br>&gt; better than using an ill-defined concept like “argument is the semantic<br>&gt; focus.”  Even if you can define this concept clearly, it would have to<br>&gt; offer some very compelling advantages to be an improvement over<br>&gt; something that is already well-established.  What are those?<br></p><p>This is the main reply.<br></p><p>First, I think it’s fair to say that, as-formulated, you can’t simultaneously:<br></p><p>- (a) take the sentence/clause rule seriously (or “use it rigorously”)<br>- (b) justify many of the existing standard-library APIs (and the intended Cocoa imports)<br></p><p>Consider the following examples:<br></p><p>// today:<br>func rangeOfString(searchString: String, options mask: NSStringCompareOptions) -&gt; NSRange<br>func stringByTrimmingCharactersInSet(characterSet: NSCharacterSet) -&gt; String<br>func indexOf(element: Element) -&gt; Index?<br></p><p>// ideal tomorrow, i assume:<br>func rangeOf(searchString: String, options: NSStringCompareOptions) -&gt; NSRange<br>func trimming(characterSet: NSCharacterSet) -&gt; String<br>func indexOf(element: Element) -&gt; Index?<br></p><p>…how do we (b) justify the lack of first-argument labels in that “ideal tomorrow” while still also (a) actually applying the sentence/clause rule? <br></p><p>At least to my eyes, “a, range of b”, “a, trimming b”, and “a, index of b”, are questionable even as clauses, let alone as sentences.<br></p><p>It seems hard to resolve the above without either:<br></p><p>- introducing a *lot* of wiggle-room (“completes a sentence, or would only require some vacuous filler words to complete a sentence”)<br>- complicating it tremendously (one rule for noun-like method names, another for verb-like method names, another for -ing method names, etc.)<br>- weakening the condition from an if-and-only-if *rule* to a “may consider, but also remember other guidelines like ‘omit needless words’&quot;<br></p><p>…and thus although I generally agree with what I see as the *intent* behind the sentence/clause rule, I’m not sure it’s actually a usable rule as-formulated.<br></p><p>If you accept that the “sentence/clause rule” is gone, what’s left of the proposed guideline is the “describes the primary semantics” aspect. <br></p><p>Here, I prefer a formulation for “primary semantic focus” because it seems it leads to easier dispute-resolution. EG, for `addObserver`, it seems easier to get agreement that `playbackController` is somehow the “focus” in uses like the below:<br></p><p>// ignoring the `options:context:` part:<br>playerItem.addObserver(playbackController, forKeyPath: “status”)<br>playerItem.addObserver(playbackController, forKeyPath: “duration”)<br>playerItem.addObserver(playbackController, forKeyPath: “tracks”)<br></p><p>…than to win an argument over whether or not “add observer” describes *enough* of the “primary semantics” of this method to fall under the proposed guideline.<br></p><p>But that’s just an opinion, and on reflection I don’t think “primary semantic focus” is the clearest formulation, either; I just don’t have anything better.<br></p><p>&gt; <br>&gt;&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt;&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt;&gt; and `present(_:animated:completion:)` (née<br>&gt;&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;&gt; <br>&gt;&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt;&gt; name would be different: the just-so story for how<br>&gt;&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt;&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt;&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt;&gt; name”; that is, the assumption is that functions like<br>&gt;&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt;&gt; &quot;base convention” and need to be justified.<br>&gt; <br>&gt; Okay, I understand it, but I&#39;m not sure why it&#39;s better.  Please explain<br>&gt; why this is an improvement over the other approach.<br>&gt; <br>&gt;&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt;&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;&gt; <br>&gt;&gt; EG, in a function like:<br>&gt;&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt;&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt;&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt;&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt;&gt; were.<br>&gt;&gt; <br>&gt;&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt;&gt; arguments should be unlabelled; thus e.g.:<br>&gt;&gt; <br>&gt;&gt; - min/max: don’t label the arguments<br>&gt;&gt; - hypot: don’t label the arguments<br>&gt;&gt; - copysign: ideally, label the arguments<br>&gt;&gt; - atan2: ideally, label the arguments<br>&gt; <br>&gt; Those last two may draw some quibbles from the math domain experts, but<br>&gt; I agree with the spirit.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt;&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt;&gt; functions. <br>&gt; <br>&gt;  colorMixer.blend(color1, color2)<br>&gt;  track.fade(from: initialVolume, to: targetVolume)<br>&gt; <br>&gt; <br>&gt;&gt; Also, please don’t be mislead by your familiarity with<br>&gt;&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt;&gt; general principle (argument-ordering) only, but in practice such<br>&gt;&gt; highly-familiar “legacy functions” might be best-off given<br>&gt;&gt; special-case handling.<br>&gt; <br>&gt; Right, so we&#39;d want different examples.<br>&gt; <br>&gt;&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;&gt; <br>&gt;&gt; The previous sections essentially assumed the function names are<br>&gt;&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt;&gt; argument-labeling preferences.<br>&gt;&gt; <br>&gt;&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;&gt; <br>&gt;&gt; The over-arching consideration is what I’ve been calling the<br>&gt;&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt;&gt; could foreseeably become a member of such—one should aim for<br>&gt;&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt;&gt; note that method families need not *require* argument labels:<br>&gt;&gt; <br>&gt;&gt; `contains(_: Point)`<br>&gt;&gt; `contains(_: Line)`<br>&gt;&gt; `contains(_: Shape)`<br>&gt;&gt; <br>&gt;&gt; …but they *may* require them, as for example in the `login` function<br>&gt;&gt; that has already been discussed.<br>&gt;&gt; <br>&gt;&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt;&gt; consider the following name suggestions:<br>&gt;&gt; <br>&gt;&gt; `animate(duration:animations:)`<br>&gt;&gt; `animate(duration:animations:completion:)`<br>&gt;&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt;&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt;&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;&gt; <br>&gt;&gt; …where the first three form an obvious family, and the next two are<br>&gt;&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;&gt; <br>&gt;&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt;&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt;&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt;&gt; will be somewhat rare in practice.<br>&gt;&gt; <br>&gt;&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;&gt; <br>&gt;&gt; // solo method (not part of any family)<br>&gt;&gt; asset.trackWith(trackID)<br>&gt;&gt; <br>&gt;&gt; // family<br>&gt;&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt;&gt; asset.allTracksWith(mediaType: ...<br>&gt;&gt; <br>&gt;&gt; // the below, instead of `trackWith` or `track(<br>&gt;&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt;&gt; asset.firstTrackWith(mediaType: …)<br>&gt;&gt; <br>&gt;&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;&gt; <br>&gt;&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt;&gt; similar things should be named similarly, and when semantic<br>&gt;&gt; differences are small-enough it makes sense to use argument labels to<br>&gt;&gt; make distinctions; different base names should be for functions that<br>&gt;&gt; are at least a little different from each other.<br>&gt; <br>&gt; This “rule” seems pretty darned vague, even after all this explanation.<br>&gt; I don&#39;t see how it could possibly be stated succinctly,<br>&gt; <br>&gt; Furthermore, as I wrote to Erica, I have concerns about anything that<br>&gt; gives special treatment to method families, specifically:<br>&gt; <br>&gt; * I&#39;m wary of adding anything that encourages the creation of<br>&gt;  “method families,” which have a higher cognitive overhead than many of<br>&gt;  the alternatives.<br>&gt; * A guideline that forces you to change an existing non-overloaded API,<br>&gt;  just because you are adding an overload, is problematic.<br></p><p>Understood, and noted, so I won’t press it, other than to point out that method families have come up independently a few times, which may deserve some consideration.<br></p><p>My own sense is they are rather more common in application-level code than would be ideal in standard library code.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; ## GENERAL REMARKS<br>&gt;&gt; <br>&gt;&gt; Note that with the way I’ve tried to formulate these rules the Swift<br>&gt;&gt; standard library should largely stay as-is. In particular:<br>&gt;&gt; <br>&gt;&gt; - methods without an identifiable “semantic focus” seem rare in a<br>&gt;&gt; standard-library context; IMHO they occur naturally, but only really<br>&gt;&gt; within UI/application-level code, not “basic building blocks” code<br>&gt;&gt; - &quot;method families” seem somewhat unnatural in “Swift-y” code outside<br>&gt;&gt; of a small number of special-case scenarios (`contains`, various<br>&gt;&gt; `init` families, etc.); they seem more common in UI/application-level<br>&gt;&gt; code (e.g. for Objective-C interoperation), as default arguments cover<br>&gt;&gt; most of the motivating use-cases<br>&gt;&gt; <br>&gt;&gt; …and most of the intent in these rules is to free up some room in the<br>&gt;&gt; guidelines so that application-level code can be written to the<br>&gt;&gt; guidelines without going through bizarre contortions (e.g. no one<br>&gt;&gt; would ever have *chosen* `func<br>&gt;&gt; dismissViewControllerAnimated(_:completion:)`, and we shouldn’t have<br>&gt;&gt; to chose between either (a) using equally-awkward constructs in our<br>&gt;&gt; own code or (b) being “non-guideline-compliant”).<br>&gt; <br>&gt; I think we can achieve that goal with succinct, well-defined<br>&gt; guidelines... provided we choose them correctly.  That&#39;s why I started<br>&gt; the thread.<br>&gt; <br>&gt;&gt; ## REMARKS ON RULE 3<br>&gt;&gt; <br>&gt;&gt; Separately, I think rule 3 is a hair too coarse to be a good guideline as-stated.<br>&gt;&gt; <br>&gt;&gt; I would split the “asking for X by name/identifier/etc.” into two cases:<br>&gt;&gt; <br>&gt;&gt; - (a) asking for X by some well-known/canonical $ID (e.g., such that<br>&gt;&gt; it is a *major* error if no X is found for $ID)<br>&gt;&gt; - (b) asking for X by some identifier (without a strong expectation as<br>&gt;&gt; to whether or not such an X will or won’t be found)<br>&gt;&gt; <br>&gt;&gt; …and at least as a code-reader:<br>&gt;&gt; <br>&gt;&gt; - I have no objection to the proposed rule (3) in scenario (a)<br>&gt;&gt; - I find rule (3) very odd in scenario (b)<br>&gt;&gt; - I think very differently about scenario (a) and scenario (b), and<br>&gt;&gt; would thus prefer that they look different<br>&gt; <br>&gt; I see your point, here.  For me, the most obvious way to distinguish<br>&gt; these would be by using a verb like “find,” “search,” or “seek” for<br>&gt; scenario (b).  I&#39;m not sure the difference needs to be expressed by<br>&gt; a different argument labeling choice—but I see how it could be.  Will<br>&gt; have to give this one some more thought, thanks.<br>&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt;&gt; guidelines that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt;&gt; * are understandable by humans<br>&gt;&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;&gt;  beginning in the base name and describing the primary semantics of<br>&gt;&gt;&gt;  the call, it gets no argument label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;&gt;    a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;&gt;                           // doesn&#39;t describe the semantics at all, <br>&gt;&gt;&gt;                           // thus we add a label for b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;&gt;                             // but doesn&#39;t describe the primary <br>&gt;&gt;&gt;                             // semantics, which are to move in both<br>&gt;&gt;&gt;                             // x and y.  Thus, x gets a label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;&gt;                             // the primary semantics, so u gets no<br>&gt;&gt;&gt;                             // label. b is an<br>&gt;&gt;&gt;                             // option that tunes the primary<br>&gt;&gt;&gt;                             // semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;&gt;  all the default argument cases too, so maybe that exception can be<br>&gt;&gt;&gt;  dropped.  We still need the exceptions for full-width type<br>&gt;&gt;&gt;  conversions and indistinguishable peers]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;&gt;  first argument, we skip it in considering this criterion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;&gt;                      // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;&gt;                      // making this determination.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html &lt;https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html&gt;) and at that<br>&gt;&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;&gt; universally-understood term.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;  should go in the base name rather than in a label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;     a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;  ambiguous]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;  go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;  initializers):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;&gt;  *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;&gt;  describe it in the base name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;&gt;     a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;&gt;     let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;&gt;     let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/e399db24/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 7:46, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consider the following examples:<br>&gt; <br>&gt; // today:<br>&gt; func rangeOfString(searchString: String, options mask: NSStringCompareOptions) -&gt; NSRange<br>&gt; func stringByTrimmingCharactersInSet(characterSet: NSCharacterSet) -&gt; String<br>&gt; func indexOf(element: Element) -&gt; Index?<br>&gt; <br>&gt; // ideal tomorrow, i assume:<br>&gt; func rangeOf(searchString: String, options: NSStringCompareOptions) -&gt; NSRange<br>&gt; func trimming(characterSet: NSCharacterSet) -&gt; String<br>&gt; func indexOf(element: Element) -&gt; Index?<br>&gt; <br>&gt; …how do we (b) justify the lack of first-argument labels in that “ideal tomorrow” while still also (a) actually applying the sentence/clause rule? <br>&gt; <br>&gt; At least to my eyes, “a, range of b”, “a, trimming b”, and “a, index of b”, are questionable even as clauses, let alone as sentences.<br>&gt; <br></p><p>&quot;a, trimming b&quot; seems totally fine as a noun phrase to me, along the lines of &quot;my speech, cutting out the parts you don&#39;t like&quot;. The other two are I guess what you&#39;re calling &quot;implicit get&quot; cases; you could also look at them as &quot;(in [receiver])&quot;, i.e. &quot;range (in a) of b&quot; and &quot;index (in a) of b&quot;. I think that extends to other nouny methods like -tracksWithMediaType: – it&#39;s &quot;tracks (in myLibrary) with media type &#39;wax cylinder&#39;&quot;.<br></p><p>(I&#39;m not proposing that we try to make the source code read like that. As long as we&#39;re minimizing ambiguity, maximizing clarity, etc, it doesn&#39;t matter if we&#39;re doing it the same way that English does.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/7850e9cf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
