<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pre-proposal] Forward/Reverse Only Indexing Methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Sorry, I can&#39;t seem to find the original message.<br></p><p>on Tue May 31 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Am 31.05.2016 um 14:46 schrieb Haravikk via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; So for Swift 3 we’re going to have the great new indexing model that<br>&gt;&gt; performs index manipulation through the collection to which an index<br>&gt;&gt; belongs.<br>&gt;&gt; <br>&gt;&gt; However, it retains one of the things I didn’t like about the old<br>&gt;&gt; model, which is that the distinction between forward/backward only<br>&gt;&gt; types is a bit fuzzy, since the single advancedBy() method, now the<br>&gt;&gt; index(:offsetBy:) method, was used for both forward and backward<br>&gt;&gt; movement, which seems contradictory compared to the forward/backward<br>&gt;&gt; only single-step methods.<br>&gt;&gt; <br>&gt;&gt; Anyway, I’m wondering what people’s thoughts would be on tweaking<br>&gt;&gt; the formula slightly such that there are methods that only work in a<br>&gt;&gt; particular direction, i.e- we’d have three main variations of the<br>&gt;&gt; methods like so:<br>&gt;&gt; <br>&gt;&gt;     public func index(_ index:Index, advancedBy:Index.Distance) -&gt;<br>&gt;&gt; Index { … } // Available on forward and bidirectional collections<br>&gt;&gt;     public func index(_ index:Index, reversedBy:Index.Distance) -&gt;<br>&gt;&gt; Index { … } // Available on reverse and bidirectional collections<br>&gt;&gt;     public func index(_ index:Index, offsetBy:Index.Distance) -&gt;<br>&gt;&gt; Index { … } // Available only on bidirectional collections<br>&gt;&gt; <br>&gt;&gt; (note, the naming isn’t definite, as reversed may not be clear<br>&gt;&gt; enough, it’s just an example for now)<br>&gt;&gt; <br>&gt;&gt; There are three reasons I’d prefer this:<br>&gt;&gt; <br>&gt;&gt; The first is that I can pass the same distance into either of the<br>&gt;&gt; first two methods, and any negation etc. is handled internally. In<br>&gt;&gt; essence I shouldn’t have to handle negative distances at all when<br>&gt;&gt; working with the first two methods. So if I’m working with a step<br>&gt;&gt; size of 5, I can just pass that into the appropriate method, I never<br>&gt;&gt; have to do anything with it the value itself.<br></p><p>I don&#39;t understand why that&#39;s an advantage.  The Distance is required to<br>be a signed integer type, so you can always negate it.<br></p><p>&gt;&gt; The second benefit is that there should be no uncertainty about the<br>&gt;&gt; capabilities of the type you’re using; if it doesn’t have the<br>&gt;&gt; index(:reversedBy:) method then you can’t go backwards, same as<br>&gt;&gt; index(before:) and index(after:).<br></p><p>That&#39;s nice... but then you *don&#39;t* propose to handle negation<br>internally in that case?<br></p><p>&gt;&gt; The third and main benefit is that the methods are just more<br>&gt;&gt; explicit about what they do, and what direction you can go in;<br>&gt;&gt; passing negatives into either of the first two would produce errors<br>&gt;&gt; outright, allowing you to pick on mistakes in these cases.<br>&gt;&gt; <br>&gt;&gt; The other main thing is that offsetBy doesn’t indicate whether a<br>&gt;&gt; type supports forward-only offsets, you have to read the<br>&gt;&gt; documentation to determine this either in the method itself or the<br>&gt;&gt; type, whereas the presence or absence of the first two variants are<br>&gt;&gt; pretty clear.<br></p><p>Yes, we are not entirely pleased with the fact that there is no<br>syntactic differentiation between BidirectionalCollection and<br>RandomAccessCollection.  We think protocol refinements are easier to<br>understand when they introduce new requirements.  On the other hand, it<br>is important to have a function, somewhere, that advances an index by N<br>steps, as efficiently as possible based on the collection&#39;s traversal<br>capability.  The natural place for that function is in a protocol<br>requirement.<br></p><p>&gt;&gt; Currently the offsetBy, and the previous advancedBy(), methods<br>&gt;&gt; require forward-only types to produce fatal errors if handed a<br>&gt;&gt; negative distance, <br></p><p>[Nit: actually they don&#39;t; your conforming forward-only Collection can<br>legally produce any result it likes when asked to traverse backward.]<br></p><p>&gt;&gt; and vice versa for backward-only types, <br></p><p>There&#39;s no such thing as a backward-only collection.  If you had one, you<br>might as well exchange the meaning of forward and backward.<br></p><p>&gt;&gt; which can only produce errors at runtime, whereas the presence or<br>&gt;&gt; absence of the first two methods can be handled during<br>&gt;&gt; development. You could still pass a negative value and end up with a<br>&gt;&gt; runtime error instead of course, but for the types of common uses<br>&gt;&gt; they’re intended for you should be unlikely to produce one.<br>&gt;&gt; <br>&gt;&gt; The offsetBy form would still exist for bidirectional collections,<br>&gt;&gt; but would only really be used when you need to do more complex<br>&gt;&gt; index/distance manipulation outside of the type where a calculation<br>&gt;&gt; might produce either positive or negative values (e.g- if you&#39;re<br>&gt;&gt; calculating the distance and don’t know where two indices are in<br>&gt;&gt; relation to each other), the rest of the time you should try to use<br>&gt;&gt; the more specific, single-direction forms as they clarify your<br>&gt;&gt; intent and can help to catch mistakes if you’ve incorrectly<br>&gt;&gt; generated a distance for example.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Just curious what other people’s thoughts are about this?<br></p><p>In general, indexing is a fairly low-level means of access to a<br>collection, as it fundamentally exposes difficult semantics (distinct<br>index instances can refer to the same element, and indices can become<br>invalid).  It is important to make indexing usable, but I&#39;m not very<br>sure the changes you&#39;re proposing would help.  To evaluate that, we<br>should see how your changes affect the writing of algorithms that do<br>indexing, like those in the standard library and in<br>https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift<br></p><p>I suggest you try your changes in the standard library and show us what<br>happens to the algorithms.  Are they clearer?  Would your changes be<br>likely to have prevented a bug?<br></p><p>&gt;&gt; <br>&gt;&gt; I intended to mention this a lot sooner (to change advancedBy), but<br>&gt;&gt; then I find out about the new indexing model so thought I’d wait<br>&gt;&gt; until afterwards, then completely forgot =)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>&gt; I like this idea. The problem is that it would require that we have an<br>&gt; Index.NonNegativeDistance as argument to really make it statically<br>&gt; safe. And we would have to have methods producing these, probably as<br>&gt; optional return values.<br>&gt; Otherwise we won&#39;t have achieved statically safety but effectively<br>&gt; just better documentation about the capabilities of the respective<br>&gt; collection.<br></p><p>As of today, negative index distances have meaning even in a forward<br>collection, since all indices are comparable.  So you can measure the<br>distance between any two indices as long as they are valid in the same<br>collection.  [I&#39;m beginning to regret making all indices comparable a<br>little, but that&#39;s a separate discussion...]<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
