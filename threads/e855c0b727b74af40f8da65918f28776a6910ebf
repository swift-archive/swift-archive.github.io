<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ed9a0d8cd44b62539b141f6c10405db1?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Rob Napier</string> &lt;robnapier at gmail.com&gt;<p>December 13, 2015 at 02:00:00am</p></header><div class="content"><p>I wanted to reopen this discussion that seems to have trailed off.<br>Requesting the return of self was my very first ask of Swift if I remember<br>correctly (https://devforums.apple.com/message/1013085). Continued work in<br>Swift has both strengthened and modified that ask. Here are several of the<br>examples discussed before:<br></p><p>https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>https://gist.github.com/rnapier/478465d1b15e95b98b42<br>https://gist.github.com/rnapier/4213dc64206b17df6935<br>https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br></p><p>I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>actually mean that, since you can use self. without capturing, and<br>sometimes have to, very often in init, so really it&#39;s basically meaningless<br>for that use).<br></p><p>That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>that this may conflict with enum usage. If so, then use another marker. For<br>instance :x or ^x or anything. But implicit self is confusing in a lot of<br>code, can (and does) lead to shadowing bugs, and is very difficult to<br>reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>code review).<br></p><p>Thoughts, David? I agree with your basic proposal; I just want to amend it.<br></p><p>-Rob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/e8550ebf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; But implicit self is confusing in a lot of code<br></p><p>On the other hand, it allows a logical explanation of how you can take code<br>from global scope and put it into an instance scope:<br></p><p>let greeting = &quot;Hello&quot;<br>let name = &quot;Michael&quot;<br></p><p>func greet() {<br>    print(&quot;\(greeting), \(name)&quot;)<br>}<br></p><p>seemlessly becomes<br></p><p>class Greeter {<br></p><p>    let greeting = &quot;Hello&quot;<br>    let name = &quot;Michael&quot;<br></p><p>    func greet() {<br>        print(&quot;\(greeting), \(name)&quot;)<br>    }<br></p><p>}<br></p><p>&gt; can (and does) lead to shadowing bugs,<br></p><p>There are simple strategies that help to minimize the amount of shadowing,<br>e.g.<br></p><p>- only expose the minimum necessary amount of names in any scope<br>- break functions into small part so that it&#39;s easy to see all the local<br>name declarations<br>- not use any globals, or at least name them in a visually different way<br>(UppercaseCamelStyle)<br>- name properties and locals in a different way (classProperty, local_var)<br></p><p>Even without a formal code style, if you tend to make property names longer<br>and local names shorter, your risk of shadowing goes down.<br></p><p>&gt; .x and .f() to mark implicit self. I realize that this may conflict with<br>enum usage.<br></p><p>This will lead to a lot of ambiguity:<br></p><p>func f() {<br>    let x = NSOperation()<br>    .name = &quot;Name&quot; // is it x.name or self.name??<br>   ...<br>}<br></p><p>&gt;  If so, then use another marker. For instance :x or ^x or anything.<br></p><p>This is workable, but still I think this is one of the best points of Swift<br>– the existence of instance scope where names are simply written as-is.<br>This helps implementing patterns like &quot;take a long function and make it<br>into a struct with a bunch of small functions instead&quot;.<br></p><p>&gt; is very difficult to reason about in diffs or any other interface that<br>isn&#39;t an IDE (especially code review)<br></p><p>This is the point where I entirely agree, good code should be easily read<br>in any context.<br>Again, may I suggest you take a look into using a style guide to<br>differentiate visually between local and instance scope?<br></p><p>Ilya<br></p><p>On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt; correctly (https://devforums.apple.com/message/1013085). Continued work<br>&gt; in Swift has both strengthened and modified that ask. Here are several of<br>&gt; the examples discussed before:<br>&gt;<br>&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;<br>&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt; actually mean that, since you can use self. without capturing, and<br>&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt; for that use).<br>&gt;<br>&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt; code review).<br>&gt;<br>&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;<br>&gt; -Rob<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/dc391324/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 13, 2015 at 10:00:00am</p></header><div class="content"><p>Hi Ilya,<br></p><p>Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br></p><p>&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope<br></p><p><br>&gt; This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br></p><p><br>Both of your previous points make sense but they make code editing easier at the expense of readability. For me, readability has always been more important, as we spend most of our time reading than writing code.<br></p><p>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br></p><p><br>I agree that that would potentially add confusion to the grammar. I&#39;ve always liked the @ and @@ prefixes of Ruby for accessing instance and class properties, but I agree that symbols like that would feel a bit foreign in Swift.<br></p><p>David<br></p><p>&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; But implicit self is confusing in a lot of code<br>&gt; <br>&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope:<br>&gt; <br>&gt; let greeting = &quot;Hello&quot;<br>&gt; let name = &quot;Michael&quot;<br>&gt; <br>&gt; func greet() {<br>&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt; }<br>&gt; <br>&gt; seemlessly becomes<br>&gt; <br>&gt; class Greeter {<br>&gt; <br>&gt;     let greeting = &quot;Hello&quot;<br>&gt;     let name = &quot;Michael&quot;<br>&gt; <br>&gt;     func greet() {<br>&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt; <br>&gt; There are simple strategies that help to minimize the amount of shadowing, e.g. <br>&gt; <br>&gt; - only expose the minimum necessary amount of names in any scope <br>&gt; - break functions into small part so that it&#39;s easy to see all the local name declarations<br>&gt; - not use any globals, or at least name them in a visually different way (UppercaseCamelStyle)<br>&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt; <br>&gt; Even without a formal code style, if you tend to make property names longer and local names shorter, your risk of shadowing goes down.<br>&gt; <br>&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with enum usage.<br>&gt; <br>&gt; This will lead to a lot of ambiguity:<br>&gt; <br>&gt; func f() {<br>&gt;     let x = NSOperation()<br>&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt; <br>&gt; This is workable, but still I think this is one of the best points of Swift – the existence of instance scope where names are simply written as-is. This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt; <br>&gt; &gt; is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review)<br>&gt; <br>&gt; This is the point where I entirely agree, good code should be easily read in any context.<br>&gt; Again, may I suggest you take a look into using a style guide to differentiate visually between local and instance scope?<br>&gt; <br>&gt; Ilya<br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt; <br>&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt;&gt; <br>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt;&gt; <br>&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;&gt; <br>&gt;&gt; -Rob<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/e117bd06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; For me, readability has always been more important, as we spend most of<br>our time reading than writing code.<br>Agree.<br></p><p>&gt; but they make code editing easier at the expense of readability.<br>Disagree. This really depends on the example. E.g. which is more readable:<br></p><p>struct Vector {<br>    var dx: Double<br>    var dy: Double<br>    var length: Double { return sqrt(dx*dx + dy*dy) }<br>}<br></p><p>vs<br></p><p>struct Vector {<br>    var dx: Double<br>    var dy: Double<br>    var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>}<br></p><p>struct Vector {<br>    var dx: Double<br>    var dy: Double<br>    var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>}<br></p><p><br></p><p>On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Hi Ilya,<br>&gt;<br>&gt; Why use a style guide when the language can enforce rules to eliminate the<br>&gt; ambiguity?<br>&gt;<br>&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt; code from global scope and put it into an instance scope<br>&gt;<br>&gt;<br>&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;<br>&gt;<br>&gt; Both of your previous points make sense but they make code editing easier<br>&gt; at the expense of readability. For me, readability has always been more<br>&gt; important, as we spend most of our time reading than writing code.<br>&gt;<br>&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;<br>&gt;<br>&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt; Swift.<br>&gt;<br>&gt; David<br>&gt;<br>&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;<br>&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt; code from global scope and put it into an instance scope:<br>&gt;<br>&gt; let greeting = &quot;Hello&quot;<br>&gt; let name = &quot;Michael&quot;<br>&gt;<br>&gt; func greet() {<br>&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt; }<br>&gt;<br>&gt; seemlessly becomes<br>&gt;<br>&gt; class Greeter {<br>&gt;<br>&gt;     let greeting = &quot;Hello&quot;<br>&gt;     let name = &quot;Michael&quot;<br>&gt;<br>&gt;     func greet() {<br>&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;<br>&gt; There are simple strategies that help to minimize the amount of shadowing,<br>&gt; e.g.<br>&gt;<br>&gt; - only expose the minimum necessary amount of names in any scope<br>&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt; name declarations<br>&gt; - not use any globals, or at least name them in a visually different way<br>&gt; (UppercaseCamelStyle)<br>&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;<br>&gt; Even without a formal code style, if you tend to make property names<br>&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;<br>&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with<br>&gt; enum usage.<br>&gt;<br>&gt; This will lead to a lot of ambiguity:<br>&gt;<br>&gt; func f() {<br>&gt;     let x = NSOperation()<br>&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;<br>&gt; This is workable, but still I think this is one of the best points of<br>&gt; Swift – the existence of instance scope where names are simply written<br>&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;<br>&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt; isn&#39;t an IDE (especially code review)<br>&gt;<br>&gt; This is the point where I entirely agree, good code should be easily read<br>&gt; in any context.<br>&gt; Again, may I suggest you take a look into using a style guide to<br>&gt; differentiate visually between local and instance scope?<br>&gt;<br>&gt; Ilya<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued work<br>&gt;&gt; in Swift has both strengthened and modified that ask. Here are several of<br>&gt;&gt; the examples discussed before:<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;<br>&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt; for that use).<br>&gt;&gt;<br>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt; code review).<br>&gt;&gt;<br>&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt; it.<br>&gt;&gt;<br>&gt;&gt; -Rob<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/58e51123/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 13, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt; }<br>&gt; <br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt; }<br></p><p>I don&#39;t agree with you because when reading your first example, I have to make a mental gymnastic to find out if the variables are local/global variables or if they are instance properties. It might seem obvious in a small piece of code like yours, but it becomes less so in a class several hundred of lines long.<br></p><p>&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt; Agree.<br>&gt; <br>&gt; &gt; but they make code editing easier at the expense of readability. <br>&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt; <br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt; }<br>&gt; <br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; Hi Ilya,<br>&gt;&gt; <br>&gt;&gt; Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br>&gt;&gt; <br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Both of your previous points make sense but they make code editing easier at the expense of readability. For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve always liked the @ and @@ prefixes of Ruby for accessing instance and class properties, but I agree that symbols like that would feel a bit foreign in Swift.<br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are simple strategies that help to minimize the amount of shadowing, e.g. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope <br>&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local name declarations<br>&gt;&gt;&gt; - not use any globals, or at least name them in a visually different way (UppercaseCamelStyle)<br>&gt;&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even without a formal code style, if you tend to make property names longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with enum usage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is workable, but still I think this is one of the best points of Swift – the existence of instance scope where names are simply written as-is. This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily read in any context.<br>&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to differentiate visually between local and instance scope?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/35bfe60a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; It might seem obvious in a small piece of code like yours, but it becomes<br>less so in a class several hundred of lines long.<br></p><p>I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>self-dot access will be useful there.<br>But even if we disagree you&#39;re still able to use self-dot access in any<br>place where you feel this to be beneficial without any changes in the<br>language.<br></p><p>&gt; Why use a style guide when the language can enforce rules to eliminate<br>the ambiguity?<br></p><p>Because each project&#39;s situation can be unique. For the same reason there&#39;s<br>no need to rush to add concurrency at the language level without<br>considering other possibilities first.<br></p><p>For the record I would also like it if the &quot;globals must start with an<br>uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>playground, those aren&#39;t true globals).<br></p><p>It still looks to me that if we make compiler enforce that and the<br>&quot;instance names must not start with an uppercase letter&quot; rule this<br>eliminates the ambiguity discussed in this thread.<br></p><p>On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;david at hartbit.com&#39;);&gt;&gt; wrote:<br></p><p>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt; }<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt; }<br>&gt;<br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I don&#39;t agree with you because when reading your first example, I have to<br>&gt; make a mental gymnastic to find out if the variables are local/global<br>&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt; hundred of lines long.<br>&gt;<br>&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;ilya.nikokoshev at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; &gt; For me, readability has always been more important, as we spend most of<br>&gt; our time reading than writing code.<br>&gt; Agree.<br>&gt;<br>&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;<br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt; }<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt; }<br>&gt;<br>&gt; struct Vector {<br>&gt;     var dx: Double<br>&gt;     var dy: Double<br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;david at hartbit.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Ilya,<br>&gt;&gt;<br>&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt; the ambiguity?<br>&gt;&gt;<br>&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt;&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Both of your previous points make sense but they make code editing easier<br>&gt;&gt; at the expense of readability. For me, readability has always been more<br>&gt;&gt; important, as we spend most of our time reading than writing code.<br>&gt;&gt;<br>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt; Swift.<br>&gt;&gt;<br>&gt;&gt; David<br>&gt;&gt;<br>&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;<br>&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;<br>&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;<br>&gt;&gt; func greet() {<br>&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; seemlessly becomes<br>&gt;&gt;<br>&gt;&gt; class Greeter {<br>&gt;&gt;<br>&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;<br>&gt;&gt;     func greet() {<br>&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;<br>&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt; shadowing, e.g.<br>&gt;&gt;<br>&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt;&gt; name declarations<br>&gt;&gt; - not use any globals, or at least name them in a visually different way<br>&gt;&gt; (UppercaseCamelStyle)<br>&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt;<br>&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;<br>&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt; with enum usage.<br>&gt;&gt;<br>&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;<br>&gt;&gt; func f() {<br>&gt;&gt;     let x = NSOperation()<br>&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;<br>&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;<br>&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt;&gt; isn&#39;t an IDE (especially code review)<br>&gt;&gt;<br>&gt;&gt; This is the point where I entirely agree, good code should be easily read<br>&gt;&gt; in any context.<br>&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;<br>&gt;&gt; Ilya<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued work<br>&gt;&gt;&gt; in Swift has both strengthened and modified that ask. Here are several of<br>&gt;&gt;&gt; the examples discussed before:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt;&gt; code review).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt;&gt; it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/fec00bf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 02:00:00pm</p></header><div class="content"><p>I also prefer to keep self. optional.<br></p><p>In the past I wrote a lot code in Java and decided that I want to<br>consistently use &quot;this.&quot; in my code whenever possible. Eclipse even<br>automatically inserted it for me every time I saved the file so I usually<br>didn&#39;t have to write it on my own. Over time I noticed that while it did<br>slightly improve clarity in *some* cases my code started looking like it<br>consists of plenty of this keywords with some actual logic spread in<br>between.<br></p><p>Then Swift was released and I began migrating our Objective-C app to Swift.<br>I noticed that the common approach was to refer to self implicitly whenever<br>possible instead of writing it explicitly and I followed that approach. Now<br>our team has built two large Swift apps which are even broken down into<br>plenty of modules. It happened very very rarely that I had to look up<br>whether a variable access or function call was referring to a local symbol<br>or to one in self. Most of the time it was clear by context.<br></p><p>I liked the result so much that I started writing and converting Java-code<br>the same way and now omit this whenever possible.<br></p><p>*Bottom line:*<br>I agree that referring to symbols in self explicitly does improve clarity<br>in a few cases. But that comes at a high cost where the whole code gets<br>polluted by and hidden between a lot placements of the self keyword. For me<br>the benefits of omitting self for decluttering outweighs the occasional<br>benefit of improved clarity by far.<br></p><p>Also the clarity can be improved easily by the IDE in this case. The IDE<br>can present instance symbols and global symbols visually distinct which<br>removes any remaining ambiguity. So in good IDEs the benefit of requiring<br>an explicit self would even be practically zero.<br></p><p><br>PS: Also note that this discussion of implicitly vs. explicitly would have<br>to also extend to various other occasions like global vs. local vs. nested<br>type names and even type inference, where a variable&#39;s type might also be<br>unclear occasionally unless the IDE supports you.<br></p><p><br>On Sun, Dec 13, 2015 at 11:35 AM, ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; It might seem obvious in a small piece of code like yours, but it<br>&gt; becomes less so in a class several hundred of lines long.<br>&gt;<br>&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>&gt; self-dot access will be useful there.<br>&gt; But even if we disagree you&#39;re still able to use self-dot access in any<br>&gt; place where you feel this to be beneficial without any changes in the<br>&gt; language.<br>&gt;<br>&gt; &gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt; the ambiguity?<br>&gt;<br>&gt; Because each project&#39;s situation can be unique. For the same reason<br>&gt; there&#39;s no need to rush to add concurrency at the language level without<br>&gt; considering other possibilities first.<br>&gt;<br>&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt; playground, those aren&#39;t true globals).<br>&gt;<br>&gt; It still looks to me that if we make compiler enforce that and the<br>&gt; &quot;instance names must not start with an uppercase letter&quot; rule this<br>&gt; eliminates the ambiguity discussed in this thread.<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t agree with you because when reading your first example, I have to<br>&gt;&gt; make a mental gymnastic to find out if the variables are local/global<br>&gt;&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt;&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt;&gt; hundred of lines long.<br>&gt;&gt;<br>&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; For me, readability has always been more important, as we spend most of<br>&gt;&gt; our time reading than writing code.<br>&gt;&gt; Agree.<br>&gt;&gt;<br>&gt;&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt;&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt;&gt;&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both of your previous points make sense but they make code editing<br>&gt;&gt;&gt; easier at the expense of readability. For me, readability has always been<br>&gt;&gt;&gt; more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt;&gt; shadowing, e.g.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt;&gt;&gt; name declarations<br>&gt;&gt;&gt; - not use any globals, or at least name them in a visually different way<br>&gt;&gt;&gt; (UppercaseCamelStyle)<br>&gt;&gt;&gt; - name properties and locals in a different way (classProperty,<br>&gt;&gt;&gt; local_var)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt;&gt; with enum usage.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt;&gt;&gt; isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily<br>&gt;&gt;&gt; read in any context.<br>&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued<br>&gt;&gt;&gt;&gt; work in Swift has both strengthened and modified that ask. Here are several<br>&gt;&gt;&gt;&gt; of the examples discussed before:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt;&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt;&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt;&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt;&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt;&gt;&gt; code review).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/4ef61cbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; I agree that referring to symbols in self explicitly does improve clarity in a few cases. But that comes at a high cost where the whole code gets polluted by and hidden between a lot placements of the self keyword. For me the benefits of omitting self for decluttering outweighs the occasional benefit of improved clarity by far.<br></p><p>It comes at a cost; I think we just disagree on how costly it is. I&#39;ve been doing it in my own code for ages, Objective-C enforces it, has been even more verbose, and it&#39;s Okay as far as I&#39;m concerned.<br></p><p>&gt; Also the clarity can be improved easily by the IDE in this case. The IDE can present instance symbols and global symbols visually distinct which removes any remaining ambiguity. So in good IDEs the benefit of requiring an explicit self would even be practically zero.<br></p><p>What are you thinking about? If you are thinking about coloring, we&#39;ve had a long discussion about it earlier in the mailing list and a majority came to the conclusion that that&#39;s not good enough: many of us are colorblind, or slightly visually impared, or work in an editor that doesn&#39;t provide correct color syntaxing.<br></p><p>&gt; On 13 Dec 2015, at 14:55, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; I also prefer to keep self. optional.<br>&gt; <br>&gt; In the past I wrote a lot code in Java and decided that I want to consistently use &quot;this.&quot; in my code whenever possible. Eclipse even automatically inserted it for me every time I saved the file so I usually didn&#39;t have to write it on my own. Over time I noticed that while it did slightly improve clarity in *some* cases my code started looking like it consists of plenty of this keywords with some actual logic spread in between.<br>&gt; <br>&gt; Then Swift was released and I began migrating our Objective-C app to Swift. I noticed that the common approach was to refer to self implicitly whenever possible instead of writing it explicitly and I followed that approach. Now our team has built two large Swift apps which are even broken down into plenty of modules. It happened very very rarely that I had to look up whether a variable access or function call was referring to a local symbol or to one in self. Most of the time it was clear by context.<br>&gt; <br>&gt; I liked the result so much that I started writing and converting Java-code the same way and now omit this whenever possible.<br>&gt; <br>&gt; *Bottom line:*<br>&gt; I agree that referring to symbols in self explicitly does improve clarity in a few cases. But that comes at a high cost where the whole code gets polluted by and hidden between a lot placements of the self keyword. For me the benefits of omitting self for decluttering outweighs the occasional benefit of improved clarity by far.<br>&gt; <br>&gt; Also the clarity can be improved easily by the IDE in this case. The IDE can present instance symbols and global symbols visually distinct which removes any remaining ambiguity. So in good IDEs the benefit of requiring an explicit self would even be practically zero.<br>&gt; <br>&gt; <br>&gt; PS: Also note that this discussion of implicitly vs. explicitly would have to also extend to various other occasions like global vs. local vs. nested type names and even type inference, where a variable&#39;s type might also be unclear occasionally unless the IDE supports you.<br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 11:35 AM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; It might seem obvious in a small piece of code like yours, but it becomes less so in a class several hundred of lines long.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps self-dot access will be useful there. <br>&gt;&gt; But even if we disagree you&#39;re still able to use self-dot access in any place where you feel this to be beneficial without any changes in the language. <br>&gt;&gt; <br>&gt;&gt; &gt; Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br>&gt;&gt; <br>&gt;&gt; Because each project&#39;s situation can be unique. For the same reason there&#39;s no need to rush to add concurrency at the language level without considering other possibilities first. <br>&gt;&gt; <br>&gt;&gt; For the record I would also like it if the &quot;globals must start with an uppercase letter&quot; rule were enforced by the compiler (well, not in the playground, those aren&#39;t true globals). <br>&gt;&gt; <br>&gt;&gt; It still looks to me that if we make compiler enforce that and the &quot;instance names must not start with an uppercase letter&quot; rule this eliminates the ambiguity discussed in this thread. <br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t agree with you because when reading your first example, I have to make a mental gymnastic to find out if the variables are local/global variables or if they are instance properties. It might seem obvious in a small piece of code like yours, but it becomes less so in a class several hundred of lines long.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; but they make code editing easier at the expense of readability. <br>&gt;&gt;&gt;&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Both of your previous points make sense but they make code editing easier at the expense of readability. For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve always liked the @ and @@ prefixes of Ruby for accessing instance and class properties, but I agree that symbols like that would feel a bit foreign in Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are simple strategies that help to minimize the amount of shadowing, e.g. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope <br>&gt;&gt;&gt;&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local name declarations<br>&gt;&gt;&gt;&gt;&gt;&gt; - not use any globals, or at least name them in a visually different way (UppercaseCamelStyle)<br>&gt;&gt;&gt;&gt;&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even without a formal code style, if you tend to make property names longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with enum usage.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is workable, but still I think this is one of the best points of Swift – the existence of instance scope where names are simply written as-is. This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily read in any context.<br>&gt;&gt;&gt;&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to differentiate visually between local and instance scope?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/e745f047/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>For reference there was another discussion where Swift developers suggested<br>that editors can solve a similar problem:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002040.html<br></p><p>We indeed disagree on cost. Objective-C is a terribly verbose language. I<br>already avoided a lot of self references there by using ivars directly.<br></p><p>Editors have more options than just color to visually distinguish elements<br>esp. for colorblind people. It could for example be underlined, thickened<br>or annotated with a symbol. If the editor isn&#39;t good that doing that then<br>an issue should be opened for the editor instead instead of changing the<br>language imho.<br></p><p><br></p><p>On Sun, Dec 13, 2015 at 4:46 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; I agree that referring to symbols in self explicitly does improve clarity<br>&gt; in a few cases. But that comes at a high cost where the whole code gets<br>&gt; polluted by and hidden between a lot placements of the self keyword. For me<br>&gt; the benefits of omitting self for decluttering outweighs the occasional<br>&gt; benefit of improved clarity by far.<br>&gt;<br>&gt;<br>&gt; It comes at a cost; I think we just disagree on how costly it is. I&#39;ve<br>&gt; been doing it in my own code for ages, Objective-C enforces it, has been<br>&gt; even more verbose, and it&#39;s Okay as far as I&#39;m concerned.<br>&gt;<br>&gt; Also the clarity can be improved easily by the IDE in this case. The IDE<br>&gt; can present instance symbols and global symbols visually distinct which<br>&gt; removes any remaining ambiguity. So in good IDEs the benefit of requiring<br>&gt; an explicit self would even be practically zero.<br>&gt;<br>&gt;<br>&gt; What are you thinking about? If you are thinking about coloring, we&#39;ve had<br>&gt; a long discussion about it earlier in the mailing list and a majority came<br>&gt; to the conclusion that that&#39;s not good enough: many of us are colorblind,<br>&gt; or slightly visually impared, or work in an editor that doesn&#39;t provide<br>&gt; correct color syntaxing.<br>&gt;<br>&gt; On 13 Dec 2015, at 14:55, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; I also prefer to keep self. optional.<br>&gt;<br>&gt; In the past I wrote a lot code in Java and decided that I want to<br>&gt; consistently use &quot;this.&quot; in my code whenever possible. Eclipse even<br>&gt; automatically inserted it for me every time I saved the file so I usually<br>&gt; didn&#39;t have to write it on my own. Over time I noticed that while it did<br>&gt; slightly improve clarity in *some* cases my code started looking like it<br>&gt; consists of plenty of this keywords with some actual logic spread in<br>&gt; between.<br>&gt;<br>&gt; Then Swift was released and I began migrating our Objective-C app to<br>&gt; Swift. I noticed that the common approach was to refer to self implicitly<br>&gt; whenever possible instead of writing it explicitly and I followed that<br>&gt; approach. Now our team has built two large Swift apps which are even broken<br>&gt; down into plenty of modules. It happened very very rarely that I had to<br>&gt; look up whether a variable access or function call was referring to a local<br>&gt; symbol or to one in self. Most of the time it was clear by context.<br>&gt;<br>&gt; I liked the result so much that I started writing and converting Java-code<br>&gt; the same way and now omit this whenever possible.<br>&gt;<br>&gt; *Bottom line:*<br>&gt; I agree that referring to symbols in self explicitly does improve clarity<br>&gt; in a few cases. But that comes at a high cost where the whole code gets<br>&gt; polluted by and hidden between a lot placements of the self keyword. For<br>&gt; me the benefits of omitting self for decluttering outweighs the<br>&gt; occasional benefit of improved clarity by far.<br>&gt;<br>&gt; Also the clarity can be improved easily by the IDE in this case. The IDE<br>&gt; can present instance symbols and global symbols visually distinct which<br>&gt; removes any remaining ambiguity. So in good IDEs the benefit of requiring<br>&gt; an explicit self would even be practically zero.<br>&gt;<br>&gt;<br>&gt; PS: Also note that this discussion of implicitly vs. explicitly would have<br>&gt; to also extend to various other occasions like global vs. local vs. nested<br>&gt; type names and even type inference, where a variable&#39;s type might also be<br>&gt; unclear occasionally unless the IDE supports you.<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 11:35 AM, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; It might seem obvious in a small piece of code like yours, but it<br>&gt;&gt; becomes less so in a class several hundred of lines long.<br>&gt;&gt;<br>&gt;&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>&gt;&gt; self-dot access will be useful there.<br>&gt;&gt; But even if we disagree you&#39;re still able to use self-dot access in any<br>&gt;&gt; place where you feel this to be beneficial without any changes in the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; &gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt; the ambiguity?<br>&gt;&gt;<br>&gt;&gt; Because each project&#39;s situation can be unique. For the same reason<br>&gt;&gt; there&#39;s no need to rush to add concurrency at the language level without<br>&gt;&gt; considering other possibilities first.<br>&gt;&gt;<br>&gt;&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt;&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt;&gt; playground, those aren&#39;t true globals).<br>&gt;&gt;<br>&gt;&gt; It still looks to me that if we make compiler enforce that and the<br>&gt;&gt; &quot;instance names must not start with an uppercase letter&quot; rule this<br>&gt;&gt; eliminates the ambiguity discussed in this thread.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t agree with you because when reading your first example, I have<br>&gt;&gt;&gt; to make a mental gymnastic to find out if the variables are local/global<br>&gt;&gt;&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt;&gt;&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt;&gt;&gt; hundred of lines long.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; For me, readability has always been more important, as we spend most<br>&gt;&gt;&gt; of our time reading than writing code.<br>&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt;&gt;&gt; Disagree. This really depends on the example. E.g. which is more<br>&gt;&gt;&gt; readable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt;&gt;&gt;&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Both of your previous points make sense but they make code editing<br>&gt;&gt;&gt;&gt; easier at the expense of readability. For me, readability has always been<br>&gt;&gt;&gt;&gt; more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt;&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt;&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt;&gt;&gt; shadowing, e.g.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the<br>&gt;&gt;&gt;&gt; local name declarations<br>&gt;&gt;&gt;&gt; - not use any globals, or at least name them in a visually different<br>&gt;&gt;&gt;&gt; way (UppercaseCamelStyle)<br>&gt;&gt;&gt;&gt; - name properties and locals in a different way (classProperty,<br>&gt;&gt;&gt;&gt; local_var)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt;&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt;&gt;&gt; with enum usage.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt;&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt;&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface<br>&gt;&gt;&gt;&gt; that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily<br>&gt;&gt;&gt;&gt; read in any context.<br>&gt;&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt;&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued<br>&gt;&gt;&gt;&gt;&gt; work in Swift has both strengthened and modified that ask. Here are several<br>&gt;&gt;&gt;&gt;&gt; of the examples discussed before:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I<br>&gt;&gt;&gt;&gt;&gt; realize that this may conflict with enum usage. If so, then use another<br>&gt;&gt;&gt;&gt;&gt; marker. For instance :x or ^x or anything. But implicit self is confusing<br>&gt;&gt;&gt;&gt;&gt; in a lot of code, can (and does) lead to shadowing bugs, and is very<br>&gt;&gt;&gt;&gt;&gt; difficult to reason about in diffs or any other interface that isn&#39;t an IDE<br>&gt;&gt;&gt;&gt;&gt; (especially code review).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to<br>&gt;&gt;&gt;&gt;&gt; amend it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/fda966c6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; For the record I would also like it if the &quot;globals must start with an uppercase letter&quot; rule were enforced by the compiler (well, not in the playground, those aren&#39;t true globals). <br></p><p>+1, in the same vein, global a should stand out :)<br></p><p>&gt; On 13 Dec 2015, at 11:35, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; It might seem obvious in a small piece of code like yours, but it becomes less so in a class several hundred of lines long.<br>&gt; <br>&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps self-dot access will be useful there. <br>&gt; But even if we disagree you&#39;re still able to use self-dot access in any place where you feel this to be beneficial without any changes in the language. <br>&gt; <br>&gt; &gt; Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br>&gt; <br>&gt; Because each project&#39;s situation can be unique. For the same reason there&#39;s no need to rush to add concurrency at the language level without considering other possibilities first. <br>&gt; <br>&gt; For the record I would also like it if the &quot;globals must start with an uppercase letter&quot; rule were enforced by the compiler (well, not in the playground, those aren&#39;t true globals). <br>&gt; <br>&gt; It still looks to me that if we make compiler enforce that and the &quot;instance names must not start with an uppercase letter&quot; rule this eliminates the ambiguity discussed in this thread. <br>&gt; <br>&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I don&#39;t agree with you because when reading your first example, I have to make a mental gymnastic to find out if the variables are local/global variables or if they are instance properties. It might seem obvious in a small piece of code like yours, but it becomes less so in a class several hundred of lines long.<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; but they make code editing easier at the expense of readability. <br>&gt;&gt;&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate the ambiguity?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both of your previous points make sense but they make code editing easier at the expense of readability. For me, readability has always been more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve always liked the @ and @@ prefixes of Ruby for accessing instance and class properties, but I agree that symbols like that would feel a bit foreign in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are simple strategies that help to minimize the amount of shadowing, e.g. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope <br>&gt;&gt;&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local name declarations<br>&gt;&gt;&gt;&gt;&gt; - not use any globals, or at least name them in a visually different way (UppercaseCamelStyle)<br>&gt;&gt;&gt;&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even without a formal code style, if you tend to make property names longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with enum usage.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is workable, but still I think this is one of the best points of Swift – the existence of instance scope where names are simply written as-is. This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily read in any context.<br>&gt;&gt;&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to differentiate visually between local and instance scope?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/ccf82a88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;d find it horrible when global variables &amp; functions would suddenly start<br>with an uppercase letter.<br>Right now the distinction is VERY clear: Types start uppercase, anything<br>else lowercase.<br>It should stay that way and the compiler should warn about violations there.<br>As mentioned earlier the IDE can easily help with the distinction between<br>global and non-global symbols anyway.<br></p><p>Enum cases are still a problem here since they are values but start<br>uppercase. But I&#39;m working on a proposal which covers that too.<br></p><p>In any case that&#39;s an unrelated topic and should be discussed separately.<br></p><p>On Sun, Dec 13, 2015 at 4:32 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt; playground, those aren&#39;t true globals).<br>&gt;<br>&gt;<br>&gt; +1, in the same vein, global a should stand out :)<br>&gt;<br>&gt; On 13 Dec 2015, at 11:35, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; It might seem obvious in a small piece of code like yours, but it<br>&gt; becomes less so in a class several hundred of lines long.<br>&gt;<br>&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>&gt; self-dot access will be useful there.<br>&gt; But even if we disagree you&#39;re still able to use self-dot access in any<br>&gt; place where you feel this to be beneficial without any changes in the<br>&gt; language.<br>&gt;<br>&gt; &gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt; the ambiguity?<br>&gt;<br>&gt; Because each project&#39;s situation can be unique. For the same reason<br>&gt; there&#39;s no need to rush to add concurrency at the language level without<br>&gt; considering other possibilities first.<br>&gt;<br>&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt; playground, those aren&#39;t true globals).<br>&gt;<br>&gt; It still looks to me that if we make compiler enforce that and the<br>&gt; &quot;instance names must not start with an uppercase letter&quot; rule this<br>&gt; eliminates the ambiguity discussed in this thread.<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t agree with you because when reading your first example, I have to<br>&gt;&gt; make a mental gymnastic to find out if the variables are local/global<br>&gt;&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt;&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt;&gt; hundred of lines long.<br>&gt;&gt;<br>&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; For me, readability has always been more important, as we spend most of<br>&gt;&gt; our time reading than writing code.<br>&gt;&gt; Agree.<br>&gt;&gt;<br>&gt;&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt;&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Vector {<br>&gt;&gt;     var dx: Double<br>&gt;&gt;     var dy: Double<br>&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt;&gt;&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both of your previous points make sense but they make code editing<br>&gt;&gt;&gt; easier at the expense of readability. For me, readability has always been<br>&gt;&gt;&gt; more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt;&gt; shadowing, e.g.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt;&gt;&gt; name declarations<br>&gt;&gt;&gt; - not use any globals, or at least name them in a visually different way<br>&gt;&gt;&gt; (UppercaseCamelStyle)<br>&gt;&gt;&gt; - name properties and locals in a different way (classProperty,<br>&gt;&gt;&gt; local_var)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt;&gt; with enum usage.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt;&gt;&gt; isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily<br>&gt;&gt;&gt; read in any context.<br>&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued<br>&gt;&gt;&gt;&gt; work in Swift has both strengthened and modified that ask. Here are several<br>&gt;&gt;&gt;&gt; of the examples discussed before:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt;&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt;&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt;&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt;&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt;&gt;&gt; code review).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/4eb26de1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; I&#39;d find it horrible when global variables &amp; functions would suddenly<br>start with an uppercase letter.<br></p><p>Uhm, that&#39;s part of the style guide for existing C- and<br>Objective-C-functions, and by extension in current Swift apps, that target<br>iOS.<br></p><p>They are of course ugly, and the best way to get rid of those is to move<br>gradually all of the free functions and constants into types. And then<br>those names will be accessible via the UpperCaseType.lowerCaseSomething<br>convention. Hopefully Apple does that to the system framworks as well:<br></p><p>CGContextRef UIGraphicsGetCurrentContext() -&gt; CGContext.currentContext<br></p><p>etc.<br></p><p><br>On Sun, Dec 13, 2015 at 6:38 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; I&#39;d find it horrible when global variables &amp; functions would suddenly<br>&gt; start with an uppercase letter.<br>&gt; Right now the distinction is VERY clear: Types start uppercase, anything<br>&gt; else lowercase.<br>&gt; It should stay that way and the compiler should warn about violations<br>&gt; there.<br>&gt; As mentioned earlier the IDE can easily help with the distinction between<br>&gt; global and non-global symbols anyway.<br>&gt;<br>&gt; Enum cases are still a problem here since they are values but start<br>&gt; uppercase. But I&#39;m working on a proposal which covers that too.<br>&gt;<br>&gt; In any case that&#39;s an unrelated topic and should be discussed separately.<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 4:32 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt;&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt;&gt; playground, those aren&#39;t true globals).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1, in the same vein, global a should stand out :)<br>&gt;&gt;<br>&gt;&gt; On 13 Dec 2015, at 11:35, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; It might seem obvious in a small piece of code like yours, but it<br>&gt;&gt; becomes less so in a class several hundred of lines long.<br>&gt;&gt;<br>&gt;&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>&gt;&gt; self-dot access will be useful there.<br>&gt;&gt; But even if we disagree you&#39;re still able to use self-dot access in any<br>&gt;&gt; place where you feel this to be beneficial without any changes in the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; &gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt; the ambiguity?<br>&gt;&gt;<br>&gt;&gt; Because each project&#39;s situation can be unique. For the same reason<br>&gt;&gt; there&#39;s no need to rush to add concurrency at the language level without<br>&gt;&gt; considering other possibilities first.<br>&gt;&gt;<br>&gt;&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt;&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt;&gt; playground, those aren&#39;t true globals).<br>&gt;&gt;<br>&gt;&gt; It still looks to me that if we make compiler enforce that and the<br>&gt;&gt; &quot;instance names must not start with an uppercase letter&quot; rule this<br>&gt;&gt; eliminates the ambiguity discussed in this thread.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t agree with you because when reading your first example, I have<br>&gt;&gt;&gt; to make a mental gymnastic to find out if the variables are local/global<br>&gt;&gt;&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt;&gt;&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt;&gt;&gt; hundred of lines long.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; For me, readability has always been more important, as we spend most<br>&gt;&gt;&gt; of our time reading than writing code.<br>&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt;&gt;&gt; Disagree. This really depends on the example. E.g. which is more<br>&gt;&gt;&gt; readable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make it<br>&gt;&gt;&gt;&gt; into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Both of your previous points make sense but they make code editing<br>&gt;&gt;&gt;&gt; easier at the expense of readability. For me, readability has always been<br>&gt;&gt;&gt;&gt; more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt;&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt;&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt;&gt;&gt; shadowing, e.g.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the<br>&gt;&gt;&gt;&gt; local name declarations<br>&gt;&gt;&gt;&gt; - not use any globals, or at least name them in a visually different<br>&gt;&gt;&gt;&gt; way (UppercaseCamelStyle)<br>&gt;&gt;&gt;&gt; - name properties and locals in a different way (classProperty,<br>&gt;&gt;&gt;&gt; local_var)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt;&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt;&gt;&gt; with enum usage.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt;&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt;&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface<br>&gt;&gt;&gt;&gt; that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily<br>&gt;&gt;&gt;&gt; read in any context.<br>&gt;&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt;&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued<br>&gt;&gt;&gt;&gt;&gt; work in Swift has both strengthened and modified that ask. Here are several<br>&gt;&gt;&gt;&gt;&gt; of the examples discussed before:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I<br>&gt;&gt;&gt;&gt;&gt; realize that this may conflict with enum usage. If so, then use another<br>&gt;&gt;&gt;&gt;&gt; marker. For instance :x or ^x or anything. But implicit self is confusing<br>&gt;&gt;&gt;&gt;&gt; in a lot of code, can (and does) lead to shadowing bugs, and is very<br>&gt;&gt;&gt;&gt;&gt; difficult to reason about in diffs or any other interface that isn&#39;t an IDE<br>&gt;&gt;&gt;&gt;&gt; (especially code review).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to<br>&gt;&gt;&gt;&gt;&gt; amend it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/dc247efa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>I don&#39;t think (Objective-)C styling guides apply to Swift and they<br>shouldn&#39;t.<br></p><p>It&#39;s true a lot of existing MacOS/iOS API is using uppercase for global<br>functions but that&#39;s mostly because there weren&#39;t many different options at<br>that time and in that language. They will likely be improved or replaced<br>over time.<br></p><p>https://developer.apple.com/library/mac/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html<br>I won&#39;t like to see all these global functions start uppercase instead.<br></p><p>Btw your example should read UIGraphics.currentContext instead. It&#39;s part<br>of UIKit, not Core Graphics.<br>But yes, that&#39;s the best way to fix it instead of relying on uppercase<br>letters.<br>The global namespace should have as little functions and variables as<br>possible anyway.<br></p><p><br>On Sun, Dec 13, 2015 at 4:51 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br></p><p>&gt; &gt; I&#39;d find it horrible when global variables &amp; functions would suddenly<br>&gt; start with an uppercase letter.<br>&gt;<br>&gt; Uhm, that&#39;s part of the style guide for existing C- and<br>&gt; Objective-C-functions, and by extension in current Swift apps, that target<br>&gt; iOS.<br>&gt;<br>&gt; They are of course ugly, and the best way to get rid of those is to move<br>&gt; gradually all of the free functions and constants into types. And then<br>&gt; those names will be accessible via the UpperCaseType.lowerCaseSomething<br>&gt; convention. Hopefully Apple does that to the system framworks as well:<br>&gt;<br>&gt; CGContextRef UIGraphicsGetCurrentContext() -&gt; CGContext.currentContext<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 6:38 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;d find it horrible when global variables &amp; functions would suddenly<br>&gt;&gt; start with an uppercase letter.<br>&gt;&gt; Right now the distinction is VERY clear: Types start uppercase, anything<br>&gt;&gt; else lowercase.<br>&gt;&gt; It should stay that way and the compiler should warn about violations<br>&gt;&gt; there.<br>&gt;&gt; As mentioned earlier the IDE can easily help with the distinction between<br>&gt;&gt; global and non-global symbols anyway.<br>&gt;&gt;<br>&gt;&gt; Enum cases are still a problem here since they are values but start<br>&gt;&gt; uppercase. But I&#39;m working on a proposal which covers that too.<br>&gt;&gt;<br>&gt;&gt; In any case that&#39;s an unrelated topic and should be discussed separately.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 4:32 PM, David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt;&gt;&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt;&gt;&gt; playground, those aren&#39;t true globals).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1, in the same vein, global a should stand out :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Dec 2015, at 11:35, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; It might seem obvious in a small piece of code like yours, but it<br>&gt;&gt;&gt; becomes less so in a class several hundred of lines long.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ll be happy to take a look at the specific examples and see if perhaps<br>&gt;&gt;&gt; self-dot access will be useful there.<br>&gt;&gt;&gt; But even if we disagree you&#39;re still able to use self-dot access in any<br>&gt;&gt;&gt; place where you feel this to be beneficial without any changes in the<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because each project&#39;s situation can be unique. For the same reason<br>&gt;&gt;&gt; there&#39;s no need to rush to add concurrency at the language level without<br>&gt;&gt;&gt; considering other possibilities first.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For the record I would also like it if the &quot;globals must start with an<br>&gt;&gt;&gt; uppercase letter&quot; rule were enforced by the compiler (well, not in the<br>&gt;&gt;&gt; playground, those aren&#39;t true globals).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It still looks to me that if we make compiler enforce that and the<br>&gt;&gt;&gt; &quot;instance names must not start with an uppercase letter&quot; rule this<br>&gt;&gt;&gt; eliminates the ambiguity discussed in this thread.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 13:12 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t agree with you because when reading your first example, I have<br>&gt;&gt;&gt;&gt; to make a mental gymnastic to find out if the variables are local/global<br>&gt;&gt;&gt;&gt; variables or if they are instance properties. It might seem obvious in a<br>&gt;&gt;&gt;&gt; small piece of code like yours, but it becomes less so in a class several<br>&gt;&gt;&gt;&gt; hundred of lines long.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:48, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; For me, readability has always been more important, as we spend most<br>&gt;&gt;&gt;&gt; of our time reading than writing code.<br>&gt;&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt;&gt;&gt;&gt; Disagree. This really depends on the example. E.g. which is more<br>&gt;&gt;&gt;&gt; readable:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Vector {<br>&gt;&gt;&gt;&gt;     var dx: Double<br>&gt;&gt;&gt;&gt;     var dy: Double<br>&gt;&gt;&gt;&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 12:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi Ilya,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Why use a style guide when the language can enforce rules to eliminate<br>&gt;&gt;&gt;&gt;&gt; the ambiguity?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Both of your previous points make sense but they make code editing<br>&gt;&gt;&gt;&gt;&gt; easier at the expense of readability. For me, readability has always been<br>&gt;&gt;&gt;&gt;&gt; more important, as we spend most of our time reading than writing code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; always liked the @ and @@ prefixes of Ruby for accessing instance and class<br>&gt;&gt;&gt;&gt;&gt; properties, but I agree that symbols like that would feel a bit foreign in<br>&gt;&gt;&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt;&gt;&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func greet() {<br>&gt;&gt;&gt;&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; seemlessly becomes<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class Greeter {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     func greet() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt;&gt;&gt;&gt; shadowing, e.g.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt;&gt;&gt;&gt; - break functions into small part so that it&#39;s easy to see all the<br>&gt;&gt;&gt;&gt;&gt; local name declarations<br>&gt;&gt;&gt;&gt;&gt; - not use any globals, or at least name them in a visually different<br>&gt;&gt;&gt;&gt;&gt; way (UppercaseCamelStyle)<br>&gt;&gt;&gt;&gt;&gt; - name properties and locals in a different way (classProperty,<br>&gt;&gt;&gt;&gt;&gt; local_var)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt;&gt;&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt;&gt;&gt;&gt; with enum usage.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;&gt;     let x = NSOperation()<br>&gt;&gt;&gt;&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt;&gt;&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt;&gt;&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt;&gt;&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface<br>&gt;&gt;&gt;&gt;&gt; that isn&#39;t an IDE (especially code review)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This is the point where I entirely agree, good code should be easily<br>&gt;&gt;&gt;&gt;&gt; read in any context.<br>&gt;&gt;&gt;&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt;&gt;&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Ilya<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt;&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt;&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued<br>&gt;&gt;&gt;&gt;&gt;&gt; work in Swift has both strengthened and modified that ask. Here are several<br>&gt;&gt;&gt;&gt;&gt;&gt; of the examples discussed before:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt;&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt;&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I<br>&gt;&gt;&gt;&gt;&gt;&gt; realize that this may conflict with enum usage. If so, then use another<br>&gt;&gt;&gt;&gt;&gt;&gt; marker. For instance :x or ^x or anything. But implicit self is confusing<br>&gt;&gt;&gt;&gt;&gt;&gt; in a lot of code, can (and does) lead to shadowing bugs, and is very<br>&gt;&gt;&gt;&gt;&gt;&gt; difficult to reason about in diffs or any other interface that isn&#39;t an IDE<br>&gt;&gt;&gt;&gt;&gt;&gt; (especially code review).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to<br>&gt;&gt;&gt;&gt;&gt;&gt; amend it.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/745b0266/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 13 Dec 2015, at 15:32, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; For the record I would also like it if the &quot;globals must start with an uppercase letter&quot; rule were enforced by the compiler (well, not in the playground, those aren&#39;t true globals). <br>&gt; <br>&gt; +1, in the same vein, global a should stand out :)<br></p><p>-1 from me.<br></p><p>I’d much prefer a way of name spacing free functions so that they don’t pollute global scope. That would help to reduce the potential ambiguity with implicit self too.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/f9a77be9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 01:00:00am</p></header><div class="content"><p>I agree with Ilya here:<br></p><p>&gt; &gt; but they make code editing easier at the expense of readability. <br>&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt; <br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt; <br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt; <br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br></p><p>I find that this holds true in larger classes as well (or even more). I have tons of view controllers and views that do stuff like:<br></p><p>obj1.prop1 = X<br>obj1.prop2 = Y<br>...<br>obj1.prop10 = Z<br>superview1.addSubview(obj1)<br></p><p>Adding “self.” everywhere adds a significant amount of visual noise; I&#39;ve tried _property and self.property access styles in Objective-C, and find the former one to be noticeably more readable.<br></p><p>To be fair, there are cases when it&#39;s not immediately clear if something is a property or a variable. That&#39;s why you can still add an explicit self. if you want. Some of those are also probably code smells.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/6606d330/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>Having so many symbols like @ all over the place kept me from learning and<br>using Ruby and Perl. It just felt wrong and artificial.<br>A language quickly becomes more difficult to learn, use and understand when<br>much of the code consists of symbols.<br></p><p>I love Swift for having such a simple &amp; clear structure and syntax in most<br>cases. Adding symbols for every instance access on self (which is a very<br>common case) would oppose these benefits and make its learning curve<br>steeper.<br></p><p>On Mon, Dec 14, 2015 at 8:17 PM, Andrey Tarantsov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with Ilya here:<br>&gt;<br>&gt; &gt; but they make code editing easier at the expense of readability.<br>&gt; Disagree. This really depends on the example. E.g. which is more readable:<br>&gt;<br>&gt;     var length: Double { return sqrt(dx*dx + dy*dy) }<br>&gt;<br>&gt;     var length: Double { return sqrt(@dx*@dx + @dy*@dy) }<br>&gt;<br>&gt;     var length: Double { return sqrt(self.dx*self.dx + self.dy*self.dy) }<br>&gt;<br>&gt;<br>&gt; I find that this holds true in larger classes as well (or even more). I<br>&gt; have tons of view controllers and views that do stuff like:<br>&gt;<br>&gt; obj1.prop1 = X<br>&gt; obj1.prop2 = Y<br>&gt; ...<br>&gt; obj1.prop10 = Z<br>&gt; superview1.addSubview(obj1)<br>&gt;<br>&gt; Adding “self.” everywhere adds a significant amount of visual noise; I&#39;ve<br>&gt; tried _property and self.property access styles in Objective-C, and find<br>&gt; the former one to be noticeably more readable.<br>&gt;<br>&gt; To be fair, there *are* cases when it&#39;s not immediately clear if<br>&gt; something is a property or a variable. That&#39;s why you can still add an<br>&gt; explicit self. if you want. Some of those are also probably code smells.<br>&gt;<br>&gt; A.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/5dc4a438/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>Jumping in here as a newbie to the list. :)<br></p><p>On Mon, Dec 14, 2015 at 1:32 PM, Marc Knaup via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Having so many symbols like @ all over the place kept me from learning and using Ruby and Perl. It just felt wrong and artificial.<br>&gt; A language quickly becomes more difficult to learn, use and understand when much of the code consists of symbols.<br>&gt;<br>&gt; I love Swift for having such a simple &amp; clear structure and syntax in most cases. Adding symbols for every instance access on self (which is a very common case) would oppose these benefits and make its learning curve steeper.<br></p><p>I agree wholeheartedly. Adding additional symbols to the language will<br>likely confuse newcomers and will inevitably lead to bike-shedding<br>(“@“ versus “self”).<br></p><p>Moreover, as much of my daily work is in Python (in addition to Obj-C<br>and increasingly more Swift!), I have a very strong affinity for<br>explicit over implicit. The optional “self” struck me from day 1 of my<br>learnings of Swift as a nice feature for convenience’s sake, but also<br>a bit risky in that ambiguous scoping issues could be a problem.<br></p><p>&gt; On Mon, Dec 14, 2015 at 8:17 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; obj1.prop1 = X<br>&gt;&gt; obj1.prop2 = Y<br>&gt;&gt; ...<br>&gt;&gt; obj1.prop10 = Z<br>&gt;&gt; superview1.addSubview(obj1)<br>&gt;&gt;<br>&gt;&gt; Adding “self.” everywhere adds a significant amount of visual noise; I&#39;ve tried _property and self.property access styles in Objective-C, and find the former one to be noticeably more readable.<br></p><p>Python enforces the usage of “self” for all instance variables and<br>methods, and—perhaps I’m biased—but I have never felt that it was<br>visual noise. On the contrary, it’s presence generally made code<br>_less_ noisy and easier to read.<br></p><p>We are fortunate because the Python mailing list debated this exact<br>issue in 2006 (albeit, in the reverse direction). I’ll quote from<br>https://www.python.org/dev/peps/pep-3099/ (“Things that will Not<br>Change in Python 3000”):<br></p><p>&gt; Having self be explicit is a good thing . It makes the code clear by removing ambiguity about how a variable resolves. It also makes the difference between functions and methods small.<br></p><p>&gt;From “Draft proposal: Implicit self in Python 3.0”,<br>http://mail.python.org/pipermail/python-dev/2006-January/059468.html<br></p><p>For any who are curious to read through the whole thread (there are<br>good arguments for and against in there):<br></p><p>[Python-Dev] Draft proposal: Implicit self in Python 3.0,<br>https://mail.python.org/pipermail/python-dev/2006-January/059446.html<br></p><p>Dan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; We are fortunate because the Python mailing list debated this exact<br>&gt; issue in 2006 (albeit, in the reverse direction). I’ll quote from<br>&gt; https://www.python.org/dev/peps/pep-3099/ (“Things that will Not<br>&gt; Change in Python 3000”):<br>&gt; <br>&gt;&gt; Having self be explicit is a good thing . It makes the code clear by removing ambiguity about how a variable resolves. It also makes the difference between functions and methods small.<br></p><p>That’s very interesting.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 03:00:00am</p></header><div class="content"><p>&gt; We are fortunate because the Python mailing list debated this exact<br>&gt; issue in 2006 (albeit, in the reverse direction). I’ll quote from<br>&gt; https://www.python.org/dev/peps/pep-3099/ (“Things that will Not<br>&gt; Change in Python 3000”):<br>&gt; <br>&gt;&gt; Having self be explicit is a good thing . It makes the code clear by removing ambiguity about how a variable resolves. It also makes the difference between functions and methods small.<br></p><p>Theoretically, if we were debating this on principle, I would agree with explicit self references.<br></p><p>However, I talk from experience using the relevant Apple frameworks writing dozens of apps. The UI code, which is more than a half of a typical app&#39;s code, consists of lines upon lines of simple object setup and manipulation, where (1) it is absolutely clear which names are properties and which are variables; (2) in many cases, it doesn&#39;t matter anyway (like maybe that tableView is an argument and not your property, but still the same object); (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br></p><p>And, perhaps more importantly, Xcode uses a different color to highlight property names. There&#39;s no need for further textual differentiation there.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 03:00:00am</p></header><div class="content"><p>Oh, one more point: in the UI code I mentioned, I often switch between a property and a variable (e.g. turning a locally-declared label into a field if I find myself needing to update it elsewhere), and it would be very irksome to have to go and update all the references.<br></p><p>Also, how often do you actually encounter a bug caused by confusion between properties and variables? I had maybe two property/argument collisions and one property/local var collision that I had to debug in my 1.5 years of swifting. Compared to that, writing &quot;self.&quot; would be an everyday annoyance.<br></p><p>A.<br></p><p><br>&gt; On Dec 15, 2015, at 3:54 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; We are fortunate because the Python mailing list debated this exact<br>&gt;&gt; issue in 2006 (albeit, in the reverse direction). I’ll quote from<br>&gt;&gt; https://www.python.org/dev/peps/pep-3099/ (“Things that will Not<br>&gt;&gt; Change in Python 3000”):<br>&gt;&gt; <br>&gt;&gt;&gt; Having self be explicit is a good thing . It makes the code clear by removing ambiguity about how a variable resolves. It also makes the difference between functions and methods small.<br>&gt; <br>&gt; Theoretically, if we were debating this on principle, I would agree with explicit self references.<br>&gt; <br>&gt; However, I talk from experience using the relevant Apple frameworks writing dozens of apps. The UI code, which is more than a half of a typical app&#39;s code, consists of lines upon lines of simple object setup and manipulation, where (1) it is absolutely clear which names are properties and which are variables; (2) in many cases, it doesn&#39;t matter anyway (like maybe that tableView is an argument and not your property, but still the same object); (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br>&gt; <br>&gt; And, perhaps more importantly, Xcode uses a different color to highlight property names. There&#39;s no need for further textual differentiation there.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 3:59 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;<br>&gt; Oh, one more point: in the UI code I mentioned, I often switch between a property and a variable (e.g. turning a locally-declared label into a field if I find myself needing to update it elsewhere), and it would be very irksome to have to go and update all the references.<br>&gt;<br>&gt; Also, how often do you actually encounter a bug caused by confusion between properties and variables? I had maybe two property/argument collisions and one property/local var collision that I had to debug in my 1.5 years of swifting. Compared to that, writing “self.” would be an everyday annoyance.<br></p><p>The difference is that one of the options puts the onus of<br>“correctness” on the developer, and the other puts it on the compiler.<br>As infallible as I might be, I prefer to think less about this sort of<br>thing and let the compiler do it for me. I guess I don’t see writing<br>“self.” as an annoyance since I’m very much used to it in Objective-C.<br></p><p>I think it’s a matter of habit. Personally, I think reading code and<br>having to decide which scope every reference refers to is a similar<br>cognitive annoyance (which I’ve attempted to reduce in my own<br>codebases by adopting the explicit style), whereas if I know “self.”<br>is the *only* way to reference an instance property or function, then<br>there’s no ambiguity and my brain can rest easy.<br></p><p>Re: hard to track to bugs, a somewhat contrived example follows (but<br>based in reality as many methods might hypothetically re-use the name<br>of an out-of-scope function for more specific behavior):<br></p><p>    func add(a: Int, b: Int) -&gt; Int {<br>        return a + b<br>    }<br></p><p>    class Add {<br>        func add(a: Int, b: Int) -&gt; Int {<br>            return a + b + 1<br>        }<br></p><p>        func aPlusB(a: Int, b: Int) → Int {<br>            return add(a, b: b);<br>        }<br>    }<br></p><p>1. Without trying this out in a playground, how many Swift users could<br>be expected to know—unambiguously—the output of “aPlusB(1, 1)”?<br>2. How can one reference a function with the same name as an instance<br>method in the class from which you’re referencing from? E.g., in the above<br>example, I believe that the “add” function is unreachable from within the class<br>(please correct me if I’m wrong).<br></p><p>&gt; &gt; However, I talk from experience using the relevant Apple frameworks writing dozens of apps. The UI code, which is more than a half of a typical app’s code, consists of lines upon lines of simple object setup and manipulation, where (1) it is absolutely clear which names are properties and which are variables; (2) in many cases, it doesn&#39;t matter anyway (like maybe that tableView is an argument and not your property, but still the same object); (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br></p><p>Like you, I have shipped dozens of apps. But mostly all (save for 2<br>which are currently in development) are written in Objective-C, which<br>forces an explicit self when referencing properties. Coming from that,<br>I’ve found the lack of it in Swift often causes me to re-read my code<br>more times than I should when trying to reason about what variable is<br>being referenced and which is not (especially in initializers).<br></p><p>I’ve also always been in the “always use properties over instance<br>variables” camp in Objective-C (e.g., self.tableView &gt; _tableView), so<br>that, combined with my Python experience, no doubt colors my opinions<br>here. :)<br></p><p>&gt; &gt; On Dec 15, 2015, at 3:54 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; And, perhaps more importantly, Xcode uses a different color to highlight property names. There’s no need for further textual differentiation there.<br></p><p>Very true. However, Xcode is just one of many environments in which<br>Swift is used. While I use Xcode all the time, I don’t think a core<br>language decision should be guided by its syntax highlighting<br>implementation (i.e., the IDE should adjust to fit the language, not<br>the other way around).<br></p><p>Dan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 5:35 PM, Dan Loewenherz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; 2. How can one reference a function with the same name as an instance<br>&gt; method in the class from which you’re referencing from? E.g., in the above<br>&gt; example, I believe that the “add” function is unreachable from within the<br>&gt; class<br>&gt; (please correct me if I’m wrong).<br></p><p><br>FWIW, I like implicit self but have been bit by this several times before.<br>You can use the current module&#39;s name to reference the free function, but<br>the error messaging you&#39;ll face beforehand doesn&#39;t make it easy to get to<br>that solution.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f92ce4bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>Swift.print() is a good example vs NSView&#39;s print()<br></p><p>I like things the way they are, and would rather use code highlights, linting tools, and in-house style standards rather than remove implicit self. That said, I could argue both sides.<br></p><p>-- E<br></p><p><br>&gt; On Dec 14, 2015, at 4:05 PM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 5:35 PM, Dan Loewenherz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; 2. How can one reference a function with the same name as an instance<br>&gt; method in the class from which you’re referencing from? E.g., in the above<br>&gt; example, I believe that the “add” function is unreachable from within the class<br>&gt; (please correct me if I’m wrong).<br>&gt; <br>&gt; FWIW, I like implicit self but have been bit by this several times before. You can use the current module&#39;s name to reference the free function, but the error messaging you&#39;ll face beforehand doesn&#39;t make it easy to get to that solution.<br>&gt; <br>&gt; Stephen<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/222dec4f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>My two cents: I don&#39;t think that &quot;there will be more work for the<br>programmer&quot; is necessarily a reason to not implement a feature. Granted, we<br>don&#39;t want to end up like Java 7 where I dreaded doing some things that<br>would be dead simple in Swift--but Swift already has a lot of<br>expressiveness and conciseness built in. Explicit self won&#39;t kill<br>that. Mandatory<br>&#39;self&#39; for ivar and method access brings a tiny bit of programmer overhead<br>(honestly, . is the easiest key to hit. You do it all the time, both in<br>plain english and in code) and prevents some issues that will nag at you<br>and waste days.<br></p><p>Java is almost hellish when it comes to conciseness but you don&#39;t hear<br>anyone saying &quot;at least we have implicit &#39;this&#39;!&quot;<br></p><p>I&#39;m sure there were people presenting that exact argument when<br>optionals/enforced nullability was first introduced into other languages:<br>&quot;Ugh, now I have to null-check everything? What a pain!&quot;<br></p><p>Although I am a strong believer in the programmer-facing aspects of a<br>language needing to be good, I think that this decision should come down to<br>the relative long-term pros/cons: use for refactoring, protecting against<br>mistakes, etc. One thing that programmers are notoriously bad at doing is<br>overcoming the immediate want to put less effort toward something, in order<br>to accept something that will be useful long-term. That is why so many<br>people don&#39;t unit test: can&#39;t see past the upfront cost to create<br>maintainability.<br></p><p>I accept that people will continue to say &quot;I can&#39;t be bothered to type<br>&#39;self.&#39;&quot;, but I just wanted to get this out there. It&#39;s really not that big<br>a deal--unless you&#39;re talking about readability rather than five keystrokes<br>on a method access. Keystrokes aren&#39;t the bottleneck in effective<br>programming.<br></p><p>On Mon, Dec 14, 2015 at 6:05 PM Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mon, Dec 14, 2015 at 5:35 PM, Dan Loewenherz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 2. How can one reference a function with the same name as an instance<br>&gt;&gt; method in the class from which you’re referencing from? E.g., in the above<br>&gt;&gt; example, I believe that the “add” function is unreachable from within the<br>&gt;&gt; class<br>&gt;&gt; (please correct me if I’m wrong).<br>&gt;<br>&gt;<br>&gt; FWIW, I like implicit self but have been bit by this several times before.<br>&gt; You can use the current module&#39;s name to reference the free function, but<br>&gt; the error messaging you&#39;ll face beforehand doesn&#39;t make it easy to get to<br>&gt; that solution.<br>&gt;<br>&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/1d571bbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0dc888223edca1a08d633bcaaa3f066f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>sune.foldager at me.com</string> &lt;sune.foldager at me.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>Personally, I am against using mandatory self. I have coded a lot of Python, and I find it quite annoying to have to type (and read) “self.” everywhere. It’s a balance, of course:<br></p><p>“self.” everywhere means you can see what’s an instance member and what’s a local variable. That’s generally a good thing. But it also means a lot of filler text in your code, which makes reading and writing slower. That’s not so good. It’s a balance, and in this case my experience from C# (and, as mentioned, Python) is that I much prefer C#’s non-mandatory use of “this”/“self&quot;.<br></p><p>I see that this proposal is going to be reviewed as SE-0009, and I am a bit concerned that not all arguments are being considered because of the contents of the proposal text: The only counter argument mentioned in the proposal has to do with capturing semantics in closures. This is fine, but why isn’t the counter argument of verbosity being mentioned? This has been brought up on the list as well.<br></p><p>Also, the “Community Responses” section exclusively lists positive feedback. Is that how it’s supposed to be with the SE process? If not, where are the arguments from people who are -1 on the proposal?<br></p><p>I really hope the review team considers:<br>- The negative responses on this list as well. Also consider that many Swift developers are not on this list; I doubt it’s representative, either, being dominated by “language interested” developers.<br>- The rather large amount of changes to existing code required.<br></p><p>-Sune<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015 at 3:03 PM, sune.foldager--- via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I see that this proposal is going to be reviewed as SE-0009, and I am a<br>&gt; bit concerned that not all arguments are being considered because of the<br>&gt; contents of the proposal text: The only counter argument mentioned in the<br>&gt; proposal has to do with capturing semantics in closures. This is fine, but<br>&gt; why isn’t the counter argument of verbosity being mentioned? This has been<br>&gt; brought up on the list as well.<br></p><p><br>Good points. Ideally the official review period will have members bring up<br>these counterpoints again.<br></p><p>SE-0009 also misses another &quot;alternative considered&quot; on this list:<br>prohibiting &quot;self&quot; outside of capture semantics, however impractical it may<br>be. Should scheduled proposals, as written, be open to amendment before<br>review?<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c96f0fdb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>Agreed, I don’t like visual clutter and that is why getting rid of semicolons at the end of the line is really great. If you want to use then you can and I like the suggestion of linters being used to enforce mandatory usage of it if you really want to. <br></p><p>However, I think, it would be ok to use period or  “.property” if that does not mess with enums or even “..&quot; (but that starts to get ugly) . <br></p><p><br>&gt; On Dec 15, 2015, at 12:03 PM, sune.foldager--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, I am against using mandatory self. I have coded a lot of Python, and I find it quite annoying to have to type (and read) “self.” everywhere. It’s a balance, of course:<br>&gt; <br>&gt; “self.” everywhere means you can see what’s an instance member and what’s a local variable. That’s generally a good thing. But it also means a lot of filler text in your code, which makes reading and writing slower. That’s not so good. It’s a balance, and in this case my experience from C# (and, as mentioned, Python) is that I much prefer C#’s non-mandatory use of “this”/“self&quot;.<br>&gt; <br>&gt; I see that this proposal is going to be reviewed as SE-0009, and I am a bit concerned that not all arguments are being considered because of the contents of the proposal text: The only counter argument mentioned in the proposal has to do with capturing semantics in closures. This is fine, but why isn’t the counter argument of verbosity being mentioned? This has been brought up on the list as well.<br>&gt; <br>&gt; Also, the “Community Responses” section exclusively lists positive feedback. Is that how it’s supposed to be with the SE process? If not, where are the arguments from people who are -1 on the proposal?<br>&gt; <br>&gt; I really hope the review team considers:<br>&gt; - The negative responses on this list as well. Also consider that many Swift developers are not on this list; I doubt it’s representative, either, being dominated by “language interested” developers.<br>&gt; - The rather large amount of changes to existing code required.<br>&gt; <br>&gt; -Sune<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de7ad0a98b5a246d7825f220b0174f4a?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Preston Sumner</string> &lt;preston.sumner at gmail.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>I suspect people would use local variable boilerplates to circumvent mandatory self, as they do in Objective-C.<br></p><p>let a = self.a<br>let b = self.b<br>let c = self.c<br></p><p>// Actually do stuff with a, b, and c.<br></p><p>Preston<br></p><p>&gt; On Dec 15, 2015, at 1:03 PM, sune.foldager--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, I am against using mandatory self. I have coded a lot of Python, and I find it quite annoying to have to type (and read) “self.” everywhere. It’s a balance, of course:<br>&gt; <br>&gt; “self.” everywhere means you can see what’s an instance member and what’s a local variable. That’s generally a good thing. But it also means a lot of filler text in your code, which makes reading and writing slower. That’s not so good. It’s a balance, and in this case my experience from C# (and, as mentioned, Python) is that I much prefer C#’s non-mandatory use of “this”/“self&quot;.<br>&gt; <br>&gt; I see that this proposal is going to be reviewed as SE-0009, and I am a bit concerned that not all arguments are being considered because of the contents of the proposal text: The only counter argument mentioned in the proposal has to do with capturing semantics in closures. This is fine, but why isn’t the counter argument of verbosity being mentioned? This has been brought up on the list as well.<br>&gt; <br>&gt; Also, the “Community Responses” section exclusively lists positive feedback. Is that how it’s supposed to be with the SE process? If not, where are the arguments from people who are -1 on the proposal?<br>&gt; <br>&gt; I really hope the review team considers:<br>&gt; - The negative responses on this list as well. Also consider that many Swift developers are not on this list; I doubt it’s representative, either, being dominated by “language interested” developers.<br>&gt; - The rather large amount of changes to existing code required.<br>&gt; <br>&gt; -Sune<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0ebf471a3ae8df42a84f93a7efbbdbd0?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Ash Furrow</string> &lt;ash at ashfurrow.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>Agreed – there are a few different disadvantages to adopting this new behaviour that aren’t discussed or mentioned at all. Especially considering the confusion from newcomers who do try to use the `let a = self.a` shortcut on value types…<br></p><p>Ash<br></p><p>On December 15, 2015 at 5:09:40 PM, Preston Sumner via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p><br>I suspect people would use local variable boilerplates to circumvent mandatory self, as they do in Objective-C.<br></p><p>let a = self.a<br>let b = self.b<br>let c = self.c<br></p><p>// Actually do stuff with a, b, and c.<br></p><p>Preston<br></p><p>&gt; On Dec 15, 2015, at 1:03 PM, sune.foldager--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt; Personally, I am against using mandatory self. I have coded a lot of Python, and I find it quite annoying to have to type (and read) “self.” everywhere. It’s a balance, of course:<br>&gt;  <br>&gt; “self.” everywhere means you can see what’s an instance member and what’s a local variable. That’s generally a good thing. But it also means a lot of filler text in your code, which makes reading and writing slower. That’s not so good. It’s a balance, and in this case my experience from C# (and, as mentioned, Python) is that I much prefer C#’s non-mandatory use of “this”/“self&quot;.<br>&gt;  <br>&gt; I see that this proposal is going to be reviewed as SE-0009, and I am a bit concerned that not all arguments are being considered because of the contents of the proposal text: The only counter argument mentioned in the proposal has to do with capturing semantics in closures. This is fine, but why isn’t the counter argument of verbosity being mentioned? This has been brought up on the list as well.<br>&gt;  <br>&gt; Also, the “Community Responses” section exclusively lists positive feedback. Is that how it’s supposed to be with the SE process? If not, where are the arguments from people who are -1 on the proposal?<br>&gt;  <br>&gt; I really hope the review team considers:<br>&gt; - The negative responses on this list as well. Also consider that many Swift developers are not on this list; I doubt it’s representative, either, being dominated by “language interested” developers.<br>&gt; - The rather large amount of changes to existing code required.<br>&gt;  <br>&gt; -Sune<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/3de3934e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br></p><p>Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br></p><p>What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br></p><p>If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br></p><p>I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br></p><p>Slava<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 15, 2015 at 10:00:00pm</p></header><div class="content"><p>I think this should be extended to functions as well. How would you know<br>the difference between a global function and a class function ?<br></p><p>On Tue, Dec 15, 2015 at 10:28 PM, Slava Pestov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I don&#39;t see anyone lay out how this proposal can interact with nested<br>&gt; types and such. There&#39;s a fair amount of complexity in Swift with what you<br>&gt; can do by nesting things inside of each other, so the simple conceptual<br>&gt; model of &quot;locals are unqualified, instance variables have a self. prefix&quot;<br>&gt; doesn&#39;t seem to generalize.<br>&gt;<br>&gt; Will I need to qualify associated types with the protocol or type name to<br>&gt; refer to them? What about generic type parameters, they&#39;re sort of like<br>&gt; &quot;instance variables&quot; too.<br>&gt;<br>&gt; What about class methods that want to call each other? Do they need the<br>&gt; explicit &#39;self&#39;, or an explicit class name prefix? The latter changes<br>&gt; semantics if the class method is overridden in a subclass.<br>&gt;<br>&gt; If we ever add the ability for an inner type to capture stored properties<br>&gt; from the outer type, how do you reference properties of the outer type? I<br>&gt; guess the problem has to be solved anyway to refer to an outer &quot;self&quot;<br>&gt; explicitly, but qualifying everything with OuterType.self.foo kind of<br>&gt; defeats the purpose of inner types altogether.<br>&gt;<br>&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It<br>&gt; seems the languages where explicit &#39;self&#39; was adopted did it mostly by<br>&gt; accident, or because of implementation concerns. In Python for instance,<br>&gt; there&#39;s no way for assignment to modify a binding in an outer scope, so<br>&gt; &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is<br>&gt; needed there. Greg Parker explains earlier in this thread by explicit self<br>&gt; was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;<br>&gt; Slava<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/a40395d2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 2:39 PM, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; I think this should be extended to functions as well. How would you know the difference between a global function and a class function ?<br></p><p>We could take this to its logical extreme and require explicit capture lists for all closures, and some kind of prefix (outer.) on captured variable accesses inside closure bodies. :-)<br></p><p>However, nobody would seriously propose this these days, because prevailing wisdom is that functions should be short and easy to read at a glance, especially if they involved nested functions, making it clear what values are captured where and so on.<br></p><p>Why don&#39;t we push the same philosophy for classes also?<br></p><p>I&#39;m not just convinced that syntactic disambiguation of scope lookup is desirable...<br></p><p>Slava<br></p><p>&gt; <br>&gt; On Tue, Dec 15, 2015 at 10:28 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br>&gt; <br>&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br>&gt; <br>&gt; What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br>&gt; <br>&gt; If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br>&gt; <br>&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt; <br>&gt; Slava<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/46762189/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>December 15, 2015 at 10:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;ve been following the thread from the beginning and some great arguments<br>have been layed out. As far as I understand, this proposal would lead to<br>fewer correctness bugs (referring to a different variable due to implicit<br>self, has happened to me twice in the last couple of months, was very hard<br>to track down).<br></p><p>The disadvantages of this are only verbosity. But, from the design<br>principles of Swift (as I understand them), correctness is preferred over<br>making the language concise, especially when those two are in conflict,<br>just like here.<br></p><p>I support the proposal, because it would lead to fewer bugs at only the<br>cost of extra few characters. Again, I&#39;ve been bitten by implicit self a<br>couple times before and those bugs are hard to track down. And the<br>readability of the code in code reviews, to me, is another huge advantage,<br>possibly leading to more correctness bugs caught early.<br></p><p>I understand and appreciate the disadvantages, but again, I believe we<br>should prefer correctness over conciseness, as explicitly stated by the<br>Swift design principles.<br></p><p>Honza<br></p><p>(sorry for the possible duplication, having some problems with my email<br>client :))<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/8aaa4054/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27fb74253bf2cb9c8dcea56452f74006?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Honza Dvorsky</string> &lt;czechboy0 at gmail.com&gt;<p>December 15, 2015 at 10:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;ve been following the thread from the beginning and some great arguments<br>have been layed out. As far as I understand, this proposal would lead to<br>fewer correctness bugs (referring to a different variable due to implicit<br>self, has happened to me twice in the last couple of months, was very hard<br>to track down).<br></p><p>The disadvantages of this are only verbosity. But, from the design<br>principles of Swift (as I understand them), correctness is preferred over<br>making the language concise, especially when those two are in conflict,<br>just like here.<br></p><p>I support the proposal, because it would lead to fewer bugs at only the<br>cost of extra few characters. Again, I&#39;ve been bitten by implicit self a<br>couple times before and those bugs are hard to track down. And the<br>readability of the code in code reviews, to me, is another huge advantage,<br>possibly leading to more correctness bugs caught early.<br></p><p>I understand and appreciate the disadvantages, but again, I believe we<br>should prefer correctness over conciseness, as explicitly stated by the<br>Swift design principles.<br>On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I don&#39;t see anyone lay out how this proposal can interact with nested<br>&gt; types and such. There&#39;s a fair amount of complexity in Swift with what you<br>&gt; can do by nesting things inside of each other, so the simple conceptual<br>&gt; model of &quot;locals are unqualified, instance variables have a self. prefix&quot;<br>&gt; doesn&#39;t seem to generalize.<br>&gt;<br>&gt; Will I need to qualify associated types with the protocol or type name to<br>&gt; refer to them? What about generic type parameters, they&#39;re sort of like<br>&gt; &quot;instance variables&quot; too.<br>&gt;<br>&gt; What about class methods that want to call each other? Do they need the<br>&gt; explicit &#39;self&#39;, or an explicit class name prefix? The latter changes<br>&gt; semantics if the class method is overridden in a subclass.<br>&gt;<br>&gt; If we ever add the ability for an inner type to capture stored properties<br>&gt; from the outer type, how do you reference properties of the outer type? I<br>&gt; guess the problem has to be solved anyway to refer to an outer &quot;self&quot;<br>&gt; explicitly, but qualifying everything with OuterType.self.foo kind of<br>&gt; defeats the purpose of inner types altogether.<br>&gt;<br>&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It<br>&gt; seems the languages where explicit &#39;self&#39; was adopted did it mostly by<br>&gt; accident, or because of implementation concerns. In Python for instance,<br>&gt; there&#39;s no way for assignment to modify a binding in an outer scope, so<br>&gt; &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is<br>&gt; needed there. Greg Parker explains earlier in this thread by explicit self<br>&gt; was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;<br>&gt; Slava<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/d6a520b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/728c1be08b1a4c91add43688b40592cf?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Rodrigues</string> &lt;david.ndh at gmail.com&gt;<p>December 16, 2015 at 12:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I understand the reasoning from both sides but this seems clearly something<br>that don&#39;t gathers consensus from a majority of us and for that reason why<br>should we really remove implicit self?<br></p><p>Swift supports both ways so there&#39;s an option to every one of us, no one is<br>forced to use implicit self neither explicit self, its something that can<br>(and should) be defined in each project as a convention to follow and<br>possible enforce using a lint.<br></p><p>And if we&#39;re really considering removing implicit self to fix a few<br>potential and hard to track bugs, we may also consider remove the !<br>operator to force unwrap an optional which is very unsafe unless verified<br>first (!= nil) when we have a syntax, if let value = value {}, which safely<br>unwraps the value and can potential prevent a lot of crashes.<br></p><p>It&#39;s only a figurative example to illustrate that is hard to achieve full<br>correctness and while there are options you can choose the one that fits<br>best to you.<br></p><p>David<br></p><p><br>2015-12-15 22:46 GMT+00:00 Honza Dvorsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I&#39;ve been following the thread from the beginning and some great arguments<br>&gt; have been layed out. As far as I understand, this proposal would lead to<br>&gt; fewer correctness bugs (referring to a different variable due to implicit<br>&gt; self, has happened to me twice in the last couple of months, was very hard<br>&gt; to track down).<br>&gt;<br>&gt; The disadvantages of this are only verbosity. But, from the design<br>&gt; principles of Swift (as I understand them), correctness is preferred over<br>&gt; making the language concise, especially when those two are in conflict,<br>&gt; just like here.<br>&gt;<br>&gt; I support the proposal, because it would lead to fewer bugs at only the<br>&gt; cost of extra few characters. Again, I&#39;ve been bitten by implicit self a<br>&gt; couple times before and those bugs are hard to track down. And the<br>&gt; readability of the code in code reviews, to me, is another huge advantage,<br>&gt; possibly leading to more correctness bugs caught early.<br>&gt;<br>&gt; I understand and appreciate the disadvantages, but again, I believe we<br>&gt; should prefer correctness over conciseness, as explicitly stated by the<br>&gt; Swift design principles.<br>&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see anyone lay out how this proposal can interact with nested<br>&gt;&gt; types and such. There&#39;s a fair amount of complexity in Swift with what you<br>&gt;&gt; can do by nesting things inside of each other, so the simple conceptual<br>&gt;&gt; model of &quot;locals are unqualified, instance variables have a self. prefix&quot;<br>&gt;&gt; doesn&#39;t seem to generalize.<br>&gt;&gt;<br>&gt;&gt; Will I need to qualify associated types with the protocol or type name to<br>&gt;&gt; refer to them? What about generic type parameters, they&#39;re sort of like<br>&gt;&gt; &quot;instance variables&quot; too.<br>&gt;&gt;<br>&gt;&gt; What about class methods that want to call each other? Do they need the<br>&gt;&gt; explicit &#39;self&#39;, or an explicit class name prefix? The latter changes<br>&gt;&gt; semantics if the class method is overridden in a subclass.<br>&gt;&gt;<br>&gt;&gt; If we ever add the ability for an inner type to capture stored properties<br>&gt;&gt; from the outer type, how do you reference properties of the outer type? I<br>&gt;&gt; guess the problem has to be solved anyway to refer to an outer &quot;self&quot;<br>&gt;&gt; explicitly, but qualifying everything with OuterType.self.foo kind of<br>&gt;&gt; defeats the purpose of inner types altogether.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I buy the readability arguments in favor of this approach.<br>&gt;&gt; It seems the languages where explicit &#39;self&#39; was adopted did it mostly by<br>&gt;&gt; accident, or because of implementation concerns. In Python for instance,<br>&gt;&gt; there&#39;s no way for assignment to modify a binding in an outer scope, so<br>&gt;&gt; &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is<br>&gt;&gt; needed there. Greg Parker explains earlier in this thread by explicit self<br>&gt;&gt; was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;&gt;<br>&gt;&gt; Slava<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a4135c92/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>I propose an alternative:<br>- all functions are expected to possibly strongly capture self (regardless of whether self is used within the closure explicitly or implicitly or not at all) unless it decides due to optimization that the code does not need a strong capture of self. The developer responsible for declaring other behavior, with directives such as [weak self].<br>- compiler generates warnings if a declared variable or bound parameter shadows a variable/property/method in higher scope, excluding let x = x and the ignored value _. <br>- These warnings would be generated lazily (so conflicts are reported on use, not declaration). You can reference the self side of the conflict explicitly to resolve the warning.<br></p><p>The disadvantage of explicit self is not just verbosity. It provides noise that interferes with the reading and understanding of the code. Correctness goes beyond Safety (which this proposal doesn’t really address) or Unambiguity IMHO, into the ability to understand the actual underlying algorithm. Yes, I’m saying that sometimes correctness is also conciseness, because the reader of the code needs to be able to understand what it does just as much as they need that understanding to be unambiguous.<br></p><p>-DW<br> <br>&gt; On Dec 15, 2015, at 3:46 PM, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;ve been following the thread from the beginning and some great arguments have been layed out. As far as I understand, this proposal would lead to fewer correctness bugs (referring to a different variable due to implicit self, has happened to me twice in the last couple of months, was very hard to track down). <br>&gt; <br>&gt; The disadvantages of this are only verbosity. But, from the design principles of Swift (as I understand them), correctness is preferred over making the language concise, especially when those two are in conflict, just like here. <br>&gt; <br>&gt; I support the proposal, because it would lead to fewer bugs at only the cost of extra few characters. Again, I&#39;ve been bitten by implicit self a couple times before and those bugs are hard to track down. And the readability of the code in code reviews, to me, is another huge advantage, possibly leading to more correctness bugs caught early. <br>&gt; <br>&gt; I understand and appreciate the disadvantages, but again, I believe we should prefer correctness over conciseness, as explicitly stated by the Swift design principles. <br>&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br>&gt; <br>&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br>&gt; <br>&gt; What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br>&gt; <br>&gt; If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br>&gt; <br>&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt; <br>&gt; Slava<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/98c46099/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>I think the most important advantage of explicit self is that it vastly simplifies the scoping rules of the language as it moves the instance scope into a clearly recognisable construction. As far as I am concerned, self should be mandatory. However, I can also understand that sometimes it might get a bit repetitive (especially when initialising state). This thread is getting a bit large, so sorry if I missed, but did anyone already suggest to introduce a scope operator, which would bind a particular instance to the top of the variable scope. Such operator could be integrated into the existing do, e.g.<br></p><p>do with self { // or with self do<br>   x = 1<br>   y = 2<br>}<br></p><p>similarly<br></p><p>do with obj {<br>   x = 1<br>   y= 2<br>}<br></p><p>This has the benefit of keeping the scoping rules simple, preventing clashes between the instance scope and the block/function/global scope, while retaining the possibility to use the ‘more readable’ form if needed. Furthermore, it can be also seen as a neat logical ‘grouping&#39;  construct that aids the programmer in understanding the code better. <br></p><p>Again, I apologise if this suggestion was already made, I might have overlooked it. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; <br>&gt; -DW<br>&gt;  <br>&gt;&gt; On Dec 15, 2015, at 3:46 PM, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been following the thread from the beginning and some great arguments have been layed out. As far as I understand, this proposal would lead to fewer correctness bugs (referring to a different variable due to implicit self, has happened to me twice in the last couple of months, was very hard to track down). <br>&gt;&gt; <br>&gt;&gt; The disadvantages of this are only verbosity. But, from the design principles of Swift (as I understand them), correctness is preferred over making the language concise, especially when those two are in conflict, just like here. <br>&gt;&gt; <br>&gt;&gt; I support the proposal, because it would lead to fewer bugs at only the cost of extra few characters. Again, I&#39;ve been bitten by implicit self a couple times before and those bugs are hard to track down. And the readability of the code in code reviews, to me, is another huge advantage, possibly leading to more correctness bugs caught early. <br>&gt;&gt; <br>&gt;&gt; I understand and appreciate the disadvantages, but again, I believe we should prefer correctness over conciseness, as explicitly stated by the Swift design principles. <br>&gt;&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br>&gt;&gt; <br>&gt;&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br>&gt;&gt; <br>&gt;&gt; What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br>&gt;&gt; <br>&gt;&gt; If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/1fbd2bf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>-1 also for reasons already listed.<br></p><p>I would even like ways to have more implicit self, like method cascading, closure binding, implicit self in a closure if self is explicitly captured, etc… <br></p><p>-- <br>Pierre<br></p><p>&gt; Le 16 déc. 2015 à 14:55, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think the most important advantage of explicit self is that it vastly simplifies the scoping rules of the language as it moves the instance scope into a clearly recognisable construction. As far as I am concerned, self should be mandatory. However, I can also understand that sometimes it might get a bit repetitive (especially when initialising state). This thread is getting a bit large, so sorry if I missed, but did anyone already suggest to introduce a scope operator, which would bind a particular instance to the top of the variable scope. Such operator could be integrated into the existing do, e.g.<br>&gt; <br>&gt; do with self { // or with self do<br>&gt;    x = 1<br>&gt;    y = 2<br>&gt; }<br>&gt; <br>&gt; similarly<br>&gt; <br>&gt; do with obj {<br>&gt;    x = 1<br>&gt;    y= 2<br>&gt; }<br>&gt; <br>&gt; This has the benefit of keeping the scoping rules simple, preventing clashes between the instance scope and the block/function/global scope, while retaining the possibility to use the ‘more readable’ form if needed. Furthermore, it can be also seen as a neat logical ‘grouping&#39;  construct that aids the programmer in understanding the code better. <br>&gt; <br>&gt; Again, I apologise if this suggestion was already made, I might have overlooked it. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 15, 2015, at 3:46 PM, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been following the thread from the beginning and some great arguments have been layed out. As far as I understand, this proposal would lead to fewer correctness bugs (referring to a different variable due to implicit self, has happened to me twice in the last couple of months, was very hard to track down). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The disadvantages of this are only verbosity. But, from the design principles of Swift (as I understand them), correctness is preferred over making the language concise, especially when those two are in conflict, just like here. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I support the proposal, because it would lead to fewer bugs at only the cost of extra few characters. Again, I&#39;ve been bitten by implicit self a couple times before and those bugs are hard to track down. And the readability of the code in code reviews, to me, is another huge advantage, possibly leading to more correctness bugs caught early. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand and appreciate the disadvantages, but again, I believe we should prefer correctness over conciseness, as explicitly stated by the Swift design principles. <br>&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Slava<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/606b6f77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/728c1be08b1a4c91add43688b40592cf?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Rodrigues</string> &lt;david.ndh at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>Hi Pierre,<br></p><p>there&#39;s actually a proposal to do that regarding implicit self in a closure<br>here:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002628.html<br>.<br></p><p>- David<br></p><p>2015-12-16 15:57 GMT+00:00 Pierre Monod-Broca via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; -1 also for reasons already listed.<br>&gt;<br>&gt; I would even like ways to have more implicit self, like method cascading,<br>&gt; closure binding, implicit self in a closure if self is explicitly captured,<br>&gt; etc…<br>&gt;<br>&gt; --<br>&gt; Pierre<br>&gt;<br>&gt; Le 16 déc. 2015 à 14:55, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I think the most important advantage of explicit self is that it vastly<br>&gt; simplifies the scoping rules of the language as it moves the instance scope<br>&gt; into a clearly recognisable construction. As far as I am concerned, self<br>&gt; should be mandatory. However, I can also understand that sometimes it might<br>&gt; get a bit repetitive (especially when initialising state). This thread is<br>&gt; getting a bit large, so sorry if I missed, but did anyone already suggest<br>&gt; to introduce a scope operator, which would bind a particular instance to<br>&gt; the top of the variable scope. Such operator could be integrated into the<br>&gt; existing do, e.g.<br>&gt;<br>&gt; do with self { // or with self do<br>&gt;    x = 1<br>&gt;    y = 2<br>&gt; }<br>&gt;<br>&gt; similarly<br>&gt;<br>&gt; do with obj {<br>&gt;    x = 1<br>&gt;    y= 2<br>&gt; }<br>&gt;<br>&gt; This has the benefit of keeping the scoping rules simple, preventing<br>&gt; clashes between the instance scope and the block/function/global scope,<br>&gt; while retaining the possibility to use the ‘more readable’ form if needed.<br>&gt; Furthermore, it can be also seen as a neat logical ‘grouping&#39;  construct<br>&gt; that aids the programmer in understanding the code better.<br>&gt;<br>&gt; Again, I apologise if this suggestion was already made, I might have<br>&gt; overlooked it.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; On Dec 15, 2015, at 3:46 PM, Honza Dvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I&#39;ve been following the thread from the beginning and some great arguments<br>&gt; have been layed out. As far as I understand, this proposal would lead to<br>&gt; fewer correctness bugs (referring to a different variable due to implicit<br>&gt; self, has happened to me twice in the last couple of months, was very hard<br>&gt; to track down).<br>&gt;<br>&gt; The disadvantages of this are only verbosity. But, from the design<br>&gt; principles of Swift (as I understand them), correctness is preferred over<br>&gt; making the language concise, especially when those two are in conflict,<br>&gt; just like here.<br>&gt;<br>&gt; I support the proposal, because it would lead to fewer bugs at only the<br>&gt; cost of extra few characters. Again, I&#39;ve been bitten by implicit self a<br>&gt; couple times before and those bugs are hard to track down. And the<br>&gt; readability of the code in code reviews, to me, is another huge advantage,<br>&gt; possibly leading to more correctness bugs caught early.<br>&gt;<br>&gt; I understand and appreciate the disadvantages, but again, I believe we<br>&gt; should prefer correctness over conciseness, as explicitly stated by the<br>&gt; Swift design principles.<br>&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see anyone lay out how this proposal can interact with nested<br>&gt;&gt; types and such. There&#39;s a fair amount of complexity in Swift with what you<br>&gt;&gt; can do by nesting things inside of each other, so the simple conceptual<br>&gt;&gt; model of &quot;locals are unqualified, instance variables have a self. prefix&quot;<br>&gt;&gt; doesn&#39;t seem to generalize.<br>&gt;&gt;<br>&gt;&gt; Will I need to qualify associated types with the protocol or type name to<br>&gt;&gt; refer to them? What about generic type parameters, they&#39;re sort of like<br>&gt;&gt; &quot;instance variables&quot; too.<br>&gt;&gt;<br>&gt;&gt; What about class methods that want to call each other? Do they need the<br>&gt;&gt; explicit &#39;self&#39;, or an explicit class name prefix? The latter changes<br>&gt;&gt; semantics if the class method is overridden in a subclass.<br>&gt;&gt;<br>&gt;&gt; If we ever add the ability for an inner type to capture stored properties<br>&gt;&gt; from the outer type, how do you reference properties of the outer type? I<br>&gt;&gt; guess the problem has to be solved anyway to refer to an outer &quot;self&quot;<br>&gt;&gt; explicitly, but qualifying everything with OuterType.self.foo kind of<br>&gt;&gt; defeats the purpose of inner types altogether.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I buy the readability arguments in favor of this approach.<br>&gt;&gt; It seems the languages where explicit &#39;self&#39; was adopted did it mostly by<br>&gt;&gt; accident, or because of implementation concerns. In Python for instance,<br>&gt;&gt; there&#39;s no way for assignment to modify a binding in an outer scope, so<br>&gt;&gt; &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is<br>&gt;&gt; needed there. Greg Parker explains earlier in this thread by explicit self<br>&gt;&gt; was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt;&gt;<br>&gt;&gt; Slava<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a84112ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>I propose an alternative:<br>- all functions are expected to possibly strongly capture self (regardless of whether self is used within the closure explicitly or implicitly or not at all) unless it decides due to optimization that the code does not need a strong capture of self. The developer responsible for declaring other behavior, with directives such as [weak self].<br>- compiler generates warnings if a declared variable or bound parameter shadows a variable/property/method in higher scope, excluding let x = x and the ignored value _. <br>- These warnings would be generated lazily (so conflicts are reported on use, not declaration). You can reference the self side of the conflict explicitly to resolve the warning.<br></p><p>The disadvantage of explicit self is not just verbosity. It provides noise that interferes with the reading and understanding of the code. Correctness goes beyond Safety (which this proposal doesn’t really address) or Unambiguity IMHO, into the ability to understand the actual underlying algorithm. Yes, I’m saying that sometimes correctness is also conciseness, because the reader of the code needs to be able to understand what it does just as much as they need that understanding to be unambiguous.<br></p><p>-DW<br> <br>&gt; On Dec 15, 2015, at 3:46 PM, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;ve been following the thread from the beginning and some great arguments have been layed out. As far as I understand, this proposal would lead to fewer correctness bugs (referring to a different variable due to implicit self, has happened to me twice in the last couple of months, was very hard to track down). <br>&gt; <br>&gt; The disadvantages of this are only verbosity. But, from the design principles of Swift (as I understand them), correctness is preferred over making the language concise, especially when those two are in conflict, just like here. <br>&gt; <br>&gt; I support the proposal, because it would lead to fewer bugs at only the cost of extra few characters. Again, I&#39;ve been bitten by implicit self a couple times before and those bugs are hard to track down. And the readability of the code in code reviews, to me, is another huge advantage, possibly leading to more correctness bugs caught early. <br>&gt; <br>&gt; I understand and appreciate the disadvantages, but again, I believe we should prefer correctness over conciseness, as explicitly stated by the Swift design principles. <br>&gt; On Tue, Dec 15, 2015 at 11:28 PM Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I don&#39;t see anyone lay out how this proposal can interact with nested types and such. There&#39;s a fair amount of complexity in Swift with what you can do by nesting things inside of each other, so the simple conceptual model of &quot;locals are unqualified, instance variables have a self. prefix&quot; doesn&#39;t seem to generalize.<br>&gt; <br>&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br>&gt; <br>&gt; What about class methods that want to call each other? Do they need the explicit &#39;self&#39;, or an explicit class name prefix? The latter changes semantics if the class method is overridden in a subclass.<br>&gt; <br>&gt; If we ever add the ability for an inner type to capture stored properties from the outer type, how do you reference properties of the outer type? I guess the problem has to be solved anyway to refer to an outer &quot;self&quot; explicitly, but qualifying everything with OuterType.self.foo kind of defeats the purpose of inner types altogether.<br>&gt; <br>&gt; I&#39;m not sure I buy the readability arguments in favor of this approach. It seems the languages where explicit &#39;self&#39; was adopted did it mostly by accident, or because of implementation concerns. In Python for instance, there&#39;s no way for assignment to modify a binding in an outer scope, so &#39;foo = bar&#39; always sets a local named &#39;foo&#39;, IIRC. So explicit self is needed there. Greg Parker explains earlier in this thread by explicit self was chosen for Objective-C, and it wasn&#39;t readability.<br>&gt; <br>&gt; Slava<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/cf1941ca/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 5:28 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Will I need to qualify associated types with the protocol or type name to refer to them? What about generic type parameters, they&#39;re sort of like &quot;instance variables&quot; too.<br></p><p>Hadn’t thought about that. It does seem that requiring “Self.” would be a natural extension of this proposal.<br></p><p>&gt; On Dec 15, 2015, at 5:46 PM, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been following the thread from the beginning and some great arguments have been layed out. As far as I understand, this proposal would lead to fewer correctness bugs (referring to a different variable due to implicit self, has happened to me twice in the last couple of months, was very hard to track down).<br></p><p>It sounds to me that the biggest advantage of requiring self is to avoid the occasional , hard-to-find bug (at the cost of muddying the readability of a lot of code). I’d much rather focus on improving compiler diagnostics and error messaging than limit the expressiveness of the language.<br></p><p>With the current discussion having a lot of voices on both sides, I can’t imagine this proposal passing, especially when a linter could easily enforce such a rule for the audience that prefers it.<br></p><p>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>+1 for keeping self optional and the argument.<br></p><p>--<br>Ilya Belenkiy<br>On Wed, Dec 16, 2015 at 7:48 AM Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Dec 15, 2015, at 5:28 PM, Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Will I need to qualify associated types with the protocol or type name<br>&gt; to refer to them? What about generic type parameters, they&#39;re sort of like<br>&gt; &quot;instance variables&quot; too.<br>&gt;<br>&gt; Hadn’t thought about that. It does seem that requiring “Self.” would be a<br>&gt; natural extension of this proposal.<br>&gt;<br>&gt; &gt; On Dec 15, 2015, at 5:46 PM, Honza Dvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been following the thread from the beginning and some great<br>&gt; arguments have been layed out. As far as I understand, this proposal would<br>&gt; lead to fewer correctness bugs (referring to a different variable due to<br>&gt; implicit self, has happened to me twice in the last couple of months, was<br>&gt; very hard to track down).<br>&gt;<br>&gt; It sounds to me that the biggest advantage of requiring self is to avoid<br>&gt; the occasional , hard-to-find bug (at the cost of muddying the readability<br>&gt; of a lot of code). I’d much rather focus on improving compiler diagnostics<br>&gt; and error messaging than limit the expressiveness of the language.<br>&gt;<br>&gt; With the current discussion having a lot of voices on both sides, I can’t<br>&gt; imagine this proposal passing, especially when a linter could easily<br>&gt; enforce such a rule for the audience that prefers it.<br>&gt;<br>&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ed21c974/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; (2) in many cases, it doesn&#39;t matter anyway (like maybe that tableView is an argument and not your property, but still the same object);<br></p><p>That’s actually a very good example.<br></p><p>Most of the time, your UIViewController or UITableViewController’s self.tableView is the same object as UITableViewDelegate’s tableView method argument. But I’ve had several cases in my app development career where that UIViewController was also used for updating a different tableView (for example a tableView used for search) which uses the same delegate, but where it is paramount to use the argument variable and not the instance variable.<br></p><p>I’ve actually had a bug due to that where code review was very quick because cellForRowAtIndexPath was using self.tableView instead of tableView and we saw it straight away.<br></p><p>&gt;&gt; (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br></p><p>Like many before, I think this is a question of taste. In our team, we don’t find it particularly verbose and we actually think it clarifies intention.<br></p><p>&gt;&gt; And, perhaps more importantly, Xcode uses a different color to highlight property names. There&#39;s no need for further textual differentiation there.<br></p><p>Like already said early in the discussion: some code review tools don’t show good enough color syntaxing, and even when in Xcode, I (and several others) are colourblind enough not to see the difference in those colours.<br></p><p>David.<br></p><p>&gt; On 14 Dec 2015, at 22:59, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Oh, one more point: in the UI code I mentioned, I often switch between a property and a variable (e.g. turning a locally-declared label into a field if I find myself needing to update it elsewhere), and it would be very irksome to have to go and update all the references.<br>&gt; <br>&gt; Also, how often do you actually encounter a bug caused by confusion between properties and variables? I had maybe two property/argument collisions and one property/local var collision that I had to debug in my 1.5 years of swifting. Compared to that, writing &quot;self.&quot; would be an everyday annoyance.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 3:54 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We are fortunate because the Python mailing list debated this exact<br>&gt;&gt;&gt; issue in 2006 (albeit, in the reverse direction). I’ll quote from<br>&gt;&gt;&gt; https://www.python.org/dev/peps/pep-3099/ (“Things that will Not<br>&gt;&gt;&gt; Change in Python 3000”):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having self be explicit is a good thing . It makes the code clear by removing ambiguity about how a variable resolves. It also makes the difference between functions and methods small.<br>&gt;&gt; <br>&gt;&gt; Theoretically, if we were debating this on principle, I would agree with explicit self references.<br>&gt;&gt; <br>&gt;&gt; However, I talk from experience using the relevant Apple frameworks writing dozens of apps. The UI code, which is more than a half of a typical app&#39;s code, consists of lines upon lines of simple object setup and manipulation, where (1) it is absolutely clear which names are properties and which are variables; (2) in many cases, it doesn&#39;t matter anyway (like maybe that tableView is an argument and not your property, but still the same object); (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br>&gt;&gt; <br>&gt;&gt; And, perhaps more importantly, Xcode uses a different color to highlight property names. There&#39;s no need for further textual differentiation there.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; Most of the time, your UIViewController or UITableViewController’s self.tableView is the same object as UITableViewDelegate’s tableView method argument. But I’ve had several cases in my app development career where that UIViewController was also used for updating a different tableView (for example a tableView used for search) which uses the same delegate, but where it is paramount to use the argument variable and not the instance variable.<br>&gt; <br>&gt; I’ve actually had a bug due to that where code review was very quick because cellForRowAtIndexPath was using self.tableView instead of tableView and we saw it straight away.<br></p><p>Like I&#39;ve mentioned, I also had a couple bugs like that, but I&#39;ll take that bug rate over the day-to-day requirement to use self.<br></p><p>&gt;&gt;&gt; (3) the code is fairly verbose as it is, and adding any extra syntactic elements obscures its intention.<br>&gt; <br>&gt; Like many before, I think this is a question of taste. In our team, we don’t find it particularly verbose and we actually think it clarifies intention.<br></p><p>I guess you can get used to it? To me, self-access to properties in Objective-C is super-obtrusive, and I&#39;ve been preferring fields for everything.<br></p><p><br>Now, I&#39;ve expressed my opinion, and I have no idea how to resolve an issue that basically boils down to one&#39;s taste (I don&#39;t buy the extra-bug-a-year being a compelling argument), so I&#39;ll let you guys continue with the discussion. :-)<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 2:59 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To me, self-access to properties in Objective-C is super-obtrusive, and I&#39;ve been preferring fields for everything.<br></p><p>Note that the `self.property` access in Objective-C was not the preferred design. <br></p><p>The first choice was for bare `property` to work. That turned out to be ambiguous too often because of identically-named ivars. Swift doesn&#39;t have that problem. <br></p><p>The second choice was for bare `property` to access the property, requiring `self-&gt;ivar` to access an identically-named ivar. That was not feasible because it was incompatible with too much existing source code. Swift doesn&#39;t have that problem either.<br></p><p>Requiring `self.property` was the third choice.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 05:00:00am</p></header><div class="content"><p>&gt; Note that the `self.property` access in Objective-C was not the preferred design. <br>&gt; <br>&gt; The first choice was for bare `property` to work. That turned out to be ambiguous too often because of identically-named ivars. Swift doesn&#39;t have that problem. <br>&gt; <br>&gt; The second choice was for bare `property` to access the property, requiring `self-&gt;ivar` to access an identically-named ivar. That was not feasible because it was incompatible with too much existing source code. Swift doesn&#39;t have that problem either.<br>&gt; <br>&gt; Requiring `self.property` was the third choice.<br></p><p>Greg, these kinds of historical insights alone make 945 unread messages in my inbox worth it. Thank you!<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4889457e1fdb5f3ba65d7053432042f8?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Bart Whiteley</string> &lt;bwhiteley at gmail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>I joined the list late. Apologies for breaking the threading.<br></p><p>On Mon, Dec 14, 2015, 12:30 AM Nick Shelley &lt;nickmshelley at gmail.com&gt; wrote:<br>&gt;<br>&gt; From what I understand, the main reason that self is required in closures<br>&gt; and not elsewhere is to serve as a compiler-enforced reminder about the<br>&gt; potential pitfalls of using self within closures (which I happen to think<br>&gt; it does well). Unless and until a different way of calling out those<br>&gt; pitfalls is proposed and accepted (as Andrew was suggesting), that point is<br>&gt; an essential part of the discussion IMO.<br>&gt;<br>&gt;<br>...<br>&gt;&gt; And on the con side, I have heard --<br>&gt;<br>&gt; You forgot &quot;Makes capture semantics of using self inside of closures less<br>&gt; apparent.&quot; I consider this the main con of the current proposal, and it<br>&gt; seems others do as well.<br>&gt;<br></p><p>A means of preventing retain cycles due to closures should not be<br>limited to `self`. The same pitfalls apply to other variables.<br></p><p>    var obj = …<br>    obj.closure = {<br>        obj.doSomething()<br>    }<br></p><p>--<br>bart<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 13, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 2:40 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &lt;snip&gt;<br>&gt; I agree that that would potentially add confusion to the grammar. I&#39;ve always liked the @ and @@ prefixes of Ruby for accessing instance and class properties, but I agree that symbols like that would feel a bit foreign in Swift.<br>&gt; <br>I believe the interesting bit about Ruby in this case is that it only exposes variables through bound scope. self.foo means ‘call foo on object self’. <br></p><p>So @foo is *not* shorthand in Ruby, it provides different functionality. This is similar to using this-&gt;foo vs self.foo in Objective C.<br></p><p>-DW<br></p><p>&gt; David<br>&gt; <br>&gt; On 13 Dec 2015, at 10:16, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt; <br>&gt;&gt; On the other hand, it allows a logical explanation of how you can take code from global scope and put it into an instance scope:<br>&gt;&gt; <br>&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt; <br>&gt;&gt; func greet() {<br>&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; seemlessly becomes<br>&gt;&gt; <br>&gt;&gt; class Greeter {<br>&gt;&gt; <br>&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt; <br>&gt;&gt;     func greet() {<br>&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt; <br>&gt;&gt; There are simple strategies that help to minimize the amount of shadowing, e.g. <br>&gt;&gt; <br>&gt;&gt; - only expose the minimum necessary amount of names in any scope <br>&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local name declarations<br>&gt;&gt; - not use any globals, or at least name them in a visually different way (UppercaseCamelStyle)<br>&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt; <br>&gt;&gt; Even without a formal code style, if you tend to make property names longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt; <br>&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with enum usage.<br>&gt;&gt; <br>&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt; <br>&gt;&gt; func f() {<br>&gt;&gt;     let x = NSOperation()<br>&gt;&gt;     .name = &quot;Name&quot; // is it x.name &lt;http://x.name/&gt; or self.name &lt;http://self.name/&gt;??<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt; <br>&gt;&gt; This is workable, but still I think this is one of the best points of Swift – the existence of instance scope where names are simply written as-is. This helps implementing patterns like &quot;take a long function and make it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt; <br>&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review)<br>&gt;&gt; <br>&gt;&gt; This is the point where I entirely agree, good code should be easily read in any context.<br>&gt;&gt; Again, may I suggest you take a look into using a style guide to differentiate visually between local and instance scope?<br>&gt;&gt; <br>&gt;&gt; Ilya<br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085 &lt;https://devforums.apple.com/message/1013085&gt;). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25 &lt;https://gist.github.com/schwa/94b11dc0a7a331f46b25&gt;<br>&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42 &lt;https://gist.github.com/rnapier/478465d1b15e95b98b42&gt;<br>&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935 &lt;https://gist.github.com/rnapier/4213dc64206b17df6935&gt;<br>&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db &lt;https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db&gt;<br>&gt;&gt; <br>&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt;&gt; <br>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt;&gt; <br>&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt;&gt; <br>&gt;&gt; -Rob<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/ff6e2c10/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; - only expose the minimum necessary amount of names in any scope<br></p><p>&gt; - break functions into small part so that it&#39;s easy to see all the local<br>name declarations<br></p><p>&gt; - not use any globals, or at least name them in a visually different way<br>(UppercaseCamelStyle)<br></p><p>&gt; - name properties and locals in a different way (classProperty, local_var)<br></p><p>Ilya, I think this may be a presumptuous way of how well programmers code.<br>When deadlines hit, those first two suggestions go out the window. And the<br>fourth/last suggestion is not valid for me - changing naming conventions<br>would be both more confusing and more work (context switching) than<br>explicit self.<br></p><p><br>The other tangible benefit of explicit self is that code becomes more<br>refactorable. You can move code to and from closures at will, and moving it<br>to unsuitable contexts gives immediate negative feedback. This is actually<br>the reason why my team chose unanimously to adopt explicit self as a strict<br>code style guideline.<br></p><p><br>-1 to the notion that it makes the transition from global state to class<br>state less fluid. Global state and class state should never be conflated<br>and implicit self can lead to such conflation. Global functions should be<br>carefully rewritten to class dynamics when the transition is desired, and<br>implicit self makes it easier to make that transition without careful<br>consideration.<br></p><p><br>Overall, I give +1 to the explicit self proposal, -1 to using a special<br>operator. Explicit self is neither hard nor particularly verbose in my<br>experience; with syntax highlighting, it happens to be very readable. I<br>love Ruby, but an @ operator for ivars would be very foreign and would kill<br>the aesthetic of the language for me. Not sure where others stand on it.<br></p><p>On Sun, Dec 13, 2015, 4:16 AM ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;<br>&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt; code from global scope and put it into an instance scope:<br>&gt;<br>&gt; let greeting = &quot;Hello&quot;<br>&gt; let name = &quot;Michael&quot;<br>&gt;<br>&gt; func greet() {<br>&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt; }<br>&gt;<br>&gt; seemlessly becomes<br>&gt;<br>&gt; class Greeter {<br>&gt;<br>&gt;     let greeting = &quot;Hello&quot;<br>&gt;     let name = &quot;Michael&quot;<br>&gt;<br>&gt;     func greet() {<br>&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;<br>&gt; There are simple strategies that help to minimize the amount of shadowing,<br>&gt; e.g.<br>&gt;<br>&gt; - only expose the minimum necessary amount of names in any scope<br>&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt; name declarations<br>&gt; - not use any globals, or at least name them in a visually different way<br>&gt; (UppercaseCamelStyle)<br>&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;<br>&gt; Even without a formal code style, if you tend to make property names<br>&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;<br>&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict with<br>&gt; enum usage.<br>&gt;<br>&gt; This will lead to a lot of ambiguity:<br>&gt;<br>&gt; func f() {<br>&gt;     let x = NSOperation()<br>&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;<br>&gt; This is workable, but still I think this is one of the best points of<br>&gt; Swift – the existence of instance scope where names are simply written<br>&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;<br>&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt; isn&#39;t an IDE (especially code review)<br>&gt;<br>&gt; This is the point where I entirely agree, good code should be easily read<br>&gt; in any context.<br>&gt; Again, may I suggest you take a look into using a style guide to<br>&gt; differentiate visually between local and instance scope?<br>&gt;<br>&gt; Ilya<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued work<br>&gt;&gt; in Swift has both strengthened and modified that ask. Here are several of<br>&gt;&gt; the examples discussed before:<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;<br>&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt; for that use).<br>&gt;&gt;<br>&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt; code review).<br>&gt;&gt;<br>&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt; it.<br>&gt;&gt;<br>&gt;&gt; -Rob<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/4c96c087/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; Ilya, I think this may be a presumptuous way of how well programmers<br>code. When deadlines hit, those first two suggestions go out the window.<br>And the fourth/last suggestion is not valid for me - changing naming<br>conventions would be both more confusing and more work (context switching)<br>than explicit self.<br></p><p>Well, I listed the things that help me deal with the shadowing problem;<br>your team is still able to use a different solution that you have chosen<br>for your project.<br></p><p>&gt;  Global state and class state should never be conflated<br></p><p>Well yes, moreover I tend to prohibit any global state at all. But moving<br>things from a *local* to instance scope is quite a useful pattern.<br></p><p>Whatever syntactic changes are required can be inserted by hand, but the<br>main point of this example is that I don&#39;t see why using an instance scope<br>should be more painful than using a local scope.<br></p><p>&gt; You can move code to and from closures at will<br></p><p>This is not something that I would call a benefit: normally, when moving<br>things to closures, you have to make a decision on the capture rules, that<br>is<br></p><p>func f() {<br>   bar.doStuff()<br>}<br></p><p>can become either<br></p><p>async { [bar = bar] in<br>  bar.doStuff()<br>}<br></p><p>or<br></p><p>async {<br>  self.bar.doStuff()<br>}<br></p><p>I wouldn&#39;t say that the second capture semantics – capturing the whole self<br>and using the value of bar at the time of executing it – is always what we<br>want when we extract code to closures.<br></p><p>&gt; This is actually the reason why my team chose unanimously to adopt<br>explicit self as a strict code style guideline.<br></p><p>That&#39;s a very interesting data point, thanks.<br></p><p>Ilya.<br></p><p>On Sun, Dec 13, 2015 at 9:33 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; &gt; - only expose the minimum necessary amount of names in any scope<br>&gt;<br>&gt; &gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt; name declarations<br>&gt;<br>&gt; &gt; - not use any globals, or at least name them in a visually different way<br>&gt; (UppercaseCamelStyle)<br>&gt;<br>&gt; &gt; - name properties and locals in a different way (classProperty,<br>&gt; local_var)<br>&gt;<br>&gt; Ilya, I think this may be a presumptuous way of how well programmers code.<br>&gt; When deadlines hit, those first two suggestions go out the window. And the<br>&gt; fourth/last suggestion is not valid for me - changing naming conventions<br>&gt; would be both more confusing and more work (context switching) than<br>&gt; explicit self.<br>&gt;<br>&gt;<br>&gt; The other tangible benefit of explicit self is that code becomes more<br>&gt; refactorable. You can move code to and from closures at will, and moving it<br>&gt; to unsuitable contexts gives immediate negative feedback. This is actually<br>&gt; the reason why my team chose unanimously to adopt explicit self as a strict<br>&gt; code style guideline.<br>&gt;<br>&gt;<br>&gt; -1 to the notion that it makes the transition from global state to class<br>&gt; state less fluid. Global state and class state should never be conflated<br>&gt; and implicit self can lead to such conflation. Global functions should be<br>&gt; carefully rewritten to class dynamics when the transition is desired, and<br>&gt; implicit self makes it easier to make that transition without careful<br>&gt; consideration.<br>&gt;<br>&gt;<br>&gt; Overall, I give +1 to the explicit self proposal, -1 to using a special<br>&gt; operator. Explicit self is neither hard nor particularly verbose in my<br>&gt; experience; with syntax highlighting, it happens to be very readable. I<br>&gt; love Ruby, but an @ operator for ivars would be very foreign and would kill<br>&gt; the aesthetic of the language for me. Not sure where others stand on it.<br>&gt;<br>&gt; On Sun, Dec 13, 2015, 4:16 AM ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; But implicit self is confusing in a lot of code<br>&gt;&gt;<br>&gt;&gt; On the other hand, it allows a logical explanation of how you can take<br>&gt;&gt; code from global scope and put it into an instance scope:<br>&gt;&gt;<br>&gt;&gt; let greeting = &quot;Hello&quot;<br>&gt;&gt; let name = &quot;Michael&quot;<br>&gt;&gt;<br>&gt;&gt; func greet() {<br>&gt;&gt;     print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; seemlessly becomes<br>&gt;&gt;<br>&gt;&gt; class Greeter {<br>&gt;&gt;<br>&gt;&gt;     let greeting = &quot;Hello&quot;<br>&gt;&gt;     let name = &quot;Michael&quot;<br>&gt;&gt;<br>&gt;&gt;     func greet() {<br>&gt;&gt;         print(&quot;\(greeting), \(name)&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; &gt; can (and does) lead to shadowing bugs,<br>&gt;&gt;<br>&gt;&gt; There are simple strategies that help to minimize the amount of<br>&gt;&gt; shadowing, e.g.<br>&gt;&gt;<br>&gt;&gt; - only expose the minimum necessary amount of names in any scope<br>&gt;&gt; - break functions into small part so that it&#39;s easy to see all the local<br>&gt;&gt; name declarations<br>&gt;&gt; - not use any globals, or at least name them in a visually different way<br>&gt;&gt; (UppercaseCamelStyle)<br>&gt;&gt; - name properties and locals in a different way (classProperty, local_var)<br>&gt;&gt;<br>&gt;&gt; Even without a formal code style, if you tend to make property names<br>&gt;&gt; longer and local names shorter, your risk of shadowing goes down.<br>&gt;&gt;<br>&gt;&gt; &gt; .x and .f() to mark implicit self. I realize that this may conflict<br>&gt;&gt; with enum usage.<br>&gt;&gt;<br>&gt;&gt; This will lead to a lot of ambiguity:<br>&gt;&gt;<br>&gt;&gt; func f() {<br>&gt;&gt;     let x = NSOperation()<br>&gt;&gt;     .name = &quot;Name&quot; // is it x.name or self.name??<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; &gt;  If so, then use another marker. For instance :x or ^x or anything.<br>&gt;&gt;<br>&gt;&gt; This is workable, but still I think this is one of the best points of<br>&gt;&gt; Swift – the existence of instance scope where names are simply written<br>&gt;&gt; as-is. This helps implementing patterns like &quot;take a long function and make<br>&gt;&gt; it into a struct with a bunch of small functions instead&quot;.<br>&gt;&gt;<br>&gt;&gt; &gt; is very difficult to reason about in diffs or any other interface that<br>&gt;&gt; isn&#39;t an IDE (especially code review)<br>&gt;&gt;<br>&gt;&gt; This is the point where I entirely agree, good code should be easily read<br>&gt;&gt; in any context.<br>&gt;&gt; Again, may I suggest you take a look into using a style guide to<br>&gt;&gt; differentiate visually between local and instance scope?<br>&gt;&gt;<br>&gt;&gt; Ilya<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 10:15 AM, Rob Napier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I wanted to reopen this discussion that seems to have trailed off.<br>&gt;&gt;&gt; Requesting the return of self was my very first ask of Swift if I remember<br>&gt;&gt;&gt; correctly (https://devforums.apple.com/message/1013085). Continued work<br>&gt;&gt;&gt; in Swift has both strengthened and modified that ask. Here are several of<br>&gt;&gt;&gt; the examples discussed before:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25<br>&gt;&gt;&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42<br>&gt;&gt;&gt; https://gist.github.com/rnapier/4213dc64206b17df6935<br>&gt;&gt;&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that<br>&gt;&gt;&gt; &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t<br>&gt;&gt;&gt; actually mean that, since you can use self. without capturing, and<br>&gt;&gt;&gt; sometimes have to, very often in init, so really it&#39;s basically meaningless<br>&gt;&gt;&gt; for that use).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize<br>&gt;&gt;&gt; that this may conflict with enum usage. If so, then use another marker. For<br>&gt;&gt;&gt; instance :x or ^x or anything. But implicit self is confusing in a lot of<br>&gt;&gt;&gt; code, can (and does) lead to shadowing bugs, and is very difficult to<br>&gt;&gt;&gt; reason about in diffs or any other interface that isn&#39;t an IDE (especially<br>&gt;&gt;&gt; code review).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts, David? I agree with your basic proposal; I just want to amend<br>&gt;&gt;&gt; it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Rob<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/f84c58dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 1:15 AM, Rob Napier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to reopen this discussion that seems to have trailed off. Requesting the return of self was my very first ask of Swift if I remember correctly (https://devforums.apple.com/message/1013085 &lt;https://devforums.apple.com/message/1013085&gt;). Continued work in Swift has both strengthened and modified that ask. Here are several of the examples discussed before:<br>&gt; <br>&gt; https://gist.github.com/schwa/94b11dc0a7a331f46b25 &lt;https://gist.github.com/schwa/94b11dc0a7a331f46b25&gt;<br>&gt; https://gist.github.com/rnapier/478465d1b15e95b98b42 &lt;https://gist.github.com/rnapier/478465d1b15e95b98b42&gt;<br>&gt; https://gist.github.com/rnapier/4213dc64206b17df6935 &lt;https://gist.github.com/rnapier/4213dc64206b17df6935&gt;<br>&gt; https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db &lt;https://gist.github.com/dwineman/d6c56ec0c0e2fdb761db&gt;<br>&gt; <br>&gt; I get that it seems tedious to type (and read) &quot;self.&quot; and I get that &quot;self.&quot; is currently a hint that self might be captured (but doesn&#39;t actually mean that, since you can use self. without capturing, and sometimes have to, very often in init, so really it&#39;s basically meaningless for that use).<br>&gt; <br>&gt; That&#39;s why I suggest using .x and .f() to mark implicit self. I realize that this may conflict with enum usage. If so, then use another marker. For instance :x or ^x or anything. But implicit self is confusing in a lot of code, can (and does) lead to shadowing bugs, and is very difficult to reason about in diffs or any other interface that isn&#39;t an IDE (especially code review).<br>&gt; <br>&gt; Thoughts, David? I agree with your basic proposal; I just want to amend it.<br>&gt; <br>&gt; -Rob<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front? That way, each person could choose whether they wanted implicit ‘self.’ or not. I know that this warning would be helpful to me, as I’ve already run into some rather weird bugs due to the implicit self, and it would be one less thing to debug.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/71162521/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On 13 Dec 2015, at 22:45, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front?<br></p><p>That is a good alternative.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f98dc2a5a610100f8528eeeb2ff3c282?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Andrew Brown</string> &lt;a.br at me.com&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>This discussion isn&#39;t going to be solved quickly so +1 for a compiler flag.<br>I&#39;d propose the flag generates an error if member variables are accessed without self.<br>Then after some time we can survey the community (or scan GitHub) to see how many people use the flag.<br>(making it a preference in Xcode would also help)<br></p><p>ABR.<br></p><p>&gt; On 14 Dec 2015, at 07:12, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 22:45, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front?<br>&gt; <br>&gt; That is a good alternative.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>+1 on a way to tell the compiler to warn the developper (a cli flag or a compiler directive in the file)<br></p><p>Pierre<br></p><p>&gt; Le 14 déc. 2015 à 09:01, Andrew Brown via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This discussion isn&#39;t going to be solved quickly so +1 for a compiler flag.<br>&gt; I&#39;d propose the flag generates an error if member variables are accessed without self.<br>&gt; Then after some time we can survey the community (or scan GitHub) to see how many people use the flag.<br>&gt; (making it a preference in Xcode would also help)<br>&gt; <br>&gt; ABR.<br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 07:12, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Dec 2015, at 22:45, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front?<br>&gt;&gt; <br>&gt;&gt; That is a good alternative.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 14 Dec 2015, at 09:01, Andrew Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This discussion isn&#39;t going to be solved quickly so +1 for a compiler flag.<br>&gt; I&#39;d propose the flag generates an error if member variables are accessed without self.<br></p><p>I’d propose it only be a warning. The reason for this is that Chris Lattner, in an unrelated thread, expressed an aversion to compiler flags that create different dialects of the language and I agree with him.<br></p><p><br>&gt; Then after some time we can survey the community (or scan GitHub) to see how many people use the flag.<br>&gt; (making it a preference in Xcode would also help)<br>&gt; <br>&gt; ABR.<br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 07:12, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Dec 2015, at 22:45, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front?<br>&gt;&gt; <br>&gt;&gt; That is a good alternative.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:29 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 14 Dec 2015, at 09:01, Andrew Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This discussion isn&#39;t going to be solved quickly so +1 for a compiler flag.<br>&gt;&gt; I&#39;d propose the flag generates an error if member variables are accessed without self.<br>&gt; <br>&gt; I’d propose it only be a warning. The reason for this is that Chris Lattner, in an unrelated thread, expressed an aversion to compiler flags that create different dialects of the language and I agree with him.<br></p><p>Please consider that individually-selectable warnings have a tendency to do the same thing.<br></p><p>Cheers,<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ed9a0d8cd44b62539b141f6c10405db1?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>Rob Napier</string> &lt;robnapier at gmail.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 10:32 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 14, 2015, at 7:29 AM, Jeremy Pereira via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 14 Dec 2015, at 09:01, Andrew Brown via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This discussion isn&#39;t going to be solved quickly so +1 for a compiler<br>&gt; flag.<br>&gt; &gt;&gt; I&#39;d propose the flag generates an error if member variables are<br>&gt; accessed without self.<br>&gt; &gt;<br>&gt; &gt; I’d propose it only be a warning. The reason for this is that Chris<br>&gt; Lattner, in an unrelated thread, expressed an aversion to compiler flags<br>&gt; that create different dialects of the language and I agree with him.<br>&gt;<br>&gt; Please consider that individually-selectable warnings have a tendency to<br>&gt; do the same thing.<br>&gt;<br>&gt;<br>Agreed. This should not be a warning. There should be a correct way to<br>reference global functions, constants, variables, methods, and properties.<br>If leading &quot;self.&quot; or punctuation is recommended, it should be required. If<br>scopes should have no distinction, then adding unnecessary &quot;self&quot; should be<br>discouraged at a minimum, not encouraged with an optional warning.<br></p><p>I prefer a distinction for methods and properties (specifically I prefer<br>punctuation), but I currently drop all unnecessary &quot;self.&quot; because<br>consistency is more critical than preference, and Apple&#39;s sample code<br>doesn&#39;t use &quot;self.&quot; except where required. Adding warnings makes it very<br>hard to share code that was written by different teams with different<br>opinions. It is better to bend than splinter.<br></p><p>But I do find that the current system (where a property looks like a local<br>variable and a method looks just like a global function) makes code review<br>harder in the tools that code review is usually done with (which are web<br>browsers, email and chat sessions, not editors or IDEs). Since I believe<br>that code review is second only to strong types in reducing bugs, I want<br>code review to be as easy as possible. So I advocate a distinction, and<br>think punctuation (particularly :x) is the lightest-weight solution.<br></p><p>But please, no warnings. There should be a single approach for stdlib, and<br>that approach should be what we all use.<br></p><p>-Rob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/35098992/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Proposal: Re-instate mandatory self for accessing instance properties and functions</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>I believe Chris stated he was fine with options that enforced existing syntax, just not ones that changed the grammar.<br></p><p>In this case, code would compile without the flag regardless of whether or not it was originally written with the flag.<br></p><p>I believe it was also stated that some sort of attribute in the file was preferred over a compiler flag, which definitely seems like a good idea to me.<br></p><p><br>On Dec 14, 2015, 09:29 -0600, Jeremy Pereira via swift-evolution&lt;swift-evolution at swift.org&gt;, wrote:<br>&gt;  <br>&gt; &gt; On 14 Dec 2015, at 09:01, Andrew Brown via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt;  <br>&gt; &gt; This discussion isn&#39;t going to be solved quickly so +1 for a compiler flag.<br>&gt; &gt; I&#39;d propose the flag generates an error if member variables are accessed without self.<br>&gt;  <br>&gt; I’d propose it only be a warning. The reason for this is that Chris Lattner, in an unrelated thread, expressed an aversion to compiler flags that create different dialects of the language and I agree with him.<br>&gt;  <br>&gt;  <br>&gt; &gt; Then after some time we can survey the community (or scan GitHub) to see how many people use the flag.<br>&gt; &gt; (making it a preference in Xcode would also help)<br>&gt; &gt;  <br>&gt; &gt; ABR.<br>&gt; &gt;  <br>&gt; &gt; &gt; On 14 Dec 2015, at 07:12, David Hart via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; On 13 Dec 2015, at 22:45, Charles Srstka via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Since opinions seem to be divided on this, how about adding an optional warning flag to the compiler, which would warn if one accessed an instance variable or method without self. in front?<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; That is a good alternative.<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/faaa60d8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
