<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  3, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi there,<br></p><p>I’m interested if this idea has some potential future in Swift or not.<br></p><p>Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br></p><p>Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br></p><p>As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).<br></p><p>The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br></p><p>struct A : Hashable { /* implement everything */ }<br></p><p>// Variant 1:<br>enum Test : A {<br>    case something = A(rawValue: A(value: &quot;something&quot;))<br>    case nothing = A(rawValue: A(value: &quot;nothing&quot;))  <br>}<br></p><p>// Variant 2:<br></p><p>protocol SomeFancyName : RawRepresentable { … }<br></p><p>struct Test : SomeFancyName {<br>     <br>    let rawValue: A<br>    init?(rawValue: A) {<br>            // Implement + reject unwanted `A`s  <br>    }<br>     <br>    static let something = A(rawValue: A(value: &quot;something&quot;))<br>    static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>}<br></p><p>let value = Test.something<br></p><p>switch value {<br>     <br>case .something:<br>    // handle<br>     <br>case .nothing:<br>    // handle<br>     <br>// Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161003/f7ba92c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I made a typo in my previous post.<br></p><p>Bikeshdding with correct types:<br></p><p>struct A : Hashable { /* implement everything */ }<br></p><p>// Variant 1:<br>enum Test : A {<br>    case something = A(value: &quot;something&quot;)<br>    case nothing = A(value: &quot;nothing&quot;)<br>}<br></p><p>// Variant 2:<br></p><p>protocol SomeFancyName : RawRepresentable { … }<br></p><p>struct Test : SomeFancyName {<br>      <br>    let rawValue: A<br>    init?(rawValue: A) {<br>            // Implement + reject unwanted `A`s   <br>    }<br>      <br>    static let something = Test(rawValue: A(value: &quot;something&quot;))<br>    static let nothing = Test(rawValue: A(value: &quot;nothing&quot;))<br>}<br></p><p>let value = Test.something<br></p><p>switch value {<br>      <br>case .something:<br>    // handle<br>      <br>case .nothing:<br>    // handle<br>      <br>// Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 3. Oktober 2016 um 21:50:07, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Hi there,<br></p><p>I’m interested if this idea has some potential future in Swift or not.<br></p><p>Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br></p><p>Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br></p><p>As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).<br></p><p>The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br></p><p>struct A : Hashable { /* implement everything */ }<br></p><p>// Variant 1:<br>enum Test : A {<br>    case something = A(rawValue: A(value: &quot;something&quot;))<br>    case nothing = A(rawValue: A(value: &quot;nothing&quot;))   <br>}<br></p><p>// Variant 2:<br></p><p>protocol SomeFancyName : RawRepresentable { … }<br></p><p>struct Test : SomeFancyName {<br>      <br>    let rawValue: A<br>    init?(rawValue: A) {<br>            // Implement + reject unwanted `A`s   <br>    }<br>      <br>    static let something = A(rawValue: A(value: &quot;something&quot;))<br>    static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>}<br></p><p>let value = Test.something<br></p><p>switch value {<br>      <br>case .something:<br>    // handle<br>      <br>case .nothing:<br>    // handle<br>      <br>// Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161003/c078aaa0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October  4, 2016 at 08:00:00am</p></header><div class="content"><p>+1.<br></p><p>I have several cases where I cannot use enums, this proposal would solve that.<br></p><p><br>&gt; On 03 Oct 2016, at 21:53, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I made a typo in my previous post.<br>&gt; <br>&gt; Bikeshdding with correct types:<br>&gt; <br>&gt; struct A : Hashable { /* implement everything */ }<br>&gt; <br>&gt; // Variant 1:<br>&gt; enum Test : A {<br>&gt;     case something = A(value: &quot;something&quot;)<br>&gt;     case nothing = A(value: &quot;nothing&quot;)<br>&gt; }<br>&gt; <br>&gt; // Variant 2:<br>&gt; <br>&gt; protocol SomeFancyName : RawRepresentable { … }<br>&gt; <br>&gt; struct Test : SomeFancyName {<br>&gt;       <br>&gt;     let rawValue: A<br>&gt;     init?(rawValue: A) {<br>&gt;             // Implement + reject unwanted `A`s   <br>&gt;     }<br>&gt;       <br>&gt;     static let something = Test(rawValue: A(value: &quot;something&quot;))<br>&gt;     static let nothing = Test(rawValue: A(value: &quot;nothing&quot;))<br>&gt; }<br>&gt; <br>&gt; let value = Test.something<br>&gt; <br>&gt; switch value {<br>&gt;       <br>&gt; case .something:<br>&gt;     // handle<br>&gt;       <br>&gt; case .nothing:<br>&gt;     // handle<br>&gt;       <br>&gt; // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 3. Oktober 2016 um 21:50:07, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I’m interested if this idea has some potential future in Swift or not.<br>&gt;&gt; <br>&gt;&gt; Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br>&gt;&gt; <br>&gt;&gt; Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br>&gt;&gt; <br>&gt;&gt; As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).<br>&gt;&gt; <br>&gt;&gt; The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br>&gt;&gt; <br>&gt;&gt; struct A : Hashable { /* implement everything */ }<br>&gt;&gt; <br>&gt;&gt; // Variant 1:<br>&gt;&gt; enum Test : A {<br>&gt;&gt;     case something = A(rawValue: A(value: &quot;something&quot;))<br>&gt;&gt;     case nothing = A(rawValue: A(value: &quot;nothing&quot;))   <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Variant 2:<br>&gt;&gt; <br>&gt;&gt; protocol SomeFancyName : RawRepresentable { … }<br>&gt;&gt; <br>&gt;&gt; struct Test : SomeFancyName {<br>&gt;&gt;       <br>&gt;&gt;     let rawValue: A<br>&gt;&gt;     init?(rawValue: A) {<br>&gt;&gt;             // Implement + reject unwanted `A`s   <br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     static let something = A(rawValue: A(value: &quot;something&quot;))<br>&gt;&gt;     static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let value = Test.something<br>&gt;&gt; <br>&gt;&gt; switch value {<br>&gt;&gt;       <br>&gt;&gt; case .something:<br>&gt;&gt;     // handle<br>&gt;&gt;       <br>&gt;&gt; case .nothing:<br>&gt;&gt;     // handle<br>&gt;&gt;       <br>&gt;&gt; // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  4, 2016 at 09:00:00am</p></header><div class="content"><p>There are still a lot of open questions here to solve.<br></p><p>How to statically guarantee the uniqueness + immutability of the hashValues?<br>Should we allow only the usage of an initializer?<br></p><p>Sometimes an init might be not enough and you’d wish you can use custom function which would return the same value for the same input you provide.<br></p><p>struct A : Hashable { … }<br>         <br>enum B : A {<br>    case a: A(someLabel: someInput)<br>    case b: createAFunction()<br>    case c: createA(with: someOtherInput)<br>}<br>Should we allow only value types here or how do we handle reference types?<br></p><p>A protocol to create custom enum-like types would be really interesting and useful. Instead of switch checking the value that conforms to that new protocol directly I’d suggest that we need some kind of an interface to satisfy and enable the enum-like switch usage (or maybe I’m totally wrong here).<br></p><p>protocol SomeFancyName : RawRepresentable {<br>    var interface: SomeType { get }<br>}<br></p><p>struct C : SomeFancyName { /* implement */ }<br></p><p>let c = C.someCase<br></p><p>switch c.interface {<br>     <br>case .someCase:<br>    // Handle<br>     <br>case .someOtherCase:<br>    // Handle<br>     <br>// No need for `default` when all cases are present<br>}<br>I couldn’t think up a simple and elegant model for such a protocol. Any suggestions is welcome.<br></p><p>Does the core team and the community feel this might have some potential future?<br></p><p>Does this impact the ABI somehow?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Oktober 2016 um 08:25:24, Rien (rien at balancingrock.nl) schrieb:<br></p><p>+1.  <br></p><p>I have several cases where I cannot use enums, this proposal would solve that.  <br></p><p><br>&gt; On 03 Oct 2016, at 21:53, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:  <br>&gt;  <br>&gt; I made a typo in my previous post.  <br>&gt;  <br>&gt; Bikeshdding with correct types:  <br>&gt;  <br>&gt; struct A : Hashable { /* implement everything */ }  <br>&gt;  <br>&gt; // Variant 1:  <br>&gt; enum Test : A {  <br>&gt; case something = A(value: &quot;something&quot;)  <br>&gt; case nothing = A(value: &quot;nothing&quot;)  <br>&gt; }  <br>&gt;  <br>&gt; // Variant 2:  <br>&gt;  <br>&gt; protocol SomeFancyName : RawRepresentable { … }  <br>&gt;  <br>&gt; struct Test : SomeFancyName {  <br>&gt;  <br>&gt; let rawValue: A  <br>&gt; init?(rawValue: A) {  <br>&gt; // Implement + reject unwanted `A`s  <br>&gt; }  <br>&gt;  <br>&gt; static let something = Test(rawValue: A(value: &quot;something&quot;))  <br>&gt; static let nothing = Test(rawValue: A(value: &quot;nothing&quot;))  <br>&gt; }  <br>&gt;  <br>&gt; let value = Test.something  <br>&gt;  <br>&gt; switch value {  <br>&gt;  <br>&gt; case .something:  <br>&gt; // handle  <br>&gt;  <br>&gt; case .nothing:  <br>&gt; // handle  <br>&gt;  <br>&gt; // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present  <br>&gt; }  <br>&gt;  <br>&gt;  <br>&gt;  <br>&gt;  <br>&gt; --  <br>&gt; Adrian Zubarev  <br>&gt; Sent with Airmail  <br>&gt;  <br>&gt; Am 3. Oktober 2016 um 21:50:07, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:  <br>&gt;  <br>&gt;&gt; Hi there,  <br>&gt;&gt;  <br>&gt;&gt; I’m interested if this idea has some potential future in Swift or not.  <br>&gt;&gt;  <br>&gt;&gt; Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).  <br>&gt;&gt;  <br>&gt;&gt; Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!  <br>&gt;&gt;  <br>&gt;&gt; As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).  <br>&gt;&gt;  <br>&gt;&gt; The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.  <br>&gt;&gt;  <br>&gt;&gt; struct A : Hashable { /* implement everything */ }  <br>&gt;&gt;  <br>&gt;&gt; // Variant 1:  <br>&gt;&gt; enum Test : A {  <br>&gt;&gt; case something = A(rawValue: A(value: &quot;something&quot;))  <br>&gt;&gt; case nothing = A(rawValue: A(value: &quot;nothing&quot;))  <br>&gt;&gt; }  <br>&gt;&gt;  <br>&gt;&gt; // Variant 2:  <br>&gt;&gt;  <br>&gt;&gt; protocol SomeFancyName : RawRepresentable { … }  <br>&gt;&gt;  <br>&gt;&gt; struct Test : SomeFancyName {  <br>&gt;&gt;  <br>&gt;&gt; let rawValue: A  <br>&gt;&gt; init?(rawValue: A) {  <br>&gt;&gt; // Implement + reject unwanted `A`s  <br>&gt;&gt; }  <br>&gt;&gt;  <br>&gt;&gt; static let something = A(rawValue: A(value: &quot;something&quot;))  <br>&gt;&gt; static let nothing = A(rawValue: A(value: &quot;nothing&quot;))  <br>&gt;&gt; }  <br>&gt;&gt;  <br>&gt;&gt; let value = Test.something  <br>&gt;&gt;  <br>&gt;&gt; switch value {  <br>&gt;&gt;  <br>&gt;&gt; case .something:  <br>&gt;&gt; // handle  <br>&gt;&gt;  <br>&gt;&gt; case .nothing:  <br>&gt;&gt; // handle  <br>&gt;&gt;  <br>&gt;&gt; // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present  <br>&gt;&gt; }  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; --  <br>&gt;&gt; Adrian Zubarev  <br>&gt;&gt; Sent with Airmail  <br>&gt;  <br>&gt; _______________________________________________  <br>&gt; swift-evolution mailing list  <br>&gt; swift-evolution at swift.org  <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/e67f4562/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  4, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Oct 4, 2016 at 2:07 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There are still a lot of open questions here to solve.<br>&gt;<br>&gt;    - How to statically guarantee the uniqueness + immutability of the<br>&gt;    hashValues?<br>&gt;       -<br>&gt;<br>&gt;       Should we allow only the usage of an initializer?<br>&gt;       -<br>&gt;<br>&gt;       Sometimes an init might be not enough and you’d wish you can use<br>&gt;       custom function which would return the same value for the same input you<br>&gt;       provide.<br>&gt;<br>&gt;       struct A : Hashable { … }<br>&gt;<br>&gt;       enum B : A {<br>&gt;           case a: A(someLabel: someInput)<br>&gt;           case b: createAFunction()<br>&gt;           case c: createA(with: someOtherInput)<br>&gt;       }<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       Should we allow only value types here or how do we handle reference<br>&gt;       types?<br>&gt;<br>&gt; A protocol to create custom enum-like types would be really interesting<br>&gt; and useful. Instead of switch checking the value that conforms to that<br>&gt; new protocol directly I’d suggest that we need some kind of an interface to<br>&gt; satisfy and enable the enum-like switch usage (or maybe I’m totally wrong<br>&gt; here).<br>&gt;<br>&gt; protocol SomeFancyName : RawRepresentable {<br>&gt;     var interface: SomeType { get }<br>&gt; }<br>&gt;<br>&gt; struct C : SomeFancyName { /* implement */ }<br>&gt;<br>&gt; let c = C.someCase<br>&gt;<br>&gt; switch c.interface {<br>&gt;<br>&gt; case .someCase:<br>&gt;     // Handle<br>&gt;<br>&gt; case .someOtherCase:<br>&gt;     // Handle<br>&gt;<br>&gt; // No need for `default` when all cases are present<br>&gt; }<br>&gt;<br>&gt; I couldn’t think up a simple and elegant model for such a protocol. Any<br>&gt; suggestions is welcome.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Does the core team and the community feel this might have some<br>&gt;    potential future?<br>&gt;    -<br>&gt;<br>&gt;    Does this impact the ABI somehow?<br>&gt;<br>&gt;<br>A protocol wouldn&#39;t work, I don&#39;t think, because classes can be extended<br>and so exhaustiveness can&#39;t be guaranteed, and there is no syntax to limit<br>protocols only to structs and final classes.<br></p><p>While I&#39;ve sometimes wished RawRepresentable could be used with more<br>Hashable types, for your motivating problem, you can already get pretty<br>close to your desired end goal:<br></p><p>```<br></p><p>protocol _RawRepresentable : RawRepresentable { }<br></p><p><br>extension _RawRepresentable where RawValue : Hashable {<br></p><p>  static func ~= (lhs: Self, rhs: Self) -&gt; Bool {<br></p><p>    return lhs.rawValue == rhs.rawValue<br></p><p>  }<br></p><p>}<br></p><p><br>struct Example : _RawRepresentable {<br></p><p>  let rawValue: String<br></p><p>  init?(rawValue: String) {<br></p><p>    switch rawValue {<br></p><p>    case &quot;foo&quot;, &quot;bar&quot;:<br></p><p>      self.rawValue = rawValue<br></p><p>    default:<br></p><p>      return nil<br></p><p>    }<br></p><p>  }<br></p><p>  static let foo = Example(rawValue: &quot;foo&quot;)!<br></p><p>  static let bar = Example(rawValue: &quot;bar&quot;)!<br></p><p>}<br></p><p><br>let ex = Example.foo<br></p><p><br>switch ex {<br></p><p>case Example.foo: // the syntax could be made more intelligent here to<br>allow `.foo`<br></p><p>  print(&quot;Foo!&quot;)<br></p><p>case Example.bar:<br></p><p>  print(&quot;Bar!&quot;)<br></p><p>default:<br></p><p>  fatalError()<br></p><p>}<br>```<br></p><p>As in the other thread, I don&#39;t understand your unwillingness to writing a<br>default case. It is a very practical solution, and it tells your reader<br>that your custom type is really meant to be switched over exhaustively. In<br>fact, it does so at the point of use much more clearly than a protocol<br>conformance that would not be nearly as obvious to the reader of the code.<br></p><p><br></p><p>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 4. Oktober 2016 um 08:25:24, Rien (rien at balancingrock.nl) schrieb:<br>&gt;<br>&gt; +1.<br>&gt;<br>&gt; I have several cases where I cannot use enums, this proposal would solve<br>&gt; that.<br>&gt;<br>&gt;<br>&gt; &gt; On 03 Oct 2016, at 21:53, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I made a typo in my previous post.<br>&gt; &gt;<br>&gt; &gt; Bikeshdding with correct types:<br>&gt; &gt;<br>&gt; &gt; struct A : Hashable { /* implement everything */ }<br>&gt; &gt;<br>&gt; &gt; // Variant 1:<br>&gt; &gt; enum Test : A {<br>&gt; &gt; case something = A(value: &quot;something&quot;)<br>&gt; &gt; case nothing = A(value: &quot;nothing&quot;)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Variant 2:<br>&gt; &gt;<br>&gt; &gt; protocol SomeFancyName : RawRepresentable { … }<br>&gt; &gt;<br>&gt; &gt; struct Test : SomeFancyName {<br>&gt; &gt;<br>&gt; &gt; let rawValue: A<br>&gt; &gt; init?(rawValue: A) {<br>&gt; &gt; // Implement + reject unwanted `A`s<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; static let something = Test(rawValue: A(value: &quot;something&quot;))<br>&gt; &gt; static let nothing = Test(rawValue: A(value: &quot;nothing&quot;))<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; let value = Test.something<br>&gt; &gt;<br>&gt; &gt; switch value {<br>&gt; &gt;<br>&gt; &gt; case .something:<br>&gt; &gt; // handle<br>&gt; &gt;<br>&gt; &gt; case .nothing:<br>&gt; &gt; // handle<br>&gt; &gt;<br>&gt; &gt; // Because of `SomeFancyName` the switch can use enum-like pattern<br>&gt; matching + does not need the `default` case when all cases are present<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt; Am 3. Oktober 2016 um 21:50:07, Adrian Zubarev (<br>&gt; adrian.zubarev at devandartist.com) schrieb:<br>&gt; &gt;<br>&gt; &gt;&gt; Hi there,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m interested if this idea has some potential future in Swift or not.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Currently RawRepresentable enums accept only a subset of literal types<br>&gt; like String, Character and the Integer family (enum Name : String { … }).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sometimes this is not enough for my use-case and I wish I could feed my<br>&gt; enums with other Hashable types!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As a workaround I can create a custom struct or even a class and<br>&gt; conform it to RawRepresentable and fake an enum with some static variables<br>&gt; (similar to what is done with OptionSet types).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The problem there is that I cannot use the same switch pattern matching<br>&gt; like with enums. I’d wish either enums could accept Hashable types (maybe<br>&gt; with some restriction) or the existence on a protocol to build custom<br>&gt; enum-like types with strucs/classes and use the same switch pattern<br>&gt; matching.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct A : Hashable { /* implement everything */ }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Variant 1:<br>&gt; &gt;&gt; enum Test : A {<br>&gt; &gt;&gt; case something = A(rawValue: A(value: &quot;something&quot;))<br>&gt; &gt;&gt; case nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Variant 2:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol SomeFancyName : RawRepresentable { … }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct Test : SomeFancyName {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let rawValue: A<br>&gt; &gt;&gt; init?(rawValue: A) {<br>&gt; &gt;&gt; // Implement + reject unwanted `A`s<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; static let something = A(rawValue: A(value: &quot;something&quot;))<br>&gt; &gt;&gt; static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let value = Test.something<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; switch value {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; case .something:<br>&gt; &gt;&gt; // handle<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; case .nothing:<br>&gt; &gt;&gt; // handle<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Because of `SomeFancyName` the switch can use enum-like pattern<br>&gt; matching + does not need the `default` case when all cases are present<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Adrian Zubarev<br>&gt; &gt;&gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/26f1b2de/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Enum raw types don&#39;t have to be strings/integers, but they have to be expressable by string or integer literals.   We don&#39;t guarantee uniqueness per se, but we do check for duplicate literals and auto-increment integers to fill gaps.<br>  <br>  <br></p><p>  <br>  <br>  <br>  <br></p><p>  <br>So all you have to do is make your custom type conform to ExpressibleByStringLiteral and you can use it as an enum&#39;s raw type.<br>  <br></p><p>  <br>Karl<br>  <br>  <br>&gt;   <br>&gt; On Oct 3, 2016 at 9:50 pm,  &lt;Adrian Zubarev via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;<br>&gt; Hi there,<br>&gt;<br>&gt;   <br>&gt;<br>&gt; I’m interested if this idea has some potential future in Swift or not.<br>&gt;<br>&gt;   <br>&gt;<br>&gt; Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br>&gt;<br>&gt;   <br>&gt;<br>&gt; Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br>&gt;<br>&gt;   <br>&gt;<br>&gt; As a workaround I can create a custom struct or even a class and conform it to  RawRepresentable  and fake an enum with some static variables (similar to what is done with  OptionSet  types).<br>&gt;<br>&gt;   <br>&gt;<br>&gt; The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br>&gt;<br>&gt;   <br>&gt;   struct A : Hashable { /* implement everything */ } // Variant 1: enum Test : A { case something = A(rawValue: A(value: &quot;something&quot;)) case nothing = A(rawValue: A(value: &quot;nothing&quot;)) } // Variant 2: protocol SomeFancyName : RawRepresentable { … } struct Test : SomeFancyName { let rawValue: A init?(rawValue: A) { // Implement + reject unwanted `A`s } static let something = A(rawValue: A(value: &quot;something&quot;)) static let nothing = A(rawValue: A(value: &quot;nothing&quot;)) } let value = Test.something switch value { case .something: // handle case .nothing: // handle // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present }    <br>&gt;   <br>&gt;<br>&gt;<br>&gt;<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;  --   <br>&gt;  Adrian Zubarev<br>&gt;  Sent with Airmail       <br>&gt;   <br>&gt;<br>&gt;<br>&gt;<br>&gt;   <br>&gt;  _______________________________________________ swift-evolution mailing list  swift-evolution at swift.org (mailto:swift-evolution at swift.org)   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;   <br>  <br>  <br>   <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/532aa25e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  4, 2016 at 07:00:00pm</p></header><div class="content"><p>Also IIRC, both of these limitations go away if you conform to RawRepresentable yourself.<br>  <br></p><p>  <br>There is no magic to RawRep. The compiler will just synthesise a failable initialiser and &#39;rawValue&#39; computed property accessor. Both just simple switch statements matching your provided literals and returning the appropriate enum case.<br>  <br> Specifically, RawRep does not change the raw representation of the enum. It&#39;s always going to be the smaller integer that fits the number of cases.<br>    <br>  <br>  <br>  <br></p><p>  <br>  <br>  <br>  <br></p><p>  <br>  <br>&gt;   <br>&gt; On Oct 4, 2016 at 6:56 pm,  &lt;Karl Wagner (mailto:razielim at gmail.com)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt; Enum raw types don&#39;t have to be strings/integers, but they have to be expressable by string or integer literals.   We don&#39;t guarantee uniqueness per se, but we do check for duplicate literals and auto-increment integers to fill gaps.<br>&gt;   <br>&gt;   <br>&gt;<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;<br>&gt;   <br>&gt; So all you have to do is make your custom type conform to ExpressibleByStringLiteral and you can use it as an enum&#39;s raw type.<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; Karl<br>&gt;   <br>&gt;   <br>&gt; &gt;   <br>&gt; &gt; On Oct 3, 2016 at 9:50 pm,  &lt;Adrian Zubarev via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; Hi there,<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; I’m interested if this idea has some potential future in Swift or not.<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; As a workaround I can create a custom struct or even a class and conform it to  RawRepresentable  and fake an enum with some static variables (similar to what is done with  OptionSet  types).<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt; The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;   struct A : Hashable { /* implement everything */ } // Variant 1: enum Test : A { case something = A(rawValue: A(value: &quot;something&quot;)) case nothing = A(rawValue: A(value: &quot;nothing&quot;)) } // Variant 2: protocol SomeFancyName : RawRepresentable { … } struct Test : SomeFancyName { let rawValue: A init?(rawValue: A) { // Implement + reject unwanted `A`s } static let something = A(rawValue: A(value: &quot;something&quot;)) static let nothing = A(rawValue: A(value: &quot;nothing&quot;)) } let value = Test.something switch value { case .something: // handle case .nothing: // handle // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present }    <br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;  --   <br>&gt; &gt;  Adrian Zubarev<br>&gt; &gt;  Sent with Airmail       <br>&gt; &gt;   <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;   <br>&gt; &gt;  _______________________________________________ swift-evolution mailing list  swift-evolution at swift.org (mailto:swift-evolution at swift.org)   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>  <br>  <br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/228646cc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 12:50 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; I’m interested if this idea has some potential future in Swift or not.<br>&gt; <br>&gt; Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br>&gt; <br>&gt; Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br>&gt; <br>&gt; As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).<br>&gt; <br>&gt; <br></p><p>The literal type constraint only affects the sugar syntax using the &#39;: String&#39; and &#39;case X = 1&#39; syntax. If you write an enum&#39;s conformance explicitly, you can use any raw type you like:<br></p><p>enum Test: RawRepresentable {<br>  case something, nothing<br></p><p>  init?(rawValue: A) {<br>    switch rawValue.value {<br>    case &quot;something&quot;: self = .something<br>    case &quot;nothing&quot;: self = .nothing<br>    default: return nil<br>    }<br>  }<br></p><p>  var rawValue: A {<br>    switch self {<br>    case .something: return A(value: &quot;something&quot;)<br>    case .nothing: return A(value: &quot;nothing&quot;)<br>    }<br>  }<br>}<br></p><p>though it&#39;s up to you at this point to guarantee the 1:1 correspondence between raw values and enum values that RawRepresentable assumes.<br></p><p>-Joe<br>&gt; The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br>&gt; <br>&gt; struct A : Hashable { /* implement everything */ }<br>&gt; <br>&gt; // Variant 1:<br>&gt; enum Test : A {<br>&gt;     case something = A(rawValue: A(value: &quot;something&quot;))<br>&gt;     case nothing = A(rawValue: A(value: &quot;nothing&quot;))  <br>&gt; }<br>&gt; <br>&gt; // Variant 2:<br>&gt; <br>&gt; protocol SomeFancyName : RawRepresentable { … }<br>&gt; <br>&gt; struct Test : SomeFancyName {<br>&gt;      <br>&gt;     let rawValue: A<br>&gt;     init?(rawValue: A) {<br>&gt;             // Implement + reject unwanted `A`s  <br>&gt;     }<br>&gt;      <br>&gt;     static let something = A(rawValue: A(value: &quot;something&quot;))<br>&gt;     static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>&gt; }<br>&gt; <br>&gt; let value = Test.something<br>&gt; <br>&gt; switch value {<br>&gt;      <br>&gt; case .something:<br>&gt;     // handle<br>&gt;      <br>&gt; case .nothing:<br>&gt;     // handle<br>&gt;      <br>&gt; // Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/9940b317/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  4, 2016 at 08:00:00pm</p></header><div class="content"><p>Doesn’t this imply more performance cost? Don’t get me wrong but the value here is not fixed and computed all over again which might waste resources if the calculation is complicated. Sure we could build some workarounds here and there, but the codebase won’t get any prettier after that.<br></p><p>Another though is that enums just need stored properties to solve the main problem here nicely. I don’t remember what the outcome of that talk was back then. I’ll search for that conversation soon.<br></p><p>Anyways, thank you Joe for showing us the possible workaround.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Oktober 2016 um 19:52:11, Joe Groff (jgroff at apple.com) schrieb:<br></p><p><br>On Oct 3, 2016, at 12:50 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hi there,<br></p><p>I’m interested if this idea has some potential future in Swift or not.<br></p><p>Currently RawRepresentable enums accept only a subset of literal types like String, Character and the Integer family (enum Name : String { … }).<br></p><p>Sometimes this is not enough for my use-case and I wish I could feed my enums with other Hashable types!<br></p><p>As a workaround I can create a custom struct or even a class and conform it to RawRepresentable and fake an enum with some static variables (similar to what is done with OptionSet types).<br></p><p><br></p><p>The literal type constraint only affects the sugar syntax using the &#39;: String&#39; and &#39;case X = 1&#39; syntax. If you write an enum&#39;s conformance explicitly, you can use any raw type you like:<br></p><p>enum Test: RawRepresentable {<br>  case something, nothing<br></p><p>  init?(rawValue: A) {<br>    switch rawValue.value {<br>    case &quot;something&quot;: self = .something<br>    case &quot;nothing&quot;: self = .nothing<br>    default: return nil<br>    }<br>  }<br></p><p>  var rawValue: A {<br>    switch self {<br>    case .something: return A(value: &quot;something&quot;)<br>    case .nothing: return A(value: &quot;nothing&quot;)<br>    }<br>  }<br>}<br></p><p>though it&#39;s up to you at this point to guarantee the 1:1 correspondence between raw values and enum values that RawRepresentable assumes.<br></p><p>-Joe<br>The problem there is that I cannot use the same switch pattern matching like with enums. I’d wish either enums could accept Hashable types (maybe with some restriction) or the existence on a protocol to build custom enum-like types with strucs/classes and use the same switch pattern matching.<br></p><p>struct A : Hashable { /* implement everything */ }<br></p><p>// Variant 1:<br>enum Test : A {<br>    case something = A(rawValue: A(value: &quot;something&quot;))<br>    case nothing = A(rawValue: A(value: &quot;nothing&quot;))   <br>}<br></p><p>// Variant 2:<br></p><p>protocol SomeFancyName : RawRepresentable { … }<br></p><p>struct Test : SomeFancyName {<br>      <br>    let rawValue: A<br>    init?(rawValue: A) {<br>            // Implement + reject unwanted `A`s   <br>    }<br>      <br>    static let something = A(rawValue: A(value: &quot;something&quot;))<br>    static let nothing = A(rawValue: A(value: &quot;nothing&quot;))<br>}<br></p><p>let value = Test.something<br></p><p>switch value {<br>      <br>case .something:<br>    // handle<br>      <br>case .nothing:<br>    // handle<br>      <br>// Because of `SomeFancyName` the switch can use enum-like pattern matching + does not need the `default` case when all cases are present<br>}<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/d1323003/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 11:07 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt; <br>&gt; Doesn’t this imply more performance cost? Don’t get me wrong but the value here is not fixed and computed all over again which might waste resources if the calculation is complicated. Sure we could build some workarounds here and there, but the codebase won’t get any prettier after that.<br>&gt; <br>I doubt it. Formally, integer and string literals are also constructor calls, but they&#39;re inlined and constant-folded away in most cases. A struct construction is also likely to be optimized. The code pattern I presented is exactly what the compiler automatically generates when you use the sugar syntax.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/50ebe95c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  4, 2016 at 08:00:00pm</p></header><div class="content"><p>Okay thanks, I’ll keep that in mind.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Oktober 2016 um 20:16:12, Joe Groff (jgroff at apple.com) schrieb:<br></p><p><br>On Oct 4, 2016, at 11:07 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br></p><p>Doesn’t this imply more performance cost? Don’t get me wrong but the value here is not fixed and computed all over again which might waste resources if the calculation is complicated. Sure we could build some workarounds here and there, but the codebase won’t get any prettier after that.<br></p><p>I doubt it. Formally, integer and string literals are also constructor calls, but they&#39;re inlined and constant-folded away in most cases. A struct construction is also likely to be optimized. The code pattern I presented is exactly what the compiler automatically generates when you use the sugar syntax.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/9f72687e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Pitch] Hashable types on RawRepresentable enums or a protocol for custom enum-like types</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>October  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 4 Oct 2016, at 19:16, Joe Groff wrote:<br>&gt; <br>&gt;&gt; On Oct 4, 2016, at 11:07 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Doesn’t this imply more performance cost? Don’t get me wrong but the value here is not fixed and computed all over again which might waste resources if the calculation is complicated. Sure we could build some workarounds here and there, but the codebase won’t get any prettier after that.<br>&gt; <br>&gt; I doubt it. Formally, integer and string literals are also constructor calls, but they&#39;re inlined and constant-folded away in most cases. A struct construction is also likely to be optimized. The code pattern I presented is exactly what the compiler automatically generates when you use the sugar syntax.<br>&gt; <br>&gt; -Joe<br></p><p>It can be surprising when enum cases don&#39;t behave like `static let` properties:<br></p><p>	Welcome to Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38).<br>	  1&gt; import Foundation<br>	  2&gt; enum Test: NSString {<br>	  3.     case test<br>	  4. }<br>	  5&gt; Test.test.rawValue === Test.test.rawValue<br>	$R0: Bool = false<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
