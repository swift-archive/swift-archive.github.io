<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Reference equivalent to value-type &#39;enum&#39;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello swift-evolution:<br></p><p>Based on recent conversations on the list, I&#39;d like to float a trial<br>balloon: an &quot;enum class&quot; kind which is analogous to classes in the same way<br>existing enums are to structs. This is a data type which allows the user to<br>define a number of cases, like enums, and can participate in pattern<br>matching and exhaustivity analysis. Instances of an enum class are<br>reference types, which enables (for example) graph nodes with a built-in<br>concept of identity.<br></p><p>To be slightly more fanciful, perhaps such a kind could be treated as an<br>&#39;almost-final&#39; class, with each case being a nested type which is defined<br>as a final subclass of the enum class. Cases could then define their own<br>behavior:<br></p><p>enum class GraphNode {<br>  case Node(left: GraphNode, right: GraphNode) {<br>    override func foo() { ... }<br>    func nodeSpecificMethod() { ... }<br>  }<br></p><p>  case Leaf {<br>    override func foo() { ... }<br>    func leafSpecificMethod() { ... }<br>  }<br></p><p>  func foo() { ... }<br>}<br></p><p>let x : GraphNode = GraphNode.newEmptyTree()<br>let y : GraphNode = GraphNode.Node(l, r)<br>let z : GraphNode = GraphNode.Leaf()<br>let a : GraphNode.Leaf = GraphNode.Leaf()<br></p><p>Enum classes would not be subclassible, and extensions would not be able to<br>define new cases (as is the case with normal enums at the present time).<br></p><p>My superficial analysis seems to suggest that this would solve two issues:<br>providing a reference-semantics type with all the pattern matching<br>functionality of current enums, and providing a construct for modeling<br>case-class style ADTs where each case should be treated as a subtype (as<br>has been occasionally proposed).<br></p><p>I would like feedback as to:<br>- Whether this is something that would be useful enough to justify<br>additional language features<br>- Whether this is something that would be theoretically well-founded and<br>elegant<br></p><p>Thanks for your time, and have a great day!<br></p><p>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/1fa85249/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Reference equivalent to value-type &#39;enum&#39;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 4:46 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution:<br>&gt; <br>&gt; Based on recent conversations on the list, I&#39;d like to float a trial balloon: an &quot;enum class&quot; kind which is analogous to classes in the same way existing enums are to structs. This is a data type which allows the user to define a number of cases, like enums, and can participate in pattern matching and exhaustivity analysis. Instances of an enum class are reference types, which enables (for example) graph nodes with a built-in concept of identity.<br>&gt; <br>&gt; To be slightly more fanciful, perhaps such a kind could be treated as an &#39;almost-final&#39; class, with each case being a nested type which is defined as a final subclass of the enum class. Cases could then define their own behavior:<br>&gt; <br>&gt; enum class GraphNode {<br>&gt;   case Node(left: GraphNode, right: GraphNode) {<br>&gt;     override func foo() { ... }<br>&gt;     func nodeSpecificMethod() { ... }<br>&gt;   }<br>&gt; <br>&gt;   case Leaf {<br>&gt;     override func foo() { ... }<br>&gt;     func leafSpecificMethod() { ... }<br>&gt;   }<br>&gt; <br>&gt;   func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; let x : GraphNode = GraphNode.newEmptyTree()<br>&gt; let y : GraphNode = GraphNode.Node(l, r)<br>&gt; let z : GraphNode = GraphNode.Leaf()<br>&gt; let a : GraphNode.Leaf = GraphNode.Leaf()<br>&gt; <br>&gt; Enum classes would not be subclassible, and extensions would not be able to define new cases (as is the case with normal enums at the present time).<br>&gt; <br>&gt; My superficial analysis seems to suggest that this would solve two issues: providing a reference-semantics type with all the pattern matching functionality of current enums, and providing a construct for modeling case-class style ADTs where each case should be treated as a subtype (as has been occasionally proposed).<br>&gt; <br>&gt; I would like feedback as to:<br>&gt; - Whether this is something that would be useful enough to justify additional language features<br>&gt; - Whether this is something that would be theoretically well-founded and elegant<br>&gt; <br></p><p>This is definitely an idea worth exploring.  I am interested in hearing from folks who have experience with Scala case classes.  How have you found them useful in ways that Swiftâ€™s current enums do not address?  <br></p><p><br>&gt; Thanks for your time, and have a great day!<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6a925eec074f3a4a853412a55bbc543e?s=50"></div><header><strong>[Pitch] Reference equivalent to value-type &#39;enum&#39;</strong> from <string>Joshua Kopin</string> &lt;jkopin at apple.com&gt;<p>May  5, 2016 at 11:00:00am</p></header><div class="content"><p>+1 -- at the very least, this strikes me as an exciting and provocative <br>new angle from which to look at the value / reference / subtype / <br>pattern matching problem space that&#39;s been discussed on this list.<br></p><p>On 4 May 2016, at 15:25, Matthew Johnson via swift-evolution wrote:<br></p><p>&gt;&gt; On May 4, 2016, at 4:46 PM, Austin Zheng via swift-evolution <br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello swift-evolution:<br>&gt;&gt;<br>&gt;&gt; Based on recent conversations on the list, I&#39;d like to float a trial <br>&gt;&gt; balloon: an &quot;enum class&quot; kind which is analogous to classes in the <br>&gt;&gt; same way existing enums are to structs. This is a data type which <br>&gt;&gt; allows the user to define a number of cases, like enums, and can <br>&gt;&gt; participate in pattern matching and exhaustivity analysis. Instances <br>&gt;&gt; of an enum class are reference types, which enables (for example) <br>&gt;&gt; graph nodes with a built-in concept of identity.<br>&gt;&gt;<br>&gt;&gt; To be slightly more fanciful, perhaps such a kind could be treated as <br>&gt;&gt; an &#39;almost-final&#39; class, with each case being a nested type which is <br>&gt;&gt; defined as a final subclass of the enum class. Cases could then <br>&gt;&gt; define their own behavior:<br>&gt;&gt;<br>&gt;&gt; enum class GraphNode {<br>&gt;&gt;   case Node(left: GraphNode, right: GraphNode) {<br>&gt;&gt;     override func foo() { ... }<br>&gt;&gt;     func nodeSpecificMethod() { ... }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   case Leaf {<br>&gt;&gt;     override func foo() { ... }<br>&gt;&gt;     func leafSpecificMethod() { ... }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   func foo() { ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let x : GraphNode = GraphNode.newEmptyTree()<br>&gt;&gt; let y : GraphNode = GraphNode.Node(l, r)<br>&gt;&gt; let z : GraphNode = GraphNode.Leaf()<br>&gt;&gt; let a : GraphNode.Leaf = GraphNode.Leaf()<br>&gt;&gt;<br>&gt;&gt; Enum classes would not be subclassible, and extensions would not be <br>&gt;&gt; able to define new cases (as is the case with normal enums at the <br>&gt;&gt; present time).<br>&gt;&gt;<br>&gt;&gt; My superficial analysis seems to suggest that this would solve two <br>&gt;&gt; issues: providing a reference-semantics type with all the pattern <br>&gt;&gt; matching functionality of current enums, and providing a construct <br>&gt;&gt; for modeling case-class style ADTs where each case should be treated <br>&gt;&gt; as a subtype (as has been occasionally proposed).<br>&gt;&gt;<br>&gt;&gt; I would like feedback as to:<br>&gt;&gt; - Whether this is something that would be useful enough to justify <br>&gt;&gt; additional language features<br>&gt;&gt; - Whether this is something that would be theoretically well-founded <br>&gt;&gt; and elegant<br>&gt;&gt;<br>&gt;<br>&gt; This is definitely an idea worth exploring.  I am interested in <br>&gt; hearing from folks who have experience with Scala case classes.  How <br>&gt; have you found them useful in ways that Swiftâ€™s current enums do not <br>&gt; address?<br>&gt;<br>&gt;<br>&gt;&gt; Thanks for your time, and have a great day!<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
