<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 15, 2016 at 07:00:00pm</p></header><div class="content"><p>Perhaps the proposal can be amended with this information with the approval of the core team. I imagine that a list of rules and a chart might be valuable. Even if adding to the proposal is the wrong way to go, a publicly accessible and vetted document would be useful to refer people to. Maybe someone can step up and form a working group.<br></p><p>-- E<br></p><p>&gt; On Jun 15, 2016, at 5:51 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think you guys are making this more complicated than it is. The rules here seem fairly simple:<br>&gt; <br>&gt; 1. The default access level is “internal”.<br>&gt; <br>&gt; 2. A type declared “private” at the top level will be visible to the file only.<br>&gt; <br>&gt; 3. If they are not given an access level, properties declared on the type will get the default “internal” access level, but since their containing type is not visible outside the file, they will not be visible either.<br>&gt; <br>&gt; Thus any properties on the type will effectively inherit the access level of that type, unless the type’s access level is broader than “internal”. For the example of a private type at the top level of a file, its properties will effectively be fileprivate.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sorry, missed the example in my last reply.<br>&gt;&gt; <br>&gt;&gt;&gt; Should this compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Outer().inner<br>&gt;&gt; <br>&gt;&gt; Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br>&gt;&gt; <br>&gt;&gt; private struct Outer {<br>&gt;&gt;     struct Inner {}<br>&gt;&gt;     let inner = Inner()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private let inner = Outer().inner<br>&gt;&gt; <br>&gt;&gt; Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this shouldn&#39;t:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Outer {<br>&gt;&gt;&gt;     private let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Outer {<br>&gt;&gt;&gt;     var inner2 : Inner { return self.inner }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The extension introduces a new scope so this is not valid.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt;&gt; <br>&gt;&gt; The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/1c057d50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 15, 2016, at 8:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Perhaps the proposal can be amended with this information with the approval of the core team. I imagine that a list of rules and a chart might be valuable. Even if adding to the proposal is the wrong way to go, a publicly accessible and vetted document would be useful to refer people to. Maybe someone can step up and form a working group.<br></p><p>I&#39;m sure the core team will chime in when they have a chance (but probably not during WWDC).  If Ilya doesn&#39;t reply and nobody else wants to do it I would be happy to clarify this in an update to the proposal after we hear from the core team.<br></p><p><br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 5:51 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think you guys are making this more complicated than it is. The rules here seem fairly simple:<br>&gt;&gt; <br>&gt;&gt; 1. The default access level is “internal”.<br>&gt;&gt; <br>&gt;&gt; 2. A type declared “private” at the top level will be visible to the file only.<br>&gt;&gt; <br>&gt;&gt; 3. If they are not given an access level, properties declared on the type will get the default “internal” access level, but since their containing type is not visible outside the file, they will not be visible either.<br>&gt;&gt; <br>&gt;&gt; Thus any properties on the type will effectively inherit the access level of that type, unless the type’s access level is broader than “internal”. For the example of a private type at the top level of a file, its properties will effectively be fileprivate.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, missed the example in my last reply.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should this compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Outer().inner<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;     struct Inner {}<br>&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private let inner = Outer().inner<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this shouldn&#39;t:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Outer {<br>&gt;&gt;&gt;&gt;     private let inner = Inner()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Outer {<br>&gt;&gt;&gt;&gt;     var inner2 : Inner { return self.inner }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The extension introduces a new scope so this is not valid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/97a18207/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
