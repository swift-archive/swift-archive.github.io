<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt; proposal I guess.<br>&gt;<br>&gt; We should start by adding AnyValue protocol to which all value types<br>&gt; conforms.<br></p><p>Having a way to constrain conformance to things with value semantics is<br>something I&#39;ve long wanted.  *However*, the approach described is too<br>simplistic.  It&#39;s possible to build classes whose instances have value<br>semantics (just make them immutable) and it&#39;s possible to build structs<br>whose instances have reference semantics (just put the struct&#39;s storage<br>in a mutable class instance that it holds as a property, and don&#39;t do<br>copy-on-write).  <br></p><p>In order for something like AnyValue to have meaning, we need to impose<br>greater order.  After thinking through many approaches over the years, I<br>have arrived at the (admittedly rather drastic) opinion that the<br>language should effectively outlaw the creation of structs and enums<br>that don&#39;t have value semantics.  (I have no problem with the idea that<br>immutable classes that want to act as values should be wrapped in a<br>struct).  The language could then do lots of things much more<br>intelligently, such as correctly generating implementations of equality. <br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt; proposal I guess.<br>&gt;&gt; <br>&gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt; conforms.<br>&gt; <br>&gt; Having a way to constrain conformance to things with value semantics is<br>&gt; something I&#39;ve long wanted.  *However*, the approach described is too<br>&gt; simplistic.  It&#39;s possible to build classes whose instances have value<br>&gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt; copy-on-write).  <br>&gt; <br>&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt; greater order.  After thinking through many approaches over the years, I<br>&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt; language should effectively outlaw the creation of structs and enums<br>&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt; immutable classes that want to act as values should be wrapped in a<br>&gt; struct).  The language could then do lots of things much more<br>&gt; intelligently, such as correctly generating implementations of equality.<br></p><p>That is a drastic solution indeed!  How would this impact things like Array&lt;UIView&gt;?  While Array itself has value semantics, the aggregate obviously does not as it contains references which usually be mutated underneath us.  Similar considerations apply to simpler wrapper structs such as Weak.<br></p><p>My expectation is a generic aggregate such as Array would have to conditionally conform to AnyValue only when Element also conforms to AnyValue.<br></p><p>I’m also wondering how such a rule would be implemented while still allowing for CoW structs that *do* implement value semantics, but do so while using references internally.  <br></p><p>If the compiler can be sophisticated enough to verify value semantics statically maybe it would be better to have that mechanism be triggered by conformance to AnyValue rather than for all structs and enums.  Types that conform to AnyValue would receive the benefits of the compiler knowing they have value semantics, while other uses of structs and enums would remain valid.  Best practice would be to conform structs and enums to AnyValue whenever possible.  <br></p><p>Another possible advantage of this approach would be allowing immutable reference types to conform to AnyValue and receive the associated benefits such as the generated implementation of equality, etc.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  4, 2016 at 09:00:00pm</p></header><div class="content"><p>I kinda feel my idea went into the wrong direction.<br></p><p>By introducing these implicit protocols (formatted with Source Code Pro font) I didn’t meant them to force a type to have only reference or value semantics.<br></p><p>                   +-------+<br>                   |  Any  |<br>                   +---+---+<br>                       |<br>         +-------------+-------------+<br>         |                           |<br>  +------+-------+             +-----+----+<br>  | AnyReference |             | AnyValue |<br>  +------+-------+             +-----+----+<br>         |                           |<br>+--------+---------+  ....................................<br>| AnyObject (ObjC) |  : Optionally Swift could also have :<br>+------------------+  :              |                   :<br>                      :      +-------+--------+          :<br>                      :      |                |          :<br>                      : +----+----+     +-----+-----+    :<br>                      : | AnyEnum |     | AnyStruct |    :<br>                      : +----+----+     +-----+-----+    :<br>                      ....................................<br></p><p>Array&lt;UIView&gt; is a great example that `AnyValue` should not restrict your type to contain only value types.<br></p><p>The main idea behind these implicit protocols was the ability to create protocols which only can be applied to a specific type (class, struct or enum, maybe tuples one day) or to distinguish between types.<br></p><p>Here are some simple examples: <br></p><p>protocol MagicValueType: AnyValue {}<br>extension MagicValueType {<br></p><p>      func expectoPatronum() { /* do some amazing magic */ }<br>      func getMeAView() -&gt; UIView { return UIView() } <br>      // AnyValue should not forbid value types to work with reference types<br>}<br></p><p>class A {}<br>struct B {}<br></p><p>extension A: MagicValueType {} // this should NOT work and produce an error, because MagicValueType is restricted to value types only<br>extension B: MagicValueType {} // wow we extended our type with an value type protocol (this is new to the language)<br></p><p>Same rules goes to the `AnyReference`.<br></p><p>We already can do something like this:<br></p><p>protocol SomeReferenceProtocol: class {} // restricted to classes only<br>extension SomeReferenceProtocol {<br></p><p>     func foo() -&gt; B { return B() } // we can work with value or reference types as we pleased<br>}<br></p><p>extension A: SomeReferenceProtocol {} // works as expected<br>extension B: SomeReferenceProtocol {} // this already produces an error which is the way it should work<br></p><p>I’d be great if we change the `class` keyword to `AnyReference` (not @objc protocol AnyObject {} as explained before).<br></p><p>protocol SomeReferenceProtocol: AnyReference {}<br></p><p>Any value type except buildin types (Tuples can’t be extended at the moment anyways) should implicitly conform to AnyValue and any Swift classes should implicitly conform to AnyReference. All ObjC classes should conform to AnyObject.<br></p><p>If these protocols would exist we could use them to overload correctly (an abstract example I used in my post two weeks ago):<br>func mutate&lt;T: AnyValue&gt;(value: T, scope: @noescape (value: inout T) -&gt; Void) -&gt; T {<br>			<br>    var mutableValue = value<br>    scope(value: &amp;mutableValue)<br>    return mutableValue<br>}<br></p><p>func mutate&lt;T: AnyReference&gt;(value: T, scope: @noescape (value: T) -&gt; Void) -&gt; T {<br>			<br>    scope(value: value)<br>    return value<br>}<br>The first `mutate` function will be called if you pass any class to it, including ObjC classes. And finally the second `mutate` function is only called when there is a value type (struct, enum).  <br>I don’t want to restrict the semantics of a type with implicit protocol, but just to constrain protocols if there is a need and correctly detect reference vs. value types.  <br>We could go even further and allow mixing of implicit protocols:<br>protocol Cocktail: AnyReference, AnyValue {}<br>this would be equivalent to: <br>protocol Cocktail: Any {}<br>or just:<br>protocol Cocktail {}<br>Complex restriction might also be possible for whatever desire:<br>protocol Burger: AnyObject, AnyStruct {}<br>extension UIView: Burger{} and extension B: Burger {} should work.<br>I home my English was enough to clarify my idea.<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Mai 2016 bei 20:46:40, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>&gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt;  <br>&gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt; proposal I guess.<br>&gt;&gt;  <br>&gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt; conforms.<br>&gt;  <br>&gt; Having a way to constrain conformance to things with value semantics is<br>&gt; something I&#39;ve long wanted. *However*, the approach described is too<br>&gt; simplistic. It&#39;s possible to build classes whose instances have value<br>&gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt; copy-on-write).  <br>&gt;  <br>&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt; greater order. After thinking through many approaches over the years, I<br>&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt; language should effectively outlaw the creation of structs and enums<br>&gt; that don&#39;t have value semantics. (I have no problem with the idea that<br>&gt; immutable classes that want to act as values should be wrapped in a<br>&gt; struct). The language could then do lots of things much more<br>&gt; intelligently, such as correctly generating implementations of equality.<br></p><p>That is a drastic solution indeed! How would this impact things like Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate obviously does not as it contains references which usually be mutated underneath us. Similar considerations apply to simpler wrapper structs such as Weak.<br></p><p>My expectation is a generic aggregate such as Array would have to conditionally conform to AnyValue only when Element also conforms to AnyValue.<br></p><p>I’m also wondering how such a rule would be implemented while still allowing for CoW structs that *do* implement value semantics, but do so while using references internally.  <br></p><p>If the compiler can be sophisticated enough to verify value semantics statically maybe it would be better to have that mechanism be triggered by conformance to AnyValue rather than for all structs and enums. Types that conform to AnyValue would receive the benefits of the compiler knowing they have value semantics, while other uses of structs and enums would remain valid. Best practice would be to conform structs and enums to AnyValue whenever possible.  <br></p><p>Another possible advantage of this approach would be allowing immutable reference types to conform to AnyValue and receive the associated benefits such as the generated implementation of equality, etc.<br></p><p>-Matthew<br></p><p>&gt;  <br>&gt;  <br>&gt; --  <br>&gt; Dave<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/6337291e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 2:31 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I kinda feel my idea went into the wrong direction.<br>&gt; <br>&gt; By introducing these implicit protocols (formatted with Source Code Pro font) I didn’t meant them to force a type to have only reference or value semantics.<br>&gt; <br>&gt;                    +-------+<br>&gt;                    |  Any  |<br>&gt;                    +---+---+<br>&gt;                        |<br>&gt;          +-------------+-------------+<br>&gt;          |                           |<br>&gt;   +------+-------+             +-----+----+<br>&gt;   | AnyReference |             | AnyValue |<br>&gt;   +------+-------+             +-----+----+<br>&gt;          |                           |<br>&gt; +--------+---------+  ....................................<br>&gt; | AnyObject (ObjC) |  : Optionally Swift could also have :<br>&gt; +------------------+  :              |                   :<br>&gt;                       :      +-------+--------+          :<br>&gt;                       :      |                |          :<br>&gt;                       : +----+----+     +-----+-----+    :<br>&gt;                       : | AnyEnum |     | AnyStruct |    :<br>&gt;                       : +----+----+     +-----+-----+    :<br>&gt;                       ....................................<br>&gt; <br>&gt; Array&lt;UIView&gt; is a great example that `AnyValue` should not restrict your type to contain only value types.<br>&gt; <br>&gt; The main idea behind these implicit protocols was the ability to create protocols which only can be applied to a specific type (class, struct or enum, maybe tuples one day) or to distinguish between types.<br></p><p>And the point others have made is that the value in this is less than it might seem at first glance.  Semantic clarity in generic code requires protocols to have semantics attached to them.  <br></p><p>&gt; <br>&gt; Here are some simple examples: <br>&gt; <br>&gt; protocol MagicValueType: AnyValue {}<br>&gt; extension MagicValueType {<br>&gt; <br>&gt;       func expectoPatronum() { /* do some amazing magic */ }<br>&gt;       func getMeAView() -&gt; UIView { return UIView() } <br>&gt;       // AnyValue should not forbid value types to work with reference types<br>&gt; }<br>&gt; <br>&gt; class A {}<br>&gt; struct B {}<br>&gt; <br>&gt; extension A: MagicValueType {} // this should NOT work and produce an error, because MagicValueType is restricted to value types only<br>&gt; extension B: MagicValueType {} // wow we extended our type with an value type protocol (this is new to the language)<br>&gt; <br>&gt; Same rules goes to the `AnyReference`.<br>&gt; <br>&gt; We already can do something like this:<br>&gt; <br>&gt; protocol SomeReferenceProtocol: class {} // restricted to classes only<br>&gt; extension SomeReferenceProtocol {<br>&gt; <br>&gt;      func foo() -&gt; B { return B() } // we can work with value or reference types as we pleased<br>&gt; }<br>&gt; <br>&gt; extension A: SomeReferenceProtocol {} // works as expected<br>&gt; extension B: SomeReferenceProtocol {} // this already produces an error which is the way it should work<br>&gt; <br>&gt; I’d be great if we change the `class` keyword to `AnyReference` (not @objc protocol AnyObject {} as explained before).<br>&gt; <br>&gt; protocol SomeReferenceProtocol: AnyReference {}<br>&gt; <br>&gt; Any value type except buildin types (Tuples can’t be extended at the moment anyways) should implicitly conform to AnyValue and any Swift classes should implicitly conform to AnyReference. All ObjC classes should conform to AnyObject.<br>&gt; <br>&gt; If these protocols would exist we could use them to overload correctly (an abstract example I used in my post two weeks ago):<br>&gt; func mutate&lt;T: AnyValue&gt;(value: T, scope: @noescape (value: inout T) -&gt; Void) -&gt; T {<br>&gt; 			<br>&gt;     var mutableValue = value<br>&gt;     scope(value: &amp;mutableValue)<br>&gt;     return mutableValue<br>&gt; }<br>&gt; <br>&gt; func mutate&lt;T: AnyReference&gt;(value: T, scope: @noescape (value: T) -&gt; Void) -&gt; T {<br>&gt; 			<br>&gt;     scope(value: value)<br>&gt;     return value<br>&gt; }<br>&gt; The first `mutate` function will be called if you pass any class to it, including ObjC classes. And finally the second `mutate` function is only called when there is a value type (struct, enum). <br>You have “first” and “second” backwards here.<br></p><p>I really like that you bring up this example.  Ideally two overloads would not be necessary here.  I haven’t thought deeply about whether a solution enabling a single implementation is possible and if so what it might look like.  If there is a solution it would be much more elegant than requiring the overloads.<br>&gt; I don’t want to restrict the semantics of a type with implicit protocol, but just to constrain protocols if there is a need and correctly detect reference vs. value types. <br>&gt; We could go even further and allow mixing of implicit protocols:<br>&gt; protocol Cocktail: AnyReference, AnyValue {}<br>&gt; this would be equivalent to: <br>&gt; protocol Cocktail: Any {}<br>&gt; or just:<br>&gt; protocol Cocktail {}<br></p><p>No, this under your suggestion this would require conforming types to conform to both AnyReference and AnyValue which would be impossible given your definitions.<br></p><p>&gt; Complex restriction might also be possible for whatever desire:<br>&gt; protocol Burger: AnyObject, AnyStruct {}<br>&gt; extension UIView: Burger{} and extension B: Burger {} should work.<br>This would be a compiler error as UIView clearly would not conform to AnyStruct.  <br></p><p><br>&gt; I home my English was enough to clarify my idea.<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 4. Mai 2016 bei 20:46:40, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt; &gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt; &gt;&gt; proposal I guess.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt; &gt;&gt; conforms.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Having a way to constrain conformance to things with value semantics is<br>&gt;&gt; &gt; something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt; &gt; simplistic. It&#39;s possible to build classes whose instances have value<br>&gt;&gt; &gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt;&gt; &gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt;&gt; &gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt;&gt; &gt; copy-on-write).  <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt; &gt; greater order. After thinking through many approaches over the years, I<br>&gt;&gt; &gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt; &gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt; &gt; that don&#39;t have value semantics. (I have no problem with the idea that<br>&gt;&gt; &gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt; &gt; struct). The language could then do lots of things much more<br>&gt;&gt; &gt; intelligently, such as correctly generating implementations of equality.<br>&gt;&gt; <br>&gt;&gt; That is a drastic solution indeed! How would this impact things like Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate obviously does not as it contains references which usually be mutated underneath us. Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt; My expectation is a generic aggregate such as Array would have to conditionally conform to AnyValue only when Element also conforms to AnyValue.<br>&gt;&gt; <br>&gt;&gt; I’m also wondering how such a rule would be implemented while still allowing for CoW structs that *do* implement value semantics, but do so while using references internally.  <br>&gt;&gt; <br>&gt;&gt; If the compiler can be sophisticated enough to verify value semantics statically maybe it would be better to have that mechanism be triggered by conformance to AnyValue rather than for all structs and enums. Types that conform to AnyValue would receive the benefits of the compiler knowing they have value semantics, while other uses of structs and enums would remain valid. Best practice would be to conform structs and enums to AnyValue whenever possible.  <br>&gt;&gt; <br>&gt;&gt; Another possible advantage of this approach would be allowing immutable reference types to conform to AnyValue and receive the associated benefits such as the generated implementation of equality, etc.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/87ea090b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  5, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 4, 2016, at 13:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt; greater order.  After thinking through many approaches over the years, I<br>&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt; language should effectively outlaw the creation of structs and enums<br>&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt; immutable classes that want to act as values should be wrapped in a<br>&gt; struct).  The language could then do lots of things much more<br>&gt; intelligently, such as correctly generating implementations of equality. <br>You mean that a struct&#39;s properties would have to have value semantics, too? I think I&#39;m okay with that, especially if it&#39;s done through new types of structs/enums.<br></p><p>- Dave Sweeris.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed May 04 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br></p><p>&gt;&gt; On May 4, 2016, at 13:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt; intelligently, such as correctly generating implementations of<br>&gt;&gt; equality. <br>&gt;<br>&gt; You mean that a struct&#39;s properties would have to have value<br>&gt; semantics, too? <br></p><p>Either that, or you&#39;d have to implement CoW, or you&#39;d not use the<br>storage behind any properties that were references in a way that affects<br>value semantics.<br></p><p>&gt; I think I&#39;m okay with that, especially if it&#39;s done through new types<br>&gt; of structs/enums.<br></p><p>New types of structs/enums?  What does that mean?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 5:01 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 13:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt;&gt; intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt; equality. <br>&gt;&gt; <br>&gt;&gt; You mean that a struct&#39;s properties would have to have value<br>&gt;&gt; semantics, too? <br>&gt; <br>&gt; Either that, or you&#39;d have to implement CoW, or you&#39;d not use the<br>&gt; storage behind any properties that were references in a way that affects<br>&gt; value semantics.<br>&gt; <br>&gt;&gt; I think I&#39;m okay with that, especially if it&#39;s done through new types<br>&gt;&gt; of structs/enums.<br>&gt; <br>&gt; New types of structs/enums?  What does that mean?<br>I meant leave `struct` and `enum` the way they are, and introduce a `different_struct` and `different_enum` (placeholder names, of course) which enforced the “no reference-semantics” rules.<br></p><p>I’m inclined to think we should adopt your “no reference-semantics” rule, but I’m not entirely sure what the impact would be. Adding new types side-steps the issue, at the cost of increasing the complexity of the language/compiler. I’m unsure if that&#39;d be a worth-while trade-off.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br></p><p>&gt;&gt; On May 5, 2016, at 5:01 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed May 04 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On May 4, 2016, at 13:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt;&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt;&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt;&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt;&gt;&gt; intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt;&gt; equality. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You mean that a struct&#39;s properties would have to have value<br>&gt;&gt;&gt; semantics, too? <br>&gt;&gt; <br>&gt;&gt; Either that, or you&#39;d have to implement CoW, or you&#39;d not use the<br>&gt;&gt; storage behind any properties that were references in a way that affects<br>&gt;&gt; value semantics.<br>&gt;&gt; <br>&gt;&gt;&gt; I think I&#39;m okay with that, especially if it&#39;s done through new types<br>&gt;&gt;&gt; of structs/enums.<br>&gt;&gt; <br>&gt;&gt; New types of structs/enums?  What does that mean?<br>&gt; I meant leave `struct` and `enum` the way they are, and introduce a<br>&gt; `different_struct` and `different_enum` (placeholder names, of course)<br>&gt; which enforced the “no reference-semantics” rules.<br></p><p>I would be pretty strongly opposed to that.  That&#39;s almost the opposite<br>of what I&#39;m proposing.<br></p><p>&gt; I’m inclined to think we should adopt your “no reference-semantics”<br>&gt; rule, but I’m not entirely sure what the impact would be. Adding new<br>&gt; types side-steps the issue, at the cost of increasing the complexity<br>&gt; of the language/compiler. I’m unsure if that&#39;d be a worth-while<br>&gt; trade-off.<br></p><p>The whole point of my proposal is to simplify the model.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 6:55 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; I meant leave `struct` and `enum` the way they are, and introduce a<br>&gt;&gt; `different_struct` and `different_enum` (placeholder names, of course)<br>&gt;&gt; which enforced the “no reference-semantics” rules.<br>&gt; <br>&gt; I would be pretty strongly opposed to that.  That&#39;s almost the opposite<br>&gt; of what I&#39;m proposing.<br>&gt; <br>&gt;&gt; I’m inclined to think we should adopt your “no reference-semantics”<br>&gt;&gt; rule, but I’m not entirely sure what the impact would be. Adding new<br>&gt;&gt; types side-steps the issue, at the cost of increasing the complexity<br>&gt;&gt; of the language/compiler. I’m unsure if that&#39;d be a worth-while<br>&gt;&gt; trade-off.<br>&gt; <br>&gt; The whole point of my proposal is to simplify the model.<br>Oh, ok… I think I got your ends and your means backwards in my head.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
