<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt; for setter access level, e.g. the current private(set). Options:<br>&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt; private(set).<br>&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt; the other unification efforts going on to make everything look like<br>&gt; function calls.<br>What about the following 3 forms?<br></p><p>private(file) //both setter and getter have file scope<br>private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>private(get: module, set: file) //getter has module scope &amp; setter has file scope<br></p><p>It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/af32ff03/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 15, 2016 at 04:00:00pm</p></header><div class="content"><p>I like Shawn&#39;s proposal:<br></p><p>var foo: Int { private(file) set }<br></p><p>In fact it&#39;s probably more sensible than the current private(set) IMO.<br></p><p><br>While I like private(get: file, set: module) idea, I think it just gets too<br>inconsistent with private(set: public) and private(set: private) (?!)<br></p><p>On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;<br>&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt; for setter access level, e.g. the current private(set). Options:<br>&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt; private(set).<br>&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt; the other unification efforts going on to make everything look like<br>&gt; function calls.<br>&gt;<br>&gt; What about the following 3 forms?<br>&gt;<br>&gt; private(file) //both setter and getter have file scope<br>&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt; “private(set)&quot;<br>&gt; private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt; file scope<br>&gt;<br>&gt; It is a bit weird, but we should probably also allow “public&quot; in that last<br>&gt; form: private(get: public, set: module)<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/76837b74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; I like Shawn&#39;s proposal:<br></p><p><br></p><p>var foo: Int { private(file) set }<br></p><p><br>&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br></p><p><br>For example, we already use<br></p><p>var foo: Int { mutating get { ... } }<br></p><p>and not<br></p><p>mutating(get) var foo: Int { get { ... } }<br></p><p>On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>patrickpijnappel at gmail.com&gt; wrote:<br></p><p>&gt; I like Shawn&#39;s proposal:<br>&gt;<br>&gt; var foo: Int { private(file) set }<br>&gt;<br>&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;<br>&gt;<br>&gt; While I like private(get: file, set: module) idea, I think it just gets<br>&gt; too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;<br>&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;<br>&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt; private(set).<br>&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt; function calls.<br>&gt;&gt;<br>&gt;&gt; What about the following 3 forms?<br>&gt;&gt;<br>&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt; “private(set)&quot;<br>&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt; file scope<br>&gt;&gt;<br>&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt; last form: private(get: public, set: module)<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/7649b52c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 15, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt; right to me or seem to enhance readability. :(<br>I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br></p><p>var foo:Int {<br>	public get {…}<br>	private(file) set {…}<br>}<br></p><p>In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br></p><p>I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br></p><p>private var foo:Int<br>private(file) var foo:Int<br>private(set: file) var foo:Int<br>private(get: global, set: file) var foo:Int<br></p><p><br>I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br></p><p>var foo:Int{<br>	public get useDefault<br>	private(file) set {…}<br>}<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like Shawn&#39;s proposal: <br>&gt;  <br>&gt; var foo: Int { private(file) set } <br>&gt; <br>&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt; <br>&gt; For example, we already use<br>&gt; <br>&gt; var foo: Int { mutating get { ... } }<br>&gt; <br>&gt; and not<br>&gt; <br>&gt; mutating(get) var foo: Int { get { ... } }<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt; I like Shawn&#39;s proposal:<br>&gt; <br>&gt; var foo: Int { private(file) set }<br>&gt; <br>&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt; <br>&gt; <br>&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt; private(set).<br>&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt; function calls.<br>&gt; What about the following 3 forms?<br>&gt; <br>&gt; private(file) //both setter and getter have file scope<br>&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt; <br>&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/ac24ac78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 16, 2016 at 12:00:00am</p></header><div class="content"><p>It&#39;s occurring to me, reading these recent posts, that we have two<br>orthogonal systems of access levels.<br></p><p>Swift&#39;s current access system is file based; a project file decides which<br>files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>determine whether a property is accessible to all, accessible only within<br>files of the module, or accessible only within a file. (This takes on an<br>extra dimension as files may belong to several modules).<br></p><p>The concept which began this discussion, and several of the proposed<br>concepts in this discussion, ask instead for a type-based access system<br>similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>to a type or subtypes.<br></p><p>I think it would be confusing if Swift applied &#39;public&#39; to a concept in the<br>file-based access system and &#39;private&#39; to a concept in the type-based<br>access system.<br></p><p>I would prefer clearer terms which actually mention the restrictions of the<br>level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties<br>accessible by a class and its subclasses; &#39;declaration&#39;, rather than<br>&#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>given type or extension declaration.<br></p><p>Since, at the moment, a declaration can only occur within one file, I think<br>this most-restricted level has managed to pass as a level of the file-based<br>access system. However, if the system is ever extended, we&#39;re going to run<br>into new syntax decisions where we have &#39;private module&#39; functions<br>(accessible only within the given type in the same module) trying to<br>communicate with &#39;protected file&#39; properties (accessible only with the type<br>and its subtypes in the same file), and that might lead to conflicts, so<br>perhaps we should decide how those might be declared now.<br></p><p>On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;<br>&gt; And again, moving the access control modification to the end just doesn&#39;t look<br>&gt; right to me or seem to enhance readability. :(<br>&gt;<br>&gt; I like Shawn’s proposal better for cases where there are custom<br>&gt; getter/setter implementations.  We should definitely be able to do:<br>&gt;<br>&gt; var foo:Int {<br>&gt; public get {…}<br>&gt; private(file) set {…}<br>&gt; }<br>&gt;<br>&gt; In fact, that is what I first tried to do before learning about<br>&gt; private(set).  But without the implementations, it just seems strange to<br>&gt; put the scoping after the rest of the declaration (they work above because<br>&gt; they are *before* the custom getter/setter).<br>&gt;<br>&gt; I still like the idea of having the option to use parameter-like syntax<br>&gt; for cases where you don’t have custom getters/setters:<br>&gt;<br>&gt; private var foo:Int<br>&gt; private(file) var foo:Int<br>&gt; private(set: file) var foo:Int<br>&gt; private(get: global, set: file) var foo:Int<br>&gt;<br>&gt;<br>&gt; I guess, if we had some way to represent the standard getter/setter, that<br>&gt; might work too.  I don’t love it, but maybe with better wording?<br>&gt;<br>&gt; var foo:Int{<br>&gt; public get useDefault<br>&gt; private(file) set {…}<br>&gt; }<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;<br>&gt; I like Shawn&#39;s proposal:<br>&gt;<br>&gt;<br>&gt;<br>&gt; var foo: Int { private(file) set }<br>&gt;<br>&gt;<br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;<br>&gt;<br>&gt; For example, we already use<br>&gt;<br>&gt; var foo: Int { mutating get { ... } }<br>&gt;<br>&gt; and not<br>&gt;<br>&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;<br>&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;<br>&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;<br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets<br>&gt;&gt; too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt;&gt; “private(set)&quot;<br>&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt;&gt; file scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt;&gt; last form: private(get: public, set: module)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/0589ab71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Ok to summarize:<br></p><p><br>*Setter access modifiers*<br></p><p>var foo: Int { private set { ... } }<br></p><p>var foo: Int { private set }<br></p><p>   - Consistent with mutating set { ... }. Arguably the current private(set)<br>   is inconsistent.<br>   - Eliminates the odd corner case of having a double access modifier,<br>   e.g. public private(set) var foo: Int.<br>   - It&#39;s very sensible for custom getters/setters (top case), it just<br>   requires allowing a bodiless get/set. We already kinda do this in protocols.<br></p><p><br>*Access modifier keywords*<br></p><p>public/private(module)/private(file)/private<br></p><p>   - It&#39;s not clear from the keywords how restrictive local/private/internal<br>   are, while private(module) and private(file) are obvious. This<br>makes a declaration<br>   either public, or private to a certain scope. Arguably e.g.<br>   public/module/file/declaration has similar benefits but they aren&#39;t as<br>   clearly access control related as a keyword (e.g. module could just as<br>   well be declaring a module).<br>   - private(module) and private(file) are relatively long, but the longest<br>   – private(module) – is rarely used (outside the standard library) as<br>   it&#39;s the default. Most uses of the old private are more appropriately<br>   done using the new private, so private(file) would likely be used less<br>   than private.<br>   - The scheme expands very well to named submodules, e.g. if you have a<br>   submodule named model you might limit the scope using private(model).<br>   - private(file) as opposed to private-file or private/file makes it more<br>   consistent with the new function-like syntax for e.g. attributes.<br></p><p><br>On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It&#39;s occurring to me, reading these recent posts, that we have two<br>&gt; orthogonal systems of access levels.<br>&gt;<br>&gt; Swift&#39;s current access system is file based; a project file decides which<br>&gt; files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>&gt; determine whether a property is accessible to all, accessible only within<br>&gt; files of the module, or accessible only within a file. (This takes on an<br>&gt; extra dimension as files may belong to several modules).<br>&gt;<br>&gt; The concept which began this discussion, and several of the proposed<br>&gt; concepts in this discussion, ask instead for a type-based access system<br>&gt; similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&gt; &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>&gt; to a type or subtypes.<br>&gt;<br>&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in<br>&gt; the file-based access system and &#39;private&#39; to a concept in the type-based<br>&gt; access system.<br>&gt;<br>&gt; I would prefer clearer terms which actually mention the restrictions of<br>&gt; the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of<br>&gt; properties accessible by a class and its subclasses; &#39;declaration&#39;, rather<br>&gt; than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>&gt; given type or extension declaration.<br>&gt;<br>&gt; Since, at the moment, a declaration can only occur within one file, I<br>&gt; think this most-restricted level has managed to pass as a level of the<br>&gt; file-based access system. However, if the system is ever extended, we&#39;re<br>&gt; going to run into new syntax decisions where we have &#39;private module&#39;<br>&gt; functions (accessible only within the given type in the same module) trying<br>&gt; to communicate with &#39;protected file&#39; properties (accessible only with the<br>&gt; type and its subtypes in the same file), and that might lead to conflicts,<br>&gt; so perhaps we should decide how those might be declared now.<br>&gt;<br>&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look<br>&gt;&gt; right to me or seem to enhance readability. :(<br>&gt;&gt;<br>&gt;&gt; I like Shawn’s proposal better for cases where there are custom<br>&gt;&gt; getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt;<br>&gt;&gt; var foo:Int {<br>&gt;&gt; public get {…}<br>&gt;&gt; private(file) set {…}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In fact, that is what I first tried to do before learning about<br>&gt;&gt; private(set).  But without the implementations, it just seems strange to<br>&gt;&gt; put the scoping after the rest of the declaration (they work above because<br>&gt;&gt; they are *before* the custom getter/setter).<br>&gt;&gt;<br>&gt;&gt; I still like the idea of having the option to use parameter-like syntax<br>&gt;&gt; for cases where you don’t have custom getters/setters:<br>&gt;&gt;<br>&gt;&gt; private var foo:Int<br>&gt;&gt; private(file) var foo:Int<br>&gt;&gt; private(set: file) var foo:Int<br>&gt;&gt; private(get: global, set: file) var foo:Int<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I guess, if we had some way to represent the standard getter/setter, that<br>&gt;&gt; might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt;<br>&gt;&gt; var foo:Int{<br>&gt;&gt; public get useDefault<br>&gt;&gt; private(file) set {…}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For example, we already use<br>&gt;&gt;<br>&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt;<br>&gt;&gt; and not<br>&gt;&gt;<br>&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets<br>&gt;&gt;&gt; too inconsistent with private(set: public) and private(set: private)<br>&gt;&gt;&gt;  (?!)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt;&gt;&gt; “private(set)&quot;<br>&gt;&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt;&gt;&gt; file scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt;&gt;&gt; last form: private(get: public, set: module)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/fa94cf0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 16, 2016 at 07:00:00am</p></header><div class="content"><p>Very good summary :) I find this option very consistent +1<br></p><p>&gt; On 16 Mar 2016, at 07:49, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok to summarize:<br>&gt; <br>&gt; Setter access modifiers<br>&gt; var foo: Int { private set { ... } }<br>&gt; var foo: Int { private set }<br>&gt; Consistent with mutating set { ... }. Arguably the current private(set) is inconsistent.<br>&gt; Eliminates the odd corner case of having a double access modifier, e.g. public private(set) var foo: Int.<br>&gt; It&#39;s very sensible for custom getters/setters (top case), it just requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt; <br>&gt; Access modifier keywords<br>&gt; public/private(module)/private(file)/private<br>&gt; It&#39;s not clear from the keywords how restrictive local/private/internal are, while private(module) and private(file) are obvious. This makes a declaration either public, or private to a certain scope. Arguably e.g. public/module/file/declaration has similar benefits but they aren&#39;t as clearly access control related as a keyword (e.g. module could just as well be declaring a module).<br>&gt; private(module) and private(file) are relatively long, but the longest – private(module) – is rarely used (outside the standard library) as it&#39;s the default. Most uses of the old private are more appropriately done using the new private, so private(file) would likely be used less than private. <br>&gt; The scheme expands very well to named submodules, e.g. if you have a submodule named model you might limit the scope using private(model). <br>&gt; private(file) as opposed to private-file or private/file makes it more consistent with the new function-like syntax for e.g. attributes.<br>&gt; <br>&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It&#39;s occurring to me, reading these recent posts, that we have two orthogonal systems of access levels.<br>&gt; <br>&gt; Swift&#39;s current access system is file based; a project file decides which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39; determine whether a property is accessible to all, accessible only within files of the module, or accessible only within a file. (This takes on an extra dimension as files may belong to several modules).<br>&gt; <br>&gt; The concept which began this discussion, and several of the proposed concepts in this discussion, ask instead for a type-based access system similar to those in other languages including Objective-C, where &#39;public&#39;, &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access to a type or subtypes.<br>&gt; <br>&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the file-based access system and &#39;private&#39; to a concept in the type-based access system.<br>&gt; <br>&gt; I would prefer clearer terms which actually mention the restrictions of the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties accessible by a class and its subclasses; &#39;declaration&#39;, rather than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a given type or extension declaration.<br>&gt; <br>&gt; Since, at the moment, a declaration can only occur within one file, I think this most-restricted level has managed to pass as a level of the file-based access system. However, if the system is ever extended, we&#39;re going to run into new syntax decisions where we have &#39;private module&#39; functions (accessible only within the given type in the same module) trying to communicate with &#39;protected file&#39; properties (accessible only with the type and its subtypes in the same file), and that might lead to conflicts, so perhaps we should decide how those might be declared now.<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt;&gt; right to me or seem to enhance readability. :(<br>&gt; I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br>&gt; <br>&gt; var foo:Int {<br>&gt; 	public get {…}<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br>&gt; <br>&gt; I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br>&gt; <br>&gt; private var foo:Int<br>&gt; private(file) var foo:Int<br>&gt; private(set: file) var foo:Int<br>&gt; private(get: global, set: file) var foo:Int<br>&gt; <br>&gt; <br>&gt; I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br>&gt; <br>&gt; var foo:Int{<br>&gt; 	public get useDefault<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like Shawn&#39;s proposal: <br>&gt;&gt;  <br>&gt;&gt; var foo: Int { private(file) set } <br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; For example, we already use<br>&gt;&gt; <br>&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt; <br>&gt;&gt; and not<br>&gt;&gt; <br>&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt; <br>&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt; function calls.<br>&gt;&gt; What about the following 3 forms?<br>&gt;&gt; <br>&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt;&gt; <br>&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/23acbe51/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 16, 2016 at 07:00:00am</p></header><div class="content"><p>Great summary, but I would still use new keywords rather than adding modifiers to private itself.<br></p><p>public<br>module<br>file/ sourceFile /pick a better word :)<br>private<br></p><p>Sent from my iPhone<br></p><p>&gt; On 16 Mar 2016, at 06:49, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok to summarize:<br>&gt; <br>&gt; Setter access modifiers<br>&gt; var foo: Int { private set { ... } }<br>&gt; var foo: Int { private set }<br>&gt; Consistent with mutating set { ... }. Arguably the current private(set) is inconsistent.<br>&gt; Eliminates the odd corner case of having a double access modifier, e.g. public private(set) var foo: Int.<br>&gt; It&#39;s very sensible for custom getters/setters (top case), it just requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt; <br>&gt; Access modifier keywords<br>&gt; public/private(module)/private(file)/private<br>&gt; It&#39;s not clear from the keywords how restrictive local/private/internal are, while private(module) and private(file) are obvious. This makes a declaration either public, or private to a certain scope. Arguably e.g. public/module/file/declaration has similar benefits but they aren&#39;t as clearly access control related as a keyword (e.g. module could just as well be declaring a module).<br>&gt; private(module) and private(file) are relatively long, but the longest – private(module) – is rarely used (outside the standard library) as it&#39;s the default. Most uses of the old private are more appropriately done using the new private, so private(file) would likely be used less than private. <br>&gt; The scheme expands very well to named submodules, e.g. if you have a submodule named model you might limit the scope using private(model). <br>&gt; private(file) as opposed to private-file or private/file makes it more consistent with the new function-like syntax for e.g. attributes.<br>&gt; <br>&gt;&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; It&#39;s occurring to me, reading these recent posts, that we have two orthogonal systems of access levels.<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s current access system is file based; a project file decides which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39; determine whether a property is accessible to all, accessible only within files of the module, or accessible only within a file. (This takes on an extra dimension as files may belong to several modules).<br>&gt;&gt; <br>&gt;&gt; The concept which began this discussion, and several of the proposed concepts in this discussion, ask instead for a type-based access system similar to those in other languages including Objective-C, where &#39;public&#39;, &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access to a type or subtypes.<br>&gt;&gt; <br>&gt;&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the file-based access system and &#39;private&#39; to a concept in the type-based access system.<br>&gt;&gt; <br>&gt;&gt; I would prefer clearer terms which actually mention the restrictions of the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties accessible by a class and its subclasses; &#39;declaration&#39;, rather than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a given type or extension declaration.<br>&gt;&gt; <br>&gt;&gt; Since, at the moment, a declaration can only occur within one file, I think this most-restricted level has managed to pass as a level of the file-based access system. However, if the system is ever extended, we&#39;re going to run into new syntax decisions where we have &#39;private module&#39; functions (accessible only within the given type in the same module) trying to communicate with &#39;protected file&#39; properties (accessible only with the type and its subtypes in the same file), and that might lead to conflicts, so perhaps we should decide how those might be declared now.<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt;&gt;&gt;&gt; right to me or seem to enhance readability. :(<br>&gt;&gt;&gt; I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo:Int {<br>&gt;&gt;&gt; 	public get {…}<br>&gt;&gt;&gt; 	private(file) set {…}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private var foo:Int<br>&gt;&gt;&gt; private(file) var foo:Int<br>&gt;&gt;&gt; private(set: file) var foo:Int<br>&gt;&gt;&gt; private(get: global, set: file) var foo:Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo:Int{<br>&gt;&gt;&gt; 	public get useDefault<br>&gt;&gt;&gt; 	private(file) set {…}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal: <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; var foo: Int { private(file) set } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, we already use<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and not<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/a60e8a54/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 16, 2016 at 08:00:00am</p></header><div class="content"><p>I like the idea of repurposing brackets after private to do this. I think though that it might be better if there were also a private(type) option to allow us to be explicit about it, even if we can still type just private to use it by default.<br></p><p>About replacing private(set), the examples you’ve given look like computed properties, and being able to put the accessibility declaration before the setter is a good option, but for stored properties I think we also need a way to specify the restriction, for example private(file: set) to enable setting the value only at the file level. This means that private on its own is by default actually private(type: get set)<br></p><p>&gt; On 16 Mar 2016, at 06:49, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok to summarize:<br>&gt; <br>&gt; Setter access modifiers<br>&gt; var foo: Int { private set { ... } }<br>&gt; var foo: Int { private set }<br>&gt; Consistent with mutating set { ... }. Arguably the current private(set) is inconsistent.<br>&gt; Eliminates the odd corner case of having a double access modifier, e.g. public private(set) var foo: Int.<br>&gt; It&#39;s very sensible for custom getters/setters (top case), it just requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt; <br>&gt; Access modifier keywords<br>&gt; public/private(module)/private(file)/private<br>&gt; It&#39;s not clear from the keywords how restrictive local/private/internal are, while private(module) and private(file) are obvious. This makes a declaration either public, or private to a certain scope. Arguably e.g. public/module/file/declaration has similar benefits but they aren&#39;t as clearly access control related as a keyword (e.g. module could just as well be declaring a module).<br>&gt; private(module) and private(file) are relatively long, but the longest – private(module) – is rarely used (outside the standard library) as it&#39;s the default. Most uses of the old private are more appropriately done using the new private, so private(file) would likely be used less than private. <br>&gt; The scheme expands very well to named submodules, e.g. if you have a submodule named model you might limit the scope using private(model). <br>&gt; private(file) as opposed to private-file or private/file makes it more consistent with the new function-like syntax for e.g. attributes.<br>&gt; <br>&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It&#39;s occurring to me, reading these recent posts, that we have two orthogonal systems of access levels.<br>&gt; <br>&gt; Swift&#39;s current access system is file based; a project file decides which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39; determine whether a property is accessible to all, accessible only within files of the module, or accessible only within a file. (This takes on an extra dimension as files may belong to several modules).<br>&gt; <br>&gt; The concept which began this discussion, and several of the proposed concepts in this discussion, ask instead for a type-based access system similar to those in other languages including Objective-C, where &#39;public&#39;, &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access to a type or subtypes.<br>&gt; <br>&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the file-based access system and &#39;private&#39; to a concept in the type-based access system.<br>&gt; <br>&gt; I would prefer clearer terms which actually mention the restrictions of the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties accessible by a class and its subclasses; &#39;declaration&#39;, rather than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a given type or extension declaration.<br>&gt; <br>&gt; Since, at the moment, a declaration can only occur within one file, I think this most-restricted level has managed to pass as a level of the file-based access system. However, if the system is ever extended, we&#39;re going to run into new syntax decisions where we have &#39;private module&#39; functions (accessible only within the given type in the same module) trying to communicate with &#39;protected file&#39; properties (accessible only with the type and its subtypes in the same file), and that might lead to conflicts, so perhaps we should decide how those might be declared now.<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt;&gt; right to me or seem to enhance readability. :(<br>&gt; I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br>&gt; <br>&gt; var foo:Int {<br>&gt; 	public get {…}<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br>&gt; <br>&gt; I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br>&gt; <br>&gt; private var foo:Int<br>&gt; private(file) var foo:Int<br>&gt; private(set: file) var foo:Int<br>&gt; private(get: global, set: file) var foo:Int<br>&gt; <br>&gt; <br>&gt; I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br>&gt; <br>&gt; var foo:Int{<br>&gt; 	public get useDefault<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like Shawn&#39;s proposal: <br>&gt;&gt;  <br>&gt;&gt; var foo: Int { private(file) set } <br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; For example, we already use<br>&gt;&gt; <br>&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt; <br>&gt;&gt; and not<br>&gt;&gt; <br>&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt; <br>&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt; function calls.<br>&gt;&gt; What about the following 3 forms?<br>&gt;&gt; <br>&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt;&gt; <br>&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/c65e581c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 16, 2016 at 10:00:00am</p></header><div class="content"><p>The full form would then need to be private(scope). I think that<br>private(file, set) would be more consistent with private(set), which would<br>then be a shorthand for private(scope, set).<br>On Wed, Mar 16, 2016 at 4:18 AM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like the idea of repurposing brackets after private to do this. I think<br>&gt; though that it might be better if there were also a private(type) option to<br>&gt; allow us to be explicit about it, even if we can still type just private to<br>&gt; use it by default.<br>&gt;<br>&gt; About replacing private(set), the examples you’ve given look like computed<br>&gt; properties, and being able to put the accessibility declaration before the<br>&gt; setter is a good option, but for stored properties I think we also need a<br>&gt; way to specify the restriction, for example private(file: set) to enable<br>&gt; setting the value only at the file level. This means that private on its<br>&gt; own is by default actually private(type: get set)<br>&gt;<br>&gt; On 16 Mar 2016, at 06:49, Patrick Pijnappel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Ok to summarize:<br>&gt;<br>&gt; *Setter access modifiers*<br>&gt; var foo: Int { private set { ... } }<br>&gt; var foo: Int { private set }<br>&gt;<br>&gt;    - Consistent with mutating set { ... }. Arguably the current<br>&gt;    private(set) is inconsistent.<br>&gt;    - Eliminates the odd corner case of having a double access modifier,<br>&gt;    e.g. public private(set) var foo: Int.<br>&gt;    - It&#39;s very sensible for custom getters/setters (top case), it just<br>&gt;    requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt;<br>&gt;<br>&gt; *Access modifier keywords*<br>&gt; public/private(module)/private(file)/private<br>&gt;<br>&gt;    - It&#39;s not clear from the keywords how restrictive<br>&gt;    local/private/internal are, while private(module) and private(file)<br>&gt;    are obvious. This makes a declaration either public, or private to a<br>&gt;    certain scope. Arguably e.g. public/module/file/declaration has<br>&gt;    similar benefits but they aren&#39;t as clearly access control related as a<br>&gt;    keyword (e.g. module could just as well be declaring a module).<br>&gt;    - private(module) and private(file) are relatively long, but the<br>&gt;    longest – private(module) – is rarely used (outside the standard<br>&gt;    library) as it&#39;s the default. Most uses of the old private are more<br>&gt;    appropriately done using the new private, so private(file) would<br>&gt;    likely be used less than private.<br>&gt;    - The scheme expands very well to named submodules, e.g. if you have a<br>&gt;    submodule named model you might limit the scope using private(model).<br>&gt;    - private(file) as opposed to private-file or private/file makes it<br>&gt;    more consistent with the new function-like syntax for e.g. attributes.<br>&gt;<br>&gt;<br>&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It&#39;s occurring to me, reading these recent posts, that we have two<br>&gt;&gt; orthogonal systems of access levels.<br>&gt;&gt;<br>&gt;&gt; Swift&#39;s current access system is file based; a project file decides which<br>&gt;&gt; files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>&gt;&gt; determine whether a property is accessible to all, accessible only within<br>&gt;&gt; files of the module, or accessible only within a file. (This takes on an<br>&gt;&gt; extra dimension as files may belong to several modules).<br>&gt;&gt;<br>&gt;&gt; The concept which began this discussion, and several of the proposed<br>&gt;&gt; concepts in this discussion, ask instead for a type-based access system<br>&gt;&gt; similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&gt;&gt; &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>&gt;&gt; to a type or subtypes.<br>&gt;&gt;<br>&gt;&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in<br>&gt;&gt; the file-based access system and &#39;private&#39; to a concept in the type-based<br>&gt;&gt; access system.<br>&gt;&gt;<br>&gt;&gt; I would prefer clearer terms which actually mention the restrictions of<br>&gt;&gt; the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of<br>&gt;&gt; properties accessible by a class and its subclasses; &#39;declaration&#39;, rather<br>&gt;&gt; than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>&gt;&gt; given type or extension declaration.<br>&gt;&gt;<br>&gt;&gt; Since, at the moment, a declaration can only occur within one file, I<br>&gt;&gt; think this most-restricted level has managed to pass as a level of the<br>&gt;&gt; file-based access system. However, if the system is ever extended, we&#39;re<br>&gt;&gt; going to run into new syntax decisions where we have &#39;private module&#39;<br>&gt;&gt; functions (accessible only within the given type in the same module) trying<br>&gt;&gt; to communicate with &#39;protected file&#39; properties (accessible only with the<br>&gt;&gt; type and its subtypes in the same file), and that might lead to conflicts,<br>&gt;&gt; so perhaps we should decide how those might be declared now.<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look<br>&gt;&gt;&gt; right to me or seem to enhance readability. :(<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like Shawn’s proposal better for cases where there are custom<br>&gt;&gt;&gt; getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var foo:Int {<br>&gt;&gt;&gt; public get {…}<br>&gt;&gt;&gt; private(file) set {…}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In fact, that is what I first tried to do before learning about<br>&gt;&gt;&gt; private(set).  But without the implementations, it just seems strange to<br>&gt;&gt;&gt; put the scoping after the rest of the declaration (they work above because<br>&gt;&gt;&gt; they are *before* the custom getter/setter).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still like the idea of having the option to use parameter-like syntax<br>&gt;&gt;&gt; for cases where you don’t have custom getters/setters:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private var foo:Int<br>&gt;&gt;&gt; private(file) var foo:Int<br>&gt;&gt;&gt; private(set: file) var foo:Int<br>&gt;&gt;&gt; private(get: global, set: file) var foo:Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I guess, if we had some way to represent the standard getter/setter,<br>&gt;&gt;&gt; that might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var foo:Int{<br>&gt;&gt;&gt; public get useDefault<br>&gt;&gt;&gt; private(file) set {…}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt;&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, we already use<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and not<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt;&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; While I like private(get: file, set: module) idea, I think it just<br>&gt;&gt;&gt;&gt; gets too inconsistent with private(set: public) and private(set:<br>&gt;&gt;&gt;&gt; private) (?!)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt;&gt;&gt;&gt; “private(set)&quot;<br>&gt;&gt;&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt;&gt;&gt;&gt; file scope<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt;&gt;&gt;&gt; last form: private(get: public, set: module)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/cb7a6933/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>A question about parsing: one of the perceived disadvantages to &#39;module&#39;<br>and &#39;file&#39; is how easily they might also be used as variable names. How<br>easily the parser can tell from context whether they&#39;re intended as<br>variable names or as access level keywords is important to deciding whether<br>they&#39;re good choices for access level words, or whether they&#39;re better as<br>modifiers (e.g. &#39;private(module)&#39; ). Is this a significant concern, or,<br>like argument labels in function calls, can the compiler handle this? (It<br>seems pretty likely to me that any accessibility label will be succeeded by<br>&#39;class&#39;/&#39;enum&#39;/&#39;struct&#39;/&#39;protocol&#39;/&#39;let&#39;/&#39;var&#39;/&#39;func&#39;, but I don&#39;t know if<br>that&#39;s enough).<br></p><p>Also, returning to a point in Chris Lattner&#39;s original brief for this<br>discussion: how should this accessibility work with @testable?<br></p><p>At the moment, if a unit test file calls &quot;import ModuleName&quot; it has access<br>to a module&#39;s public symbols, but if it calls &quot;@testable import ModuleName&quot;<br>it has access to internal symbols. I like the idea of maintaining<br>&quot;@testable&quot; so it&#39;s clear which module is being tested regardless of access<br>level, but should we consider using the access level keywords as an<br>attribute to this in future?<br></p><p>e.g.<br>@testable(public) import ModuleName<br>@testable(internal) import ModuleName<br>@testable(file) import ModuleName // lets us test correctness of<br>file-scoped behaviours<br></p><p>If this is the case then this would seem clunky:<br>@testable(private(scope)) import ModuleName<br></p><p><br>On Wed, Mar 16, 2016 at 10:43 AM, Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The full form would then need to be private(scope). I think that<br>&gt; private(file, set) would be more consistent with private(set), which would<br>&gt; then be a shorthand for private(scope, set).<br>&gt;<br>&gt; On Wed, Mar 16, 2016 at 4:18 AM Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I like the idea of repurposing brackets after private to do this. I think<br>&gt;&gt; though that it might be better if there were also a private(type) option to<br>&gt;&gt; allow us to be explicit about it, even if we can still type just private to<br>&gt;&gt; use it by default.<br>&gt;&gt;<br>&gt;&gt; About replacing private(set), the examples you’ve given look like<br>&gt;&gt; computed properties, and being able to put the accessibility declaration<br>&gt;&gt; before the setter is a good option, but for stored properties I think we<br>&gt;&gt; also need a way to specify the restriction, for example private(file: set)<br>&gt;&gt; to enable setting the value only at the file level. This means that private<br>&gt;&gt; on its own is by default actually private(type: get set)<br>&gt;&gt;<br>&gt;&gt; On 16 Mar 2016, at 06:49, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Ok to summarize:<br>&gt;&gt;<br>&gt;&gt; *Setter access modifiers*<br>&gt;&gt; var foo: Int { private set { ... } }<br>&gt;&gt; var foo: Int { private set }<br>&gt;&gt;<br>&gt;&gt;    - Consistent with mutating set { ... }. Arguably the current<br>&gt;&gt;    private(set) is inconsistent.<br>&gt;&gt;    - Eliminates the odd corner case of having a double access modifier,<br>&gt;&gt;    e.g. public private(set) var foo: Int.<br>&gt;&gt;    - It&#39;s very sensible for custom getters/setters (top case), it just<br>&gt;&gt;    requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Access modifier keywords*<br>&gt;&gt; public/private(module)/private(file)/private<br>&gt;&gt;<br>&gt;&gt;    - It&#39;s not clear from the keywords how restrictive<br>&gt;&gt;    local/private/internal are, while private(module) and private(file)<br>&gt;&gt;    are obvious. This makes a declaration either public, or private to a<br>&gt;&gt;    certain scope. Arguably e.g. public/module/file/declaration has<br>&gt;&gt;    similar benefits but they aren&#39;t as clearly access control related as a<br>&gt;&gt;    keyword (e.g. module could just as well be declaring a module).<br>&gt;&gt;    - private(module) and private(file) are relatively long, but the<br>&gt;&gt;    longest – private(module) – is rarely used (outside the standard<br>&gt;&gt;    library) as it&#39;s the default. Most uses of the old private are more<br>&gt;&gt;    appropriately done using the new private, so private(file) would<br>&gt;&gt;    likely be used less than private.<br>&gt;&gt;    - The scheme expands very well to named submodules, e.g. if you have<br>&gt;&gt;    a submodule named model you might limit the scope using private(model)<br>&gt;&gt;    .<br>&gt;&gt;    - private(file) as opposed to private-file or private/file makes it<br>&gt;&gt;    more consistent with the new function-like syntax for e.g. attributes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It&#39;s occurring to me, reading these recent posts, that we have two<br>&gt;&gt;&gt; orthogonal systems of access levels.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift&#39;s current access system is file based; a project file decides<br>&gt;&gt;&gt; which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and<br>&gt;&gt;&gt; &#39;private&#39; determine whether a property is accessible to all, accessible<br>&gt;&gt;&gt; only within files of the module, or accessible only within a file. (This<br>&gt;&gt;&gt; takes on an extra dimension as files may belong to several modules).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The concept which began this discussion, and several of the proposed<br>&gt;&gt;&gt; concepts in this discussion, ask instead for a type-based access system<br>&gt;&gt;&gt; similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&gt;&gt;&gt; &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>&gt;&gt;&gt; to a type or subtypes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in<br>&gt;&gt;&gt; the file-based access system and &#39;private&#39; to a concept in the type-based<br>&gt;&gt;&gt; access system.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would prefer clearer terms which actually mention the restrictions of<br>&gt;&gt;&gt; the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of<br>&gt;&gt;&gt; properties accessible by a class and its subclasses; &#39;declaration&#39;, rather<br>&gt;&gt;&gt; than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>&gt;&gt;&gt; given type or extension declaration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since, at the moment, a declaration can only occur within one file, I<br>&gt;&gt;&gt; think this most-restricted level has managed to pass as a level of the<br>&gt;&gt;&gt; file-based access system. However, if the system is ever extended, we&#39;re<br>&gt;&gt;&gt; going to run into new syntax decisions where we have &#39;private module&#39;<br>&gt;&gt;&gt; functions (accessible only within the given type in the same module) trying<br>&gt;&gt;&gt; to communicate with &#39;protected file&#39; properties (accessible only with the<br>&gt;&gt;&gt; type and its subtypes in the same file), and that might lead to conflicts,<br>&gt;&gt;&gt; so perhaps we should decide how those might be declared now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look<br>&gt;&gt;&gt;&gt; right to me or seem to enhance readability. :(<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like Shawn’s proposal better for cases where there are custom<br>&gt;&gt;&gt;&gt; getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var foo:Int {<br>&gt;&gt;&gt;&gt; public get {…}<br>&gt;&gt;&gt;&gt; private(file) set {…}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In fact, that is what I first tried to do before learning about<br>&gt;&gt;&gt;&gt; private(set).  But without the implementations, it just seems strange to<br>&gt;&gt;&gt;&gt; put the scoping after the rest of the declaration (they work above because<br>&gt;&gt;&gt;&gt; they are *before* the custom getter/setter).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still like the idea of having the option to use parameter-like syntax<br>&gt;&gt;&gt;&gt; for cases where you don’t have custom getters/setters:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; private var foo:Int<br>&gt;&gt;&gt;&gt; private(file) var foo:Int<br>&gt;&gt;&gt;&gt; private(set: file) var foo:Int<br>&gt;&gt;&gt;&gt; private(get: global, set: file) var foo:Int<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I guess, if we had some way to represent the standard getter/setter,<br>&gt;&gt;&gt;&gt; that might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var foo:Int{<br>&gt;&gt;&gt;&gt; public get useDefault<br>&gt;&gt;&gt;&gt; private(file) set {…}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt;&gt;&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, we already use<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; and not<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt;&gt;&gt;&gt; patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; While I like private(get: file, set: module) idea, I think it just<br>&gt;&gt;&gt;&gt;&gt; gets too inconsistent with private(set: public) and private(set:<br>&gt;&gt;&gt;&gt;&gt; private) (?!)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt;&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt;&gt;&gt;&gt;&gt; “private(set)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter<br>&gt;&gt;&gt;&gt;&gt;&gt; has file scope<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt;&gt;&gt;&gt;&gt; last form: private(get: public, set: module)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/19cbd39a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 16 Mar 2016, at 11:04, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; If this is the case then this would seem clunky:<br>&gt; @testable(private(scope)) import ModuleName<br></p><p>Does the parameter for @testable need to match exactly? An alternative could be to take it as @testable(private: scope), not quite as clunky but keeps the same basic structure of all restricted accessibility being “private” followed by a type of privacy.<br></p><p>I think that use of a modifier for private(scope) type declarations is the best way to go for avoiding introducing new keywords (actually it would free up internal). It’s actually a style that I’d like to see more of; there was discussion recently about introducing customisable property behaviours, but there was difficulty about how to apply them, however a behaviour(lazy) type syntax could solve that.<br></p><p>When it comes to parsing though, I think that it as long as let/var is required to be the last element before a property name then this eliminates most parsing issues regarding name collisions with properties.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 7:04 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A question about parsing: one of the perceived disadvantages to &#39;module&#39; and &#39;file&#39; is how easily they might also be used as variable names. How easily the parser can tell from context whether they&#39;re intended as variable names or as access level keywords is important to deciding whether they&#39;re good choices for access level words, or whether they&#39;re better as modifiers (e.g. &#39;private(module)&#39; ). Is this a significant concern, or, like argument labels in function calls, can the compiler handle this? (It seems pretty likely to me that any accessibility label will be succeeded by &#39;class&#39;/&#39;enum&#39;/&#39;struct&#39;/&#39;protocol&#39;/&#39;let&#39;/&#39;var&#39;/&#39;func&#39;, but I don&#39;t know if that&#39;s enough).<br>&gt; <br>&gt; Also, returning to a point in Chris Lattner&#39;s original brief for this discussion: how should this accessibility work with @testable?<br>&gt; <br>&gt; At the moment, if a unit test file calls &quot;import ModuleName&quot; it has access to a module&#39;s public symbols, but if it calls &quot;@testable import ModuleName&quot; it has access to internal symbols. I like the idea of maintaining &quot;@testable&quot; so it&#39;s clear which module is being tested regardless of access level, but should we consider using the access level keywords as an attribute to this in future?<br>&gt; <br>&gt; e.g.<br>&gt; @testable(public) import ModuleName<br>&gt; @testable(internal) import ModuleName<br>&gt; @testable(file) import ModuleName // lets us test correctness of file-scoped behaviours<br></p><p>I like this idea, and want this capability. But my first thought is this would be better accomplished by a more fine-grained import capability. That is, the ability to import only certain parts from a module. Not sure that would handle the file case though.<br></p><p>&gt; <br>&gt; If this is the case then this would seem clunky:<br>&gt; @testable(private(scope)) import ModuleName<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Mar 16, 2016 at 10:43 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The full form would then need to be private(scope). I think that private(file, set) would be more consistent with private(set), which would then be a shorthand for private(scope, set).<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 16, 2016 at 4:18 AM Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I like the idea of repurposing brackets after private to do this. I think though that it might be better if there were also a private(type) option to allow us to be explicit about it, even if we can still type just private to use it by default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; About replacing private(set), the examples you’ve given look like computed properties, and being able to put the accessibility declaration before the setter is a good option, but for stored properties I think we also need a way to specify the restriction, for example private(file: set) to enable setting the value only at the file level. This means that private on its own is by default actually private(type: get set)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 16 Mar 2016, at 06:49, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok to summarize:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Setter access modifiers<br>&gt;&gt;&gt;&gt; var foo: Int { private set { ... } }<br>&gt;&gt;&gt;&gt; var foo: Int { private set }<br>&gt;&gt;&gt;&gt; Consistent with mutating set { ... }. Arguably the current private(set) is inconsistent.<br>&gt;&gt;&gt;&gt; Eliminates the odd corner case of having a double access modifier, e.g. public private(set) var foo: Int.<br>&gt;&gt;&gt;&gt; It&#39;s very sensible for custom getters/setters (top case), it just requires allowing a bodiless get/set. We already kinda do this in protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Access modifier keywords<br>&gt;&gt;&gt;&gt; public/private(module)/private(file)/private<br>&gt;&gt;&gt;&gt; It&#39;s not clear from the keywords how restrictive local/private/internal are, while private(module) and private(file) are obvious. This makes a declaration either public, or private to a certain scope. Arguably e.g. public/module/file/declaration has similar benefits but they aren&#39;t as clearly access control related as a keyword (e.g. module could just as well be declaring a module).<br>&gt;&gt;&gt;&gt; private(module) and private(file) are relatively long, but the longest – private(module) – is rarely used (outside the standard library) as it&#39;s the default. Most uses of the old private are more appropriately done using the new private, so private(file) would likely be used less than private. <br>&gt;&gt;&gt;&gt; The scheme expands very well to named submodules, e.g. if you have a submodule named model you might limit the scope using private(model). <br>&gt;&gt;&gt;&gt; private(file) as opposed to private-file or private/file makes it more consistent with the new function-like syntax for e.g. attributes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Mar 16, 2016 at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; It&#39;s occurring to me, reading these recent posts, that we have two orthogonal systems of access levels.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift&#39;s current access system is file based; a project file decides which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39; determine whether a property is accessible to all, accessible only within files of the module, or accessible only within a file. (This takes on an extra dimension as files may belong to several modules).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The concept which began this discussion, and several of the proposed concepts in this discussion, ask instead for a type-based access system similar to those in other languages including Objective-C, where &#39;public&#39;, &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access to a type or subtypes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the file-based access system and &#39;private&#39; to a concept in the type-based access system.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would prefer clearer terms which actually mention the restrictions of the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties accessible by a class and its subclasses; &#39;declaration&#39;, rather than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a given type or extension declaration.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since, at the moment, a declaration can only occur within one file, I think this most-restricted level has managed to pass as a level of the file-based access system. However, if the system is ever extended, we&#39;re going to run into new syntax decisions where we have &#39;private module&#39; functions (accessible only within the given type in the same module) trying to communicate with &#39;protected file&#39; properties (accessible only with the type and its subtypes in the same file), and that might lead to conflicts, so perhaps we should decide how those might be declared now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; right to me or seem to enhance readability. :(<br>&gt;&gt;&gt;&gt;&gt;&gt; I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var foo:Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	public get {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; 	private(file) set {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private var foo:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private(file) var foo:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private(set: file) var foo:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private(get: global, set: file) var foo:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var foo:Int{<br>&gt;&gt;&gt;&gt;&gt;&gt; 	public get useDefault<br>&gt;&gt;&gt;&gt;&gt;&gt; 	private(file) set {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo: Int { private(file) set } <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, we already use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function calls.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about the following 3 forms?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/01f6e54f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 16, 2016 at 09:00:00am</p></header><div class="content"><p>SE-0025 did not include any type-based access control. I personally would like to keep Swift free of type-based access control, and I think the core team feels the same way. &quot;The world, the module, the file, the current lexical scope&quot; is a properly nested set of scopes that are not defined in terms of types.<br></p><p>I think discussion of type-based access control should happen on a different thread. As you say, it would be orthogonal to any refinements of SE-0025.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On Mar 15, 2016, at 17:26 , Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s occurring to me, reading these recent posts, that we have two orthogonal systems of access levels.<br>&gt; <br>&gt; Swift&#39;s current access system is file based; a project file decides which files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39; determine whether a property is accessible to all, accessible only within files of the module, or accessible only within a file. (This takes on an extra dimension as files may belong to several modules).<br>&gt; <br>&gt; The concept which began this discussion, and several of the proposed concepts in this discussion, ask instead for a type-based access system similar to those in other languages including Objective-C, where &#39;public&#39;, &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access to a type or subtypes.<br>&gt; <br>&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the file-based access system and &#39;private&#39; to a concept in the type-based access system.<br>&gt; <br>&gt; I would prefer clearer terms which actually mention the restrictions of the level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties accessible by a class and its subclasses; &#39;declaration&#39;, rather than &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a given type or extension declaration.<br>&gt; <br>&gt; Since, at the moment, a declaration can only occur within one file, I think this most-restricted level has managed to pass as a level of the file-based access system. However, if the system is ever extended, we&#39;re going to run into new syntax decisions where we have &#39;private module&#39; functions (accessible only within the given type in the same module) trying to communicate with &#39;protected file&#39; properties (accessible only with the type and its subtypes in the same file), and that might lead to conflicts, so perhaps we should decide how those might be declared now.<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; And again, moving the access control modification to the end just doesn&#39;t look <br>&gt;&gt; right to me or seem to enhance readability. :(<br>&gt; I like Shawn’s proposal better for cases where there are custom getter/setter implementations.  We should definitely be able to do:<br>&gt; <br>&gt; var foo:Int {<br>&gt; 	public get {…}<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; In fact, that is what I first tried to do before learning about private(set).  But without the implementations, it just seems strange to put the scoping after the rest of the declaration (they work above because they are before the custom getter/setter).<br>&gt; <br>&gt; I still like the idea of having the option to use parameter-like syntax for cases where you don’t have custom getters/setters:<br>&gt; <br>&gt; private var foo:Int<br>&gt; private(file) var foo:Int<br>&gt; private(set: file) var foo:Int<br>&gt; private(get: global, set: file) var foo:Int<br>&gt; <br>&gt; <br>&gt; I guess, if we had some way to represent the standard getter/setter, that might work too.  I don’t love it, but maybe with better wording?<br>&gt; <br>&gt; var foo:Int{<br>&gt; 	public get useDefault<br>&gt; 	private(file) set {…}<br>&gt; }<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like Shawn&#39;s proposal: <br>&gt;&gt;  <br>&gt;&gt; var foo: Int { private(file) set } <br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; For example, we already use<br>&gt;&gt; <br>&gt;&gt; var foo: Int { mutating get { ... } }<br>&gt;&gt; <br>&gt;&gt; and not<br>&gt;&gt; <br>&gt;&gt; mutating(get) var foo: Int { get { ... } }<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I like Shawn&#39;s proposal:<br>&gt;&gt; <br>&gt;&gt; var foo: Int { private(file) set }<br>&gt;&gt; <br>&gt;&gt; In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; While I like private(get: file, set: module) idea, I think it just gets too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt; for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt; private(set).<br>&gt;&gt;&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt; - Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt; the other unification efforts going on to make everything look like<br>&gt;&gt;&gt; function calls.<br>&gt;&gt; What about the following 3 forms?<br>&gt;&gt; <br>&gt;&gt; private(file) //both setter and getter have file scope<br>&gt;&gt; private(set: file) //setter has file scope.  Equivalent to current “private(set)&quot;<br>&gt;&gt; private(get: module, set: file) //getter has module scope &amp; setter has file scope<br>&gt;&gt; <br>&gt;&gt; It is a bit weird, but we should probably also allow “public&quot; in that last form: private(get: public, set: module)<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/3ecc1daa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
