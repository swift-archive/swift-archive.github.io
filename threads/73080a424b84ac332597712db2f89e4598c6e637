<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>November  9, 2016 at 10:00:00am</p></header><div class="content"><p>Although out of scope for phase 1, something that keeps cropping up in a variety of Linux/Darwin Swift scripts is the conditional inclusion of Darwin or GlibC per platform. The last point was an observation that creating a &#39;nice&#39; wrapper for LibC or a cleaned up POSIX API is a non-goal:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html<br></p><p>&gt; I think it makes sense to have a cross platform “libc” which is an alias for darwin, glibc, or whatever, and just leave it at that.<br>&gt; <br>&gt; Other proposals for a “POSIX” module have gotten bogged down because inevitably the idea comes up to make the resultant API nicer in various ways: rename creat, handle errno more nicely, make use of multiple return values, … etc.  The problem with this approach is that we don’t *want* people using these layer of APIs, we want higher level Foundation-like APIs to be used.<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; I think we should formally decide that a “nice” wrapper for libc is a non-goal.  There is too much that doesn’t make sense to wrap at this level - the only Swift code that should be using this is the implementation of higher level API, and such extremely narrow cases that we can live with them having to handle the problems of dealing with the raw APIs directly.<br>&gt; <br>&gt; -Chris<br></p><p>I have created a draft for a proposal to create such a module. Comments are welcome.<br></p><p>Alex<br></p><p>---<br></p><p># Libc module for Swift<br></p><p>* Proposal: [SE-NNNN](NNNN-filename.md)<br>* Authors: [Alex Blewitt](https://github.com/alblue)<br>* Review Manager: TBD<br>* Status: **Under discussion**<br></p><p>## Introduction<br></p><p>When running on Darwin, the base module is called `Darwin`. When running<br>on Linux or other operating systems, it&#39;s called `GlibC`. <br></p><p>This repeatedly leads to code such as:<br></p><p>    ````<br>    #if os(Linux)<br>      import Glibc<br>    #else<br>      import Darwin<br>    #endif<br>    ```<br></p><p>As the set of operating systems evolve, one of these conditional imports<br>needs to be updated. Instead of repeating this, make it available via a<br>standard `Libc` module in the base Swift library.<br></p><p>Swift-evolution thread: [Discussion thread topic for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html)<br></p><p>## Motivation<br></p><p>The [set of platforms](https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36)<br>that Swift currently runs on can be divided into two; Darwin and XNU based systems<br>(macOS, iOS, watchOS, tvOS), Windows, and Unix based systems<br>(Linux, FreeBSD, Android, PS4). <br></p><p>The base module on Darwin is called `Darwin`, while on Linux and<br>other Unix systems the base module is called `Glibc`. The base<br>module is typically conditionally included when working at a lower layer<br>than Foundation (which has the same detail involved in importing the<br>base module).<br></p><p>As a result, conditionally importing the right version typically uses<br>a conditional test based on the operating system, and the same code is<br>seen in a number of different modules, both internal to Swift and external:<br></p><p>* [Test for mmap in stdlib](https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9)<br>* [Validation test for PassIfChildCrashedDuringTestExecution](https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9)<br>* [Kitura&#39;s Socket definitions](https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25)<br>* [Vapor&#39;s HTTP Server](https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5)<br></p><p>Some have already created a `Libc` module that effectively does what this<br>proposal suggests, such as [Vapor&#39;s Core Libc](https://github.com/vapor/core/blob/master/Sources/libc/libc.swift)<br></p><p>    ```<br>    #if os(Linux)<br>      @_exported import Glibc<br>    #else<br>      @_exported import Darwin.C<br>    #endif<br>    ```<br></p><p>Each of these examples has subtly different behaviour; for example,<br>whether or not the os tests only include Linux (and then fail over to<br>Darwin), or whether they contain other Unices such as FreeBSD and Android.<br></p><p>## Proposed solution<br></p><p>The solution is to formalise these patterns in the base Swift library<br>and present a `Libc` module that conditionally imports `Glibc` or `Darwin`<br>based on the correct platform. Additional operating systems can be added<br>and kept up to date with the list of supported operating system conditionals<br>and including a failure message when an unknown operating system is detected.<br></p><p>## Detailed design<br></p><p>This will add a `Libc` module for the standard library that re-exports<br>the correct import depending on the operating system:<br></p><p>    ```<br>    #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>      @_exported import Darwin<br>    #elseif os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>      @_exported import Glibc<br>    #else<br>      fatalError(&quot;Libc not supported on operating system&quot;)<br>    #endif<br>    ```<br></p><p>As new operating systems are added or become supported (such as Windows)<br>the standard imports can be added appropriately to this module.<br></p><p>## Source compatibility<br></p><p>There is no impact to source compatibility, since this proposal is additive.<br>Existing source code will work regardless of if this module is used or not.<br>However it improves source compatibility going forwards, since as new<br>operating systems are added this file will be updated, instead of the change<br>having to be made in multiple open-source projects.<br></p><p>## Effect on ABI stability<br></p><p>There is no impact to ABI compatibility, since this proposal is additive.<br>Existing source code will work regardless of if this module is used or not.<br></p><p>## Effect on API resilience<br></p><p>There is no impact to ABI resilience, since this proposal is additive.<br>Existing source code will work regardless of if this module is used or not.<br></p><p>## Alternatives considered<br></p><p>The first alternative is to do nothing. Existing Swift projects already<br>conditionally import these modules, or import a higher-level module (such<br>as `Foundation`) that performs the conditional import.<br></p><p>The second alternative is to export sub-modules of the modules. Clang<br>permits imports of sub-modules, so it could be possible to import only<br>`Darwin.POSIX` and `GlibC.POSIX`. However, in Swift, importing a sub-module<br>makes the whole module available anyway, so the difference between importing<br>a whole module versus a submodule is irrelevant.<br></p><p>The third alternative is to explore creating standard functions (in Swift)<br>corresponding to POSIX functionality, but where the format of the return<br>results are known. This would require a per-operating system binding to<br>expose operating-system details such as the byte ordering of structures<br>as used in the various `getaddrinfo` calls. These may evolve out of future<br>evolution proposals and this does not conflict with those goals at this<br>stage. There are additional clean-ups that this could address, such as the<br>use of the (thread-local) `errno` which may not be reliably read from within<br>Swift. However, the (swift-evolution thread)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html]<br>calls this &quot;the perfect being the enemy of the good&quot;. Instead of trying to<br>solve all of these problems, they should be handled by subsequent<br>proposals (such as (Johannes&#39; proposal)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html]<br>regarding errno handling sent to swift-evolution previously).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/7308e637/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>November  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 9, 2016, at 10:58 AM, Alex Blewitt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although out of scope for phase 1, something that keeps cropping up in a variety of Linux/Darwin Swift scripts is the conditional inclusion of Darwin or GlibC per platform. The last point was an observation that creating a &#39;nice&#39; wrapper for LibC or a cleaned up POSIX API is a non-goal:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html<br></p><p>I appreciate the desire to have a combined module for this but I&#39;m not convinced that `Libc` (or `LibC`) is a particularly good choice of name here. The `Lib` prefix feels particularly non-Swifty here, most other instances of lib&lt;something&gt; on Darwin have their `lib` prefix dropped when imported as module. From a hierarchical point of view, the `Darwin` module encompasses a suite of libraries that are larger than libsystem_c.dylib (the Darwin Libc). Confusing the naming with layering here would be unfortunate. There&#39;s also a potentially confusing Darwin.C submodule that isn&#39;t what you&#39;re asking for but does step, somewhat, on the namespace.<br></p><p>Perhaps names more along the lines of `Platform` or `Base` would work better here? On Darwin the all-encompasing base libraries are all under Libsystem, `System` would be another potentially platform-agnostic name.<br></p><p>&gt; <br>&gt;&gt; I think it makes sense to have a cross platform “libc” which is an alias for darwin, glibc, or whatever, and just leave it at that.<br>&gt;&gt; <br>&gt;&gt; Other proposals for a “POSIX” module have gotten bogged down because inevitably the idea comes up to make the resultant API nicer in various ways: rename creat, handle errno more nicely, make use of multiple return values, … etc.  The problem with this approach is that we don’t *want* people using these layer of APIs, we want higher level Foundation-like APIs to be used.<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think we should formally decide that a “nice” wrapper for libc is a non-goal.  There is too much that doesn’t make sense to wrap at this level - the only Swift code that should be using this is the implementation of higher level API, and such extremely narrow cases that we can live with them having to handle the problems of dealing with the raw APIs directly.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; I have created a draft for a proposal to create such a module. Comments are welcome.<br>&gt; <br>&gt; Alex<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; # Libc module for Swift<br>&gt; <br>&gt; * Proposal: [SE-NNNN](NNNN-filename.md)<br>&gt; * Authors: [Alex Blewitt](https://github.com/alblue)<br>&gt; * Review Manager: TBD<br>&gt; * Status: **Under discussion**<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; When running on Darwin, the base module is called `Darwin`. When running<br>&gt; on Linux or other operating systems, it&#39;s called `GlibC`. <br>&gt; <br>&gt; This repeatedly leads to code such as:<br>&gt; <br>&gt;     ````<br>&gt;     #if os(Linux)<br>&gt;       import Glibc<br>&gt;     #else<br>&gt;       import Darwin<br>&gt;     #endif<br>&gt;     ```<br>&gt; <br>&gt; As the set of operating systems evolve, one of these conditional imports<br>&gt; needs to be updated. Instead of repeating this, make it available via a<br>&gt; standard `Libc` module in the base Swift library.<br>&gt; <br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; The [set of platforms](https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36)<br>&gt; that Swift currently runs on can be divided into two; Darwin and XNU based systems<br>&gt; (macOS, iOS, watchOS, tvOS), Windows, and Unix based systems<br>&gt; (Linux, FreeBSD, Android, PS4). <br>&gt; <br>&gt; The base module on Darwin is called `Darwin`, while on Linux and<br>&gt; other Unix systems the base module is called `Glibc`. The base<br>&gt; module is typically conditionally included when working at a lower layer<br>&gt; than Foundation (which has the same detail involved in importing the<br>&gt; base module).<br>&gt; <br>&gt; As a result, conditionally importing the right version typically uses<br>&gt; a conditional test based on the operating system, and the same code is<br>&gt; seen in a number of different modules, both internal to Swift and external:<br>&gt; <br>&gt; * [Test for mmap in stdlib](https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9)<br>&gt; * [Validation test for PassIfChildCrashedDuringTestExecution](https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9)<br>&gt; * [Kitura&#39;s Socket definitions](https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25)<br>&gt; * [Vapor&#39;s HTTP Server](https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5)<br>&gt; <br>&gt; Some have already created a `Libc` module that effectively does what this<br>&gt; proposal suggests, such as [Vapor&#39;s Core Libc](https://github.com/vapor/core/blob/master/Sources/libc/libc.swift)<br>&gt; <br>&gt;     ```<br>&gt;     #if os(Linux)<br>&gt;       @_exported import Glibc<br>&gt;     #else<br>&gt;       @_exported import Darwin.C<br>&gt;     #endif<br>&gt;     ```<br>&gt; <br>&gt; Each of these examples has subtly different behaviour; for example,<br>&gt; whether or not the os tests only include Linux (and then fail over to<br>&gt; Darwin), or whether they contain other Unices such as FreeBSD and Android.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; The solution is to formalise these patterns in the base Swift library<br>&gt; and present a `Libc` module that conditionally imports `Glibc` or `Darwin`<br>&gt; based on the correct platform. Additional operating systems can be added<br>&gt; and kept up to date with the list of supported operating system conditionals<br>&gt; and including a failure message when an unknown operating system is detected.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; This will add a `Libc` module for the standard library that re-exports<br>&gt; the correct import depending on the operating system:<br>&gt; <br>&gt;     ```<br>&gt;     #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>&gt;       @_exported import Darwin<br>&gt;     #elseif os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;       @_exported import Glibc<br>&gt;     #else<br>&gt;       fatalError(&quot;Libc not supported on operating system&quot;)<br>&gt;     #endif<br>&gt;     ```<br>&gt; <br>&gt; As new operating systems are added or become supported (such as Windows)<br>&gt; the standard imports can be added appropriately to this module.<br>&gt; <br>&gt; ## Source compatibility<br>&gt; <br>&gt; There is no impact to source compatibility, since this proposal is additive.<br>&gt; Existing source code will work regardless of if this module is used or not.<br>&gt; However it improves source compatibility going forwards, since as new<br>&gt; operating systems are added this file will be updated, instead of the change<br>&gt; having to be made in multiple open-source projects.<br>&gt; <br>&gt; ## Effect on ABI stability<br>&gt; <br>&gt; There is no impact to ABI compatibility, since this proposal is additive.<br>&gt; Existing source code will work regardless of if this module is used or not.<br>&gt; <br>&gt; ## Effect on API resilience<br>&gt; <br>&gt; There is no impact to ABI resilience, since this proposal is additive.<br>&gt; Existing source code will work regardless of if this module is used or not.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; The first alternative is to do nothing. Existing Swift projects already<br>&gt; conditionally import these modules, or import a higher-level module (such<br>&gt; as `Foundation`) that performs the conditional import.<br>&gt; <br>&gt; The second alternative is to export sub-modules of the modules. Clang<br>&gt; permits imports of sub-modules, so it could be possible to import only<br>&gt; `Darwin.POSIX` and `GlibC.POSIX`. However, in Swift, importing a sub-module<br>&gt; makes the whole module available anyway, so the difference between importing<br>&gt; a whole module versus a submodule is irrelevant.<br>&gt; <br>&gt; The third alternative is to explore creating standard functions (in Swift)<br>&gt; corresponding to POSIX functionality, but where the format of the return<br>&gt; results are known. This would require a per-operating system binding to<br>&gt; expose operating-system details such as the byte ordering of structures<br>&gt; as used in the various `getaddrinfo` calls. These may evolve out of future<br>&gt; evolution proposals and this does not conflict with those goals at this<br>&gt; stage. There are additional clean-ups that this could address, such as the<br>&gt; use of the (thread-local) `errno` which may not be reliably read from within<br>&gt; Swift. However, the (swift-evolution thread)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html]<br>&gt; calls this &quot;the perfect being the enemy of the good&quot;. Instead of trying to<br>&gt; solve all of these problems, they should be handled by subsequent<br>&gt; proposals (such as (Johannes&#39; proposal)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html]<br>&gt; regarding errno handling sent to swift-evolution previously).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>November 10, 2016 at 09:00:00pm</p></header><div class="content"><p>grep -R &quot;import Glibc&quot; ~/Code --include &quot;*.swift&quot; | wc -l<br>    297<br></p><p>As someone who might be characterized as suffering from the problem this<br>proposal purports to solve, I am not convinced.<br></p><p>The primary problem here is that &quot;libc&quot; is a misnomer.  Did you mean<br>musl, dietlibc, or glibc?  Did you mean &quot;whatever libc my distro likes?&quot;<br>Swift in practice only supports one per platform, but that is a bug not<br>a feature, and that bug should not be standardized.  We could try to<br>invent some syntax to specify one but now we are back with the current<br>system again.<br></p><p>The other problem is that in all my usages, &quot;import Glibc&quot; is not a real<br>problem I face.  The real problems are that &quot;the libcs *plural*&quot; are<br>*just different*.  Darwin has timeval64, glibc does not, and you&#39;d<br>better check your arch and pick the right one, only on one platform.<br>SO_REUSEADDR has one type in Brand X and another type in Brand Y.  Don&#39;t<br>even get me *started* on poll, EREs, or half a dozen other behavioral<br>variations.<br></p><p>Taking two different libraries and pretending they are the same is not<br>the solution, it&#39;s the disease.  The way out of this swamp for most<br>developers is to use a real Swift library, the same damn Swift library,<br>on all platforms (sadly, Foundation today does not meet this<br>requirement).  The way out of this swamp for crazy people like me who<br>must write to the metal is to actually write to the metal, to the<br>particular libc being targeted, not to a hypothetical platonic ideal<br>libc which does not exist.<br></p><p>I realize that four lines at the top of my files is a *visible*<br>annoyance, but fixing it just promotes it to an invisible one.<br></p><p>Drew<br></p><p>--<br>  Drew Crawford<br>  drew at sealedabstract.com<br></p><p><br></p><p>On Wed, Nov 9, 2016, at 12:58 PM, Alex Blewitt via swift-evolution wrote:<br>&gt; Although out of scope for phase 1, something that keeps cropping up in<br>&gt; a variety of Linux/Darwin Swift scripts is the conditional inclusion<br>&gt; of Darwin or GlibC per platform. The last point was an observation<br>&gt; that creating a &#39;nice&#39; wrapper for LibC or a cleaned up POSIX API is a<br>&gt; non-goal:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html<br>&gt;<br>&gt;&gt; I think it makes sense to have a cross platform “libc” which is an<br>&gt;&gt; alias for darwin, glibc, or whatever, and just leave it at that.<br>&gt;&gt; Other proposals for a “POSIX” module have gotten bogged down because<br>&gt;&gt; inevitably the idea comes up to make the resultant API nicer in<br>&gt;&gt; various ways: rename creat, handle errno more nicely, make use of<br>&gt;&gt; multiple return values, … etc.  The problem with this approach is<br>&gt;&gt; that we don’t *want* people using these layer of APIs, we want higher<br>&gt;&gt; level Foundation-like APIs to be used.  ...*<br>* I think we should formally decide that a “nice” wrapper for libc is a<br>  non-goal.  There is too much that doesn’t make sense to wrap at this<br>  level - the only Swift code that should be using this is the<br>  implementation of higher level API, and such extremely narrow cases<br>  that we can live with them having to handle the problems of dealing<br>  with the raw APIs directly.  -Chris<br>&gt;<br>&gt; I have created a draft for a proposal to create such a module.<br>&gt; Comments are welcome.<br>&gt;<br>&gt; Alex<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; # Libc module for Swift<br>&gt;<br>&gt; * Proposal: [SE-NNNN](NNNN-filename.md)<br>&gt; * Authors: [Alex Blewitt](https://github.com/alblue)<br>&gt; * Review Manager: TBD<br>&gt; * Status: **Under discussion**<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; When running on Darwin, the base module is called `Darwin`.<br>&gt; When running<br>&gt; on Linux or other operating systems, it&#39;s called `GlibC`.<br>&gt;<br>&gt; This repeatedly leads to code such as:<br>&gt;<br>&gt;     ````<br>&gt;     #if os(Linux)<br>&gt;       import Glibc<br>&gt;     #else<br>&gt;       import Darwin<br>&gt;     #endif<br>&gt;     ```<br>&gt;<br>&gt; As the set of operating systems evolve, one of these<br>&gt; conditional imports<br>&gt; needs to be updated. Instead of repeating this, make it<br>&gt; available via a<br>&gt; standard `Libc` module in the base Swift library.<br>&gt;<br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal]<br>&gt; (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; The [set of platforms]<br>&gt; (https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36)<br>&gt; that Swift currently runs on can be divided into two; Darwin and XNU<br>&gt; based systems<br>&gt; (macOS, iOS, watchOS, tvOS), Windows, and Unix based systems<br>&gt; (Linux, FreeBSD, Android, PS4).<br>&gt;<br>&gt; The base module on Darwin is called `Darwin`, while on Linux and<br>&gt; other Unix systems the base module is called `Glibc`. The base<br>&gt; module is typically conditionally included when working at a<br>&gt; lower layer<br>&gt; than Foundation (which has the same detail involved in importing the<br>&gt; base module).<br>&gt;<br>&gt; As a result, conditionally importing the right version typically uses<br>&gt; a conditional test based on the operating system, and the same code is<br>&gt; seen in a number of different modules, both internal to Swift and<br>&gt; external:<br>&gt;<br>&gt; * [Test for mmap in stdlib]<br>&gt;   (https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9)<br>&gt; * [Validation test for PassIfChildCrashedDuringTestExecution]<br>&gt;   (https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9)<br>&gt; * [Kitura&#39;s Socket definitions]<br>&gt;   (https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25)<br>&gt; * [Vapor&#39;s HTTP Server]<br>&gt;   (https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5)<br>&gt;<br>&gt; Some have already created a `Libc` module that effectively does<br>&gt; what this<br>&gt; proposal suggests, such as [Vapor&#39;s Core Libc]<br>&gt; (https://github.com/vapor/core/blob/master/Sources/libc/libc.swift)<br>&gt;<br>&gt;     ```<br>&gt;     #if os(Linux)<br>&gt;       @_exported import Glibc<br>&gt;     #else<br>&gt;       @_exported import Darwin.C<br>&gt;     #endif<br>&gt;     ```<br>&gt;<br>&gt; Each of these examples has subtly different behaviour; for example,<br>&gt; whether or not the os tests only include Linux (and then fail over to<br>&gt; Darwin), or whether they contain other Unices such as FreeBSD and<br>&gt; Android.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The solution is to formalise these patterns in the base Swift library<br>&gt; and present a `Libc` module that conditionally imports `Glibc` or<br>&gt; `Darwin`<br>&gt; based on the correct platform. Additional operating systems can<br>&gt; be added<br>&gt; and kept up to date with the list of supported operating system<br>&gt; conditionals<br>&gt; and including a failure message when an unknown operating system is<br>&gt; detected.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; This will add a `Libc` module for the standard library that re-exports<br>&gt; the correct import depending on the operating system:<br>&gt;<br>&gt;     ```<br>&gt;     #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>&gt;       @_exported import Darwin<br>&gt;     #elseif os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;       @_exported import Glibc<br>&gt;     #else<br>&gt;       fatalError(&quot;Libc not supported on operating system&quot;)<br>&gt;     #endif<br>&gt;     ```<br>&gt;<br>&gt; As new operating systems are added or become supported (such as<br>&gt; Windows)<br>&gt; the standard imports can be added appropriately to this module.<br>&gt;<br>&gt; ## Source compatibility<br>&gt;<br>&gt; There is no impact to source compatibility, since this proposal is<br>&gt; additive.<br>&gt; Existing source code will work regardless of if this module is<br>&gt; used or not.<br>&gt; However it improves source compatibility going forwards, since as new<br>&gt; operating systems are added this file will be updated, instead of<br>&gt; the change<br>&gt; having to be made in multiple open-source projects.<br>&gt;<br>&gt; ## Effect on ABI stability<br>&gt;<br>&gt; There is no impact to ABI compatibility, since this proposal is<br>&gt; additive.<br>&gt; Existing source code will work regardless of if this module is<br>&gt; used or not.<br>&gt;<br>&gt; ## Effect on API resilience<br>&gt;<br>&gt; There is no impact to ABI resilience, since this proposal is additive.<br>&gt; Existing source code will work regardless of if this module is<br>&gt; used or not.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The first alternative is to do nothing. Existing Swift projects<br>&gt; already<br>&gt; conditionally import these modules, or import a higher-level<br>&gt; module (such<br>&gt; as `Foundation`) that performs the conditional import.<br>&gt;<br>&gt; The second alternative is to export sub-modules of the modules. Clang<br>&gt; permits imports of sub-modules, so it could be possible to import only<br>&gt; `Darwin.POSIX` and `GlibC.POSIX`. However, in Swift, importing a<br>&gt; sub-module<br>&gt; makes the whole module available anyway, so the difference between<br>&gt; importing<br>&gt; a whole module versus a submodule is irrelevant.<br>&gt;<br>&gt; The third alternative is to explore creating standard functions<br>&gt; (in Swift)<br>&gt; corresponding to POSIX functionality, but where the format of<br>&gt; the return<br>&gt; results are known. This would require a per-operating system<br>&gt; binding to<br>&gt; expose operating-system details such as the byte ordering of<br>&gt; structures<br>&gt; as used in the various `getaddrinfo` calls. These may evolve out<br>&gt; of future<br>&gt; evolution proposals and this does not conflict with those goals at<br>&gt; this<br>&gt; stage. There are additional clean-ups that this could address,<br>&gt; such as the<br>&gt; use of the (thread-local) `errno` which may not be reliably read<br>&gt; from within<br>&gt; Swift. However, the (swift-evolution thread)[<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html]<br>&gt; calls this &quot;the perfect being the enemy of the good&quot;. Instead of<br>&gt; trying to<br>&gt; solve all of these problems, they should be handled by subsequent<br>&gt; proposals (such as (Johannes&#39; proposal)[<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html]<br>&gt; regarding errno handling sent to swift-evolution previously).<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/7b9c6a0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree that trying to completely unify low-level platforms is usually a mess. That said, I also don’t think accessing platform specific behaviour needs to involve completely throwing away the nice abstractions in Foundation. Wherever possible, we should provide platform-specific extensions to the types in Foundation. For instance, we could expose methods/inits that operate in terms of file descriptors on unix-y systems, and handle_t on windows.<br></p><p>But I also think there should be some opt-in to doing this, so that Foundation users can be confident they’re writing portable software by default. I don’t think imports should be the mechanism for this because this necessarily forces awkward divisions. I’m cautiously optimistic the feature flag system we need to build out for language evolution purposes will provide a good fit here. Opting into platform-specific behaviour is fairly similar to opting into experimental APIs. <br></p><p>(Note: I haven’t actually used Foundation much, so this may be inconsistent with its overarching design)<br></p><p>&gt; On Nov 10, 2016, at 10:48 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;     grep -R &quot;import Glibc&quot; ~/Code --include &quot;*.swift&quot; | wc -l<br>&gt;     297<br>&gt; <br>&gt; As someone who might be characterized as suffering from the problem this proposal purports to solve, I am not convinced.<br>&gt; <br>&gt; The primary problem here is that &quot;libc&quot; is a misnomer.  Did you mean musl, dietlibc, or glibc?  Did you mean &quot;whatever libc my distro likes?&quot;  Swift in practice only supports one per platform, but that is a bug not a feature, and that bug should not be standardized.  We could try to invent some syntax to specify one but now we are back with the current system again.<br>&gt; <br>&gt; The other problem is that in all my usages, &quot;import Glibc&quot; is not a real problem I face.  The real problems are that &quot;the libcs plural&quot; are *just different*.  Darwin has timeval64, glibc does not, and you&#39;d better check your arch and pick the right one, only on one platform.  SO_REUSEADDR has one type in Brand X and another type in Brand Y.  Don&#39;t even get me *started* on poll, EREs, or half a dozen other behavioral variations.  <br>&gt; <br>&gt; Taking two different libraries and pretending they are the same is not the solution, it&#39;s the disease.  The way out of this swamp for most developers is to use a real Swift library, the same damn Swift library, on all platforms (sadly, Foundation today does not meet this requirement).  The way out of this swamp for crazy people like me who must write to the metal is to actually write to the metal, to the particular libc being targeted, not to a hypothetical platonic ideal libc which does not exist.  <br>&gt; <br>&gt; I realize that four lines at the top of my files is a *visible* annoyance, but fixing it just promotes it to an invisible one. <br>&gt; <br>&gt; Drew<br>&gt; <br>&gt; --<br>&gt;   Drew Crawford<br>&gt;   drew at sealedabstract.com<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Nov 9, 2016, at 12:58 PM, Alex Blewitt via swift-evolution wrote:<br>&gt;&gt; Although out of scope for phase 1, something that keeps cropping up in a variety of Linux/Darwin Swift scripts is the conditional inclusion of Darwin or GlibC per platform. The last point was an observation that creating a &#39;nice&#39; wrapper for LibC or a cleaned up POSIX API is a non-goal:<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; I think it makes sense to have a cross platform “libc” which is an alias for darwin, glibc, or whatever, and just leave it at that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other proposals for a “POSIX” module have gotten bogged down because inevitably the idea comes up to make the resultant API nicer in various ways: rename creat, handle errno more nicely, make use of multiple return values, … etc.  The problem with this approach is that we don’t *want* people using these layer of APIs, we want higher level Foundation-like APIs to be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we should formally decide that a “nice” wrapper for libc is a non-goal.  There is too much that doesn’t make sense to wrap at this level - the only Swift code that should be using this is the implementation of higher level API, and such extremely narrow cases that we can live with them having to handle the problems of dealing with the raw APIs directly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I have created a draft for a proposal to create such a module. Comments are welcome.<br>&gt;&gt; <br>&gt;&gt; Alex<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; # Libc module for Swift<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](NNNN-filename.md)<br>&gt;&gt; * Authors: [Alex Blewitt](https://github.com/alblue &lt;https://github.com/alblue&gt;)<br>&gt;&gt; * Review Manager: TBD<br>&gt;&gt; * Status: **Under discussion**<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When running on Darwin, the base module is called `Darwin`. When running<br>&gt;&gt; on Linux or other operating systems, it&#39;s called `GlibC`. <br>&gt;&gt; <br>&gt;&gt; This repeatedly leads to code such as:<br>&gt;&gt; <br>&gt;&gt;     ````<br>&gt;&gt;     #if os(Linux)<br>&gt;&gt;       import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; As the set of operating systems evolve, one of these conditional imports<br>&gt;&gt; needs to be updated. Instead of repeating this, make it available via a<br>&gt;&gt; standard `Libc` module in the base Swift library.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; The [set of platforms](https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36 &lt;https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36&gt;)<br>&gt;&gt; that Swift currently runs on can be divided into two; Darwin and XNU based systems<br>&gt;&gt; (macOS, iOS, watchOS, tvOS), Windows, and Unix based systems<br>&gt;&gt; (Linux, FreeBSD, Android, PS4). <br>&gt;&gt; <br>&gt;&gt; The base module on Darwin is called `Darwin`, while on Linux and<br>&gt;&gt; other Unix systems the base module is called `Glibc`. The base<br>&gt;&gt; module is typically conditionally included when working at a lower layer<br>&gt;&gt; than Foundation (which has the same detail involved in importing the<br>&gt;&gt; base module).<br>&gt;&gt; <br>&gt;&gt; As a result, conditionally importing the right version typically uses<br>&gt;&gt; a conditional test based on the operating system, and the same code is<br>&gt;&gt; seen in a number of different modules, both internal to Swift and external:<br>&gt;&gt; <br>&gt;&gt; * [Test for mmap in stdlib](https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9 &lt;https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9&gt;)<br>&gt;&gt; * [Validation test for PassIfChildCrashedDuringTestExecution](https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9 &lt;https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9&gt;)<br>&gt;&gt; * [Kitura&#39;s Socket definitions](https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25 &lt;https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25&gt;)<br>&gt;&gt; * [Vapor&#39;s HTTP Server](https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5 &lt;https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5&gt;)<br>&gt;&gt; <br>&gt;&gt; Some have already created a `Libc` module that effectively does what this<br>&gt;&gt; proposal suggests, such as [Vapor&#39;s Core Libc](https://github.com/vapor/core/blob/master/Sources/libc/libc.swift &lt;https://github.com/vapor/core/blob/master/Sources/libc/libc.swift&gt;)<br>&gt;&gt; <br>&gt;&gt;     ```<br>&gt;&gt;     #if os(Linux)<br>&gt;&gt;       @_exported import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       @_exported import Darwin.C<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; Each of these examples has subtly different behaviour; for example,<br>&gt;&gt; whether or not the os tests only include Linux (and then fail over to<br>&gt;&gt; Darwin), or whether they contain other Unices such as FreeBSD and Android.<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution is to formalise these patterns in the base Swift library<br>&gt;&gt; and present a `Libc` module that conditionally imports `Glibc` or `Darwin`<br>&gt;&gt; based on the correct platform. Additional operating systems can be added<br>&gt;&gt; and kept up to date with the list of supported operating system conditionals<br>&gt;&gt; and including a failure message when an unknown operating system is detected.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; This will add a `Libc` module for the standard library that re-exports<br>&gt;&gt; the correct import depending on the operating system:<br>&gt;&gt; <br>&gt;&gt;     ```<br>&gt;&gt;     #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>&gt;&gt;       @_exported import Darwin<br>&gt;&gt;     #elseif os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;&gt;       @_exported import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       fatalError(&quot;Libc not supported on operating system&quot;)<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; As new operating systems are added or become supported (such as Windows)<br>&gt;&gt; the standard imports can be added appropriately to this module.<br>&gt;&gt; <br>&gt;&gt; ## Source compatibility<br>&gt;&gt; <br>&gt;&gt; There is no impact to source compatibility, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; However it improves source compatibility going forwards, since as new<br>&gt;&gt; operating systems are added this file will be updated, instead of the change<br>&gt;&gt; having to be made in multiple open-source projects.<br>&gt;&gt; <br>&gt;&gt; ## Effect on ABI stability<br>&gt;&gt; <br>&gt;&gt; There is no impact to ABI compatibility, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; <br>&gt;&gt; ## Effect on API resilience<br>&gt;&gt; <br>&gt;&gt; There is no impact to ABI resilience, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The first alternative is to do nothing. Existing Swift projects already<br>&gt;&gt; conditionally import these modules, or import a higher-level module (such<br>&gt;&gt; as `Foundation`) that performs the conditional import.<br>&gt;&gt; <br>&gt;&gt; The second alternative is to export sub-modules of the modules. Clang<br>&gt;&gt; permits imports of sub-modules, so it could be possible to import only<br>&gt;&gt; `Darwin.POSIX` and `GlibC.POSIX`. However, in Swift, importing a sub-module<br>&gt;&gt; makes the whole module available anyway, so the difference between importing<br>&gt;&gt; a whole module versus a submodule is irrelevant.<br>&gt;&gt; <br>&gt;&gt; The third alternative is to explore creating standard functions (in Swift)<br>&gt;&gt; corresponding to POSIX functionality, but where the format of the return<br>&gt;&gt; results are known. This would require a per-operating system binding to<br>&gt;&gt; expose operating-system details such as the byte ordering of structures<br>&gt;&gt; as used in the various `getaddrinfo` calls. These may evolve out of future<br>&gt;&gt; evolution proposals and this does not conflict with those goals at this<br>&gt;&gt; stage. There are additional clean-ups that this could address, such as the<br>&gt;&gt; use of the (thread-local) `errno` which may not be reliably read from within<br>&gt;&gt; Swift. However, the (swift-evolution thread)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html&gt;]<br>&gt;&gt; calls this &quot;the perfect being the enemy of the good&quot;. Instead of trying to<br>&gt;&gt; solve all of these problems, they should be handled by subsequent<br>&gt;&gt; proposals (such as (Johannes&#39; proposal)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html&gt;]<br>&gt;&gt; regarding errno handling sent to swift-evolution previously).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/7d26f705/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>November 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 11 Nov 2016, at 03:48, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt;     grep -R &quot;import Glibc&quot; ~/Code --include &quot;*.swift&quot; | wc -l<br>&gt;     297<br>&gt; <br>&gt; As someone who might be characterized as suffering from the problem this proposal purports to solve, I am not convinced.<br>&gt; <br>&gt; The primary problem here is that &quot;libc&quot; is a misnomer.  Did you mean musl, dietlibc, or glibc?  Did you mean &quot;whatever libc my distro likes?&quot;  Swift in practice only supports one per platform, but that is a bug not a feature, and that bug should not be standardized.  We could try to invent some syntax to specify one but now we are back with the current system again.<br></p><p>We&#39;re at the current system to start off with, though. When you do &quot;import Darwin&quot; or &quot;import GlibC&quot; you&#39;re getting whatever the platform has, regardless of what you call it. You could call it something else, like &quot;Platform&quot; or &quot;Base&quot; but it doesn&#39;t change the suggestion itself.<br></p><p>&gt; The other problem is that in all my usages, &quot;import Glibc&quot; is not a real problem I face.  The real problems are that &quot;the libcs plural&quot; are *just different*.  Darwin has timeval64, glibc does not, and you&#39;d better check your arch and pick the right one, only on one platform.  SO_REUSEADDR has one type in Brand X and another type in Brand Y.  Don&#39;t even get me *started* on poll, EREs, or half a dozen other behavioral variations.  <br></p><p>Yes, these are issues. Some of them will be worked out with the swift server workgroup, or at least standardising Socket as a type which abstracts the platform away. But we&#39;re at that position at the moment, whether or not there&#39;s a standard module to represent Darwin/Glibc.<br></p><p>&gt; Taking two different libraries and pretending they are the same is not the solution, it&#39;s the disease.  The way out of this swamp for most developers is to use a real Swift library, the same damn Swift library, on all platforms (sadly, Foundation today does not meet this requirement).  The way out of this swamp for crazy people like me who must write to the metal is to actually write to the metal, to the particular libc being targeted, not to a hypothetical platonic ideal libc which does not exist.  <br>&gt; <br>&gt; I realize that four lines at the top of my files is a *visible* annoyance, but fixing it just promotes it to an invisible one. <br></p><p>Not necessarily, it can be a starting point to fix some of the other problems. In any case, the four lines at the top of your files are almost certainly inconsistent on other platforms; for example, do you test for freebsd? Or ps4?<br></p><p>https://github.com/drewcrawford/Caroline/blob/26cd0d71e57a62fac6258e4e13dfd6849a1945c6/caroline-static-tool/FileUtils.swift &lt;https://github.com/drewcrawford/Caroline/blob/26cd0d71e57a62fac6258e4e13dfd6849a1945c6/caroline-static-tool/FileUtils.swift&gt;<br></p><p><br>#if os(OSX)<br>import Darwin<br>#elseif os(Linux)<br>import Glibc<br>#endif<br></p><p>So your test framework doesn&#39;t work on FreeBSD by default. Yet they&#39;ve still got the same &#39;write&#39; method. It also doesn&#39;t seem to support some of the other platforms that might be desirable in a test framework, such as iOS, watchOS or tvOS. You&#39;ll just get silent errors on those when it&#39;s used on those platforms. And as new platforms get added, your code will slowly drift further away from supporting everything to supporting a few known values.<br></p><p>Now granted, some of these may have yet more incompatible versions for &#39;write&#39; which needs handling specifically. That&#39;s bad, and it should be something that can be worked on. But most of the other functions (like &#39;close&#39;) don&#39;t need handling specifically. Or, as used in https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift &lt;https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift&gt; to just get access to the exit() function, which is the same across all platforms.<br></p><p>Other proposals - such as Johannes&#39; treatment of how to handle errno - will help work around these problems. Perhaps we end up with a generic write function that wraps the platform specific one to abstract that away as well, which reduces these issues one by one.<br></p><p>Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/b067dfee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>November 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for using specific examples, as they are illustrative.<br></p><p>Or, as used in https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift to just get access to the exit() function, which is the same across all platforms.<br></p><p>exit is an interesting case.  Believe it or not, it is *not* portable, as used here.  The C standard defines two constants for its parameter: EXIT_SUCCESS (defined to be zero) and EXIT_FAILURE (undefined).  You can pass other values (trivia time: only values less than 0377, because the high bits of this integer are reserved on some platforms), but the &quot;fail-iarity&quot; or &quot;successiness&quot; of values other than the defined two are not specified and may take on different meanings on different platforms.  C programmers commonly pick a nonzero value to indicate failure (as I did here) – sometimes multiple distinct values to indicate different kinds of failure – but this is actually non-portable.<br></p><p>The reason I am being pedantic here is because it demonstrates a broader point: people do not actually write portable code; they target either their current platform or some vague amalgamation of  2-3 platforms in their immediate vicinity.  All the platforms I cared about do something sane with exit(1) so it&#39;s &quot;portable enough&quot;.  But &quot;portable enough&quot; isn&#39;t portable.<br></p><p> In any case, the four lines at the top of your files are almost certainly inconsistent on other platforms; for example, do you test for freebsd? Or ps4?<br></p><p>This is a feature, not a bug.  We *like* compiler errors because they give us early warning we got something wrong.<br></p><p>I *want* the compiler to stop me when compiling this for OpenVMS.  When I wrote this code, I had only Darwin/Glibc in mind, and on that basis, I used exit(1). The working assumption is now violated, and the compiler is correct to remind me about it.  I don&#39;t know, and would need to go find out, what kind of exit is sensible for VMS.  Or to move to EXIT_FAILURE like a language lawyer.<br></p><p>But the compile error itself is not a silly annoyance that I would like to &quot;solve&quot; by blindly putting more libcs in the list etc. This is a guard rail where I indicated the platforms I had in mind when writing this code, and when I wake up one morning in a drunken stupor and try to do something else, we fire a warning shot.<br></p><p>It&#39;s a safety feature, like force-unwrap.  If you&#39;re sure it won&#39;t blow up, you can put an exclamation mark in there and shut up the compiler.  If you&#39;re sure it&#39;s portable to bsd, add bsd to the list and shut up the compiler.  But the resolution to this compile error is not to import more libcs.  The resolution is to *consider carefully if that is a good idea*.<br></p><p>The assumption embedded in the proposal is that of course we want the program to compile, and the question is merely to calculate the set of import statements that will achieve compilation, for which the proposal offers an algorithm.  My argument is that actually we do not want the program to compile unless we are reasonably sure it will work as intended, and the question is what syntax allows the author to reasonably encode their assumptions so that when they are violated we provide a moment of quiet reflection to consider e.g. if exit(1) is sensible on VMS.<br></p><p>The existing system is imperfect (and very ugly) but does a surprisingly good job in this dimension.<br></p><p> It also doesn&#39;t seem to support some of the other platforms that might be desirable in a test framework, such as iOS, watchOS or tvOS.<br>I do support iOS (not in this component – it&#39;s a command-line tool, so the omission of iOS in this file is deliberate, and the compatibility issues go far beyond exit).  I don&#39;t yet support watchOS or tvOS because I don&#39;t have CI for those platforms yet and in my view supporting a platform is more than adjusting an import statement and wondering if it will compile.<br></p><p>So in summary:<br></p><p>1.  I would not use this feature in the cited examples<br></p><p>2.  I would prefer it if others did not use this feature.  When I see &quot;import Glibc&quot; at the top of a file I know what I am signing up for.  When I see &quot;import libc&quot; for all I know the developer used Windows.<br></p><p>Finally, this is more of a detail, but I still do not understand how this would be implemented for a Linux platform without Glibc, such as Arch.  The current proposal has <br></p><p><br></p><p>  #if os(Linux)<br></p><p>      @_exported import Glibc<br></p><p>which is obviously not going to compile on Arch.  So if the goal is to have syntax that is portable the current proposal does not do it.<br></p><p>I do believe there is some room for a more moderate reform on the libc problem.  For example instead of the traditional ifdefs, we could have<br></p><p>import? Glibc<br></p><p>import? Darwin<br></p><p><br>Where the &quot;import?&quot; keyword imports the module if available or otherwise has no effect.<br></p><p>This preserves the majority of desireable properties discussed above (clearly indicates the intended libcs, provides guard rails similar to the present regime) while being significantly shorter than the present regime.  It also contemplates problems that the current proposal does not, such as Arch (we can continue to list libcs until we find one, and Swift already has rules for resolving multiple imports), and it is more broadly applicable to other kinds of import problems than libc imports narrowly.<br></p><p>One problem with the import? idea is that it glosses e.g. watchOS/tvOS/macOS as &quot;Darwin&quot; when that is not strictly true (posix_spawn for example) but it&#39;s at least a far more sensible unification than VMS/Darwin.  We do have a clear path to check Darwin portability in the compiler (e.g. require @availability(macOS) for posix_spawn) while no similar path exists to check Darwin/VMS portability.  So I think doing something moderate is at least plausible.<br></p><p>Still, it may be a solution in search of a problem.  If you are writing against something as badly fractured as POSIX, it should feel like it, and even a small unification may be a step too far.<br></p><p>Of course, the real solution to writing portable code is to target a portable standard, such as Foundation or some alternative high-level library.<br>On November 15, 2016 at 10:27:14 AM, Alex Blewitt (alblue at apple.com) wrote:<br></p><p><br>On 11 Nov 2016, at 03:48, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br></p><p>    grep -R &quot;import Glibc&quot; ~/Code --include &quot;*.swift&quot; | wc -l<br>    297<br></p><p>As someone who might be characterized as suffering from the problem this proposal purports to solve, I am not convinced.<br></p><p>The primary problem here is that &quot;libc&quot; is a misnomer.  Did you mean musl, dietlibc, or glibc?  Did you mean &quot;whatever libc my distro likes?&quot;  Swift in practice only supports one per platform, but that is a bug not a feature, and that bug should not be standardized.  We could try to invent some syntax to specify one but now we are back with the current system again.<br></p><p>We&#39;re at the current system to start off with, though. When you do &quot;import Darwin&quot; or &quot;import GlibC&quot; you&#39;re getting whatever the platform has, regardless of what you call it. You could call it something else, like &quot;Platform&quot; or &quot;Base&quot; but it doesn&#39;t change the suggestion itself.<br></p><p>The other problem is that in all my usages, &quot;import Glibc&quot; is not a real problem I face.  The real problems are that &quot;the libcs plural&quot; are *just different*.  Darwin has timeval64, glibc does not, and you&#39;d better check your arch and pick the right one, only on one platform.  SO_REUSEADDR has one type in Brand X and another type in Brand Y.  Don&#39;t even get me *started* on poll, EREs, or half a dozen other behavioral variations.  <br></p><p>Yes, these are issues. Some of them will be worked out with the swift server workgroup, or at least standardising Socket as a type which abstracts the platform away. But we&#39;re at that position at the moment, whether or not there&#39;s a standard module to represent Darwin/Glibc.<br></p><p>Taking two different libraries and pretending they are the same is not the solution, it&#39;s the disease.  The way out of this swamp for most developers is to use a real Swift library, the same damn Swift library, on all platforms (sadly, Foundation today does not meet this requirement).  The way out of this swamp for crazy people like me who must write to the metal is to actually write to the metal, to the particular libc being targeted, not to a hypothetical platonic ideal libc which does not exist.  <br></p><p>I realize that four lines at the top of my files is a *visible* annoyance, but fixing it just promotes it to an invisible one. <br></p><p>Not necessarily, it can be a starting point to fix some of the other problems. In any case, the four lines at the top of your files are almost certainly inconsistent on other platforms; for example, do you test for freebsd? Or ps4?<br></p><p>https://github.com/drewcrawford/Caroline/blob/26cd0d71e57a62fac6258e4e13dfd6849a1945c6/caroline-static-tool/FileUtils.swift<br></p><p><br></p><p><br>#if<br>os(OSX)<br></p><p>import<br>Darwin<br></p><p>#elseif<br>os(Linux)<br></p><p>import<br>Glibc<br></p><p>#endif<br></p><p>So your test framework doesn&#39;t work on FreeBSD by default. Yet they&#39;ve still got the same &#39;write&#39; method. It also doesn&#39;t seem to support some of the other platforms that might be desirable in a test framework, such as iOS, watchOS or tvOS. You&#39;ll just get silent errors on those when it&#39;s used on those platforms. And as new platforms get added, your code will slowly drift further away from supporting everything to supporting a few known values.<br></p><p>Now granted, some of these may have yet more incompatible versions for &#39;write&#39; which needs handling specifically. That&#39;s bad, and it should be something that can be worked on. But most of the other functions (like &#39;close&#39;) don&#39;t need handling specifically. Or, as used in https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift to just get access to the exit() function, which is the same across all platforms.<br></p><p>Other proposals - such as Johannes&#39; treatment of how to handle errno - will help work around these problems. Perhaps we end up with a generic write function that wraps the platform specific one to abstract that away as well, which reduces these issues one by one.<br></p><p>Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/b753386f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>November 15, 2016 at 08:00:00pm</p></header><div class="content"><p>OpenVMS isn&#39;t in the supported list of Swift packages, so comparing it to that is pointless.<br></p><p>https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/lib/Basic/LangOptions.cpp#L26-L36<br></p><p><br>static const StringRef SupportedConditionalCompilationOSs[] = {<br>  &quot;OSX&quot;,<br>  &quot;tvOS&quot;,<br>  &quot;watchOS&quot;,<br>  &quot;iOS&quot;,<br>  &quot;Linux&quot;,<br>  &quot;FreeBSD&quot;,<br>  &quot;Windows&quot;,<br>  &quot;Android&quot;,<br>  &quot;PS4&quot;,<br>};<br></p><p>Look, this code is already battle tested in Swift. It&#39;s even used in the test case for the interpreter:<br></p><p>https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/test/Interpreter/SDK/libc.swift#L10-L14 &lt;https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/test/Interpreter/SDK/libc.swift#L10-L14&gt;<br></p><p><br></p><p>#if os(OSX) || os(iOS) || os(watchOS) || os(tvOS)<br>  import Darwin<br>#elseif os(Linux) || os(FreeBSD) || os(PS4) || os(Android)<br>  import Glibc<br>#endif<br></p><p>Alex<br></p><p>&gt; On 15 Nov 2016, at 19:51, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; Thanks for using specific examples, as they are illustrative.<br>&gt; <br>&gt;&gt; Or, as used in https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift &lt;https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift&gt; to just get access to the exit() function, which is the same across all platforms.<br>&gt; <br>&gt; <br>&gt; exit is an interesting case.  Believe it or not, it is *not* portable, as used here.  The C standard defines two constants for its parameter: EXIT_SUCCESS (defined to be zero) and EXIT_FAILURE (undefined).  You can pass other values (trivia time: only values less than 0377, because the high bits of this integer are reserved on some platforms), but the &quot;fail-iarity&quot; or &quot;successiness&quot; of values other than the defined two are not specified and may take on different meanings on different platforms.  C programmers commonly pick a nonzero value to indicate failure (as I did here) – sometimes multiple distinct values to indicate different kinds of failure – but this is actually non-portable.<br>&gt; <br>&gt; The reason I am being pedantic here is because it demonstrates a broader point: people do not actually write portable code; they target either their current platform or some vague amalgamation of  2-3 platforms in their immediate vicinity.  All the platforms I cared about do something sane with exit(1) so it&#39;s &quot;portable enough&quot;.  But &quot;portable enough&quot; isn&#39;t portable.<br>&gt; <br>&gt;&gt;  In any case, the four lines at the top of your files are almost certainly inconsistent on other platforms; for example, do you test for freebsd? Or ps4?<br>&gt; <br>&gt; This is a feature, not a bug.  We *like* compiler errors because they give us early warning we got something wrong.<br>&gt; <br>&gt; I *want* the compiler to stop me when compiling this for OpenVMS.  When I wrote this code, I had only Darwin/Glibc in mind, and on that basis, I used exit(1). The working assumption is now violated, and the compiler is correct to remind me about it.  I don&#39;t know, and would need to go find out, what kind of exit is sensible for VMS.  Or to move to EXIT_FAILURE like a language lawyer.<br>&gt; <br>&gt; But the compile error itself is not a silly annoyance that I would like to &quot;solve&quot; by blindly putting more libcs in the list etc. This is a guard rail where I indicated the platforms I had in mind when writing this code, and when I wake up one morning in a drunken stupor and try to do something else, we fire a warning shot.<br>&gt; <br>&gt; It&#39;s a safety feature, like force-unwrap.  If you&#39;re sure it won&#39;t blow up, you can put an exclamation mark in there and shut up the compiler.  If you&#39;re sure it&#39;s portable to bsd, add bsd to the list and shut up the compiler.  But the resolution to this compile error is not to import more libcs.  The resolution is to *consider carefully if that is a good idea*.<br>&gt; <br>&gt; The assumption embedded in the proposal is that of course we want the program to compile, and the question is merely to calculate the set of import statements that will achieve compilation, for which the proposal offers an algorithm.  My argument is that actually we do not want the program to compile unless we are reasonably sure it will work as intended, and the question is what syntax allows the author to reasonably encode their assumptions so that when they are violated we provide a moment of quiet reflection to consider e.g. if exit(1) is sensible on VMS.<br>&gt; <br>&gt; The existing system is imperfect (and very ugly) but does a surprisingly good job in this dimension.<br>&gt; <br>&gt;&gt;  It also doesn&#39;t seem to support some of the other platforms that might be desirable in a test framework, such as iOS, watchOS or tvOS.<br>&gt; <br>&gt; I do support iOS (not in this component – it&#39;s a command-line tool, so the omission of iOS in this file is deliberate, and the compatibility issues go far beyond exit).  I don&#39;t yet support watchOS or tvOS because I don&#39;t have CI for those platforms yet and in my view supporting a platform is more than adjusting an import statement and wondering if it will compile.<br>&gt; <br>&gt; So in summary:<br>&gt; <br>&gt; 1.  I would not use this feature in the cited examples<br>&gt; <br>&gt; 2.  I would prefer it if others did not use this feature.  When I see &quot;import Glibc&quot; at the top of a file I know what I am signing up for.  When I see &quot;import libc&quot; for all I know the developer used Windows.<br>&gt; <br>&gt; Finally, this is more of a detail, but I still do not understand how this would be implemented for a Linux platform without Glibc, such as Arch.  The current proposal has <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;   #if os(Linux)<br>&gt;&gt; <br>&gt;&gt;       @_exported import Glibc<br>&gt;&gt; <br>&gt; <br>&gt; which is obviously not going to compile on Arch.  So if the goal is to have syntax that is portable the current proposal does not do it.<br>&gt; <br>&gt; I do believe there is some room for a more moderate reform on the libc problem.  For example instead of the traditional ifdefs, we could have<br>&gt; <br>&gt;&gt; import? Glibc<br>&gt;&gt; <br>&gt;&gt; import? Darwin<br>&gt;&gt; <br>&gt; <br>&gt; Where the &quot;import?&quot; keyword imports the module if available or otherwise has no effect.<br>&gt; <br>&gt; This preserves the majority of desireable properties discussed above (clearly indicates the intended libcs, provides guard rails similar to the present regime) while being significantly shorter than the present regime.  It also contemplates problems that the current proposal does not, such as Arch (we can continue to list libcs until we find one, and Swift already has rules for resolving multiple imports), and it is more broadly applicable to other kinds of import problems than libc imports narrowly.<br>&gt; <br>&gt; One problem with the import? idea is that it glosses e.g. watchOS/tvOS/macOS as &quot;Darwin&quot; when that is not strictly true (posix_spawn for example) but it&#39;s at least a far more sensible unification than VMS/Darwin.  We do have a clear path to check Darwin portability in the compiler (e.g. require @availability(macOS) for posix_spawn) while no similar path exists to check Darwin/VMS portability.  So I think doing something moderate is at least plausible.<br>&gt; <br>&gt; Still, it may be a solution in search of a problem.  If you are writing against something as badly fractured as POSIX, it should feel like it, and even a small unification may be a step too far.<br>&gt; <br>&gt; Of course, the real solution to writing portable code is to target a portable standard, such as Foundation or some alternative high-level library.<br>&gt; On November 15, 2016 at 10:27:14 AM, Alex Blewitt (alblue at apple.com &lt;mailto:alblue at apple.com&gt;) wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Nov 2016, at 03:48, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     grep -R &quot;import Glibc&quot; ~/Code --include &quot;*.swift&quot; | wc -l<br>&gt;&gt;&gt;     297<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As someone who might be characterized as suffering from the problem this proposal purports to solve, I am not convinced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary problem here is that &quot;libc&quot; is a misnomer.  Did you mean musl, dietlibc, or glibc?  Did you mean &quot;whatever libc my distro likes?&quot;  Swift in practice only supports one per platform, but that is a bug not a feature, and that bug should not be standardized.  We could try to invent some syntax to specify one but now we are back with the current system again.<br>&gt;&gt; <br>&gt;&gt; We&#39;re at the current system to start off with, though. When you do &quot;import Darwin&quot; or &quot;import GlibC&quot; you&#39;re getting whatever the platform has, regardless of what you call it. You could call it something else, like &quot;Platform&quot; or &quot;Base&quot; but it doesn&#39;t change the suggestion itself.<br>&gt;&gt; <br>&gt;&gt;&gt; The other problem is that in all my usages, &quot;import Glibc&quot; is not a real problem I face.  The real problems are that &quot;the libcs plural&quot; are *just different*.  Darwin has timeval64, glibc does not, and you&#39;d better check your arch and pick the right one, only on one platform.  SO_REUSEADDR has one type in Brand X and another type in Brand Y.  Don&#39;t even get me *started* on poll, EREs, or half a dozen other behavioral variations.  <br>&gt;&gt; <br>&gt;&gt; Yes, these are issues. Some of them will be worked out with the swift server workgroup, or at least standardising Socket as a type which abstracts the platform away. But we&#39;re at that position at the moment, whether or not there&#39;s a standard module to represent Darwin/Glibc.<br>&gt;&gt; <br>&gt;&gt;&gt; Taking two different libraries and pretending they are the same is not the solution, it&#39;s the disease.  The way out of this swamp for most developers is to use a real Swift library, the same damn Swift library, on all platforms (sadly, Foundation today does not meet this requirement).  The way out of this swamp for crazy people like me who must write to the metal is to actually write to the metal, to the particular libc being targeted, not to a hypothetical platonic ideal libc which does not exist.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I realize that four lines at the top of my files is a *visible* annoyance, but fixing it just promotes it to an invisible one. <br>&gt;&gt; <br>&gt;&gt; Not necessarily, it can be a starting point to fix some of the other problems. In any case, the four lines at the top of your files are almost certainly inconsistent on other platforms; for example, do you test for freebsd? Or ps4?<br>&gt;&gt; <br>&gt;&gt; https://github.com/drewcrawford/Caroline/blob/26cd0d71e57a62fac6258e4e13dfd6849a1945c6/caroline-static-tool/FileUtils.swift &lt;https://github.com/drewcrawford/Caroline/blob/26cd0d71e57a62fac6258e4e13dfd6849a1945c6/caroline-static-tool/FileUtils.swift&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #if<br>&gt;&gt; os(OSX)<br>&gt;&gt; <br>&gt;&gt; import<br>&gt;&gt; Darwin<br>&gt;&gt; <br>&gt;&gt; #elseif<br>&gt;&gt; os(Linux)<br>&gt;&gt; <br>&gt;&gt; import<br>&gt;&gt; Glibc<br>&gt;&gt; <br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; So your test framework doesn&#39;t work on FreeBSD by default. Yet they&#39;ve still got the same &#39;write&#39; method. It also doesn&#39;t seem to support some of the other platforms that might be desirable in a test framework, such as iOS, watchOS or tvOS. You&#39;ll just get silent errors on those when it&#39;s used on those platforms. And as new platforms get added, your code will slowly drift further away from supporting everything to supporting a few known values.<br>&gt;&gt; <br>&gt;&gt; Now granted, some of these may have yet more incompatible versions for &#39;write&#39; which needs handling specifically. That&#39;s bad, and it should be something that can be worked on. But most of the other functions (like &#39;close&#39;) don&#39;t need handling specifically. Or, as used in https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift &lt;https://github.com/drewcrawford/Caroline/blob/edd8aefef44717ecfa03c629100baf095fab983a/caroline-static-tool/main.swift&gt; to just get access to the exit() function, which is the same across all platforms.<br>&gt;&gt; <br>&gt;&gt; Other proposals - such as Johannes&#39; treatment of how to handle errno - will help work around these problems. Perhaps we end up with a generic write function that wraps the platform specific one to abstract that away as well, which reduces these issues one by one.<br>&gt;&gt; <br>&gt;&gt; Alex<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/46667a82/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
