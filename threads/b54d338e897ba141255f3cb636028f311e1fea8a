<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br></p><p># Factory Initializers<br></p><p>The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br></p><p>Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br></p><p>class AbstractBase {<br>    public factory init(type: InformationToSwitchOn) {<br>        return ConcreteImplementation(type)<br>    }<br>}<br></p><p>class ConcreteImplementation : AbstractBase {<br></p><p>}<br></p><p>Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br></p><p>## Class Cluster/Abstract Classes<br>This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br></p><p>## Protocol Initializers<br>Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br></p><p>## Initializing Storyboard-backed View Controller<br>This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br></p><p>Here are some comments from the previous thread that I believe are still relevant:<br></p><p><br>&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br></p><p><br>&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; <br>&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; <br></p><p><br>I’d love to hear everyone’s thoughts on this!<br></p><p>Best,<br>Riley Testut<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; <br>&gt; # Factory Initializers<br>&gt; <br>&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; <br>&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; <br>&gt; class AbstractBase {<br>&gt;    public factory init(type: InformationToSwitchOn) {<br>&gt;        return ConcreteImplementation(type)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; <br>&gt; ## Class Cluster/Abstract Classes<br>&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; <br>&gt; ## Protocol Initializers<br>&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; <br>&gt; ## Initializing Storyboard-backed View Controller<br>&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; <br>&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt; <br>&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts on this!<br></p><p>+1; this is a known-needed, missing feature.<br></p><p>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; <br>&gt; # Factory Initializers<br>&gt; <br>&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; <br>&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; <br>&gt; class AbstractBase {<br>&gt;    public factory init(type: InformationToSwitchOn) {<br>&gt;        return ConcreteImplementation(type)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br></p><p>I’m confused, isn’t this already handled by “convenience” initializers?  <br></p><p>What we lack now is the ability to use the AbstractBase(42) syntax the produce something with a static type of ConcreteImplementation.  This is something expressible in Objective-C, and something that Swift can currently import into Objective-C, but that you can’t write directly in Swift code right now.<br></p><p>The approach that I would suggest is a simple extension of the grammar, to allow &quot;-&gt; T” on a convenience initializer.  In this case, you could write:<br></p><p><br>class AbstractBase {<br>   convenience init(type: InformationToSwitchOn) -&gt; ConcreteImplementation {<br>       return ConcreteImplementation(type)<br>   }<br></p><p>and then &quot;AbstractBase(stuff)” would produce a value with the static type of ConcreteImplementation.  This syntax is already produced by the AST printer for imported ObjC stuff, so we have much of the mechanics for this already in the compiler.  It would be great to see someone push this forward!<br></p><p>-Chris<br></p><p><br></p><p><br>&gt; <br>&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; <br>&gt; ## Class Cluster/Abstract Classes<br>&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; <br>&gt; ## Protocol Initializers<br>&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; <br>&gt; ## Initializing Storyboard-backed View Controller<br>&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; <br>&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt; <br>&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; <br>&gt; Best,<br>&gt; Riley Testut<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 17, 2015, at 6:25 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt; <br>&gt; I’m confused, isn’t this already handled by “convenience” initializers?  <br></p><p>That first part of the post is handled by the convenience initializer syntax you suggest.  Your suggestion doesn&#39;t address the idea of protocol initializers further down though.  That is very interesting as well.<br></p><p>protocol P {}<br>struct S: P {}<br>extension P {<br>  factory init(type: InformationToSwitchOn) {<br>    return S()<br>  }<br>}<br></p><p>let p = P(type: informationToSwitchOn)<br></p><p><br>&gt; <br>&gt; What we lack now is the ability to use the AbstractBase(42) syntax the produce something with a static type of ConcreteImplementation.  This is something expressible in Objective-C, and something that Swift can currently import into Objective-C, but that you can’t write directly in Swift code right now.<br>&gt; <br>&gt; The approach that I would suggest is a simple extension of the grammar, to allow &quot;-&gt; T” on a convenience initializer.  In this case, you could write:<br>&gt; <br>&gt; <br>&gt; class AbstractBase {<br>&gt;   convenience init(type: InformationToSwitchOn) -&gt; ConcreteImplementation {<br>&gt;       return ConcreteImplementationr(type)<br>&gt;   }<br>&gt; <br>&gt; and then &quot;AbstractBase(stuff)” would produce a value with the static type of ConcreteImplementation.  This syntax is already produced by the AST printer for imported ObjC stuff, so we have much of the mechanics for this already in the compiler.  It would be great to see someone push this forward!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>The reason for the additional “factory” keyword would be to differentiate it from other initializers because it actually “returned&quot; a value. For the record, I am entirely in support of modifying convenience initializers to return instances directly; I assumed (incorrectly it seems!) that the ability to return directly from an initializer was intentionally left out, for whatever reason. I agree using the convenience initializer syntax with an explicit return type would be a better approach, and would be more in-line with what you can do with initializers in Objective-C :-)<br></p><p>If this is already implemented in the compiler, I would love to certainly push this idea forward! I genuinely believe this could add great value to the language, without changing the fundamentals too much.<br></p><p>&gt; On Dec 17, 2015, at 6:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt; <br>&gt; I’m confused, isn’t this already handled by “convenience” initializers?  <br>&gt; <br>&gt; What we lack now is the ability to use the AbstractBase(42) syntax the produce something with a static type of ConcreteImplementation.  This is something expressible in Objective-C, and something that Swift can currently import into Objective-C, but that you can’t write directly in Swift code right now.<br>&gt; <br>&gt; The approach that I would suggest is a simple extension of the grammar, to allow &quot;-&gt; T” on a convenience initializer.  In this case, you could write:<br>&gt; <br>&gt; <br>&gt; class AbstractBase {<br>&gt;   convenience init(type: InformationToSwitchOn) -&gt; ConcreteImplementation {<br>&gt;       return ConcreteImplementation(type)<br>&gt;   }<br>&gt; <br>&gt; and then &quot;AbstractBase(stuff)” would produce a value with the static type of ConcreteImplementation.  This syntax is already produced by the AST printer for imported ObjC stuff, so we have much of the mechanics for this already in the compiler.  It would be great to see someone push this forward!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c6d42c8d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br></p><p>-Thorsten <br></p><p>&gt; Am 18.12.2015 um 01:25 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt; <br>&gt; I’m confused, isn’t this already handled by “convenience” initializers?  <br>&gt; <br>&gt; What we lack now is the ability to use the AbstractBase(42) syntax the produce something with a static type of ConcreteImplementation.  This is something expressible in Objective-C, and something that Swift can currently import into Objective-C, but that you can’t write directly in Swift code right now.<br>&gt; <br>&gt; The approach that I would suggest is a simple extension of the grammar, to allow &quot;-&gt; T” on a convenience initializer.  In this case, you could write:<br>&gt; <br>&gt; <br>&gt; class AbstractBase {<br>&gt;   convenience init(type: InformationToSwitchOn) -&gt; ConcreteImplementation {<br>&gt;       return ConcreteImplementation(type)<br>&gt;   }<br>&gt; <br>&gt; and then &quot;AbstractBase(stuff)” would produce a value with the static type of ConcreteImplementation.  This syntax is already produced by the AST printer for imported ObjC stuff, so we have much of the mechanics for this already in the compiler.  It would be great to see someone push this forward!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 8:15 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>&gt; Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br></p><p>Got it.  If that is the case, then yes, something like a “factory init” makes sense to me.  It is unfortunate that such a thing would make the swift initializer model even MORE complex :-) but it is probably still the right way to go.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 18.12.2015 um 01:25 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Factory Initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;  public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;      return ConcreteImplementation(type)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’m confused, isn’t this already handled by “convenience” initializers?  <br>&gt;&gt; <br>&gt;&gt; What we lack now is the ability to use the AbstractBase(42) syntax the produce something with a static type of ConcreteImplementation.  This is something expressible in Objective-C, and something that Swift can currently import into Objective-C, but that you can’t write directly in Swift code right now.<br>&gt;&gt; <br>&gt;&gt; The approach that I would suggest is a simple extension of the grammar, to allow &quot;-&gt; T” on a convenience initializer.  In this case, you could write:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;  convenience init(type: InformationToSwitchOn) -&gt; ConcreteImplementation {<br>&gt;&gt;      return ConcreteImplementation(type)<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; and then &quot;AbstractBase(stuff)” would produce a value with the static type of ConcreteImplementation.  This syntax is already produced by the AST printer for imported ObjC stuff, so we have much of the mechanics for this already in the compiler.  It would be great to see someone push this forward!<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Riley Testut<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 12:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 8:15 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>&gt;&gt; Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br>&gt; <br>&gt; Got it.  If that is the case, then yes, something like a “factory init” makes sense to me.  It is unfortunate that such a thing would make the swift initializer model even MORE complex :-) but it is probably still the right way to go.<br></p><p>In the implementation model, if not the language model, convenience inits today pretty much already are factory initializers, since the ABI allows for a different `self` object to be returned as long as it&#39;s a subclass of the current type, much like a factory method. Instead of adding another wrinkle to the initializer model, we could embrace this, and allow convenience inits to reassign `self` as in ObjC.  This would also bring more consistency between struct and class initializers, since struct initializers are already able to reassign `self` as well. We have to interop with the [[T alloc] init] model for ObjC classes, so we&#39;d have to deallocate a wasted empty object if a convenience initializer for an @objc class changes self, but the ABI for pure Swift convenience initializers could be made to be callee-allocating to avoid that performance problem.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>I’m not opposed to assigning to self directly in convenience initializers (especially if there is already support for it in the ABI). My only concern would be that it feels less “natural” to do so than to simply return a value from the initializer. That being said, I think that’s a very negligible disadvantage (if even that), and if assigning to self is the easiest way to pull this off, I’m all for it.<br></p><p>However, should we keep convenience initializers as the only way to assign self directly, and required initializers keep the same behavior as they do today? And then would it make sense to disable the assignment to self in struct required initializers to keep things consistent? Don’t have a strong preference for any of these, but I do think they’re worth discussing.<br></p><p>&gt; On Dec 18, 2015, at 3:06 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 12:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 8:15 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>&gt;&gt;&gt; Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br>&gt;&gt; <br>&gt;&gt; Got it.  If that is the case, then yes, something like a “factory init” makes sense to me.  It is unfortunate that such a thing would make the swift initializer model even MORE complex :-) but it is probably still the right way to go.<br>&gt; <br>&gt; In the implementation model, if not the language model, convenience inits today pretty much already are factory initializers, since the ABI allows for a different `self` object to be returned as long as it&#39;s a subclass of the current type, much like a factory method. Instead of adding another wrinkle to the initializer model, we could embrace this, and allow convenience inits to reassign `self` as in ObjC.  This would also bring more consistency between struct and class initializers, since struct initializers are already able to reassign `self` as well. We have to interop with the [[T alloc] init] model for ObjC classes, so we&#39;d have to deallocate a wasted empty object if a convenience initializer for an @objc class changes self, but the ABI for pure Swift convenience initializers could be made to be callee-allocating to avoid that performance problem.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1b770f17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:20 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not opposed to assigning to self directly in convenience initializers (especially if there is already support for it in the ABI). My only concern would be that it feels less “natural” to do so than to simply return a value from the initializer.<br></p><p>My instinct agrees with that.  Also, reassigning self raises the question of whether an object is allocated (and partly initialized?) before the reassignment.  Even if we can answer those questions in some clear way, I’d rather not have them come up at all.<br></p><p>&gt; That being said, I think that’s a very negligible disadvantage (if even that), and if assigning to self is the easiest way to pull this off, I’m all for it.<br>&gt; <br>&gt; However, should we keep convenience initializers as the only way to assign self directly, and required initializers keep the same behavior as they do today? And then would it make sense to disable the assignment to self in struct required initializers to keep things consistent? Don’t have a strong preference for any of these, but I do think they’re worth discussing.<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 3:06 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 12:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 8:15 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>&gt;&gt;&gt;&gt; Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Got it.  If that is the case, then yes, something like a “factory init” makes sense to me.  It is unfortunate that such a thing would make the swift initializer model even MORE complex :-) but it is probably still the right way to go.<br>&gt;&gt; <br>&gt;&gt; In the implementation model, if not the language model, convenience inits today pretty much already are factory initializers, since the ABI allows for a different `self` object to be returned as long as it&#39;s a subclass of the current type, much like a factory method. Instead of adding another wrinkle to the initializer model, we could embrace this, and allow convenience inits to reassign `self` as in ObjC.  This would also bring more consistency between struct and class initializers, since struct initializers are already able to reassign `self` as well. We have to interop with the [[T alloc] init] model for ObjC classes, so we&#39;d have to deallocate a wasted empty object if a convenience initializer for an @objc class changes self, but the ABI for pure Swift convenience initializers could be made to be callee-allocating to avoid that performance problem.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/d904db52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 18, 2015 at 09:00:00pm</p></header><div class="content"><p>I guess a better question here is, is it worth modifying the existing compiler/ABI behavior to explicitly allow returning instances from convenience initializers? Personally, while I prefer the use of return statements (especially because they&#39;re already used to return nil from failable initializers), I know that finalizing Swift 3 is a priority, and if we can have essentially the same functionality while also taking advantage of what already is implemented, that might make a more sense for implementation.<br></p><p>Of course, I&#39;m making plenty of assumptions about the difficulty/time to implement both of these solutions. Would love to hear what the expected methodology would be to implement both of those, and if anyone has genuinely strong preferences either way.<br></p><p>&gt; On Dec 18, 2015, at 6:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 3:20 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not opposed to assigning to self directly in convenience initializers (especially if there is already support for it in the ABI). My only concern would be that it feels less “natural” to do so than to simply return a value from the initializer.<br>&gt; <br>&gt; My instinct agrees with that.  Also, reassigning self raises the question of whether an object is allocated (and partly initialized?) before the reassignment.  Even if we can answer those questions in some clear way, I’d rather not have them come up at all.<br>&gt; <br>&gt;&gt; That being said, I think that’s a very negligible disadvantage (if even that), and if assigning to self is the easiest way to pull this off, I’m all for it.<br>&gt;&gt; <br>&gt;&gt; However, should we keep convenience initializers as the only way to assign self directly, and required initializers keep the same behavior as they do today? And then would it make sense to disable the assignment to self in struct required initializers to keep things consistent? Don’t have a strong preference for any of these, but I do think they’re worth discussing.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 3:06 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 12:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 8:15 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now I&#39;m confused: I thought the idea should enable class clusters, i.e. allowing AbstractBaseClass(42) to return something with the *dynamic* type of ConcreteImplementation but still the static type of AbstractBaseClass.<br>&gt;&gt;&gt;&gt;&gt; Otherwise I would just call ConcreteImplementation(42) if I wanted something of that static type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Got it.  If that is the case, then yes, something like a “factory init” makes sense to me.  It is unfortunate that such a thing would make the swift initializer model even MORE complex :-) but it is probably still the right way to go.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the implementation model, if not the language model, convenience inits today pretty much already are factory initializers, since the ABI allows for a different `self` object to be returned as long as it&#39;s a subclass of the current type, much like a factory method. Instead of adding another wrinkle to the initializer model, we could embrace this, and allow convenience inits to reassign `self` as in ObjC.  This would also bring more consistency between struct and class initializers, since struct initializers are already able to reassign `self` as well. We have to interop with the [[T alloc] init] model for ObjC classes, so we&#39;d have to deallocate a wasted empty object if a convenience initializer for an @objc class changes self, but the ABI for pure Swift convenience initializers could be made to be callee-allocating to avoid that performance problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/7ab83940/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 1:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br></p><p>Thanks for working on this!<br></p><p>&gt; # Factory Initializers<br>&gt; <br>&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br></p><p>For the record, the Swift compiler and programming model actually already has factory initializers, but one can only get to them by writing a factory method in Objective-C that then gets imported as a factory initializer into Swift. For example:<br></p><p>	@interface ABCFoo : NSObject<br>	+(nonnull ABCFoo *)fooWithString:(nonnull NSString *)string;<br>	@end<br></p><p>comes in as a factory initializer (using your proposed syntax):<br></p><p>	factory init(string: String)<br></p><p>&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; <br>&gt; class AbstractBase {<br>&gt;    public factory init(type: InformationToSwitchOn) {<br>&gt;        return ConcreteImplementation(type)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br></p><p>FWIW, there’s a historical syntax here of<br></p><p>	public init(type: InformationToSwitchOn) -&gt; AbstractBase<br></p><p>I’m not attached to the “-&gt;” syntax at all, but there were two reasons for using it for factory initializers:<br></p><p>	1) It more strongly indicates the “function” nature of this initializer, because you’re expected to return a “self” rather than initializing the “self” you’ve been given, which is very different from all other initializers. “Factory” also says that if you know what factory initializers are, but “-&gt;” is more firmly embedded in the language semantics to mean “you should return one of these”.<br></p><p>	2) It lets you distinguish between factory initializers that return “Self” (i.e., the type used to perform the initialization) and those that return some concrete upper bound (like your example). The distinction affects inheritance of initializers and, by extension, whether the initializer can satisfy an initializer requirement in a protocol. For example, in your example above, I would expect us to reject<br></p><p>		ConcreteImplementation(type: InformationToSwiftOn())<br></p><p>	because we have named “ConcreteImplementation” but the factory initializer is only guaranteed to provide an “AbstractBase”. If instead one had:<br></p><p>		public init(type: InformationToSwiftOn) -&gt; Self { … }<br></p><p>	then <br></p><p>		ConcreteImplementation(type: InformationToSwiftOn())<br></p><p>	is well-formed and produces a ConcreteImplementation while<br></p><p>		AbstractBase(type: InformationToSwiftOn())<br></p><p>	is also well-formed and produces an AbstractBase. In other words, the factory initializer written “-&gt; Self” is guaranteed to be inherited. Whether the others are inherited is more complicated.<br></p><p>&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; <br>&gt; ## Class Cluster/Abstract Classes<br>&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br></p><p>At least some of these cases would better be addressed by protocol initializers, below, because there might be no reason at all for the OS-appopriate “subclasses” to actually share a superclass (nor should they have to be classes!).<br></p><p>&gt; <br>&gt; ## Protocol Initializers<br>&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br></p><p>Seems plausible.<br></p><p>	- Doug<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>Strong +1 on this, particularly on the part about protocol initializers. This would bring together some of the best aspects of both Objective-C class clusters and Swift protocol-oriented programming and would be a huge benefit to application developers.<br></p><p>Charles<br></p><p>&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; <br>&gt; # Factory Initializers<br>&gt; <br>&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; <br>&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; <br>&gt; class AbstractBase {<br>&gt;    public factory init(type: InformationToSwitchOn) {<br>&gt;        return ConcreteImplementation(type)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; <br>&gt; ## Class Cluster/Abstract Classes<br>&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; <br>&gt; ## Protocol Initializers<br>&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; <br>&gt; ## Initializing Storyboard-backed View Controller<br>&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; <br>&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt; <br>&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; <br>&gt; Best,<br>&gt; Riley Testut<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>Glad to see there&#39;s definitely some interest in this community then! I would love to start writing up a final proposal to submit to the Swift-Evolution repo, but I think that last piece of information needed would be the actual method of initialization, specifically should we allow for returning instances from convenience initializers, or should we simply assign to self? <br></p><p>Personally, I think returning from the initializer makes the most sense, especially because &quot;self&quot; in a protocol extension seems ambiguous. However, I&#39;m not that much in favor that I couldn&#39;t be convinced to simply assign to self, because that already has some low level support in the language. Anyone have strong thoughts one way or another?<br></p><p>&gt; On Dec 22, 2015, at 1:00 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Strong +1 on this, particularly on the part about protocol initializers. This would bring together some of the best aspects of both Objective-C class clusters and Swift protocol-oriented programming and would be a huge benefit to application developers.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 11:09 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Glad to see there&#39;s definitely some interest in this community then! I would love to start writing up a final proposal to submit to the Swift-Evolution repo, but I think that last piece of information needed would be the actual method of initialization, specifically should we allow for returning instances from convenience initializers, or should we simply assign to self? <br>&gt; <br>&gt; Personally, I think returning from the initializer makes the most sense, especially because &quot;self&quot; in a protocol extension seems ambiguous. However, I&#39;m not that much in favor that I couldn&#39;t be convinced to simply assign to self, because that already has some low level support in the language. Anyone have strong thoughts one way or another?<br></p><p>Assigning to self was always a bit weird. I think returning an instance makes more sense intuitively. It’s also, as you say, unclear exactly what “self” even means in the context of a protocol.<br></p><p>Probably the way I’d do it would be to have the method declared “factory init” and be required to return an object.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/91e5970f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 23, 2015, at 11:57 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 11:09 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Glad to see there&#39;s definitely some interest in this community then! I would love to start writing up a final proposal to submit to the Swift-Evolution repo, but I think that last piece of information needed would be the actual method of initialization, specifically should we allow for returning instances from convenience initializers, or should we simply assign to self? <br>&gt;&gt; <br>&gt;&gt; Personally, I think returning from the initializer makes the most sense, especially because &quot;self&quot; in a protocol extension seems ambiguous. However, I&#39;m not that much in favor that I couldn&#39;t be convinced to simply assign to self, because that already has some low level support in the language. Anyone have strong thoughts one way or another?<br>&gt; <br>&gt; Assigning to self was always a bit weird. I think returning an instance makes more sense intuitively. It’s also, as you say, unclear exactly what “self” even means in the context of a protocol.<br>&gt; <br>&gt; Probably the way I’d do it would be to have the method declared “factory init” and be required to return an object.<br></p><p>+1 assuming we want to use the same syntax in type and protocol extensions.  I don&#39;t like assign-to-self in a protocol extension.  <br></p><p>Returning the instance also matches how factory methods are usually done in other languages.  That shouldn&#39;t carry too much weight but it is worth noting.<br></p><p><br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/d6be6271/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; <br>&gt; # Factory Initializers<br>&gt; <br>&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; <br>&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; <br>&gt; class AbstractBase {<br>&gt;    public factory init(type: InformationToSwitchOn) {<br>&gt;        return ConcreteImplementation(type)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; <br>&gt; ## Class Cluster/Abstract Classes<br>&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; <br>&gt; ## Protocol Initializers<br>&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; <br>&gt; ## Initializing Storyboard-backed View Controller<br>&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; <br>&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt; <br>&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; <br>&gt; Best,<br>&gt; Riley Testut<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Hey all!<br></p><p>Very sorry, restored my MacBook at the beginning of the calendar year, and forgot to re-subscribe to Swift-Evolution 😄. Once I realized this, I decided to hold off on pushing this forward till after Swift 2.2, and now that it&#39;s been released, I&#39;d love to make moves on this!<br></p><p>So, is there still an interest in the proposal? If so, I&#39;ll write up a new proposal with everyone&#39;s feedback, and then post it here for more discussion. I think this would very valuable (and would certainly help a bunch in my current app), but want to see where everyone stands!<br></p><p>Riley Testut<br></p><p>On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br></p><p>&gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt; <br>&gt; Charles<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Definitely a +1 here on interest for this proposal, have run into this<br>several times.<br></p><p>On Tue, Mar 22, 2016 at 5:16 PM, Riley Testut via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hey all!<br>&gt;<br>&gt; Very sorry, restored my MacBook at the beginning of the calendar year, and<br>&gt; forgot to re-subscribe to Swift-Evolution 😄. Once I realized this, I<br>&gt; decided to hold off on pushing this forward till after Swift 2.2, and now<br>&gt; that it&#39;s been released, I&#39;d love to make moves on this!<br>&gt;<br>&gt; So, is there still an interest in the proposal? If so, I&#39;ll write up a new<br>&gt; proposal with everyone&#39;s feedback, and then post it here for more<br>&gt; discussion. I think this would very valuable (and would certainly help a<br>&gt; bunch in my current app), but want to see where everyone stands!<br>&gt;<br>&gt; Riley Testut<br>&gt;<br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the<br>&gt; &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we<br>&gt; discussed it and came up with different approaches, it evolved into a<br>&gt; functionality that I believe is far more beneficial to Swift, and<br>&gt; subsequently should be the focus of its own proposal. So here is the<br>&gt; improved (pre-)proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Factory Initializers<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including<br>&gt; Objective-C. Essentially, instead of initializing a type directly, a method<br>&gt; is called that returns an instance of the appropriate type determined by<br>&gt; the input parameters. Functionally this works well, but ultimately it<br>&gt; forces the client of the API to remember to call the factory method<br>&gt; instead, rather than the type&#39;s initializer. This might seem like a minor<br>&gt; gripe, but given that we want Swift to be as approachable as possible to<br>&gt; new developers, I think we can do better in this regard.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the<br>&gt; factory pattern right into Swift, by way of specialized “factory<br>&gt; initializers”. The exact syntax was proposed by Philippe Hausler from the<br>&gt; previous thread, and I think it is an excellent solution:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class AbstractBase {<br>&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development,<br>&gt; I’ve come across a few places where this would especially be relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think<br>&gt; it would be a very valid use case. The public superclass would declare all<br>&gt; the public methods, and could delegate off the specific implementations to<br>&gt; the private subclasses. Alternatively, this method could be used as an easy<br>&gt; way to handle backwards-compatibility: rather than litter the code with<br>&gt; branches depending on the OS version, simply return the OS-appropriate<br>&gt; subclass from the factory initializer. Very useful.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Protocol Initializers<br>&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with<br>&gt; protocol extensions to return the appropriate instance conforming to a<br>&gt; protocol for the given needs. Similar to the class cluster/abstract class<br>&gt; method, but can work with structs too. This would be closer to the factory<br>&gt; method pattern, since you don’t need to know exactly what type is returned,<br>&gt; just the protocol it conforms to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory<br>&gt; initializers could definitely help here. Currently, view controllers<br>&gt; associated with a storyboard must be initialized from the client through a<br>&gt; factory method on the storyboard instance (storyboard.<br>&gt; instantiateViewControllerWithIdentifier()). This works when the entire flow<br>&gt; of the app is storyboard based, but when a single storyboard is used to<br>&gt; configure a one-off view controller, having to initialize through the<br>&gt; storyboard is essentially use of private implementation details; it<br>&gt; shouldn’t matter whether the VC was designed in code or storyboards,<br>&gt; ultimately a single initializer should “do the right thing” (just as it<br>&gt; does when using XIBs directly). A factory initializer for a View Controller<br>&gt; subclass could handle the loading of the storyboard and returning the<br>&gt; appropriate view controller.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some comments from the previous thread that I believe are<br>&gt; still relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have<br>&gt; much more idiomatic swift and much more similar behavior to the way<br>&gt; Foundation on Darwin actually works if we had factory initializers.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which<br>&gt; is *not* applied to types conforming to the protocol. Instead, it is<br>&gt; actually an initializer on the protocol itself. `self` is the protocol<br>&gt; metatype, not an instance of anything. The provided implementation should<br>&gt; `return` an instance conforming to (and implicitly casted to) the protocol.<br>&gt; Just like any other initializer, a `protocol init` can be failable or<br>&gt; throwing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at<br>&gt; compile time which concrete type will be returned by a protocol init(),<br>&gt; reducing opportunities to statically bind methods and perform other<br>&gt; optimization tricks. Frankly, though, that’s just the cost of doing<br>&gt; business. If you want to select a type dynamically, you’re going to lose<br>&gt; the ability to aggressively optimize calls to the resulting instance.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Riley Testut<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; Was any proposal for this ever written up? It would be really useful to<br>&gt; have, and it appeared to have the support of several Apple staff members.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/4b514f20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 22, 2016 at 11:00:00am</p></header><div class="content"><p>+1 for factory initializers on classes.<br></p><p>-0.5 for factory initializers on protocols.<br></p><p>I believe  there is a strong pairing between Dependency Inversion (from SOLID principals, that you should depend on abstractions like protocols instead of concretions like a particular class) and dependency injection (that your implementation should be given the instances of the abstraction you need rather than creating concrete classes on its own)<br></p><p>By having your code depend on a factory initializer at runtime to get its abstractions, you are limited in your ability to adapt the code to other scenarios such as testing. You may for instance need to put your factory initializer on your protocol into a ‘testing mode’ in order to perform unit testing on your code.<br></p><p>Or in other words, while its already possible to have factory methods and factory functions, I worry that factory initializers will result in APIs being unknowingly designed toward a higher degree of coupling in their code. Having factory initializers provides a greater degree of “blessing” in API design to (what I at least consider to be) an anti-pattern.<br></p><p>-DW<br></p><p>&gt; On Mar 22, 2016, at 4:42 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Definitely a +1 here on interest for this proposal, have run into this several times.<br>&gt; <br>&gt; On Tue, Mar 22, 2016 at 5:16 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hey all!<br>&gt; <br>&gt; Very sorry, restored my MacBook at the beginning of the calendar year, and forgot to re-subscribe to Swift-Evolution 😄. Once I realized this, I decided to hold off on pushing this forward till after Swift 2.2, and now that it&#39;s been released, I&#39;d love to make moves on this!<br>&gt; <br>&gt; So, is there still an interest in the proposal? If so, I&#39;ll write up a new proposal with everyone&#39;s feedback, and then post it here for more discussion. I think this would very valuable (and would certainly help a bunch in my current app), but want to see where everyone stands!<br>&gt; <br>&gt; Riley Testut<br>&gt; <br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Factory Initializers<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class AbstractBase {<br>&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Protocol Initializers<br>&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;mailto:phausler at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Riley Testut<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/6daba224/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; -0.5 for factory initializers on protocols.<br>&gt; <br>&gt; I believe  there is a strong pairing between Dependency Inversion (from SOLID principals, that you should depend on abstractions like protocols instead of concretions like a particular class) and dependency injection (that your implementation should be given the instances of the abstraction you need rather than creating concrete classes on its own)<br>&gt; <br>&gt; By having your code depend on a factory initializer at runtime to get its abstractions, you are limited in your ability to adapt the code to other scenarios such as testing. You may for instance need to put your factory initializer on your protocol into a ‘testing mode’ in order to perform unit testing on your code.<br>&gt; <br>&gt; Or in other words, while its already possible to have factory methods and factory functions, I worry that factory initializers will result in APIs being unknowingly designed toward a higher degree of coupling in their code. Having factory initializers provides a greater degree of “blessing” in API design to (what I at least consider to be) an anti-pattern.<br></p><p>Testability and dependency injection are red herrings; factory initializers are no better or worse for those than any other mechanism in the language.<br></p><p>For instance, suppose you have an Image protocol with a factory initializer on its data:<br></p><p>	protocol Image {<br>		init(data: NSData)<br>		var data: NSData { get }<br>		<br>		var size: CGSize<br>		func draw(at point: CGPoint, in context: CGContext)<br>	}<br>	<br>	extension Image {<br>		factory init(data: NSData) {<br>			if isJPEG(data: data) {<br>				self = JPEGImage(data: data)<br>			}<br>			else if isPNG(data: data) {<br>				self = PNGImage(data: data)<br>			}<br>			else {<br>				self = BitmapImage(data: data)<br>			}<br>		}<br>	}<br></p><p>Certainly if your code says `Image(data:)` directly, this violates dependency injection:<br></p><p>	class ImageDownloader: Downloader {<br>		var completion: (Image?, Error?) -&gt; Void<br>		<br>		func didComplete(data: NSData) {<br>			let image = Image(data: data)<br>			completion(image, nil)<br>		}<br>	}<br></p><p>But the same would be true if we didn&#39;t have factory inits and instead had a static method or function that did the same thing. The solution is not to ban factory methods; it&#39;s to keep using dependency injection.<br></p><p>	class ImageDownloader: Downloader {<br>		var completion: (Image?, Error?) -&gt; Void<br></p><p>		// Defaulted for convenience in normal use, but a test can change it.<br>		var makeImage: NSData -&gt; Image = Image.init(data:)<br>		<br>		func didComplete(data: NSData) {<br>			let image = makeImage(data)<br>			completion(image, nil)<br>		}<br>	}<br></p><p>Similarly, if you think the factory init is not testable enough, you are not complaining about it being a factory init; you are complaining about it being poorly factored. The solution is to improve its factoring:<br></p><p>	func imageType(for data: NSData) -&gt; Image.Type {<br>		if isJPEG(data: data) {<br>			return JPEGImage.self<br>		}<br>		else if isPNG(data: data) {<br>			return PNGImage.self<br>		}<br>		else {<br>			return BitmapImage.self<br>		}<br>	}<br>	<br>	extension Image {<br>		// Defaulted for convenience in normal use<br>		factory init(data: NSData, decideImageType: NSData -&gt; Image.Type = imageType(for:)) {<br>			let type = decideImageType(data)<br>			self = type.init(data: data)<br>		}<br>	}<br></p><p>With this in place, you can separately test that:<br></p><p>* `imageType(for:)` correctly detects image types.<br>* `Image.init` constructs an image of the type returned by `decideImageType`.<br></p><p>Which lets you test this design without forcing you to construct any unwanted concrete types.<br></p><p>So in short, I think factory inits are no less testable than any other code, and if you&#39;re running into trouble because you&#39;re not injecting dependencies, the solution is, quite simply, to inject dependencies.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>March 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Very strong +1 for factory initializers on both classes and protocols.<br></p><p>Charles<br></p><p>&gt; On Mar 22, 2016, at 1:16 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey all!<br>&gt; <br>&gt; Very sorry, restored my MacBook at the beginning of the calendar year, and forgot to re-subscribe to Swift-Evolution 😄. Once I realized this, I decided to hold off on pushing this forward till after Swift 2.2, and now that it&#39;s been released, I&#39;d love to make moves on this!<br>&gt; <br>&gt; So, is there still an interest in the proposal? If so, I&#39;ll write up a new proposal with everyone&#39;s feedback, and then post it here for more discussion. I think this would very valuable (and would certainly help a bunch in my current app), but want to see where everyone stands!<br>&gt; <br>&gt; Riley Testut<br>&gt; <br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Factory Initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;  public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;      return ConcreteImplementation(type)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Riley Testut<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>FWIW, even in Swift2, factory initializer is possible.<br></p><p>I&#39;ve post a gist here:<br>https://gist.github.com/rintaro/9eadc2720ac8be6a7898<br>It&#39;s pretty hackish though :)<br></p><p><br>2016-03-22 15:16 GMT+09:00 Riley Testut via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Hey all!<br>&gt;<br>&gt; Very sorry, restored my MacBook at the beginning of the calendar year, and<br>&gt; forgot to re-subscribe to Swift-Evolution 😄. Once I realized this, I<br>&gt; decided to hold off on pushing this forward till after Swift 2.2, and now<br>&gt; that it&#39;s been released, I&#39;d love to make moves on this!<br>&gt;<br>&gt; So, is there still an interest in the proposal? If so, I&#39;ll write up a new<br>&gt; proposal with everyone&#39;s feedback, and then post it here for more<br>&gt; discussion. I think this would very valuable (and would certainly help a<br>&gt; bunch in my current app), but want to see where everyone stands!<br>&gt;<br>&gt; Riley Testut<br>&gt;<br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the<br>&gt; &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we<br>&gt; discussed it and came up with different approaches, it evolved into a<br>&gt; functionality that I believe is far more beneficial to Swift, and<br>&gt; subsequently should be the focus of its own proposal. So here is the<br>&gt; improved (pre-)proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Factory Initializers<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including<br>&gt; Objective-C. Essentially, instead of initializing a type directly, a method<br>&gt; is called that returns an instance of the appropriate type determined by<br>&gt; the input parameters. Functionally this works well, but ultimately it<br>&gt; forces the client of the API to remember to call the factory method<br>&gt; instead, rather than the type&#39;s initializer. This might seem like a minor<br>&gt; gripe, but given that we want Swift to be as approachable as possible to<br>&gt; new developers, I think we can do better in this regard.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the<br>&gt; factory pattern right into Swift, by way of specialized “factory<br>&gt; initializers”. The exact syntax was proposed by Philippe Hausler from the<br>&gt; previous thread, and I think it is an excellent solution:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class AbstractBase {<br>&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development,<br>&gt; I’ve come across a few places where this would especially be relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think<br>&gt; it would be a very valid use case. The public superclass would declare all<br>&gt; the public methods, and could delegate off the specific implementations to<br>&gt; the private subclasses. Alternatively, this method could be used as an easy<br>&gt; way to handle backwards-compatibility: rather than litter the code with<br>&gt; branches depending on the OS version, simply return the OS-appropriate<br>&gt; subclass from the factory initializer. Very useful.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Protocol Initializers<br>&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with<br>&gt; protocol extensions to return the appropriate instance conforming to a<br>&gt; protocol for the given needs. Similar to the class cluster/abstract class<br>&gt; method, but can work with structs too. This would be closer to the factory<br>&gt; method pattern, since you don’t need to know exactly what type is returned,<br>&gt; just the protocol it conforms to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory<br>&gt; initializers could definitely help here. Currently, view controllers<br>&gt; associated with a storyboard must be initialized from the client through a<br>&gt; factory method on the storyboard instance (storyboard.<br>&gt; instantiateViewControllerWithIdentifier()). This works when the entire flow<br>&gt; of the app is storyboard based, but when a single storyboard is used to<br>&gt; configure a one-off view controller, having to initialize through the<br>&gt; storyboard is essentially use of private implementation details; it<br>&gt; shouldn’t matter whether the VC was designed in code or storyboards,<br>&gt; ultimately a single initializer should “do the right thing” (just as it<br>&gt; does when using XIBs directly). A factory initializer for a View Controller<br>&gt; subclass could handle the loading of the storyboard and returning the<br>&gt; appropriate view controller.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some comments from the previous thread that I believe are<br>&gt; still relevant:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have<br>&gt; much more idiomatic swift and much more similar behavior to the way<br>&gt; Foundation on Darwin actually works if we had factory initializers.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which<br>&gt; is *not* applied to types conforming to the protocol. Instead, it is<br>&gt; actually an initializer on the protocol itself. `self` is the protocol<br>&gt; metatype, not an instance of anything. The provided implementation should<br>&gt; `return` an instance conforming to (and implicitly casted to) the protocol.<br>&gt; Just like any other initializer, a `protocol init` can be failable or<br>&gt; throwing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at<br>&gt; compile time which concrete type will be returned by a protocol init(),<br>&gt; reducing opportunities to statically bind methods and perform other<br>&gt; optimization tricks. Frankly, though, that’s just the cost of doing<br>&gt; business. If you want to select a type dynamically, you’re going to lose<br>&gt; the ability to aggressively optimize calls to the resulting instance.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Riley Testut<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; Was any proposal for this ever written up? It would be really useful to<br>&gt; have, and it appeared to have the support of several Apple staff members.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/2b074fce/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
