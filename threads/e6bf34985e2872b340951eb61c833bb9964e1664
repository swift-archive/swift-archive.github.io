<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eda6788f4ddde383cbb035f3fe2ed7f6?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Akiva Leffert</string> &lt;aleffert at gmail.com&gt;<p>December 10, 2015 at 12:00:00am</p></header><div class="content"><p>Hi,<br>I’m interested in adding user defined annotations. For example,<br></p><p>	```<br>	@MyAnnotation func foo() {<br>	}<br>	```<br></p><p>This would help enable third party linting and behavioral documentation. This is useful in its own right, but it can also help inform the future direction of static checks within the language.<br></p><p>I’ve started hacking on this (adding a new “Annotation” attribute and associated declaration), but I figured before I went too far I should get some feedback.<br></p><p>—<br></p><p>I imagine you would declare one of these in the following way:<br>	<br>	```<br>	annotation MyAnnotation<br>	```<br></p><p>and use it as above, using a qualified path if necessary: ``@MyModule.MyClass.MyAnnotation``.<br></p><p>You could also imagine just having a single extendable attribute that takes a string, similar to how C compilers do it, ``@Annotate(“whatever”)`` but that seems error prone and really only works in C because you #define it once and count on the preprocessor to avoid typos. It also doesn’t help prepare for more interesting annotation usage later.<br></p><p>As such, this would introduce a new keyword “annotation”. I think these are sufficiently useful - especially if they end up tying into a macro system - that they deserve a keyword. However, an alternate approach is to overload the existing attribute syntax:<br>	```<br>	@Annotation(MyAnnotation)<br>	```<br></p><p>	or<br></p><p>	```<br>	@annotation MyAnnotation<br>	```<br>	<br>	To me this seems awkward, as it does not match the style of any other declarations, but adding a new keyword is a big deal, so there’s an obvious trade off.<br></p><p>This proposal does not include annotations with arguments nor does it ascribe any dynamic behavior to those annotations. The static content is limited to checking whether the annotation is already defined.<br></p><p>I deliberately skipped arguments for annotations since there are a lot of questions about defining the types of those arguments, but it&#39;s an obvious future extension.<br></p><p>Other possible extensions this proposal needs to not prevent:<br></p><p>1. Providing annotations that actually do things like:<br>	- Evaluate macros<br>	- Connect to a protocol or class in some way a la java<br>	- Python style decorators<br>2. Limiting annotations to certain syntactic classes.<br>3. New built in attributes.<br>4. &lt;Insert your feature idea here&gt;<br></p><p>This initial version is sufficiently minimal that I don’t think any of those would be blocked by it*.<br></p><p>It’s not obvious to me what is the right way to scope user annotations vs new compiler ones. A simple namespace might be best, forcing the compiler to use “_” or lowercase or something like that, but that would involve further migration for existing code.<br></p><p>Anyway, I’m happy to write this up into a proper proposal if there’s general interest.<br></p><p><br>-Akiva Leffert<br></p><p>* Strawman examples of being compatible with possible extensions<br></p><p>// arguments<br>annotation Foo(A, B, C)<br></p><p>// macros<br>annotation macro Bar(A, B, C) {<br>	… do stuff ...<br>}<br></p><p>// decorators<br>annotation func Baz(f : Int -&gt; String) -&gt; (Int -&gt; String) {<br>	… do stuff ...<br>}<br></p><p>// only certain syntactic classes<br>annotation Foo { usage { func, decl, struct, class } }<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>Hi Akiva,<br></p><p>You mention documentation/linting and static checks - could you elaborate a bit on what exactly the use case for user-defined annotations would be for these things? How would one define a static runtime check in your proposed syntax? <br></p><p>For documentation, it would perhaps suffice if the compiler just ignored any &#39;unknown&#39; annotations, but would provide them to external lint/documentation tools. Then again we already have documentation comment blocks.<br></p><p>A few other use cases I can think of: serialization (annotate field name to property), concurrency (so you can implement something like @synchronized) and reflection. Not sure whether any of these are in scope for Swift 3.0 though.<br></p><p>Best,<br>Tommy.<br></p><p>&gt; Op 10 dec. 2015, om 06:40 heeft Akiva Leffert via swift-evolution &lt;swift-evolution at swift.org&gt; het volgende geschreven:<br>&gt; <br>&gt; Hi,<br>&gt; I’m interested in adding user defined annotations. For example,<br>&gt; <br>&gt; 	```<br>&gt; 	@MyAnnotation func foo() {<br>&gt; 	}<br>&gt; 	```<br>&gt; <br>&gt; This would help enable third party linting and behavioral documentation. This is useful in its own right, but it can also help inform the future direction of static checks within the language.<br>&gt; <br>&gt; I’ve started hacking on this (adding a new “Annotation” attribute and associated declaration), but I figured before I went too far I should get some feedback.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; I imagine you would declare one of these in the following way:<br>&gt; 	<br>&gt; 	```<br>&gt; 	annotation MyAnnotation<br>&gt; 	```<br>&gt; <br>&gt; and use it as above, using a qualified path if necessary: ``@MyModule.MyClass.MyAnnotation``.<br>&gt; <br>&gt; You could also imagine just having a single extendable attribute that takes a string, similar to how C compilers do it, ``@Annotate(“whatever”)`` but that seems error prone and really only works in C because you #define it once and count on the preprocessor to avoid typos. It also doesn’t help prepare for more interesting annotation usage later.<br>&gt; <br>&gt; As such, this would introduce a new keyword “annotation”. I think these are sufficiently useful - especially if they end up tying into a macro system - that they deserve a keyword. However, an alternate approach is to overload the existing attribute syntax:<br>&gt; 	```<br>&gt; 	@Annotation(MyAnnotation)<br>&gt; 	```<br>&gt; <br>&gt; 	or<br>&gt; <br>&gt; 	```<br>&gt; 	@annotation MyAnnotation<br>&gt; 	```<br>&gt; 	<br>&gt; 	To me this seems awkward, as it does not match the style of any other declarations, but adding a new keyword is a big deal, so there’s an obvious trade off.<br>&gt; <br>&gt; This proposal does not include annotations with arguments nor does it ascribe any dynamic behavior to those annotations. The static content is limited to checking whether the annotation is already defined.<br>&gt; <br>&gt; I deliberately skipped arguments for annotations since there are a lot of questions about defining the types of those arguments, but it&#39;s an obvious future extension.<br>&gt; <br>&gt; Other possible extensions this proposal needs to not prevent:<br>&gt; <br>&gt; 1. Providing annotations that actually do things like:<br>&gt; 	- Evaluate macros<br>&gt; 	- Connect to a protocol or class in some way a la java<br>&gt; 	- Python style decorators<br>&gt; 2. Limiting annotations to certain syntactic classes.<br>&gt; 3. New built in attributes.<br>&gt; 4. &lt;Insert your feature idea here&gt;<br>&gt; <br>&gt; This initial version is sufficiently minimal that I don’t think any of those would be blocked by it*.<br>&gt; <br>&gt; It’s not obvious to me what is the right way to scope user annotations vs new compiler ones. A simple namespace might be best, forcing the compiler to use “_” or lowercase or something like that, but that would involve further migration for existing code.<br>&gt; <br>&gt; Anyway, I’m happy to write this up into a proper proposal if there’s general interest.<br>&gt; <br>&gt; <br>&gt; -Akiva Leffert<br>&gt; <br>&gt; * Strawman examples of being compatible with possible extensions<br>&gt; <br>&gt; // arguments<br>&gt; annotation Foo(A, B, C)<br>&gt; <br>&gt; // macros<br>&gt; annotation macro Bar(A, B, C) {<br>&gt; 	… do stuff ...<br>&gt; }<br>&gt; <br>&gt; // decorators<br>&gt; annotation func Baz(f : Int -&gt; String) -&gt; (Int -&gt; String) {<br>&gt; 	… do stuff ...<br>&gt; }<br>&gt; <br>&gt; // only certain syntactic classes<br>&gt; annotation Foo { usage { func, decl, struct, class } }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/f12cb638/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>Just chiming in here to say that I&#39;ve always wanted to add something like @animatable to all animatable properties for my classes. It&#39;d be so much better than searching docs.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Dec 2015, at 08:30, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Akiva,<br>&gt; <br>&gt; You mention documentation/linting and static checks - could you elaborate a bit on what exactly the use case for user-defined annotations would be for these things? How would one define a static runtime check in your proposed syntax? <br>&gt; <br>&gt; For documentation, it would perhaps suffice if the compiler just ignored any &#39;unknown&#39; annotations, but would provide them to external lint/documentation tools. Then again we already have documentation comment blocks.<br>&gt; <br>&gt; A few other use cases I can think of: serialization (annotate field name to property), concurrency (so you can implement something like @synchronized) and reflection. Not sure whether any of these are in scope for Swift 3.0 though.<br>&gt; <br>&gt; Best,<br>&gt; Tommy.<br>&gt; <br>&gt;&gt; Op 10 dec. 2015, om 06:40 heeft Akiva Leffert via swift-evolution &lt;swift-evolution at swift.org&gt; het volgende geschreven:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; I’m interested in adding user defined annotations. For example,<br>&gt;&gt; <br>&gt;&gt; 	```<br>&gt;&gt; 	@MyAnnotation func foo() {<br>&gt;&gt; 	}<br>&gt;&gt; 	```<br>&gt;&gt; <br>&gt;&gt; This would help enable third party linting and behavioral documentation. This is useful in its own right, but it can also help inform the future direction of static checks within the language.<br>&gt;&gt; <br>&gt;&gt; I’ve started hacking on this (adding a new “Annotation” attribute and associated declaration), but I figured before I went too far I should get some feedback.<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; I imagine you would declare one of these in the following way:<br>&gt;&gt; 	<br>&gt;&gt; 	```<br>&gt;&gt; 	annotation MyAnnotation<br>&gt;&gt; 	```<br>&gt;&gt; <br>&gt;&gt; and use it as above, using a qualified path if necessary: ``@MyModule.MyClass.MyAnnotation``.<br>&gt;&gt; <br>&gt;&gt; You could also imagine just having a single extendable attribute that takes a string, similar to how C compilers do it, ``@Annotate(“whatever”)`` but that seems error prone and really only works in C because you #define it once and count on the preprocessor to avoid typos. It also doesn’t help prepare for more interesting annotation usage later.<br>&gt;&gt; <br>&gt;&gt; As such, this would introduce a new keyword “annotation”. I think these are sufficiently useful - especially if they end up tying into a macro system - that they deserve a keyword. However, an alternate approach is to overload the existing attribute syntax:<br>&gt;&gt; 	```<br>&gt;&gt; 	@Annotation(MyAnnotation)<br>&gt;&gt; 	```<br>&gt;&gt; <br>&gt;&gt; 	or<br>&gt;&gt; <br>&gt;&gt; 	```<br>&gt;&gt; 	@annotation MyAnnotation<br>&gt;&gt; 	```<br>&gt;&gt; 	<br>&gt;&gt; 	To me this seems awkward, as it does not match the style of any other declarations, but adding a new keyword is a big deal, so there’s an obvious trade off.<br>&gt;&gt; <br>&gt;&gt; This proposal does not include annotations with arguments nor does it ascribe any dynamic behavior to those annotations. The static content is limited to checking whether the annotation is already defined.<br>&gt;&gt; <br>&gt;&gt; I deliberately skipped arguments for annotations since there are a lot of questions about defining the types of those arguments, but it&#39;s an obvious future extension.<br>&gt;&gt; <br>&gt;&gt; Other possible extensions this proposal needs to not prevent:<br>&gt;&gt; <br>&gt;&gt; 1. Providing annotations that actually do things like:<br>&gt;&gt; 	- Evaluate macros<br>&gt;&gt; 	- Connect to a protocol or class in some way a la java<br>&gt;&gt; 	- Python style decorators<br>&gt;&gt; 2. Limiting annotations to certain syntactic classes.<br>&gt;&gt; 3. New built in attributes.<br>&gt;&gt; 4. &lt;Insert your feature idea here&gt;<br>&gt;&gt; <br>&gt;&gt; This initial version is sufficiently minimal that I don’t think any of those would be blocked by it*.<br>&gt;&gt; <br>&gt;&gt; It’s not obvious to me what is the right way to scope user annotations vs new compiler ones. A simple namespace might be best, forcing the compiler to use “_” or lowercase or something like that, but that would involve further migration for existing code.<br>&gt;&gt; <br>&gt;&gt; Anyway, I’m happy to write this up into a proper proposal if there’s general interest.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Akiva Leffert<br>&gt;&gt; <br>&gt;&gt; * Strawman examples of being compatible with possible extensions<br>&gt;&gt; <br>&gt;&gt; // arguments<br>&gt;&gt; annotation Foo(A, B, C)<br>&gt;&gt; <br>&gt;&gt; // macros<br>&gt;&gt; annotation macro Bar(A, B, C) {<br>&gt;&gt; 	… do stuff ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // decorators<br>&gt;&gt; annotation func Baz(f : Int -&gt; String) -&gt; (Int -&gt; String) {<br>&gt;&gt; 	… do stuff ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // only certain syntactic classes<br>&gt;&gt; annotation Foo { usage { func, decl, struct, class } }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/ef7d754e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eda6788f4ddde383cbb035f3fe2ed7f6?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Akiva Leffert</string> &lt;aleffert at gmail.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 2:30 AM, Tommy van der Vorst &lt;tommy at pixelspark.nl&gt; wrote:<br>&gt; <br>&gt; Hi Akiva,<br>&gt; <br>&gt; You mention documentation/linting and static checks - could you elaborate a bit on what exactly the use case for user-defined annotations would be for these things? How would one define a static runtime check in your proposed syntax? <br></p><p>You wouldn’t define a static runtime check directly. That&#39;s the responsibility of external tools. Swift linter tools have already started to appear, though I don’t think any of them are taking advantage of the compiler tooling yet. User defined annotations would give them a lot more options and potential power and help motivate an ecosystem. You could imagine a way to have pluggable checks be part of the core language infrastructure, but that seemed out of scope.<br></p><p>As an example of a check, there was a previous discussion of a scope based access control modifier. It would be relatively straightforward to define an attribute for that and linter pass for it, see if people find it has value and if so, feed it back into the core language.<br></p><p>Some other off the cuff examples of annotations include:<br>1. Key-value observable<br>2. Must call super<br>3. Animatable (as mentioned by Rudolf)<br>4. Should be on main thread<br>5. Side effect free<br></p><p>Some of these are just for standardizing documentation, and some could have actual checks associated with them.<br></p><p>I haven’t looked at this closely, but I expect it would allow several existing attributes, like IBAction and friends, to move out of the core language and into libraries.<br></p><p>Further, part of the point of custom annotations is to allow the community to experiment with new features without having to accept them into the core language. Having a feature like this helps prepare for whatever good ideas people have later. Some of those ideas will of course, not be good, but by allowing them to start out as user defined tags we can validate them and find the ones that have real value. You can see this sort of thing happening in the Java community around annotations like @Override and @Nonnull.<br></p><p>&gt; For documentation, it would perhaps suffice if the compiler just ignored any &#39;unknown&#39; annotations, but would provide them to external lint/documentation tools. Then again we already have documentation comment blocks.<br></p><p>I think having the compiler check that your annotations exist has value. Typos are easy to make.<br></p><p>&gt; A few other use cases I can think of: serialization (annotate field name to property), concurrency (so you can implement something like @synchronized) and reflection. Not sure whether any of these are in scope for Swift 3.0 though.<br></p><p>Yeah, these are useful features for sure and annotations could go that way in the long term. This proposal is more of a stake in the ground to get things started and help inform the direction of those designs, while also providing enough initial value to be worthwhile on its own.<br></p><p>-Akiva Leffert<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/660f0451/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 9:40 PM, Akiva Leffert via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; I’m interested in adding user defined annotations. For example,<br>&gt; <br>&gt; 	```<br>&gt; 	@MyAnnotation func foo() {<br>&gt; 	}<br>&gt; 	```<br>&gt; <br>&gt; This would help enable third party linting and behavioral documentation. This is useful in its own right, but it can also help inform the future direction of static checks within the language.<br></p><p>Quick feedback: I’d love to see Swift have this sort of functionality someday, but when it exists, it should almost certainly tie into the reflection system.  One of our stretch goals for Swift 3 is to rework the &quot;mirror” APIs into a proper reflection system, and the design of user-defined annotations should wait until that settles out IMO.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3770c1b6a421c8d4de4177356911a829?s=50"></div><header><strong>User Defined Attributes/Annotations</strong> from <string>Bryan Irace</string> &lt;bryan at irace.me&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>Really thrilled to hear that this is a priority. Custom annotation types (and a reflection API to consume them) were something I took advantage of constantly when writing Java and would very much love to see them in Swift.<br></p><p>&gt; On Dec 10, 2015, at 9:09 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 9:40 PM, Akiva Leffert via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; I’m interested in adding user defined annotations. For example,<br>&gt;&gt; <br>&gt;&gt; 	```<br>&gt;&gt; 	@MyAnnotation func foo() {<br>&gt;&gt; 	}<br>&gt;&gt; 	```<br>&gt;&gt; <br>&gt;&gt; This would help enable third party linting and behavioral documentation. This is useful in its own right, but it can also help inform the future direction of static checks within the language.<br>&gt; <br>&gt; Quick feedback: I’d love to see Swift have this sort of functionality someday, but when it exists, it should almost certainly tie into the reflection system.  One of our stretch goals for Swift 3 is to rework the &quot;mirror” APIs into a proper reflection system, and the design of user-defined annotations should wait until that settles out IMO.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
