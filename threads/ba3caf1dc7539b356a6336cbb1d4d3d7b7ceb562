<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hello dear Swift community, I’m not sure if this was discussed before or not, but I really want to know if something like this is welcome for the future Swift version. If this topic was already discussed, I’m apologizing for bringing it back to life in a new thread.<br></p><p>Lets say I’ve got a third party module and I want to know when the a variable of some type has changed:<br></p><p>extension UIViewController {<br>     <br>    public override var view: UIView {<br>         <br>        willSet {<br>            // do something useful here<br>        }<br>         <br>        didSet {<br>            // do something useful here<br>        }<br>    }<br>}<br>Wouldn’t be handy to inject custom didSet and willSet functions into any property or computed property?<br></p><p>This would also allow us to build a proper two-way-binding mechanism.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/ba3cb562/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>+1. This would allow us to create observers on any foreign variable. I&#39;m<br>far from a compiler right now but I wouldn&#39;t this syntax create a new<br>variable instead of observing an existing one? Even if not, by reading<br>this one could be mislead to believe so. Perhaps you should give it<br>something to differentiate from creating a new var, for example by<br>suppressing the type on this declaration.<br></p><p>On Friday, 8 July 2016, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello dear Swift community, I’m not sure if this was discussed before or<br>&gt; not, but I really want to know if something like this is welcome for the<br>&gt; future Swift version. If this topic was already discussed, I’m apologizing<br>&gt; for bringing it back to life in a new thread.<br>&gt;<br>&gt; Lets say I’ve got a third party module and I want to know when the a<br>&gt; variable of some type has changed:<br>&gt;<br>&gt; extension UIViewController {<br>&gt;<br>&gt;     public override var view: UIView {<br>&gt;<br>&gt;         willSet {<br>&gt;             // do something useful here<br>&gt;         }<br>&gt;<br>&gt;         didSet {<br>&gt;             // do something useful here<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Wouldn’t be handy to inject custom didSet and willSet functions into any<br>&gt; property or computed property?<br>&gt;<br>&gt; This would also allow us to build a proper two-way-binding mechanism.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br></p><p>-- <br>L<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/3ad44c80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Thats a good point!<br></p><p>Here is some bikeshedding:<br></p><p>public extension UIViewController {<br>      <br>    observe public var view: UIView {<br>          <br>        willSet {<br>            // do something useful here<br>        }<br>          <br>        didSet {<br>            // do something useful here<br>        }<br>    }<br>}<br>An extra observe keyword might signal to the compiler the correct intended usage.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 13:14:38, Leonardo Pessoa (me at lmpessoa.com) schrieb:<br></p><p>+1. This would allow us to create observers on any foreign variable. I&#39;m far from a compiler right now but I wouldn&#39;t this syntax create a new variable instead of observing an existing one? Even if not, by reading this one could be mislead to believe so. Perhaps you should give it something to differentiate from creating a new var, for example by suppressing the type on this declaration.<br></p><p>On Friday, 8 July 2016, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Hello dear Swift community, I’m not sure if this was discussed before or not, but I really want to know if something like this is welcome for the future Swift version. If this topic was already discussed, I’m apologizing for bringing it back to life in a new thread.<br></p><p>Lets say I’ve got a third party module and I want to know when the a variable of some type has changed:<br></p><p>extension UIViewController {<br>      <br>    public override var view: UIView {<br>          <br>        willSet {<br>            // do something useful here<br>        }<br>          <br>        didSet {<br>            // do something useful here<br>        }<br>    }<br>}<br>Wouldn’t be handy to inject custom didSet and willSet functions into any property or computed property?<br></p><p>This would also allow us to build a proper two-way-binding mechanism.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p><br>--<br>L<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/db940b7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>I also would like to mention a problem I see with this ‘feature’.<br></p><p>Lets say this is my module:<br></p><p>public struct A {<br>     <br>    public var member1: Int = 42<br>     <br>    public var member2: Int = 0 {<br>         <br>        didSet {<br>             <br>            self.member1 = self.member2<br>        }<br>    }<br>}<br>From a different project, that contains our module we want to observe the public properties:<br></p><p><br>public extension A {<br>     <br>    observe public var member1: Int {<br>         <br>        didSet {<br>            // will be called first<br>        }<br>    }<br>     <br>    observe public var member2: Int {<br>         <br>        didSet {<br>            // will be called last<br>        }<br>    }<br>}<br></p><p>var a = A()<br>a.member1 // 42<br>a.member2 // 0<br></p><p>a.member2 = 100<br>a.member1 // 100<br>a.member2 // 100<br>It’s clear that we should decide on when our observer will be executed. In the example from above I pretended that my observer will be executed after the observer from the module itself.<br></p><p>When we set a.member2 the observer for member1 on our side will be called first, follows by member2 observer, which ‘might’ not be what we need.<br></p><p>I’d suggest that if this ‘feature’ might ever be considered for Swift that we should be able to set the execution order.<br></p><p>Bikeshedding:<br></p><p>observe(first) // called before observer from the module are called<br>observe(last) // called after the observer from the module where called<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 13:22:45, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Thats a good point!<br></p><p>Here is some bikeshedding:<br></p><p>public extension UIViewController {<br>       <br>    observe public var view: UIView {<br>           <br>        willSet {<br>            // do something useful here<br>        }<br>           <br>        didSet {<br>            // do something useful here<br>        }<br>    }<br>}<br>An extra observe keyword might signal to the compiler the correct intended usage.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 13:14:38, Leonardo Pessoa (me at lmpessoa.com) schrieb:<br></p><p>+1. This would allow us to create observers on any foreign variable. I&#39;m far from a compiler right now but I wouldn&#39;t this syntax create a new variable instead of observing an existing one? Even if not, by reading this one could be mislead to believe so. Perhaps you should give it something to differentiate from creating a new var, for example by suppressing the type on this declaration.<br></p><p>On Friday, 8 July 2016, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Hello dear Swift community, I’m not sure if this was discussed before or not, but I really want to know if something like this is welcome for the future Swift version. If this topic was already discussed, I’m apologizing for bringing it back to life in a new thread.<br></p><p>Lets say I’ve got a third party module and I want to know when the a variable of some type has changed:<br></p><p>extension UIViewController {<br>       <br>    public override var view: UIView {<br>           <br>        willSet {<br>            // do something useful here<br>        }<br>           <br>        didSet {<br>            // do something useful here<br>        }<br>    }<br>}<br>Wouldn’t be handy to inject custom didSet and willSet functions into any property or computed property?<br></p><p>This would also allow us to build a proper two-way-binding mechanism.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p><br>--<br>L<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/6c42a17f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 6:45 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It’s clear that we should decide on when our observer will be executed. In the example from above I pretended that my observer will be executed after the observer from the module itself. <br>&gt; <br>&gt; When we set a.member2 the observer for member1 on our side will be called first, follows by member2 observer, which ‘might’ not be what we need.<br>&gt; <br>&gt; I’d suggest that if this ‘feature’ might ever be considered for Swift that we should be able to set the execution order.<br>&gt; <br>&gt; Bikeshedding: <br>&gt; <br>&gt; observe(first) // called before observer from the module are called<br>&gt; observe(last) // called after the observer from the module where called<br>I think I’d say that your “local” willset should be called before the module’s, and your local didset should be called after the module’s. This ensures that module’s code executes closest to when the memory gets changed.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/cbb22eb2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>There are (were?) plans for generalized property behaviors; those would be used to implement lazy, as well as didSet/willSet, and could incorporate many other things (including injection)<br></p><p>Of course, an option to observe variables would be handy — but there&#39;s always a price to pay, and you&#39;ll at least need a way to opt-out: Even if you actually don&#39;t observe a property that changes hundreds of times per second, the hooks alone could degrade performance (it&#39;s another question if it&#39;s wise to have such properties ;-)<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>True story, if you’re doing something heavy and there are tons of calls from your observed property you’d pay with a huge performance decrease. Personally I don’t feel like this would be something that stays in the way of having this handy feature, because it’s always up to us to balance the performance of our application.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 13:44:45, Tino Heth (2th at gmx.de) schrieb:<br></p><p>There are (were?) plans for generalized property behaviors; those would be used to implement lazy, as well as didSet/willSet, and could incorporate many other things (including injection)  <br></p><p>Of course, an option to observe variables would be handy — but there&#39;s always a price to pay, and you&#39;ll at least need a way to opt-out: Even if you actually don&#39;t observe a property that changes hundreds of times per second, the hooks alone could degrade performance (it&#39;s another question if it&#39;s wise to have such properties ;-)  <br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/09eb57bd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Allow injection of `didSet` and `willSet`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 4:43 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are (were?) plans for generalized property behaviors; those would be used to implement lazy, as well as didSet/willSet, and could incorporate many other things (including injection)<br></p><p>Indeed, the latest draft is here:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p>This will surely come back sometime after Swift 3.0.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
