<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Forgive me if this has been answered already, but is<br></p><p>func isLessThanOrEqualTo(_ other: Self) -&gt; Bool<br></p><p>really needed?<br></p><p>I understand the lack of trichotomy. But can’t this simply be implemented using the other existing methods?<br></p><p>Consider that the consumers of the types will normally use the global operators instead of the protocol methods. So instead of<br></p><p>func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>{  <br>	return lhs.isLessThanOrEqualTo(rhs)<br>}<br></p><p>it should be enough to do<br></p><p>func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>{  <br>	return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>}<br></p><p>Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x == y) are both false?<br></p><p>Thanks,<br>Nicola<br></p><p><br>&gt; Hello Swift community,<br>&gt; <br>&gt; Steve opted to revise his original proposal in order to incorporate great feedback from the original review period. As such, we’re extending the review period in order to get adequate consideration of his new changes. The extended review of &quot;SE-0067: Enhanced Floating Point Protocols&quot; runs through April 29. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md<br>&gt; <br>&gt; His previous revision is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/fb1368a6a5474f57aa8f1846b5355d18753098f3/proposals/0067-floating-point-protocols.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; it should be enough to do<br>&gt; <br>&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt; {  <br>&gt; 	return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt; }<br>&gt; <br>&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x == y) are both false?<br></p><p>No, these are always equivalent.<br></p><p>However, there is a problem with this approach: the compiler knows about the built-in floating-point types (Float, Double, Float80) and their aliases (CGFloat, etc) and can fuse the two comparisons into a single hardware operation.  However, for soft-float types, without a lessThanOrEqual method, there is no single comparison that the compiler could fuse these to.<br></p><p>In some cases, if they are simple enough, the compiler may be able to actually fuse the bodies of the two comparison operations, but we can’t reasonably depend on that happening or even being possible in all cases.  So for performance, it’s important that there be an actual less than or equal to method.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/2483fb34/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>If performance is the only reasons to have a separate method, perhaps it<br>might make sense to have a note about this in the isLessThanOrEqualTo<br>description, and provide a default implementation that calls down on isLess<br>and isEqual.<br></p><p>Nicola<br></p><p><br>On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; it should be enough to do<br>&gt;<br>&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt; {<br>&gt; return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt; }<br>&gt;<br>&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x ==<br>&gt; y) are both false?<br>&gt;<br>&gt;<br>&gt; No, these are always equivalent.<br>&gt;<br>&gt; However, there is a problem with this approach: the compiler knows about<br>&gt; the built-in floating-point types (Float, Double, Float80) and their<br>&gt; aliases (CGFloat, etc) and can fuse the two comparisons into a single<br>&gt; hardware operation.  However, for soft-float types, without a<br>&gt; lessThanOrEqual method, there is no single comparison that the compiler<br>&gt; could fuse these to.<br>&gt;<br>&gt; In some cases, if they are simple enough, the compiler may be able to<br>&gt; actually fuse the bodies of the two comparison operations, but we can’t<br>&gt; reasonably depend on that happening or even being possible in all cases.<br>&gt; So for performance, it’s important that there be an actual less than or<br>&gt; equal to method.<br>&gt;<br>&gt; – Steve<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/439b117e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Unrelated to this discussion about comparison operators, please remember to<br>put back .abs() or .absoluteValue() somewhere in FloatingPoint. Thanks!<br></p><p><br>On Tue, Apr 26, 2016 at 12:07 PM, Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If performance is the only reasons to have a separate method, perhaps it<br>&gt; might make sense to have a note about this in the isLessThanOrEqualTo<br>&gt; description, and provide a default implementation that calls down on isLess<br>&gt; and isEqual.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; it should be enough to do<br>&gt;&gt;<br>&gt;&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt;&gt; {<br>&gt;&gt; return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x<br>&gt;&gt; == y) are both false?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No, these are always equivalent.<br>&gt;&gt;<br>&gt;&gt; However, there is a problem with this approach: the compiler knows about<br>&gt;&gt; the built-in floating-point types (Float, Double, Float80) and their<br>&gt;&gt; aliases (CGFloat, etc) and can fuse the two comparisons into a single<br>&gt;&gt; hardware operation.  However, for soft-float types, without a<br>&gt;&gt; lessThanOrEqual method, there is no single comparison that the compiler<br>&gt;&gt; could fuse these to.<br>&gt;&gt;<br>&gt;&gt; In some cases, if they are simple enough, the compiler may be able to<br>&gt;&gt; actually fuse the bodies of the two comparison operations, but we can’t<br>&gt;&gt; reasonably depend on that happening or even being possible in all cases.<br>&gt;&gt; So for performance, it’s important that there be an actual less than or<br>&gt;&gt; equal to method.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/0eebe200/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Do you actually want a method added, or just conformance to AbsoluteValuable?<br></p><p>– Steve<br></p><p>&gt; On Apr 26, 2016, at 7:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unrelated to this discussion about comparison operators, please remember to put back .abs() or .absoluteValue() somewhere in FloatingPoint. Thanks!<br>&gt; <br>&gt; <br>&gt; On Tue, Apr 26, 2016 at 12:07 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If performance is the only reasons to have a separate method, perhaps it might make sense to have a note about this in the isLessThanOrEqualTo description, and provide a default implementation that calls down on isLess and isEqual.<br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; <br>&gt; On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; it should be enough to do<br>&gt;&gt; <br>&gt;&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt;&gt; {  <br>&gt;&gt; 	return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x == y) are both false?<br>&gt; <br>&gt; No, these are always equivalent.<br>&gt; <br>&gt; However, there is a problem with this approach: the compiler knows about the built-in floating-point types (Float, Double, Float80) and their aliases (CGFloat, etc) and can fuse the two comparisons into a single hardware operation.  However, for soft-float types, without a lessThanOrEqual method, there is no single comparison that the compiler could fuse these to.<br>&gt; <br>&gt; In some cases, if they are simple enough, the compiler may be able to actually fuse the bodies of the two comparison operations, but we can’t reasonably depend on that happening or even being possible in all cases.  So for performance, it’s important that there be an actual less than or equal to method.<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/107f9d44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>I thought you&#39;d mentioned that AbsoluteValuable conformance was removed for<br>a reason and that the method would be added to FloatingPoint? Otherwise, it<br>seems like conformance to AbsoluteValuable would be much the same...<br></p><p><br>On Tue, Apr 26, 2016 at 6:54 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; Do you actually want a method added, or just conformance to<br>&gt; AbsoluteValuable?<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; On Apr 26, 2016, at 7:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Unrelated to this discussion about comparison operators, please remember<br>&gt; to put back .abs() or .absoluteValue() somewhere in FloatingPoint. Thanks!<br>&gt;<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 12:07 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; If performance is the only reasons to have a separate method, perhaps it<br>&gt;&gt; might make sense to have a note about this in the isLessThanOrEqualTo<br>&gt;&gt; description, and provide a default implementation that calls down on isLess<br>&gt;&gt; and isEqual.<br>&gt;&gt;<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; it should be enough to do<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x<br>&gt;&gt;&gt; == y) are both false?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No, these are always equivalent.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, there is a problem with this approach: the compiler knows about<br>&gt;&gt;&gt; the built-in floating-point types (Float, Double, Float80) and their<br>&gt;&gt;&gt; aliases (CGFloat, etc) and can fuse the two comparisons into a single<br>&gt;&gt;&gt; hardware operation.  However, for soft-float types, without a<br>&gt;&gt;&gt; lessThanOrEqual method, there is no single comparison that the compiler<br>&gt;&gt;&gt; could fuse these to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In some cases, if they are simple enough, the compiler may be able to<br>&gt;&gt;&gt; actually fuse the bodies of the two comparison operations, but we can’t<br>&gt;&gt;&gt; reasonably depend on that happening or even being possible in all cases.<br>&gt;&gt;&gt; So for performance, it’s important that there be an actual less than or<br>&gt;&gt;&gt; equal to method.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/bcd18449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May  1, 2016 at 09:00:00am</p></header><div class="content"><p>Am I correct in assuming that this would also eliminate the hidden<br>associatedtype<br>_BitsType currently preventing non-stdlib conformances?<br></p><p>On Wed, Apr 27, 2016 at 2:04 AM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I thought you&#39;d mentioned that AbsoluteValuable conformance was removed<br>&gt; for a reason and that the method would be added to FloatingPoint?<br>&gt; Otherwise, it seems like conformance to AbsoluteValuable would be much the<br>&gt; same...<br>&gt;<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 6:54 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Do you actually want a method added, or just conformance to<br>&gt;&gt; AbsoluteValuable?<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Apr 26, 2016, at 7:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Unrelated to this discussion about comparison operators, please remember<br>&gt;&gt; to put back .abs() or .absoluteValue() somewhere in FloatingPoint. Thanks!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 12:07 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; If performance is the only reasons to have a separate method, perhaps it<br>&gt;&gt;&gt; might make sense to have a note about this in the isLessThanOrEqualTo<br>&gt;&gt;&gt; description, and provide a default implementation that calls down on isLess<br>&gt;&gt;&gt; and isEqual.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; it should be enough to do<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and (x<br>&gt;&gt;&gt;&gt; == y) are both false?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; No, these are always equivalent.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, there is a problem with this approach: the compiler knows<br>&gt;&gt;&gt;&gt; about the built-in floating-point types (Float, Double, Float80) and their<br>&gt;&gt;&gt;&gt; aliases (CGFloat, etc) and can fuse the two comparisons into a single<br>&gt;&gt;&gt;&gt; hardware operation.  However, for soft-float types, without a<br>&gt;&gt;&gt;&gt; lessThanOrEqual method, there is no single comparison that the compiler<br>&gt;&gt;&gt;&gt; could fuse these to.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In some cases, if they are simple enough, the compiler may be able to<br>&gt;&gt;&gt;&gt; actually fuse the bodies of the two comparison operations, but we can’t<br>&gt;&gt;&gt;&gt; reasonably depend on that happening or even being possible in all cases.<br>&gt;&gt;&gt;&gt; So for performance, it’s important that there be an actual less than or<br>&gt;&gt;&gt;&gt; equal to method.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/2dd97e47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Review #2] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May  1, 2016 at 10:00:00am</p></header><div class="content"><p>Also, maximum() should probably return y if x == y to be consistent with<br>max()<br>&lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Algorithm.swift#L38&gt;,<br>preserving stable ordering for (x, y) = (min(x, y), max(x, y)). I think<br>IEEE 754 leaves the x == y case unspecified. Currently we have the<br>guarantee below.<br></p><p>/// (…) Returns `x` if `x &gt;= y`, `y` if `y &gt; x` (…)static func<br>maximum(x: Self, _ y: Self) -&gt; Self<br></p><p><br>Patrick<br></p><p>On Sun, May 1, 2016 at 9:03 AM, Patrick Pijnappel &lt;<br>patrickpijnappel at gmail.com&gt; wrote:<br></p><p>&gt; Am I correct in assuming that this would also eliminate the hidden associatedtype<br>&gt; _BitsType currently preventing non-stdlib conformances?<br>&gt;<br>&gt; On Wed, Apr 27, 2016 at 2:04 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I thought you&#39;d mentioned that AbsoluteValuable conformance was removed<br>&gt;&gt; for a reason and that the method would be added to FloatingPoint?<br>&gt;&gt; Otherwise, it seems like conformance to AbsoluteValuable would be much the<br>&gt;&gt; same...<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 6:54 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Do you actually want a method added, or just conformance to<br>&gt;&gt;&gt; AbsoluteValuable?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 26, 2016, at 7:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unrelated to this discussion about comparison operators, please remember<br>&gt;&gt;&gt; to put back .abs() or .absoluteValue() somewhere in FloatingPoint. Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Apr 26, 2016 at 12:07 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If performance is the only reasons to have a separate method, perhaps<br>&gt;&gt;&gt;&gt; it might make sense to have a note about this in the isLessThanOrEqualTo<br>&gt;&gt;&gt;&gt; description, and provide a default implementation that calls down on isLess<br>&gt;&gt;&gt;&gt; and isEqual.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Apr 26, 2016 at 4:59 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Apr 26, 2016, at 10:03 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; it should be enough to do<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; return lhs.isLess(than: rhs) || lhs.isEqual(to: rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Or is there some case of x, y where (x &lt;= y) is true but (x &lt; y) and<br>&gt;&gt;&gt;&gt;&gt; (x == y) are both false?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; No, these are always equivalent.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; However, there is a problem with this approach: the compiler knows<br>&gt;&gt;&gt;&gt;&gt; about the built-in floating-point types (Float, Double, Float80) and their<br>&gt;&gt;&gt;&gt;&gt; aliases (CGFloat, etc) and can fuse the two comparisons into a single<br>&gt;&gt;&gt;&gt;&gt; hardware operation.  However, for soft-float types, without a<br>&gt;&gt;&gt;&gt;&gt; lessThanOrEqual method, there is no single comparison that the compiler<br>&gt;&gt;&gt;&gt;&gt; could fuse these to.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In some cases, if they are simple enough, the compiler may be able to<br>&gt;&gt;&gt;&gt;&gt; actually fuse the bodies of the two comparison operations, but we can’t<br>&gt;&gt;&gt;&gt;&gt; reasonably depend on that happening or even being possible in all cases.<br>&gt;&gt;&gt;&gt;&gt; So for performance, it’s important that there be an actual less than or<br>&gt;&gt;&gt;&gt;&gt; equal to method.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/7135ddae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
