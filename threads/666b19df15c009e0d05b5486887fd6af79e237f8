<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 07:00:00am</p></header><div class="content"><p>Hi there,<br></p><p>I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br></p><p>And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br></p><p>While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br></p><p>This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br></p><p>a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br></p><p>b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br></p><p>I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br></p><p>Sincerely yours,<br></p><p>Krystof Vasa<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 18, 2016 at 11:00:00am</p></header><div class="content"><p>I’ve been wondering if shadowing variable names should just be an error. I know that it’s a very common pattern when unwrapping such as:<br></p><p>if let thing = thing {}<br></p><p>But that not only looks ugly, there’s often better ways to solve this and using different names there would also likely improve clarity anyway. Wouldn’t an error when shadowing any variable name also have prevented this bug without requiring self since there would have been no way for there to be a local variable with the same name? Would that be too restrictive or would it actually further Swift&#39;s goals of clarity and safety? I think I could probably argue that making shadowed names a straight up error would improve code quality.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On May 18, 2016, at 12:09 AM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt; <br>&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt; <br>&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt; <br>&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt; <br>&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt; <br>&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt; <br>&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt; <br>&gt; Sincerely yours,<br>&gt; <br>&gt; Krystof Vasa<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>There&#39;s shadowing and shadowing.<br></p><p>With instance variables, making this an error isn&#39;t a great idea. This will lead to people using &quot;localTableView&quot; instead of just &quot;tableView&quot; which IMHO leads to a code that&#39;s not easily readable. In 90% of cases, the issue is that you use something very generic such as the tableView, result, response, etc. How to name it to make more sense? localTableView? myResult, resultOfThisFunction?<br></p><p>BTW the issue I&#39;ve mentioned earlier that I was chasing for two hours was due to refactoring - I was refactoring a larger method into several smaller ones - and you don&#39;t retype the code, you copy-paste it (darn you, copy paste!). And I had a local variable that was incidently the same name as instance variable - and the compiler compiled it since `self` was not required. These kinds of things are then bugs hard to catch and IMHO this is not in line with Swift emphasizing compile-time safety (even though this is not related to type-safety).<br></p><p>I believe that making the proposal an optional warning you can turn on/off on the compiler will satisfy both camps - it will not be required for those who do not want this &quot;safety&quot;, yet those who wish to keep on the safe side would simply turn this on.<br></p><p>Krystof<br></p><p>&gt; On May 18, 2016, at 6:13 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been wondering if shadowing variable names should just be an error. I know that it’s a very common pattern when unwrapping such as:<br>&gt; <br>&gt; if let thing = thing {}<br>&gt; <br>&gt; But that not only looks ugly, there’s often better ways to solve this and using different names there would also likely improve clarity anyway. Wouldn’t an error when shadowing any variable name also have prevented this bug without requiring self since there would have been no way for there to be a local variable with the same name? Would that be too restrictive or would it actually further Swift&#39;s goals of clarity and safety? I think I could probably argue that making shadowed names a straight up error would improve code quality.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:09 AM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>May 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Perhaps a better approach to the shadow variables problem is to enable the objc compiler flag -Wshadow   to be available in Swift. <br></p><p>In the same way a &quot;requiring self&quot; compiler flag should help enforce self on the programer by always showing a warning when the flag is on. <br></p><p><br></p><p><br></p><p>&gt; On May 18, 2016, at 9:13 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been wondering if shadowing variable names should just be an error. I know that it’s a very common pattern when unwrapping such as:<br>&gt; <br>&gt; if let thing = thing {}<br>&gt; <br>&gt; But that not only looks ugly, there’s often better ways to solve this and using different names there would also likely improve clarity anyway. Wouldn’t an error when shadowing any variable name also have prevented this bug without requiring self since there would have been no way for there to be a local variable with the same name? Would that be too restrictive or would it actually further Swift&#39;s goals of clarity and safety? I think I could probably argue that making shadowed names a straight up error would improve code quality.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:09 AM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/8ffcd6ef/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Fully support your opinion. +1 for warning option.<br>Also, I believe we need a warning (not error as suggested by @Sean in reply <br>to this thread) when type&#39;s property shadowed with local variable.<br></p><p>Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br></p><p>class A {<br>     var x = 100<br></p><p>     func f() {<br>         let x = 10<br>         print(x)<br>     }<br>}<br></p><p><br>On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt; Hi there,<br>&gt;<br>&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;<br>&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;<br>&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;<br>&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;<br>&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;<br>&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;<br>&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;<br>&gt; Sincerely yours,<br>&gt;<br>&gt; Krystof Vasa<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>For this, maybe. But consider e.g. UITableViewDelegate methods. They have a &quot;tableView&quot; variable within the method parameters.<br></p><p>When you implement this on UITableViewController, you get automatically a shadowed variable:<br></p><p>class MyController: UITableViewController {<br></p><p>	func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {<br>		/// tableView here can mean both self.tableView and tableView in the method parameters<br>	}<br></p><p>}<br></p><p>So making variable shadowing warnings/errors isn&#39;t as easy. You&#39;d then need to make it something like:<br></p><p>func tableView(aTableView: UITableView, ...) { <br>	aTableView.reloadData()<br>}<br></p><p><br>BTW there is a compiler warning for shadowed variabled in LLVM (-Wshadow). But it doesn&#39;t seem to be working with Swift.<br></p><p>&gt; On May 18, 2016, at 6:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Fully support your opinion. +1 for warning option.<br>&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt; <br>&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt; <br>&gt; class A {<br>&gt;    var x = 100<br>&gt; <br>&gt;    func f() {<br>&gt;        let x = 10<br>&gt;        print(x)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Hm.. can&#39;t check right now.. But can&#39;t we change `tableView` parameter name <br>as it is internal name for parameter<br></p><p>func tableView(*theTableView*: UITableView, didSelectRowAtIndexPath <br>indexPath: NSIndexPath) {<br>}<br></p><p>In any case, I think the problem with shadowing exists and IMO Swift will <br>be better if we&#39;ll have some rules about it.<br></p><p>On 18.05.2016 19:51, Krystof Vasa wrote:<br>&gt; For this, maybe. But consider e.g. UITableViewDelegate methods. They have a &quot;tableView&quot; variable within the method parameters.<br>&gt;<br>&gt; When you implement this on UITableViewController, you get automatically a shadowed variable:<br>&gt;<br>&gt; class MyController: UITableViewController {<br>&gt;<br>&gt; 	func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {<br>&gt; 		/// tableView here can mean both self.tableView and tableView in the method parameters<br>&gt; 	}<br>&gt;<br>&gt; }<br>&gt;<br>&gt; So making variable shadowing warnings/errors isn&#39;t as easy. You&#39;d then need to make it something like:<br>&gt;<br>&gt; func tableView(aTableView: UITableView, ...) {<br>&gt; 	aTableView.reloadData()<br>&gt; }<br>&gt;<br>&gt;<br>&gt; BTW there is a compiler warning for shadowed variabled in LLVM (-Wshadow). But it doesn&#39;t seem to be working with Swift.<br>&gt;<br>&gt;&gt; On May 18, 2016, at 6:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Fully support your opinion. +1 for warning option.<br>&gt;&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt;&gt;<br>&gt;&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt;&gt;<br>&gt;&gt; class A {<br>&gt;&gt;    var x = 100<br>&gt;&gt;<br>&gt;&gt;    func f() {<br>&gt;&gt;        let x = 10<br>&gt;&gt;        print(x)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt;&gt; Hi there,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sincerely yours,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Krystof Vasa<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 18, 2016 at 01:00:00pm</p></header><div class="content"><p>I always thought that requiring self everywhere was a red herring, and that what was really needed was clearer use of shadowing. But “if let x = x” is a case of the developer asking for shadowing. So either:<br>- shadowing only causes warnings in some places and is allowed in others (and has a way to indicate intent to turn off warnings)<br>- shadowing is disallowed everywhere, and “if let” has some terse syntax to indicate intent.<br></p><p>-DW<br>&gt; On May 18, 2016, at 10:39 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Fully support your opinion. +1 for warning option.<br>&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt; <br>&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt; <br>&gt; class A {<br>&gt;    var x = 100<br>&gt; <br>&gt;    func f() {<br>&gt;        let x = 10<br>&gt;        print(x)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>See my example with the tableView and the UITableViewDelegate on UITableViewController. `if let x = x` isn&#39;t the usual case. The usual case is that you have e.g. tableView instance on the class and a method that takes a tableView parameter. Then you change the method signature not to include the parameter and the code still compiles, since the tableView reference now goes to the instance variable, which is wrong.<br></p><p>I agree that shadowing variables is not a good idea, but I stand by my point that it&#39;s potentially dangerous and error-prone to allow accessing instance variables without `self`.<br></p><p>Krystof<br></p><p><br>&gt; On May 18, 2016, at 9:36 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; I always thought that requiring self everywhere was a red herring, and that what was really needed was clearer use of shadowing. But “if let x = x” is a case of the developer asking for shadowing. So either:<br>&gt; - shadowing only causes warnings in some places and is allowed in others (and has a way to indicate intent to turn off warnings)<br>&gt; - shadowing is disallowed everywhere, and “if let” has some terse syntax to indicate intent.<br>&gt; <br>&gt; -DW<br>&gt;&gt; On May 18, 2016, at 10:39 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Fully support your opinion. +1 for warning option.<br>&gt;&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt;&gt; <br>&gt;&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt;   var x = 100<br>&gt;&gt; <br>&gt;&gt;   func f() {<br>&gt;&gt;       let x = 10<br>&gt;&gt;       print(x)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt;&gt; Hi there,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely yours,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Krystof Vasa<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:43 PM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt; <br>&gt; See my example with the tableView and the UITableViewDelegate on UITableViewController. `if let x = x` isn&#39;t the usual case. The usual case is that you have e.g. tableView instance on the class and a method that takes a tableView parameter.<br>That would be shadowing.<br></p><p>&gt; Then you change the method signature not to include the parameter and the code still compiles, since the tableView reference now goes to the instance variable, which is wrong.<br>If the annotation/keyword behaved similar to ‘override’, then you would either have a shadowing warning before saying that there was shadowing, or afterward saying that you are using the annotation/keyword when shadowing isn’t happening.<br></p><p>&gt; <br>&gt; I agree that shadowing variables is not a good idea, but I stand by my point that it&#39;s potentially dangerous and error-prone to allow accessing instance variables without `self`.<br>&gt; <br>&gt; Krystof<br>&gt; <br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; See my example with the tableView and the UITableViewDelegate on UITableViewController. `if let x = x` isn&#39;t the usual case. The usual case is that you have e.g. tableView instance on the class and a method that takes a tableView parameter.<br>&gt; That would be shadowing.<br></p><p>Yes, of course. But if you mark shadowing as error/warning, you need to update dozens if not hundreds of places in your projects since most default argument names in UITableViewController shadow the tableView instance variable.<br></p><p>&gt;&gt; Then you change the method signature not to include the parameter and the code still compiles, since the tableView reference now goes to the instance variable, which is wrong.<br>&gt; If the annotation/keyword behaved similar to ‘override’, then you would either have a shadowing warning before saying that there was shadowing, or afterward saying that you are using the annotation/keyword when shadowing isn’t happening.<br></p><p>That was just an example - I&#39;ve written in another email here that the issue I was describing occurred during refactoring a larger method into smaller ones - you retype the code, you copy-paste it. And since reference to an instance variable without refering to self is fine, it may compile even though the semantics changed.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by my point that it&#39;s potentially dangerous and error-prone to allow accessing instance variables without `self`.<br>&gt;&gt; <br>&gt;&gt; Krystof<br>&gt;&gt; <br>&gt; <br>&gt; -DW<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>On 19.05.2016 0:09, Krystof Vasa via swift-evolution wrote:<br>&gt; Yes, of course. But if you mark shadowing as error/warning, you need to<br>&gt; update dozens if not hundreds of places in your projects since most<br>&gt; default argument names in UITableViewController shadow the tableView<br>&gt; instance variable.<br></p><p>I believe no sense to discuss *error* on shadowing - seems like almost no <br>one is supporting error in this case.<br></p><p>But as for *warning*, I see that we have 3 options in this situation:<br>1. Live with silence shadowing of `tableView` and with possible bugs <br>because of this (no warnings)<br>2. Have warnings in our project regarding shadowing of tableView, and do <br>nothing with them(or probably we need a feature to ignore some specific <br>warnings in project once and forever). Project still can be compiled.<br>3. Rename each `tableView` in such places (or probably we need some <br>customization of what name XCode will use when appends this method) as you <br>don&#39;t want warnings and don&#39;t want to shadow property.<br></p><p>IMO the best solution here: option in compiler/settings, where one can <br>decide if he/she needs warnings in this case.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt; I agree that shadowing variables is not a good idea, but I stand by my<br>&gt; point that it&#39;s potentially dangerous and error-prone to allow accessing<br>&gt; instance variables without `self`.<br></p><p>Could we all agree that we need these options:<br>1. option to turn on warnings on accessing instance variables without `self`<br>2. option to turn on warnings on shadowing<br>And that by default, none of that options should be enabled.<br>?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 19, 2016 at 11:00:00am</p></header><div class="content"><p>I believe the Swift Team has previously stated they do not want opt-in warnings defining alternate swift ‘grammars’. I don’t believe there are any existing -W flags for the compiler, for instance.<br></p><p>If there is shadowing warning added, I’m of the opinion it should work similar to the override keyword.<br></p><p>-DW<br></p><p>&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by my<br>&gt;&gt; point that it&#39;s potentially dangerous and error-prone to allow accessing<br>&gt;&gt; instance variables without `self`.<br>&gt; <br>&gt; Could we all agree that we need these options:<br>&gt; 1. option to turn on warnings on accessing instance variables without `self`<br>&gt; 2. option to turn on warnings on shadowing<br>&gt; And that by default, none of that options should be enabled.<br>&gt; ?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 19, 2016 at 01:00:00pm</p></header><div class="content"><p>I think it is too easy to just add warnings for warts and call it a day. These problems, IMO, should be addressed somehow eventually - but not with a warning. Either Swift decides these situations are errors and refuses to enable them at all, or the constructs involved should be carefully reconsidered and changed to prevent them from even happening or being encouraged in the first place.<br></p><p>So in short: I too do not agree to adding optional warnings. :)<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On May 19, 2016, at 12:58 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe the Swift Team has previously stated they do not want opt-in warnings defining alternate swift ‘grammars’. I don’t believe there are any existing -W flags for the compiler, for instance.<br>&gt; <br>&gt; If there is shadowing warning added, I’m of the opinion it should work similar to the override keyword.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by my<br>&gt;&gt;&gt; point that it&#39;s potentially dangerous and error-prone to allow accessing<br>&gt;&gt;&gt; instance variables without `self`.<br>&gt;&gt; <br>&gt;&gt; Could we all agree that we need these options:<br>&gt;&gt; 1. option to turn on warnings on accessing instance variables without `self`<br>&gt;&gt; 2. option to turn on warnings on shadowing<br>&gt;&gt; And that by default, none of that options should be enabled.<br>&gt;&gt; ?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>Is the status quo in this honey moon phase better?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 May 2016, at 19:12, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it is too easy to just add warnings for warts and call it a day. These problems, IMO, should be addressed somehow eventually - but not with a warning. Either Swift decides these situations are errors and refuses to enable them at all, or the constructs involved should be carefully reconsidered and changed to prevent them from even happening or being encouraged in the first place.<br>&gt; <br>&gt; So in short: I too do not agree to adding optional warnings. :)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On May 19, 2016, at 12:58 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe the Swift Team has previously stated they do not want opt-in warnings defining alternate swift ‘grammars’. I don’t believe there are any existing -W flags for the compiler, for instance.<br>&gt;&gt; <br>&gt;&gt; If there is shadowing warning added, I’m of the opinion it should work similar to the override keyword.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt;&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by my<br>&gt;&gt;&gt;&gt; point that it&#39;s potentially dangerous and error-prone to allow accessing<br>&gt;&gt;&gt;&gt; instance variables without `self`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could we all agree that we need these options:<br>&gt;&gt;&gt; 1. option to turn on warnings on accessing instance variables without `self`<br>&gt;&gt;&gt; 2. option to turn on warnings on shadowing<br>&gt;&gt;&gt; And that by default, none of that options should be enabled.<br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Oh, in this case IMO warning for &#39;self.&#39; will never be introduced, it&#39;s <br>clear. And as I understand, no support in community for warning for <br>shadowing. OK, so as I understand, the only solution here - tools like <br>SwiftLint and plugins to xcode.<br></p><p>Btw, regarding &#39;similar to the override keyword&#39;, do you mean something <br>like this:<br></p><p>class A {<br>   public var x = 10<br></p><p>   func f() {<br>     override var x = 100<br></p><p>     var value: Int? = 1<br>     if override let value = value {..}<br>   }<br>}<br></p><p>?<br></p><p>On 19.05.2016 20:58, David Waite wrote:<br>&gt; I believe the Swift Team has previously stated they do not want opt-in<br>&gt; warnings defining alternate swift ‘grammars’. I don’t believe there are<br>&gt; any existing -W flags for the compiler, for instance.<br>&gt;<br>&gt; If there is shadowing warning added, I’m of the opinion it should work<br>&gt; similar to the override keyword.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by<br>&gt;&gt;&gt; my point that it&#39;s potentially dangerous and error-prone to allow<br>&gt;&gt;&gt; accessing instance variables without `self`.<br>&gt;&gt;<br>&gt;&gt; Could we all agree that we need these options: 1. option to turn on<br>&gt;&gt; warnings on accessing instance variables without `self` 2. option to<br>&gt;&gt; turn on warnings on shadowing And that by default, none of that<br>&gt;&gt; options should be enabled. ?<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Well, SE-0009 is not related to shadowing, is it? I think it is something completely different.<br></p><p>The problem that SE-0009 tries to solve is that when looking at a line in isolation, like<br></p><p>    print(foo)<br></p><p>there is no way to tell wether foo is an iVar, a local var or a parameter. This can happen if you don&#39;t remember the names of all iVars of a class. A warning on shadowing will not help here at all. I think shadowing is not bad, and if someone wants to disallow shadowing, he should make another proposal. After all, if I add another iVar to a class, I want it to still compile. With shadowing disallowed, I may give an iVar the same name as the local variable in some of the methods.<br></p><p>Regarding the original SE-0009, I think it is better to use syntax highlighting for this. Xcode already does it well: local vars are black, other vars have some color (with the &quot;Default&quot; syntax highlighting theme).<br></p><p>I know not everyone is using Xcode. But anyways, coding without an IDE is always painful if the program you write has more than 500 lines. And for any IDE that has autocompletion and something like the &quot;Jump to symbol&quot; feature of Xcode, implementing syntax highlighting right is not that hard. Omitting &quot;self&quot; is convenient, and the problems arising from it are not so bad that &quot;self&quot; should be made mandatory IMO.<br></p><p>-Michael<br></p><p>&gt; Am 19.05.2016 um 20:12 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Oh, in this case IMO warning for &#39;self.&#39; will never be introduced, it&#39;s clear. And as I understand, no support in community for warning for shadowing. OK, so as I understand, the only solution here - tools like SwiftLint and plugins to xcode.<br>&gt; <br>&gt; Btw, regarding &#39;similar to the override keyword&#39;, do you mean something like this:<br>&gt; <br>&gt; class A {<br>&gt;  public var x = 10<br>&gt; <br>&gt;  func f() {<br>&gt;    override var x = 100<br>&gt; <br>&gt;    var value: Int? = 1<br>&gt;    if override let value = value {..}<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; On 19.05.2016 20:58, David Waite wrote:<br>&gt;&gt; I believe the Swift Team has previously stated they do not want opt-in<br>&gt;&gt; warnings defining alternate swift ‘grammars’. I don’t believe there are<br>&gt;&gt; any existing -W flags for the compiler, for instance.<br>&gt;&gt; <br>&gt;&gt; If there is shadowing warning added, I’m of the opinion it should work<br>&gt;&gt; similar to the override keyword.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt;&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by<br>&gt;&gt;&gt;&gt; my point that it&#39;s potentially dangerous and error-prone to allow<br>&gt;&gt;&gt;&gt; accessing instance variables without `self`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could we all agree that we need these options: 1. option to turn on<br>&gt;&gt;&gt; warnings on accessing instance variables without `self` 2. option to<br>&gt;&gt;&gt; turn on warnings on shadowing And that by default, none of that<br>&gt;&gt;&gt; options should be enabled. ?<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 2:15 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The problem that SE-0009 tries to solve is that when looking at a line in isolation, like<br>&gt; <br>&gt;    print(foo)<br>&gt; <br>&gt; there is no way to tell wether foo is an iVar, a local var or a parameter.<br></p><p>Or whether print() is going to log something to the console, or open up the OS’s Print sheet.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/3047947e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 19, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree that it shouldn&#39;t be mandatory, but voluntary, even though I do not support it. E.g. looking at git diffs will always be cleared with self. - there&#39;s not syntax highlighting there.<br></p><p>What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br></p><p>Since the self. usage is not mandatory, yet is supported (no one is stopping anyone from using it), I don&#39;t see a reason why there shouldn&#39;t be a compiler option to help people who&#39;d like to use this to enforce it; which would make both camps happy.<br></p><p>When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br></p><p>I don&#39;t see this option harming anyone - it&#39;d be only helping people wanting to have safer codebase.<br></p><p>Krystof<br></p><p>&gt; On May 19, 2016, at 9:15 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, SE-0009 is not related to shadowing, is it? I think it is something completely different.<br>&gt; <br>&gt; The problem that SE-0009 tries to solve is that when looking at a line in isolation, like<br>&gt; <br>&gt;    print(foo)<br>&gt; <br>&gt; there is no way to tell wether foo is an iVar, a local var or a parameter. This can happen if you don&#39;t remember the names of all iVars of a class. A warning on shadowing will not help here at all. I think shadowing is not bad, and if someone wants to disallow shadowing, he should make another proposal. After all, if I add another iVar to a class, I want it to still compile. With shadowing disallowed, I may give an iVar the same name as the local variable in some of the methods.<br>&gt; <br>&gt; Regarding the original SE-0009, I think it is better to use syntax highlighting for this. Xcode already does it well: local vars are black, other vars have some color (with the &quot;Default&quot; syntax highlighting theme).<br>&gt; <br>&gt; I know not everyone is using Xcode. But anyways, coding without an IDE is always painful if the program you write has more than 500 lines. And for any IDE that has autocompletion and something like the &quot;Jump to symbol&quot; feature of Xcode, implementing syntax highlighting right is not that hard. Omitting &quot;self&quot; is convenient, and the problems arising from it are not so bad that &quot;self&quot; should be made mandatory IMO.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 19.05.2016 um 20:12 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Oh, in this case IMO warning for &#39;self.&#39; will never be introduced, it&#39;s clear. And as I understand, no support in community for warning for shadowing. OK, so as I understand, the only solution here - tools like SwiftLint and plugins to xcode.<br>&gt;&gt; <br>&gt;&gt; Btw, regarding &#39;similar to the override keyword&#39;, do you mean something like this:<br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt; public var x = 10<br>&gt;&gt; <br>&gt;&gt; func f() {<br>&gt;&gt;   override var x = 100<br>&gt;&gt; <br>&gt;&gt;   var value: Int? = 1<br>&gt;&gt;   if override let value = value {..}<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; On 19.05.2016 20:58, David Waite wrote:<br>&gt;&gt;&gt; I believe the Swift Team has previously stated they do not want opt-in<br>&gt;&gt;&gt; warnings defining alternate swift ‘grammars’. I don’t believe there are<br>&gt;&gt;&gt; any existing -W flags for the compiler, for instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there is shadowing warning added, I’m of the opinion it should work<br>&gt;&gt;&gt; similar to the override keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 19, 2016, at 11:28 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18.05.2016 22:43, Krystof Vasa wrote:<br>&gt;&gt;&gt;&gt;&gt; I agree that shadowing variables is not a good idea, but I stand by<br>&gt;&gt;&gt;&gt;&gt; my point that it&#39;s potentially dangerous and error-prone to allow<br>&gt;&gt;&gt;&gt;&gt; accessing instance variables without `self`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could we all agree that we need these options: 1. option to turn on<br>&gt;&gt;&gt;&gt; warnings on accessing instance variables without `self` 2. option to<br>&gt;&gt;&gt;&gt; turn on warnings on shadowing And that by default, none of that<br>&gt;&gt;&gt;&gt; options should be enabled. ?<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br></p><p>&gt; When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br></p><p>Clang has lots of these kinds of warning flags, but so far, Swift does not. This is not an accident—it&#39;s a deliberate design. We don&#39;t want dragging a file between projects, or otherwise moving it from one context to another, to suddenly make it emit errors or warnings. There should not be dialects of Swift; there should be one Swift that everyone writes in.<br></p><p>However, that necessarily means that we can&#39;t provide a lot of configurability in terms of warnings. If every warning needs to be on for every file, then we need to choose warnings which have a high signal, and we need to have ways to disable them merely by editing code without changing its semantics (like by adding extra parentheses). This limits the kinds of warnings we can provide: we can&#39;t really warn about subjective style issues. Even the &quot;unnecessary var&quot; and &quot;why don&#39;t you assign to _?&quot; warnings are toeing the line of acceptable noisiness in Swift diagnostics.<br></p><p>So because of the philosophy behind Swift&#39;s error and warning design, we can&#39;t really support things like an &quot;implicit self&quot; warning. It quite simply runs counter to the language&#39;s goals. That&#39;s why we&#39;re interested in robust linting and formatting tools. Swift is packaged as a library not merely because it&#39;s a cleaner design, but also because it makes it easier to build accurate tools like these, things that can help fill in the gaps in Swift&#39;s own tooling.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 20, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Brent and Krystof,<br></p><p>The proposal brought a lot of interesting discussions, but in the end, I think the right choice was made. It fits the Swift philosophy and rational, both in terms of the decision concerning the self. and concerning not having a warning. It took some time for me to try and adapt to not using self everywhere, but it is an interesting change.<br></p><p>David.<br></p><p>&gt; On 20 May 2016, at 00:00, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br>&gt; <br>&gt;&gt; When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br>&gt; <br>&gt; Clang has lots of these kinds of warning flags, but so far, Swift does not. This is not an accident—it&#39;s a deliberate design. We don&#39;t want dragging a file between projects, or otherwise moving it from one context to another, to suddenly make it emit errors or warnings. There should not be dialects of Swift; there should be one Swift that everyone writes in.<br>&gt; <br>&gt; However, that necessarily means that we can&#39;t provide a lot of configurability in terms of warnings. If every warning needs to be on for every file, then we need to choose warnings which have a high signal, and we need to have ways to disable them merely by editing code without changing its semantics (like by adding extra parentheses). This limits the kinds of warnings we can provide: we can&#39;t really warn about subjective style issues. Even the &quot;unnecessary var&quot; and &quot;why don&#39;t you assign to _?&quot; warnings are toeing the line of acceptable noisiness in Swift diagnostics.<br>&gt; <br>&gt; So because of the philosophy behind Swift&#39;s error and warning design, we can&#39;t really support things like an &quot;implicit self&quot; warning. It quite simply runs counter to the language&#39;s goals. That&#39;s why we&#39;re interested in robust linting and formatting tools. Swift is packaged as a library not merely because it&#39;s a cleaner design, but also because it makes it easier to build accurate tools like these, things that can help fill in the gaps in Swift&#39;s own tooling.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 20, 2016 at 06:00:00am</p></header><div class="content"><p>From the rejection rationale:<br></p><p>&gt; * Individuals or teams that feel that explicit “self.” is beneficial for their own code bases can enforce such a coding convention via tooling with the status quo. If this proposal were accepted, those opposed to the proposal would effectively have no recourse because the language itself would be enforcing “self.”.<br></p><p>With which I agree, giving the final decision to the user/team. This which pretty much means that teams and individuals such as myself will continue using the explicit self to keep on the safe side. However, the explicit self won&#39;t prevent you from the class of bugs refering to an instance variable/method by mistake unless there&#39;s a warning for not using the explicit self.<br></p><p>Swift is designed (from what I understand) to become much more than just a language for &quot;apps on the AppStore&quot;, i.e. something that could be used in medicine, military, etc. - in applications where code-safety is the number one priority since discovering bugs in production can have lethal consequences - and the current ambiguity of being able to refer to instance members without self is IMHO undermining Swift in this kind of usage.<br></p><p>When you take a look at some of the more sensitive projects (in C/C++), they have most of the non-standard warnings turned on to prevent bugs at compile time - which is another aspect of Swift that is held up high, yet this is a place nasty bugs (in my experience) happen a lot (as per my original email here, I spent 2 hours debugging an app after refactoring a few larger methods into smaller ones) - and this is simply not acceptible e.g. for NASA usage (not saying NASA will be using Swift, just giving an example).<br></p><p>Krystof<br></p><p><br>&gt; On May 20, 2016, at 12:00 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br>&gt; <br>&gt;&gt; When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br>&gt; <br>&gt; Clang has lots of these kinds of warning flags, but so far, Swift does not. This is not an accident—it&#39;s a deliberate design. We don&#39;t want dragging a file between projects, or otherwise moving it from one context to another, to suddenly make it emit errors or warnings. There should not be dialects of Swift; there should be one Swift that everyone writes in.<br>&gt; <br>&gt; However, that necessarily means that we can&#39;t provide a lot of configurability in terms of warnings. If every warning needs to be on for every file, then we need to choose warnings which have a high signal, and we need to have ways to disable them merely by editing code without changing its semantics (like by adding extra parentheses). This limits the kinds of warnings we can provide: we can&#39;t really warn about subjective style issues. Even the &quot;unnecessary var&quot; and &quot;why don&#39;t you assign to _?&quot; warnings are toeing the line of acceptable noisiness in Swift diagnostics.<br>&gt; <br>&gt; So because of the philosophy behind Swift&#39;s error and warning design, we can&#39;t really support things like an &quot;implicit self&quot; warning. It quite simply runs counter to the language&#39;s goals. That&#39;s why we&#39;re interested in robust linting and formatting tools. Swift is packaged as a library not merely because it&#39;s a cleaner design, but also because it makes it easier to build accurate tools like these, things that can help fill in the gaps in Swift&#39;s own tooling.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 20, 2016 at 07:00:00am</p></header><div class="content"><p>Agreed, this is a topic that needs to be properly solved.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 20 May 2016, at 05:34, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From the rejection rationale:<br>&gt; <br>&gt;&gt; * Individuals or teams that feel that explicit “self.” is beneficial for their own code bases can enforce such a coding convention via tooling with the status quo. If this proposal were accepted, those opposed to the proposal would effectively have no recourse because the language itself would be enforcing “self.”.<br>&gt; <br>&gt; With which I agree, giving the final decision to the user/team. This which pretty much means that teams and individuals such as myself will continue using the explicit self to keep on the safe side. However, the explicit self won&#39;t prevent you from the class of bugs refering to an instance variable/method by mistake unless there&#39;s a warning for not using the explicit self.<br>&gt; <br>&gt; Swift is designed (from what I understand) to become much more than just a language for &quot;apps on the AppStore&quot;, i.e. something that could be used in medicine, military, etc. - in applications where code-safety is the number one priority since discovering bugs in production can have lethal consequences - and the current ambiguity of being able to refer to instance members without self is IMHO undermining Swift in this kind of usage.<br>&gt; <br>&gt; When you take a look at some of the more sensitive projects (in C/C++), they have most of the non-standard warnings turned on to prevent bugs at compile time - which is another aspect of Swift that is held up high, yet this is a place nasty bugs (in my experience) happen a lot (as per my original email here, I spent 2 hours debugging an app after refactoring a few larger methods into smaller ones) - and this is simply not acceptible e.g. for NASA usage (not saying NASA will be using Swift, just giving an example).<br>&gt; <br>&gt; Krystof<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 12:00 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br>&gt;&gt; <br>&gt;&gt;&gt; When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br>&gt;&gt; <br>&gt;&gt; Clang has lots of these kinds of warning flags, but so far, Swift does not. This is not an accident—it&#39;s a deliberate design. We don&#39;t want dragging a file between projects, or otherwise moving it from one context to another, to suddenly make it emit errors or warnings. There should not be dialects of Swift; there should be one Swift that everyone writes in.<br>&gt;&gt; <br>&gt;&gt; However, that necessarily means that we can&#39;t provide a lot of configurability in terms of warnings. If every warning needs to be on for every file, then we need to choose warnings which have a high signal, and we need to have ways to disable them merely by editing code without changing its semantics (like by adding extra parentheses). This limits the kinds of warnings we can provide: we can&#39;t really warn about subjective style issues. Even the &quot;unnecessary var&quot; and &quot;why don&#39;t you assign to _?&quot; warnings are toeing the line of acceptable noisiness in Swift diagnostics.<br>&gt;&gt; <br>&gt;&gt; So because of the philosophy behind Swift&#39;s error and warning design, we can&#39;t really support things like an &quot;implicit self&quot; warning. It quite simply runs counter to the language&#39;s goals. That&#39;s why we&#39;re interested in robust linting and formatting tools. Swift is packaged as a library not merely because it&#39;s a cleaner design, but also because it makes it easier to build accurate tools like these, things that can help fill in the gaps in Swift&#39;s own tooling.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>I have created a proposal for making the self. optional warning. It can be viewed here:<br></p><p>https://github.com/charlieMonroe/swift-evolution/blob/master/proposals/xxxx-optional-warning-for-explicit-self.md<br></p><p>Does anyone see a downside to this solution, having it an optional warning?<br></p><p><br>&gt; On May 20, 2016, at 8:36 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Agreed, this is a topic that needs to be properly solved.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 20 May 2016, at 05:34, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the rejection rationale:<br>&gt;&gt; <br>&gt;&gt;&gt; * Individuals or teams that feel that explicit “self.” is beneficial for their own code bases can enforce such a coding convention via tooling with the status quo. If this proposal were accepted, those opposed to the proposal would effectively have no recourse because the language itself would be enforcing “self.”.<br>&gt;&gt; <br>&gt;&gt; With which I agree, giving the final decision to the user/team. This which pretty much means that teams and individuals such as myself will continue using the explicit self to keep on the safe side. However, the explicit self won&#39;t prevent you from the class of bugs refering to an instance variable/method by mistake unless there&#39;s a warning for not using the explicit self.<br>&gt;&gt; <br>&gt;&gt; Swift is designed (from what I understand) to become much more than just a language for &quot;apps on the AppStore&quot;, i.e. something that could be used in medicine, military, etc. - in applications where code-safety is the number one priority since discovering bugs in production can have lethal consequences - and the current ambiguity of being able to refer to instance members without self is IMHO undermining Swift in this kind of usage.<br>&gt;&gt; <br>&gt;&gt; When you take a look at some of the more sensitive projects (in C/C++), they have most of the non-standard warnings turned on to prevent bugs at compile time - which is another aspect of Swift that is held up high, yet this is a place nasty bugs (in my experience) happen a lot (as per my original email here, I spent 2 hours debugging an app after refactoring a few larger methods into smaller ones) - and this is simply not acceptible e.g. for NASA usage (not saying NASA will be using Swift, just giving an example).<br>&gt;&gt; <br>&gt;&gt; Krystof<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 12:00 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I don&#39;t understand is why can&#39;t this be an option. There are two camps, each advocating either preferences and each camp is quite vocal about it. Why not let the user decide? Hence my proposal to make it an optional warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you take a look at all the LLVM warnings options, there are things people usually don&#39;t have enabled, but advanced users or users who prefer safer code, can enable them. E.g. -Wfour-char-constants for warning about four-char OSTypes, etc. (just go through them in Xcode build settings).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clang has lots of these kinds of warning flags, but so far, Swift does not. This is not an accident—it&#39;s a deliberate design. We don&#39;t want dragging a file between projects, or otherwise moving it from one context to another, to suddenly make it emit errors or warnings. There should not be dialects of Swift; there should be one Swift that everyone writes in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, that necessarily means that we can&#39;t provide a lot of configurability in terms of warnings. If every warning needs to be on for every file, then we need to choose warnings which have a high signal, and we need to have ways to disable them merely by editing code without changing its semantics (like by adding extra parentheses). This limits the kinds of warnings we can provide: we can&#39;t really warn about subjective style issues. Even the &quot;unnecessary var&quot; and &quot;why don&#39;t you assign to _?&quot; warnings are toeing the line of acceptable noisiness in Swift diagnostics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So because of the philosophy behind Swift&#39;s error and warning design, we can&#39;t really support things like an &quot;implicit self&quot; warning. It quite simply runs counter to the language&#39;s goals. That&#39;s why we&#39;re interested in robust linting and formatting tools. Swift is packaged as a library not merely because it&#39;s a cleaner design, but also because it makes it easier to build accurate tools like these, things that can help fill in the gaps in Swift&#39;s own tooling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 21, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 21, 2016, at 5:30 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have created a proposal for making the self. optional warning. It can be viewed here:<br>&gt; <br>&gt; https://github.com/charlieMonroe/swift-evolution/blob/master/proposals/xxxx-optional-warning-for-explicit-self.md<br>&gt; <br>&gt; Does anyone see a downside to this solution, having it an optional warning?<br></p><p>I suspect the only issue is that there are lots of things that people would want to have as optional warnings, and it might be hard to justify why this optional warning is more important than other optional warnings all of which would benefit the user. In previous conversations, I believe &quot;can it be linted?&quot; has been proposed as the question to be asked for this kind of thing.<br></p><p>I haven&#39;t paid attention very closely to most of these conversations and I did vote against an explicit self requirement.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 21, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 21, 2016, at 7:22 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 21, 2016, at 5:30 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have created a proposal for making the self. optional warning. It can be viewed here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/charlieMonroe/swift-evolution/blob/master/proposals/xxxx-optional-warning-for-explicit-self.md<br>&gt;&gt; <br>&gt;&gt; Does anyone see a downside to this solution, having it an optional warning?<br>&gt; <br>&gt; I suspect the only issue is that there are lots of things that people would want to have as optional warnings, and it might be hard to justify why this optional warning is more important than other optional warnings all of which would benefit the user. In previous conversations, I believe &quot;can it be linted?&quot; has been proposed as the question to be asked for this kind of thing.<br>&gt; <br>&gt; I haven&#39;t paid attention very closely to most of these conversations and I did vote against an explicit self requirement.<br>&gt; <br>&gt; -- E<br></p><p>I believe the Swift team has taken a stance that there should be no optional warnings.  Notice the absence of any optional warning flags today reported by the swift compiler.<br></p><p>The warnings have to meet a suitably high bar such that the code changes to disable the warning make the code clearer. For an example, @warn_unusued_result functions give a warning unless you assign to underscore, e.g.<br></p><p>	_ = list.sort()<br></p><p>On the other hand, “require every reference to be fully qualified” sounds more like something to add to a project like SwiftLint. I subjectively state that littering my methods with redundant “self” references makes the logic of my code harder to digest.<br></p><p>This is why I was suggesting earlier in this thread to focus on warnings when variables and methods are being shadowed, and now to declare in code that a name is meant to shadow another name. I suspect that (with sufficient bikeshedding) this would meet the bar for the swift always-on warnings.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 22, 2016 at 10:00:00am</p></header><div class="content"><p>On 22.05.2016 4:49, David Waite via swift-evolution wrote:<br>&gt; This is why I was suggesting earlier in this thread to focus on warnings<br>&gt; when variables and methods are being shadowed, and now to declare in<br>&gt; code that a name is meant to shadow another name. I suspect that (with<br>&gt; sufficient bikeshedding) this would meet the bar for the swift always-on<br>&gt; warnings.<br></p><p>Personally I support both : the optional warning(which is OFF by default) <br>for implicit `self.` and warning + &#39;fix&#39; for shadowing.<br>In case we have no way(as I understand) for optional warning for &#39;self.&#39;, <br>I&#39;d like to move forward the idea of warning for shadowing and &#39;fix&#39; for <br>it. David, would you like to propose some Draft/proposal for this or start <br>new thread to discuss?<br></p><p>Btw, the problem with static dispatch of some protocol extension methods <br>(in parallel thread &quot;Static Dispatch Pitfalls&quot;) has some intersections with <br>this &#39;shadowing&#39; problem: in case of static dispatch of protocol extension <br>method, if type has the same method declared - this looks like type&#39;s <br>method shadowing method in protocol extension. So, probably there could me <br>some common solutions/keywords/etc for these problems.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; This is why I was suggesting earlier in this thread to focus on warnings when variables and methods are being shadowed, and now to declare in code that a name is meant to shadow another name. I suspect that (with sufficient bikeshedding) this would meet the bar for the swift always-on warnings.<br></p><p>I&#39;ve mentioned in the proposal that the shadowing was discussed, but I believe that making it a mandatory warning would make a lot of mess and unnecessary boilerplate. Imagine UITableViewDataSource or Delegate methods, where each of the methods has tableView argument - which when implemented on UITableViewController (common case) is shadowing self.tableView.<br></p><p>What&#39;s the solution to this? Rename all of these arguments to aTableView? localTableView? Not to mention that you rename the argument in the function and suddenly, all previous references to the argument refer to self.tableView instead of the argument (if you e.g. forget to use Edit All in Scope) - it would need to be automated and the developer would need to rename a lot of variables...<br></p><p>Charlie<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I suspect the only issue is that there are lots of things that people would want to have as optional warnings, and it might be hard to justify why this optional warning is more important than other optional warnings all of which would benefit the user. In previous conversations, I believe &quot;can it be linted?&quot; has been proposed as the question to be asked for this kind of thing.<br></p><p>My main argument is that Swift is aspiring to be more than a language used for &quot;apps on AppStore&quot;. As I&#39;ve mentioned in the proposal, sensitive projects can&#39;t afford this class of bugs, since they are simple to make, hard to find and often you won&#39;t find them until runtime.<br></p><p>I know it&#39;s an extreme example, but can you imagine NASA using Swift with this kind of ambiguity without the ability to turn on such a warning? I&#39;ve read several of their articles on software development and they are simply control freaks about everything. I know it&#39;s an extreme example, but the same goes IMHO with kernel development and any applications where lives are at stake.<br></p><p>Since Swift stresses out safety and IMHO this helps with the issue. And I don&#39;t think that it should be part of a linting tool, but as an optional safety feature of the compiler itself.<br></p><p>Charlie<br></p><p>&gt; <br>&gt; I haven&#39;t paid attention very closely to most of these conversations and I did vote against an explicit self requirement.<br>&gt; <br>&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 22 May 2016, at 11:08, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My main argument is that Swift is aspiring to be more than a language used for &quot;apps on AppStore&quot;. As I&#39;ve mentioned in the proposal, sensitive projects can&#39;t afford this class of bugs, since they are simple to make, hard to find and often you won&#39;t find them until runtime.<br>&gt; <br>&gt; I know it&#39;s an extreme example, but can you imagine NASA using Swift with this kind of ambiguity without the ability to turn on such a warning? I&#39;ve read several of their articles on software development and they are simply control freaks about everything. I know it&#39;s an extreme example, but the same goes IMHO with kernel development and any applications where lives are at stake.<br></p><p>The kind of critical applications used in sensitive system like rockets, nuclear plants, medical machines most often require safety so extreme that they use languages more fitted for those uses like ADA, or they use heavy linters over languages like Java.<br></p><p>One thing is sure: it’s already a difficult task to make a language like Swift span from systems to application development. I think it would be an impossible design task to make it also be useful by default for critical systems. I think it is much wiser to keep safety in mind, but leave the most extreme use cases to be implemented using linters.<br></p><p>If the design team is very serious about not integrating optional warnings, then I don’t think it is a huge bother to implement think in linters like SwiftLint is doing.<br></p><p>Regards,<br>David.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/907a4fe5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 22 May 2016, David Hart wrote:<br>&gt; <br>&gt; If the design team is very serious about not integrating optional warnings, then I don’t think it is a huge bother to implement think in linters like SwiftLint is doing.<br></p><p>I&#39;m fine with the way SE-0009 was decided but I think the review left one consideration for linters unexplored: How to be explicit about what&#39;s captured by a closure if the coding style enforced by a linter involves using `self.` everywhere?<br></p><p>There were (are) basically two reasons for keeping `self.` implicit the way it is:<br></p><p>Reason 1. It keeps noise level down. E.g. computed properties often read better this way:<br></p><p>    var area: Double {<br>      return width * height<br>      // rather than: &#39;self.width * self.height&#39;<br>    }<br></p><p>Reason 2. It makes the capturing of `self` explicit, because `self.` is only required in escaping closures and thus the capturing expressions require thinking when writing code and also stand out when reading code.<br></p><p>I think those are good reasons. But then, the language rules don&#39;t really favour the other coding style where the `self.` prefix is used throughout, even if it *can* be enforced by a linter:<br></p><p>Example 1. There&#39;s no other way (but using the `self.` prefix) to indicate that `self` should be retained by a closure:<br></p><p>    self.prepareWork()<br>    queue.async { [self] in<br>    //             ^<br>    // error: Expected &#39;weak&#39;, &#39;unowned&#39;, or no<br>    // specifier in capture list<br>      self.doTheWork()<br>    }<br></p><p>Example 2. There&#39;s currently no way to mark when an escaping closure is intended to **not** capture any other references but those explicitly listed:<br></p><p>    queue.async { [bar] in<br>      if bar.isAdjustable {<br>        baz.adjust()<br>      }<br>    }<br>    // Meant &#39;bar&#39;, but compiler didn&#39;t alert!<br></p><p>So I think it would be a good idea to adjust the capture list syntax a bit:<br></p><p>Suggestion 1. Allow capture lists to explicitly state that they capture `self` strongly by spelling it out with no weak/unowned specifier, i.e. `[self]`.<br></p><p>Suggestion 2. Add a succinct way to indicate that the capture list is *comprehensive*, i.e. that implicitly capturing other variables from the local scope is an error. (Capturing variables from the file scope should be allowed though, I reckon.) The syntax for this could be e.g. postfixing the capture list brackets with the exclamation mark `!`:<br></p><p>    queue.async { [service]! in<br>      service.handleTask(self.task)<br>    //                   ^<br>    // error: Implicit capture of &#39;self&#39; in closure<br>    }<br>    queue.async { [service, self]! in<br>      service.execute(self.task) // ok<br>    }<br>    queue.async { [service, task = self.task]! in<br>      service.execute(task) // also ok; didn&#39;t capture &#39;self&#39;<br>    }<br>    queue.async { [bar]! in<br>      if bar.isAdjustable {<br>        baz.adjust()<br>    //  ^<br>    // error: Implicit capture of &#39;baz&#39; in closure<br>      }<br>    }<br></p><p>With these two changes, the coding style choice of what to use the `self.` prefix for would be better supported both ways, and no optional warnings would be needed. A linter could then require capturing `self` explicitly where it&#39;s used inside an escaping block. Myself, I wouldn&#39;t use comprehensive capture lists all the time but there have been a few cases where it would&#39;ve been useful to prevent mistakenly capturing anything that could create a retain cycle.<br></p><p>Any thoughts? Would an idea like this help any of the people who started this mailing list thread—that is, with the aid of a respectively configured linter of course?<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/d6c05517/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 22, 2016, at 11:33 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 May 2016, David Hart wrote:<br>&gt;&gt; <br>&gt;&gt; If the design team is very serious about not integrating optional warnings, then I don’t think it is a huge bother to implement think in linters like SwiftLint is doing.<br>&gt; <br>&gt; I&#39;m fine with the way SE-0009 was decided but I think the review left one consideration for linters unexplored: How to be explicit about what&#39;s captured by a closure if the coding style enforced by a linter involves using `self.` everywhere?<br>&gt; <br>&gt; There were (are) basically two reasons for keeping `self.` implicit the way it is:<br>&gt; <br>&gt; Reason 1. It keeps noise level down. E.g. computed properties often read better this way:<br>&gt; <br>&gt;     var area: Double {<br>&gt;       return width * height<br>&gt;       // rather than: &#39;self.width * self.height&#39;<br>&gt;     }<br>&gt; <br>&gt; Reason 2. It makes the capturing of `self` explicit, because `self.` is only required in escaping closures and thus the capturing expressions require thinking when writing code and also stand out when reading code.<br>&gt; <br>&gt; I think those are good reasons. But then, the language rules don&#39;t really favour the other coding style where the `self.` prefix is used throughout, even if it *can* be enforced by a linter:<br>&gt; <br>&gt; Example 1. There&#39;s no other way (but using the `self.` prefix) to indicate that `self` should be retained by a closure:<br>&gt; <br>&gt;     self.prepareWork()<br>&gt;     queue.async { [self] in<br>&gt;     //             ^<br>&gt;     // error: Expected &#39;weak&#39;, &#39;unowned&#39;, or no<br>&gt;     // specifier in capture list<br>&gt;       self.doTheWork()<br>&gt;     }<br>&gt; <br>&gt; Example 2. There&#39;s currently no way to mark when an escaping closure is intended to **not** capture any other references but those explicitly listed:<br>&gt; <br>&gt;     queue.async { [bar] in<br>&gt;       if bar.isAdjustable {<br>&gt;         baz.adjust()<br>&gt;       }<br>&gt;     }<br>&gt;     // Meant &#39;bar&#39;, but compiler didn&#39;t alert!<br>&gt; <br>&gt; So I think it would be a good idea to adjust the capture list syntax a bit:<br>&gt; <br>&gt; Suggestion 1. Allow capture lists to explicitly state that they capture `self` strongly by spelling it out with no weak/unowned specifier, i.e. `[self]`.<br>&gt; <br>&gt; Suggestion 2. Add a succinct way to indicate that the capture list is *comprehensive*, i.e. that implicitly capturing other variables from the local scope is an error. (Capturing variables from the file scope should be allowed though, I reckon.) The syntax for this could be e.g. postfixing the capture list brackets with the exclamation mark `!`:<br>&gt; <br>&gt;     queue.async { [service]! in<br>&gt;       service.handleTask(self.task)<br>&gt;     //                   ^<br>&gt;     // error: Implicit capture of &#39;self&#39; in closure<br>&gt;     }<br>&gt;     queue.async { [service, self]! in<br>&gt;       service.execute(self.task) // ok<br>&gt;     }<br>&gt;     queue.async { [service, task = self.task]! in<br>&gt;       service.execute(task) // also ok; didn&#39;t capture &#39;self&#39;<br>&gt;     }<br>&gt;     queue.async { [bar]! in<br>&gt;       if bar.isAdjustable {<br>&gt;         baz.adjust()<br>&gt;     //  ^<br>&gt;     // error: Implicit capture of &#39;baz&#39; in closure<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt; With these two changes, the coding style choice of what to use the `self.` prefix for would be better supported both ways, and no optional warnings would be needed. A linter could then require capturing `self` explicitly where it&#39;s used inside an escaping block. Myself, I wouldn&#39;t use comprehensive capture lists all the time but there have been a few cases where it would&#39;ve been useful to prevent mistakenly capturing anything that could create a retain cycle.<br>&gt; <br>&gt; Any thoughts? Would an idea like this help any of the people who started this mailing list thread—that is, with the aid of a respectively configured linter of course?<br></p><p>+1.  I like both ideas (and don&#39;t like mandating style).  One other thing that might be nice is a plugin mechanism for the build system that provides a standard interface for linters / style checkers and allows them to emit style &quot;warnings&quot; (ideally integrated with Xcode).<br></p><p>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/01bbe952/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:22 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 21, 2016, at 5:30 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have created a proposal for making the self. optional warning. It can be viewed here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/charlieMonroe/swift-evolution/blob/master/proposals/xxxx-optional-warning-for-explicit-self.md<br>&gt;&gt; <br>&gt;&gt; Does anyone see a downside to this solution, having it an optional warning?<br>&gt; <br>&gt; I suspect the only issue is that there are lots of things that people would want to have as optional warnings, and it might be hard to justify why this optional warning is more important than other optional warnings all of which would benefit the user. In previous conversations, I believe &quot;can it be linted?&quot; has been proposed as the question to be asked for this kind of thing.<br>&gt; <br>&gt; I haven&#39;t paid attention very closely to most of these conversations and I did vote against an explicit self requirement.<br></p><p>+1 <br>many languages have thrived despite not mandating a &quot;self.&quot; prefix, and it has not caused all software written with these languages to be bug ridden catastrophies. Lint seems like a rational place to resolve these stylistic preferences.<br></p><p>The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br></p><p>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br></p><p>Tell that to the colorblind :)<br></p><p>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>As a colorblind developer, this isn’t really an issue. The vast majority of colorblind people can discern colors. As long as the IDE allows you to customize which colors it displays, you can find a palette that will work with your eyes (for my type of colorblindness, for instance, I have difficulty differentiating blue and purple, so I wouldn’t use both in my syntax highlighting color scheme). As long as color isn’t the only thing differentiating on-screen elements, adding colors to syntax highlighting is beneficial even to us colorblind developers. :)<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br></p><p>Check out Developing for Apple Watch, Second Edition &lt;https://pragprog.com/titles/jkwatch2/developing-for-apple-watch-second-edition&gt;, now in print!<br></p><p>&gt; On May 23, 2016, at 12:24 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt; <br>&gt; Tell that to the colorblind :)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/39d2da56/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 6:43 PM, Jeff Kelley &lt;slaunchaman at gmail.com&gt; wrote:<br>&gt; <br>&gt; As a colorblind developer, this isn’t really an issue. The vast majority of colorblind people can discern colors. As long as the IDE allows you to customize which colors it displays, you can find a palette that will work with your eyes (for my type of colorblindness, for instance, I have difficulty differentiating blue and purple, so I wouldn’t use both in my syntax highlighting color scheme). As long as color isn’t the only thing differentiating on-screen elements, adding colors to syntax highlighting is beneficial even to us colorblind developers. :)<br>&gt; <br></p><p>I believe in eclipse you can choose the font, which inludes setting its color.<br></p><p>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; <br>&gt; Check out Developing for Apple Watch, Second Edition, now in print!<br>&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 12:24 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt;&gt; <br>&gt;&gt; Tell that to the colorblind :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b8070d1c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>As another colorblind developer, this kind of is an issue. While I *can* discern colors, the only one that sticks out strongly is blue. If you’ve got reds, greens, browns, or oranges, my experience will be on a continuum from “I think that’s red?” in the best case, “I can figure this out if I accessibility-zoom it into a huge color patch” in the middle, and “Let me get out DigitalColorMeter” in the worst case. Purple, of course, is very hard to distinguish from blue. I guess grey is distinguishable, if you consider it a color. Other than that, syntax highlighting doesn’t do a lot for me.<br></p><p>Plus, I might end up having to use a different source editor sometimes, particularly when I’m doing a large refactor and Xcode is stuck in its “SourceKitService crash every time two characters are typed” thing. I’d really rather have things differentiable in the language itself rather than relying on external crutches.<br></p><p>Charles<br></p><p>&gt; On May 23, 2016, at 11:43 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a colorblind developer, this isn’t really an issue. The vast majority of colorblind people can discern colors. As long as the IDE allows you to customize which colors it displays, you can find a palette that will work with your eyes (for my type of colorblindness, for instance, I have difficulty differentiating blue and purple, so I wouldn’t use both in my syntax highlighting color scheme). As long as color isn’t the only thing differentiating on-screen elements, adding colors to syntax highlighting is beneficial even to us colorblind developers. :)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/9c7ae74e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 24, 2016 at 12:00:00am</p></header><div class="content"><p>On 23.05.2016 21:41, Charles Srstka via swift-evolution wrote:<br>&gt; Plus, I might end up having to use a different source editor sometimes,<br>&gt; particularly when I’m doing a large refactor and Xcode is stuck in its<br>&gt; “SourceKitService crash every time two characters are typed” thing. I’d<br>&gt; really rather have things differentiable in the language itself rather than<br>&gt; relying on external crutches.<br>&gt;<br></p><p>IMO it&#39;s weird to rely on XCode features when we discuss some features of <br>the language. Not always Swift code is edited in XCode, not always in IDE <br>that supports different colors for different kind of variables, not always <br>you have IDE at all and you can have just editor with simple(it will not <br>parse/compile Swift code/project) coloring for base language constructions.<br></p><p>As for this proposal. I don&#39;t believe(based on community and core team <br>response) the situation with implicit &#39;self.&#39; could be changed. So let&#39;s <br>use lints and other tools to achieve the target of warning for implicit <br>&#39;self.&#39;. I suggest to move forward the idea of warning(and &#39;fix&#39;) for <br>shadowing of variables in general and property and local variable in <br>particular.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>As another colorblind developer, I have trouble paying attention to the syntax highlighting. I didn’t even notice that member variables were colored until someone mentioned it on this list.<br></p><p><br>&gt; On May 23, 2016, at 9:43 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a colorblind developer, this isn’t really an issue. The vast majority of colorblind people can discern colors. As long as the IDE allows you to customize which colors it displays, you can find a palette that will work with your eyes (for my type of colorblindness, for instance, I have difficulty differentiating blue and purple, so I wouldn’t use both in my syntax highlighting color scheme). As long as color isn’t the only thing differentiating on-screen elements, adding colors to syntax highlighting is beneficial even to us colorblind developers. :)<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; <br>&gt; Check out Developing for Apple Watch, Second Edition &lt;https://pragprog.com/titles/jkwatch2/developing-for-apple-watch-second-edition&gt;, now in print!<br>&gt; <br>&gt;&gt; On May 23, 2016, at 12:24 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt;&gt; <br>&gt;&gt; Tell that to the colorblind :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/76150bdd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 06:00:00pm</p></header><div class="content"><p>The IDE will speak the scope name... :)<br></p><p>On May 23, 2016, at 6:24 PM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br></p><p>&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt; <br>&gt; Tell that to the colorblind :)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>On May 23, 2016, at 11:24, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt; <br>&gt; Tell that to the colorblind :)<br></p><p>Dunno about other IDEs, but Xcode&#39;s syntax highlighting can change the size, typeface (bold, italic, etc), and even the font. You can make instance variables show up as 24pt comic sans, if you want. You can’t do polkadot, though… apparently that’s going too far.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 7:26 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On May 23, 2016, at 11:24, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; The problem can also be easily mitigated by having the IDE use a different color to display a variable based on where it was defined (eclipse come to mind as an example). This is something the brain naturally notices without paying any conscious attention.<br>&gt;&gt; <br>&gt;&gt; Tell that to the colorblind :)<br>&gt; <br>&gt; Dunno about other IDEs, but Xcode&#39;s syntax highlighting can change the size, typeface (bold, italic, etc), and even the font. You can make instance variables show up as 24pt comic sans, if you want. You can’t do polkadot, though… apparently that’s going too far.<br>&gt; <br></p><p>Issue is SourceKit may not have the scope of an identifier (was not there last time I looked), just the fact that it was an identifier (i looked a while ago mind you)<br></p><p><br>&gt; - Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>May 23, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016 at 12:26 PM, David Sweeris via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Dunno about other IDEs, but Xcode&#39;s syntax highlighting can change the size, typeface (bold, italic, etc), and even the font. You can make instance variables show up as 24pt comic sans, if you want. You can’t do polkadot, though… apparently that’s going too far.<br></p><p>Unfortunately, doing this can trigger a longstanding Xcode bug that<br>makes it very difficult to edit any file that&#39;s substantially longer<br>than the height of your window.<br></p><p>http://stackoverflow.com/questions/26761295/xcode-6-code-editor-erratic-behaviour<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;d prefer to raise warning for any shadowing, and so, in case of<br>`if let value = value` we&#39;ll have a warning: in discussions about &#39;if let! <br>value&#39; construction proposal there was many opinions that &#39;if let v = v&#39; is <br>a bad style and you should avoid to do this and improve your code to not do <br>this. So I believe warning for &#39;if let v = v&#39; will be accepted by community.<br></p><p>On 18.05.2016 22:36, David Waite wrote:<br>&gt; I always thought that requiring self everywhere was a red herring, and that what was really needed was clearer use of shadowing. But “if let x = x” is a case of the developer asking for shadowing. So either:<br>&gt; - shadowing only causes warnings in some places and is allowed in others (and has a way to indicate intent to turn off warnings)<br>&gt; - shadowing is disallowed everywhere, and “if let” has some terse syntax to indicate intent.<br>&gt;<br>&gt; -DW<br>&gt;&gt; On May 18, 2016, at 10:39 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Fully support your opinion. +1 for warning option.<br>&gt;&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt;&gt;<br>&gt;&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt;&gt;<br>&gt;&gt; class A {<br>&gt;&gt;    var x = 100<br>&gt;&gt;<br>&gt;&gt;    func f() {<br>&gt;&gt;        let x = 10<br>&gt;&gt;        print(x)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt;&gt; Hi there,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sincerely yours,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Krystof Vasa<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; .<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>The code you pasted  really ought to print a warning out (allowing variable shadowing without even a warning can lead to annoying bugs), a generation of Swift developers will be trained by relying on the Swift compiler to make their code automagically safe and this is another one of those Not Fun To Debug bits (similar to the dispatching rules of protocol extensions default methods).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 18 May 2016, at 17:39, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Fully support your opinion. +1 for warning option.<br>&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt; <br>&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt; <br>&gt; class A {<br>&gt;    var x = 100<br>&gt; <br>&gt;    func f() {<br>&gt;        let x = 10<br>&gt;        print(x)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 18.05.2016 um 21:53 schrieb Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The code you pasted  really ought to print a warning out (allowing variable shadowing without even a warning can lead to annoying bugs), a generation of Swift developers will be trained by relying on the Swift compiler to make their code automagically safe and this is another one of those Not Fun To Debug bits (similar to the dispatching rules of protocol extensions default methods).<br></p><p>There are dispatching rules of protocol extension default methods? I thought the methods are selected randomly... just kidding - I think this issue would be worth a proposal...<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 18 May 2016, at 17:39, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Fully support your opinion. +1 for warning option.<br>&gt;&gt; Also, I believe we need a warning (not error as suggested by @Sean in reply to this thread) when type&#39;s property shadowed with local variable.<br>&gt;&gt; <br>&gt;&gt; Or do we *really* feel that this code don&#39;t require at least a warning ?? :<br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt;   var x = 100<br>&gt;&gt; <br>&gt;&gt;   func f() {<br>&gt;&gt;       let x = 10<br>&gt;&gt;       print(x)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18.05.2016 8:09, Krystof Vasa via swift-evolution wrote:<br>&gt;&gt;&gt; Hi there,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely yours,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Krystof Vasa<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>On 19.05.2016 0:01, Michael Peternell wrote:<br>&gt;&gt; Not Fun To Debug bits (similar to the dispatching rules of protocol<br>&gt;&gt; extensions default methods).<br>&gt; There are dispatching rules of protocol extension default methods? I<br>&gt; thought the methods are selected randomly... just kidding -<br></p><p>[offtopic]<br>Could you please describe the joke and the problem of &#39;dispatching rules of <br>protocol extensions default methods&#39;? Want to clarify this for myself. <br>Thank you.<br>[/offtopic]<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 19, 2016 at 02:00:00pm</p></header><div class="content"><p>See this example that demonstrates how it&#39;s pretty much unusable (IMHO), since whenever you refer to the instance as to the protocol, the default implementation gets invoked:<br></p><p>protocol MyProtocol { }<br></p><p>extension MyProtocol {<br>	func getInt() -&gt; Int {<br>		return 0<br>	}<br>}<br></p><p>class MyClass: MyProtocol {<br>	func getInt() -&gt; Int {<br>		return 1<br>	}<br>}<br></p><p><br>let instance = MyClass()<br>instance.getInt() // 1<br></p><p>var anyInstance: MyProtocol = instance<br>anyInstance.getInt() // 0 !!!!!!!<br></p><p><br>Since anyInstance is of MyProtocol type, you get the default implementation (no dynamic dispatch).<br></p><p>Krystof<br></p><p>&gt; On May 19, 2016, at 2:22 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 19.05.2016 0:01, Michael Peternell wrote:<br>&gt;&gt;&gt; Not Fun To Debug bits (similar to the dispatching rules of protocol<br>&gt;&gt;&gt; extensions default methods).<br>&gt;&gt; There are dispatching rules of protocol extension default methods? I<br>&gt;&gt; thought the methods are selected randomly... just kidding -<br>&gt; <br>&gt; [offtopic]<br>&gt; Could you please describe the joke and the problem of &#39;dispatching rules of protocol extensions default methods&#39;? Want to clarify this for myself. Thank you.<br>&gt; [/offtopic]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 19 May 2016, at 13:30, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; See this example that demonstrates how it&#39;s pretty much unusable (IMHO), since whenever you refer to the instance as to the protocol, the default implementation gets invoked:<br>&gt; <br>&gt; protocol MyProtocol { }<br>&gt; <br>&gt; extension MyProtocol {<br>&gt; 	func getInt() -&gt; Int {<br>&gt; 		return 0<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class MyClass: MyProtocol {<br>&gt; 	func getInt() -&gt; Int {<br>&gt; 		return 1<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; let instance = MyClass()<br>&gt; instance.getInt() // 1<br>&gt; <br>&gt; var anyInstance: MyProtocol = instance<br>&gt; anyInstance.getInt() // 0 !!!!!!!<br>&gt; <br>&gt; <br>&gt; Since anyInstance is of MyProtocol type, you get the default implementation (no dynamic dispatch).<br></p><p><br>That’s because the only information that the compiler has about anyInstance is that it conforms to MyProtocol which has no methods so it doesn’t know that it can dispatch getInt() to the implementation in MyClass. Change the protocol to <br></p><p>protocol MyProtocol {<br>    func getInt() -&gt; Int<br>}<br></p><p>and it will work as expected.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 19, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello Jeremy,<br></p><p>It seems it is a little bit more complex than this:<br>http://allblue.me/swift/2016/01/23/swift-method-dispatch-with-protocol-extension-protocol-extension-and-subclass/<br>[image: diagram]<br></p><p>   - IF the inferred type of a variable is the protocol:<br>      - IF the method is in a class conform directly to the original<br>      protocol:<br>         - AND the method is defined in the original protocol<br>            - THEN the runtime type’s implementation is called,<br>            irrespective of whether there is a default implementation<br>in the extension.<br>         - AND the method is not defined in the original protocol,<br>            - THEN the default implementation is called.<br>         - ELSE IF the method is in a subclass of another class who conform<br>      to the original protocol<br>         - THEN the default implementation of protocol is called.<br>      - ELSE IF the inferred type of the variable is the type<br>      - THEN the type’s implementation is called.<br></p><p><br></p><p>On Thu, May 19, 2016 at 5:24 PM, Jeremy Pereira via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 19 May 2016, at 13:30, Krystof Vasa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; See this example that demonstrates how it&#39;s pretty much unusable (IMHO),<br>&gt; since whenever you refer to the instance as to the protocol, the default<br>&gt; implementation gets invoked:<br>&gt; &gt;<br>&gt; &gt; protocol MyProtocol { }<br>&gt; &gt;<br>&gt; &gt; extension MyProtocol {<br>&gt; &gt;       func getInt() -&gt; Int {<br>&gt; &gt;               return 0<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class MyClass: MyProtocol {<br>&gt; &gt;       func getInt() -&gt; Int {<br>&gt; &gt;               return 1<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; let instance = MyClass()<br>&gt; &gt; instance.getInt() // 1<br>&gt; &gt;<br>&gt; &gt; var anyInstance: MyProtocol = instance<br>&gt; &gt; anyInstance.getInt() // 0 !!!!!!!<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Since anyInstance is of MyProtocol type, you get the default<br>&gt; implementation (no dynamic dispatch).<br>&gt;<br>&gt;<br>&gt; That’s because the only information that the compiler has about<br>&gt; anyInstance is that it conforms to MyProtocol which has no methods so it<br>&gt; doesn’t know that it can dispatch getInt() to the implementation in<br>&gt; MyClass. Change the protocol to<br>&gt;<br>&gt; protocol MyProtocol {<br>&gt;     func getInt() -&gt; Int<br>&gt; }<br>&gt;<br>&gt; and it will work as expected.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/08e091fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>And... is this all OK? No one think this is a broken design?<br></p><p>So, in addition to the example with getInt() (when no method declaration <br>exists in protocol itself, but just in extension and in type), we have this:<br></p><p>protocol A {<br>     func f()<br>     func x()<br>}<br></p><p>extension A {<br>     func x() {print(&quot;a-x&quot;)}<br>}<br></p><p>class B: A {<br>     func f() {}<br>}<br></p><p>class C: B {<br>     func x(){print(&quot;c-x&quot;)}<br>}<br></p><p>var c : A = C()<br>c.x() // a-x. but C() *implements* x() that *is* defined in protocol<br></p><p>I don&#39;t know how this could be called &#39;expected&#39; and &#39;wanted&#39; behavior.<br></p><p>Who was talking here regarding the main target of Swift to be readable and <br>understandable even by &#39;poor beginners&#39; ? ;-)<br></p><p><br>On 19.05.2016 20:12, Goffredo Marocchi via swift-evolution wrote:<br>&gt; Hello Jeremy,<br>&gt;<br>&gt; It seems it is a little bit more complex than this:<br>&gt; http://allblue.me/swift/2016/01/23/swift-method-dispatch-with-protocol-extension-protocol-extension-and-subclass/<br>&gt; diagram<br>&gt;<br>&gt;   * IF the inferred type of a variable is the protocol:<br>&gt;       o IF the method is in a class conform directly to the original protocol:<br>&gt;           + AND the method is defined in the original protocol<br>&gt;               # THEN the runtime type’s implementation is called,<br>&gt;                 irrespective of whether there is a default implementation<br>&gt;                 in the extension.<br>&gt;           + AND the method is not defined in the original protocol,<br>&gt;               # THEN the default implementation is called.<br>&gt;       o ELSE IF the method is in a subclass of another class who conform to<br>&gt;         the original protocol<br>&gt;           + THEN the default implementation of protocol is called.<br>&gt;   * ELSE IF the inferred type of the variable is the type<br>&gt;       o THEN the type’s implementation is called.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, May 19, 2016 at 5:24 PM, Jeremy Pereira via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;     &gt; On 19 May 2016, at 13:30, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; See this example that demonstrates how it&#39;s pretty much unusable (IMHO), since whenever you refer to the instance as to the protocol, the default implementation gets invoked:<br>&gt;     &gt;<br>&gt;     &gt; protocol MyProtocol { }<br>&gt;     &gt;<br>&gt;     &gt; extension MyProtocol {<br>&gt;     &gt;       func getInt() -&gt; Int {<br>&gt;     &gt;               return 0<br>&gt;     &gt;       }<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; class MyClass: MyProtocol {<br>&gt;     &gt;       func getInt() -&gt; Int {<br>&gt;     &gt;               return 1<br>&gt;     &gt;       }<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt; let instance = MyClass()<br>&gt;     &gt; instance.getInt() // 1<br>&gt;     &gt;<br>&gt;     &gt; var anyInstance: MyProtocol = instance<br>&gt;     &gt; anyInstance.getInt() // 0 !!!!!!!<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt; Since anyInstance is of MyProtocol type, you get the default implementation (no dynamic dispatch).<br>&gt;<br>&gt;<br>&gt;     That’s because the only information that the compiler has about<br>&gt;     anyInstance is that it conforms to MyProtocol which has no methods so<br>&gt;     it doesn’t know that it can dispatch getInt() to the implementation in<br>&gt;     MyClass. Change the protocol to<br>&gt;<br>&gt;     protocol MyProtocol {<br>&gt;         func getInt() -&gt; Int<br>&gt;     }<br>&gt;<br>&gt;     and it will work as expected.<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>static vs. dynamic dispatch of protocol methods</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 20, 2016 at 12:00:00am</p></header><div class="content"><p>(renamed subject line from &quot;Re: [swift-evolution] Proposal SE-0009 Reconsideration&quot; to &quot;static vs. dynamic dispatch of protocol methods&quot;)<br></p><p>&gt; Am 19.05.2016 um 19:59 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; And... is this all OK? No one think this is a broken design?<br></p><p>I do. I think this has not been done on purpose. But a solution to this problem is far from obvious, I fear.<br></p><p>***<br></p><p>May I explain something, that may bring us closer to understanding the problem?<br></p><p>I think the difficulty of dispatching everything dynamically is that it would require to &quot;duck type&quot; everything. (Google: &quot;duck typing&quot;)<br></p><p>E.g.:<br></p><p>// Module: ObjSupportLibrary<br>// ObjectPlayground.swift ...<br></p><p>class A {<br>   func foo() { ... }<br>}<br></p><p>class B {<br>   func foo() { ... }<br>}<br></p><p>class C {<br>   func bar() { ... }<br>}<br></p><p>If I just want to call foo(), but I don&#39;t want the type to be known at compile time, I can just do<br></p><p>// Module: Main<br>// CanFooSupport.swift ...<br></p><p>protocol CanFoo {<br>    func foo()<br>}<br></p><p>extension AnyObject: CanFoo [named Extension12] {<br>    func foo() { ... }<br>}<br></p><p>So... it is clear that the name `foo` has to be available at runtime, in class `A` and class `B`, because the compiler cannot know if some other module will make a `CanFoo`-protocol when it compiles module ObjSupportLibrary. And if someone implements a `CanFoo`-protocol, the information that `A.foo` and `B.foo` have the same signature has to be available at runtime. At least there has to be some function `S` with the property that `S(CanFoo.foo) == S(A.foo) == S(B.foo)` and a dispatch-table for `A` with `a.dispatchTable(S(CanFoo.foo)) == A.foo` and a dispatch table for `C` with `c.dispatchTable(S(CanFoo.foo)) == nil`, (a: A, c: C), I suspect that this is not the case yet, but maybe someone who knows better about the current ABI can provide more insight here? At the call site, for a variable `b` of runtime type `B` and inferred type `CanFoo`, a call to `b.foo()` has to do something like<br></p><p>    if let f = b.dispatchTable(S(CanFoo.foo)) {<br>        f()<br>    } else {<br>        Extension12.foo(self: b)<br>    }<br></p><p>The above is unlike any `objc_messageSend()` call! It&#39;s more like `objc_messageSendWithFallbackIsaPointers([Extension12.class], b)`.<br>You cannot ask the class-object of `b` (which is `B`) to &quot;just invoke foo&quot;, because from the declaration `b: CanFoo`, you cannot tell if `b.dynamicType` has overridden `foo()`. You have to check if `b` implements `foo()`, and if it does, just call it, and if not, call the default implementation instead. This is not an algorithm that the class object can do. After all, there could be a different protocol `CanFoo2` that works the same but has a different default implementation. How can the class-object of `b` know if the inferred type of the variable holding it is `CanFoo` or `CanFoo2`? It cannot. The default implementation from the extension has to be statically dispatched.<br></p><p>***<br></p><p>What can be done about this?<br></p><p>Maybe we should define:<br></p><p>If you have a variable `x` with inferred type `P` (where `P` is a protocol) and you want to call a function `f` on it:<br>1) try to look up the function `f()` in the dispatch table of `x`&#39;s class object. If `f()` is defined there with an `override(P)` annotation, just call it.<br>2) if 1) didn&#39;t work, call the protocol extensions default method instead. This means that a method defined in a protocol is only dynamically dispatched if it is annotated with `override(P)`.<br></p><p>This also means that all protocol-implementations would have to be annotated with `override(Protocol_name)` (or some other, equivalent syntax) (e.g. `extension X: P { func bar() { ... } }` would need to change to `extension X: P { override(P) func bar() { ... } }` too. (there are funny edge-cases if you don&#39;t require that.))<br></p><p>Dynamically overriding something from a protocol extension will just not be possible, because you cannot name a protocol extension. (I named the extension above `Extension12` just because I had to refer to it, but it&#39;s not valid Swift syntax.) Unless of course, that method is also defined in the protocol itself! If protocol extensions can be given names (there is already another proposal/pitch for that), this may be possible though.<br></p><p>I don&#39;t know if this would be feasible, or how much effort it would be to implement this. But maybe it&#39;s a starting point? I know there is still more design work to be done here, for example I have swept generics under the mat. That said, I think I understand now why no one has really solved this problem yet. It&#39;s just really hard.<br></p><p>***<br></p><p>Why wouldn&#39;t we want to just dispatch everything dynamically?<br></p><p>The problem with dispatching everything dynamically is that it would mean that we could accidentally override methods from protocols. The specialized method may have a totally different contract, and the developer of method `fooo()` cannot know if some protocol will eventually declare and implement a `fooo()`-method too.<br></p><p>For a more realistic example:<br></p><p>class Diagram {<br>    /// should draw to the screen (default UI-graphics-context)<br>    func draw() {<br>        // default implementation does nothing<br>    }<br>    func toXML() -&gt; String {<br>        return &quot;&lt;diagram&gt;&lt;/diagram&gt;&quot;<br>    }<br>}<br></p><p>class BluePolygonDiagram: Diagram {<br>    override func draw() { ... }<br>    override func toXML() { ... }<br>    /// changes the blue-ness of the diagram<br>    /// - parameter v: should be in the open range (-100.0 .. +100.0).<br>    func makeBlue(v: Float) { ... }<br>}<br></p><p>// imagine 32 other Diagram-subclasses here...<br></p><p>// and in another place:<br></p><p>extension Diagram {<br>    /// will draw a blue-and-white version of the diagram to the screen<br>    /// - parameter v: how much blue you want it.. 0=&quot;black and white&quot;, 1=&quot;blue and white&quot;, and everything in-between is possible too<br>    func makeBlue(v: Float) {<br>        ...<br>    }<br>}<br></p><p>// then at some other place<br></p><p>func drawDiagramsNextToEachOther(diagrams: Array&lt;Diagram&gt;, withBlueness: Float? = nil) {<br>    for d in diagrams {<br>        if let blueness = withBlueness {<br>            d.makeBlue(blueness)<br>        } else {<br>            d.draw()<br>        }<br>    }<br>}<br></p><p>Therefore:<br>- can the developer of BluePolygonDiagram be blamed for not knowing that some other developer will be making an extension that defines makeBlue(_:) in a different way?<br>- can the developer of the makeBlue-Diagram-extension blamed for not reading through every class in the Diagram-standard-library, in order to know that there is already a makeBlue-method implemented somewhere?<br>=&gt; I think the answers to both questions have to be &quot;No&quot;. It follows that you can also have *too much* dynamic dispatch, not only *too little*.<br></p><p>***<br></p><p>Maybe someone wants to write up a proposal draft?<br></p><p>Regards,<br>Michael<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>Oh, cool! This is exactly the same code I was asking the community to <br>comment out if this is wanted/expected behavior. Unfortunately no reply was <br>given. This is why I suggested a warning if type&#39;s method has the same name <br>as such protocol extension method in my current thread &quot;[Pitch] Requiring <br>special keyword to mark protocol implementation methods&quot;<br></p><p>On 19.05.2016 15:30, Krystof Vasa wrote:<br>&gt; See this example that demonstrates how it&#39;s pretty much unusable (IMHO), since whenever you refer to the instance as to the protocol, the default implementation gets invoked:<br>&gt;<br>&gt; protocol MyProtocol { }<br>&gt;<br>&gt; extension MyProtocol {<br>&gt; 	func getInt() -&gt; Int {<br>&gt; 		return 0<br>&gt; 	}<br>&gt; }<br>&gt;<br>&gt; class MyClass: MyProtocol {<br>&gt; 	func getInt() -&gt; Int {<br>&gt; 		return 1<br>&gt; 	}<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let instance = MyClass()<br>&gt; instance.getInt() // 1<br>&gt;<br>&gt; var anyInstance: MyProtocol = instance<br>&gt; anyInstance.getInt() // 0 !!!!!!!<br>&gt;<br>&gt;<br>&gt; Since anyInstance is of MyProtocol type, you get the default implementation (no dynamic dispatch).<br>&gt;<br>&gt; Krystof<br>&gt;<br>&gt;&gt; On May 19, 2016, at 2:22 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 19.05.2016 0:01, Michael Peternell wrote:<br>&gt;&gt;&gt;&gt; Not Fun To Debug bits (similar to the dispatching rules of protocol<br>&gt;&gt;&gt;&gt; extensions default methods).<br>&gt;&gt;&gt; There are dispatching rules of protocol extension default methods? I<br>&gt;&gt;&gt; thought the methods are selected randomly... just kidding -<br>&gt;&gt;<br>&gt;&gt; [offtopic]<br>&gt;&gt; Could you please describe the joke and the problem of &#39;dispatching rules of protocol extensions default methods&#39;? Want to clarify this for myself. Thank you.<br>&gt;&gt; [/offtopic]<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; .<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 19, 2016 at 01:00:00pm</p></header><div class="content"><p>In addition to what has already been posted:<br></p><p>https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br></p><p>https://medium.com/ios-os-x-development/swift-protocol-extension-method-dispatch-6a6bf270ba94#.14j0qq1i3<br></p><p>(even more complete summary of previous research in this issue)<br>http://allblue.me/swift/2016/01/23/swift-method-dispatch-with-protocol-extension-protocol-extension-and-subclass/<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 May 2016, at 13:22, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 19.05.2016 0:01, Michael Peternell wrote:<br>&gt;&gt;&gt; Not Fun To Debug bits (similar to the dispatching rules of protocol<br>&gt;&gt;&gt; extensions default methods).<br>&gt;&gt; There are dispatching rules of protocol extension default methods? I<br>&gt;&gt; thought the methods are selected randomly... just kidding -<br>&gt; <br>&gt; [offtopic]<br>&gt; Could you please describe the joke and the problem of &#39;dispatching rules of protocol extensions default methods&#39;? Want to clarify this for myself. Thank you.<br>&gt; [/offtopic]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Vladimir.S,<br></p><p>Goffredo already described it well. That was exactly what I was referring to.<br></p><p>-Michael<br></p><p>&gt; Am 19.05.2016 um 14:51 schrieb Goffredo Marocchi &lt;panajev at gmail.com&gt;:<br>&gt; <br>&gt; In addition to what has already been posted:<br>&gt; <br>&gt; https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; <br>&gt; https://medium.com/ios-os-x-development/swift-protocol-extension-method-dispatch-6a6bf270ba94#.14j0qq1i3<br>&gt; <br>&gt; (even more complete summary of previous research in this issue)<br>&gt; http://allblue.me/swift/2016/01/23/swift-method-dispatch-with-protocol-extension-protocol-extension-and-subclass/<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 19 May 2016, at 13:22, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 19.05.2016 0:01, Michael Peternell wrote:<br>&gt;&gt;&gt;&gt; Not Fun To Debug bits (similar to the dispatching rules of protocol<br>&gt;&gt;&gt;&gt; extensions default methods).<br>&gt;&gt;&gt; There are dispatching rules of protocol extension default methods? I<br>&gt;&gt;&gt; thought the methods are selected randomly... just kidding -<br>&gt;&gt; <br>&gt;&gt; [offtopic]<br>&gt;&gt; Could you please describe the joke and the problem of &#39;dispatching rules of protocol extensions default methods&#39;? Want to clarify this for myself. Thank you.<br>&gt;&gt; [/offtopic]<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Since this keeps coming up, it seems that something would be good here. Perhaps this has been explored before but why can’t we just use dot without the word “self&quot;, to indicate self? <br></p><p>class DotIsSelf<br>{<br>    func p() -&gt; String {<br>        return &quot;self p&quot;<br>    }<br>    <br>    func g() {<br>        print(.p()) 	// print “self p&quot;<br>	print(p)	// error undefined<br>        let p = &quot;local p&quot;<br>        print(p) 	// print “local p&quot;<br>        print(.p())	// print “self p”<br>    }<br>    <br>    class func k() -&gt; String<br>    {<br>        return &quot;self k&quot;<br>    }<br>    <br>    class func j() {<br>        print(.k()) 	// print “self k&quot;<br>	print(k)	// error undefined<br>        let k = &quot;local k” <br>        print(k) 	// print “local k&quot;<br>        print(.k()) 	// print “self k&quot;<br>    }<br>}<br></p><p>Self could still be used but “self.” or “.” would be required to access self. <br></p><p>Rationale:<br>• since self is referenced quite often in classes it should be very short and easy to type<br>• less cluttered than self being everywhere but not ambiguous. whether you mean the local variable or the instance.<br>* Already very similar notation for enums where you leave off the entity name when it can be implied.<br>• Does not interfere, that I could see, with other uses of dot. (I am sure I will be corrected if wrong, but putting it out there because I want to know why :-) <br>• Feels quite intuitive and easy to understand. <br>* Make Swift safer because it eliminates potential ambiguity as has been pointed out many times.<br>• Other characters would be less natural than dot. <br>• In the IDE, hitting dot would immediately bring up self items as choices.<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/22d12568/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 11:00:00pm</p></header><div class="content"><p>IMO nice idea, but I see that this could be confused with using enum values:<br></p><p>enum E {<br>     case one<br>     case two<br></p><p>     static func foo(e: E) {}<br>}<br></p><p>struct S {<br>     var one = 100<br>     ...<br></p><p>     func f() {<br>         E.foo(.one)<br>         print(one) // ? print(.one)<br>	someFunc(.something) // is it enum or property of this struct S?<br>     }<br>}<br></p><p>Probably another variants like `:` symbol could be suggested:<br></p><p>     func f() {<br>         E.foo(.one)<br>         print(:one)<br>	someFunc(:something)<br>     }<br>But also not ideal.<br></p><p>But all this just a discussions - there was clear opinion of core team <br>posted that Swift should not have requirement to explicitly decorate type <br>properties inside code (explicit `self.` or similar). So, someone who wants <br>to use explicit &#39;self.&#39; - can use it. Others - will not use.<br></p><p>On 26.05.2016 22:26, Paul Ossenbruggen wrote:<br>&gt; Since this keeps coming up, it seems that something would be good here.<br>&gt; Perhaps this has been explored before but why can’t we just use dot without<br>&gt; the word “self&quot;, to indicate self?<br>&gt;<br>&gt; classDotIsSelf<br>&gt; {<br>&gt;     funcp() -&gt; String{<br>&gt;         return&quot;self p&quot;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     funcg() {<br>&gt;         print(.p()) // print “self p&quot;<br>&gt; print(p)// error undefined<br>&gt;         letp = &quot;local p&quot;<br>&gt;         print(p) // print “local p&quot;<br>&gt;         print(.p())// print “self p”<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     classfunck() -&gt; String<br>&gt;     {<br>&gt;<br>&gt;         return &quot;self k&quot;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     classfuncj() {<br>&gt;         print(.k()) // print “self k&quot;<br>&gt; print(k)// error undefined<br>&gt;         letk = &quot;local k”<br>&gt;         print(k) // print “local k&quot;<br>&gt;         print(.k()) // print “self k&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Self could still be used but “self.” or “.” would be required to access self.<br>&gt;<br>&gt; Rationale:<br>&gt; • since self is referenced quite often in classes it should be very short<br>&gt; and easy to type<br>&gt; • less cluttered than self being everywhere but not ambiguous. whether you<br>&gt; mean the local variable or the instance.<br>&gt; * Already very similar notation for enums where you leave off the entity<br>&gt; name when it can be implied.<br>&gt; • Does not interfere, that I could see, with other uses of dot. (I am sure<br>&gt; I will be corrected if wrong, but putting it out there because I want to<br>&gt; know why :-)<br>&gt; • Feels quite intuitive and easy to understand.<br>&gt; * Make Swift safer because it eliminates potential ambiguity as has been<br>&gt; pointed out many times.<br>&gt; • Other characters would be less natural than dot.<br>&gt; • In the IDE, hitting dot would immediately bring up self items as choices.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; * Already very similar notation for enums where you leave off the entity name when it can be implied.<br></p><p>That&#39;s the problem. Leading dot already means something—it means &quot;look up a static member of the type we&#39;re expecting here&quot;. (That&#39;s what you&#39;re actually doing when you access an &quot;enum case&quot;.) It can&#39;t mean two different things in the same place.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>While not as nice, Vladimir’s colon suggestion could work. :g()<br></p><p>Reminds a bit of C++ but not bad.<br></p><p>&gt; On May 26, 2016, at 2:05 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; * Already very similar notation for enums where you leave off the entity name when it can be implied.<br>&gt; <br>&gt; That&#39;s the problem. Leading dot already means something—it means &quot;look up a static member of the type we&#39;re expecting here&quot;. (That&#39;s what you&#39;re actually doing when you access an &quot;enum case&quot;.) It can&#39;t mean two different things in the same place.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Since you’re using OSX - CMD + click, jumps to definition.<br></p><p>&gt; On 18 May 2016, at 07:09, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt; <br>&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt; <br>&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt; <br>&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt; <br>&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt; <br>&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt; <br>&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt; <br>&gt; Sincerely yours,<br>&gt; <br>&gt; Krystof Vasa<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 18, 2016 at 01:00:00pm</p></header><div class="content"><p>And that works about 30% of the time, if you’re being generous.<br></p><p>Charles<br></p><p>&gt; On May 18, 2016, at 1:20 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since you’re using OSX - CMD + click, jumps to definition.<br>&gt; <br>&gt;&gt; On 18 May 2016, at 07:09, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Sure, but that assumes that you know where the issue is. Since the app compiles and works fine, except for various glitches, you need to debug this (takes time). This is not preventing an issue that shouldn&#39;t happen in the first place.<br></p><p>&gt; On May 18, 2016, at 8:20 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since you’re using OSX - CMD + click, jumps to definition.<br>&gt; <br>&gt;&gt; On 18 May 2016, at 07:09, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>That proposal might be one of the first early proposals to really get a lot of attention. My take out of the experience is that people (me included in this case) will yell very loudly if you try to enforce your coding standards through the compiler.<br></p><p>There is an open bug on SwiftLint &lt;https://github.com/realm/SwiftLint/issues/321&gt; to add a rule that enforces using self to access member variables. It might be worth taking a look.<br></p><p>Félix<br></p><p>&gt; Le 17 mai 2016 à 22:09:44, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt; <br>&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt; <br>&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt; <br>&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt; <br>&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt; <br>&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt; <br>&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt; <br>&gt; Sincerely yours,<br>&gt; <br>&gt; Krystof Vasa<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/8329f1bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 19, 2016 at 06:00:00am</p></header><div class="content"><p>Thanks for the link, I&#39;ll definitely keep my eye on it, though since there are two large camps siding with either side, I don&#39;t see the harm making this proposal an optional warning of the compiler that would be off by default and those wanting to stay on the safe side would enable this and get a warning.<br></p><p>BTW another example of what this would prevent:<br></p><p>On OS X, all views (NSView) have a print(_:) method. So whenever you write within your code print(&quot;something&quot;), it actually invokes the printing method (since its argument is AnyObject?) - if you indeed want to print something to the console, you need to use Swift.print(&quot;something&quot;) which is incredibly annoying mostly when you forget about this and all of sudden you get print dialogs instead of a log in the console.<br></p><p>Yes, it&#39;s shadowing, but with this one, you can&#39;t do anything about and there will always be cases of shadowing - the more dangerous when you don&#39;t know about them.<br></p><p>Krystof<br></p><p>&gt; On May 19, 2016, at 6:32 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That proposal might be one of the first early proposals to really get a lot of attention. My take out of the experience is that people (me included in this case) will yell very loudly if you try to enforce your coding standards through the compiler.<br>&gt; <br>&gt; There is an open bug on SwiftLint &lt;https://github.com/realm/SwiftLint/issues/321&gt; to add a rule that enforces using self to access member variables. It might be worth taking a look.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 17 mai 2016 à 22:09:44, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt; <br>&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com &lt;http://bugreport.apple.com/&gt; over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt; <br>&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt; <br>&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt; <br>&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt; <br>&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt; <br>&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt; <br>&gt;&gt; Sincerely yours,<br>&gt;&gt; <br>&gt;&gt; Krystof Vasa<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/d0a0c097/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal SE-0009 Reconsideration</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 19, 2016 at 12:00:00am</p></header><div class="content"><p>Put me firmly in the pro-warning camp. If enforcing manual synthesis of ivars (something I never understood the brouhaha about) warranted a warning flag in clang, I think requiring self should at least merit consideration. It certainly has a much greater potential for bugs than automatic ivar synthesis.<br></p><p>Charles<br></p><p>&gt; On May 18, 2016, at 11:44 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the link, I&#39;ll definitely keep my eye on it, though since there are two large camps siding with either side, I don&#39;t see the harm making this proposal an optional warning of the compiler that would be off by default and those wanting to stay on the safe side would enable this and get a warning.<br>&gt; <br>&gt; BTW another example of what this would prevent:<br>&gt; <br>&gt; On OS X, all views (NSView) have a print(_:) method. So whenever you write within your code print(&quot;something&quot;), it actually invokes the printing method (since its argument is AnyObject?) - if you indeed want to print something to the console, you need to use Swift.print(&quot;something&quot;) which is incredibly annoying mostly when you forget about this and all of sudden you get print dialogs instead of a log in the console.<br>&gt; <br>&gt; Yes, it&#39;s shadowing, but with this one, you can&#39;t do anything about and there will always be cases of shadowing - the more dangerous when you don&#39;t know about them.<br>&gt; <br>&gt; Krystof<br>&gt; <br>&gt;&gt; On May 19, 2016, at 6:32 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That proposal might be one of the first early proposals to really get a lot of attention. My take out of the experience is that people (me included in this case) will yell very loudly if you try to enforce your coding standards through the compiler.<br>&gt;&gt; <br>&gt;&gt; There is an open bug on SwiftLint &lt;https://github.com/realm/SwiftLint/issues/321&gt; to add a rule that enforces using self to access member variables. It might be worth taking a look.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 17 mai 2016 à 22:09:44, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi there,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been an OS X developer for over a decade now and was a huge fan of ObjC, implementing ObjC runtime into FreeBSD kernel as a intern at Cambridge University and my Masters thesis was a modular ObjC runtime that ran on Win 3.11. With the advance of Swift, it was clear to me, however, that this is a point to say goodbye to ObjC and move to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so, I&#39;ve migrated all my projects over 5 months into Swift, which is over 200 KLOC of code, with one project being 90 KLOC. This has lead unfortunately to various hiccups due to bugs in Swift, Xcode, compiler, where I was unable to build a project for a month, etc. - I&#39;ve filed 84 bug reports at bugreport.apple.com &lt;http://bugreport.apple.com/&gt; over the past few months regarding developer tools (including Swift) and have begun closely watching the evolution of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I strongly disagree with the rejection of SE-0009, I understood the reasoning that it&#39;s a boilerplate to keep adding self. in front of all variables. I personally always refer to self when accessing instance variables (and methods), unless they are private variables starting with underscore. I know the underscore thing isn&#39;t very Swift-y, but on the other hand, reading the code you immediately know you are dealing with a private instance variable, not something local.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was until I spent 2 hours chasing a bug that was caused by the exact issue this proposal was trying to prevent. I was furious. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) When you read someone elses code and you see myVar.doSomething(), you assume it&#39;s refering to a local variable. Which is incredibly confusing, if this is an instance variable. Swift is all about compile-time checks and this is where it fails.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) If you indeed decide not to go with this proposal, please consider adding a warning option. When you take a look at LLVM warning options, I bet there would be a place for this. Let the user decide. I personally would immediately turn it on on all my projects. Don&#39;t make it an error, make it a warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I speak to you as someone with quite a huge real-life experience with Swift, mainly in the last year - the question whether to force the reference to self is something that may be dividing the community, but I believe that most people with more developing experience would be all for this. At least as an option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely yours,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Krystof Vasa<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/fd74602a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
