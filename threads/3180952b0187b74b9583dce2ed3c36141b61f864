<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>I propose that assert and assertionFailure should be no-ops (with branch <br>hints) in unchecked builds as they are in normal release builds rather <br>than resulting in undefined behaviour in the failure condition.<br></p><p>I would like to kick off a discussion of this. I found the proposal <br>template useful for setting out my thoughts clearly to trigger the <br>discussion but I&#39;m not trying jump the discussion phase. I&#39;m open to <br>radical rewrites or to not proceed if there is opposition. Also if my <br>understanding of the current code is wrong please let me know.<br></p><p>[Current Situation]<br></p><p>The documented behaviour of assert and assertionFailure in &quot;disable <br>safety checks&quot; builds (still documented as -Ounchecked) is that the <br>compiler &quot;may assume that it would evaluate to true&quot; or in the <br>assertionFailure case never be called.<br></p><p>This documented behaviour would allow the compiler to completely <br>eliminate tests and branches before or after the assertion and take the <br>operation deep into undefined behaviour.<br></p><p>https://github.com/apple/swift/blob/cf8baedee2b09c9dd2d9c5519bf61629d1f6ebc8/stdlib/public/core/Assert.swift <br>(latest commit to this file at time of writing)<br></p><p>[NOTE - Actual current behaviour]<br></p><p>It appears from the code as if the assumption is not currently applied <br>on the assert method although it is on the assertionFailure case by <br>means of the _conditionallyUnreachable() call. assert seems to be a <br>no-op in both normal release and disable safety checks build modes.<br></p><p>It also appears that precondition does not apply the permitted <br>assumption when in _isFastAssertConfiguration mode.<br></p><p>There also appears to be code in assert to hint the compiler that the <br>assert will likely be true. This was something that I was planning to <br>suggest and means that code containing asserts can be faster than the <br>same code without the assert in release mode.<br></p><p>[Proposed Change]<br></p><p>Change the documentation for assert and assertionFailure so that <br>behaviour in unchecked mode is the same as in normal release - no <br>evaluation and no effect.<br></p><p>Change the behaviour of assertionFailure to match the updated documentation.<br></p><p>[Motivation]<br></p><p>1) Expected behaviour based on other languages is for assert to have no <br>effect in release. (If current behaviour is highly desired another <br>function name should be used). Having potential dangerous behaviour from <br>a function that is familiar across languages and is regarded as a safety <br>feature is undesirable.<br></p><p>2) Adding asserts to code should not make the code more dangerous <br>whatever the build. Assuming the truth of the assert may lead to runtime <br>safety checks being skipped and undefined behaviour when a no-op would <br>be a safe behaviour.<br></p><p>3) &quot;For highly robust code assert and then handle the error anyway&quot; <br>[Code Complete 2nd Edition section 8.2] While the designed expectation <br>from the Swift team is to use them for checks against internal <br>programming errors within a module in a number of cases I use assertions <br>and assertionFailure calls while processing input data. The code without <br>the assertion would simply fail to read the input gracefully but as the <br>developer I want to know immediately if there are realistic cases that <br>have not been handled so use assertions to flag it to myself that a case <br>may need better handling. As such there are assertions in my code that <br>are in error cases that I expect not to occur. I do not want the runtime <br>safety checks being optimised out. [Being aware of this issue I use <br>custom assertions but am therefore missing out on the branch hinting of <br>the stdlib version and others may want similar behaviour and may not <br>fully read the documentation].<br></p><p>[Impact on existing code]<br></p><p>Loss of performance in cases where assertionFailure is used. Loss of <br>potential performance improvement option in assert usage. In most cases <br>this performance loss will be small but there is potential where the <br>assumption of the value allows large code blocks (to evaluate the <br>condition) to be eliminated for significant effects but I suspect that <br>these cases are rare and preconditionFailure could be used instead to <br>get the performance in unchecked builds (at the cost of release <br>performance) or an additional method could be added.<br></p><p>[Alternatives]<br></p><p>Renaming assert so that the behaviour is not assumed by users familiar <br>with other languages. Function name suggestion:<br></p><p>assume/assumeUnreachable<br></p><p>This could either behaviour as the current assert/assertionFailure <br>documentation or possibly allow the assumption to be made in normal <br>release mode not just the unchecked. It should be a fatal error in debug <br>builds if assumption is incorrect.<br></p><p>[Note about precondition]<br></p><p>precondition/preconditionFailure also have undefined behaviour in <br>unchecked mode but this is not a problem for me for a couple of reasons:<br></p><p>1) I don&#39;t have the same prior understanding about what they do.<br></p><p>2) It is clear from release build behaviour that hitting the condition <br>is always an error.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>On Dec 28, 2015, at 5:48 AM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The documented behaviour of assert and assertionFailure in &quot;disable safety checks&quot; builds (still documented as -Ounchecked) is that the compiler &quot;may assume that it would evaluate to true&quot; or in the assertionFailure case never be called.<br></p><p>Right.<br></p><p>&gt; This documented behaviour would allow the compiler to completely eliminate tests and branches before or after the assertion and take the operation deep into undefined behaviour.<br></p><p>Only in cases where the assertion would have failed, right?  The point of -Ounchecked is that - if your code was correct with the checks - that it will still be correct.  Disabling overflow and array bounds checks is far more dangerous than the assertion behavior you cite here.<br></p><p>&gt; It appears from the code as if the assumption is not currently applied on the assert method although it is on the assertionFailure case by means of the _conditionallyUnreachable() call. assert seems to be a no-op in both normal release and disable safety checks build modes.<br></p><p>Right.<br></p><p>&gt; [Proposed Change]<br>&gt; <br>&gt; Change the documentation for assert and assertionFailure so that behaviour in unchecked mode is the same as in normal release - no evaluation and no effect.<br></p><p>Why? :<br></p><p>&gt; 1) Expected behaviour based on other languages is for assert to have no effect in release. (If current behaviour is highly desired another function name should be used). Having potential dangerous behaviour from a function that is familiar across languages and is regarded as a safety feature is undesirable.<br></p><p>This is the C model, but as you know, there is a whole field of custom assertions libraries that people have developed.  I don’t think there is anything like consensus on this topic.<br></p><p>&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br></p><p>This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br></p><p>If you don’t like that model, don’t use this mode.<br></p><p>&gt; 3) &quot;For highly robust code assert and then handle the error anyway&quot; [Code Complete 2nd Edition section 8.2]<br></p><p>Highly robust code shouldn’t build with -Ounchecked, so I don’t see how this point is pertinent.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 12:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 28, 2015, at 5:48 AM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The documented behaviour of assert and assertionFailure in &quot;disable safety checks&quot; builds (still documented as -Ounchecked) is that the compiler &quot;may assume that it would evaluate to true&quot; or in the assertionFailure case never be called.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; This documented behaviour would allow the compiler to completely eliminate tests and branches before or after the assertion and take the operation deep into undefined behaviour.<br>&gt; <br>&gt; Only in cases where the assertion would have failed, right?  The point of -Ounchecked is that - if your code was correct with the checks - that it will still be correct.  Disabling overflow and array bounds checks is far more dangerous than the assertion behavior you cite here.<br>&gt; <br>&gt;&gt; It appears from the code as if the assumption is not currently applied on the assert method although it is on the assertionFailure case by means of the _conditionallyUnreachable() call. assert seems to be a no-op in both normal release and disable safety checks build modes.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; [Proposed Change]<br>&gt;&gt; <br>&gt;&gt; Change the documentation for assert and assertionFailure so that behaviour in unchecked mode is the same as in normal release - no evaluation and no effect.<br>&gt; <br>&gt; Why? :<br>&gt; <br>&gt;&gt; 1) Expected behaviour based on other languages is for assert to have no effect in release. (If current behaviour is highly desired another function name should be used). Having potential dangerous behaviour from a function that is familiar across languages and is regarded as a safety feature is undesirable.<br>&gt; <br>&gt; This is the C model, but as you know, there is a whole field of custom assertions libraries that people have developed.  I don’t think there is anything like consensus on this topic.<br>&gt; <br>&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt; <br>&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt; <br>&gt; If you don’t like that model, don’t use this mode.<br></p><p>Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br></p><p>Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt;&gt; <br>&gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt;&gt; <br>&gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt; <br>&gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br></p><p>Ah, good point.<br></p><p>&gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br></p><p>Yes, I agree.  -O should not imply undefined behavior in the case of an assert() predicate being dynamically false.<br></p><p>It sounds like we just need a documentation update here?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 11:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt;&gt; <br>&gt;&gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt; <br>&gt; Ah, good point.<br>&gt; <br>&gt;&gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br>&gt; <br>&gt; Yes, I agree.  -O should not imply undefined behavior in the case of an assert() predicate being dynamically false.<br>&gt; <br>&gt; It sounds like we just need a documentation update here?<br></p><p>I’m pretty sure the documentation reflects assumptions that the optimizer is already taking advantage of, but the performance team knows for sure.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>January  2, 2016 at 11:00:00am</p></header><div class="content"><p>&#39;assert&#39; evaluates the condition and aborts only in Odebug builds.<br></p><p>&#39;precondition&#39; evaluates the condition and aborts also in optimized -0 builds.<br></p><p>As far as I remember  the decision was made to give it this semantics to mimic C&#39;s assert() function.<br></p><p>If an abort is desired in optimized builds one should use &#39;precondition&#39;.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 2, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 1, 2016, at 11:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt;&gt; <br>&gt;&gt; Ah, good point.<br>&gt;&gt; <br>&gt;&gt;&gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br>&gt;&gt; <br>&gt;&gt; Yes, I agree.  -O should not imply undefined behavior in the case of an assert() predicate being dynamically false.<br>&gt;&gt; <br>&gt;&gt; It sounds like we just need a documentation update here?<br>&gt; <br>&gt; I’m pretty sure the documentation reflects assumptions that the optimizer is already taking advantage of, but the performance team knows for sure.<br>&gt; <br>&gt; -Dave<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Fri, Jan 1, 2016, at 11:25 PM, Chris Lattner via swift-evolution wrote:<br>&gt; &gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt; &gt; <br>&gt; &gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt; <br>&gt; Ah, good point.<br>&gt; <br>&gt; &gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br>&gt; <br>&gt; Yes, I agree.  -O should not imply undefined behavior in the case of an assert() predicate being dynamically false.<br>&gt; <br>&gt; It sounds like we just need a documentation update here?<br></p><p>assert() and assertionFailure() are already explicitly documented as doing nothing in -O builds, and only making the assumption that the condition is always true/function is never called in -Ounchecked builds.<br></p><p>As far as I can tell, the only actual inaccuracy in the documentation is the fact that assert() claims that the optimizer may assume the condition is always true in -Ounchecked when it doesn&#39;t seem to actually do that (because it doesn&#39;t do anything at all when not using -Onone). Both assert() and assertionFailure() do nothing in -O, which matches the documentation.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Fri, Jan 1, 2016, at 11:58 PM, Kevin Ballard wrote:<br>&gt; On Fri, Jan 1, 2016, at 11:25 PM, Chris Lattner via swift-evolution wrote:<br>&gt; &gt; &gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt; &gt; &gt;&gt; <br>&gt; &gt; &gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt; &gt; &gt;&gt; <br>&gt; &gt; &gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt; &gt; <br>&gt; &gt; Ah, good point.<br>&gt; &gt; <br>&gt; &gt; &gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br>&gt; &gt; <br>&gt; &gt; Yes, I agree.  -O should not imply undefined behavior in the case of an assert() predicate being dynamically false.<br>&gt; &gt; <br>&gt; &gt; It sounds like we just need a documentation update here?<br>&gt; <br>&gt; assert() and assertionFailure() are already explicitly documented as doing nothing in -O builds, and only making the assumption that the condition is always true/function is never called in -Ounchecked builds.<br>&gt; <br>&gt; As far as I can tell, the only actual inaccuracy in the documentation is the fact that assert() claims that the optimizer may assume the condition is always true in -Ounchecked when it doesn&#39;t seem to actually do that (because it doesn&#39;t do anything at all when not using -Onone). Both assert() and assertionFailure() do nothing in -O, which matches the documentation.<br></p><p>Having said that, it occurs to me that maybe the optimizer is actually specially detecting the call to assert() under -Ounchecked, but from the source of assert() there&#39;s nothing there to indicate that it actually makes any assumptions under -Ounchecked.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 12:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 5:48 AM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; The documented behaviour of assert and assertionFailure in &quot;disable safety checks&quot; builds (still documented as -Ounchecked) is that the compiler &quot;may assume that it would evaluate to true&quot; or in the assertionFailure case never be called.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt;&gt; This documented behaviour would allow the compiler to completely eliminate tests and branches before or after the assertion and take the operation deep into undefined behaviour.<br>&gt;&gt; <br>&gt;&gt; Only in cases where the assertion would have failed, right?  The point of -Ounchecked is that - if your code was correct with the checks - that it will still be correct.  Disabling overflow and array bounds checks is far more dangerous than the assertion behavior you cite here.<br>&gt;&gt; <br>&gt;&gt;&gt; It appears from the code as if the assumption is not currently applied on the assert method although it is on the assertionFailure case by means of the _conditionallyUnreachable() call. assert seems to be a no-op in both normal release and disable safety checks build modes.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt;&gt; [Proposed Change]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Change the documentation for assert and assertionFailure so that behaviour in unchecked mode is the same as in normal release - no evaluation and no effect.<br>&gt;&gt; <br>&gt;&gt; Why? :<br>&gt;&gt; <br>&gt;&gt;&gt; 1) Expected behaviour based on other languages is for assert to have no effect in release. (If current behaviour is highly desired another function name should be used). Having potential dangerous behaviour from a function that is familiar across languages and is regarded as a safety feature is undesirable.<br>&gt;&gt; <br>&gt;&gt; This is the C model, but as you know, there is a whole field of custom assertions libraries that people have developed.  I don’t think there is anything like consensus on this topic.<br>&gt;&gt; <br>&gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt;&gt; <br>&gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt;&gt; <br>&gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt; <br>&gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt; <br>&gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br></p><p>Wait a sec; I just read the doc comments for assert over again.  They don’t say there’s undefined behavior in -O if the condition isn’t satisfied.  So now I don’t understand what Joseph is complaining about.  assert in -O is documented to act exactly as C’s assert would with NDEBUG #defined.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 5:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 1:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 12:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 5:48 AM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; The documented behaviour of assert and assertionFailure in &quot;disable safety checks&quot; builds (still documented as -Ounchecked) is that the compiler &quot;may assume that it would evaluate to true&quot; or in the assertionFailure case never be called.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This documented behaviour would allow the compiler to completely eliminate tests and branches before or after the assertion and take the operation deep into undefined behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Only in cases where the assertion would have failed, right?  The point of -Ounchecked is that - if your code was correct with the checks - that it will still be correct.  Disabling overflow and array bounds checks is far more dangerous than the assertion behavior you cite here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It appears from the code as if the assumption is not currently applied on the assert method although it is on the assertionFailure case by means of the _conditionallyUnreachable() call. assert seems to be a no-op in both normal release and disable safety checks build modes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Proposed Change]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Change the documentation for assert and assertionFailure so that behaviour in unchecked mode is the same as in normal release - no evaluation and no effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why? :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Expected behaviour based on other languages is for assert to have no effect in release. (If current behaviour is highly desired another function name should be used). Having potential dangerous behaviour from a function that is familiar across languages and is regarded as a safety feature is undesirable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the C model, but as you know, there is a whole field of custom assertions libraries that people have developed.  I don’t think there is anything like consensus on this topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don’t like that model, don’t use this mode.<br>&gt;&gt; <br>&gt;&gt; Let’s just consider -O; I think I understand Joseph’s objection here, and it seems valid.<br>&gt;&gt; <br>&gt;&gt; Normally in -O, we say that if you stay in the “safe subset” of Swift code, you never get undefined behavior, even if there’s a bug in your code.  You might get *unpredictable* behavior of course, but presumably guaranteeing no undefined behavior rules out large classes of problems, including many security holes.  Now suppose you decide to be responsible and add some asserts to help you catch bugs during development.  Hopefully they help you catch all the bugs, but what if they don’t?  All of a sudden, if you still have a bug when you ship, you now have undefined behavior.  As much as I’m a fan of assertions having optimization benefits, It seems a little perverse that using them could make shipping code less secure.<br>&gt; <br>&gt; Wait a sec; I just read the doc comments for assert over again.  They don’t say there’s undefined behavior in -O if the condition isn’t satisfied.  So now I don’t understand what Joseph is complaining about.  assert in -O is documented to act exactly as C’s assert would with NDEBUG #defined.<br>&gt; <br>&gt; -Dave<br></p><p>Thanks for the responses. <br></p><p>The behaviour and documentation at -O is fine. My worry is only for unchecked builds. <br></p><p>My concern is only for the unchecked behaviour. I still think it is surprising that adding an assert can substantively change the behaviour (undefined if false condition occurs). If assert was a brand new idea that did not exist in other languages It would be absolutely appropriate behaviour for the word as it is now but with the history of assert in other languages I still have two problems based on my understanding of asserts across languages. <br></p><p>1) Adding asserts should never be able to add bugs (which they can do in unchecked code).<br>2) The stdlib assert cannot be used to handle any errors that may potentially occur and are handled but that you want to be informed of during development if there is any possibility that the code will ever be compiled in unchecked mode. <br></p><p>The quote I put in the original email about having asserts and handling the error was to show that it is not a practice unique to myself. <br></p><p>An example of where I use asserts is when parsing JSON I will always conditionally handle all potential results of invalid content (missing elements or wrong datatypes) and will usually just ignore the item and fail gracefully but will put asserts so that in development I know that either the data is malformed or I have a bug and am not handling all the reasonable inputs. If this code was compiled in unchecked mode with stdlib asserts it is likely to expose crashes and potentially be exploitable. <br></p><p>Having said all of that there hasn&#39;t been much interest on the list so maybe my feeling about assert isn&#39;t ideally shared. <br></p><p>Joseph<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Asserts should not cause undefined behaviour</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January  3, 2016 at 02:00:00pm</p></header><div class="content"><p>I gave a quick reply to an email later in the chain last night but I think these points are worth addressing. Apologies for the slow response, I wanted to ponder and consider the points rather than rush the response.<br></p><p>&gt;&gt; On Dec 31, 2015, at 8:27 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 5:48 AM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The documented behaviour of assert and assertionFailure in &quot;disable safety checks&quot; builds (still documented as -Ounchecked) is that the compiler &quot;may assume that it would evaluate to true&quot; or in the assertionFailure case never be called.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; This documented behaviour would allow the compiler to completely eliminate tests and branches before or after the assertion and take the operation deep into undefined behaviour.<br>&gt; <br>&gt; Only in cases where the assertion would have failed, right?  The point of -Ounchecked is that - if your code was correct with the checks - that it will still be correct.  Disabling overflow and array bounds checks is far more dangerous than the assertion behavior you cite here.<br></p><p>Yes only when it would have failed but that may still make correct code incorrect where whole branches of runtime belt and braces code could be a eliminated. <br></p><p>&gt;&gt; It appears from the code as if the assumption is not currently applied on the assert method although it is on the assertionFailure case by means of the _conditionallyUnreachable() call. assert seems to be a no-op in both normal release and disable safety checks build modes.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; [Proposed Change]<br>&gt;&gt; <br>&gt;&gt; Change the documentation for assert and assertionFailure so that behaviour in unchecked mode is the same as in normal release - no evaluation and no effect.<br>&gt; <br>&gt; Why? :<br>&gt; <br>&gt;&gt; 1) Expected behaviour based on other languages is for assert to have no effect in release. (If current behaviour is highly desired another function name should be used). Having potential dangerous behaviour from a function that is familiar across languages and is regarded as a safety feature is undesirable.<br>&gt; <br>&gt; This is the C model, but as you know, there is a whole field of custom assertions libraries that people have developed.  I don’t think there is anything like consensus on this topic.<br></p><p>C, Python, Erlang, Ocaml, Java (although it can enabled at runtime) and probably more. I recognise that in house assertion policies and systems may have different behaviours and agreed modes but I think affecting surrounding code (before and after the assertion) is surprising based on people experience with these other languages. I have not seen elsewhere any instances of compilers removing code outside of the branch itself which could be possible if the compiler is allowed to assume the truth of the assertion condition. <br></p><p>if let names = jsonObject as? [String] where names.count &gt; 0 {<br>  print(names.first)<br>} else {<br>  assertionFailure(&quot;Invalid JSON&quot;)<br>  return nil<br>}<br></p><p>Could be compiled to pretty much an unconditional print of an address in unchecked. The nil return could be unreachable, the if let reduced to an unsafe bitcast (maybe not given array bridging but possibly in other cases) and the .first converted to [0] given the assumed passing of the where clause.<br></p><p>&gt;&gt; 2) Adding asserts to code should not make the code more dangerous whatever the build. Assuming the truth of the assert may lead to runtime safety checks being skipped and undefined behaviour when a no-op would be a safe behaviour.<br>&gt; <br>&gt; This only affects code built with -Ounchecked, which is definitely not a safe mode to build your code.  The intention of this mode is that you can use it to get a performance boost, if you believe your code to be sufficiently tested.  This mode, which isn’t the default in any way, intentionally takes the guard rails off to get better performance.<br>&gt; <br>&gt; If you don’t like that model, don’t use this mode<br></p><p>One fear is that libraries will be compiled in this way by people who aren&#39;t the original authors and that people won&#39;t realise the consequences.<br></p><p>&gt;&gt; 3) &quot;For highly robust code assert and then handle the error anyway&quot; [Code Complete 2nd Edition section 8.2]<br>&gt; <br>&gt; Highly robust code shouldn’t build with -Ounchecked, so I don’t see how this point is pertinent.<br></p><p>The quote was external validation of the concept of having asserts where the case is also handled. I would not limit the use to &quot;highly robust code&quot;. <br></p><p>However as I said in my other email if no one else is concerned I will just go away and use my custom assertions and miss out on the compiler hinting.<br></p><p>Joseph<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
