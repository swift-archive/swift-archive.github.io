<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 27, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 27 2016, Stephen Canon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 27, 2016, at 1:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Apr 26 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 26, 2016, at 7:34 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt; Would something like this be possible? Imagine protocols defined like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  public protocol Equatable {<br>&gt;&gt;&gt;&gt;      static func == (lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is that every type that conforms to Equatable has to<br>&gt;&gt;&gt; provide an overload of == in order to conform.  This is exactly what<br>&gt;&gt;&gt; having named methods as requirements solves.<br>&gt;&gt; <br>&gt;&gt; Note that Tony is proposing to make the requirement static.  Whether<br>&gt;&gt; it&#39;s actually called “==” or isEqual is almost immaterial, because the<br>&gt;&gt; fact that it is static makes it less likely that anyone will try to call<br>&gt;&gt; it directly.  <br>&gt;&gt; <br>&gt;&gt; However, if we allowed static operators to be defined, and called using<br>&gt;&gt; the syntax “T.==(x,y)”, as Tony has suggested, IMO it would further<br>&gt;&gt; discourage direct use, and it would avoid growing the number of<br>&gt;&gt; truly distinct spellings for the same operation.<br>&gt;&gt; <br>&gt;&gt; That would also remove many instances of “formXXX” methods that<br>&gt;&gt; currently cause many people discomfort.  Whether that&#39;s a win or not<br>&gt;&gt; depends on whether you view widespread discomfort with “formXXX” as a<br>&gt;&gt; nuisance or a beneficial forcing function for finding something better<br>&gt;&gt; ;-)<br>&gt;<br>&gt; Personally I like this, but t’s not totally clear how it would extend<br>&gt; to mutating operations.  `T.+=(x: inout T, y: T)`?<br></p><p>Well, that looks like a mix between a decl and a use.  I presume you<br>mean<br></p><p>  static func +=(x: inout T, y: T)<br></p><p>and<br></p><p>  T.+=(&amp;x, y)<br></p><p>That seems like the obvious answer to me.<br></p><p>&gt;<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 27, 2016 at 07:00:00pm</p></header><div class="content"><p>On Wed, Apr 27, 2016 at 11:07 AM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 27 2016, Stephen Canon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Apr 27, 2016, at 1:54 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Tue Apr 26 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Apr 26, 2016, at 7:34 PM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; Would something like this be possible? Imagine protocols defined like<br>&gt; this:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;  public protocol Equatable {<br>&gt; &gt;&gt;&gt;&gt;      static func == (lhs: Self, rhs: Self) -&gt; Self<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The problem is that every type that conforms to Equatable has to<br>&gt; &gt;&gt;&gt; provide an overload of == in order to conform.  This is exactly what<br>&gt; &gt;&gt;&gt; having named methods as requirements solves.<br>&gt;<br></p><p>Forgive me, but I&#39;m not following you here. How would that differ from<br>every type that conforms to `FloatingPoint` (or `Equatable`, if we modeled<br>it the same way) having to provide an overload of `isEqual` if a generic<br>`==&lt;T: FloatingPoint&gt;` (or `==&lt;T: Equatable&gt;`) was implemented in terms of<br>that named method?<br></p><p>If the issue is with class hierarchies and dynamic dispatch, the conforming<br>class can make `==` a class method instead of a static one, and then<br>subclasses can either (1) inherit the base class implementation if they<br>don&#39;t need to change anything, or (2) override and extend it. Thus,<br>`T.==(lhs, rhs)` should dynamically dispatch to the same thing<br>`lhs.isEqual(rhs)` would (since the arguments in the protocol are of type<br>`Self`).<br></p><p><br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note that Tony is proposing to make the requirement static.  Whether<br>&gt; &gt;&gt; it&#39;s actually called “==” or isEqual is almost immaterial, because the<br>&gt; &gt;&gt; fact that it is static makes it less likely that anyone will try to call<br>&gt; &gt;&gt; it directly.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; However, if we allowed static operators to be defined, and called using<br>&gt; &gt;&gt; the syntax “T.==(x,y)”, as Tony has suggested, IMO it would further<br>&gt; &gt;&gt; discourage direct use, and it would avoid growing the number of<br>&gt; &gt;&gt; truly distinct spellings for the same operation.<br>&gt;<br></p><p>Exactly—and in that sense, I would argue that the choice of name isn&#39;t<br>quite immaterial, because `==` matches the global operator name while<br>`isEqual` is arbitrary and user-chosen. This would avoid situations where<br>one person might implement `==` with a method named `isEqual` and another<br>might use `isSame`.<br></p><p>Granted, we already have some places where operators duplicate<br>functionality of named methods (like `Array` mapping `+=` to<br>`appendContentsOf`), but this approach at least lets the author of the<br>protocol and its types use the operator name itself as the *sole and<br>primary* name of the function when the context is such that that makes the<br>most sense (such as arithmetic contexts) and coming up with alternative<br>names would be either awkward or increase potential for confusion by<br>increasing the API surface and giving the user two ways to do the same<br>thing (when it might not be obvious if they actually do the exact same<br>thing).<br></p><p><br>&gt;&gt;<br>&gt; &gt;&gt; That would also remove many instances of “formXXX” methods that<br>&gt; &gt;&gt; currently cause many people discomfort.  Whether that&#39;s a win or not<br>&gt; &gt;&gt; depends on whether you view widespread discomfort with “formXXX” as a<br>&gt; &gt;&gt; nuisance or a beneficial forcing function for finding something better<br>&gt; &gt;&gt; ;-)<br></p><p>&gt;<br>&gt; &gt; Personally I like this, but t’s not totally clear how it would extend<br>&gt; &gt; to mutating operations.  `T.+=(x: inout T, y: T)`?<br>&gt;<br>&gt; Well, that looks like a mix between a decl and a use.  I presume you<br>&gt; mean<br>&gt;<br>&gt;   static func +=(x: inout T, y: T)<br>&gt;<br>&gt; and<br>&gt;<br>&gt;   T.+=(&amp;x, y)<br>&gt;<br>&gt; That seems like the obvious answer to me.<br>&gt;<br></p><p>Precisely. The signature would be exactly the same as the global function,<br>just declared static in the protocol instead of non-static. In this case,<br>the compiler would automatically generate the global trampoline operator:<br></p><p>    func += &lt;T: TheProtocol&gt;(lhs: inout T, rhs: T) { T.+=(&amp;x, y) }<br></p><p>Users could still refer to `T.+=` directly to obtain a reference to the<br>`(inout T, T) -&gt; Void` function, but would likely only need to do this in<br>the context of generic algorithms, and then only in situations where the<br>compiler needed more help inferring the argument types (if `+=` by itself<br>didn&#39;t provide enough context).<br></p><p><br></p><p>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; – Steve<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/8f82bfc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Apr 27 2016, Tony Allevato &lt;allevato-AT-google.com&gt; wrote:<br></p><p>&gt; On Wed, Apr 27, 2016 at 11:07 AM Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 27 2016, Stephen Canon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt;&gt; On Apr 27, 2016, at 1:54 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; on Tue Apr 26 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt;&gt; On Apr 26, 2016, at 7:34 PM, Tony Allevato via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt;&gt;&gt;&gt; Would something like this be possible? Imagine protocols defined like<br>&gt;     this:<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; public protocol Equatable {<br>&gt;     &gt;&gt;&gt;&gt; static func == (lhs: Self, rhs: Self) -&gt; Self<br>&gt;     &gt;&gt;&gt;&gt; }<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; The problem is that every type that conforms to Equatable has to<br>&gt;     &gt;&gt;&gt; provide an overload of == in order to conform. This is exactly what<br>&gt;     &gt;&gt;&gt; having named methods as requirements solves.<br>&gt;<br>&gt; Forgive me, but I&#39;m not following you here. How would that differ from every<br>&gt; type that conforms to `FloatingPoint` (or `Equatable`, if we modeled it the same<br>&gt; way) having to provide an overload of `isEqual` if a generic `==&lt;T:<br>&gt; FloatingPoint&gt;` (or `==&lt;T: Equatable&gt;`) was implemented in terms of that named<br>&gt; method?<br>&gt;<br>&gt; If the issue is with class hierarchies and dynamic dispatch, the conforming<br>&gt; class can make `==` a class method instead of a static one, and then subclasses<br>&gt; can either (1) inherit the base class implementation if they don&#39;t need to<br>&gt; change anything, or (2) override and extend it. Thus, `T.==(lhs, rhs)` should<br>&gt; dynamically dispatch to the same thing `lhs.isEqual(rhs)` would (since the<br>&gt; arguments in the protocol are of type `Self`).<br>&gt;<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; Note that Tony is proposing to make the requirement static. Whether<br>&gt;     &gt;&gt; it&#39;s actually called “==” or isEqual is almost immaterial, because the<br>&gt;     &gt;&gt; fact that it is static makes it less likely that anyone will try to call<br>&gt;     &gt;&gt; it directly.<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; However, if we allowed static operators to be defined, and called using<br>&gt;     &gt;&gt; the syntax “T.==(x,y)”, as Tony has suggested, IMO it would further<br>&gt;     &gt;&gt; discourage direct use, and it would avoid growing the number of<br>&gt;     &gt;&gt; truly distinct spellings for the same operation.<br>&gt;<br>&gt; Exactly—and in that sense, I would argue that the choice of name isn&#39;t quite<br>&gt; immaterial, because `==` matches the global operator name while `isEqual` is<br>&gt; arbitrary and user-chosen. This would avoid situations where one person might<br>&gt; implement `==` with a method named `isEqual` and another might use<br>&gt; `isSame`.<br></p><p>That&#39;s why I said *almost* immaterial.<br></p><p>&gt; Granted, we already have some places where operators duplicate functionality of<br>&gt; named methods (like `Array` mapping `+=` to `appendContentsOf`), but this<br>&gt; approach at least lets the author of the protocol and its types use the operator<br>&gt; name itself as the *sole and primary* name of the function when the context is<br>&gt; such that that makes the most sense (such as arithmetic contexts) and coming up<br>&gt; with alternative names would be either awkward or increase potential for<br>&gt; confusion by increasing the API surface and giving the user two ways to do the<br>&gt; same thing (when it might not be obvious if they actually do the exact same<br>&gt; thing).<br></p><p>Hey, I agree with you.<br></p><p>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; That would also remove many instances of “formXXX” methods that<br>&gt;     &gt;&gt; currently cause many people discomfort. Whether that&#39;s a win or not<br>&gt;     &gt;&gt; depends on whether you view widespread discomfort with “formXXX” as a<br>&gt;     &gt;&gt; nuisance or a beneficial forcing function for finding something better<br>&gt;     &gt;&gt; ;-)<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; Personally I like this, but t’s not totally clear how it would extend<br>&gt;     &gt; to mutating operations. `T.+=(x: inout T, y: T)`?<br>&gt;<br>&gt;     Well, that looks like a mix between a decl and a use. I presume you<br>&gt;     mean<br>&gt;<br>&gt;     static func +=(x: inout T, y: T)<br>&gt;<br>&gt;     and<br>&gt;<br>&gt;     T.+=(&amp;x, y)<br>&gt;<br>&gt;     That seems like the obvious answer to me.<br>&gt;<br>&gt; Precisely. The signature would be exactly the same as the global function, just<br>&gt; declared static in the protocol instead of non-static. <br></p><p>The one possible alternative I thought of would be to support infix<br>notation, e.g.<br></p><p>          x T.+= y<br></p><p>It might come down to what&#39;s easier to parse.<br></p><p>&gt; In this case, the compiler would automatically generate the global<br>&gt; trampoline operator:<br>&gt;<br>&gt; func += &lt;T: TheProtocol&gt;(lhs: inout T, rhs: T) { T.+=(&amp;x, y) }<br></p><p>Whoops: I didn&#39;t realize you were talking about doing that<br>automatically.  IMO the minimal change that could possibly fit in Swift<br>3 would be to allow static operator declarations and calls, and have the<br>library declare the trampolines.  If there&#39;s time to go further, I<br>wouldn&#39;t necessarily be opposed, but at this point it&#39;s extremely late<br>to do anything ambitious.  <br></p><p>Keep in mind though that several people in the community have long held<br>that operators should be regular members, which presumably would<br>obsolete these static members.  On the other hand, we don&#39;t have a<br>design for that change, which I think would require defining a new set<br>of lookup rules.  This is probably an incremental step in the right<br>direction.<br></p><p>&gt; Users could still refer to `T.+=` directly to obtain a reference to the `(inout<br>&gt; T, T) -&gt; Void` function, but would likely only need to do this in the context of<br>&gt; generic algorithms, and then only in situations where the compiler needed more<br>&gt; help inferring the argument types (if `+=` by itself didn&#39;t provide enough<br>&gt; context).<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt; – Steve<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 27, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Apr 27, 2016 at 1:14 PM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; The one possible alternative I thought of would be to support infix<br>&gt; notation, e.g.<br>&gt;<br>&gt;           x T.+= y<br>&gt;<br>&gt; It might come down to what&#39;s easier to parse.<br>&gt;<br></p><p>That personally looks a bit awkward to me, but if it turned out to be<br>significantly easier from a parsing point of view, I wouldn&#39;t object.<br></p><p><br>&gt; &gt; In this case, the compiler would automatically generate the global<br>&gt; &gt; trampoline operator:<br>&gt; &gt;<br>&gt; &gt; func += &lt;T: TheProtocol&gt;(lhs: inout T, rhs: T) { T.+=(&amp;x, y) }<br>&gt;<br>&gt; Whoops: I didn&#39;t realize you were talking about doing that<br>&gt; automatically.  IMO the minimal change that could possibly fit in Swift<br>&gt; 3 would be to allow static operator declarations and calls, and have the<br>&gt; library declare the trampolines.  If there&#39;s time to go further, I<br>&gt; wouldn&#39;t necessarily be opposed, but at this point it&#39;s extremely late<br>&gt; to do anything ambitious.<br>&gt;<br></p><p>That&#39;s a reasonable compromise. My thinking was that it would be helpful<br>for the compiler to provide the trampoline implicitly for protocol<br>operators because it&#39;s likely to always be the same delegation, but since<br>they can be written manually in 1–2 lines of code, that&#39;s not a significant<br>burden.<br></p><p>As you say, if making the operators themselves static is doable in the<br>Swift 3 timeframe, a longer-term plan could auto-define the trampolines and<br>the compiler could either (1) flag ones identical to the<br>would-be-auto-generated ones with a warning that they&#39;re redundant, or (2)<br>silently accept them. (If we autogenerate, then we also have an open<br>question: what do we do if the user declares their own trampoline that<br>differs from the expectation? Do we let them override?)<br></p><p>Keep in mind though that several people in the community have long held<br>&gt; that operators should be regular members, which presumably would<br>&gt; obsolete these static members.  On the other hand, we don&#39;t have a<br>&gt; design for that change, which I think would require defining a new set<br>&gt; of lookup rules.  This is probably an incremental step in the right<br>&gt; direction.<br>&gt;<br></p><p>My &quot;regular members&quot;, do you mean that `a + b` would become something like<br>`a.+(b)`? (Sorry, I&#39;m entering some discussions late here.) I personally<br>don&#39;t have a *strong* opposition to that, but I feel like arbitrarily<br>elevating the left-hand side to be a receiver instead of an argument<br>doesn&#39;t buy you much either. To me, `a + b` is computing a result based on<br>two values on equal footing, not calling a method on one and passing it the<br>other. And since class methods permit the &quot;static&quot; protocol method to be<br>dispatched dynamically, it doesn&#39;t need to be a method for that reason<br>either if you&#39;re implementing operators on a class hierarchy.<br></p><p><br>&gt; Users could still refer to `T.+=` directly to obtain a reference to the<br>&gt; `(inout<br>&gt; &gt; T, T) -&gt; Void` function, but would likely only need to do this in the<br>&gt; context of<br>&gt; &gt; generic algorithms, and then only in situations where the compiler<br>&gt; needed more<br>&gt; &gt; help inferring the argument types (if `+=` by itself didn&#39;t provide<br>&gt; enough<br>&gt; &gt; context).<br>&gt; &gt;<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; – Steve<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;     --<br>&gt; &gt;     Dave<br>&gt; &gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/e3b501ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Apr 27 2016, Tony Allevato &lt;allevato-AT-google.com&gt; wrote:<br></p><p>&gt; On Wed, Apr 27, 2016 at 1:14 PM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;     The one possible alternative I thought of would be to support infix<br>&gt;     notation, e.g.<br>&gt;<br>&gt;     x T.+= y<br>&gt;<br>&gt;     It might come down to what&#39;s easier to parse.<br>&gt;<br>&gt; That personally looks a bit awkward to me, but if it turned out to be<br>&gt; significantly easier from a parsing point of view, I wouldn&#39;t object.<br>&gt;<br>&gt;     &gt; In this case, the compiler would automatically generate the global<br>&gt;     &gt; trampoline operator:<br>&gt;     &gt;<br>&gt;     &gt; func += &lt;T: TheProtocol&gt;(lhs: inout T, rhs: T) { T.+=(&amp;x, y) }<br>&gt;<br>&gt;     Whoops: I didn&#39;t realize you were talking about doing that<br>&gt;     automatically. IMO the minimal change that could possibly fit in Swift<br>&gt;     3 would be to allow static operator declarations and calls, and have the<br>&gt;     library declare the trampolines. If there&#39;s time to go further, I<br>&gt;     wouldn&#39;t necessarily be opposed, but at this point it&#39;s extremely late<br>&gt;     to do anything ambitious.<br>&gt;<br>&gt; That&#39;s a reasonable compromise. My thinking was that it would be helpful for the<br>&gt; compiler to provide the trampoline implicitly for protocol operators because<br>&gt; it&#39;s likely to always be the same delegation, but since they can be written<br>&gt; manually in 1–2 lines of code, that&#39;s not a significant burden.<br>&gt;<br>&gt; As you say, if making the operators themselves static is doable in the Swift 3<br>&gt; timeframe, a longer-term plan could auto-define the trampolines and the compiler<br>&gt; could either (1) flag ones identical to the would-be-auto-generated ones with a<br>&gt; warning that they&#39;re redundant, or (2) silently accept them. (If we<br>&gt; autogenerate, then we also have an open question: what do we do if the user<br>&gt; declares their own trampoline that differs from the expectation? Do we let them<br>&gt; override?)<br>&gt;<br>&gt;     Keep in mind though that several people in the community have long held<br>&gt;     that operators should be regular members, which presumably would<br>&gt;     obsolete these static members. On the other hand, we don&#39;t have a<br>&gt;     design for that change, which I think would require defining a new set<br>&gt;     of lookup rules. This is probably an incremental step in the right<br>&gt;     direction.<br>&gt;<br>&gt; My &quot;regular members&quot;, do you mean that `a + b` would become something like `a.+<br>&gt; (b)`? (Sorry, I&#39;m entering some discussions late here.) <br></p><p>Not changing the calling syntax, but changing how they&#39;re declared (in<br>the body of one of the participating types, without `static`) and<br>something-that-has-yet-to-be-designed about how they&#39;re looked up.<br></p><p>&gt; I personally don&#39;t have a *strong* opposition to that, but I feel like<br>&gt; arbitrarily elevating the left-hand side to be a receiver instead of<br>&gt; an argument doesn&#39;t buy you much either. <br></p><p>Hey, I agree.  I&#39;ve never quite seen how this “regular members” plan is<br>going to work out.  Python and D do something for this that involves<br>awkward fallbacks to &quot;r&quot; versions of the operators for heterogeneous<br>argument types.  I don&#39;t know that I&#39;d want to repeat that in Swift.<br>Maybe your static-with-automatic-trampoline scheme is actually a better<br>long-term solution.  But we don&#39;t have time to design the long-term<br>solution right now ;-)<br></p><p>&gt; To me, `a + b` is computing a result based on two values on equal<br>&gt; footing, not calling a method on one and passing it the other. And<br>&gt; since class methods permit the &quot;static&quot; protocol method to be<br>&gt; dispatched dynamically, it doesn&#39;t need to be a method for that reason<br>&gt; either if you&#39;re implementing operators on a class hierarchy.<br>&gt;<br>&gt;     &gt; Users could still refer to `T.+=` directly to obtain a reference to the<br>&gt;     `(inout<br>&gt;     &gt; T, T) -&gt; Void` function, but would likely only need to do this in the<br>&gt;     context of<br>&gt;     &gt; generic algorithms, and then only in situations where the compiler needed<br>&gt;     more<br>&gt;     &gt; help inferring the argument types (if `+=` by itself didn&#39;t provide enough<br>&gt;     &gt; context).<br>&gt;     &gt;<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; – Steve<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; _______________________________________________<br>&gt;     &gt; &gt; swift-evolution mailing list<br>&gt;     &gt; &gt; swift-evolution at swift.org<br>&gt;     &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; --<br>&gt;     &gt; Dave<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
