<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br></p><p>Feedback requested before I submit this as a formal pull request.<br></p><p>Thank you,<br></p><p>-- Erica<br></p><p><br></p><p>Eliminating Swift&#39;s Screaming Snake Case Identifiers<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br></p><p>This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br></p><p>The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br></p><p> &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br></p><p>Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br></p><p>The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br></p><p> &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br></p><p>Using octothorpe-prefixed keywords offers several advantages:<br></p><p>They match the existing #available keyword (D. Gregor)<br>They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>They would support targeted code completion (D. Gregor)<br>They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br> &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br></p><p>This proposal:<br></p><p>renames <br>__FILE__ to #file,<br>__LINE__ to #line,<br>__FUNCTION__ to #function, and <br>__COLUMN__ to #column<br>adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br></p><p>public struct SourceLocation: CustomDebugStringConvertible {<br>    init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>        self.file = file<br>        self.line = line<br>        self.column = column<br>        self.function = function<br>    }<br></p><p>    public let file: String<br>    public let line: Int<br>    public let column: Int<br>    public let function: String<br></p><p>    public var debugDescription: String {<br>        return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>    }<br>}<br> &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br></p><p>Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/9ebe26eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 22, 2016 at 12:00:00pm</p></header><div class="content"><p>`#line` already exists in the language, how will you deal with this?<br></p><p>Jack<br>&gt; On Jan 22, 2016, at 12:17 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br>&gt; <br>&gt; Feedback requested before I submit this as a formal pull request.<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; <br>&gt; Eliminating Swift&#39;s Screaming Snake Case Identifiers<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br>&gt; <br>&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt; <br>&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt; <br>&gt; They match the existing #available keyword (D. Gregor)<br>&gt; They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>&gt; They would support targeted code completion (D. Gregor)<br>&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This proposal:<br>&gt; <br>&gt; renames <br>&gt; __FILE__ to #file,<br>&gt; __LINE__ to #line,<br>&gt; __FUNCTION__ to #function, and <br>&gt; __COLUMN__ to #column<br>&gt; adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>&gt; adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt; <br>&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;         self.file = file<br>&gt;         self.line = line<br>&gt;         self.column = column<br>&gt;         self.function = function<br>&gt;     }<br>&gt; <br>&gt;     public let file: String<br>&gt;     public let line: Int<br>&gt;     public let column: Int<br>&gt;     public let function: String<br>&gt; <br>&gt;     public var debugDescription: String {<br>&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/4f0b1e17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>It could easily be replaced with #codeLine, #fileLine, etc.<br></p><p>-- E<br></p><p>&gt; On Jan 22, 2016, at 1:20 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; `#line` already exists in the language, how will you deal with this?<br>&gt; <br>&gt; Jack<br>&gt;&gt; On Jan 22, 2016, at 12:17 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br>&gt;&gt; <br>&gt;&gt; Feedback requested before I submit this as a formal pull request.<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Eliminating Swift&#39;s Screaming Snake Case Identifiers<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br>&gt;&gt; <br>&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt;&gt; <br>&gt;&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt;&gt; <br>&gt;&gt; They match the existing #available keyword (D. Gregor)<br>&gt;&gt; They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>&gt;&gt; They would support targeted code completion (D. Gregor)<br>&gt;&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt;&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; This proposal:<br>&gt;&gt; <br>&gt;&gt; renames <br>&gt;&gt; __FILE__ to #file,<br>&gt;&gt; __LINE__ to #line,<br>&gt;&gt; __FUNCTION__ to #function, and <br>&gt;&gt; __COLUMN__ to #column<br>&gt;&gt; adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>&gt;&gt; adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>&gt;&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt;&gt; <br>&gt;&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;&gt;         self.file = file<br>&gt;&gt;         self.line = line<br>&gt;&gt;         self.column = column<br>&gt;&gt;         self.function = function<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public let file: String<br>&gt;&gt;     public let line: Int<br>&gt;&gt;     public let column: Int<br>&gt;&gt;     public let function: String<br>&gt;&gt; <br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/2a830f39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>And some other feedback off list:<br></p><p>- Why have individual keywords if they are subsumed into a common representation? <br>    I would not personally object to simplifying things without the extra keywords<br></p><p>- Eliminate #column entirely? <br>    No one I know (&quot;Pauline Kael&quot;) uses it, but presumably it was designed in there for a reason<br></p><p><br>&gt; On Jan 22, 2016, at 1:24 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It could easily be replaced with #codeLine, #fileLine, etc.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:20 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt; <br>&gt;&gt; Jack<br>&gt;&gt;&gt; On Jan 22, 2016, at 12:17 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback requested before I submit this as a formal pull request.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eliminating Swift&#39;s Screaming Snake Case Identifiers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They match the existing #available keyword (D. Gregor)<br>&gt;&gt;&gt; They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>&gt;&gt;&gt; They would support targeted code completion (D. Gregor)<br>&gt;&gt;&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt;&gt;&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; renames <br>&gt;&gt;&gt; __FILE__ to #file,<br>&gt;&gt;&gt; __LINE__ to #line,<br>&gt;&gt;&gt; __FUNCTION__ to #function, and <br>&gt;&gt;&gt; __COLUMN__ to #column<br>&gt;&gt;&gt; adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>&gt;&gt;&gt; adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>&gt;&gt;&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;&gt;&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;&gt;&gt;         self.file = file<br>&gt;&gt;&gt;         self.line = line<br>&gt;&gt;&gt;         self.column = column<br>&gt;&gt;&gt;         self.function = function<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public let file: String<br>&gt;&gt;&gt;     public let line: Int<br>&gt;&gt;&gt;     public let column: Int<br>&gt;&gt;&gt;     public let function: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/92f4d3f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>I think that having all of these individually accessible feels like global namespace pollution. Dot notated “properties” on “#sourceLocation” (or a similar word) should take care of everything we need, and be easier search for and learn about via autocomplete.<br></p><p>e.g.<br>#sourceLocation.module<br>#sourceLocation.function<br>etc.<br></p><p>That’s of course going with the idea that we would continue to type these things. I don’t actually feel like text is the appropriate representation, and would rather have icons in the code for something so reusable. <br></p><p>&gt; On Jan 22, 2016, at 3:32 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And some other feedback off list:<br>&gt; <br>&gt; - Why have individual keywords if they are subsumed into a common representation? <br>&gt;     I would not personally object to simplifying things without the extra keywords<br>&gt; <br>&gt; - Eliminate #column entirely? <br>&gt;     No one I know (&quot;Pauline Kael&quot;) uses it, but presumably it was designed in there for a reason<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:24 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It could easily be replaced with #codeLine, #fileLine, etc.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:20 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jack<br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:17 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback requested before I submit this as a formal pull request.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Eliminating Swift&#39;s Screaming Snake Case Identifiers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They match the existing #available keyword (D. Gregor)<br>&gt;&gt;&gt;&gt; They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>&gt;&gt;&gt;&gt; They would support targeted code completion (D. Gregor)<br>&gt;&gt;&gt;&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt;&gt;&gt;&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; renames <br>&gt;&gt;&gt;&gt; __FILE__ to #file,<br>&gt;&gt;&gt;&gt; __LINE__ to #line,<br>&gt;&gt;&gt;&gt; __FUNCTION__ to #function, and <br>&gt;&gt;&gt;&gt; __COLUMN__ to #column<br>&gt;&gt;&gt;&gt; adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>&gt;&gt;&gt;&gt; adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>&gt;&gt;&gt;&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;&gt;&gt;&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;&gt;&gt;&gt;         self.file = file<br>&gt;&gt;&gt;&gt;         self.line = line<br>&gt;&gt;&gt;&gt;         self.column = column<br>&gt;&gt;&gt;&gt;         self.function = function<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public let file: String<br>&gt;&gt;&gt;&gt;     public let line: Int<br>&gt;&gt;&gt;&gt;     public let column: Int<br>&gt;&gt;&gt;&gt;     public let function: String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;&gt;&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/37be915c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Reload the gist: https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br></p><p>Not sure what you mean by &quot;icons in the code&quot;<br></p><p>-- E<br></p><p>&gt; On Jan 22, 2016, at 2:06 PM, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that having all of these individually accessible feels like global namespace pollution. Dot notated “properties” on “#sourceLocation” (or a similar word) should take care of everything we need, and be easier search for and learn about via autocomplete.<br>&gt; <br>&gt; e.g.<br>&gt; #sourceLocation.module<br>&gt; #sourceLocation.function<br>&gt; etc.<br>&gt; <br>&gt; That’s of course going with the idea that we would continue to type these things. I don’t actually feel like text is the appropriate representation, and would rather have icons in the code for something so reusable. <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 3:32 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And some other feedback off list:<br>&gt;&gt; <br>&gt;&gt; - Why have individual keywords if they are subsumed into a common representation? <br>&gt;&gt;     I would not personally object to simplifying things without the extra keywords<br>&gt;&gt; <br>&gt;&gt; - Eliminate #column entirely? <br>&gt;&gt;     No one I know (&quot;Pauline Kael&quot;) uses it, but presumably it was designed in there for a reason<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:24 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It could easily be replaced with #codeLine, #fileLine, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:20 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jack<br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:17 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Feedback requested before I submit this as a formal pull request.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Eliminating Swift&#39;s Screaming Snake Case Identifiers<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal aims to eliminate Swift&#39;s screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; like __FILE__ and __FUNCTION__ and replacing instances with octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt;, e.g. #file and #function. It extends the set of built-in identifiers and adds a generalized #sourceLocation representation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; They match the existing #available keyword (D. Gregor)<br>&gt;&gt;&gt;&gt;&gt; They match SE-0022&#39;s possible #selector(...) approach for referencing a method&#39;s Objective-C selector (D. Gregor)<br>&gt;&gt;&gt;&gt;&gt; They would support targeted code completion (D. Gregor)<br>&gt;&gt;&gt;&gt;&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt;&gt;&gt;&gt;&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; renames <br>&gt;&gt;&gt;&gt;&gt; __FILE__ to #file,<br>&gt;&gt;&gt;&gt;&gt; __LINE__ to #line,<br>&gt;&gt;&gt;&gt;&gt; __FUNCTION__ to #function, and <br>&gt;&gt;&gt;&gt;&gt; __COLUMN__ to #column<br>&gt;&gt;&gt;&gt;&gt; adds #module and #type to represent the source module, and the source type (self.dynamicType, should it exist) to extend the calling context semantics.<br>&gt;&gt;&gt;&gt;&gt; adds #sourceLocation, a compound type with well-defined fields that create a single context representation.<br>&gt;&gt;&gt;&gt;&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;&gt;&gt;&gt;&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;&gt;&gt;&gt;&gt;         self.file = file<br>&gt;&gt;&gt;&gt;&gt;         self.line = line<br>&gt;&gt;&gt;&gt;&gt;         self.column = column<br>&gt;&gt;&gt;&gt;&gt;         self.function = function<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public let file: String<br>&gt;&gt;&gt;&gt;&gt;     public let line: Int<br>&gt;&gt;&gt;&gt;&gt;     public let column: Int<br>&gt;&gt;&gt;&gt;&gt;     public let function: String<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;&gt;&gt;&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/016f44258586aaf13b5c#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given the narrow nature of this proposal, alternative approaches have not been seriously considered.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/732801af/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 12:32 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And some other feedback off list:<br>&gt; <br>&gt; - Why have individual keywords if they are subsumed into a common representation? <br>&gt;     I would not personally object to simplifying things without the extra keywords<br>&gt; <br>&gt; - Eliminate #column entirely? <br>&gt;     No one I know (&quot;Pauline Kael&quot;) uses it, but presumably it was designed in there for a reason<br></p><p>Getting rid of #column or __COLUMN__ seems extremely arbitrary; it’s very useful when providing debug output. Why would you remove it? <br></p><p>This is a trivial example, but you’d have no easy way to tell which err’ed:<br></p><p>func err(line: Int = __LINE__, column: Int = __COLUMN__) {<br>    print(&quot;err: \(line):\(column)&quot;)<br>}<br></p><p>if true { err() } else { err() }<br></p><p>The value of __LINE__ to #line is marginal. However, the collapse to a #sourceLocation structure of some sort that contained the info would be fantastic.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/5e008828/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>On Jan 22, 2016, at 1:08 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The value of __LINE__ to #line is marginal. <br></p><p>FWIW, while I agree that there is no functional benefit to the renaming, I think that there is a pretty strong benefit to standardize the spelling of things.  These were just a hold-over from C’s spelling, they were never actually thought through and debated.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; `#line` already exists in the language, how will you deal with this?<br></p><p>It does?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Indeed. Here’s the grammar from TSPL:<br></p><p>line-control-statement → #line­<br> &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br> &lt;&gt;line-number → A decimal integer greater than zero<br> &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br></p><p>&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt; <br>&gt; It does?<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/67006d0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>It&#39;s mainly used by LLDB to make sure user-visible line numbers make sense even in the presence of textually-inserted code.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 22, 2016, at 13:43, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Indeed. Here’s the grammar from TSPL:<br>&gt; <br>&gt; line-control-statement → #line­<br>&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt; <br>&gt;&gt; It does?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/844b09ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br></p><p>Jack<br>&gt; On Jan 22, 2016, at 1:48 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; It&#39;s mainly used by LLDB to make sure user-visible line numbers make sense even in the presence of textually-inserted code.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 13:43, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt; <br>&gt;&gt; line-control-statement → #line­<br>&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d5178b78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>1. impressed.<br>2. gist revised: https://gist.github.com/erica/016f44258586aaf13b5c &lt;https://gist.github.com/erica/016f44258586aaf13b5c&gt;<br></p><p>-- E<br></p><p><br>&gt; On Jan 22, 2016, at 3:04 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br>&gt; <br>&gt; Jack<br>&gt;&gt; On Jan 22, 2016, at 1:48 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s mainly used by LLDB to make sure user-visible line numbers make sense even in the presence of textually-inserted code.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 13:43, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/04475ad2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 2:04 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br></p><p>Given the compiler-internal-ish nature of the existing `#line` feature (and since it&#39;s yet another thing copped from C with little consideration), I feel like we&#39;d prefer to rename *that* if we had a better more mainstream use for the name #line.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 completely agreed. I would also find it interesting to explore some sort of unified syntax the existing #line and the new #line, where I could read or write to it like (completely strawman syntax):<br></p><p>let line = #line // read<br>#line = (number: 1, file: &quot;/Users/jack/Desktop/coolswift.swift&quot;) // write<br></p><p>Jack<br>&gt; On Jan 22, 2016, at 2:09 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 2:04 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br>&gt; <br>&gt; Given the compiler-internal-ish nature of the existing `#line` feature (and since it&#39;s yet another thing copped from C with little consideration), I feel like we&#39;d prefer to rename *that* if we had a better more mainstream use for the name #line.<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 2:15 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; +1 completely agreed. I would also find it interesting to explore some sort of unified syntax the existing #line and the new #line, where I could read or write to it like (completely strawman syntax):<br>&gt; <br>&gt; let line = #line // read<br>&gt; #line = (number: 1, file: &quot;/Users/jack/Desktop/coolswift.swift&quot;) // write<br></p><p>That&#39;s cute, though it would behave quite differently from other properties, since you could only assign literals, and you could do so in any context. Not necessarily a showstopper problem, just an observation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 22, 2016 at 07:00:00pm</p></header><div class="content"><p>One thing not mentioned about the current syntax of this obscure #line, is that you can use it on its own to reset to the real line numbers.<br></p><p>print(__LINE__) //  Line 6<br>#line 2456 &quot;filename&quot;<br>print(__LINE__) // Line 2456<br>#line<br>print(__LINE__) // Line 10<br></p><p>The above currently doesn’t work in Playground (I’m guessing, lines are fed one by one to the compiler/interpreter), but does when properly compiled. So this new concept of using #line as a getter/setter will need a way to reset to real value.<br></p><p>Dany<br></p><p><br>&gt; Le 22 janv. 2016 à 17:17, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 2:15 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 completely agreed. I would also find it interesting to explore some sort of unified syntax the existing #line and the new #line, where I could read or write to it like (completely strawman syntax):<br>&gt;&gt; <br>&gt;&gt; let line = #line // read<br>&gt;&gt; #line = (number: 1, file: &quot;/Users/jack/Desktop/coolswift.swift&quot;) // write<br>&gt; <br>&gt; That&#39;s cute, though it would behave quite differently from other properties, since you could only assign literals, and you could do so in any context. Not necessarily a showstopper problem, just an observation.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>You could make these identifiers act like {get set} vars in order to support the current behavior of #line. E.g. LLDB and playgrounds would use `#line = 12; #file = “foo.swift”` instead of `#line 12 foo.swift`.<br></p><p>	- Greg<br></p><p>&gt; On Jan 22, 2016, at 2:04 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br>&gt; <br>&gt; Jack<br>&gt;&gt; On Jan 22, 2016, at 1:48 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s mainly used by LLDB to make sure user-visible line numbers make sense even in the presence of textually-inserted code.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 13:43, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d3f8b0f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Exactly, beat me to it :)<br></p><p>Jack<br>&gt; On Jan 22, 2016, at 2:10 PM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You could make these identifiers act like {get set} vars in order to support the current behavior of #line. E.g. LLDB and playgrounds would use `#line = 12; #file = “foo.swift”` instead of `#line 12 foo.swift`.<br>&gt; <br>&gt; 	- Greg<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 2:04 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also use it in a similar way in playgrounds to inject some hidden preamble code and then rewrite the location of diagnostics.<br>&gt;&gt; <br>&gt;&gt; Jack<br>&gt;&gt;&gt; On Jan 22, 2016, at 1:48 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s mainly used by LLDB to make sure user-visible line numbers make sense even in the presence of textually-inserted code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 13:43, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 12:20 PM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `#line` already exists in the language, how will you deal with this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It does?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/b43f5cc7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; Indeed. Here’s the grammar from TSPL:<br>&gt; <br>&gt; line-control-statement → #line­<br>&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br></p><p>Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/35ffe9fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 23, 2016 at 07:00:00pm</p></header><div class="content"><p>Pull request: https://github.com/apple/swift-evolution/pull/116 &lt;https://github.com/apple/swift-evolution/pull/116&gt;<br></p><p>-- E<br></p><p><br>&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt; <br>&gt;&gt; line-control-statement → #line­<br>&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt; <br>&gt; Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/4ade20e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9da021619c0eac198d5b6148868aa791?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Remy Demarest</string> &lt;remy.demarest at gmail.com&gt;<p>January 24, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 I love the idea of having not-only consistent naming convention for compiler-magic code starting with #.<br></p><p>And I also love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.<br></p><p>Remy Demarest<br>remy.demarest at gmail.com<br></p><p><br></p><p>&gt; Le 23 janv. 2016 à 18:46, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Pull request: https://github.com/apple/swift-evolution/pull/116 &lt;https://github.com/apple/swift-evolution/pull/116&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt; <br>&gt;&gt; Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/e4b80238/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1402 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/e4b80238/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 26, 2016 at 02:00:00pm</p></header><div class="content"><p>What do you think of:<br></p><p>#file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br></p><p>and calling it a day?<br></p><p>* using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>* renaming function to symbol takes care of self.dynamicType as well<br>* file and lineNumbers are gimmes<br>* column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>* adding module fills a big hole.<br></p><p>No tuples for Doug, covers some of Chris&#39;s points.<br></p><p>-- E<br></p><p>&gt; On Jan 24, 2016, at 4:12 PM, Remy Demarest &lt;remy.demarest at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 I love the idea of having not-only consistent naming convention for compiler-magic code starting with #.<br>&gt; <br>&gt; And I also love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.<br>&gt; <br>&gt; Remy Demarest<br>&gt; remy.demarest at gmail.com &lt;mailto:remy.demarest at gmail.com&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 23 janv. 2016 à 18:46, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Pull request: https://github.com/apple/swift-evolution/pull/116 &lt;https://github.com/apple/swift-evolution/pull/116&gt;<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/c9798ba2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m not a fan of #lineNumber, but since #line is taken, wouldn’t it be consistent to have a #columnNumber instead?<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 26, 2016, at 4:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What do you think of:<br>&gt; <br>&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt; <br>&gt; and calling it a day?<br>&gt; <br>&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt; * file and lineNumbers are gimmes<br>&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt; * adding module fills a big hole.<br>&gt; <br>&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jan 24, 2016, at 4:12 PM, Remy Demarest &lt;remy.demarest at gmail.com &lt;mailto:remy.demarest at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 I love the idea of having not-only consistent naming convention for compiler-magic code starting with #.<br>&gt;&gt; <br>&gt;&gt; And I also love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.<br>&gt;&gt; <br>&gt;&gt; Remy Demarest<br>&gt;&gt; remy.demarest at gmail.com &lt;mailto:remy.demarest at gmail.com&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 23 janv. 2016 à 18:46, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pull request: https://github.com/apple/swift-evolution/pull/116 &lt;https://github.com/apple/swift-evolution/pull/116&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/a732822b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What do you think of:<br>&gt; <br>&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br></p><p>I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the `#line = ...` syntax a few people suggested.<br></p><p>-Joe<br></p><p>&gt; and calling it a day?<br>&gt; <br>&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt; * file and lineNumbers are gimmes<br>&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt; * adding module fills a big hole.<br>&gt; <br>&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jan 24, 2016, at 4:12 PM, Remy Demarest &lt;remy.demarest at gmail.com &lt;mailto:remy.demarest at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 I love the idea of having not-only consistent naming convention for compiler-magic code starting with #.<br>&gt;&gt; <br>&gt;&gt; And I also love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.<br>&gt;&gt; <br>&gt;&gt; Remy Demarest<br>&gt;&gt; remy.demarest at gmail.com &lt;mailto:remy.demarest at gmail.com&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 23 janv. 2016 à 18:46, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pull request: https://github.com/apple/swift-evolution/pull/116 &lt;https://github.com/apple/swift-evolution/pull/116&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; line-control-statement → #line­<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;line-control-statement → #line­line-number &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;­file-name &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;­<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;line-number → A decimal integer greater than zero<br>&gt;&gt;&gt;&gt;&gt;  &lt;&gt;file-name → static-string-literal &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;­<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Huh ok, I forgot we supported that.  We could handle that by requiring that form of #line to be at the start of a line, if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/6e189525/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Instead of #contextDictionary, what about #source. If it&#39;s a dictionary, I<br>think that would read better:<br></p><p>#source[&#39;file&#39;]<br>#source[&#39;line&#39;]<br>...<br></p><p>On Tue, Jan 26, 2016 at 4:48 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What do you think of:<br>&gt;<br>&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init),<br>&gt; #module, #contextDictionary<br>&gt;<br>&gt; and calling it a day?<br>&gt;<br>&gt; * using contextDictionary allows expandability and can subsume all<br>&gt; existing context elements, indexed presumably by the same names<br>&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt; * file and lineNumbers are gimmes<br>&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog<br>&gt; on this)<br>&gt; * adding module fills a big hole.<br>&gt;<br>&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Jan 24, 2016, at 4:12 PM, Remy Demarest &lt;remy.demarest at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; +1 I love the idea of having not-only consistent naming convention for<br>&gt; compiler-magic code starting with #.<br>&gt;<br>&gt; And I also love the idea that source location would be one object that you<br>&gt; can print to get the full story while still retaining the possibility to<br>&gt; use each individual components as needed, which is probably the rarer case.<br>&gt; I never find myself wanting only some of properties and usually don&#39;t<br>&gt; include them simply because it takes longer to write the format properly,<br>&gt; if I can get them all in one go it&#39;s certainly a win.<br>&gt;<br>&gt; Remy Demarest<br>&gt; remy.demarest at gmail.com<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 23 janv. 2016 à 18:46, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Pull request: https://github.com/apple/swift-evolution/pull/116<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 5:40 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 1:43 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;<br>&gt; Indeed. Here’s the grammar from TSPL:<br>&gt;<br>&gt; line-control-statement → #line­<br>&gt; line-control-statement → #line­line-number<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-number&gt;<br>&gt; ­file-name<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/file-name&gt;<br>&gt; ­<br>&gt; line-number → A decimal integer greater than zero<br>&gt; file-name → static-string-literal<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal&gt;<br>&gt; ­<br>&gt;<br>&gt;<br>&gt; Huh ok, I forgot we supported that.  We could handle that by requiring<br>&gt; that form of #line to be at the start of a line, if necessary.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/fbda4b25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 26, 2016 at 07:00:00pm</p></header><div class="content"><p>-1 I don’t mind how it reads, but Dictionaries return optionals.<br></p><p>&gt; On Jan 26, 2016, at 15:44, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Instead of #contextDictionary, what about #source. If it&#39;s a dictionary, I think that would read better:<br>&gt; <br>&gt; #source[&#39;file&#39;]<br>&gt; #source[&#39;line&#39;]<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>January 27, 2016 at 03:00:00am</p></header><div class="content"><p>I have no strong feelings on the proposal, but I would like to confirm that the behavior will remain the same--this simply changes the name of these identifiers, is that correct?<br>I ask because swift-corelibs-xctest and the Objective-C XCTest SDK overlay use `__FILE__` and `__LINE__` as default parameters for assertion functions (see: https://github.com/apple/swift-corelibs-xctest/blob/73ff15ac353e6596bf314d66f90e1471043cf071/Sources/XCTest/XCTAssert.swift#L158). These currently evaluate to the callsite of the function: calling `XCTAssert(true)` in a file named &quot;Foo.swift&quot; expands to `XCTAssertTrue(true, file: &quot;Foo.swift&quot;)`.<br>As we attempt to replicate the Objective-C XCTest API in swift-corelibs-xctest, we&#39;re beginning to rely on these identifiers more (see: https://github.com/apple/swift-corelibs-xctest/pull/43). It would be quite the setback if the behavior of the identifiers changed on us, so I just wanted to confirm that this proposal is only discussing naming, not behavior.<br>- Brian Gesiak<br></p><p><br></p><p>On Tue, Jan 26, 2016 at 7:13 PM -0800, &quot;Dave via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-1 I don’t mind how it reads, but Dictionaries return optionals.<br></p><p>&gt; On Jan 26, 2016, at 15:44, Trent Nadeau via swift-evolution  wrote:<br>&gt; <br>&gt; Instead of #contextDictionary, what about #source. If it&#39;s a dictionary, I think that would read better:<br>&gt; <br>&gt; #source[&#39;file&#39;]<br>&gt; #source[&#39;line&#39;]<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/93b3b0da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 7:41 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have no strong feelings on the proposal, but I would like to confirm that the behavior will remain the same--this simply changes the name of these identifiers, is that correct?<br>&gt; <br>&gt; I ask because swift-corelibs-xctest and the Objective-C XCTest SDK overlay use `__FILE__` and `__LINE__` as default parameters for assertion functions (see: https://github.com/apple/swift-corelibs-xctest/blob/73ff15ac353e6596bf314d66f90e1471043cf071/Sources/XCTest/XCTAssert.swift#L158 &lt;https://github.com/apple/swift-corelibs-xctest/blob/73ff15ac353e6596bf314d66f90e1471043cf071/Sources/XCTest/XCTAssert.swift#L158&gt;). These currently evaluate to the callsite of the function: calling `XCTAssert(true)` in a file named &quot;Foo.swift&quot; expands to `XCTAssertTrue(true, file: &quot;Foo.swift&quot;)`.<br>&gt; <br>&gt; As we attempt to replicate the Objective-C XCTest API in swift-corelibs-xctest, we&#39;re beginning to rely on these identifiers more (see: https://github.com/apple/swift-corelibs-xctest/pull/43 &lt;https://github.com/apple/swift-corelibs-xctest/pull/43&gt;). It would be quite the setback if the behavior of the identifiers changed on us, so I just wanted to confirm that this proposal is only discussing naming, not behavior.<br></p><p>This proposal does not change the behavior; #sourceLocation default arguments (or whatever we name it) will still be expanded at the call site. The Swift standard library depends on this fairly heavily, too.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/2274900b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; What do you think of:<br>&gt; <br>&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt; <br>&gt; and calling it a day?<br>&gt; <br>&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt; * file and lineNumbers are gimmes<br>&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt; * adding module fills a big hole.<br>&gt; <br>&gt; No tuples for Doug, covers some of Chris&#39;s points.<br></p><p>I mentioned this in the pull request:<br></p><p>I&#39;d suggest:<br>(file: String, line: Int, column: Int, symbol: String)<br></p><p>Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br></p><p><br>I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Module use case is to identify the source of a call, just like everything else.<br></p><p>https://gist.github.com/erica/3aa2cea3ab6d2acd56b4 &lt;https://gist.github.com/erica/3aa2cea3ab6d2acd56b4&gt; <br></p><p>-- E<br></p><p><br>&gt; On Jan 26, 2016, at 4:58 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What do you think of:<br>&gt;&gt; <br>&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt; <br>&gt;&gt; and calling it a day?<br>&gt;&gt; <br>&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt; * adding module fills a big hole.<br>&gt;&gt; <br>&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt; <br>&gt; I mentioned this in the pull request:<br>&gt; <br>&gt; I&#39;d suggest:<br>&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt; <br>&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt; <br>&gt; <br>&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/a06fd835/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Joseph Lord</string> &lt;Joseph at human-friendly.com&gt;<p>January 27, 2016 at 02:00:00am</p></header><div class="content"><p>Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime. (I have a fuller logging idea but have noted it is the example of out of scope and decided not to argue at this point). <br></p><p>Joseph<br></p><p><br>&gt; On Jan 26, 2016, at 11:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What do you think of:<br>&gt;&gt; <br>&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt; <br>&gt;&gt; and calling it a day?<br>&gt;&gt; <br>&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt; * adding module fills a big hole.<br>&gt;&gt; <br>&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt; <br>&gt; I mentioned this in the pull request:<br>&gt; <br>&gt; I&#39;d suggest:<br>&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt; <br>&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt; <br>&gt; <br>&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 6:13 PM, Joseph Lord &lt;joseph at human-friendly.com&gt; wrote:<br>&gt; <br>&gt; Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime. (I have a fuller logging idea but have noted it is the example of out of scope and decided not to argue at this point). <br></p><p>Ok, but why can’t you split that off the front of the symbol name?  The advantage of providing a fully qualified symbol name is that it allows users of this feature to get exactly the information they want.  Unlike my suggestion below, it should also include parameter type information, so it can identify overloads properly.<br></p><p>Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day.  Providing all of the different things that clients could want seems like a never-ending problem.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Joseph<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 11:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and calling it a day?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt;&gt; * adding module fills a big hole.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt;&gt; <br>&gt;&gt; I mentioned this in the pull request:<br>&gt;&gt; <br>&gt;&gt; I&#39;d suggest:<br>&gt;&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt;&gt; <br>&gt;&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Modernizing Swift&#39;s Debugging Identifiers<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#introduction&gt;Introduction<br></p><p>This proposal aims to eliminate Swift&#39;s use of &quot;screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt;&quot; like __FILE__ and __FUNCTION__ and replacing identifier instances with common octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt; #identifier representations.<br></p><p>The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread and then in its own &quot;[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers&quot; thread<br></p><p> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#motivation&gt;Motivation<br></p><p>Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br></p><p>The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest &lt;https://s-media-cache-ak0.pinimg.com/originals/59/ea/ee/59eaee788c31463b70e6e3d4fca5508f.jpg&gt; fully swallowed keywords.<br></p><p> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#proposed-solution&gt;Proposed solution<br></p><p>Using octothorpe-prefixed keywords offers several advantages:<br></p><p>They match the existing #available keyword (D. Gregor)<br>They match SE-0022&#39;s already-accepted #selector(...) approach that reference a method&#39;s Objective-C selector (D. Gregor)<br>They support targeted code completion (D. Gregor)<br>They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#detailed-design&gt;Detailed design<br></p><p>This proposal renames the following identifiers:<br></p><p>__FILE__ -&gt; #file<br>__LINE__ -&gt; #line<br>__COLUMN__ -&gt; #column<br>__DSO_HANDLE__ -&gt; #dso_handle<br>This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br></p><p>A fully qualified symbol enables users to access exactly the information they desire. <br>It should contain parameter type information to properly identify member overloads.<br>Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br></p><p> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#sourcelocation&gt;#sourceLocation<br></p><p>SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br></p><p>public struct SourceLocation: CustomDebugStringConvertible {<br>    init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>        self.file = file<br>        self.line = line<br>        self.column = column<br>        self.function = function<br>    }<br></p><p>    public let file: String<br>    public let line: Int<br>    public let column: Int<br>    public let function: String<br></p><p>    public var debugDescription: String {<br>        return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>    }<br>}<br> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#summarizing-with-context&gt;Summarizing with #context<br></p><p>A #context identifier would provide a compound type to provide a common well-defined tuple or struct summary of the current context with addressable elements. Offering addressable elements with a single identifier provides clean implementation. It permits developers to customize output based on current build settings without having to decompose the #symbol identifier output in logging routines.<br></p><p>Choosing which elements to represent could be problematic. Chris Lattner writes, &quot;Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day. Providing all of the different things that clients could want seems like a never-ending problem.&quot;<br></p><p>In support of addressable elements, Joseph Lord writes, &quot;Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime.&quot;<br></p><p>In support of summaries, Remy Demerest writes, &quot;[I] love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.&quot;<br></p><p> &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#implementation-notes&gt;Implementation notes<br></p><p>Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested.&quot;<br></p><p><br>&gt; On Jan 26, 2016, at 11:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 6:13 PM, Joseph Lord &lt;joseph at human-friendly.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime. (I have a fuller logging idea but have noted it is the example of out of scope and decided not to argue at this point). <br>&gt; <br>&gt; Ok, but why can’t you split that off the front of the symbol name?  The advantage of providing a fully qualified symbol name is that it allows users of this feature to get exactly the information they want.  Unlike my suggestion below, it should also include parameter type information, so it can identify overloads properly.<br>&gt; <br>&gt; Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day.  Providing all of the different things that clients could want seems like a never-ending problem.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Joseph<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 11:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and calling it a day?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt;&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt;&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt;&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt;&gt;&gt; * adding module fills a big hole.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mentioned this in the pull request:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d suggest:<br>&gt;&gt;&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/46ef712e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 27 janv. 2016 à 17:56, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; [..]<br>&gt; This proposal renames the following identifiers:<br>&gt; <br>&gt; __FILE__ -&gt; #file<br>&gt; __LINE__ -&gt; #line<br>&gt; __COLUMN__ -&gt; #column<br>&gt; __DSO_HANDLE__ -&gt; #dso_handle<br>&gt; This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br>&gt; <br>&gt; A fully qualified symbol enables users to access exactly the information they desire. <br>&gt; It should contain parameter type information to properly identify member overloads.<br>&gt; Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br>&gt; <br>The fully qualified name could be quite long on occasion as I would expect it to include class hierarchy, nested class and nested function. So there might still be some usefulness in the brevity of a #function (__FUNCTION__). Revealing the fully qualified name is useful for fixing bug and understanding the code flow, but some people could see it as a security concern, as it reveal how your code is structured. <br></p><p>On the brevity side, #file may benefit from a filename only version. I personally never liked seeing my user id in the output of __FILE__. On large project the filename only is not a perfect differentiator, but with __FUNCTION__ it is a nice starting point to find where the code reside ( find ./ -name FILE -exec grep -l FUNCTION {} \; ).<br></p><p>With the help of __LINE__, I start to even wonder if the calling signature (argument list) is even required as part of __FUNCTION__, but I don’t want to start long discussion on that topic, so I’ll drop the matter.<br></p><p>For #file, the user code can easily post-process the data and do an equivalent of basename(), but nonetheless the original __FILE__ has to be somewhere inside my final binary (and showing my user id)<br></p><p>For the #symbol, I do not think it would be that easy for user code to go extract the function name.<br></p><p>I think that keeping #function should be added to this proposal (assuming other support the idea).<br>And that the #shortfile (or whatever name) should be investigated later as a distinct proposal (again based on support for the idea).<br>The current proposal should only avoid preventing the possibility of providing a short file version in the future<br></p><p>Just for the record, I started to reply wanting a really long #symbol for the hierarchy and nesting, and convinced myself that I only needed the bare function name, file name and line number to find where a log was generated. On some rare case, I guess I might need the column number (like in the nice example from David)<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#implementation-notes&gt;Implementation notes<br>&gt; <br>&gt; Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested. »<br></p><p>Using the #line = … syntax would need a reset syntax (#line = resume | default | real), which could make such implementation a little more complex than the simple wording above suggest, a note to that effect should be added to the proposal.<br></p><p>Dany St-Amant<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/e269ffe4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>January 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Le 28 janv. 2016 à 05:26, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Le 27 janv. 2016 à 17:56, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; [..]<br>&gt;&gt; This proposal renames the following identifiers:<br>&gt;&gt; <br>&gt;&gt; __FILE__ -&gt; #file<br>&gt;&gt; __LINE__ -&gt; #line<br>&gt;&gt; __COLUMN__ -&gt; #column<br>&gt;&gt; __DSO_HANDLE__ -&gt; #dso_handle<br>&gt;&gt; This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br>&gt;&gt; <br>&gt;&gt; A fully qualified symbol enables users to access exactly the information they desire. <br>&gt;&gt; It should contain parameter type information to properly identify member overloads.<br>&gt;&gt; Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br>&gt;&gt; <br>&gt; The fully qualified name could be quite long on occasion as I would expect it to include class hierarchy, nested class and nested function. So there might still be some usefulness in the brevity of a #function (__FUNCTION__). Revealing the fully qualified name is useful for fixing bug and understanding the code flow, but some people could see it as a security concern, as it reveal how your code is structured. <br>&gt; <br>&gt; On the brevity side, #file may benefit from a filename only version. I personally never liked seeing my user id in the output of __FILE__. On large project the filename only is not a perfect differentiator, but with __FUNCTION__ it is a nice starting point to find where the code reside ( find ./ -name FILE -exec grep -l FUNCTION {} \; ).<br>&gt; <br>&gt; With the help of __LINE__, I start to even wonder if the calling signature (argument list) is even required as part of __FUNCTION__, but I don’t want to start long discussion on that topic, so I’ll drop the matter.<br>&gt; <br>&gt; For #file, the user code can easily post-process the data and do an equivalent of basename(), but nonetheless the original __FILE__ has to be somewhere inside my final binary (and showing my user id)<br>&gt; <br>&gt; For the #symbol, I do not think it would be that easy for user code to go extract the function name.<br>&gt; <br>&gt; I think that keeping #function should be added to this proposal (assuming other support the idea).<br>&gt; And that the #shortfile (or whatever name) should be investigated later as a distinct proposal (again based on support for the idea).<br>&gt; The current proposal should only avoid preventing the possibility of providing a short file version in the future<br></p><p>I can&#39;t see a use case where you want to hide a part of the path in some files, and let it in other files, so having both #file and #shortFile don’t look that useful.<br></p><p>Maybe instead of having a #shortFile directive, we should consider adding a compiler flag to specify the project root, and just let the compiler expands the #file directive using a path relative to that root instead of the absolute path.<br></p><p><br>&gt; Just for the record, I started to reply wanting a really long #symbol for the hierarchy and nesting, and convinced myself that I only needed the bare function name, file name and line number to find where a log was generated. On some rare case, I guess I might need the column number (like in the nice example from David)<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#implementation-notes&gt;Implementation notes<br>&gt;&gt; <br>&gt;&gt; Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested. »<br>&gt; <br>&gt; Using the #line = … syntax would need a reset syntax (#line = resume | default | real), which could make such implementation a little more complex than the simple wording above suggest, a note to that effect should be added to the proposal.<br>&gt; <br>&gt; Dany St-Amant<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/e4d0e691/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>As someone who has custom code in her error contextualization code for trimming file name&#39;s last component, I thoroughly understand the desire for short file. I would be happy to add it in.<br></p><p>The fully qualified name is left as an exercise for Apple, but I will update the proposal to include that concern, so it&#39;s there and ready for discussion.<br></p><p>I hear what you are saying about decomposing #symbol and will add that concern to the proposal.<br></p><p>-- Erica<br></p><p><br>&gt; On Jan 27, 2016, at 9:26 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 27 janv. 2016 à 17:56, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; [..]<br>&gt;&gt; This proposal renames the following identifiers:<br>&gt;&gt; <br>&gt;&gt; __FILE__ -&gt; #file<br>&gt;&gt; __LINE__ -&gt; #line<br>&gt;&gt; __COLUMN__ -&gt; #column<br>&gt;&gt; __DSO_HANDLE__ -&gt; #dso_handle<br>&gt;&gt; This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br>&gt;&gt; <br>&gt;&gt; A fully qualified symbol enables users to access exactly the information they desire. <br>&gt;&gt; It should contain parameter type information to properly identify member overloads.<br>&gt;&gt; Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br>&gt;&gt; <br>&gt; The fully qualified name could be quite long on occasion as I would expect it to include class hierarchy, nested class and nested function. So there might still be some usefulness in the brevity of a #function (__FUNCTION__). Revealing the fully qualified name is useful for fixing bug and understanding the code flow, but some people could see it as a security concern, as it reveal how your code is structured. <br>&gt; <br>&gt; On the brevity side, #file may benefit from a filename only version. I personally never liked seeing my user id in the output of __FILE__. On large project the filename only is not a perfect differentiator, but with __FUNCTION__ it is a nice starting point to find where the code reside ( find ./ -name FILE -exec grep -l FUNCTION {} \; ).<br>&gt; <br>&gt; With the help of __LINE__, I start to even wonder if the calling signature (argument list) is even required as part of __FUNCTION__, but I don’t want to start long discussion on that topic, so I’ll drop the matter.<br>&gt; <br>&gt; For #file, the user code can easily post-process the data and do an equivalent of basename(), but nonetheless the original __FILE__ has to be somewhere inside my final binary (and showing my user id)<br>&gt; <br>&gt; For the #symbol, I do not think it would be that easy for user code to go extract the function name.<br>&gt; <br>&gt; I think that keeping #function should be added to this proposal (assuming other support the idea).<br>&gt; And that the #shortfile (or whatever name) should be investigated later as a distinct proposal (again based on support for the idea).<br>&gt; The current proposal should only avoid preventing the possibility of providing a short file version in the future<br>&gt; <br>&gt; Just for the record, I started to reply wanting a really long #symbol for the hierarchy and nesting, and convinced myself that I only needed the bare function name, file name and line number to find where a log was generated. On some rare case, I guess I might need the column number (like in the nice example from David)<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#implementation-notes&gt;Implementation notes<br>&gt;&gt; <br>&gt;&gt; Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested. »<br>&gt; <br>&gt; Using the #line = … syntax would need a reset syntax (#line = resume | default | real), which could make such implementation a little more complex than the simple wording above suggest, a note to that effect should be added to the proposal.<br>&gt; <br>&gt; Dany St-Amant<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/93626985/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for the proposal, Erica. I support the change. However, I prefer the #sourceLocation alternative syntax, though some compiler smarts around instantiation rather than embedding the old snake-case identifiers in the default arguments of the initializer.<br></p><p>That is, if I just wanted to reference the line number, I could write `#sourceLocation.line`, but if I wanted full context information I could use #sourceLocation, which would resolve to an instance of the struct. The compiler could use look ahead to avoid allocating the struct when only individual members are accessed. (Though perhaps the optimizer would make this front-end optimization unnecessary.) <br></p><p>In keeping with the proposal, I&#39;d drop `function` from #sourceLocation in favor of `symbol`. I&#39;m not familiar with how __DSO_HANDLE__ is used, so don&#39;t know whether it makes more sense as `#sourceLocation.dsoHandle` or whether it should stand alone. Assuming it belongs with the others, I&#39;d suggest the #sourceLocation semantically represent an instance of a struct:<br></p><p>public struct SourceLocation: CustomDebugStringConvertible {<br>    public let file: String<br>    public let line: Int<br>    public let column: Int<br>    public let symbol: String<br>    public let dsoHandle: String<br></p><p>    public var debugDescription: String {<br>        return &quot;\(symbol):\(dsoHandle) @ \(file):\(line):\(column)&quot;<br>    }<br>}<br></p><p>As I said, I&#39;m supportive of the proposal, but just have a preference for the alternative syntax. If folks don&#39;t want to go that direction, then perhaps some discussion of why not would strengthen the proposal.<br></p><p>If we stick with the proposal for multiple special identifiers, I think #dso_handle should be #dsoHandle. If we&#39;re going to kill the snake case, we should kill it dead.<br></p><p>(Regarding the #context approach, I don&#39;t think I fully understand it. I read the prior threads, but must have forgotten that bit. Is #context just an alternative to #symbol that provides NSURLComponents-like addressing of the pieces of the symbol? A concrete example of using #context would strengthen the argument against this option.)<br></p><p>Cheers,<br></p><p>Curt<br></p><p>-------------------------<br>Curt Clifton, PhD<br>Software Developer<br>The Omni Group<br>www.curtclifton.net <br></p><p><br></p><p>&gt; On Jan 27, 2016, at 2:56 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Modernizing Swift&#39;s Debugging Identifiers<br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims to eliminate Swift&#39;s use of &quot;screaming snake case&quot; like __FILE__ and __FUNCTION__ and replacing identifier instances with common octothorpe-prefixed lower camel case #identifier representations.<br>&gt; <br>&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread and then in its own &quot;[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers&quot; thread<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context.<br>&gt; <br>&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest fully swallowed keywords.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt; <br>&gt; They match the existing #available keyword (D. Gregor)<br>&gt; They match SE-0022&#39;s already-accepted #selector(...) approach that reference a method&#39;s Objective-C selector (D. Gregor)<br>&gt; They support targeted code completion (D. Gregor)<br>&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt; Detailed design<br>&gt; <br>&gt; This proposal renames the following identifiers:<br>&gt; <br>&gt; __FILE__ -&gt; #file<br>&gt; __LINE__ -&gt; #line<br>&gt; __COLUMN__ -&gt; #column<br>&gt; __DSO_HANDLE__ -&gt; #dso_handle<br>&gt; This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br>&gt; <br>&gt; A fully qualified symbol enables users to access exactly the information they desire. <br>&gt; It should contain parameter type information to properly identify member overloads.<br>&gt; Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; #sourceLocation<br>&gt; <br>&gt; SR-198 requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett offered an initial design: <br>&gt; <br>&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;         self.file = file<br>&gt;         self.line = line<br>&gt;         self.column = column<br>&gt;         self.function = function<br>&gt;     }<br>&gt; <br>&gt;     public let file: String<br>&gt;     public let line: Int<br>&gt;     public let column: Int<br>&gt;     public let function: String<br>&gt; <br>&gt;     public var debugDescription: String {<br>&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;     }<br>&gt; }<br>&gt; Summarizing with #context<br>&gt; <br>&gt; A #context identifier would provide a compound type to provide a common well-defined tuple or struct summary of the current context with addressable elements. Offering addressable elements with a single identifier provides clean implementation. It permits developers to customize output based on current build settings without having to decompose the #symbol identifier output in logging routines.<br>&gt; <br>&gt; Choosing which elements to represent could be problematic. Chris Lattner writes, &quot;Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day. Providing all of the different things that clients could want seems like a never-ending problem.&quot;<br>&gt; <br>&gt; In support of addressable elements, Joseph Lord writes, &quot;Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime.&quot;<br>&gt; <br>&gt; In support of summaries, Remy Demerest writes, &quot;[I] love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.&quot;<br>&gt; <br>&gt; Implementation notes<br>&gt; <br>&gt; Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested.&quot;<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 11:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 6:13 PM, Joseph Lord &lt;joseph at human-friendly.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime. (I have a fuller logging idea but have noted it is the example of out of scope and decided not to argue at this point).<br>&gt;&gt; <br>&gt;&gt; Ok, but why can’t you split that off the front of the symbol name?  The advantage of providing a fully qualified symbol name is that it allows users of this feature to get exactly the information they want.  Unlike my suggestion below, it should also include parameter type information, so it can identify overloads properly.<br>&gt;&gt; <br>&gt;&gt; Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day.  Providing all of the different things that clients could want seems like a never-ending problem.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joseph<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 11:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think of:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and calling it a day?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt;&gt;&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt;&gt;&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt;&gt;&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt;&gt;&gt;&gt; * adding module fills a big hole.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I mentioned this in the pull request:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d suggest:<br>&gt;&gt;&gt;&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/280b473e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>Oh good gracious. Did I not change dso_handle to dsoHandle? I meant to. Will fix.<br></p><p>-- E<br></p><p>&gt; On Jan 27, 2016, at 10:47 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the proposal, Erica. I support the change. However, I prefer the #sourceLocation alternative syntax, though some compiler smarts around instantiation rather than embedding the old snake-case identifiers in the default arguments of the initializer.<br>&gt; <br>&gt; That is, if I just wanted to reference the line number, I could write `#sourceLocation.line`, but if I wanted full context information I could use #sourceLocation, which would resolve to an instance of the struct. The compiler could use look ahead to avoid allocating the struct when only individual members are accessed. (Though perhaps the optimizer would make this front-end optimization unnecessary.) <br>&gt; <br>&gt; In keeping with the proposal, I&#39;d drop `function` from #sourceLocation in favor of `symbol`. I&#39;m not familiar with how __DSO_HANDLE__ is used, so don&#39;t know whether it makes more sense as `#sourceLocation.dsoHandle` or whether it should stand alone. Assuming it belongs with the others, I&#39;d suggest the #sourceLocation semantically represent an instance of a struct:<br>&gt; <br>&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;     public let file: String<br>&gt;     public let line: Int<br>&gt;     public let column: Int<br>&gt;     public let symbol: String<br>&gt;     public let dsoHandle: String<br>&gt; <br>&gt;     public var debugDescription: String {<br>&gt;         return &quot;\(symbol):\(dsoHandle) @ \(file):\(line):\(column)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; As I said, I&#39;m supportive of the proposal, but just have a preference for the alternative syntax. If folks don&#39;t want to go that direction, then perhaps some discussion of why not would strengthen the proposal.<br>&gt; <br>&gt; If we stick with the proposal for multiple special identifiers, I think #dso_handle should be #dsoHandle. If we&#39;re going to kill the snake case, we should kill it dead.<br>&gt; <br>&gt; (Regarding the #context approach, I don&#39;t think I fully understand it. I read the prior threads, but must have forgotten that bit. Is #context just an alternative to #symbol that provides NSURLComponents-like addressing of the pieces of the symbol? A concrete example of using #context would strengthen the argument against this option.)<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; -------------------------<br>&gt; Curt Clifton, PhD<br>&gt; Software Developer<br>&gt; The Omni Group<br>&gt; www.curtclifton.net &lt;http://www.curtclifton.net/&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jan 27, 2016, at 2:56 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Modernizing Swift&#39;s Debugging Identifiers<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims to eliminate Swift&#39;s use of &quot;screaming snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt;&quot; like __FILE__ and __FUNCTION__ and replacing identifier instances with common octothorpe-prefixed &lt;https://en.wiktionary.org/wiki/octothorpe&gt; lower camel case &lt;https://en.wikipedia.org/wiki/CamelCase&gt; #identifier representations.<br>&gt;&gt; <br>&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Review] SE-0022: Referencing the Objective-C selector of a method&quot; thread and then in its own &quot;[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers&quot; thread<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s pre-processor offers built-in __FILE__, __LINE__, __COLUMN__, and __FUNCTION__ identifiers. These expand to string and integer literals corresponding to a current location in source code. This feature provides high utility for logging, both tracing execution through logged messages and enabling developers to capture error context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;.<br>&gt;&gt; <br>&gt;&gt; The current identifiers owe their syntax to C&#39;s __FILE__ and __LINE__ macros. These are built into C&#39;s preprocessor and expanded before running the C-language parser. Swift&#39;s implementation differs from C&#39;s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming camel case, which look like boa constrictors trying to digest &lt;https://s-media-cache-ak0.pinimg.com/originals/59/ea/ee/59eaee788c31463b70e6e3d4fca5508f.jpg&gt; fully swallowed keywords.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Using octothorpe-prefixed keywords offers several advantages:<br>&gt;&gt; <br>&gt;&gt; They match the existing #available keyword (D. Gregor)<br>&gt;&gt; They match SE-0022&#39;s already-accepted #selector(...) approach that reference a method&#39;s Objective-C selector (D. Gregor)<br>&gt;&gt; They support targeted code completion (D. Gregor)<br>&gt;&gt; They add a compiler-supported expression type that doesn&#39;t steal keywords, introducing a convention where # means &quot;invoke compiler substitution logic here&quot; (J. Rose)<br>&gt;&gt; They&#39;d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor)<br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; This proposal renames the following identifiers:<br>&gt;&gt; <br>&gt;&gt; __FILE__ -&gt; #file<br>&gt;&gt; __LINE__ -&gt; #line<br>&gt;&gt; __COLUMN__ -&gt; #column<br>&gt;&gt; __DSO_HANDLE__ -&gt; #dso_handle<br>&gt;&gt; This proposal eliminates __FUNCTION__. It introduces #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. <br>&gt;&gt; <br>&gt;&gt; A fully qualified symbol enables users to access exactly the information they desire. <br>&gt;&gt; It should contain parameter type information to properly identify member overloads.<br>&gt;&gt; Each identifier will still expand at the call site, ensuring that the behavior matches that from the current suite.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#sourcelocation&gt;#sourceLocation<br>&gt;&gt; <br>&gt;&gt; SR-198 &lt;https://bugs.swift.org/browse/SR-198&gt; requested the coalescing of the existing file, line, and function identifiers, potentially supporting a module representation as well. Andrew Bennett &lt;https://bugs.swift.org/secure/ViewProfile.jspa?name=bnut&gt; offered an initial design: <br>&gt;&gt; <br>&gt;&gt; public struct SourceLocation: CustomDebugStringConvertible {<br>&gt;&gt;     init(file: String = __FILE__, line: Int = __LINE__, column: Int = __COLUMN__, function: String = __FUNCTION__) {<br>&gt;&gt;         self.file = file<br>&gt;&gt;         self.line = line<br>&gt;&gt;         self.column = column<br>&gt;&gt;         self.function = function<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public let file: String<br>&gt;&gt;     public let line: Int<br>&gt;&gt;     public let column: Int<br>&gt;&gt;     public let function: String<br>&gt;&gt; <br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;\(function) @ \(file):\(line):\(column)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#summarizing-with-context&gt;Summarizing with #context<br>&gt;&gt; <br>&gt;&gt; A #context identifier would provide a compound type to provide a common well-defined tuple or struct summary of the current context with addressable elements. Offering addressable elements with a single identifier provides clean implementation. It permits developers to customize output based on current build settings without having to decompose the #symbol identifier output in logging routines.<br>&gt;&gt; <br>&gt;&gt; Choosing which elements to represent could be problematic. Chris Lattner writes, &quot;Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day. Providing all of the different things that clients could want seems like a never-ending problem.&quot;<br>&gt;&gt; <br>&gt;&gt; In support of addressable elements, Joseph Lord writes, &quot;Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime.&quot;<br>&gt;&gt; <br>&gt;&gt; In support of summaries, Remy Demerest writes, &quot;[I] love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don&#39;t include them simply because it takes longer to write the format properly, if I can get them all in one go it&#39;s certainly a win.&quot;<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/8b8c7eb841da39ac47c7#implementation-notes&gt;Implementation notes<br>&gt;&gt; <br>&gt;&gt; Although the octothorpe-delineated #line identifier already exists in Swift for resetting line numbers (J. Lawrence), context can distinguish between uses. Joe Groff writes, &quot;I&#39;d prefer to use #line for this, and constrain the use of the current #line directive by context; like Chris said, we could require it to be the first thing after a newline, or we could adopt the #line = ... syntax a few people suggested.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 11:51 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 6:13 PM, Joseph Lord &lt;joseph at human-friendly.com &lt;mailto:joseph at human-friendly.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Module information would be useful for a logging library, possibly to print the information but possibly also to allow different log levels (e.g. info, debug, warning, error, criticalError) to be configured for each module in a project so that log spam is manageable and possibly adjustable at runtime. (I have a fuller logging idea but have noted it is the example of out of scope and decided not to argue at this point). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, but why can’t you split that off the front of the symbol name?  The advantage of providing a fully qualified symbol name is that it allows users of this feature to get exactly the information they want.  Unlike my suggestion below, it should also include parameter type information, so it can identify overloads properly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Splitting out module, type, method, or other information is prone to issues given that we allow nesting of types, nesting of functions, and perhaps nesting of modules some day.  Providing all of the different things that clients could want seems like a never-ending problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joseph<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 11:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What do you think of:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #file, #lineNumber, #column, #symbol (e.g. Swift.Dictionary.init), #module, #contextDictionary<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and calling it a day?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * using contextDictionary allows expandability and can subsume all existing context elements, indexed presumably by the same names<br>&gt;&gt;&gt;&gt;&gt;&gt; * renaming function to symbol takes care of self.dynamicType as well<br>&gt;&gt;&gt;&gt;&gt;&gt; * file and lineNumbers are gimmes<br>&gt;&gt;&gt;&gt;&gt;&gt; * column is apparently well liked by some (not going to kick someone&#39;s dog on this)<br>&gt;&gt;&gt;&gt;&gt;&gt; * adding module fills a big hole.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No tuples for Doug, covers some of Chris&#39;s points.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I mentioned this in the pull request:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d suggest:<br>&gt;&gt;&gt;&gt;&gt; (file: String, line: Int, column: Int, symbol: String)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Where symbol would be the fully qualified name like &quot;Swift.Dictionary.init”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m curious to hear what Doug’s concern about using tuples are.  Also, what is the use-case for #module?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/d8d88ef4/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 22, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 for anything that removes underscores — those inherited from Haskell(?) are more than enough ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Eliminating Swift&#39;s Screaming Snake Case Identifiers</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 22, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 for improved consistency of the names and the &quot;#&quot; symbol in general.<br></p><p>On Fri, Jan 22, 2016 at 5:40 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for anything that removes underscores — those inherited from Haskell(?)<br>&gt; are more than enough ;-)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/4845199b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
