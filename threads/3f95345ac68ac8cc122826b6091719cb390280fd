<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 11:00:00am</p></header><div class="content"><p>I put together the skeleton of a proposal detailing enhancements to how<br>associated types can be referenced in Swift 3+. It&#39;s certainly not ready<br>for submission, but I think it gets across my ideas pretty well. Would love<br>to gather feedback and especially improvements.<br></p><p>Be unsparing; whatever form this feature takes will profoundly affect how<br>Swift developers program for years, so it needs to be done right.<br></p><p>See below:<br></p><p>*Proposal*<br></p><p>An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential<br>types can be nested.<br></p><p>The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br></p><p>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated<br>by semicolons. (This is so commas can be used in where constraints, below.<br>Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas<br>exclusively.)<br></p><p>There are five different possible clauses:<br></p><p><br>   - &#39;class&#39;. Must be the first clause, if present. Places a constraint on<br>   the existential to be any class type. (Implies: Only one can exist.<br>   Mutually exclusive with class name clause.)<br></p><p><br>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a<br>counterpart.)<br></p><p><br>   - Class name. Must be the first clause, if present. (Implies: Only one<br>   can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>   existential (not really an existential anymore) to be an instance of the<br>   class, or one of its subclasses.<br></p><p>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data<br>source and delegate protocols&quot;<br></p><p>   - Dynamic protocol. This is entirely composed of the name of a protocol<br>   which has no associated types or Self requirement.<br></p><p><br>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and<br>BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated<br>types or self requirements. Feel free to propose a more sound name.<br></p><p><br>   - Self-contained static protocol, simple. This is composed of the name<br>   of a static protocol, optionally followed by a &#39;where&#39; clause in which the<br>   associated types can be constrained (with any of the three basic<br>   conformance types: subclassing, protocol conformance, or type equality).<br>   Associated types are referred to with a leading dot.<br></p><p><br>Example: Any&lt;Collection where .Generator.Element : NSObject,<br>.Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their<br>subclasses conforming to SomeProtocol.&quot;<br></p><p><br>   - Bound static protocol. This is the same as a self-contained static<br>   protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>   generic typealias. The name can be then be used in subsequent clauses to<br>   build constraints.<br></p><p><br>Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>.IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer<br>literal, in which the collection elements are the same type as the type of<br>the integer used for the integer literal conformance.&quot;<br></p><p>There will be rules to prevent recursive nesting. For example, if generic<br>typealiases are allowed, they cannot refer to each other in a circular<br>manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a<br>cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by<br>the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there<br>were any methods on Equatable that did not use the associated types at all<br>you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable<br>where .Self == String&gt;&#39; would allow for == to be called on instances. (This<br>is a stupid example, since Any&lt;Equatable where .Self == String&gt; is<br>equivalent to &#39;String&#39;, but there are almost certainly useful examples one<br>could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br></p><p>   - Don&#39;t constrain any associated types. You can pass around<br>   Any&lt;Equatable&gt;s, but that&#39;s about it.<br>   - Constrain associated types to conform to protocols.<br>   - Fully constrain associated types.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/3f9580fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 17, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 for extending my proposal and making `Any&lt;&gt;` even more a powerful beast. :)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br></p><p>Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br></p><p>See below:<br></p><p>Proposal<br></p><p>An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br></p><p>The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br></p><p>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>There are five different possible clauses:<br></p><p>&#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br></p><p>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br></p><p>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br></p><p>Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br></p><p>Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.&quot;<br></p><p>Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br></p><p>Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.&quot;<br></p><p>There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br>Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>Constrain associated types to conform to protocols.<br>Fully constrain associated types.<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/fd7ffdec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 12:00:00pm</p></header><div class="content"><p>Feel free to add as much of this proposal into yours as you want.<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 12:09 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for extending my proposal and making `Any&lt;&gt;` even more a powerful<br>&gt; beast. :)<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; I put together the skeleton of a proposal detailing enhancements to how<br>&gt; associated types can be referenced in Swift 3+. It&#39;s certainly not ready<br>&gt; for submission, but I think it gets across my ideas pretty well. Would love<br>&gt; to gather feedback and especially improvements.<br>&gt;<br>&gt; Be unsparing; whatever form this feature takes will profoundly affect how<br>&gt; Swift developers program for years, so it needs to be done right.<br>&gt;<br>&gt; See below:<br>&gt;<br>&gt; *Proposal*<br>&gt;<br>&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential<br>&gt; types can be nested.<br>&gt;<br>&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br>&gt;<br>&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt; separated by semicolons. (This is so commas can be used in where<br>&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt; can use commas exclusively.)<br>&gt;<br>&gt; There are five different possible clauses:<br>&gt;<br>&gt;<br>&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a constraint<br>&gt;    on the existential to be any class type. (Implies: Only one can exist.<br>&gt;    Mutually exclusive with class name clause.)<br>&gt;<br>&gt;<br>&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a<br>&gt; counterpart.)<br>&gt;<br>&gt;<br>&gt;    - Class name. Must be the first clause, if present. (Implies: Only one<br>&gt;    can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;    class, or one of its subclasses.<br>&gt;<br>&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt; &quot;Any UIViewController or subclass which also satisfies the table view data<br>&gt; source and delegate protocols&quot;<br>&gt;<br>&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;    protocol which has no associated types or Self requirement.<br>&gt;<br>&gt;<br>&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt; BooleanType protocols&quot;<br>&gt;<br>&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated<br>&gt; types or self requirements. Feel free to propose a more sound name.<br>&gt;<br>&gt;<br>&gt;    - Self-contained static protocol, simple. This is composed of the name<br>&gt;    of a static protocol, optionally followed by a &#39;where&#39; clause in which the<br>&gt;    associated types can be constrained (with any of the three basic<br>&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;    Associated types are referred to with a leading dot.<br>&gt;<br>&gt;<br>&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt; .Generator.Element : SomeProtocol&gt;<br>&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt; subclasses conforming to SomeProtocol.&quot;<br>&gt;<br>&gt;<br>&gt;    - Bound static protocol. This is the same as a self-contained static<br>&gt;    protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>&gt;    generic typealias. The name can be then be used in subsequent clauses to<br>&gt;    build constraints.<br>&gt;<br>&gt;<br>&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt; literal, in which the collection elements are the same type as the type of<br>&gt; the integer used for the integer literal conformance.&quot;<br>&gt;<br>&gt; There will be rules to prevent recursive nesting. For example, if generic<br>&gt; typealiases are allowed, they cannot refer to each other in a circular<br>&gt; manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a<br>&gt; cyclic graph of enums containing themselves).<br>&gt;<br>&gt; How an existential can be used depends on what guarantees are provided by<br>&gt; the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there<br>&gt; were any methods on Equatable that did not use the associated types at all<br>&gt; you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable<br>&gt; where .Self == String&gt;&#39; would allow for == to be called on instances. (This<br>&gt; is a stupid example, since Any&lt;Equatable where .Self == String&gt; is<br>&gt; equivalent to &#39;String&#39;, but there are almost certainly useful examples one<br>&gt; could come up with.)<br>&gt;<br>&gt; In order of increasing &#39;power&#39;:<br>&gt;<br>&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;    - Constrain associated types to conform to protocols.<br>&gt;    - Fully constrain associated types.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/16a6022d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 2:45 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Feel free to add as much of this proposal into yours as you want.<br></p><p>The trend is towards smaller proposals and introducing change in stages.  Since Adrian’s proposal is almost ready it’s probably best to move ahead with it as-is and follow up with generalized existentials (yours), and then possibly a third on “opening” existentials.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 17, 2016 at 12:09 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1 for extending my proposal and making `Any&lt;&gt;` even more a powerful beast. :)<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br>&gt;&gt; <br>&gt;&gt; Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br>&gt;&gt; <br>&gt;&gt; See below:<br>&gt;&gt; <br>&gt;&gt; Proposal<br>&gt;&gt; <br>&gt;&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br>&gt;&gt; <br>&gt;&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br>&gt;&gt; <br>&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt; <br>&gt;&gt; There are five different possible clauses:<br>&gt;&gt; <br>&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt; <br>&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt; <br>&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt; <br>&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt; <br>&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt; <br>&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.&quot;<br>&gt;&gt; <br>&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt; <br>&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.&quot;<br>&gt;&gt; <br>&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt; <br>&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt; <br>&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt; Fully constrain associated types.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/aa925733/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m honestly not sure it makes sense to introduce a proposal just for<br>expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying<br>to retrofit fuller support for other existentials onto it. I would prefer<br>that the &#39;basic package&#39; of existential cases be considered together as a<br>single proposal, unless a core team member expresses their preference<br>otherwise.<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 17, 2016, at 2:45 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Feel free to add as much of this proposal into yours as you want.<br>&gt;<br>&gt;<br>&gt; The trend is towards smaller proposals and introducing change in stages.<br>&gt; Since Adrian’s proposal is almost ready it’s probably best to move ahead<br>&gt; with it as-is and follow up with generalized existentials (yours), and then<br>&gt; possibly a third on “opening” existentials.<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 17, 2016 at 12:09 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1 for extending my proposal and making `Any&lt;&gt;` even more a powerful<br>&gt;&gt; beast. :)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (<br>&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;<br>&gt;&gt; I put together the skeleton of a proposal detailing enhancements to how<br>&gt;&gt; associated types can be referenced in Swift 3+. It&#39;s certainly not ready<br>&gt;&gt; for submission, but I think it gets across my ideas pretty well. Would love<br>&gt;&gt; to gather feedback and especially improvements.<br>&gt;&gt;<br>&gt;&gt; Be unsparing; whatever form this feature takes will profoundly affect how<br>&gt;&gt; Swift developers program for years, so it needs to be done right.<br>&gt;&gt;<br>&gt;&gt; See below:<br>&gt;&gt;<br>&gt;&gt; *Proposal*<br>&gt;&gt;<br>&gt;&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct.<br>&gt;&gt; Existential types can be nested.<br>&gt;&gt;<br>&gt;&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br>&gt;&gt;<br>&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt;&gt; separated by semicolons. (This is so commas can be used in where<br>&gt;&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt;&gt; can use commas exclusively.)<br>&gt;&gt;<br>&gt;&gt; There are five different possible clauses:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a constraint<br>&gt;&gt;    on the existential to be any class type. (Implies: Only one can exist.<br>&gt;&gt;    Mutually exclusive with class name clause.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as<br>&gt;&gt; a counterpart.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Class name. Must be the first clause, if present. (Implies: Only<br>&gt;&gt;    one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;&gt;    class, or one of its subclasses.<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view<br>&gt;&gt; data source and delegate protocols&quot;<br>&gt;&gt;<br>&gt;&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;&gt;    protocol which has no associated types or Self requirement.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt;&gt; BooleanType protocols&quot;<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated<br>&gt;&gt; types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Self-contained static protocol, simple. This is composed of the<br>&gt;&gt;    name of a static protocol, optionally followed by a &#39;where&#39; clause in which<br>&gt;&gt;    the associated types can be constrained (with any of the three basic<br>&gt;&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;&gt;    Associated types are referred to with a leading dot.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt;&gt; .Generator.Element : SomeProtocol&gt;<br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt;&gt; subclasses conforming to SomeProtocol.&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Bound static protocol. This is the same as a self-contained static<br>&gt;&gt;    protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>&gt;&gt;    generic typealias. The name can be then be used in subsequent clauses to<br>&gt;&gt;    build constraints.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt;&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt;&gt; literal, in which the collection elements are the same type as the type of<br>&gt;&gt; the integer used for the integer literal conformance.&quot;<br>&gt;&gt;<br>&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic<br>&gt;&gt; typealiases are allowed, they cannot refer to each other in a circular<br>&gt;&gt; manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a<br>&gt;&gt; cyclic graph of enums containing themselves).<br>&gt;&gt;<br>&gt;&gt; How an existential can be used depends on what guarantees are provided by<br>&gt;&gt; the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there<br>&gt;&gt; were any methods on Equatable that did not use the associated types at all<br>&gt;&gt; you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable<br>&gt;&gt; where .Self == String&gt;&#39; would allow for == to be called on instances. (This<br>&gt;&gt; is a stupid example, since Any&lt;Equatable where .Self == String&gt; is<br>&gt;&gt; equivalent to &#39;String&#39;, but there are almost certainly useful examples one<br>&gt;&gt; could come up with.)<br>&gt;&gt;<br>&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;<br>&gt;&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;    - Constrain associated types to conform to protocols.<br>&gt;&gt;    - Fully constrain associated types.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/0861af26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 17, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m honestly not sure it makes sense to introduce a proposal just for expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying to retrofit fuller support for other existentials onto it. I would prefer that the &#39;basic package&#39; of existential cases be considered together as a single proposal, unless a core team member expresses their preference otherwise.<br></p><p>I don’t see the point why we couldn’t do that! I mean if we add to much into a single proposal it would have more chances to be rejected. Besides that Chris already did the same with his `generic typealias` proposal where the whole feature was only introduced in its base form, which will gain more constraints later on. I don’t think the base form of `Any&lt;&gt;` gaining more constraints will break any code later, when there are no significant changes in syntax.<br></p><p>Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>I was thinking about this while looking at `var view: Any&lt;UIView, SomeProtocol&gt;`. If UIView does not conform to SomeProtocol you won’t be able to construct that type because otherwise it just would be `UIView`.<br></p><p>One would only be able to construct `Any&lt;&gt;` if it can be inferred to a single type like `SomeClass`. Thats what I thought and dropped from mentioning that. <br></p><p><br></p><p>Btw. I submitted a pull request already, but I noted in my proposal in the future directions section the following:<br></p><p>Any&lt;&gt; should reflect powerful generalized generic features to be able to constrain types even further. (This should have its own proposal, which will extend Any&lt;&gt; proposed here.)<br></p><p>I hope my English wasn&#39;t too bad, please don’t blame me. :D<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Mai 2016 bei 22:07:00, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p><br>Austin<br></p><p>On Tue, May 17, 2016 at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>On May 17, 2016, at 2:45 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Feel free to add as much of this proposal into yours as you want.<br></p><p>The trend is towards smaller proposals and introducing change in stages.  Since Adrian’s proposal is almost ready it’s probably best to move ahead with it as-is and follow up with generalized existentials (yours), and then possibly a third on “opening” existentials.<br></p><p><br>Austin<br></p><p>On Tue, May 17, 2016 at 12:09 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>+1 for extending my proposal and making `Any&lt;&gt;` even more a powerful beast. :)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br></p><p>Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br></p><p>See below:<br></p><p>Proposal<br></p><p>An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br></p><p>The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br></p><p>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>There are five different possible clauses:<br></p><p>&#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br></p><p>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br></p><p>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br></p><p>Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br></p><p>Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.&quot;<br></p><p>Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br></p><p>Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.&quot;<br></p><p>There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br>Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>Constrain associated types to conform to protocols.<br>Fully constrain associated types.<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/a283e58f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 3:06 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m honestly not sure it makes sense to introduce a proposal just for expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying to retrofit fuller support for other existentials onto it. I would prefer that the &#39;basic package&#39; of existential cases be considered together as a single proposal, unless a core team member expresses their preference otherwise.<br></p><p>It also renames protocol&lt;&gt; to Any, but fair enough.  <br></p><p>One reason to keep it separate is that the rename is a breaking change and we should really try to get that into Swift 3.  Generalizing existentials is an additive change.  I would love to have that in Swift 3 as well, but if it’s not going to make it I don’t think it should hold back the smaller change which is a breaking change.<br></p><p>Doug, any opinion on this?<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 17, 2016 at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 17, 2016, at 2:45 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Feel free to add as much of this proposal into yours as you want.<br>&gt; <br>&gt; The trend is towards smaller proposals and introducing change in stages.  Since Adrian’s proposal is almost ready it’s probably best to move ahead with it as-is and follow up with generalized existentials (yours), and then possibly a third on “opening” existentials.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 12:09 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1 for extending my proposal and making `Any&lt;&gt;` even more a powerful beast. :)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Mai 2016 bei 20:52:34, Austin Zheng via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/422e49a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 1:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 17, 2016, at 3:06 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m honestly not sure it makes sense to introduce a proposal just for expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying to retrofit fuller support for other existentials onto it. I would prefer that the &#39;basic package&#39; of existential cases be considered together as a single proposal, unless a core team member expresses their preference otherwise.<br>&gt; <br>&gt; It also renames protocol&lt;&gt; to Any, but fair enough.  <br>&gt; <br>&gt; One reason to keep it separate is that the rename is a breaking change and we should really try to get that into Swift 3.  Generalizing existentials is an additive change.  I would love to have that in Swift 3 as well, but if it’s not going to make it I don’t think it should hold back the smaller change which is a breaking change.<br>&gt; <br>&gt; Doug, any opinion on this?<br></p><p>I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I think this is also probably the best approach. Reskin protocol&lt;&gt; so<br>people can fix their code when 3.0 hits, and then extend its functionality<br>in an additive way.<br></p><p>Joe, given that this counts as part of &quot;generics and ABI&quot;, is it acceptable<br>to continue discussion? Or should all of this be tabled until August?<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 1:55 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 17, 2016, at 1:27 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 17, 2016, at 3:06 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m honestly not sure it makes sense to introduce a proposal just for<br>&gt; expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying<br>&gt; to retrofit fuller support for other existentials onto it. I would prefer<br>&gt; that the &#39;basic package&#39; of existential cases be considered together as a<br>&gt; single proposal, unless a core team member expresses their preference<br>&gt; otherwise.<br>&gt; &gt;<br>&gt; &gt; It also renames protocol&lt;&gt; to Any, but fair enough.<br>&gt; &gt;<br>&gt; &gt; One reason to keep it separate is that the rename is a breaking change<br>&gt; and we should really try to get that into Swift 3.  Generalizing<br>&gt; existentials is an additive change.  I would love to have that in Swift 3<br>&gt; as well, but if it’s not going to make it I don’t think it should hold back<br>&gt; the smaller change which is a breaking change.<br>&gt; &gt;<br>&gt; &gt; Doug, any opinion on this?<br>&gt;<br>&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;,<br>&gt; we should frontload that change—in addition to affecting source code, it&#39;d<br>&gt; also influence the runtime behavior of type printing/parsing, which can&#39;t<br>&gt; be statically migrated in the future. I think any discussion of extending<br>&gt; existentials has to be considered out of scope for Swift 3, though, so the<br>&gt; Any rename deserves its own proposal.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/0c88396b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 2:04 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think this is also probably the best approach. Reskin protocol&lt;&gt; so people can fix their code when 3.0 hits, and then extend its functionality in an additive way.<br>&gt; <br>&gt; Joe, given that this counts as part of &quot;generics and ABI&quot;, is it acceptable to continue discussion? Or should all of this be tabled until August?<br></p><p>IMO, discussion on the list is fine, though most of us are probably too busy to deeply participate right now, and any submitted proposals are likely to be deferred until after Swift 3 wraps up.<br></p><p>-Joe<br></p><p>&gt; Austin<br>&gt; <br>&gt; On Tue, May 17, 2016 at 1:55 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On May 17, 2016, at 1:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 17, 2016, at 3:06 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m honestly not sure it makes sense to introduce a proposal just for expressing &lt;Class, Protocol, Protocol&gt; style requirements, and then trying to retrofit fuller support for other existentials onto it. I would prefer that the &#39;basic package&#39; of existential cases be considered together as a single proposal, unless a core team member expresses their preference otherwise.<br>&gt; &gt;<br>&gt; &gt; It also renames protocol&lt;&gt; to Any, but fair enough.<br>&gt; &gt;<br>&gt; &gt; One reason to keep it separate is that the rename is a breaking change and we should really try to get that into Swift 3.  Generalizing existentials is an additive change.  I would love to have that in Swift 3 as well, but if it’s not going to make it I don’t think it should hold back the smaller change which is a breaking change.<br>&gt; &gt;<br>&gt; &gt; Doug, any opinion on this?<br>&gt; <br>&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt; <br>&gt; -Joe<br></p><p><br>Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 22, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br></p><p>Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br></p><p>Austin<br></p><p>&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; <br>&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt; <br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/2513e471/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 22, 2016, at 5:18 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt; <br>&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>This looks really nice.  I really, really appreciate all of your hard work on this.  It addresses one of the very largest pain points in Swift and does so comprehensively.  (The other really large pain point IMO is lack of conditional conformance).<br></p><p>I haven&#39;t had time to thoroughly review every detail but didn&#39;t see errors in a relatively quick glance over it.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/7d748a9d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>Excellent! I’m glad to see someone pick this up (and interest this time! I was disheartened earlier by lack of discussion when I proposed this)<br></p><p>One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br></p><p>protocol Sequence {<br>  associatedtype Element<br>  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>  …<br>}<br></p><p><br>&gt; On May 22, 2016, at 6:18 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Austin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b82c6aa9/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b82c6aa9/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Element<br>&gt;   associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt; <br>&gt;   associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;   …<br>&gt; }<br></p><p>That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br></p><p>What *would* work is allowing `where` clauses on associated types:<br></p><p>&gt; protocol Sequence {<br>&gt;   associatedtype Element<br>&gt;   associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;   associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;   …<br>&gt; }<br></p><p>I believe this is part of the generics manifesto.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 24, 2016 at 08:00:00am</p></header><div class="content"><p>It&#39;s actually a proposal waiting to be merged: https://github.com/apple/swift-evolution/pull/284<br></p><p>On 24 May 2016, at 04:52, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;  associatedtype Element<br>&gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt; <br>&gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;  …<br>&gt;&gt; }<br>&gt; <br>&gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;  associatedtype Element<br>&gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;  …<br>&gt;&gt; }<br>&gt; <br>&gt; I believe this is part of the generics manifesto.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;  associatedtype Element<br>&gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt; <br>&gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;  …<br>&gt;&gt; }<br>&gt; <br>&gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br></p><p>After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br></p><p>&gt; <br>&gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;  associatedtype Element<br>&gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;  …<br>&gt;&gt; }<br>&gt; <br>&gt; I believe this is part of the generics manifesto.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>The inimitable Joe Groff provided me with an outline as to how the design<br>could be improved. I&#39;ve taken the liberty of rewriting parts of the<br>proposal to account for his advice.<br></p><p>It turns out the runtime type system is considerably more powerful than I<br>expected. The previous concept in which protocols with associated types&#39;<br>APIs were vended out selectively and using existentials has been discarded.<br></p><p>Instead, all the associated types that belong to an existential are<br>accessible as &#39;anonymous&#39; types within the scope of the existential. These<br>anonymous types are not existentials - they are an anonymous representation<br>of whatever concrete type is satisfying the existential&#39;s value&#39;s<br>underlying type&#39;s associated type.<br></p><p>This is an enormous step up in power - for example, an existential can<br>return a value of one of these anonymous associated types from one function<br>and pass it into another function that takes the same type, maintaining<br>perfect type safety but without ever revealing the actual type. There is no<br>need anymore to limit the APIs exposed to the user, although there may<br>still exist APIs that are semantically useless without additional type<br>information.<br></p><p>A set of conversions has also been defined. At compile-time &#39;as&#39; can be<br>used to turn values of these anonymous associated types back into<br>existentials based on the constraints defined earlier. &#39;as?&#39; can also be<br>used for conditional casting of these anonymously-typed values into<br>potential actual types.<br></p><p>As always, the link is here, and feedback would be greatly appreciated:<br>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>Best,<br>Austin<br></p><p>On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types,<br>&gt; I believe you can define Sequence Element directly, rather than with a type<br>&gt; alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where<br>&gt; IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element ==<br>&gt; Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an<br>&gt; existential, not a protocol. It&#39;s basically an automatically-generated<br>&gt; version of our current `AnyIterator&lt;T&gt;` type (though with some additional<br>&gt; flexibility). It can&#39;t appear on the right side of a `:`, any more than<br>&gt; AnyIterator could.<br>&gt;<br>&gt; After this proposal you should be able to use these existentials anywhere<br>&gt; you can place a constraint, so it would work.  You can do this with the<br>&gt; protocol composition operator today and the future existential is just an<br>&gt; extension of that capability.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where<br>&gt; Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element ==<br>&gt; Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b144bea4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 26, 2016 at 07:00:00am</p></header><div class="content"><p>Great news :)<br></p><p>Sent from my iPhone<br></p><p>&gt; On 26 May 2016, at 06:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/7911fd2f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>May 26, 2016 at 01:00:00pm</p></header><div class="content"><p>This looks very nice!<br></p><p>Two questions/comments<br></p><p>1. I would prefer to write simpler existential types without Any, e.g.:<br></p><p>      let a: Sequence where Sequence.Iterator.Element == Int<br></p><p>    Is there a reason why we need Any&lt;&gt; at all, aside as a parsing aid?<br></p><p>2. If this proposal gets accepted, does it mean that type-erased wrappers like AnySequence become superfluous? They always struck me as a hack, used only to overcome the limitations of the type system. <br></p><p>Best, <br></p><p> Taras<br></p><p><br></p><p>&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/85e13676/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 6:59 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This looks very nice!<br>&gt; <br>&gt; Two questions/comments<br>&gt; <br>&gt; 1. I would prefer to write simpler existential types without Any, e.g.:<br>&gt; <br>&gt;       let a: Sequence where Sequence.Iterator.Element == Int<br>&gt; <br>&gt;     Is there a reason why we need Any&lt;&gt; at all, aside as a parsing aid?<br>&gt; <br>&gt; 2. If this proposal gets accepted, does it mean that type-erased wrappers like AnySequence become superfluous? They always struck me as a hack, used only to overcome the limitations of the type system. <br></p><p>Many type-erase wrappers will be unnecessary.  However, if you look at AnyCollection it defines AnyIndex.  You can pass values of this type that come from one value of AnyCollection to another AnyCollection even if it has a totally different underlying type.  In other words, it is explicitly type unsafe and will call fatalError if you use a bad index.  <br></p><p>If you want behavior like that you will still have to implement it manually.  But it&#39;s probably more an artifact of the state of the language at the time AnyCollection was designed than anything else.  I think we&#39;d prefer safe behavior, which is possible with the latest update to this proposal (exposing associated types as &#39;anonymous types&#39; where safe use with the existential that produced them is well defined) .<br></p><p>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/52187618/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 6:08 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 26, 2016, at 6:59 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; This looks very nice!<br>&gt;&gt; <br>&gt;&gt; Two questions/comments<br>&gt;&gt; <br>&gt;&gt; 1. I would prefer to write simpler existential types without Any, e.g.:<br>&gt;&gt; <br>&gt;&gt;       let a: Sequence where Sequence.Iterator.Element == Int<br>&gt;&gt; <br>&gt;&gt;     Is there a reason why we need Any&lt;&gt; at all, aside as a parsing aid?<br>&gt;&gt; <br>&gt;&gt; 2. If this proposal gets accepted, does it mean that type-erased wrappers like AnySequence become superfluous? They always struck me as a hack, used only to overcome the limitations of the type system. <br>&gt; <br>&gt; Many type-erase wrappers will be unnecessary.  However, if you look at AnyCollection it defines AnyIndex.  You can pass values of this type that come from one value of AnyCollection to another AnyCollection even if it has a totally different underlying type.  In other words, it is explicitly type unsafe and will call fatalError if you use a bad index.  <br></p><p>I think this actually shouldn&#39;t be a problem anymore (warning, strawman syntax):<br></p><p>func doSomethingWithTwoCollections(x: Any&lt;Collection&gt;, y: Any&lt;Collection&gt;) {<br>  <br>  let anIndex : x.Index = x.startIndex<br>  var anotherIndex : y.Index = y.startIndex<br>  <br>  // NOT ALLOWED - x.Index and y.Index are not equivalent<br>  anotherIndex = anIndex<br></p><p>  // With the new collection model (SE-0065), indices are simply Comparable now<br>  // Okay to cast from x.Index to Comparable<br>  let a = anIndex as Comparable<br></p><p>  // Not okay to cast from Comparable to y.Index<br>  let b = a as y.Index<br></p><p>  // This should be okay. We may want to break this feature into &#39;Opening Existentials&#39; follow-up proposal<br>  if let b = a as? y.Index {<br>    // do stuff with b<br>  }<br>}<br></p><p><br>&gt; <br>&gt; If you want behavior like that you will still have to implement it manually.  But it&#39;s probably more an artifact of the state of the language at the time AnyCollection was designed than anything else.  I think we&#39;d prefer safe behavior, which is possible with the latest update to this proposal (exposing associated types as &#39;anonymous types&#39; where safe use with the existential that produced them is well defined) .<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; <br>&gt;&gt;  Taras<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b9cb81ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 10:27 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 6:08 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 6:59 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This looks very nice!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two questions/comments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I would prefer to write simpler existential types without Any, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       let a: Sequence where Sequence.Iterator.Element == Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Is there a reason why we need Any&lt;&gt; at all, aside as a parsing aid?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. If this proposal gets accepted, does it mean that type-erased wrappers like AnySequence become superfluous? They always struck me as a hack, used only to overcome the limitations of the type system. <br>&gt;&gt; <br>&gt;&gt; Many type-erase wrappers will be unnecessary.  However, if you look at AnyCollection it defines AnyIndex.  You can pass values of this type that come from one value of AnyCollection to another AnyCollection even if it has a totally different underlying type.  In other words, it is explicitly type unsafe and will call fatalError if you use a bad index.  <br>&gt; <br>&gt; I think this actually shouldn&#39;t be a problem anymore (warning, strawman syntax):<br>&gt; <br>&gt; func doSomethingWithTwoCollections(x: Any&lt;Collection&gt;, y: Any&lt;Collection&gt;) {<br>&gt;   <br>&gt;   let anIndex : x.Index = x.startIndex<br>&gt;   var anotherIndex : y.Index = y.startIndex<br>&gt;   <br>&gt;   // NOT ALLOWED - x.Index and y.Index are not equivalent<br>&gt;   anotherIndex = anIndex<br>&gt; <br>&gt;   // With the new collection model (SE-0065), indices are simply Comparable now<br>&gt;   // Okay to cast from x.Index to Comparable<br>&gt;   let a = anIndex as Comparable<br>&gt; <br>&gt;   // Not okay to cast from Comparable to y.Index<br>&gt;   let b = a as y.Index<br>&gt; <br>&gt;   // This should be okay. We may want to break this feature into &#39;Opening Existentials&#39; follow-up proposal<br>&gt;   if let b = a as? y.Index {<br>&gt;     // do stuff with b<br>&gt;   }<br>&gt; }<br></p><p>Right.  If we want the safer behavior we will get it with this proposal.  But if you want unsafe behavior for some reason you’re going to have to implement in manually (not sure why you would want that though).<br></p><p>Replacing AnyCollection with the safer behavior will be a breaking change, but is the right thing to do IMO.  I am just pointing out the fact that it is a breaking change.  :)<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If you want behavior like that you will still have to implement it manually.  But it&#39;s probably more an artifact of the state of the language at the time AnyCollection was designed than anything else.  I think we&#39;d prefer safe behavior, which is possible with the latest update to this proposal (exposing associated types as &#39;anonymous types&#39; where safe use with the existential that produced them is well defined) .<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/6b37aaa1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 02:00:00am</p></header><div class="content"><p>&gt;   // With the new collection model (SE-0065), indices are simply Comparable now<br>&gt;   // Okay to cast from x.Index to Comparable<br>&gt;   let a = anIndex as Comparable<br>&gt; <br>&gt;   // Not okay to cast from Comparable to y.Index<br>&gt;   let b = a as y.Index<br>&gt; <br>&gt;   // This should be okay. We may want to break this feature into &#39;Opening Existentials&#39; follow-up proposal<br>&gt;   if let b = a as? y.Index {<br>&gt;     // do stuff with b<br>&gt;   }<br></p><p>If you&#39;re going to do this, it might make sense to add a new form of `as?`/`as!` cast for casting between the same associated type on different existentials:<br></p><p>	if let b = x.startIndex as? y.Index {<br>		// do stuff with b<br>	}<br></p><p>This would succeed if the concrete types of `x` and `y` had the same type for `Index`, and fail otherwise.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Thank you for your comments! (inline)<br></p><p>&gt; On May 26, 2016, at 4:59 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; This looks very nice!<br>&gt; <br>&gt; Two questions/comments<br>&gt; <br>&gt; 1. I would prefer to write simpler existential types without Any, e.g.:<br>&gt; <br>&gt;       let a: Sequence where Sequence.Iterator.Element == Int<br>&gt; <br>&gt;     Is there a reason why we need Any&lt;&gt; at all, aside as a parsing aid?<br>&gt; <br></p><p>Not really. All the syntax in that pre-proposal is contingent on whatever happens to #95 (https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt;), which is currently under review.<br></p><p>&gt; 2. If this proposal gets accepted, does it mean that type-erased wrappers like AnySequence become superfluous? They always struck me as a hack, used only to overcome the limitations of the type system. <br></p><p>Probably. I could see type aliases being defined for AnySequence and the three types of Collections.<br></p><p>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/a02c289d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 12:53 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>I really like the enhancement.  This makes a lot of sense.  All members are visible, but some members can&#39;t be called because you can&#39;t form an argument of the necessary type (i.e. when it is a non-concrete associated type and you can&#39;t get a value as output of another member of the existential).  Thanks for chiming in on this Joe!<br></p><p>There is one part of the update that could use clarification:<br>// Okay, because String conforms to both Protocol1 and Streamable <br>let r2 = result as? String<br>I think you mean that the attempted cast is ok because there is a possibility it might succeed, but it might also fail.  The possibility of failure should probably be highlighted.<br></p><p>You might also want to elaborate that the Int attempt is a compiler error because there is no possibility for the attempted cast to succeed (if that is what you intend).<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b939291b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 6:02 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I really like the enhancement.  This makes a lot of sense.  All members are visible, but some members can&#39;t be called because you can&#39;t form an argument of the necessary type (i.e. when it is a non-concrete associated type and you can&#39;t get a value as output of another member of the existential).  Thanks for chiming in on this Joe!<br>&gt; <br>&gt; There is one part of the update that could use clarification:<br>&gt; // Okay, because String conforms to both Protocol1 and Streamable <br>&gt; let r2 = result as? String<br>&gt; I think you mean that the attempted cast is ok because there is a possibility it might succeed, but it might also fail.  The possibility of failure should probably be highlighted.<br>&gt; <br>&gt; You might also want to elaborate that the Int attempt is a compiler error because there is no possibility for the attempted cast to succeed (if that is what you intend).<br></p><p>Yes, this is exactly what I meant. I&#39;ll make the copy clearer. Thanks!<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/f35238a4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br></p><p>let a : Any&lt;Collection&gt;<br>// A variable whose type is the Element associated type of the underlying<br>// concrete type of &#39;a&#39;.<br>let theElement : a.Element = ...<br></p><p>In Scala this would be a „path dependent type“ which actually depends on the variable `a`.<br>What would happen in the following case:<br></p><p>func foo&lt;T: Any&lt;Collection&gt;&gt;(a: T, b: T) {<br>	// is the type of a.Element equal to the type of b.Element here? (In Scala it would not) <br>}<br></p><p><br>-Thorsten<br></p><p><br></p><p>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/88a87251/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>I suppose &quot;a.Element&quot; could be considered a path-dependent type.<br></p><p>My inclination is to disallow the use of &quot;a.AssociatedType&quot; if &#39;a&#39; is a<br>generic type like T inside func&lt;T&gt;(a: T) or class&lt;T&gt;, and only allow it if<br>&#39;a&#39; is an existential. This goes back to the notion that existential types<br>and generic types (universal types?) are two different concepts that are<br>closely related. Allowing the use of that notation would be an additive<br>change, so if necessary it could be expressed in a followup proposal (and<br>we could hash out all the semantics then).<br></p><p>Austin<br></p><p><br>On Thu, May 26, 2016 at 10:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; The inimitable Joe Groff provided me with an outline as to how the design<br>&gt; could be improved. I&#39;ve taken the liberty of rewriting parts of the<br>&gt; proposal to account for his advice.<br>&gt;<br>&gt; It turns out the runtime type system is considerably more powerful than I<br>&gt; expected. The previous concept in which protocols with associated types&#39;<br>&gt; APIs were vended out selectively and using existentials has been discarded.<br>&gt;<br>&gt; Instead, all the associated types that belong to an existential are<br>&gt; accessible as &#39;anonymous&#39; types within the scope of the existential. These<br>&gt; anonymous types are not existentials - they are an anonymous representation<br>&gt; of whatever concrete type is satisfying the existential&#39;s value&#39;s<br>&gt; underlying type&#39;s associated type.<br>&gt;<br>&gt;<br>&gt; let a : Any&lt;Collection&gt;<br>&gt;<br>&gt; // A variable whose type is the Element associated type of the underlying// concrete type of &#39;a&#39;.let theElement : a.Element = ...<br>&gt;<br>&gt;<br>&gt; In Scala this would be a „path dependent type“ which actually depends on<br>&gt; the variable `a`.<br>&gt; What would happen in the following case:<br>&gt;<br>&gt; func foo&lt;T: Any&lt;Collection&gt;&gt;(a: T, b: T) {<br>&gt; // is the type of a.Element equal to the type of b.Element here? (In Scala<br>&gt; it would not)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; This is an enormous step up in power - for example, an existential can<br>&gt; return a value of one of these anonymous associated types from one function<br>&gt; and pass it into another function that takes the same type, maintaining<br>&gt; perfect type safety but without ever revealing the actual type. There is no<br>&gt; need anymore to limit the APIs exposed to the user, although there may<br>&gt; still exist APIs that are semantically useless without additional type<br>&gt; information.<br>&gt;<br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be<br>&gt; used to turn values of these anonymous associated types back into<br>&gt; existentials based on the constraints defined earlier. &#39;as?&#39; can also be<br>&gt; used for conditional casting of these anonymously-typed values into<br>&gt; potential actual types.<br>&gt;<br>&gt; As always, the link is here, and feedback would be greatly appreciated:<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential<br>&gt;&gt; types, I believe you can define Sequence Element directly, rather than with<br>&gt;&gt; a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where<br>&gt;&gt; IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element ==<br>&gt;&gt; Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an<br>&gt;&gt; existential, not a protocol. It&#39;s basically an automatically-generated<br>&gt;&gt; version of our current `AnyIterator&lt;T&gt;` type (though with some additional<br>&gt;&gt; flexibility). It can&#39;t appear on the right side of a `:`, any more than<br>&gt;&gt; AnyIterator could.<br>&gt;&gt;<br>&gt;&gt; After this proposal you should be able to use these existentials anywhere<br>&gt;&gt; you can place a constraint, so it would work.  You can do this with the<br>&gt;&gt; protocol composition operator today and the future existential is just an<br>&gt;&gt; extension of that capability.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where<br>&gt;&gt; Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element ==<br>&gt;&gt; Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/0d3f7d05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>I’d like to throw one idea of mine in the room I couldn’t stop thinking when I read one of Thorsten’s replies on SE–0095 review thread.<br></p><p>This wiki section explains the existential types where we have something like this:<br></p><p>&quot;T = ∃X { a: X; f: (X → int); } This could be implemented in different ways; for example:<br></p><p>intT = { a: int; f: (int → int); }<br>floatT = { a: float; f: (float → int); }<br>We discussed how we could create existential types with constraints for protocols and classes so far. Such an existential can’t create something like in the example above.<br></p><p>I’m not sure if we need this at all, I’d say it’s a nice to have idea of mine.<br></p><p>To solve this we could introduce a new scope similar to protocols today but without the need to explicitly conform types to this existential.<br></p><p>// the above example can become<br>existential T {<br>    associatedtype X<br>    var a: X<br>    func f(_ value: X) -&gt; Int<br>}<br></p><p>struct A /* no explicit conformance to T needed */ {<br>    var a: Int<br>    init(a: Int) { self.a = a }<br>    func f(_ value: Int) -&gt; Int { return value }<br>}<br></p><p>let store: T = A() // this could or should work, just because we do have visibility to all constraints from T in A here<br></p><p>// if we had `private var a: Int` in A we wouldn&#39;t be able to store A inside `store`<br>I din’t though if existential could have potential to replace Any&lt;…&gt; completely. Until now I just wanted to solve that particular issue so please don’t judge with me. :)<br></p><p>Just because of associated types we won’t be able to use store in this example, but there might be more trivial examples where one would use such existential type (for only visible portion at compile or dynamically at run-time) without explicit conformance.<br></p><p>struct B {<br>    var x: Int = 42<br>    var y: Double = -100.5<br>}<br></p><p>struct C: SomeProtocol {<br>    var y: Double = 0.0<br>    var x: Int = 10<br>}<br></p><p>existential SomeShinyThing {<br>    var x: Int<br>    var y: Double<br>}<br></p><p>// we should be safe here because the compiler has visibility for  <br>// internal B and C here<br>let anotherStore: SomeShinyThing = B() /* or */ C()  <br></p><p>// otherwise one could use dynamic casts<br>if let thirdStore = instanceOfCShadowedAsSomeProtocol as? SomeShinyThing { … }<br>Feel to tear this idea apart as you want. :D<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/1f7176ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>I alway enjoy hearing your ideas.<br></p><p>This is quite interesting. It&#39;s basically a way to define an ad-hoc<br>interface that a type doesn&#39;t need to explicitly declare it conforms to. I<br>know Golang works similarly; if a Go type implements all the requirements<br>of an interface it conforms automatically.<br></p><p>There are positives and negatives to allowing this sort of ad-hoc<br>interface. This would make for a good standalone proposal -- both because<br>it&#39;s complex enough to deserve its own discussion, and because if the<br>community is interested someone would have to work through all the<br>implications in order to put together a proposal. It would be quite a big<br>change.<br></p><p>Best,<br>Austin<br></p><p>On Thu, May 26, 2016 at 11:56 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’d like to throw one idea of mine in the room I couldn’t stop thinking<br>&gt; when I read one of Thorsten’s replies on SE–0095 review thread.<br>&gt;<br>&gt; This wiki section<br>&gt; &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt; explains<br>&gt; the existential types where we have something like this:<br>&gt;<br>&gt; &quot;T = ∃X { a: X; f: (X → int); } This could be implemented in different<br>&gt; ways; for example:<br>&gt;<br>&gt;    - intT = { a: int; f: (int → int); }<br>&gt;    - floatT = { a: float; f: (float → int); }<br>&gt;<br>&gt; We discussed how we could create existential types with constraints for<br>&gt; protocols and classes so far. Such an existential can’t create something<br>&gt; like in the example above.<br>&gt;<br>&gt; I’m not sure if we need this at all, I’d say it’s a *nice to have* idea<br>&gt; of mine.<br>&gt;<br>&gt; To solve this we could introduce a new scope similar to protocols today<br>&gt; but without the need to explicitly conform types to this existential.<br>&gt;<br>&gt; // the above example can become<br>&gt; existential T {<br>&gt;     associatedtype X<br>&gt;     var a: X<br>&gt;     func f(_ value: X) -&gt; Int<br>&gt; }<br>&gt;<br>&gt; struct A /* no explicit conformance to T needed */ {<br>&gt;     var a: Int<br>&gt;     init(a: Int) { self.a = a }<br>&gt;     func f(_ value: Int) -&gt; Int { return value }<br>&gt; }<br>&gt;<br>&gt; let store: T = A() // this could or should work, just because we do have visibility to all constraints from T in A here<br>&gt;<br>&gt; // if we had `private var a: Int` in A we wouldn&#39;t be able to store A inside `store`<br>&gt;<br>&gt; I din’t though if existential could have potential to replace Any&lt;…&gt;<br>&gt; completely. Until now I just wanted to solve that particular issue so<br>&gt; please don’t judge with me. :)<br>&gt;<br>&gt; Just because of associated types we won’t be able to use store in this<br>&gt; example, but there might be more trivial examples where one would use such<br>&gt; existential type (for only visible portion at compile or dynamically at<br>&gt; run-time) without explicit conformance.<br>&gt;<br>&gt; struct B {<br>&gt;     var x: Int = 42<br>&gt;     var y: Double = -100.5<br>&gt; }<br>&gt;<br>&gt; struct C: SomeProtocol {<br>&gt;     var y: Double = 0.0<br>&gt;     var x: Int = 10<br>&gt; }<br>&gt;<br>&gt; existential SomeShinyThing {<br>&gt;     var x: Int<br>&gt;     var y: Double<br>&gt; }<br>&gt;<br>&gt; // we should be safe here because the compiler has visibility for<br>&gt; // internal B and C here<br>&gt; let anotherStore: SomeShinyThing = B() /* or */ C()<br>&gt;<br>&gt; // otherwise one could use dynamic casts<br>&gt; if let thirdStore = instanceOfCShadowedAsSomeProtocol as? SomeShinyThing { … }<br>&gt;<br>&gt; Feel to tear this idea apart as you want. :D<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/e4731403/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I alway enjoy hearing your ideas.<br>In a good or funny way? I don’t want to say dumb things you know. :D<br></p><p>This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>I’m familiar with Go and also realized that this whole idea might be similar. I love easy and shiny looking syntax. :)<br></p><p>There are positives and negatives to allowing this sort of ad-hoc interface. This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br></p><p>I know that this whole thing &quot;might“ be huge/complex and that its needs its own proposal, if at all. <br>It was just an idea I wanted to share with the community since we’re talking about existential types here. Maybe one day we will need or use this. Lets see how Swift will evolve. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/054939be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 2:49 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I alway enjoy hearing your ideas.<br>&gt; <br>&gt; This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>&gt; <br>&gt; There are positives and negatives to allowing this sort of ad-hoc interface.<br></p><p>Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br></p><p>&gt; This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br></p><p>I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br></p><p>That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 11:56 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’d like to throw one idea of mine in the room I couldn’t stop thinking when I read one of Thorsten’s replies on SE–0095 review thread.<br>&gt;&gt; <br>&gt;&gt; This wiki section explains the existential types where we have something like this:<br>&gt;&gt; <br>&gt;&gt; &quot;T = ∃X { a: X; f: (X → int); } This could be implemented in different ways; for example:<br>&gt;&gt; <br>&gt;&gt; intT = { a: int; f: (int → int); }<br>&gt;&gt; floatT = { a: float; f: (float → int); }<br>&gt;&gt; We discussed how we could create existential types with constraints for protocols and classes so far. Such an existential can’t create something like in the example above.<br>&gt;&gt; <br>&gt;&gt; I’m not sure if we need this at all, I’d say it’s a nice to have idea of mine.<br>&gt;&gt; <br>&gt;&gt; To solve this we could introduce a new scope similar to protocols today but without the need to explicitly conform types to this existential.<br>&gt;&gt; <br>&gt;&gt; // the above example can become<br>&gt;&gt; existential T {<br>&gt;&gt;     associatedtype X<br>&gt;&gt;     var a: X<br>&gt;&gt;     func f(_ value: X) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct A /* no explicit conformance to T needed */ {<br>&gt;&gt;     var a: Int<br>&gt;&gt;     init(a: Int) { self.a = a }<br>&gt;&gt;     func f(_ value: Int) -&gt; Int { return value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let store: T = A() // this could or should work, just because we do have visibility to all constraints from T in A here<br>&gt;&gt; <br>&gt;&gt; // if we had `private var a: Int` in A we wouldn&#39;t be able to store A inside `store`<br>&gt;&gt; I din’t though if existential could have potential to replace Any&lt;…&gt; completely. Until now I just wanted to solve that particular issue so please don’t judge with me. :)<br>&gt;&gt; <br>&gt;&gt; Just because of associated types we won’t be able to use store in this example, but there might be more trivial examples where one would use such existential type (for only visible portion at compile or dynamically at run-time) without explicit conformance.<br>&gt;&gt; <br>&gt;&gt; struct B {<br>&gt;&gt;     var x: Int = 42<br>&gt;&gt;     var y: Double = -100.5<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct C: SomeProtocol {<br>&gt;&gt;     var y: Double = 0.0<br>&gt;&gt;     var x: Int = 10<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; existential SomeShinyThing {<br>&gt;&gt;     var x: Int<br>&gt;&gt;     var y: Double<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // we should be safe here because the compiler has visibility for  <br>&gt;&gt; // internal B and C here<br>&gt;&gt; let anotherStore: SomeShinyThing = B() /* or */ C()  <br>&gt;&gt; <br>&gt;&gt; // otherwise one could use dynamic casts<br>&gt;&gt; if let thirdStore = instanceOfCShadowedAsSomeProtocol as? SomeShinyThing { … }<br>&gt;&gt; Feel to tear this idea apart as you want. :D<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/7dec8248/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I alway enjoy hearing your ideas.<br></p><p>This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br></p><p>There are positives and negatives to allowing this sort of ad-hoc interface.<br></p><p>Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br></p><p>This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br></p><p>I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br></p><p>That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>I don’t see any desire to follow Go’s path here and drop explicit conformance in any way.<br></p><p>Basically such `existential` mechanism could express more than `Any&lt;…&gt;` could. That said I do feel that this &quot;could“ have some potential to exist alongside `Any&lt;…&gt;`.<br></p><p>From my understanding of this whole existential type thing is that it can be used both ways, explicitly and implicitly. As said before we only discussed the explicit existential types.<br></p><p><br></p><p>Just another pseudo example:<br></p><p>```swift<br></p><p>// this could also replace typealiases for (generic) existentials<br></p><p>existential CrazyView  {<br></p><p>    // we could introduce a way for constraints which could have a nice looking syntax<br></p><p>    // break `Any&lt;…&gt;` nesting and long very long composition lines of `Any&lt;…&gt;` <br></p><p>    constraint Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br></p><p>    constraint ProtocolA.AssociatedType == Int <br></p><p>    func crazyFunction()<br></p><p>}<br></p><p><br></p><p>existential AnyCollection&lt;T&gt;  {<br></p><p>   constraint Collection<br></p><p>   constraint Collection.Element == T<br></p><p>}<br></p><p>```<br></p><p>But I don’t want to go any further if there is no need (yet).<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/d0caa708/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 3:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I alway enjoy hearing your ideas.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are positives and negatives to allowing this sort of ad-hoc interface.<br>&gt;&gt; <br>&gt;&gt; Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br>&gt;&gt; <br>&gt;&gt;&gt; This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br>&gt;&gt; <br>&gt;&gt; That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>&gt; <br>&gt; I don’t see any desire to follow Go’s path here and drop explicit conformance in any way.<br>&gt; <br>&gt; Basically such `existential` mechanism could express more than `Any&lt;…&gt;` could. That said I do feel that this &quot;could“ have some potential to exist alongside `Any&lt;…&gt;`.<br>&gt; <br>&gt; <br></p><p>Anything “more” it could express would be specific member requirements, which would make it in some sense ad-hoc protocol.  I would rather see one mechanism for defining member requirements.  We already have that and it is called a protocol.<br></p><p>The reason types won’t need to declare explicit conformance to an `Any` is that the requirements of the `Any` are composed of an optional supertype as well zero or more protocol and associated type constraints.  The “conformance&quot; of a type to the `Any` is defined by its conformance to the protocols that the `Any` is composed of.  <br></p><p>If you want to introduce new requirements the right way to do it is to declare an additional protocol and add it to the list of protocol constraints in the `Any`.<br>&gt; From my understanding of this whole existential type thing is that it can be used both ways, explicitly and implicitly. As said before we only discussed the explicit existential types.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Just another pseudo example:<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; // this could also replace typealiases for (generic) existentials<br>&gt; <br>&gt; <br></p><p>I gave some consideration to scoped syntax like this a few days ago.  The problem with it is that `Any` is a structural type defined by the constraints and this makes it look like a nominal type.  <br></p><p>If you define two “existential” types with the exact same constraints under different names, what happens?  They should be identical to other any equivalent formulation and that is clear under Austin’s proposal, but because this alternative looks like a nominal type you might have the expectation that the types are independent of each other.  That is why typealias is the correct solution here IMO.  It is clear that the name is just an alias for a structural type.<br>&gt; existential CrazyView  {<br>&gt; <br>&gt;     // we could introduce a way for constraints which could have a nice looking syntax<br>&gt; <br>&gt;     // break `Any&lt;…&gt;` nesting and long very long composition lines of `Any&lt;…&gt;` <br>&gt; <br>&gt;     constraint Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt; <br>&gt;     constraint ProtocolA.AssociatedType == Int <br>&gt; <br>&gt;     func crazyFunction()<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; existential AnyCollection&lt;T&gt;  {<br>&gt; <br>&gt;    constraint Collection<br>&gt; <br>&gt;    constraint Collection.Element == T<br>&gt; <br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; But I don’t want to go any further if there is no need (yet).<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/752bc72c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 10:56 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 3:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I alway enjoy hearing your ideas.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are positives and negatives to allowing this sort of ad-hoc interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>&gt;&gt; <br>&gt;&gt; I don’t see any desire to follow Go’s path here and drop explicit conformance in any way.<br>&gt;&gt; <br>&gt;&gt; Basically such `existential` mechanism could express more than `Any&lt;…&gt;` could. That said I do feel that this &quot;could“ have some potential to exist alongside `Any&lt;…&gt;`.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; Anything “more” it could express would be specific member requirements, which would make it in some sense ad-hoc protocol.  I would rather see one mechanism for defining member requirements.  We already have that and it is called a protocol.<br>&gt; <br>&gt; The reason types won’t need to declare explicit conformance to an `Any` is that the requirements of the `Any` are composed of an optional supertype as well zero or more protocol and associated type constraints.  The “conformance&quot; of a type to the `Any` is defined by its conformance to the protocols that the `Any` is composed of.  <br>&gt; <br>&gt; If you want to introduce new requirements the right way to do it is to declare an additional protocol and add it to the list of protocol constraints in the `Any`.<br>&gt;&gt; From my understanding of this whole existential type thing is that it can be used both ways, explicitly and implicitly. As said before we only discussed the explicit existential types.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Just another pseudo example:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; <br>&gt;&gt; // this could also replace typealiases for (generic) existentials<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I gave some consideration to scoped syntax like this a few days ago.  The problem with it is that `Any` is a structural type defined by the constraints and this makes it look like a nominal type.  <br></p><p>I am not sure I follow you.. If Any is a structural type, then case closed, it is instantiate-able and carry all the normal behavior of all other structural types. Or is it a wolf in sheep&#39;s clothing that is actually neither a wolf, nor a sheep?<br></p><p>This is ultimately coming back to my earlier question of how does one differentiate between  X&lt;...&gt;   and Y&lt;...&gt;? <br></p><p>Should we read the angle brackets first and reach the logical (but wrong) conclusion that X and Y will essentially behave in a similar fashion, or should we read the names first and remember that we have to go to two different pages of the swift programmer&#39;s guide to make sense of what follows?<br></p><p>As was previously said with great eloquence (i believe by Joe Groff), Any&lt;&gt; is something only a compiler loves... I would like it if we found something both the swift compiler and the swift programmer could love.<br></p><p><br>&gt; <br>&gt; If you define two “existential” types with the exact same constraints under different names, what happens?  They should be identical to other any equivalent formulation and that is clear under Austin’s proposal, but because this alternative looks like a nominal type you might have the expectation that the types are independent of each other.  That is why typealias is the correct solution here IMO.  It is clear that the name is just an alias for a structural type.<br>&gt;&gt; existential CrazyView  {<br>&gt;&gt; <br>&gt;&gt;     // we could introduce a way for constraints which could have a nice looking syntax<br>&gt;&gt; <br>&gt;&gt;     // break `Any&lt;…&gt;` nesting and long very long composition lines of `Any&lt;…&gt;` <br>&gt;&gt; <br>&gt;&gt;     constraint Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt;&gt; <br>&gt;&gt;     constraint ProtocolA.AssociatedType == Int <br>&gt;&gt; <br>&gt;&gt;     func crazyFunction()<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; existential AnyCollection&lt;T&gt;  {<br>&gt;&gt; <br>&gt;&gt;    constraint Collection<br>&gt;&gt; <br>&gt;&gt;    constraint Collection.Element == T<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; But I don’t want to go any further if there is no need (yet).<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/24e28f81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 6:02 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On May 26, 2016, at 10:56 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 3:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I alway enjoy hearing your ideas.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are positives and negatives to allowing this sort of ad-hoc interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see any desire to follow Go’s path here and drop explicit conformance in any way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically such `existential` mechanism could express more than `Any&lt;…&gt;` could. That said I do feel that this &quot;could“ have some potential to exist alongside `Any&lt;…&gt;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Anything “more” it could express would be specific member requirements, which would make it in some sense ad-hoc protocol.  I would rather see one mechanism for defining member requirements.  We already have that and it is called a protocol.<br>&gt;&gt; <br>&gt;&gt; The reason types won’t need to declare explicit conformance to an `Any` is that the requirements of the `Any` are composed of an optional supertype as well zero or more protocol and associated type constraints.  The “conformance&quot; of a type to the `Any` is defined by its conformance to the protocols that the `Any` is composed of. <br>&gt;&gt; <br>&gt;&gt; If you want to introduce new requirements the right way to do it is to declare an additional protocol and add it to the list of protocol constraints in the `Any`.<br>&gt;&gt;&gt; From my understanding of this whole existential type thing is that it can be used both ways, explicitly and implicitly. As said before we only discussed the explicit existential types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just another pseudo example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // this could also replace typealiases for (generic) existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I gave some consideration to scoped syntax like this a few days ago.  The problem with it is that `Any` is a structural type defined by the constraints and this makes it look like a nominal type.  <br>&gt; <br>&gt; I am not sure I follow you.. If Any is a structural type, then case closed, it is instantiate-able and carry all the normal behavior of all other structural types. Or is it a wolf in sheep&#39;s clothing that is actually neither a wolf, nor a sheep?<br></p><p>It is defined by the structure of the constraints, not the structure of the data.  <br></p><p>&gt; <br>&gt; This is ultimately coming back to my earlier question of how does one differentiate between  X&lt;...&gt;   and Y&lt;...&gt;? <br>&gt; <br>&gt; Should we read the angle brackets first and reach the logical (but wrong) conclusion that X and Y will essentially behave in a similar fashion, or should we read the names first and remember that we have to go to two different pages of the swift programmer&#39;s guide to make sense of what follows?<br>&gt; <br>&gt; As was previously said with great eloquence (i believe by Joe Groff), Any&lt;&gt; is something only a compiler loves... I would like it if we found something both the swift compiler and the swift programmer could love.<br></p><p>It isn’t entirely clear to me what you’re arguing for here.  It *seems* like maybe your advocating for the `&amp;` syntax (or similar) to make a stronger differentiation from generic types.  That makes sense.<br></p><p>The point I was making is that any names we give to an existential type are *aliases* for it.  The name doesn’t matter as far as the type system is concerned.  The syntax Adrian posted makes it *look* like the name actually matters to the type system IMO and introduces potential for confusion because of that.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If you define two “existential” types with the exact same constraints under different names, what happens?  They should be identical to other any equivalent formulation and that is clear under Austin’s proposal, but because this alternative looks like a nominal type you might have the expectation that the types are independent of each other.  That is why typealias is the correct solution here IMO.  It is clear that the name is just an alias for a structural type.<br>&gt;&gt;&gt; existential CrazyView  {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // we could introduce a way for constraints which could have a nice looking syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // break `Any&lt;…&gt;` nesting and long very long composition lines of `Any&lt;…&gt;` <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     constraint Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     constraint ProtocolA.AssociatedType == Int <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func crazyFunction()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; existential AnyCollection&lt;T&gt;  {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    constraint Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    constraint Collection.Element == T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I don’t want to go any further if there is no need (yet).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/836f3338/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Good point. :)<br></p><p>I’ve been thinking if there is a way to still have a shiny and swifty looking syntax which would solve this problem:<br></p><p>typealias SomeExistential&lt;T&gt; = existential&lt;T&gt; {<br></p><p>    constraint UIView<br>    constraint ProtocolA     <br>    constraint ProtocolB.AssociatedType == T<br>     <br>    var someVar: Int { get set }<br>}<br>This mimics typealias Name = protocol&lt;…&gt; where the protocol&lt;…&gt; does not have an explicit name.<br></p><p>One downside of this approach:<br></p><p>To use such an existential you would need give it a name trough typealias.<br>typealias AnyCollection&lt;T&gt; = existential&lt;T&gt; {<br></p><p>   constraint Collection<br>   constraint Collection.Element == T<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 26. Mai 2016 bei 22:56:10, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On May 26, 2016, at 3:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I alway enjoy hearing your ideas.<br></p><p>This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br></p><p>There are positives and negatives to allowing this sort of ad-hoc interface.<br></p><p>Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br></p><p>This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br></p><p>I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br></p><p>That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>I don’t see any desire to follow Go’s path here and drop explicit conformance in any way.<br></p><p>Basically such `existential` mechanism could express more than `Any&lt;…&gt;` could. That said I do feel that this &quot;could“ have some potential to exist alongside `Any&lt;…&gt;`.<br></p><p><br></p><p>Anything “more” it could express would be specific member requirements, which would make it in some sense ad-hoc protocol.  I would rather see one mechanism for defining member requirements.  We already have that and it is called a protocol.<br></p><p>The reason types won’t need to declare explicit conformance to an `Any` is that the requirements of the `Any` are composed of an optional supertype as well zero or more protocol and associated type constraints.  The “conformance&quot; of a type to the `Any` is defined by its conformance to the protocols that the `Any` is composed of.  <br></p><p>If you want to introduce new requirements the right way to do it is to declare an additional protocol and add it to the list of protocol constraints in the `Any`.<br>From my understanding of this whole existential type thing is that it can be used both ways, explicitly and implicitly. As said before we only discussed the explicit existential types.<br></p><p><br></p><p>Just another pseudo example:<br></p><p>```swift<br></p><p>// this could also replace typealiases for (generic) existentials<br></p><p><br></p><p>I gave some consideration to scoped syntax like this a few days ago.  The problem with it is that `Any` is a structural type defined by the constraints and this makes it look like a nominal type.  <br></p><p>If you define two “existential” types with the exact same constraints under different names, what happens?  They should be identical to other any equivalent formulation and that is clear under Austin’s proposal, but because this alternative looks like a nominal type you might have the expectation that the types are independent of each other.  That is why typealias is the correct solution here IMO.  It is clear that the name is just an alias for a structural type.<br>existential CrazyView  {<br></p><p>    // we could introduce a way for constraints which could have a nice looking syntax<br></p><p>    // break `Any&lt;…&gt;` nesting and long very long composition lines of `Any&lt;…&gt;` <br></p><p>    constraint Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br></p><p>    constraint ProtocolA.AssociatedType == Int <br></p><p>    func crazyFunction()<br></p><p>}<br></p><p><br></p><p>existential AnyCollection&lt;T&gt;  {<br></p><p>   constraint Collection<br></p><p>   constraint Collection.Element == T<br></p><p>}<br></p><p>```<br></p><p>But I don’t want to go any further if there is no need (yet).<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/271db60a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 26.05.2016 um 22:07 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 26, 2016, at 2:49 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I alway enjoy hearing your ideas.<br>&gt;&gt; <br>&gt;&gt; This is quite interesting. It&#39;s basically a way to define an ad-hoc interface that a type doesn&#39;t need to explicitly declare it conforms to. I know Golang works similarly; if a Go type implements all the requirements of an interface it conforms automatically.<br>&gt;&gt; <br>&gt;&gt; There are positives and negatives to allowing this sort of ad-hoc interface.<br>&gt; <br>&gt; Agree.  It would definitely make the language &quot;feel&quot; a bit more fluid.  But it doesn&#39;t add any expressive power and could have undesirable consequences.<br>&gt; <br>&gt;&gt; This would make for a good standalone proposal -- both because it&#39;s complex enough to deserve its own discussion, and because if the community is interested someone would have to work through all the implications in order to put together a proposal. It would be quite a big change.<br>&gt; <br>&gt; I don&#39;t see how this is different from a protocol other than the lack of requirement to declare conformance explicitly.  The need to explicitly declare conformance is a design decision that I believe the core team feels pretty strongly about.  <br>&gt; <br>&gt; That said, it hasn&#39;t been debated by the community yet so if someone feels strongly about dropping explicit conformance declarations it might be worth pitching the idea, if for not other reason than to have a discussion about it on the lost.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 11:56 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I’d like to throw one idea of mine in the room I couldn’t stop thinking when I read one of Thorsten’s replies on SE–0095 review thread.<br>&gt;&gt; <br>&gt;&gt; This wiki section &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt; explains the existential types where we have something like this:<br>&gt;&gt; <br>&gt;&gt; &quot;T = ∃X { a: X; f: (X → int); } This could be implemented in different ways; for example:<br>&gt;&gt; <br>&gt;&gt; intT = { a: int; f: (int → int); }<br>&gt;&gt; floatT = { a: float; f: (float → int); }<br>&gt;&gt; We discussed how we could create existential types with constraints for protocols and classes so far. Such an existential can’t create something like in the example above.<br>&gt;&gt; <br>&gt;&gt; <br></p><p>With Joe’s information about unbound associated types still being usable, e.g. as `a.Element` with the current proposal we should actually already have existential types like defined in Wikipedia or Haskell (except for the name &quot;existential“ being used differently in Swift, e.g. for protocols without associated types, too).<br></p><p>protocol T {<br>	associatedtype X<br>	var a: X { get }<br>	func f(_ value: X) -&gt; Int<br>}<br></p><p>// use T as existential in Wikipedia’s sense<br>func foo(t: any&lt;T&gt;) -&gt; Int {<br>	return t.f(t.a)  // t.X is not bound to a fixed type but as it is used consistently it works for any T<br>}<br></p><p><br>struct A : T {<br>	var a: Int<br>	func f(_ value: Int) -&gt; Int { return value }<br>}<br></p><p>struct B : T {<br>	var a: String<br>	func f(_ value: String) -&gt; Int { return value.characters.count }<br>}<br></p><p>let a = A(a: 42)<br>let b = B(a: &quot;hello&quot;)<br>let x = foo(a) // 42<br>let y = foo(b) // 5<br></p><p><br>Actually in this case we could have written foo() also as generic function (without having to bind X!)<br></p><p>func foo&lt;P: T&gt;(t: P) -&gt; Int {<br>	return t.f(t.a)<br>}<br></p><p>This works already today.<br></p><p><br>-Thorsten<br></p><p>&gt;&gt; I’m not sure if we need this at all, I’d say it’s a nice to have idea of mine.<br>&gt;&gt; <br>&gt;&gt; To solve this we could introduce a new scope similar to protocols today but without the need to explicitly conform types to this existential.<br>&gt;&gt; <br>&gt;&gt; // the above example can become<br>&gt;&gt; existential T {<br>&gt;&gt;     associatedtype X<br>&gt;&gt;     var a: X<br>&gt;&gt;     func f(_ value: X) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct A /* no explicit conformance to T needed */ {<br>&gt;&gt;     var a: Int<br>&gt;&gt;     init(a: Int) { self.a = a }<br>&gt;&gt;     func f(_ value: Int) -&gt; Int { return value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let store: T = A() // this could or should work, just because we do have visibility to all constraints from T in A here<br></p><p>Isn’t this just structural subtyping as opposed to nominal subtyping (which I strongly prefer)?<br></p><p>-Thorsten<br></p><p><br></p><p>&gt;&gt; <br>&gt;&gt; // if we had `private var a: Int` in A we wouldn&#39;t be able to store A inside `store`<br>&gt;&gt; I din’t though if existential could have potential to replace Any&lt;…&gt; completely. Until now I just wanted to solve that particular issue so please don’t judge with me. :)<br>&gt;&gt; <br>&gt;&gt; Just because of associated types we won’t be able to use store in this example, but there might be more trivial examples where one would use such existential type (for only visible portion at compile or dynamically at run-time) without explicit conformance.<br>&gt;&gt; <br>&gt;&gt; struct B {<br>&gt;&gt;     var x: Int = 42<br>&gt;&gt;     var y: Double = -100.5<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct C: SomeProtocol {<br>&gt;&gt;     var y: Double = 0.0<br>&gt;&gt;     var x: Int = 10<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; existential SomeShinyThing {<br>&gt;&gt;     var x: Int<br>&gt;&gt;     var y: Double<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // we should be safe here because the compiler has visibility for  <br>&gt;&gt; // internal B and C here<br>&gt;&gt; let anotherStore: SomeShinyThing = B() /* or */ C()  <br>&gt;&gt; <br>&gt;&gt; // otherwise one could use dynamic casts<br>&gt;&gt; if let thirdStore = instanceOfCShadowedAsSomeProtocol as? SomeShinyThing { … }<br>&gt;&gt; Feel to tear this idea apart as you want. :D<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/8f91546a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 1:12 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; Am 26.05.2016 um 22:07 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br>&gt; With Joe’s information about unbound associated types still being usable, e.g. as `a.Element` with the current proposal we should actually already have existential types like defined in Wikipedia or Haskell (except for the name &quot;existential“ being used differently in Swift, e.g. for protocols without associated types, too).<br>&gt; <br>&gt; protocol T {<br>&gt; 	associatedtype X<br>&gt; 	var a: X { get }<br>&gt; 	func f(_ value: X) -&gt; Int<br>&gt; }<br>&gt; <br>&gt; // use T as existential in Wikipedia’s sense<br>&gt; func foo(t: any&lt;T&gt;) -&gt; Int {<br>&gt; 	return t.f(t.a)  // t.X is not bound to a fixed type but as it is used consistently it works for any T<br>&gt; }<br></p><p>Yes, this is the key insight. The types aren&#39;t known at runtime, but they are used in a manner that is guaranteed to be sound. (Whatever the type of X is, if you get it as an output from &quot;a&quot; you should be able to pass it into &quot;f&quot;).<br></p><p>&gt; <br>&gt; <br>&gt; struct A : T {<br>&gt; 	var a: Int<br>&gt; 	func f(_ value: Int) -&gt; Int { return value }<br>&gt; }<br>&gt; <br>&gt; struct B : T {<br>&gt; 	var a: String<br>&gt; 	func f(_ value: String) -&gt; Int { return value.characters.count }<br>&gt; }<br>&gt; <br>&gt; let a = A(a: 42)<br>&gt; let b = B(a: &quot;hello&quot;)<br>&gt; let x = foo(a) // 42<br>&gt; let y = foo(b) // 5<br>&gt; <br>&gt; <br>&gt; Actually in this case we could have written foo() also as generic function (without having to bind X!)<br>&gt; <br>&gt; func foo&lt;P: T&gt;(t: P) -&gt; Int {<br>&gt; 	return t.f(t.a)<br>&gt; }<br>&gt; <br>&gt; This works already today.<br></p><p>Once opening existentials enters the language (which would allow two or more existentials to compare their self types and associated types), I think existentials become almost equivalent in power to generics in Swift.<br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2070a71a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Considering how I interpret (i.e. I could be totally wrong) sentiments expressed by the core team on expressiveness, I would wager that duck typing is NOT on their agenda for Swift.<br></p><p><br>&gt; On May 26, 2016, at 8:56 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’d like to throw one idea of mine in the room I couldn’t stop thinking when I read one of Thorsten’s replies on SE–0095 review thread.<br>&gt; <br>&gt; This wiki section explains the existential types where we have something like this:<br>&gt; <br>&gt; &quot;T = ∃X { a: X; f: (X → int); } This could be implemented in different ways; for example:<br>&gt; <br>&gt; intT = { a: int; f: (int → int); }<br>&gt; floatT = { a: float; f: (float → int); }<br>&gt; We discussed how we could create existential types with constraints for protocols and classes so far. Such an existential can’t create something like in the example above.<br>&gt; <br>&gt; I’m not sure if we need this at all, I’d say it’s a nice to have idea of mine.<br>&gt; <br>&gt; To solve this we could introduce a new scope similar to protocols today but without the need to explicitly conform types to this existential.<br>&gt; <br>&gt; // the above example can become<br>&gt; existential T {<br>&gt;     associatedtype X<br>&gt;     var a: X<br>&gt;     func f(_ value: X) -&gt; Int<br>&gt; }<br>&gt; <br>&gt; struct A /* no explicit conformance to T needed */ {<br>&gt;     var a: Int<br>&gt;     init(a: Int) { self.a = a }<br>&gt;     func f(_ value: Int) -&gt; Int { return value }<br>&gt; }<br>&gt; <br>&gt; let store: T = A() // this could or should work, just because we do have visibility to all constraints from T in A here<br>&gt; <br>&gt; // if we had `private var a: Int` in A we wouldn&#39;t be able to store A inside `store`<br>&gt; I din’t though if existential could have potential to replace Any&lt;…&gt; completely. Until now I just wanted to solve that particular issue so please don’t judge with me. :)<br>&gt; <br>&gt; Just because of associated types we won’t be able to use store in this example, but there might be more trivial examples where one would use such existential type (for only visible portion at compile or dynamically at run-time) without explicit conformance.<br>&gt; <br>&gt; struct B {<br>&gt;     var x: Int = 42<br>&gt;     var y: Double = -100.5<br>&gt; }<br>&gt; <br>&gt; struct C: SomeProtocol {<br>&gt;     var y: Double = 0.0<br>&gt;     var x: Int = 10<br>&gt; }<br>&gt; <br>&gt; existential SomeShinyThing {<br>&gt;     var x: Int<br>&gt;     var y: Double<br>&gt; }<br>&gt; <br>&gt; // we should be safe here because the compiler has visibility for  <br>&gt; // internal B and C here<br>&gt; let anotherStore: SomeShinyThing = B() /* or */ C()  <br>&gt; <br>&gt; // otherwise one could use dynamic casts<br>&gt; if let thirdStore = instanceOfCShadowedAsSomeProtocol as? SomeShinyThing { … }<br>&gt; Feel to tear this idea apart as you want. :D<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/6d00aec1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 12:52 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; let a : Any&lt;Collection&gt;<br>&gt; // A variable whose type is the Element associated type of the underlying<br>&gt; // concrete type of &#39;a&#39;.<br>&gt; let theElement : a.Element = ...<br>&gt; <br>&gt; In Scala this would be a „path dependent type“ which actually depends on the variable `a`.<br>&gt; What would happen in the following case:<br>&gt; <br>&gt; func foo&lt;T: Any&lt;Collection&gt;&gt;(a: T, b: T) {<br>&gt; 	// is the type of a.Element equal to the type of b.Element here? (In Scala it would not) <br>&gt; }<br></p><p>As Austin noted, this is unrelated to existentials.  The constraint is identical to &#39;T: Collection&#39;.  Allowing &#39;Any&#39; in constraints is just a convenient way to factor them out (by using a typealias).<br></p><p>Because there is only one type parameter there is only one Element.  But because a and b are not existential values you can&#39;t access the associated type of the instance directly (that is something new in Austin&#39;s proposal).  You have to use either T or dynamicType.<br></p><p>       func foo&lt;T: Collection&gt;(a: T, b: T) {<br>           print(a.dynamicType.Iterator.Element.self == b.dynamicType.Iterator.Element.self)<br>       }<br>       // prints true<br>       foo(a: [1, 2, 3], b: [4, 5, 6])<br></p><p>Austin, this brings to mind the question of how you will handle conflicts if the type defines an instance member with the same name as the asociatedtype.  This should be uncommon due to capitalization conventions but is still a possibility.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/37e060e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 12:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Austin, this brings to mind the question of how you will handle conflicts if the type defines an instance member with the same name as the asociatedtype.  This should be uncommon due to capitalization conventions but is still a possibility.<br></p><p>This is a really good point. I&#39;m tempted at this point to punt on this potential issue, the same way we don&#39;t handle two protocols with associated types that have the same name :).<br></p><p>This problem should be mentioned, but like you said code that conforms to conventional Swift style shouldn&#39;t run into this problem. For example, I wouldn&#39;t expect Apple frameworks to be able to cause this issue in user code, since they are pretty scrupulous about naming. It may simply be easiest to ask users to rename their members if it becomes a problem. (Any alternate suggestions are, as always, welcome too.)<br></p><p>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/76e889d3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Austin,<br></p><p>I never had te occasion to say thanks for the work you have put in this proposal, so thanks! I’m really looking forward to be able to have some form of it accepted and implemented in Swift.<br></p><p>Here are a few comments:<br></p><p>1) Why would Any&lt;&gt; and Any&lt;NSView&gt; be illegal? What error messages would they generate? Why not make them simply synonymous to Any, and NSView, the same way protocol&lt;&gt; currently behaves?<br></p><p>2) You say that &quot;An Any&lt;...&gt; existential can have zero or one where clauses, following the list of requirements.” This seems to be contradicted in two places:<br></p><p>In the example under Nested Any&lt;...&gt;, which should probably be edited to:<br></p><p>// NOT ALLOWED<br>// This is impossible to fufill. A collection&#39;s elements cannot be both strings<br>// and integers at the same time.<br>let a : Any&lt;Collection, Any&lt;Collection where Collection.Element == Int&gt; where Collection.Element == String&gt;<br></p><p>In the where clause section, you say:<br></p><p>Associated types used within the where clause must belong to the protocols in the current or previous requirements.<br></p><p>This sounds a bit bizarre because where clauses always appear at the end, so there is no such “current” requirements and all requirements are “previous”.<br></p><p>I still have to take the time to finish digesting the end of the proposal.<br></p><p>David.<br></p><p>&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/a11d95ab/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 01:00:00pm</p></header><div class="content"><p>(inline)<br></p><p>On Thu, May 26, 2016 at 12:22 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Hi Austin,<br>&gt;<br>&gt; I never had te occasion to say thanks for the work you have put in this<br>&gt; proposal, so thanks! I’m really looking forward to be able to have some<br>&gt; form of it accepted and implemented in Swift.<br>&gt;<br></p><p>Thank you! I just hope a proposal like this one ends up being good enough<br>that it means less work for the core team, not more...<br></p><p><br>&gt;<br>&gt; Here are a few comments:<br>&gt;<br>&gt; 1) Why would Any&lt;&gt; and Any&lt;NSView&gt; be illegal? What error messages would<br>&gt; they generate? Why not make them simply synonymous to Any, and NSView,<br>&gt; the same way protocol&lt;&gt; currently behaves?<br>&gt;<br></p><p>&quot;Any&lt;&gt;&quot; being illegal is a syntactic battle that is being fought over in a<br>different thread; I&#39;m not personally invested one way or another. (We might<br>not even adopt &quot;Any&quot; syntax specifically; Joe Groff has ideas for a<br>different syntax that doesn&#39;t use the brackets.)<br></p><p>&quot;Any&lt;NSView&gt;&quot; is an existential, and &quot;NSView&quot; isn&#39;t. Existentials&#39;<br>metatypes are different from the metatypes of concrete types, and the ways<br>they can be used with generics is different as well. My opinion is that<br>Any&lt;...&gt; signifies an existential, and allowing the use of &quot;Any&lt;SomeClass&gt;&quot;<br>as a concrete type would just confuse people even more.<br></p><p><br>&gt;<br>&gt; 2) You say that &quot;An Any&lt;...&gt; existential can have zero or<br>&gt; one where clauses, *following the list of requirements.*” This seems to<br>&gt; be contradicted in two places:<br>&gt;<br></p><p>&gt; In the example under *Nested Any&lt;...&gt;*, which should probably be edited<br>&gt; to:<br>&gt;<br>&gt; // NOT ALLOWED// This is impossible to fufill. A collection&#39;s elements cannot be both strings// and integers at the same time.let a : Any&lt;Collection, Any&lt;Collection where Collection.Element == Int&gt; where Collection.Element == String&gt;<br>&gt;<br>&gt;<br>&gt;<br>Yes, my wording should have been clearer. What I meant is that you can&#39;t<br>have more than one where clause in the *current* Any&lt;&gt;, but you can nest<br>another Any&lt;&gt; that has its own where clause. I&#39;ll edit the copy.<br></p><p><br>&gt; In the *where clause* section, you say:<br>&gt;<br>&gt; Associated types used within the where clause must belong to the<br>&gt; protocols in the current or previous requirements.<br>&gt;<br>&gt; This sounds a bit bizarre because where clauses always appear at the end,<br>&gt; so there is no such “current” requirements and all requirements are<br>&gt; “previous”.<br>&gt;<br></p><p>You are right; I&#39;ll fix that. The weird verbiage is a remnant of an earlier<br>draft where each protocol could have its own where clause.<br></p><p><br>&gt;<br>&gt; I still have to take the time to finish digesting the end of the proposal.<br>&gt;<br></p><p>Happy to clarify or answer any questions you might have.<br></p><p><br>&gt;<br>&gt; David.<br>&gt;<br>&gt; On 26 May 2016, at 07:53, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The inimitable Joe Groff provided me with an outline as to how the design<br>&gt; could be improved. I&#39;ve taken the liberty of rewriting parts of the<br>&gt; proposal to account for his advice.<br>&gt;<br>&gt; It turns out the runtime type system is considerably more powerful than I<br>&gt; expected. The previous concept in which protocols with associated types&#39;<br>&gt; APIs were vended out selectively and using existentials has been discarded.<br>&gt;<br>&gt; Instead, all the associated types that belong to an existential are<br>&gt; accessible as &#39;anonymous&#39; types within the scope of the existential. These<br>&gt; anonymous types are not existentials - they are an anonymous representation<br>&gt; of whatever concrete type is satisfying the existential&#39;s value&#39;s<br>&gt; underlying type&#39;s associated type.<br>&gt;<br>&gt; This is an enormous step up in power - for example, an existential can<br>&gt; return a value of one of these anonymous associated types from one function<br>&gt; and pass it into another function that takes the same type, maintaining<br>&gt; perfect type safety but without ever revealing the actual type. There is no<br>&gt; need anymore to limit the APIs exposed to the user, although there may<br>&gt; still exist APIs that are semantically useless without additional type<br>&gt; information.<br>&gt;<br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be<br>&gt; used to turn values of these anonymous associated types back into<br>&gt; existentials based on the constraints defined earlier. &#39;as?&#39; can also be<br>&gt; used for conditional casting of these anonymously-typed values into<br>&gt; potential actual types.<br>&gt;<br>&gt; As always, the link is here, and feedback would be greatly appreciated:<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential<br>&gt;&gt; types, I believe you can define Sequence Element directly, rather than with<br>&gt;&gt; a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where<br>&gt;&gt; IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element ==<br>&gt;&gt; Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an<br>&gt;&gt; existential, not a protocol. It&#39;s basically an automatically-generated<br>&gt;&gt; version of our current `AnyIterator&lt;T&gt;` type (though with some additional<br>&gt;&gt; flexibility). It can&#39;t appear on the right side of a `:`, any more than<br>&gt;&gt; AnyIterator could.<br>&gt;&gt;<br>&gt;&gt; After this proposal you should be able to use these existentials anywhere<br>&gt;&gt; you can place a constraint, so it would work.  You can do this with the<br>&gt;&gt; protocol composition operator today and the future existential is just an<br>&gt;&gt; extension of that capability.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where<br>&gt;&gt; Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element ==<br>&gt;&gt; Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/ee057f65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 26.05.2016 um 22:44 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; (inline)<br>&gt; <br>&gt; On Thu, May 26, 2016 at 12:22 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; Hi Austin,<br>&gt; <br>&gt; I never had te occasion to say thanks for the work you have put in this proposal, so thanks! I’m really looking forward to be able to have some form of it accepted and implemented in Swift.<br>&gt; <br>&gt; Thank you! I just hope a proposal like this one ends up being good enough that it means less work for the core team, not more...<br>&gt;  <br>&gt; <br>&gt; Here are a few comments:<br>&gt; <br>&gt; 1) Why would Any&lt;&gt; and Any&lt;NSView&gt; be illegal? What error messages would they generate? Why not make them simply synonymous to Any, and NSView, the same way protocol&lt;&gt; currently behaves?<br>&gt; <br>&gt; &quot;Any&lt;&gt;&quot; being illegal is a syntactic battle that is being fought over in a different thread; I&#39;m not personally invested one way or another. (We might not even adopt &quot;Any&quot; syntax specifically; Joe Groff has ideas for a different syntax that doesn&#39;t use the brackets.)<br>&gt; <br>&gt; &quot;Any&lt;NSView&gt;&quot; is an existential, and &quot;NSView&quot; isn&#39;t. Existentials&#39; metatypes are different from the metatypes of concrete types, and the ways they can be used with generics is different as well. My opinion is that Any&lt;...&gt; signifies an existential, and allowing the use of &quot;Any&lt;SomeClass&gt;&quot; as a concrete type would just confuse people even more.<br></p><p><br>This is something where I still have a problem understanding what an existential is in the Swift sense. In the &quot;normal“ sense (as defined in Wikipedia or Haskell) NSView cannot be an existential because it has no unbound associated types. It cannot be just made an existential either. How would that work?<br></p><p>So, what is the meaning of `Any&lt;NSView&gt;` being an existential? How is that type different from the type `NSView`?<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/6d6a4044/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 01:00:00am</p></header><div class="content"><p>Thank you for all your great feedback!<br></p><p>Let me try rephrasing what I said, because it wasn&#39;t very clear. Apologies.<br></p><p>NSView is not an existential, like you said.<br></p><p>Any&lt;...&gt; syntax is, as far as we&#39;ve seen, always used for existential types.<br></p><p>&quot;Any&lt;NSView&gt;&quot; *looks* like an existential because it has the &quot;Any&lt;...&gt;&quot; syntax, but if it&#39;s a synonym for just &quot;NSView&quot; then it actually isn&#39;t an existential.<br></p><p>So &quot;Any&lt;NSView&gt;&quot; isn&#39;t an existential, but it looks like one. This is something I think would be confusing to a lot of people, and also redundant: there is no reason as far as I know to ever write Any&lt;SomeClass&gt; when you could just write SomeClass, so by banning the confusing form we don&#39;t lose any expressive power.<br></p><p>Hope that helps,<br>Austin<br></p><p>&gt; On May 27, 2016, at 1:24 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 26.05.2016 um 22:44 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; (inline)<br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 12:22 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; Hi Austin,<br>&gt;&gt; <br>&gt;&gt; I never had te occasion to say thanks for the work you have put in this proposal, so thanks! I’m really looking forward to be able to have some form of it accepted and implemented in Swift.<br>&gt;&gt; <br>&gt;&gt; Thank you! I just hope a proposal like this one ends up being good enough that it means less work for the core team, not more...<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Here are a few comments:<br>&gt;&gt; <br>&gt;&gt; 1) Why would Any&lt;&gt; and Any&lt;NSView&gt; be illegal? What error messages would they generate? Why not make them simply synonymous to Any, and NSView, the same way protocol&lt;&gt; currently behaves?<br>&gt;&gt; <br>&gt;&gt; &quot;Any&lt;&gt;&quot; being illegal is a syntactic battle that is being fought over in a different thread; I&#39;m not personally invested one way or another. (We might not even adopt &quot;Any&quot; syntax specifically; Joe Groff has ideas for a different syntax that doesn&#39;t use the brackets.)<br>&gt;&gt; <br>&gt;&gt; &quot;Any&lt;NSView&gt;&quot; is an existential, and &quot;NSView&quot; isn&#39;t. Existentials&#39; metatypes are different from the metatypes of concrete types, and the ways they can be used with generics is different as well. My opinion is that Any&lt;...&gt; signifies an existential, and allowing the use of &quot;Any&lt;SomeClass&gt;&quot; as a concrete type would just confuse people even more.<br>&gt; <br>&gt; <br>&gt; This is something where I still have a problem understanding what an existential is in the Swift sense. In the &quot;normal“ sense (as defined in Wikipedia or Haskell) NSView cannot be an existential because it has no unbound associated types. It cannot be just made an existential either. How would that work?<br>&gt; <br>&gt; So, what is the meaning of `Any&lt;NSView&gt;` being an existential? How is that type different from the type `NSView`?<br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/0cfa03dc/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>protocol Protocol1 { }<br></p><p>func doSomething&lt;T : Protocol1&gt;(arg: T) { ... }<br></p><p>func doSomethingElse(a: Any&lt;Collection where .Element : Protocol1&gt;) {<br>    let firstElement : a.Element = a.first!<br></p><p>    // NOT ALLOWED - allowing this would mean allowing doSomething&lt;T&gt; to be<br>    // specialized upon &quot;a.Element&quot;, which makes little sense.<br>    doSomething(firstElement)<br>}<br></p><p>I do not agree with this restriction. This should be possible.<br>`a.Element` is constrained to `Protocol1` so I don’t see a reason to forbid calling doSomething(firstElement) which expects a `Protocol1`.<br></p><p>I do not understand the comment &quot;allowing doSomething&lt;T&gt; to be specialized upon ‚a.Element‘“.<br>Swift is not C++ where generics are templates which are realized for the type parameters involved. In Swift like in most other languages a generic function exists only once and will just use the types given within their restrictions, i.e. here T must conform to Protocol1, so all methods of Protocol1 can be used on `arg` within `doSomething`. The type `a.Element` does not exist within `doSomething` and therefore no escaping takes place.<br></p><p>-Thorsten<br> <br></p><p>&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/26ba4c9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 01:00:00am</p></header><div class="content"><p>This is a good point. &quot;a.Element&quot; is not an existential, it is a concrete type whose value is not known at compile time. So there is nothing in principle stopping it from being passed into a generic function. This would also allow you to do thing like e.g. make an Array of a.Elements, which might be useful. (You can imagine calling an API that returns an &quot;a.Index&quot; several times, putting the returned values in an array, and then passing an &quot;[a.Index]&quot; into a different API.)<br></p><p>I will remove the restriction and make a note; if the proposal goes to review the impetus will be on the core team to cut it out of they think it is too difficult to implement.<br></p><p>Austin<br></p><p>&gt; On May 26, 2016, at 11:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; protocol Protocol1 { }<br>&gt; <br>&gt; func doSomething&lt;T : Protocol1&gt;(arg: T) { ... }<br>&gt; <br>&gt; func doSomethingElse(a: Any&lt;Collection where .Element : Protocol1&gt;) {<br>&gt;     let firstElement : a.Element = a.first!<br>&gt; <br>&gt;     // NOT ALLOWED - allowing this would mean allowing doSomething&lt;T&gt; to be<br>&gt;     // specialized upon &quot;a.Element&quot;, which makes little sense.<br>&gt;     doSomething(firstElement)<br>&gt; }<br>&gt; <br>&gt; I do not agree with this restriction. This should be possible.<br>&gt; `a.Element` is constrained to `Protocol1` so I don’t see a reason to forbid calling doSomething(firstElement) which expects a `Protocol1`.<br>&gt; <br>&gt; I do not understand the comment &quot;allowing doSomething&lt;T&gt; to be specialized upon ‚a.Element‘“.<br>&gt; Swift is not C++ where generics are templates which are realized for the type parameters involved. In Swift like in most other languages a generic function exists only once and will just use the types given within their restrictions, i.e. here T must conform to Protocol1, so all methods of Protocol1 can be used on `arg` within `doSomething`. The type `a.Element` does not exist within `doSomething` and therefore no escaping takes place.<br>&gt; <br>&gt; -Thorsten<br>&gt;  <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/1a24b314/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks! And thanks for your great work on this proposal!<br></p><p>-Thorsten<br></p><p><br>&gt; Am 27.05.2016 um 10:10 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; This is a good point. &quot;a.Element&quot; is not an existential, it is a concrete type whose value is not known at compile time. So there is nothing in principle stopping it from being passed into a generic function. This would also allow you to do thing like e.g. make an Array of a.Elements, which might be useful. (You can imagine calling an API that returns an &quot;a.Index&quot; several times, putting the returned values in an array, and then passing an &quot;[a.Index]&quot; into a different API.)<br>&gt; <br>&gt; I will remove the restriction and make a note; if the proposal goes to review the impetus will be on the core team to cut it out of they think it is too difficult to implement.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On May 26, 2016, at 11:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; protocol Protocol1 { }<br>&gt;&gt; <br>&gt;&gt; func doSomething&lt;T : Protocol1&gt;(arg: T) { ... }<br>&gt;&gt; <br>&gt;&gt; func doSomethingElse(a: Any&lt;Collection where .Element : Protocol1&gt;) {<br>&gt;&gt;     let firstElement : a.Element = a.first!<br>&gt;&gt; <br>&gt;&gt;     // NOT ALLOWED - allowing this would mean allowing doSomething&lt;T&gt; to be<br>&gt;&gt;     // specialized upon &quot;a.Element&quot;, which makes little sense.<br>&gt;&gt;     doSomething(firstElement)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I do not agree with this restriction. This should be possible.<br>&gt;&gt; `a.Element` is constrained to `Protocol1` so I don’t see a reason to forbid calling doSomething(firstElement) which expects a `Protocol1`.<br>&gt;&gt; <br>&gt;&gt; I do not understand the comment &quot;allowing doSomething&lt;T&gt; to be specialized upon ‚a.Element‘“.<br>&gt;&gt; Swift is not C++ where generics are templates which are realized for the type parameters involved. In Swift like in most other languages a generic function exists only once and will just use the types given within their restrictions, i.e. here T must conform to Protocol1, so all methods of Protocol1 can be used on `arg` within `doSomething`. The type `a.Element` does not exist within `doSomething` and therefore no escaping takes place.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/bdfe0778/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m not happy with that restriction in the proposal:<br></p><p>Existentials cannot be used with generics in the following ways:<br></p><p>In generic declarations, with the requirements composed out of generic type variables:<br></p><p>// NOT ALLOWED<br>func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br></p><p>Why is that not allowed?<br></p><p>I would have hoped to be able to write something like<br></p><p>func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br></p><p><br>-Thorsten<br></p><p><br></p><p>&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt; <br>&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt; <br>&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt; <br>&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt; <br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt; <br>&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt; <br>&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt; &gt;<br>&gt; &gt;&gt; protocol Sequence {<br>&gt; &gt;&gt;  associatedtype Element<br>&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt; &gt;&gt;  …<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I believe this is part of the generics manifesto.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/94774c9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 12:00:00pm</p></header><div class="content"><p>There are a couple of reasons why it&#39;s not possible.<br></p><p>- You can&#39;t force A and B to be protocols (forcing them to be protocols is<br>distinct from forcing them to be types that implement a certain protocol).<br>If you pass in two concrete types &quot;Any&lt;A, B&gt;&quot; becomes invalid.<br></p><p>- If a generic type has any constraints on it, that generic type cannot be<br>fulfilled by an existential today. A protocol is not considered to<br>implement itself.<br></p><p>Changing how generics work to accommodate this functionality is beyond the<br>scope of this proposal, which is already too big as is.<br></p><p>Austin<br></p><p><br>On Sat, May 28, 2016 at 12:31 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt; I’m not happy with that restriction in the proposal:<br>&gt;<br>&gt; Existentials cannot be used with generics in the following ways:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    In generic declarations, with the requirements composed out of generic<br>&gt;    type variables:<br>&gt;<br>&gt;    // NOT ALLOWEDfunc foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Why is that not allowed?<br>&gt;<br>&gt; I would have hoped to be able to write something like<br>&gt;<br>&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; The inimitable Joe Groff provided me with an outline as to how the design<br>&gt; could be improved. I&#39;ve taken the liberty of rewriting parts of the<br>&gt; proposal to account for his advice.<br>&gt;<br>&gt; It turns out the runtime type system is considerably more powerful than I<br>&gt; expected. The previous concept in which protocols with associated types&#39;<br>&gt; APIs were vended out selectively and using existentials has been discarded.<br>&gt;<br>&gt; Instead, all the associated types that belong to an existential are<br>&gt; accessible as &#39;anonymous&#39; types within the scope of the existential. These<br>&gt; anonymous types are not existentials - they are an anonymous representation<br>&gt; of whatever concrete type is satisfying the existential&#39;s value&#39;s<br>&gt; underlying type&#39;s associated type.<br>&gt;<br>&gt; This is an enormous step up in power - for example, an existential can<br>&gt; return a value of one of these anonymous associated types from one function<br>&gt; and pass it into another function that takes the same type, maintaining<br>&gt; perfect type safety but without ever revealing the actual type. There is no<br>&gt; need anymore to limit the APIs exposed to the user, although there may<br>&gt; still exist APIs that are semantically useless without additional type<br>&gt; information.<br>&gt;<br>&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be<br>&gt; used to turn values of these anonymous associated types back into<br>&gt; existentials based on the constraints defined earlier. &#39;as?&#39; can also be<br>&gt; used for conditional casting of these anonymously-typed values into<br>&gt; potential actual types.<br>&gt;<br>&gt; As always, the link is here, and feedback would be greatly appreciated:<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential<br>&gt;&gt; types, I believe you can define Sequence Element directly, rather than with<br>&gt;&gt; a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where<br>&gt;&gt; IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element ==<br>&gt;&gt; Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an<br>&gt;&gt; existential, not a protocol. It&#39;s basically an automatically-generated<br>&gt;&gt; version of our current `AnyIterator&lt;T&gt;` type (though with some additional<br>&gt;&gt; flexibility). It can&#39;t appear on the right side of a `:`, any more than<br>&gt;&gt; AnyIterator could.<br>&gt;&gt;<br>&gt;&gt; After this proposal you should be able to use these existentials anywhere<br>&gt;&gt; you can place a constraint, so it would work.  You can do this with the<br>&gt;&gt; protocol composition operator today and the future existential is just an<br>&gt;&gt; extension of that capability.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where<br>&gt;&gt; Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element ==<br>&gt;&gt; Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/025fb580/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Two more minor things:<br></p><p>- The wording of that section should be amended to make it clear that the<br>current behavior (existentials with exactly one requirement and no<br>constraints are allowed to satisfy totally unconstrained generic type<br>parameters) continues to be allowed.<br></p><p>- Unfortunately, even if we did somehow support this feature your snippet<br>would be impossible to express :(. Set&lt;Any&lt;A, B&gt;&gt; requires Any&lt;A, B&gt; to<br>conform to Hashable, but protocols conforming to other protocols is marked<br>as a non-started in the Completing Generics document.<br></p><p>Hope that helps,<br>Austin<br></p><p>On Sat, May 28, 2016 at 12:38 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>wrote:<br></p><p>&gt; There are a couple of reasons why it&#39;s not possible.<br>&gt;<br>&gt; - You can&#39;t force A and B to be protocols (forcing them to be protocols is<br>&gt; distinct from forcing them to be types that implement a certain protocol).<br>&gt; If you pass in two concrete types &quot;Any&lt;A, B&gt;&quot; becomes invalid.<br>&gt;<br>&gt; - If a generic type has any constraints on it, that generic type cannot be<br>&gt; fulfilled by an existential today. A protocol is not considered to<br>&gt; implement itself.<br>&gt;<br>&gt; Changing how generics work to accommodate this functionality is beyond the<br>&gt; scope of this proposal, which is already too big as is.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On Sat, May 28, 2016 at 12:31 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I’m not happy with that restriction in the proposal:<br>&gt;&gt;<br>&gt;&gt; Existentials cannot be used with generics in the following ways:<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    In generic declarations, with the requirements composed out of<br>&gt;&gt;    generic type variables:<br>&gt;&gt;<br>&gt;&gt;    // NOT ALLOWEDfunc foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why is that not allowed?<br>&gt;&gt;<br>&gt;&gt; I would have hoped to be able to write something like<br>&gt;&gt;<br>&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design<br>&gt;&gt; could be improved. I&#39;ve taken the liberty of rewriting parts of the<br>&gt;&gt; proposal to account for his advice.<br>&gt;&gt;<br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I<br>&gt;&gt; expected. The previous concept in which protocols with associated types&#39;<br>&gt;&gt; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;<br>&gt;&gt; Instead, all the associated types that belong to an existential are<br>&gt;&gt; accessible as &#39;anonymous&#39; types within the scope of the existential. These<br>&gt;&gt; anonymous types are not existentials - they are an anonymous representation<br>&gt;&gt; of whatever concrete type is satisfying the existential&#39;s value&#39;s<br>&gt;&gt; underlying type&#39;s associated type.<br>&gt;&gt;<br>&gt;&gt; This is an enormous step up in power - for example, an existential can<br>&gt;&gt; return a value of one of these anonymous associated types from one function<br>&gt;&gt; and pass it into another function that takes the same type, maintaining<br>&gt;&gt; perfect type safety but without ever revealing the actual type. There is no<br>&gt;&gt; need anymore to limit the APIs exposed to the user, although there may<br>&gt;&gt; still exist APIs that are semantically useless without additional type<br>&gt;&gt; information.<br>&gt;&gt;<br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be<br>&gt;&gt; used to turn values of these anonymous associated types back into<br>&gt;&gt; existentials based on the constraints defined earlier. &#39;as?&#39; can also be<br>&gt;&gt; used for conditional casting of these anonymously-typed values into<br>&gt;&gt; potential actual types.<br>&gt;&gt;<br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated:<br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential<br>&gt;&gt;&gt; types, I believe you can define Sequence Element directly, rather than with<br>&gt;&gt;&gt; a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where<br>&gt;&gt;&gt; IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element ==<br>&gt;&gt;&gt; Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an<br>&gt;&gt;&gt; existential, not a protocol. It&#39;s basically an automatically-generated<br>&gt;&gt;&gt; version of our current `AnyIterator&lt;T&gt;` type (though with some additional<br>&gt;&gt;&gt; flexibility). It can&#39;t appear on the right side of a `:`, any more than<br>&gt;&gt;&gt; AnyIterator could.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; After this proposal you should be able to use these existentials<br>&gt;&gt;&gt; anywhere you can place a constraint, so it would work.  You can do this<br>&gt;&gt;&gt; with the protocol composition operator today and the future existential is<br>&gt;&gt;&gt; just an extension of that capability.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where<br>&gt;&gt;&gt; Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element ==<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/f1fc065b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 2:31 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not happy with that restriction in the proposal:<br>&gt; <br>&gt; Existentials cannot be used with generics in the following ways:<br>&gt; <br>&gt; In generic declarations, with the requirements composed out of generic type variables:<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt; <br>&gt; Why is that not allowed?<br>&gt; <br>&gt; I would have hoped to be able to write something like<br>&gt; <br>&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br></p><p>What do you expect to happen when someone writes: `union(Set&lt;Int&gt;(), Set&lt;String&gt;())`?<br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/d76a796e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 28.05.2016 um 22:04 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 2:31 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not happy with that restriction in the proposal:<br>&gt;&gt; <br>&gt;&gt; Existentials cannot be used with generics in the following ways:<br>&gt;&gt; <br>&gt;&gt; In generic declarations, with the requirements composed out of generic type variables:<br>&gt;&gt; <br>&gt;&gt; // NOT ALLOWED<br>&gt;&gt; func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; Why is that not allowed?<br>&gt;&gt; <br>&gt;&gt; I would have hoped to be able to write something like<br>&gt;&gt; <br>&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt; <br>&gt; What do you expect to happen when someone writes: `union(Set&lt;Int&gt;(), Set&lt;String&gt;())`?<br></p><p>(I meant `intersection` instead of `union`… see my other response, but for the union case which should result in `Set&lt;A | B&gt;` I would expect Set&lt;Int | String&gt;; for the intersection case I would expect Set&lt;Any&lt;Int, String&gt;&gt; which would be Set&lt;Bottom&gt; or Set&lt;Nothing&gt; in Ceylon, where the bottom type is called `Nothing`).<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/7288f406/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 2:31 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not happy with that restriction in the proposal:<br>&gt; <br>&gt; Existentials cannot be used with generics in the following ways:<br>&gt; <br>&gt; In generic declarations, with the requirements composed out of generic type variables:<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt; <br>&gt; Why is that not allowed?<br>&gt; <br>&gt; I would have hoped to be able to write something like<br>&gt; <br>&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br></p><p>I think what you’re looking for is an anonymous union type `A | B`, not an existential made of the two of them.  <br></p><p>To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br></p><p>The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br></p><p>func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br></p><p>And returning the expected result.<br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt; <br>&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt; <br>&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt; <br>&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt; <br>&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt; <br>&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt; <br>&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt; &gt;&gt;  …<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/a28da50e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 28.05.2016 um 22:08 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 2:31 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not happy with that restriction in the proposal:<br>&gt;&gt; <br>&gt;&gt; Existentials cannot be used with generics in the following ways:<br>&gt;&gt; <br>&gt;&gt; In generic declarations, with the requirements composed out of generic type variables:<br>&gt;&gt; <br>&gt;&gt; // NOT ALLOWED<br>&gt;&gt; func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; Why is that not allowed?<br>&gt;&gt; <br>&gt;&gt; I would have hoped to be able to write something like<br>&gt;&gt; <br>&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt; <br>&gt; I think what you’re looking for is an anonymous union type `A | B`, not an existential made of the two of them.  <br></p><p>Sorry, I of course meant<br></p><p>func intersection&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br></p><p>I guess I will forever confuse this until we write existentials with `&amp;`…<br></p><p>You are right, for the union I want the union type `A | B`. But that is stuff for another proposal.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt; <br>&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt; <br>&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt; <br>&gt; And returning the expected result.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/57a37344/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 8:50 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 28.05.2016 um 22:08 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 2:31 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not happy with that restriction in the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existentials cannot be used with generics in the following ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In generic declarations, with the requirements composed out of generic type variables:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt; func foo&lt;A, B&gt;(x: A, y: B) -&gt; Any&lt;A, B&gt; { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is that not allowed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would have hoped to be able to write something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt;&gt; <br>&gt;&gt; I think what you’re looking for is an anonymous union type `A | B`, not an existential made of the two of them.  <br>&gt; <br>&gt; Sorry, I of course meant<br>&gt; <br>&gt; func intersection&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;Any&lt;A, B&gt;&gt; { … }<br>&gt; <br>&gt; I guess I will forever confuse this until we write existentials with `&amp;`…<br>&gt; <br>&gt; You are right, for the union I want the union type `A | B`. But that is stuff for another proposal.<br></p><p>This makes a lot more sense!  So you want to be able to use uninhabitable types in the contexts of things like collection elements (such collections must always be empty but are inhabitable by a single empty instance).  It is a great example of why it might make sense to allow types like this.  <br></p><p>What you are really asking for is the ability to drop the restriction that only a single superclass constraint is allowed and no value type constraints are allowed.  It might be useful in cases like your intersection example.  But it could also be a source of error confusing error messages when people form such a type and it doesn&#39;t work the way they expect.  If the type is disallowed as under the current proposal the error message might be more straightforward.  This is a topic that probably deserves further consideration.  But I have to say I find your intersection example to be reasonably compelling.<br></p><p>Austin, what do you think about this example?<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt;&gt; <br>&gt;&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt;&gt; <br>&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt;&gt; <br>&gt;&gt; And returning the expected result.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/91893c51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 29, 2016, at 7:04 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This makes a lot more sense!  So you want to be able to use uninhabitable types in the contexts of things like collection elements (such collections must always be empty but are inhabitable by a single empty instance).  It is a great example of why it might make sense to allow types like this.  <br>&gt; <br>&gt; What you are really asking for is the ability to drop the restriction that only a single superclass constraint is allowed and no value type constraints are allowed.  It might be useful in cases like your intersection example.  But it could also be a source of error confusing error messages when people form such a type and it doesn&#39;t work the way they expect.  If the type is disallowed as under the current proposal the error message might be more straightforward.  This is a topic that probably deserves further consideration.  But I have to say I find your intersection example to be reasonably compelling.<br>&gt; <br>&gt; Austin, what do you think about this example?<br></p><p>I personally don&#39;t feel like the additional complexity is worth it as Swift exists today.<br></p><p>Swift getting a real bottom type would be a completely different proposal. It would allow you to do things like:<br></p><p>let universalNil : Bottom? = nil<br>var a : Int? = universalNil<br>var b : UIView? = universalNil<br></p><p>and so on.<br></p><p>If Swift does ever get such a type relaxing the restriction from the proposal would be an additive change, and could be proposed separately as a follow up addition.<br></p><p>Austin<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And returning the expected result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/6bfbd27b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 29.05.2016 um 18:07 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 29, 2016, at 7:04 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This makes a lot more sense!  So you want to be able to use uninhabitable types in the contexts of things like collection elements (such collections must always be empty but are inhabitable by a single empty instance).  It is a great example of why it might make sense to allow types like this.  <br>&gt;&gt; <br>&gt;&gt; What you are really asking for is the ability to drop the restriction that only a single superclass constraint is allowed and no value type constraints are allowed.  It might be useful in cases like your intersection example.  But it could also be a source of error confusing error messages when people form such a type and it doesn&#39;t work the way they expect.  If the type is disallowed as under the current proposal the error message might be more straightforward.  This is a topic that probably deserves further consideration.  But I have to say I find your intersection example to be reasonably compelling.<br>&gt;&gt; <br>&gt;&gt; Austin, what do you think about this example?<br>&gt; <br>&gt; I personally don&#39;t feel like the additional complexity is worth it as Swift exists today.<br></p><p>I agree that adding a bottom type would be a different proposal. As an intermediate step we could just make it a type error if an existential would only be satisfied by the bottom type. <br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; Swift getting a real bottom type would be a completely different proposal. It would allow you to do things like:<br>&gt; <br>&gt; let universalNil : Bottom? = nil<br>&gt; var a : Int? = universalNil<br>&gt; var b : UIView? = universalNil<br>&gt; <br>&gt; and so on.<br>&gt; <br>&gt; If Swift does ever get such a type relaxing the restriction from the proposal would be an additive change, and could be proposed separately as a follow up addition.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And returning the expected result.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/982b0434/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;ll add it to the &quot;Future Directions&quot; section. I feel that&#39;s the best place to put it, since there&#39;s no guarantee that Swift will get a bottom type, and because making existentials to work with a bottom type would be a completely additive change.<br></p><p>Austin<br></p><p>&gt; On May 29, 2016, at 12:48 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 29.05.2016 um 18:07 schrieb Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 7:04 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes a lot more sense!  So you want to be able to use uninhabitable types in the contexts of things like collection elements (such collections must always be empty but are inhabitable by a single empty instance).  It is a great example of why it might make sense to allow types like this.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you are really asking for is the ability to drop the restriction that only a single superclass constraint is allowed and no value type constraints are allowed.  It might be useful in cases like your intersection example.  But it could also be a source of error confusing error messages when people form such a type and it doesn&#39;t work the way they expect.  If the type is disallowed as under the current proposal the error message might be more straightforward.  This is a topic that probably deserves further consideration.  But I have to say I find your intersection example to be reasonably compelling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin, what do you think about this example?<br>&gt;&gt; <br>&gt;&gt; I personally don&#39;t feel like the additional complexity is worth it as Swift exists today.<br>&gt; <br>&gt; I agree that adding a bottom type would be a different proposal. As an intermediate step we could just make it a type error if an existential would only be satisfied by the bottom type. <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Swift getting a real bottom type would be a completely different proposal. It would allow you to do things like:<br>&gt;&gt; <br>&gt;&gt; let universalNil : Bottom? = nil<br>&gt;&gt; var a : Int? = universalNil<br>&gt;&gt; var b : UIView? = universalNil<br>&gt;&gt; <br>&gt;&gt; and so on.<br>&gt;&gt; <br>&gt;&gt; If Swift does ever get such a type relaxing the restriction from the proposal would be an additive change, and could be proposed separately as a follow up addition.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And returning the expected result.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/64a7d8b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Forgive me if this has already come up, but since we’re talking about fixing generics, I wonder if there is any solution in the pipeline for this problem:<br></p><p>--<br></p><p>protocol P { func foo() }<br>struct S: P { func foo() { print(&quot;foo&quot;) } }<br></p><p>func doSomething&lt;C: CollectionType where C.Generator.Element: P&gt;(c: C) {<br>	for each in c {<br>		each.foo()<br>	}<br>}<br></p><p>let arr: [P] = [S()]<br></p><p>doSomething(arr) // error: cannot invoke &#39;doSomething&#39; with an argument list of type &#39;([P])’<br></p><p>--<br></p><p>Why is this an error? The whole definition of [P] is basically an array of things that conform to P. Isn’t that exactly what “where Element: P” is asking for?<br></p><p>Changing Element: P to Element == P solves this particular issue, of course, but then passing something like [S] to the array will fail. The result is that you need to write two functions, and either have one eat the performance cost of constructing a new array that has the correct static type to pass to the other (since, unlike arrays, I can’t figure out a way to convert “Collection where Element: P” into “Collection where Element == P” with a simple cast), or just fill it with the dreaded copy-paste code. Neither seems ideal.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br></p><p>I think there was some discussion about it on the original &quot;Completing Generics&quot; thread from March. I&#39;d probably ask on the swift-users list why P can&#39;t be made to conform to P, and then put together a proposal if there&#39;s no good reason.<br></p><p>Austin<br></p><p>&gt; On May 29, 2016, at 3:13 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Forgive me if this has already come up, but since we’re talking about fixing generics, I wonder if there is any solution in the pipeline for this problem:<br>&gt; <br>&gt; --<br>&gt; <br>&gt; protocol P { func foo() }<br>&gt; struct S: P { func foo() { print(&quot;foo&quot;) } }<br>&gt; <br>&gt; func doSomething&lt;C: CollectionType where C.Generator.Element: P&gt;(c: C) {<br>&gt; 	for each in c {<br>&gt; 		each.foo()<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let arr: [P] = [S()]<br>&gt; <br>&gt; doSomething(arr) // error: cannot invoke &#39;doSomething&#39; with an argument list of type &#39;([P])’<br>&gt; <br>&gt; --<br>&gt; <br>&gt; Why is this an error? The whole definition of [P] is basically an array of things that conform to P. Isn’t that exactly what “where Element: P” is asking for?<br>&gt; <br>&gt; Changing Element: P to Element == P solves this particular issue, of course, but then passing something like [S] to the array will fail. The result is that you need to write two functions, and either have one eat the performance cost of constructing a new array that has the correct static type to pass to the other (since, unlike arrays, I can’t figure out a way to convert “Collection where Element: P” into “Collection where Element == P” with a simple cast), or just fill it with the dreaded copy-paste code. Neither seems ideal.<br>&gt; <br>&gt; Charles<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br></p><p>But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br></p><p>&gt; I think there was some discussion about it on the original &quot;Completing Generics&quot; thread from March. I&#39;d probably ask on the swift-users list why P can&#39;t be made to conform to P, and then put together a proposal if there&#39;s no good reason.<br></p><p>Will do.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/e30b0d8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt; <br>&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br></p><p>You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br></p><p>There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br></p><p>&gt; <br>&gt;&gt; I think there was some discussion about it on the original &quot;Completing Generics&quot; thread from March. I&#39;d probably ask on the swift-users list why P can&#39;t be made to conform to P, and then put together a proposal if there&#39;s no good reason.<br>&gt; <br>&gt; Will do.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/d40214f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt;&gt; <br>&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt; <br>&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt; <br>&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br></p><p>It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/b41e1302/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt;&gt; <br>&gt;&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt;&gt; <br>&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt; <br>&gt; It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br></p><p>Existentials have their own type in Swift.  The problem you are running into is because the generic constraint is looking at the existential type of P and asking if that type conforms to P (which it does not - you can&#39;t write the conformance and the compiler does not provide it for you).  It is not asking if the type of the object underlying the existential value conforms to P (which it necessarily does).  When you have a value of type P you have already erased the type of the underlying object.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/dc9bb2c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 10:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; On May 29, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt; <br>&gt;&gt; It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br>&gt; <br>&gt; Existentials have their own type in Swift.  The problem you are running into is because the generic constraint is looking at the existential type of P and asking if that type conforms to P (which it does not - you can&#39;t write the conformance and the compiler does not provide it for you).  It is not asking if the type of the object underlying the existential value conforms to P (which it necessarily does).  When you have a value of type P you have already erased the type of the underlying object.<br></p><p>Have we not also erased the type of the underlying object with id &lt;P&gt;, though? The only thing we get from the “id” is that it’s an Objective-C object of some type, which it would have to have been anyway in order to conform to the protocol in the first place. Thus the type of the object is erased, and the only thing we know about it is that it conforms to the protocol—just like something typed P in Swift.<br></p><p>What I’m trying to figure out is whether there’s any positive benefit or rationale to the reason things work the way they do here, or whether it’s just bugs / implementation details.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/fbbb38f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 30, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 10:22 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 10:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br>&gt;&gt; <br>&gt;&gt; Existentials have their own type in Swift.  The problem you are running into is because the generic constraint is looking at the existential type of P and asking if that type conforms to P (which it does not - you can&#39;t write the conformance and the compiler does not provide it for you).  It is not asking if the type of the object underlying the existential value conforms to P (which it necessarily does).  When you have a value of type P you have already erased the type of the underlying object.<br>&gt; <br>&gt; Have we not also erased the type of the underlying object with id &lt;P&gt;, though? The only thing we get from the “id” is that it’s an Objective-C object of some type, which it would have to have been anyway in order to conform to the protocol in the first place. Thus the type of the object is erased, and the only thing we know about it is that it conforms to the protocol—just like something typed P in Swift.<br></p><p>In Swift values with the existential type P are not necessarily objects, they could be values.  Because of this existentials are implemented a bit differently.<br></p><p>&gt; <br>&gt; What I’m trying to figure out is whether there’s any positive benefit or rationale to the reason things work the way they do here, or whether it’s just bugs / implementation details.<br></p><p>I think it&#39;s a bit of both.  As I mentioned, IIRC there are cases where values of existential type *cannot* correctly conform to the protocol that they were derived from (I believe this is when Self or associated type requirements are involved).  There are also cases where it is possible but is more difficult to implement than you might expect.  I think we&#39;ll see progress eventually, but not in Swift 3.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/973d4b33/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 5:22 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 10:13 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br></p><p>not that simple. see further down.<br></p><p>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br>&gt;&gt; <br>&gt;&gt; Existentials have their own type in Swift.  The problem you are running into is because the generic constraint is looking at the existential type of P and asking if that type conforms to P (which it does not - you can&#39;t write the conformance and the compiler does not provide it for you).  It is not asking if the type of the object underlying the existential value conforms to P (which it necessarily does).  When you have a value of type P you have already erased the type of the underlying object.<br>&gt; <br>&gt; Have we not also erased the type of the underlying object with id &lt;P&gt;, though? The only thing we get from the “id” is that it’s an Objective-C object of some type, which it would have to have been anyway in order to conform to the protocol in the first place. Thus the type of the object is erased, and the only thing we know about it is that it conforms to the protocol—just like something typed P in Swift.<br>&gt; <br>&gt; What I’m trying to figure out is whether there’s any positive benefit or rationale to the reason things work the way they do here, or whether it’s just bugs / implementation details.<br>&gt; <br></p><p>I’ve been wondering about that one because of this:<br></p><p>    /// Whether the existential of this protocol conforms to itself.<br>    unsigned ExistentialConformsToSelf : 1;<br></p><p>but in the end it is false for non obj-c protocols (which eliminates the Struct in the example). but there are still more rules<br></p><p><br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/c921c1c0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 5:13 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 29, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 9:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 5:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 5:16 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the problem here is that P == P is true, but P : P is not (a protocol does not conform to itself).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if you have a variable, parameter, etc. typed as P, that’s *not* the protocol, since protocols aren’t concrete entities. What you have there, by definition, is something that conforms to P. Similarly, something like [P] is just a collection of things, perhaps of various types, which all have the common feature that they conform to P.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have an existential value of type P.  It is a well known frustration in Swift that the existential type corresponding to a protocol does not conform to the protocol.  This has been discussed off and on at different times.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt; <br>&gt;&gt; It’s been my understanding that a variable typed P in swift is equivalent to what we would have called id &lt;P&gt; in Objective-C—that is, an object of unknown type that conforms to P. Is this not the case? I am curious what the conceptual difference would be, as well as the rationale behind it.<br>&gt; <br>&gt; Existentials have their own type in Swift.  The problem you are running into is because the generic constraint is looking at the existential type of P and asking if that type conforms to P (which it does not - you can&#39;t write the conformance and the compiler does not provide it for you).  It is not asking if the type of the object underlying the existential value conforms to P (which it necessarily does).  When you have a value of type P you have already erased the type of the underlying object.<br></p><p>I&#39;d say it is the opposite: there is no really erasure per-se but more masking. Depending on the kind of existential, there are 3 possible types of wrappers used by the compiler. If there was real erasure, you’d never be able to do a “let x = ar[0] as? S because the S-ness would be lost. In this situation the existential needs to be opened to perform a checked cast.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/d1f8a1da/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 30, 2016 at 06:00:00am</p></header><div class="content"><p>Great! Thanks!<br></p><p>-Thorsten <br></p><p>&gt; Am 29.05.2016 um 22:29 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; I&#39;ll add it to the &quot;Future Directions&quot; section. I feel that&#39;s the best place to put it, since there&#39;s no guarantee that Swift will get a bottom type, and because making existentials to work with a bottom type would be a completely additive change.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 12:48 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.05.2016 um 18:07 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 7:04 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This makes a lot more sense!  So you want to be able to use uninhabitable types in the contexts of things like collection elements (such collections must always be empty but are inhabitable by a single empty instance).  It is a great example of why it might make sense to allow types like this.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you are really asking for is the ability to drop the restriction that only a single superclass constraint is allowed and no value type constraints are allowed.  It might be useful in cases like your intersection example.  But it could also be a source of error confusing error messages when people form such a type and it doesn&#39;t work the way they expect.  If the type is disallowed as under the current proposal the error message might be more straightforward.  This is a topic that probably deserves further consideration.  But I have to say I find your intersection example to be reasonably compelling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin, what do you think about this example?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I personally don&#39;t feel like the additional complexity is worth it as Swift exists today.<br>&gt;&gt; <br>&gt;&gt; I agree that adding a bottom type would be a different proposal. As an intermediate step we could just make it a type error if an existential would only be satisfied by the bottom type. <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift getting a real bottom type would be a completely different proposal. It would allow you to do things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let universalNil : Bottom? = nil<br>&gt;&gt;&gt; var a : Int? = universalNil<br>&gt;&gt;&gt; var b : UIView? = universalNil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and so on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If Swift does ever get such a type relaxing the restriction from the proposal would be an additive change, and could be proposed separately as a follow up addition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To write this `union` and have it behave in the usual way you need `Any&lt;A, B&gt;` to be a supertype of `A` and of `B`.  The existential doesn’t actually do that so it would not be possible for this union function to guarantee the result would have all of the members of `x` and all the members of `y` the way that a `union` usually would.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The anonymous union type `A | B` *is* a supertype of `A` and a supertype of `B` so you would have no trouble writing this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func union&lt;A, B&gt;(x: Set&lt;A&gt;, y: Set&lt;B&gt;) -&gt; Set&lt;A | B&gt; { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And returning the expected result.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 07:53 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The inimitable Joe Groff provided me with an outline as to how the design could be improved. I&#39;ve taken the liberty of rewriting parts of the proposal to account for his advice.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It turns out the runtime type system is considerably more powerful than I expected. The previous concept in which protocols with associated types&#39; APIs were vended out selectively and using existentials has been discarded.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Instead, all the associated types that belong to an existential are accessible as &#39;anonymous&#39; types within the scope of the existential. These anonymous types are not existentials - they are an anonymous representation of whatever concrete type is satisfying the existential&#39;s value&#39;s underlying type&#39;s associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is an enormous step up in power - for example, an existential can return a value of one of these anonymous associated types from one function and pass it into another function that takes the same type, maintaining perfect type safety but without ever revealing the actual type. There is no need anymore to limit the APIs exposed to the user, although there may still exist APIs that are semantically useless without additional type information.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A set of conversions has also been defined. At compile-time &#39;as&#39; can be used to turn values of these anonymous associated types back into existentials based on the constraints defined earlier. &#39;as?&#39; can also be used for conditional casting of these anonymously-typed values into potential actual types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As always, the link is here, and feedback would be greatly appreciated: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 5:09 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; One initial bit of feedback -  I believe if you have existential types, I believe you can define Sequence Element directly, rather than with a type alias. e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: any&lt;IteratorProtocol where IteratorProtocol.Element==Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: any&lt;Sequence where Sequence.Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; That&#39;s not really the same thing. Any&lt;IteratorProtocol&gt; is an existential, not a protocol. It&#39;s basically an automatically-generated version of our current `AnyIterator&lt;T&gt;` type (though with some additional flexibility). It can&#39;t appear on the right side of a `:`, any more than AnyIterator could.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; After this proposal you should be able to use these existentials anywhere you can place a constraint, so it would work.  You can do this with the protocol composition operator today and the future existential is just an extension of that capability.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; What *would* work is allowing `where` clauses on associated types:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype Iterator: IteratorProtocol where Iterator.Element==Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  associatedtype SubSequence: Sequence where SubSequence.Element == Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I believe this is part of the generics manifesto.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/53b33353/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt; <br>&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>I think that *all* methods should be available - at least in principle - with associated types <br>- replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>- replaced by their lower bounds if in contravariant position<br></p><p>As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/c3084729/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt; - replaced by their lower bounds if in contravariant position<br>&gt; <br>&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt; <br></p><p>Thanks for the feedback! So methods that have associated types in contravariant position would have those types be Nothing, unless there was a concrete type bound to that associated type in the Any&#39;s where clause?<br></p><p>Example<br></p><p>protocol MyProtocol {<br>  associatedtype AssocType1<br>  associatedtype AssocType2<br>  func foo(x: AssocType1, y: AssocType2)<br>}<br></p><p>let a : Any&lt;MyProtocol&gt;<br>// on &#39;a&#39;, foo is exposed as &#39;foo(x: Nothing, y: Nothing)&#39;, and can thus not be called<br></p><p>let b : Any&lt;MyProtocol where .AssocType1 == Int&gt;<br>// on &#39;b&#39;, foo is exposed as &#39;foo(x: Int, y: Nothing)&#39; and still can&#39;t be called<br></p><p>let c : Any&lt;MyProtocol where .AssocType1 == Int, .AssocType2 == String&gt;<br>// on &#39;c&#39;, foo is exposed as &#39;foo(x: Int, y: String)&#39;, and can therefore be called<br></p><p>Let me know if this is what you had in mind.<br></p><p>Austin<br></p><p>&gt; -Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b439ae9a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 11:08 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt; <br>&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for the feedback! So methods that have associated types in contravariant position would have those types be Nothing, unless there was a concrete type bound to that associated type in the Any&#39;s where clause?<br>&gt; <br>&gt; Example<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;   associatedtype AssocType1<br>&gt;   associatedtype AssocType2<br>&gt;   func foo(x: AssocType1, y: AssocType2)<br>&gt; }<br>&gt; <br>&gt; let a : Any&lt;MyProtocol&gt;<br>&gt; // on &#39;a&#39;, foo is exposed as &#39;foo(x: Nothing, y: Nothing)&#39;, and can thus not be called<br>&gt; <br>&gt; let b : Any&lt;MyProtocol where .AssocType1 == Int&gt;<br>&gt; // on &#39;b&#39;, foo is exposed as &#39;foo(x: Int, y: Nothing)&#39; and still can&#39;t be called<br>&gt; <br>&gt; let c : Any&lt;MyProtocol where .AssocType1 == Int, .AssocType2 == String&gt;<br>&gt; // on &#39;c&#39;, foo is exposed as &#39;foo(x: Int, y: String)&#39;, and can therefore be called<br>&gt; <br>&gt; Let me know if this is what you had in mind.<br></p><p>From the standpoint of the interface of the existential these methods are not callable.  That is the most important point and your proposal already covers this.<br></p><p>If contravariance were ever introduced into Swift we would want to include updates to existentials in the process of adding it.<br></p><p><br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/c7f3d361/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 23.05.2016 um 18:08 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt; <br>&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for the feedback! So methods that have associated types in contravariant position would have those types be Nothing, unless there was a concrete type bound to that associated type in the Any&#39;s where clause?<br>&gt; <br>&gt; Example<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;   associatedtype AssocType1<br>&gt;   associatedtype AssocType2<br>&gt;   func foo(x: AssocType1, y: AssocType2)<br>&gt; }<br>&gt; <br>&gt; let a : Any&lt;MyProtocol&gt;<br>&gt; // on &#39;a&#39;, foo is exposed as &#39;foo(x: Nothing, y: Nothing)&#39;, and can thus not be called<br>&gt; <br>&gt; let b : Any&lt;MyProtocol where .AssocType1 == Int&gt;<br>&gt; // on &#39;b&#39;, foo is exposed as &#39;foo(x: Int, y: Nothing)&#39; and still can&#39;t be called<br>&gt; <br>&gt; let c : Any&lt;MyProtocol where .AssocType1 == Int, .AssocType2 == String&gt;<br>&gt; // on &#39;c&#39;, foo is exposed as &#39;foo(x: Int, y: String)&#39;, and can therefore be called<br>&gt; <br>&gt; Let me know if this is what you had in mind.<br></p><p>Yes, that’s what I had in mind. <br></p><p>IMHO this would make for simple rules and if Swift might one day get the ability to specify lower bounds this would easily fit in (I don’t know how useful that would be in reality, but I think Scala allows the declaration of lower bounds).<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/a101e5d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 23, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, this is probably better founded.<br></p><p>Right now Swift doesn&#39;t have a blessed nothing type, the closest you can<br>get is enum Nothing { }, and that type doesn&#39;t participate in subtyping<br>relationships (it&#39;s not really a Bottom type like Scala&#39;s). Proposing such<br>an expansion to the type system is beyond the scope of this proposal,<br>although the &quot;associated types&quot; section should certainly be written such<br>that generalizing it would be trivial if Swift did get contravariant types<br>and a Bottom type.<br></p><p>Austin<br></p><p>On Mon, May 23, 2016 at 11:24 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Am 23.05.2016 um 18:08 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;<br>&gt;<br>&gt; I think that *all* methods should be available - at least in principle -<br>&gt; with associated types<br>&gt; - replaced by their upper bounds (i.e. Any if no constraints have been<br>&gt; given either by the protocol definition itself or th existential) if in<br>&gt; covariant position and<br>&gt; - replaced by their lower bounds if in contravariant position<br>&gt;<br>&gt; As it is not possible to define lower bounds in Swift, the lower bounds<br>&gt; are always the bottom type (called `Nothing` in Swift and not be confused<br>&gt; with optionals). The bottom type has no members and therefore a method<br>&gt; referencing that type cannot be called and is effectively not available.<br>&gt;<br>&gt;<br>&gt; Thanks for the feedback! So methods that have associated types in<br>&gt; contravariant position would have those types be Nothing, unless there was<br>&gt; a concrete type bound to that associated type in the Any&#39;s where clause?<br>&gt;<br>&gt; Example<br>&gt;<br>&gt; protocol MyProtocol {<br>&gt;   associatedtype AssocType1<br>&gt;   associatedtype AssocType2<br>&gt;   func foo(x: AssocType1, y: AssocType2)<br>&gt; }<br>&gt;<br>&gt; let a : Any&lt;MyProtocol&gt;<br>&gt; // on &#39;a&#39;, foo is exposed as &#39;foo(x: Nothing, y: Nothing)&#39;, and can thus<br>&gt; not be called<br>&gt;<br>&gt; let b : Any&lt;MyProtocol where .AssocType1 == Int&gt;<br>&gt; // on &#39;b&#39;, foo is exposed as &#39;foo(x: Int, y: Nothing)&#39; and still can&#39;t be<br>&gt; called<br>&gt;<br>&gt; let c : Any&lt;MyProtocol where .AssocType1 == Int, .AssocType2 == String&gt;<br>&gt; // on &#39;c&#39;, foo is exposed as &#39;foo(x: Int, y: String)&#39;, and can therefore<br>&gt; be called<br>&gt;<br>&gt; Let me know if this is what you had in mind.<br>&gt;<br>&gt;<br>&gt; Yes, that’s what I had in mind.<br>&gt;<br>&gt; IMHO this would make for simple rules and if Swift might one day get the<br>&gt; ability to specify lower bounds this would easily fit in (I don’t know how<br>&gt; useful that would be in reality, but I think Scala allows the declaration<br>&gt; of lower bounds).<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/636a7038/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 10:57 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt;&gt; <br>&gt;&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt; - replaced by their lower bounds if in contravariant position<br>&gt; <br>&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br></p><p>Called `Nothing` in Swift?  Where do you get that?  `func foo(s: Nothing) {}` gives me “use of undeclared type `Nothing`”.  If Swift had a bottom type wouldn’t we be able to declare a function accepting an argument of type `Nothing` (we could just never call it because we couldn’t construct an argument).<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Russ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/03ff5a3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>The fun part about Nothing (⊥) is that it does have one constructor: crashing.<br></p><p>~Robert Widmann<br></p><p>2016/05/23 10:17、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On May 23, 2016, at 10:57 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt; <br>&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt; <br>&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt; <br>&gt; Called `Nothing` in Swift?  Where do you get that?  `func foo(s: Nothing) {}` gives me “use of undeclared type `Nothing`”.  If Swift had a bottom type wouldn’t we be able to declare a function accepting an argument of type `Nothing` (we could just never call it because we couldn’t construct an argument).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change―in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/04c95f54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 23, 2016, at 12:26 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; The fun part about Nothing (⊥) is that it does have one constructor: crashing.<br></p><p>Ok, but where does the part about calling bottom &#39;Nothing&#39; in Swift come from?  This is the first I&#39;ve heard of the name &#39;Nothing&#39; in Swift.<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/05/23 10:17、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 10:57 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt;&gt; <br>&gt;&gt; Called `Nothing` in Swift?  Where do you get that?  `func foo(s: Nothing) {}` gives me “use of undeclared type `Nothing`”.  If Swift had a bottom type wouldn’t we be able to declare a function accepting an argument of type `Nothing` (we could just never call it because we couldn’t construct an argument).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/cf27df28/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 23.05.2016 um 19:17 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 10:57 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt; <br>&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt; <br>&gt; Called `Nothing` in Swift?  Where do you get that?  `func foo(s: Nothing) {}` gives me “use of undeclared type `Nothing`”.  If Swift had a bottom type wouldn’t we be able to declare a function accepting an argument of type `Nothing` (we could just never call it because we couldn’t construct an argument).<br></p><p>oops, sorry, I had wanted to type „called `Nothing` in Scala“ :-)<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/98bc5b43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 23, 2016, at 1:21 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 23.05.2016 um 19:17 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 10:57 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 23.05.2016 um 00:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree; the difference between protocols with and without associated types has been an endless source of confusion for a lot of people.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Speaking of which, for those who care I rewrote the draft proposal to attempt a much more rigorous treatment of the semantics of the generalized existential, including a discussion about existential type equivalence and subtyping. It would be nice to see people poke holes in my logic so I can patch them up. https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that *all* methods should be available - at least in principle - with associated types <br>&gt;&gt;&gt; - replaced by their upper bounds (i.e. Any if no constraints have been given either by the protocol definition itself or th existential) if in covariant position and <br>&gt;&gt;&gt; - replaced by their lower bounds if in contravariant position<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As it is not possible to define lower bounds in Swift, the lower bounds are always the bottom type (called `Nothing` in Swift and not be confused with optionals). The bottom type has no members and therefore a method referencing that type cannot be called and is effectively not available.<br>&gt;&gt; <br>&gt;&gt; Called `Nothing` in Swift?  Where do you get that?  `func foo(s: Nothing) {}` gives me “use of undeclared type `Nothing`”.  If Swift had a bottom type wouldn’t we be able to declare a function accepting an argument of type `Nothing` (we could just never call it because we couldn’t construct an argument).<br>&gt; <br>&gt; oops, sorry, I had wanted to type „called `Nothing` in Scala“ :-)<br></p><p>Lol that makes more sense. :)<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:05 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 17, 2016, at 1:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with this. If we&#39;re certain we should reskin protocol&lt;&gt; as Any&lt;&gt;, we should frontload that change—in addition to affecting source code, it&#39;d also influence the runtime behavior of type printing/parsing, which can&#39;t be statically migrated in the future. I think any discussion of extending existentials has to be considered out of scope for Swift 3, though, so the Any rename deserves its own proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Its really unfortunate that the generics work is probably going to be deferred. When you really dive in to protocol-oriented programming and designing frameworks to be native Swift (taking advantage of Swift features) the existential problem comes up a lot and leads to sub-optimal designs, abandonment of type safety, or gobs of boilerplate.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/01e7ef03/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br>&gt; <br>&gt; Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br>&gt; <br>&gt; See below:<br>&gt; <br>&gt; Proposal<br>&gt; <br>&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br>&gt; <br>&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any’.<br></p><p>Also, Any&lt;SomeProtocol&gt; is equivalent to SomeProtocol.<br></p><p>&gt; <br>&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br></p><p>&gt; <br>&gt; There are five different possible clauses:<br>&gt; <br>&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt; <br>&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br></p><p>&gt; <br>&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br></p><p>Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br></p><p>typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>Any&lt;AnotherProtocol, Foo&gt;<br></p><p>I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br></p><p>typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br></p><p>This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br></p><p>&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt; <br>&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt; <br>&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br></p><p>&gt; <br>&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br></p><p>Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br></p><p>&quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br></p><p>&gt; <br>&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt; <br>&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br></p><p>I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br></p><p>You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br></p><p>&gt; <br>&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt; <br>&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt; <br>&gt; In order of increasing &#39;power&#39;:<br>&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt; Constrain associated types to conform to protocols.<br>&gt; Fully constrain associated types.<br></p><p>I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br></p><p>For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br></p><p>Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br></p><p>One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br></p><p>Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br></p><p>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/2e6a1f51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Responses inline. Thanks for taking the time to read through and comment,<br>your feedback is incredibly useful!<br></p><p>On Tue, May 17, 2016 at 12:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 17, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I put together the skeleton of a proposal detailing enhancements to how<br>&gt; associated types can be referenced in Swift 3+. It&#39;s certainly not ready<br>&gt; for submission, but I think it gets across my ideas pretty well. Would love<br>&gt; to gather feedback and especially improvements.<br>&gt;<br>&gt; Be unsparing; whatever form this feature takes will profoundly affect how<br>&gt; Swift developers program for years, so it needs to be done right.<br>&gt;<br>&gt; See below:<br>&gt;<br>&gt; *Proposal*<br>&gt;<br>&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential<br>&gt; types can be nested.<br>&gt;<br>&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any’.<br>&gt;<br>&gt;<br>&gt; Also, Any&lt;SomeProtocol&gt; is equivalent to SomeProtocol.<br>&gt;<br></p><p>Yes. protocol&lt;&gt; currently also behaves like this.<br></p><p><br>&gt;<br>&gt;<br>&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt; separated by semicolons. (This is so commas can be used in where<br>&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt; can use commas exclusively.)<br>&gt;<br>&gt;<br>&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.<br>&gt; The `where` keyword separates the protocol list from the constraints just<br>&gt; fine.  The list on either side should be able to use commas with no problem<br>&gt; (or line breaks if that proposal goes through).<br>&gt;<br>&gt;<br>I&#39;m leaning towards getting rid of the commas, but would like to write out<br>a few &#39;dummy&#39; examples to see if there are any readability issues that<br>arise.<br></p><p>&gt;<br>&gt; There are five different possible clauses:<br>&gt;<br>&gt;<br>&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a constraint<br>&gt;    on the existential to be any class type. (Implies: Only one can exist.<br>&gt;    Mutually exclusive with class name clause.)<br>&gt;<br>&gt;<br>&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a<br>&gt; counterpart.)<br>&gt;<br>&gt;<br>&gt; If we’re going to allow `struct` we should also allow `enum`.  `value`<br>&gt; would allow either of those.<br>&gt;<br>&gt;<br>Of course. A future proposal can allow list members to discuss the exact<br>details as to how struct, value, or enum specifiers should work.<br></p><p>&gt;<br>&gt;<br>&gt;    - Class name. Must be the first clause, if present. (Implies: Only one<br>&gt;    can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;    class, or one of its subclasses.<br>&gt;<br>&gt; It is still be an existential if it includes protocol requirements that<br>&gt; the class does not fulfill.  For example, you might have Any&lt;UIView,<br>&gt; SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various<br>&gt; subclasses do.<br>&gt;<br>&gt;<br>Fair enough. (I don&#39;t think the way things work would be affected.)<br></p><p><br>&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did<br>&gt; like this:<br>&gt;<br>&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;<br></p><p>I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a<br>type &#39;expression&#39; just like any other, and should be allowed to participate<br>in other Any&lt;...&gt;s.<br></p><p><br>&gt;<br>&gt; I like the idea of composition as it allows us to factor out constraints.<br>&gt; If we are going to do that we should allow a class to be specified in the<br>&gt; composition as long is it is a subclass of all class requirements of Any<br>&gt; types it composes.  For example, this should be allowed:<br>&gt;<br>&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;<br>&gt; This is still one class requirement for Bar, it just refines the class<br>&gt; requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;<br></p><p>This is a good point. There should be clarification as to how special cases<br>of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said<br>Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This<br>will go into any proposal that emerges from the discussion.<br></p><p><br>&gt;<br>&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt; &quot;Any UIViewController or subclass which also satisfies the table view data<br>&gt; source and delegate protocols&quot;<br>&gt;<br>&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;    protocol which has no associated types or Self requirement.<br>&gt;<br>&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt; BooleanType protocols&quot;<br>&gt;<br>&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated<br>&gt; types or self requirements. Feel free to propose a more sound name.<br>&gt;<br>&gt;<br>&gt;    - Self-contained static protocol, simple. This is composed of the name<br>&gt;    of a static protocol, optionally followed by a &#39;where&#39; clause in which the<br>&gt;    associated types can be constrained (with any of the three basic<br>&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;    Associated types are referred to with a leading dot.<br>&gt;<br>&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.<br>&gt; We want to support existentials of protocols that have self or associated<br>&gt; type requirements.  The dynamic vs static distinction is a limitation of<br>&gt; the current implementation of Swift and doesn’t make sense for the long<br>&gt; term vision.<br>&gt;<br></p><p>I&#39;m not trying to introduce new terms, these are just placeholders. At the<br>same time &quot;protocols with self or associated type requirements&quot; is<br>cumbersome to work with and it would be nice for someone to come up with a<br>descriptive term of art for referring to them.<br></p><p><br>&gt;<br>&gt;<br>&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt; .Generator.Element : SomeProtocol&gt;<br>&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt; subclasses conforming to SomeProtocol.”<br>&gt;<br>&gt;<br>&gt; Swift does not allow disjunction of requirements.  Only conjunctions are<br>&gt; supported.  That means the correct reading is:<br>&gt;<br>&gt; &quot;Any type that is a Collection, whose elements are NSObjects *and* their<br>&gt; subclasses conforming to SomeProtocol.”<br>&gt;<br>&gt;<br>Yes, that is what I meant. &quot;whose elements are (NSObjects or their<br>subclasses) conforming to SomeProtocol&quot;.<br></p><p>&gt;<br>&gt;<br>&gt;    - Bound static protocol. This is the same as a self-contained static<br>&gt;    protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>&gt;    generic typealias. The name can be then be used in subsequent clauses to<br>&gt;    build constraints.<br>&gt;<br>&gt;<br>&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt; literal, in which the collection elements are the same type as the type of<br>&gt; the integer used for the integer literal conformance.”<br>&gt;<br>&gt;<br>&gt; I’m not sure about this, but if we’re going to do it it should be the<br>&gt; other way around: `Collection as T` with the alias *after* the name of<br>&gt; the protocol.<br>&gt;<br>&gt;<br>I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int,<br>Protocol.Bar : Baz&quot;.<br></p><p><br>&gt; You are also using “dot shorthand” here to refer to an associated type of<br>&gt; IntegerLiteralConvertible.  I think “dot shorthand” should be limited to<br>&gt; cases where there is only one protocol that is getting constrained.  In<br>&gt; other cases, we need to be clear about which protocol we are referring to.<br>&gt;<br></p><p>I borrowed dot shorthand from the generics manifesto. But you are right, it<br>should only be allowed if there is one protocol with associated types or<br>self requirements clause in the Any&lt;...&gt; construction.<br></p><p><br>&gt;<br>&gt;<br>&gt; There will be rules to prevent recursive nesting. For example, if generic<br>&gt; typealiases are allowed, they cannot refer to each other in a circular<br>&gt; manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a<br>&gt; cyclic graph of enums containing themselves).<br>&gt;<br>&gt; How an existential can be used depends on what guarantees are provided by<br>&gt; the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there<br>&gt; were any methods on Equatable that did not use the associated types at all<br>&gt; you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable<br>&gt; where .Self == String&gt;&#39; would allow for == to be called on instances. (This<br>&gt; is a stupid example, since Any&lt;Equatable where .Self == String&gt; is<br>&gt; equivalent to &#39;String&#39;, but there are almost certainly useful examples one<br>&gt; could come up with.)<br>&gt;<br>&gt; In order of increasing &#39;power&#39;:<br>&gt;<br>&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;    - Constrain associated types to conform to protocols.<br>&gt;    - Fully constrain associated types.<br>&gt;<br>&gt; I think we need to spell out pretty clearly what members we expect to be<br>&gt; available or not available.  This section probably needs the most design<br>&gt; and elaboration.<br>&gt;<br>&gt; For example, we probably can’t access a member who uses an associated type<br>&gt; as an input unless it is constrained to a specific type.  On the other hand<br>&gt; output types probably don’t need to limit access to a member.  However, if<br>&gt; the output type is Self or an associated type the visible signature would<br>&gt; have an output type which has the relevant constraints of the existential<br>&gt; applied, but no more.  In some cases this means the output type would<br>&gt; simply be Any.<br>&gt;<br></p><p>Absolutely. This is vaguely what I had in mind but I wanted to get<br>something down first. Thanks for thinking through some of the implications<br>:).<br></p><p><br>&gt;<br>&gt; Where this really gets tricky is for compound types like functions,<br>&gt; generic types, etc.  Working out the details in these cases is pretty<br>&gt; complex.  I will defer to Doug on whether it is best to just defer those<br>&gt; cases to the future, leave them up to the implementer, or try to work out<br>&gt; all of the relevant details in the proposal (in which case we probably need<br>&gt; a type system expert to help!).<br>&gt;<br></p><p>Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols<br>with associated types or self requirements be used within generic function<br>or type definitions? Maybe there&#39;s an argument that existential types of<br>this nature are redundant if you have access to generics (e.g. defining a<br>property on a generic type that is a Collection containing Ints; you should<br>be able to do that today). On the other hand, maybe there are use cases I<br>haven&#39;t thought of...<br></p><p><br>&gt;<br>&gt; One area you didn’t touch on is “opening” the existential?  Is that out of<br>&gt; scope for this proposal?  That would be fine with me as this proposal is<br>&gt; already taking on a lot.  But if so, you should mention something about<br>&gt; future directions as it is pretty closely related to this proposal.<br>&gt;<br></p><p>Yes, existential opening is explicitly separate from this (although I<br>wanted to mention it in the section where I talk about how Any&lt;Equatable&gt;<br>is not very useful). But you are absolutely right, this proposal should<br>discuss how it wants to interact with possible future directions.<br></p><p><br>&gt;<br>&gt; Another area you didn’t touch on is whether Any constructs (and<br>&gt; typealiases referring to them) should be usable as generic constraints.  I<br>&gt; would expect this to be possible but I think we need to spell it out.<br>&gt;<br></p><p>I&#39;m hoping for community input. This is a tricky subject, and at some point<br>we&#39;ll bump into implementation limitations.<br></p><p><br>&gt;<br>&gt; -Matthew<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/d1412764/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 3:05 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Responses inline. Thanks for taking the time to read through and comment, your feedback is incredibly useful!<br></p><p>No problem!  Glad to help.<br></p><p>&gt; <br>&gt; On Tue, May 17, 2016 at 12:41 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 17, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br>&gt;&gt; <br>&gt;&gt; Be unsparing; whatever form this feature takes will profoundly affect how Swift developers program for years, so it needs to be done right.<br>&gt;&gt; <br>&gt;&gt; See below:<br>&gt;&gt; <br>&gt;&gt; Proposal<br>&gt;&gt; <br>&gt;&gt; An existential type is defined using the &quot;Any&lt;...&gt;&quot; construct. Existential types can be nested.<br>&gt;&gt; <br>&gt;&gt; The empty existential type &quot;Any&lt;&gt;&quot; is typealiased to &#39;Any’.<br>&gt; <br>&gt; Also, Any&lt;SomeProtocol&gt; is equivalent to SomeProtocol.<br>&gt; <br>&gt; Yes. protocol&lt;&gt; currently also behaves like this.<br>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt; <br>&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt; <br>&gt; <br>&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br></p><p>Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br></p><p>&gt;&gt; <br>&gt;&gt; There are five different possible clauses:<br>&gt;&gt; <br>&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt; <br>&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt; <br>&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt; <br>&gt; <br>&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br></p><p>Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br></p><p>&gt;&gt; <br>&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt; <br>&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt; <br>&gt; <br>&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;  <br>&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt; <br>&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt; <br>&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;  <br>&gt; <br>&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt; <br>&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt; <br>&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt; <br>&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br></p><p>Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt; <br>&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt; <br>&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt; <br>&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br></p><p>I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt; <br>&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt; <br>&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt; <br>&gt; <br>&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br></p><p>Ok, good.  Wasn’t quite clear to me.<br></p><p>&gt;&gt; <br>&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt; <br>&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt; <br>&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt; <br>&gt; <br>&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br></p><p>Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br></p><p>&gt;  <br>&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt; <br>&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br></p><p>I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt; <br>&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt; <br>&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt; Fully constrain associated types.<br>&gt; <br>&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt; <br>&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt; <br>&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br></p><p>That’s what I thought.  Just wanted to start the process of elaborating expectations.<br></p><p>&gt;  <br>&gt; <br>&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt; <br>&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br></p><p>I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br></p><p>A simple example of what I was referring to there is something like this:<br></p><p>protocol P {<br>    associatedtype Foo<br></p><p>    func bar(callback: (Foo) -&gt; ())<br>}<br></p><p>In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br></p><p>&gt;  <br>&gt; <br>&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt; <br>&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;  <br>&gt; <br>&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt; <br>&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br></p><p>I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br></p><p>&gt;  <br>&gt; <br>&gt; -Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/3d44c20c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt;&gt; separated by semicolons. (This is so commas can be used in where<br>&gt;&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt;&gt; can use commas exclusively.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.<br>&gt;&gt; The `where` keyword separates the protocol list from the constraints just<br>&gt;&gt; fine.  The list on either side should be able to use commas with no problem<br>&gt;&gt; (or line breaks if that proposal goes through).<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out<br>&gt; a few &#39;dummy&#39; examples to see if there are any readability issues that<br>&gt; arise.<br>&gt;<br>&gt;<br>&gt; Replaced with what?  Whitespace separation?  I suppose that might work for<br>&gt; the protocol list but it feels inconsistent with the rest of Swift.  Commas<br>&gt; plus (hopefully) the alternative of newline seem like the right direction<br>&gt; to me.<br>&gt;<br></p><p>Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the<br>semicolons and use commas. I&#39;ve come to the conclusion that there are no<br>readability issues, protocol&lt;&gt; already uses commas, and semicolons used in<br>this manner don&#39;t have a precedent anywhere else in the language.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt; There are five different possible clauses:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a constraint<br>&gt;&gt;    on the existential to be any class type. (Implies: Only one can exist.<br>&gt;&gt;    Mutually exclusive with class name clause.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as<br>&gt;&gt; a counterpart.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value`<br>&gt;&gt; would allow either of those.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Of course. A future proposal can allow list members to discuss the exact<br>&gt; details as to how struct, value, or enum specifiers should work.<br>&gt;<br>&gt;<br>&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should<br>&gt; not leave obvious holes in what would be considered.  :)<br>&gt;<br></p><p>Absolutely.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;    - Class name. Must be the first clause, if present. (Implies: Only<br>&gt;&gt;    one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;&gt;    class, or one of its subclasses.<br>&gt;&gt;<br>&gt;&gt; It is still be an existential if it includes protocol requirements that<br>&gt;&gt; the class does not fulfill.  For example, you might have Any&lt;UIView,<br>&gt;&gt; SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various<br>&gt;&gt; subclasses do.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;<br>&gt;<br>&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did<br>&gt;&gt; like this:<br>&gt;&gt;<br>&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;<br>&gt;<br>&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is<br>&gt; a type &#39;expression&#39; just like any other, and should be allowed to<br>&gt; participate in other Any&lt;...&gt;s.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I like the idea of composition as it allows us to factor out<br>&gt;&gt; constraints.  If we are going to do that we should allow a class to be<br>&gt;&gt; specified in the composition as long is it is a subclass of all class<br>&gt;&gt; requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;<br>&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;<br>&gt;&gt; This is still one class requirement for Bar, it just refines the class<br>&gt;&gt; requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;<br>&gt;<br>&gt; This is a good point. There should be clarification as to how special<br>&gt; cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you<br>&gt; said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid.<br>&gt; This will go into any proposal that emerges from the discussion.<br>&gt;<br>&gt;<br>&gt; Yes, this is why we need to discuss Any composition.  There are also cases<br>&gt; of incompatible associated type constraints which need to be rejected (such<br>&gt; as composing two Any’s where one has Element == String and another has<br>&gt; Element == Int).<br>&gt;<br></p><p>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view<br>&gt;&gt; data source and delegate protocols&quot;<br>&gt;&gt;<br>&gt;&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;&gt;    protocol which has no associated types or Self requirement.<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt;&gt; BooleanType protocols&quot;<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated<br>&gt;&gt; types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Self-contained static protocol, simple. This is composed of the<br>&gt;&gt;    name of a static protocol, optionally followed by a &#39;where&#39; clause in which<br>&gt;&gt;    the associated types can be constrained (with any of the three basic<br>&gt;&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;&gt;    Associated types are referred to with a leading dot.<br>&gt;&gt;<br>&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.<br>&gt;&gt; We want to support existentials of protocols that have self or associated<br>&gt;&gt; type requirements.  The dynamic vs static distinction is a limitation of<br>&gt;&gt; the current implementation of Swift and doesn’t make sense for the long<br>&gt;&gt; term vision.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the<br>&gt; same time &quot;protocols with self or associated type requirements&quot; is<br>&gt; cumbersome to work with and it would be nice for someone to come up with a<br>&gt; descriptive term of art for referring to them.<br>&gt;<br>&gt;<br>&gt; I agree that a better term would be useful.  In the meantime, I would<br>&gt; prefer something like “trivial” and “nontrivial” protocols.<br>&gt;<br></p><p>I&#39;ve decided to just use the full name until the community comes up with<br>better names. Clarity is preferable to brevity in this case.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt;&gt; .Generator.Element : SomeProtocol&gt;<br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are<br>&gt;&gt; supported.  That means the correct reading is:<br>&gt;&gt;<br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects *and* their<br>&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their<br>&gt; subclasses) conforming to SomeProtocol”.<br>&gt;<br>&gt;<br>&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;<br></p><p>Yes, the verbiage will need to be clearer in the future. That sentence<br>could be ambiguously parsed.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;    - Bound static protocol. This is the same as a self-contained static<br>&gt;&gt;    protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>&gt;&gt;    generic typealias. The name can be then be used in subsequent clauses to<br>&gt;&gt;    build constraints.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt;&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt;&gt; literal, in which the collection elements are the same type as the type of<br>&gt;&gt; the integer used for the integer literal conformance.”<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the<br>&gt;&gt; other way around: `Collection as T` with the alias *after* the name of<br>&gt;&gt; the protocol.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int,<br>&gt; Protocol.Bar : Baz”.<br>&gt;<br>&gt;<br>&gt; Why did you introduce an alias here and then not use it?  Did you mean<br>&gt; &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;<br></p><p>Another result of rushing to compose an email. Sorry!<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of<br>&gt;&gt; IntegerLiteralConvertible.  I think “dot shorthand” should be limited to<br>&gt;&gt; cases where there is only one protocol that is getting constrained.  In<br>&gt;&gt; other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;<br>&gt;<br>&gt; I borrowed dot shorthand from the generics manifesto. But you are right,<br>&gt; it should only be allowed if there is one protocol with associated types or<br>&gt; self requirements clause in the Any&lt;...&gt; construction.<br>&gt;<br>&gt;<br>&gt; I would actually go further and limit it to one protocol period, and<br>&gt; possibly even to one protocol and no type names (as types can have nested<br>&gt; types and typealiases).  When we allow shorthand it should be immediately<br>&gt; unambiguous what the shorthand references with no need to look at type or<br>&gt; protocol declarations.<br>&gt;<br></p><p>It might be desirable to propose the proposal with no allowance for<br>shorthand, and have the dot shorthand be a smaller follow-up proposal.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic<br>&gt;&gt; typealiases are allowed, they cannot refer to each other in a circular<br>&gt;&gt; manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a<br>&gt;&gt; cyclic graph of enums containing themselves).<br>&gt;&gt;<br>&gt;&gt; How an existential can be used depends on what guarantees are provided by<br>&gt;&gt; the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there<br>&gt;&gt; were any methods on Equatable that did not use the associated types at all<br>&gt;&gt; you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable<br>&gt;&gt; where .Self == String&gt;&#39; would allow for == to be called on instances. (This<br>&gt;&gt; is a stupid example, since Any&lt;Equatable where .Self == String&gt; is<br>&gt;&gt; equivalent to &#39;String&#39;, but there are almost certainly useful examples one<br>&gt;&gt; could come up with.)<br>&gt;&gt;<br>&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;<br>&gt;&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;    - Constrain associated types to conform to protocols.<br>&gt;&gt;    - Fully constrain associated types.<br>&gt;&gt;<br>&gt;&gt; I think we need to spell out pretty clearly what members we expect to be<br>&gt;&gt; available or not available.  This section probably needs the most design<br>&gt;&gt; and elaboration.<br>&gt;&gt;<br>&gt;&gt; For example, we probably can’t access a member who uses an associated<br>&gt;&gt; type as an input unless it is constrained to a specific type.  On the other<br>&gt;&gt; hand output types probably don’t need to limit access to a member.<br>&gt;&gt; However, if the output type is Self or an associated type the visible<br>&gt;&gt; signature would have an output type which has the relevant constraints of<br>&gt;&gt; the existential applied, but no more.  In some cases this means the output<br>&gt;&gt; type would simply be Any.<br>&gt;&gt;<br>&gt;<br>&gt; Absolutely. This is vaguely what I had in mind but I wanted to get<br>&gt; something down first. Thanks for thinking through some of the implications<br>&gt; :).<br>&gt;<br>&gt;<br>&gt; That’s what I thought.  Just wanted to start the process of elaborating<br>&gt; expectations.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Where this really gets tricky is for compound types like functions,<br>&gt;&gt; generic types, etc.  Working out the details in these cases is pretty<br>&gt;&gt; complex.  I will defer to Doug on whether it is best to just defer those<br>&gt;&gt; cases to the future, leave them up to the implementer, or try to work out<br>&gt;&gt; all of the relevant details in the proposal (in which case we probably need<br>&gt;&gt; a type system expert to help!).<br>&gt;&gt;<br>&gt;<br>&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols<br>&gt; with associated types or self requirements be used within generic function<br>&gt; or type definitions? Maybe there&#39;s an argument that existential types of<br>&gt; this nature are redundant if you have access to generics (e.g. defining a<br>&gt; property on a generic type that is a Collection containing Ints; you should<br>&gt; be able to do that today). On the other hand, maybe there are use cases I<br>&gt; haven&#39;t thought of…<br>&gt;<br>&gt;<br>&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For<br>&gt; example, you may want to store instances in a heterogeneous collection.<br>&gt; You need existentials to do that.<br>&gt;<br>&gt; A simple example of what I was referring to there is something like this:<br>&gt;<br>&gt; protocol P {<br>&gt;     associatedtype Foo<br>&gt;<br>&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt; }<br>&gt;<br>&gt; In other words, types in the signature of a protocol member are complex<br>&gt; types that reference Self or associated types.  I think you really need a<br>&gt; formal understanding of the type system to understand how to expose these<br>&gt; members through a constrained existential.  We can probably understand the<br>&gt; expected behavior in some of the simpler cases on a case by case basis, but<br>&gt; that approach doesn’t scale at all and is arbitrary.  If they’re going to<br>&gt; be supported an expert is going to need to be involved in the design.<br>&gt;<br></p><p>Yes. I have some ideas regarding this topic.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out<br>&gt;&gt; of scope for this proposal?  That would be fine with me as this proposal is<br>&gt;&gt; already taking on a lot.  But if so, you should mention something about<br>&gt;&gt; future directions as it is pretty closely related to this proposal.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, existential opening is explicitly separate from this (although I<br>&gt; wanted to mention it in the section where I talk about how Any&lt;Equatable&gt;<br>&gt; is not very useful). But you are absolutely right, this proposal should<br>&gt; discuss how it wants to interact with possible future directions.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Another area you didn’t touch on is whether Any constructs (and<br>&gt;&gt; typealiases referring to them) should be usable as generic constraints.  I<br>&gt;&gt; would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m hoping for community input. This is a tricky subject, and at some<br>&gt; point we&#39;ll bump into implementation limitations.<br>&gt;<br>&gt;<br>&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the<br>&gt; Any into the list of generic constraints.  Maybe I’m missing something, but<br>&gt; I don’t think so.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/6c4a9813/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;ve put together a considerably more detailed draft proposal, taking into<br>account as much of Matthew&#39;s feedback as I could. You can find it below:<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>Since there is no chance this will come up for review anytime soon, I<br>expect to make significant revisions to it over the next month or so. Any<br>feedback would be greatly appreciated.<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt;&gt;&gt; separated by semicolons. (This is so commas can be used in where<br>&gt;&gt;&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt;&gt;&gt; can use commas exclusively.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.<br>&gt;&gt;&gt; The `where` keyword separates the protocol list from the constraints just<br>&gt;&gt;&gt; fine.  The list on either side should be able to use commas with no problem<br>&gt;&gt;&gt; (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write<br>&gt;&gt; out a few &#39;dummy&#39; examples to see if there are any readability issues that<br>&gt;&gt; arise.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work<br>&gt;&gt; for the protocol list but it feels inconsistent with the rest of Swift.<br>&gt;&gt; Commas plus (hopefully) the alternative of newline seem like the right<br>&gt;&gt; direction to me.<br>&gt;&gt;<br>&gt;<br>&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the<br>&gt; semicolons and use commas. I&#39;ve come to the conclusion that there are no<br>&gt; readability issues, protocol&lt;&gt; already uses commas, and semicolons used in<br>&gt; this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a constraint<br>&gt;&gt;&gt;    on the existential to be any class type. (Implies: Only one can exist.<br>&gt;&gt;&gt;    Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as<br>&gt;&gt;&gt; a counterpart.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value`<br>&gt;&gt;&gt; would allow either of those.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Of course. A future proposal can allow list members to discuss the exact<br>&gt;&gt; details as to how struct, value, or enum specifiers should work.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we<br>&gt;&gt; should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;<br>&gt;<br>&gt; Absolutely.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Class name. Must be the first clause, if present. (Implies: Only<br>&gt;&gt;&gt;    one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;&gt;&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;&gt;&gt;    class, or one of its subclasses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that<br>&gt;&gt;&gt; the class does not fulfill.  For example, you might have Any&lt;UIView,<br>&gt;&gt;&gt; SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various<br>&gt;&gt;&gt; subclasses do.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did<br>&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is<br>&gt;&gt; a type &#39;expression&#39; just like any other, and should be allowed to<br>&gt;&gt; participate in other Any&lt;...&gt;s.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like the idea of composition as it allows us to factor out<br>&gt;&gt;&gt; constraints.  If we are going to do that we should allow a class to be<br>&gt;&gt;&gt; specified in the composition as long is it is a subclass of all class<br>&gt;&gt;&gt; requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class<br>&gt;&gt;&gt; requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a good point. There should be clarification as to how special<br>&gt;&gt; cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you<br>&gt;&gt; said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid.<br>&gt;&gt; This will go into any proposal that emerges from the discussion.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also<br>&gt;&gt; cases of incompatible associated type constraints which need to be rejected<br>&gt;&gt; (such as composing two Any’s where one has Element == String and another<br>&gt;&gt; has Element == Int).<br>&gt;&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource;<br>&gt;&gt;&gt; UITableViewDelegate&gt;<br>&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view<br>&gt;&gt;&gt; data source and delegate protocols&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;&gt;&gt;    protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt;&gt;&gt; BooleanType protocols&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with<br>&gt;&gt;&gt; associated types or self requirements. Feel free to propose a more sound<br>&gt;&gt;&gt; name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Self-contained static protocol, simple. This is composed of the<br>&gt;&gt;&gt;    name of a static protocol, optionally followed by a &#39;where&#39; clause in which<br>&gt;&gt;&gt;    the associated types can be constrained (with any of the three basic<br>&gt;&gt;&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;&gt;&gt;    Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.<br>&gt;&gt;&gt; We want to support existentials of protocols that have self or associated<br>&gt;&gt;&gt; type requirements.  The dynamic vs static distinction is a limitation of<br>&gt;&gt;&gt; the current implementation of Swift and doesn’t make sense for the long<br>&gt;&gt;&gt; term vision.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At<br>&gt;&gt; the same time &quot;protocols with self or associated type requirements&quot; is<br>&gt;&gt; cumbersome to work with and it would be nice for someone to come up with a<br>&gt;&gt; descriptive term of art for referring to them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree that a better term would be useful.  In the meantime, I would<br>&gt;&gt; prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;ve decided to just use the full name until the community comes up with<br>&gt; better names. Clarity is preferable to brevity in this case.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt;&gt;&gt; .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are<br>&gt;&gt;&gt; supported.  That means the correct reading is:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects *and* their<br>&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their<br>&gt;&gt; subclasses) conforming to SomeProtocol”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, the verbiage will need to be clearer in the future. That sentence<br>&gt; could be ambiguously parsed.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Bound static protocol. This is the same as a self-contained static<br>&gt;&gt;&gt;    protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a<br>&gt;&gt;&gt;    generic typealias. The name can be then be used in subsequent clauses to<br>&gt;&gt;&gt;    build constraints.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt;&gt;&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt;&gt;&gt; literal, in which the collection elements are the same type as the type of<br>&gt;&gt;&gt; the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the<br>&gt;&gt;&gt; other way around: `Collection as T` with the alias *after* the name of<br>&gt;&gt;&gt; the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int,<br>&gt;&gt; Protocol.Bar : Baz”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean<br>&gt;&gt; &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;<br>&gt;<br>&gt; Another result of rushing to compose an email. Sorry!<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type<br>&gt;&gt;&gt; of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to<br>&gt;&gt;&gt; cases where there is only one protocol that is getting constrained.  In<br>&gt;&gt;&gt; other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right,<br>&gt;&gt; it should only be allowed if there is one protocol with associated types or<br>&gt;&gt; self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I would actually go further and limit it to one protocol period, and<br>&gt;&gt; possibly even to one protocol and no type names (as types can have nested<br>&gt;&gt; types and typealiases).  When we allow shorthand it should be immediately<br>&gt;&gt; unambiguous what the shorthand references with no need to look at type or<br>&gt;&gt; protocol declarations.<br>&gt;&gt;<br>&gt;<br>&gt; It might be desirable to propose the proposal with no allowance for<br>&gt; shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if<br>&gt;&gt;&gt; generic typealiases are allowed, they cannot refer to each other in a<br>&gt;&gt;&gt; circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t<br>&gt;&gt;&gt; create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided<br>&gt;&gt;&gt; by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if<br>&gt;&gt;&gt; there were any methods on Equatable that did not use the associated types<br>&gt;&gt;&gt; at all you&#39;d be able to call them, but that&#39;s about it. However,<br>&gt;&gt;&gt; &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on<br>&gt;&gt;&gt; instances. (This is a stupid example, since Any&lt;Equatable where .Self ==<br>&gt;&gt;&gt; String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful<br>&gt;&gt;&gt; examples one could come up with.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;&gt;&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;    - Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;    - Fully constrain associated types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be<br>&gt;&gt;&gt; available or not available.  This section probably needs the most design<br>&gt;&gt;&gt; and elaboration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated<br>&gt;&gt;&gt; type as an input unless it is constrained to a specific type.  On the other<br>&gt;&gt;&gt; hand output types probably don’t need to limit access to a member.<br>&gt;&gt;&gt; However, if the output type is Self or an associated type the visible<br>&gt;&gt;&gt; signature would have an output type which has the relevant constraints of<br>&gt;&gt;&gt; the existential applied, but no more.  In some cases this means the output<br>&gt;&gt;&gt; type would simply be Any.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get<br>&gt;&gt; something down first. Thanks for thinking through some of the implications<br>&gt;&gt; :).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating<br>&gt;&gt; expectations.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Where this really gets tricky is for compound types like functions,<br>&gt;&gt;&gt; generic types, etc.  Working out the details in these cases is pretty<br>&gt;&gt;&gt; complex.  I will defer to Doug on whether it is best to just defer those<br>&gt;&gt;&gt; cases to the future, leave them up to the implementer, or try to work out<br>&gt;&gt;&gt; all of the relevant details in the proposal (in which case we probably need<br>&gt;&gt;&gt; a type system expert to help!).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols<br>&gt;&gt; with associated types or self requirements be used within generic function<br>&gt;&gt; or type definitions? Maybe there&#39;s an argument that existential types of<br>&gt;&gt; this nature are redundant if you have access to generics (e.g. defining a<br>&gt;&gt; property on a generic type that is a Collection containing Ints; you should<br>&gt;&gt; be able to do that today). On the other hand, maybe there are use cases I<br>&gt;&gt; haven&#39;t thought of…<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For<br>&gt;&gt; example, you may want to store instances in a heterogeneous collection.<br>&gt;&gt; You need existentials to do that.<br>&gt;&gt;<br>&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt;<br>&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In other words, types in the signature of a protocol member are complex<br>&gt;&gt; types that reference Self or associated types.  I think you really need a<br>&gt;&gt; formal understanding of the type system to understand how to expose these<br>&gt;&gt; members through a constrained existential.  We can probably understand the<br>&gt;&gt; expected behavior in some of the simpler cases on a case by case basis, but<br>&gt;&gt; that approach doesn’t scale at all and is arbitrary.  If they’re going to<br>&gt;&gt; be supported an expert is going to need to be involved in the design.<br>&gt;&gt;<br>&gt;<br>&gt; Yes. I have some ideas regarding this topic.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out<br>&gt;&gt;&gt; of scope for this proposal?  That would be fine with me as this proposal is<br>&gt;&gt;&gt; already taking on a lot.  But if so, you should mention something about<br>&gt;&gt;&gt; future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, existential opening is explicitly separate from this (although I<br>&gt;&gt; wanted to mention it in the section where I talk about how Any&lt;Equatable&gt;<br>&gt;&gt; is not very useful). But you are absolutely right, this proposal should<br>&gt;&gt; discuss how it wants to interact with possible future directions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and<br>&gt;&gt;&gt; typealiases referring to them) should be usable as generic constraints.  I<br>&gt;&gt;&gt; would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some<br>&gt;&gt; point we&#39;ll bump into implementation limitations.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of<br>&gt;&gt; the Any into the list of generic constraints.  Maybe I’m missing something,<br>&gt;&gt; but I don’t think so.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/22d4cfd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 09:00:00am</p></header><div class="content"><p>I kinda feel my proposal was a little waste of time now. Or am I wrong here? ^^<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 09:35:56, Austin Zheng via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p><br>On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br> <br></p><p><br>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br></p><p><br>I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br></p><p>Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br></p><p>Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br> <br></p><p><br>There are five different possible clauses:<br></p><p>&#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br></p><p>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br></p><p><br>Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br></p><p>Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br></p><p>Absolutely.<br> <br></p><p><br>Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br></p><p><br>Fair enough. (I don&#39;t think the way things work would be affected.)<br> <br>Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br></p><p>typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>Any&lt;AnotherProtocol, Foo&gt;<br></p><p>I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br> <br></p><p>I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br></p><p>typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br></p><p>This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br></p><p>This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br></p><p>Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br></p><p> <br></p><p>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br></p><p>Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br></p><p>I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br></p><p>I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br></p><p>I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br> <br></p><p> <br></p><p><br>Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br></p><p>Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br></p><p>&quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br></p><p><br>Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br></p><p>Ok, good.  Wasn’t quite clear to me.<br></p><p>Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br> <br></p><p><br>Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br></p><p>Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br></p><p>I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br></p><p><br>I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br></p><p>Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br></p><p>Another result of rushing to compose an email. Sorry!<br> <br></p><p> <br>You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br></p><p>I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br></p><p>I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br></p><p>It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br> <br></p><p> <br></p><p><br>There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br>Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>Constrain associated types to conform to protocols.<br>Fully constrain associated types.<br>I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br></p><p>For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br></p><p>Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br></p><p>That’s what I thought.  Just wanted to start the process of elaborating expectations.<br></p><p> <br></p><p>Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br></p><p>Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br></p><p>I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br></p><p>A simple example of what I was referring to there is something like this:<br></p><p>protocol P {<br>    associatedtype Foo<br></p><p>    func bar(callback: (Foo) -&gt; ())<br>}<br></p><p>In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br></p><p>Yes. I have some ideas regarding this topic.<br> <br></p><p> <br></p><p>One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br></p><p>Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br> <br></p><p>Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br></p><p>I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br></p><p>I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br></p><p> <br></p><p>-Matthew<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/a9fc179d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 12:00:00am</p></header><div class="content"><p>You&#39;re still welcome to submit your proposal for review, or to ask people to debate the merits of the two proposals, or to argue that your proposal is better. Having diverse opinions interact can only make Swift a better language :).<br></p><p>Austin<br></p><p>&gt; On May 18, 2016, at 12:49 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I kinda feel my proposal was a little waste of time now. Or am I wrong here? ^^<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 18. Mai 2016 bei 09:35:56, Austin Zheng via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt; <br>&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt; <br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt; <br>&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt; <br>&gt;&gt; Absolutely.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt; <br>&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt; <br>&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt; <br>&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt; <br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt; <br>&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt; <br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt; <br>&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt; <br>&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt; <br>&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt; <br>&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt; <br>&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; <br>&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt; <br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt; <br>&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/bc28d287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>I added a note to my proposal which makes it clear that the `Any&lt;&gt;` I proposed represents the simple/base form that Swift 3 should integrate, if accepted. Later `Any&lt;&gt;` could be enhanced without any breaking changes.<br></p><p>I’m not sure if your and my nesting rules do fit together, we might reconsider mine before the pull request is accepted.<br></p><p>- Also I don’t see the point why `Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;` this is illegal!?<br></p><p>	`Any&lt;&gt;` proposed by me will allow that, even it its useless form the point of the readers view. This type is inferred to `Any&lt;ProtocolA, ProtocolB&gt;`.<br></p><p>Why do you not allow value types in your proposal?<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/22002793/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 08:00:00am</p></header><div class="content"><p>You should definitely submit your proposal first. I&#39;ll review your nesting<br>rules later. f your proposal is accepted I will edit mine to match.<br></p><p>Allowing value types belong in a separate proposal; I think this is<br>something people would want to discuss on their own merits. For example,<br>the `class` keyword already exists, and can be used in several places to<br>force something to be a class. People would want similar value type<br>keywords to also work everywhere `class` does, not only in a composite type<br>declaration.<br></p><p>Austin<br></p><p>On Wed, May 18, 2016 at 6:49 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I added a note to my proposal which makes it clear that the `Any&lt;&gt;` I<br>&gt; proposed represents the simple/base form that Swift 3 should integrate, if<br>&gt; accepted. Later `Any&lt;&gt;` could be enhanced without any breaking changes.<br>&gt;<br>&gt; I’m not sure if your and my nesting rules do fit together, we might<br>&gt; reconsider mine before the pull request is accepted.<br>&gt;<br>&gt; - Also I don’t see the point why `Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;` this is<br>&gt; illegal!?<br>&gt;<br>&gt; `Any&lt;&gt;` proposed by me will allow that, even it its useless form the point<br>&gt; of the readers view. This type is inferred to `Any&lt;ProtocolA, ProtocolB&gt;`.<br>&gt;<br>&gt; Why do you not allow value types in your proposal?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/81f79217/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 18, 2016, at 10:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You should definitely submit your proposal first. I&#39;ll review your nesting rules later. f your proposal is accepted I will edit mine to match.<br>&gt; <br>&gt; Allowing value types belong in a separate proposal; I think this is something people would want to discuss on their own merits. For example, the `class` keyword already exists, and can be used in several places to force something to be a class. People would want similar value type keywords to also work everywhere `class` does, not only in a composite type declaration.<br></p><p>I agree about value types.  I&#39;m not sure what benefit that provides.  What we really need here is the ability to constrain value semantics.  Simply constraining to a value type does not do that (a struct can have a class property and use it in a way that violates value semantics).  Dave A and I have had a pretty lengthy discussion of desirable se,antic guarantees recently.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Wed, May 18, 2016 at 6:49 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I added a note to my proposal which makes it clear that the `Any&lt;&gt;` I proposed represents the simple/base form that Swift 3 should integrate, if accepted. Later `Any&lt;&gt;` could be enhanced without any breaking changes.<br>&gt;&gt; <br>&gt;&gt; I’m not sure if your and my nesting rules do fit together, we might reconsider mine before the pull request is accepted.<br>&gt;&gt; <br>&gt;&gt; - Also I don’t see the point why `Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;` this is illegal!?<br>&gt;&gt; <br>&gt;&gt; 	`Any&lt;&gt;` proposed by me will allow that, even it its useless form the point of the readers view. This type is inferred to `Any&lt;ProtocolA, ProtocolB&gt;`.<br>&gt;&gt; <br>&gt;&gt; Why do you not allow value types in your proposal?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/af68fe03/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt; <br>&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br></p><p>Thank you for working on this!  Great progress.<br></p><p>Minor nit, but I think the proper word is constraint rather than requirement here:<br></p><p>&quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br></p><p>Another tweak: <br></p><p>&quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br></p><p>This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br></p><p>Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br></p><p>Another item:<br>// NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br></p><p>On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br></p><p>On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br></p><p>The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br></p><p>The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br></p><p>In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt; <br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt; <br>&gt;&gt; Absolutely.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt; <br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt; <br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt; <br>&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt; <br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/d954fd99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 09:00:00am</p></header><div class="content"><p>I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;).<br></p><p>Here are a couple of thoughts:<br></p><p>- I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br></p><p>- Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br></p><p>- The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br></p><p>- I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br></p><p>- I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br></p><p>- I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br></p><p>- I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br></p><p>Austin<br></p><p>&gt; On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt; <br>&gt; Thank you for working on this!  Great progress.<br>&gt; <br>&gt; Minor nit, but I think the proper word is constraint rather than requirement here:<br>&gt; <br>&gt; &quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br>&gt; <br>&gt; Another tweak: <br>&gt; <br>&gt; &quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br>&gt; <br>&gt; This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br>&gt; <br>&gt; Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br>&gt; <br>&gt; Another item:<br>&gt; // NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt; <br>&gt; Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br>&gt; <br>&gt; On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br>&gt; <br>&gt; On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br>&gt; <br>&gt; The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br>&gt; <br>&gt; The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br>&gt; <br>&gt; In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt; <br>&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt; <br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt; <br>&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt; <br>&gt;&gt; Absolutely.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt; <br>&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt; <br>&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt; <br>&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt; <br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt; <br>&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt; <br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt; <br>&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt; <br>&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt; <br>&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt; <br>&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt; <br>&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; <br>&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt; <br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt; <br>&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/8d2e6663/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Okay now I feel like we’re merging everything we came up until now :D I’d love to see something like this happen to Swift, because `Any` seems to be a really powerful beast one day.<br></p><p>One quick question: Do we really need this &quot;This must be the first requirement, if present.“?<br></p><p>I’d say the compiler should reorder all types as it wants to. Current protocol&lt;&gt; already doing this today.<br></p><p>e.g.<br></p><p>protocol A {}<br>protocol B {}<br></p><p>typealias C = protocol&lt;A, B&gt;<br>typealias D = protocol&lt;B, A&gt;<br></p><p>print(C) // prints protocol&lt;A, B&gt;<br>print(D) // prints protocol&lt;A, B&gt;<br>print(C.self == D.self) // prints true<br></p><p>Basically what I mean<br></p><p>Any&lt;SomeProtocol, class, AnotherProtocol&gt;<br></p><p>Any&lt;Any&lt;ProtocolA, ProtocolB&gt;, UIView&gt;<br></p><p>should be valid.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 18:30:02, Austin Zheng via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md).<br></p><p>Here are a couple of thoughts:<br></p><p>- I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br></p><p>- Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br></p><p>- The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br></p><p>- I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br></p><p>- I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br></p><p>- I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br></p><p>- I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br></p><p>Austin<br></p><p>On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p><br></p><p>Sent from my iPad<br></p><p>On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br></p><p>Thank you for working on this!  Great progress.<br></p><p>Minor nit, but I think the proper word is constraint rather than requirement here:<br></p><p>&quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br></p><p>Another tweak: <br></p><p>&quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br></p><p>This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br></p><p>Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br></p><p>Another item:<br>// NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br></p><p>On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br></p><p>On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br></p><p>The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br></p><p>The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br></p><p>In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br></p><p><br>Austin<br></p><p>On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p><br>On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br> <br></p><p><br>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br></p><p><br>I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br></p><p>Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br></p><p>Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br> <br></p><p><br>There are five different possible clauses:<br></p><p>&#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br></p><p>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br></p><p><br>Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br></p><p>Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br></p><p>Absolutely.<br> <br></p><p><br>Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br></p><p><br>Fair enough. (I don&#39;t think the way things work would be affected.)<br> <br>Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br></p><p>typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>Any&lt;AnotherProtocol, Foo&gt;<br></p><p>I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br> <br></p><p>I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br></p><p>typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br></p><p>This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br></p><p>This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br></p><p>Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br></p><p> <br></p><p>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br></p><p>Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br></p><p>I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br></p><p>I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br></p><p>I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br> <br></p><p> <br></p><p><br>Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br></p><p>Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br></p><p>&quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br></p><p><br>Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br></p><p>Ok, good.  Wasn’t quite clear to me.<br></p><p>Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br> <br></p><p><br>Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br></p><p>Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br></p><p>I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br></p><p><br>I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br></p><p>Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br></p><p>Another result of rushing to compose an email. Sorry!<br> <br></p><p> <br>You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br></p><p>I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br></p><p>I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br></p><p>It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br> <br></p><p> <br></p><p><br>There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br>Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>Constrain associated types to conform to protocols.<br>Fully constrain associated types.<br>I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br></p><p>For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br></p><p>Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br></p><p>That’s what I thought.  Just wanted to start the process of elaborating expectations.<br></p><p> <br></p><p>Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br></p><p>Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br></p><p>I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br></p><p>A simple example of what I was referring to there is something like this:<br></p><p>protocol P {<br>    associatedtype Foo<br></p><p>    func bar(callback: (Foo) -&gt; ())<br>}<br></p><p>In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br></p><p>Yes. I have some ideas regarding this topic.<br> <br></p><p> <br></p><p>One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br></p><p>Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br> <br></p><p>Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br></p><p>I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br></p><p>I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br></p><p> <br></p><p>-Matthew<br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/455794a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 12:12 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Okay now I feel like we’re merging everything we came up until now :D I’d love to see something like this happen to Swift, because `Any` seems to be a really powerful beast one day.<br>&gt; <br>&gt; One quick question: Do we really need this &quot;This must be the first requirement, if present.“?<br></p><p>I’m on the fence about this.  The reason it would matter is for readability.  The counter argument to that is that you can’t rely on the first argument being a class to determine whether a composed Any will have a class constraint or not.<br></p><p>&gt; <br>&gt; I’d say the compiler should reorder all types as it wants to. Current protocol&lt;&gt; already doing this today.<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; protocol A {}<br>&gt; protocol B {}<br>&gt; <br>&gt; typealias C = protocol&lt;A, B&gt;<br>&gt; typealias D = protocol&lt;B, A&gt;<br>&gt; <br>&gt; print(C) // prints protocol&lt;A, B&gt;<br>&gt; print(D) // prints protocol&lt;A, B&gt;<br>&gt; print(C.self == D.self) // prints true<br>&gt; <br>&gt; Basically what I mean<br>&gt; <br>&gt; Any&lt;SomeProtocol, class, AnotherProtocol&gt;<br>&gt; <br>&gt; Any&lt;Any&lt;ProtocolA, ProtocolB&gt;, UIView&gt;<br>&gt; <br>&gt; should be valid.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 18. Mai 2016 bei 18:30:02, Austin Zheng via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;).<br>&gt;&gt; <br>&gt;&gt; Here are a couple of thoughts:<br>&gt;&gt; <br>&gt;&gt; - I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br>&gt;&gt; <br>&gt;&gt; - Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br>&gt;&gt; <br>&gt;&gt; - The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br>&gt;&gt; <br>&gt;&gt; - I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br>&gt;&gt; <br>&gt;&gt; - I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br>&gt;&gt; <br>&gt;&gt; - I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br>&gt;&gt; <br>&gt;&gt; - I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for working on this!  Great progress.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Minor nit, but I think the proper word is constraint rather than requirement here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another tweak: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another item:<br>&gt;&gt;&gt; // NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/204b93f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 12:00:00pm</p></header><div class="content"><p>I strongly prefer keeping the class requirement first, both for readability<br>and because this reflects how protocol and &#39;class&#39; or superclass<br>conformances already work when defining classes or protocols. I think &quot;look<br>at the first argument, and then recursively look at the first arguments of<br>any nested Any&#39;s for class requirements&quot; is straightforward enough not to<br>confuse people, and helps keep the type definitions organized.<br></p><p>Austin<br></p><p>On Wed, May 18, 2016 at 12:11 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On May 18, 2016, at 12:12 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Okay now I feel like we’re merging everything we came up until now :D I’d<br>&gt; love to see something like this happen to Swift, because `Any` seems to be<br>&gt; a really powerful beast one day.<br>&gt;<br>&gt; One quick question: Do we really need this &quot;This must be the first<br>&gt; requirement, if present.“?<br>&gt;<br>&gt;<br>&gt; I’m on the fence about this.  The reason it would matter is for<br>&gt; readability.  The counter argument to that is that you can’t rely on the<br>&gt; first argument being a class to determine whether a composed Any will have<br>&gt; a class constraint or not.<br>&gt;<br>&gt;<br>&gt; I’d say the compiler should reorder all types as it wants to. Current<br>&gt; protocol&lt;&gt; already doing this today.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; protocol A {}<br>&gt; protocol B {}<br>&gt;<br>&gt; typealias C = protocol&lt;A, B&gt;<br>&gt; typealias D = protocol&lt;B, A&gt;<br>&gt;<br>&gt; print(C) // prints protocol&lt;A, B&gt;<br>&gt; print(D) // prints protocol&lt;A, B&gt;<br>&gt; print(C.self == D.self) // prints true<br>&gt;<br>&gt; Basically what I mean<br>&gt;<br>&gt; Any&lt;SomeProtocol, class, AnotherProtocol&gt;<br>&gt;<br>&gt; Any&lt;Any&lt;ProtocolA, ProtocolB&gt;, UIView&gt;<br>&gt;<br>&gt; should be valid.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 18. Mai 2016 bei 18:30:02, Austin Zheng via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; I made heavy revisions to my proposal to reflect all the great feedback I<br>&gt; got from you and several other folks (<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt; ).<br>&gt;<br>&gt; Here are a couple of thoughts:<br>&gt;<br>&gt; - I used &#39;requirements&#39; because that&#39;s how the grammar describes similar<br>&gt; constructs elsewhere in Swift. Open to change, though.<br>&gt;<br>&gt; - Having only one where clause makes complete sense. Protocol extensions<br>&gt; and generics all use one where clause, so should this construct.<br>&gt;<br>&gt; - The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x<br>&gt; : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you<br>&gt; can with protocols without associated types or self requirements today.<br>&gt;<br>&gt; - I&#39;ve come to the conclusion that it&#39;s probably best to propose the<br>&gt; proposal in the most general form, and allow any reviewers on the core team<br>&gt; to excise parts they don&#39;t think are useful enough or are too difficult to<br>&gt; implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any<br>&gt; usage is fully general.<br>&gt;<br>&gt; - I moved discussion of typealiases back into the main protocol, like you<br>&gt; said, because typealiases using existentials are *not* actually generic and<br>&gt; can be done today.<br>&gt;<br>&gt; - I added some stuff about &#39;narrowing&#39; existentials at point of use using<br>&gt; as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this<br>&gt; proposal nicely.<br>&gt;<br>&gt; - I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably<br>&gt; sure there&#39;s not much more flexibility we can give the user. Parameter<br>&gt; associated types can&#39;t be treated as covariant (they are almost always<br>&gt; invariant or contravariant IIRC) and therefore they should only be<br>&gt; accessible if fully bound. Return types can be treated as covariant; some<br>&gt; languages do and some don&#39;t. (Swift falls into the second bucket.) I would<br>&gt; love to be wrong, though.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into<br>&gt; account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;<br>&gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;<br>&gt; Since there is no chance this will come up for review anytime soon, I<br>&gt; expect to make significant revisions to it over the next month or so. Any<br>&gt; feedback would be greatly appreciated.<br>&gt;<br>&gt;<br>&gt; Thank you for working on this!  Great progress.<br>&gt;<br>&gt; Minor nit, but I think the proper word is constraint rather than<br>&gt; requirement here:<br>&gt;<br>&gt; &quot;Within the angle brackets &lt; and &gt; are zero or more *requirements*.<br>&gt; Requirements are separated by commas.&quot;<br>&gt;<br>&gt; Another tweak:<br>&gt;<br>&gt; &quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without<br>&gt; associated type or self requirements.&quot;<br>&gt;<br>&gt; This proposal is introducing generalized existentials.  P and Any&lt;P&gt;<br>&gt; should be interchangeable for any protocol regardless of requirements of<br>&gt; the protocol.  Existentials of protocols with self or associated type<br>&gt; requirements that do not include constraints will just expose limited<br>&gt; direct functionality.  It would still be possible to attempt cast them to<br>&gt; concrete types to recover more functionality.  In the future (after a<br>&gt; follow on proposal) it will also be possible to open the existential.<br>&gt;<br>&gt; Thorsten pointed out that there should only be one where clause for the<br>&gt; whole existential.  This follows the structure of generic type and function<br>&gt; constraints.  It may also be worth removing the &#39;as&#39; alias from this<br>&gt; proposal.  This could be introduced as a stand alone proposal where it<br>&gt; would apply to any context with generic constraints.<br>&gt;<br>&gt; Another item:<br>&gt; // NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt;<br>&gt; Why is this not allowed?  It is pointless, but should be allowed and<br>&gt; considered identical to the flattened syntax.<br>&gt;<br>&gt; On dynamic casting, I don&#39;t believe it should be restricted in the way you<br>&gt; have defined here.  Casting *to* an existential doesn&#39;t have anything to do<br>&gt; with opening an existential.  We should allow casting to any existential<br>&gt; type.<br>&gt;<br>&gt; On a similar note, I completely disagree with the limitation you specify<br>&gt; for use of Any in generic constraints precisely because of your<br>&gt; counterargument.  In the discussion about moving the where clause it has<br>&gt; been noted that sometime it is necessary to apply a lot of constraints to<br>&gt; get the necessary effect.  A mechanism for factoring constraints is highly<br>&gt; desirable and will greatly improve the readability of generic code.<br>&gt; Typealiases bound to Any can provide such a mechanism.  Let&#39;s not<br>&gt; artificially restrict the use of it.<br>&gt;<br>&gt; The section regarding members of a partly constrained existential needs to<br>&gt; be more fleshed out.  We can&#39;t simply punt it to a future proposal.<br>&gt; However, I do think it is a good idea to wait until the core team has time<br>&gt; to participate in the discussion.<br>&gt;<br>&gt; The section about defining typealias also should not be left to the<br>&gt; future.  It is possible to define typealias with protocol&lt;&gt; today and to<br>&gt; use that alias in a generic constraint.  Removing that capability would be<br>&gt; a regression.  In fact, it&#39;s utility will increase significantly with this<br>&gt; proposal.<br>&gt;<br>&gt; In general, I don&#39;t think we need the distinction between simple and full<br>&gt; Any.  The whole idea of this proposal IMO should be fully generalizing<br>&gt; existentials.  If restrictions are necessary they should be due to<br>&gt; (hopefully temporary) implementation considerations.<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt;&gt;&gt;&gt; separated by semicolons. (This is so commas can be used in where<br>&gt;&gt;&gt;&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt;&gt;&gt;&gt; can use commas exclusively.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.<br>&gt;&gt;&gt;&gt; The `where` keyword separates the protocol list from the constraints just<br>&gt;&gt;&gt;&gt; fine.  The list on either side should be able to use commas with no problem<br>&gt;&gt;&gt;&gt; (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write<br>&gt;&gt;&gt; out a few &#39;dummy&#39; examples to see if there are any readability issues that<br>&gt;&gt;&gt; arise.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work<br>&gt;&gt;&gt; for the protocol list but it feels inconsistent with the rest of Swift.<br>&gt;&gt;&gt; Commas plus (hopefully) the alternative of newline seem like the right<br>&gt;&gt;&gt; direction to me.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of<br>&gt;&gt; the semicolons and use commas. I&#39;ve come to the conclusion that there are<br>&gt;&gt; no readability issues, protocol&lt;&gt; already uses commas, and semicolons used<br>&gt;&gt; in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a<br>&gt;&gt;&gt;&gt;    constraint on the existential to be any class type. (Implies: Only one can<br>&gt;&gt;&gt;&gt;    exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39;<br>&gt;&gt;&gt;&gt; as a counterpart.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value`<br>&gt;&gt;&gt;&gt; would allow either of those.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact<br>&gt;&gt;&gt; details as to how struct, value, or enum specifiers should work.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we<br>&gt;&gt;&gt; should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Absolutely.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Class name. Must be the first clause, if present. (Implies: Only<br>&gt;&gt;&gt;&gt;    one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;&gt;&gt;&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;&gt;&gt;&gt;    class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that<br>&gt;&gt;&gt;&gt; the class does not fulfill.  For example, you might have Any&lt;UIView,<br>&gt;&gt;&gt;&gt; SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various<br>&gt;&gt;&gt;&gt; subclasses do.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s<br>&gt;&gt;&gt;&gt; did like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type<br>&gt;&gt;&gt; is a type &#39;expression&#39; just like any other, and should be allowed to<br>&gt;&gt;&gt; participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out<br>&gt;&gt;&gt;&gt; constraints.  If we are going to do that we should allow a class to be<br>&gt;&gt;&gt;&gt; specified in the composition as long is it is a subclass of all class<br>&gt;&gt;&gt;&gt; requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class<br>&gt;&gt;&gt;&gt; requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a good point. There should be clarification as to how special<br>&gt;&gt;&gt; cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you<br>&gt;&gt;&gt; said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid.<br>&gt;&gt;&gt; This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also<br>&gt;&gt;&gt; cases of incompatible associated type constraints which need to be rejected<br>&gt;&gt;&gt; (such as composing two Any’s where one has Element == String and another<br>&gt;&gt;&gt; has Element == Int).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource;<br>&gt;&gt;&gt;&gt; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view<br>&gt;&gt;&gt;&gt; data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;&gt;&gt;&gt;    protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt;&gt;&gt;&gt; BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with<br>&gt;&gt;&gt;&gt; associated types or self requirements. Feel free to propose a more sound<br>&gt;&gt;&gt;&gt; name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Self-contained static protocol, simple. This is composed of the<br>&gt;&gt;&gt;&gt;    name of a static protocol, optionally followed by a &#39;where&#39; clause in which<br>&gt;&gt;&gt;&gt;    the associated types can be constrained (with any of the three basic<br>&gt;&gt;&gt;&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;&gt;&gt;&gt;    Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static<br>&gt;&gt;&gt;&gt; protocol”.  We want to support existentials of protocols that have self or<br>&gt;&gt;&gt;&gt; associated type requirements.  The dynamic vs static distinction is a<br>&gt;&gt;&gt;&gt; limitation of the current implementation of Swift and doesn’t make sense<br>&gt;&gt;&gt;&gt; for the long term vision.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At<br>&gt;&gt;&gt; the same time &quot;protocols with self or associated type requirements&quot; is<br>&gt;&gt;&gt; cumbersome to work with and it would be nice for someone to come up with a<br>&gt;&gt;&gt; descriptive term of art for referring to them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would<br>&gt;&gt;&gt; prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with<br>&gt;&gt; better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt;&gt;&gt;&gt; .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt;&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions<br>&gt;&gt;&gt;&gt; are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects *and* their<br>&gt;&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their<br>&gt;&gt;&gt; subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence<br>&gt;&gt; could be ambiguously parsed.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Bound static protocol. This is the same as a self-contained<br>&gt;&gt;&gt;&gt;    static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol<br>&gt;&gt;&gt;&gt;    to a generic typealias. The name can be then be used in subsequent clauses<br>&gt;&gt;&gt;&gt;    to build constraints.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt;&gt;&gt;&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt;&gt;&gt;&gt; literal, in which the collection elements are the same type as the type of<br>&gt;&gt;&gt;&gt; the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the<br>&gt;&gt;&gt;&gt; other way around: `Collection as T` with the alias *after* the name of<br>&gt;&gt;&gt;&gt; the protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int,<br>&gt;&gt;&gt; Protocol.Bar : Baz”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean<br>&gt;&gt;&gt; &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type<br>&gt;&gt;&gt;&gt; of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to<br>&gt;&gt;&gt;&gt; cases where there is only one protocol that is getting constrained.  In<br>&gt;&gt;&gt;&gt; other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right,<br>&gt;&gt;&gt; it should only be allowed if there is one protocol with associated types or<br>&gt;&gt;&gt; self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and<br>&gt;&gt;&gt; possibly even to one protocol and no type names (as types can have nested<br>&gt;&gt;&gt; types and typealiases).  When we allow shorthand it should be immediately<br>&gt;&gt;&gt; unambiguous what the shorthand references with no need to look at type or<br>&gt;&gt;&gt; protocol declarations.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It might be desirable to propose the proposal with no allowance for<br>&gt;&gt; shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if<br>&gt;&gt;&gt;&gt; generic typealiases are allowed, they cannot refer to each other in a<br>&gt;&gt;&gt;&gt; circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t<br>&gt;&gt;&gt;&gt; create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided<br>&gt;&gt;&gt;&gt; by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if<br>&gt;&gt;&gt;&gt; there were any methods on Equatable that did not use the associated types<br>&gt;&gt;&gt;&gt; at all you&#39;d be able to call them, but that&#39;s about it. However,<br>&gt;&gt;&gt;&gt; &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on<br>&gt;&gt;&gt;&gt; instances. (This is a stupid example, since Any&lt;Equatable where .Self ==<br>&gt;&gt;&gt;&gt; String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful<br>&gt;&gt;&gt;&gt; examples one could come up with.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;&gt;&gt;&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;    - Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;    - Fully constrain associated types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to<br>&gt;&gt;&gt;&gt; be available or not available.  This section probably needs the most design<br>&gt;&gt;&gt;&gt; and elaboration.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated<br>&gt;&gt;&gt;&gt; type as an input unless it is constrained to a specific type.  On the other<br>&gt;&gt;&gt;&gt; hand output types probably don’t need to limit access to a member.<br>&gt;&gt;&gt;&gt; However, if the output type is Self or an associated type the visible<br>&gt;&gt;&gt;&gt; signature would have an output type which has the relevant constraints of<br>&gt;&gt;&gt;&gt; the existential applied, but no more.  In some cases this means the output<br>&gt;&gt;&gt;&gt; type would simply be Any.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get<br>&gt;&gt;&gt; something down first. Thanks for thinking through some of the implications<br>&gt;&gt;&gt; :).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating<br>&gt;&gt;&gt; expectations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions,<br>&gt;&gt;&gt;&gt; generic types, etc.  Working out the details in these cases is pretty<br>&gt;&gt;&gt;&gt; complex.  I will defer to Doug on whether it is best to just defer those<br>&gt;&gt;&gt;&gt; cases to the future, leave them up to the implementer, or try to work out<br>&gt;&gt;&gt;&gt; all of the relevant details in the proposal (in which case we probably need<br>&gt;&gt;&gt;&gt; a type system expert to help!).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols<br>&gt;&gt;&gt; with associated types or self requirements be used within generic function<br>&gt;&gt;&gt; or type definitions? Maybe there&#39;s an argument that existential types of<br>&gt;&gt;&gt; this nature are redundant if you have access to generics (e.g. defining a<br>&gt;&gt;&gt; property on a generic type that is a Collection containing Ints; you should<br>&gt;&gt;&gt; be able to do that today). On the other hand, maybe there are use cases I<br>&gt;&gt;&gt; haven&#39;t thought of…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For<br>&gt;&gt;&gt; example, you may want to store instances in a heterogeneous collection.<br>&gt;&gt;&gt; You need existentials to do that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex<br>&gt;&gt;&gt; types that reference Self or associated types.  I think you really need a<br>&gt;&gt;&gt; formal understanding of the type system to understand how to expose these<br>&gt;&gt;&gt; members through a constrained existential.  We can probably understand the<br>&gt;&gt;&gt; expected behavior in some of the simpler cases on a case by case basis, but<br>&gt;&gt;&gt; that approach doesn’t scale at all and is arbitrary.  If they’re going to<br>&gt;&gt;&gt; be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out<br>&gt;&gt;&gt;&gt; of scope for this proposal?  That would be fine with me as this proposal is<br>&gt;&gt;&gt;&gt; already taking on a lot.  But if so, you should mention something about<br>&gt;&gt;&gt;&gt; future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I<br>&gt;&gt;&gt; wanted to mention it in the section where I talk about how Any&lt;Equatable&gt;<br>&gt;&gt;&gt; is not very useful). But you are absolutely right, this proposal should<br>&gt;&gt;&gt; discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and<br>&gt;&gt;&gt;&gt; typealiases referring to them) should be usable as generic constraints.  I<br>&gt;&gt;&gt;&gt; would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some<br>&gt;&gt;&gt; point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of<br>&gt;&gt;&gt; the Any into the list of generic constraints.  Maybe I’m missing something,<br>&gt;&gt;&gt; but I don’t think so.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/6ea6b809/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>So without any initial constraints how would one use this generic function??<br></p><p>extension UIButton: ProtocolA {}<br></p><p>let button = UIButton()<br>let shadowedButton: ProtocolA = UIButton()<br></p><p>// creates a set of a least one element if the generic type could be inferred<br>func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br></p><p>// this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br></p><p>// this won’t be possible because of the restriction<br>let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br></p><p>Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br></p><p>&quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br></p><p>This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br></p><p>class A: ClassB, ProtocolA {}<br></p><p>Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 21:23:35, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>I strongly prefer keeping the class requirement first, both for readability and because this reflects how protocol and &#39;class&#39; or superclass conformances already work when defining classes or protocols. I think &quot;look at the first argument, and then recursively look at the first arguments of any nested Any&#39;s for class requirements&quot; is straightforward enough not to confuse people, and helps keep the type definitions organized.<br></p><p>Austin<br></p><p>On Wed, May 18, 2016 at 12:11 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>On May 18, 2016, at 12:12 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Okay now I feel like we’re merging everything we came up until now :D I’d love to see something like this happen to Swift, because `Any` seems to be a really powerful beast one day.<br></p><p>One quick question: Do we really need this &quot;This must be the first requirement, if present.“?<br></p><p>I’m on the fence about this.  The reason it would matter is for readability.  The counter argument to that is that you can’t rely on the first argument being a class to determine whether a composed Any will have a class constraint or not.<br></p><p><br>I’d say the compiler should reorder all types as it wants to. Current protocol&lt;&gt; already doing this today.<br></p><p>e.g.<br></p><p>protocol A {}<br>protocol B {}<br></p><p>typealias C = protocol&lt;A, B&gt;<br>typealias D = protocol&lt;B, A&gt;<br></p><p>print(C) // prints protocol&lt;A, B&gt;<br>print(D) // prints protocol&lt;A, B&gt;<br>print(C.self == D.self) // prints true<br></p><p>Basically what I mean<br></p><p>Any&lt;SomeProtocol, class, AnotherProtocol&gt;<br></p><p>Any&lt;Any&lt;ProtocolA, ProtocolB&gt;, UIView&gt;<br></p><p>should be valid.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 18:30:02, Austin Zheng via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md).<br></p><p>Here are a couple of thoughts:<br></p><p>- I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br></p><p>- Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br></p><p>- The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br></p><p>- I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br></p><p>- I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br></p><p>- I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br></p><p>- I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br></p><p>Austin<br></p><p>On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p><br></p><p>Sent from my iPad<br></p><p>On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br></p><p>Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br></p><p>Thank you for working on this!  Great progress.<br></p><p>Minor nit, but I think the proper word is constraint rather than requirement here:<br></p><p>&quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br></p><p>Another tweak: <br></p><p>&quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br></p><p>This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br></p><p>Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br></p><p>Another item:<br>// NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br></p><p>On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br></p><p>On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br></p><p>The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br></p><p>The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br></p><p>In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br></p><p><br>Austin<br></p><p>On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p><br>On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br> <br></p><p><br>Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br></p><p>I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br></p><p><br>I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br></p><p>Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br></p><p>Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br> <br></p><p><br>There are five different possible clauses:<br></p><p>&#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br></p><p>(In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br></p><p>If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br></p><p><br>Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br></p><p>Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br></p><p>Absolutely.<br> <br></p><p><br>Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br></p><p><br>Fair enough. (I don&#39;t think the way things work would be affected.)<br> <br>Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br></p><p>typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>Any&lt;AnotherProtocol, Foo&gt;<br></p><p>I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br> <br></p><p>I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br></p><p>typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br></p><p>This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br></p><p>This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br></p><p>Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br></p><p> <br></p><p>Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br></p><p>I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br></p><p>Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br></p><p>I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br></p><p>I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br></p><p>I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br> <br></p><p> <br></p><p><br>Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br></p><p>Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br></p><p>&quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br></p><p><br>Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br></p><p>Ok, good.  Wasn’t quite clear to me.<br></p><p>Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br> <br></p><p><br>Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br></p><p>Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br></p><p>I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br></p><p><br>I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br></p><p>Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br></p><p>Another result of rushing to compose an email. Sorry!<br> <br></p><p> <br>You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br></p><p>I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br></p><p>I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br></p><p>It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br> <br></p><p> <br></p><p><br>There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br></p><p>How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br></p><p>In order of increasing &#39;power&#39;:<br>Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>Constrain associated types to conform to protocols.<br>Fully constrain associated types.<br>I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br></p><p>For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br></p><p>Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br></p><p>That’s what I thought.  Just wanted to start the process of elaborating expectations.<br></p><p> <br></p><p>Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br></p><p>Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br></p><p>I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br></p><p>A simple example of what I was referring to there is something like this:<br></p><p>protocol P {<br>    associatedtype Foo<br></p><p>    func bar(callback: (Foo) -&gt; ())<br>}<br></p><p>In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br></p><p>Yes. I have some ideas regarding this topic.<br> <br></p><p> <br></p><p>One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br></p><p>Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br> <br></p><p>Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br></p><p>I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br></p><p>I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br></p><p> <br></p><p>-Matthew<br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/5a192c54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:15 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So without any initial constraints how would one use this generic function??<br>&gt; <br>&gt; extension UIButton: ProtocolA {}<br>&gt; <br>&gt; let button = UIButton()<br>&gt; let shadowedButton: ProtocolA = UIButton()<br>&gt; <br>&gt; // creates a set of a least one element if the generic type could be inferred<br>&gt; func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br></p><p>You would not be able to form Any&lt;T, U&gt; here because T and U are generic arguments unknown.  We don’t accept those, only `class`, specific classes, and specific protocols (and recursively, other Any).<br></p><p>&gt; <br>&gt; // this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>&gt; let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br>&gt; <br>&gt; // this won’t be possible because of the restriction<br>&gt; let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br>&gt; <br>&gt; Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br>&gt; <br>&gt; &quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br>&gt; <br>&gt; This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br>&gt; <br>&gt; class A: ClassB, ProtocolA {}<br>&gt; <br>&gt; Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br></p><p>`Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is provided it must come first.<br></p><p>`Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than one class.<br></p><p>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 18. Mai 2016 bei 21:23:35, Austin Zheng (austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I strongly prefer keeping the class requirement first, both for readability and because this reflects how protocol and &#39;class&#39; or superclass conformances already work when defining classes or protocols. I think &quot;look at the first argument, and then recursively look at the first arguments of any nested Any&#39;s for class requirements&quot; is straightforward enough not to confuse people, and helps keep the type definitions organized.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Wed, May 18, 2016 at 12:11 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:12 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay now I feel like we’re merging everything we came up until now :D I’d love to see something like this happen to Swift, because `Any` seems to be a really powerful beast one day.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One quick question: Do we really need this &quot;This must be the first requirement, if present.“?<br>&gt;&gt; <br>&gt;&gt; I’m on the fence about this.  The reason it would matter is for readability.  The counter argument to that is that you can’t rely on the first argument being a class to determine whether a composed Any will have a class constraint or not.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d say the compiler should reorder all types as it wants to. Current protocol&lt;&gt; already doing this today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {}<br>&gt;&gt;&gt; protocol B {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias C = protocol&lt;A, B&gt;<br>&gt;&gt;&gt; typealias D = protocol&lt;B, A&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(C) // prints protocol&lt;A, B&gt;<br>&gt;&gt;&gt; print(D) // prints protocol&lt;A, B&gt;<br>&gt;&gt;&gt; print(C.self == D.self) // prints true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically what I mean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any&lt;SomeProtocol, class, AnotherProtocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any&lt;Any&lt;ProtocolA, ProtocolB&gt;, UIView&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; should be valid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 18. Mai 2016 bei 18:30:02, Austin Zheng via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are a couple of thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you for working on this!  Great progress.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Minor nit, but I think the proper word is constraint rather than requirement here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another tweak: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another item:<br>&gt;&gt;&gt;&gt;&gt; // NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/769581e7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>So without any initial constraints how would one use this generic function??<br></p><p>extension UIButton: ProtocolA {}<br></p><p>let button = UIButton()<br>let shadowedButton: ProtocolA = UIButton()<br></p><p>// creates a set of a least one element if the generic type could be inferred<br>func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br></p><p>You would not be able to form Any&lt;T, U&gt; here because T and U are generic arguments unknown.  We don’t accept those, only `class`, specific classes, and specific protocols (and recursively, other Any).<br></p><p>Why would Any&lt;…&gt; does not work with the generic system here? To me it makes no sense, I as a developer would assume I can use a generic Type anywhere a type can be used (protocols and their associated types are a special case).<br></p><p>I would assume that:<br></p><p>func foo&lt;T: UIView&gt;(value: Any&lt;T, SomeProtocol&gt;)<br></p><p>should be equal to (without the need of generics):<br></p><p>func foo(value: Any&lt;UIView, SomeProtocol&gt;)<br></p><p><br>// this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br></p><p>// this won’t be possible because of the restriction<br>let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br></p><p>Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br></p><p>&quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br></p><p>This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br></p><p>class A: ClassB, ProtocolA {}<br></p><p>Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br></p><p>`Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is provided it must come first.<br></p><p>`Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than one class.<br>Not true, take a look at the nested section of the proposal again.<br></p><p>We discussed that this is valid:<br></p><p>// Allowed, but pointless.<br>// Identical to Any&lt;ProtocolA, ProtocolB&gt;<br>let b : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>This implies that also this would be valid:<br></p><p>Any&lt;Any&lt;ClassA, ProtocolA&gt;&gt; inferred as Any&lt;ClassA, ProtocolA&gt;<br></p><p>There is another example:<br></p><p>// Can be any type that is a UITableView conforming to ProtocolA.<br>// UITableView is the most specific class, and it is a subclass of the other<br>// two classes.<br>let a : Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br></p><p>Which followed by the mentioned rule can als be:<br></p><p>Any&lt;UIScrollView, UITableView, Any&lt;UIView, ProtocolA&gt;&gt; or<br>Any&lt;UIScrollView, UITableView, UIView, ProtocolA&gt;<br></p><p>This would force us to allow multiple classes inside Any&lt;…&gt; if there is a inheritance relationship between them.<br></p><p>And because this is a inheritance relationship it can be simplified to:<br></p><p>Any&lt;UITableView, ProtocolA&gt; which is valid. <br></p><p>And by the way since the order in your proposal would matter, this example won’t work at all, because its not:<br></p><p>Any&lt;UITableView, Any&lt;UIScrollView, Any&lt;UIView, ProtocolA&gt;&gt;&gt; <br></p><p>In my proposal I explicitly banned multiple reference types and inheritance branches like this. I would need to simplify that type to Any&lt;UITableView, ProtocolA&gt; by myself.<br>Ingeneral this is a good idea, but it makes nesting (with typealiases) almost impossible, when there are some relationship like in the above example.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/dad5bc89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m not sure what your objections actually are, but my responses are inline.<br></p><p>On Wed, May 18, 2016 at 1:57 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So without any initial constraints how would one use this generic<br>&gt; function??<br>&gt;<br>&gt; extension UIButton: ProtocolA {}<br>&gt;<br>&gt; let button = UIButton()<br>&gt; let shadowedButton: ProtocolA = UIButton()<br>&gt;<br>&gt; // creates a set of a least one element if the generic type could be<br>&gt; inferred<br>&gt; func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge<br>&gt; somehow if possible */ }<br>&gt;<br>&gt;<br>&gt; You would not be able to form Any&lt;T, U&gt; here because T and U are generic<br>&gt; arguments unknown.  We don’t accept those, only `class`, specific classes,<br>&gt; and specific protocols (and recursively, other Any).<br>&gt;<br>&gt;<br>&gt; Why would Any&lt;…&gt; does not work with the generic system here? To me it<br>&gt; makes no sense, I as a developer would assume I can use a generic Type<br>&gt; anywhere a type can be used (protocols and their associated types are a<br>&gt; special case).<br>&gt;<br></p><p>Because what existentials are trying to model and what generic type<br>parameters are trying to model are two different things. You already cannot<br>use arbitrary types within a Any&lt;&gt; existential as the proposal stands.<br></p><p>This doesn&#39;t currently work in Swift, and it shouldn&#39;t: &quot;func foo&lt;A, B&gt;()<br>-&gt; protocol&lt;A, B&gt;&quot;. There is no useful way to generically compose instances<br>of two protocol types at runtime to form an instance of a type that<br>conforms to both protocols, like there is a way to compose instances of two<br>types to form a tuple containing those types. Therefore, writing a generic<br>function to do this makes no sense.<br></p><p><br>&gt; I would assume that:<br>&gt;<br>&gt; func foo&lt;T: UIView&gt;(value: Any&lt;T, SomeProtocol&gt;)<br>&gt;<br>&gt; should be equal to (without the need of generics):<br>&gt;<br>&gt; func foo(value: Any&lt;UIView, SomeProtocol&gt;)<br>&gt;<br>&gt;<br>&gt; // this should be valid because the compiler will assume Any&lt;UIView,<br>&gt; ProtocolA&gt; where T == UIView and U == ProtocolA<br>&gt; let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView<br>&gt; subtype */ button, /* ProtocolA */ shadowedButton)<br>&gt;<br>&gt; // this won’t be possible because of the restriction<br>&gt; let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; =<br>&gt; unionIfPossible(shadowedButton, button)<br>&gt;<br>&gt; Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may<br>&gt; feel right for readability but the types should be equal.<br>&gt;<br>&gt; &quot;Can be any class type that is a UIView or a subclass of UIView, that also<br>&gt; conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a<br>&gt; UIView or a subclass of UIView.“<br>&gt;<br>&gt; This is also a nesting problem where you will be forced to choose the<br>&gt; right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br>&gt;<br>&gt; class A: ClassB, ProtocolA {}<br>&gt;<br>&gt; Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; ==<br>&gt; Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and<br>&gt; inferred as A<br>&gt;<br>&gt;<br>&gt; `Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is<br>&gt; provided it must come first.<br>&gt;<br>&gt; `Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than<br>&gt; one class.<br>&gt;<br>&gt; Not true, take a look at the nested section of the proposal again.<br>&gt;<br>&gt; We discussed that this is valid:<br>&gt;<br>&gt; // Allowed, but pointless.// Identical to Any&lt;ProtocolA, ProtocolB&gt;let b : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt;<br>&gt;<br>&gt; This implies that also this would be valid:<br>&gt;<br>&gt; Any&lt;Any&lt;ClassA, ProtocolA&gt;&gt; inferred as Any&lt;ClassA, ProtocolA&gt;<br>&gt;<br></p><p>Yes, this is valid.<br></p><p><br>&gt;<br>&gt; There is another example:<br>&gt;<br>&gt; // Can be any type that is a UITableView conforming to ProtocolA.// UITableView is the most specific class, and it is a subclass of the other// two classes.let a : Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt;<br>&gt;<br>&gt; Which followed by the mentioned rule can als be:<br>&gt;<br>&gt; Any&lt;UIScrollView, UITableView, Any&lt;UIView, ProtocolA&gt;&gt; or<br>&gt; Any&lt;UIScrollView, UITableView, UIView, ProtocolA&gt;<br>&gt;<br>&gt; This would force us to allow multiple classes inside Any&lt;…&gt; if there is a<br>&gt; inheritance relationship between them.<br>&gt;<br></p><p>Yes. As explained in the proposal, there is already a way to handle<br>resolving the single &#39;effective&#39; class constraint. You can only<br>&#39;explicitly&#39; declare one class constraint, but you can pull in other class<br>constraints from nested existentials for the sake of making composition<br>easier. In the end it doesn&#39;t matter, because if the class constraints<br>don&#39;t form a valid inheritance hierarchy the compiler will complain, and if<br>they do the most specific type will be chosen.<br></p><p><br>&gt;<br>&gt; And because this is a inheritance relationship it can be simplified to:<br>&gt;<br>&gt; Any&lt;UITableView, ProtocolA&gt; which is valid.<br>&gt;<br>&gt; And by the way since the order in your proposal would matter, this example<br>&gt; won’t work at all, because its not:<br>&gt;<br>&gt; Any&lt;UITableView, Any&lt;UIScrollView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt;<br></p><p>The order does *not* affect the semantic meaning of the existential. There<br>is a section in the proposal on how existentials are conceptually &#39;reduced&#39;<br>from whatever form they take when the programmer types them in, please read<br>it. I am not proposing a macro system. The compiler does not do textual<br>replacement in order to flatten nested existential definitions.<br></p><p>This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because<br>such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other<br>generic type or aggregate type in Swift.<br></p><p><br>&gt;<br>&gt; In my proposal I explicitly banned multiple reference types and<br>&gt; inheritance branches like this. I would need to simplify that type to<br>&gt; Any&lt;UITableView, ProtocolA&gt; by myself.<br>&gt; Ingeneral this is a good idea, but it makes nesting (with typealiases)<br>&gt; almost impossible, when there are some relationship like in the above<br>&gt; example.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/c1062cea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 4:17 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure what your objections actually are, but my responses are inline.<br></p><p>Your responses are exactly what mine would be.  For a second I was worried that I missed something when reading the latest draft! :)<br></p><p>&gt; <br>&gt; On Wed, May 18, 2016 at 1:57 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; So without any initial constraints how would one use this generic function??<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton: ProtocolA {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let button = UIButton()<br>&gt;&gt;&gt; let shadowedButton: ProtocolA = UIButton()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // creates a set of a least one element if the generic type could be inferred<br>&gt;&gt;&gt; func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br>&gt;&gt; <br>&gt;&gt; You would not be able to form Any&lt;T, U&gt; here because T and U are generic arguments unknown.  We don’t accept those, only `class`, specific classes, and specific protocols (and recursively, other Any).<br>&gt; <br>&gt; Why would Any&lt;…&gt; does not work with the generic system here? To me it makes no sense, I as a developer would assume I can use a generic Type anywhere a type can be used (protocols and their associated types are a special case).<br>&gt; <br>&gt; Because what existentials are trying to model and what generic type parameters are trying to model are two different things. You already cannot use arbitrary types within a Any&lt;&gt; existential as the proposal stands.<br>&gt; <br>&gt; This doesn&#39;t currently work in Swift, and it shouldn&#39;t: &quot;func foo&lt;A, B&gt;() -&gt; protocol&lt;A, B&gt;&quot;. There is no useful way to generically compose instances of two protocol types at runtime to form an instance of a type that conforms to both protocols, like there is a way to compose instances of two types to form a tuple containing those types. Therefore, writing a generic function to do this makes no sense.<br>&gt; <br>&gt; <br>&gt; I would assume that:<br>&gt; <br>&gt; func foo&lt;T: UIView&gt;(value: Any&lt;T, SomeProtocol&gt;)<br>&gt; <br>&gt; should be equal to (without the need of generics):<br>&gt; <br>&gt; func foo(value: Any&lt;UIView, SomeProtocol&gt;)<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>&gt;&gt;&gt; let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // this won’t be possible because of the restriction<br>&gt;&gt;&gt; let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A: ClassB, ProtocolA {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br>&gt;&gt; <br>&gt;&gt; `Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is provided it must come first.<br>&gt;&gt; <br>&gt;&gt; `Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than one class.<br>&gt; <br>&gt; Not true, take a look at the nested section of the proposal again.<br>&gt; <br>&gt; We discussed that this is valid:<br>&gt; <br>&gt; // Allowed, but pointless.<br>&gt; // Identical to Any&lt;ProtocolA, ProtocolB&gt;<br>&gt; let b : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt; <br>&gt; This implies that also this would be valid:<br>&gt; <br>&gt; Any&lt;Any&lt;ClassA, ProtocolA&gt;&gt; inferred as Any&lt;ClassA, ProtocolA&gt;<br>&gt; <br>&gt; Yes, this is valid.<br>&gt;  <br>&gt; <br>&gt; There is another example:<br>&gt; <br>&gt; // Can be any type that is a UITableView conforming to ProtocolA.<br>&gt; // UITableView is the most specific class, and it is a subclass of the other<br>&gt; // two classes.<br>&gt; let a : Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br>&gt; <br>&gt; Which followed by the mentioned rule can als be:<br>&gt; <br>&gt; Any&lt;UIScrollView, UITableView, Any&lt;UIView, ProtocolA&gt;&gt; or<br>&gt; Any&lt;UIScrollView, UITableView, UIView, ProtocolA&gt;<br>&gt; <br>&gt; This would force us to allow multiple classes inside Any&lt;…&gt; if there is a inheritance relationship between them.<br>&gt; <br>&gt; Yes. As explained in the proposal, there is already a way to handle resolving the single &#39;effective&#39; class constraint. You can only &#39;explicitly&#39; declare one class constraint, but you can pull in other class constraints from nested existentials for the sake of making composition easier. In the end it doesn&#39;t matter, because if the class constraints don&#39;t form a valid inheritance hierarchy the compiler will complain, and if they do the most specific type will be chosen.<br>&gt;  <br>&gt; <br>&gt; And because this is a inheritance relationship it can be simplified to:<br>&gt; <br>&gt; Any&lt;UITableView, ProtocolA&gt; which is valid. <br>&gt; <br>&gt; And by the way since the order in your proposal would matter, this example won’t work at all, because its not:<br>&gt; <br>&gt; Any&lt;UITableView, Any&lt;UIScrollView, Any&lt;UIView, ProtocolA&gt;&gt;&gt; <br>&gt; <br>&gt; The order does not affect the semantic meaning of the existential. There is a section in the proposal on how existentials are conceptually &#39;reduced&#39; from whatever form they take when the programmer types them in, please read it. I am not proposing a macro system. The compiler does not do textual replacement in order to flatten nested existential definitions.<br>&gt; <br>&gt; This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other generic type or aggregate type in Swift.<br>&gt;  <br>&gt; <br>&gt; In my proposal I explicitly banned multiple reference types and inheritance branches like this. I would need to simplify that type to Any&lt;UITableView, ProtocolA&gt; by myself.<br>&gt; Ingeneral this is a good idea, but it makes nesting (with typealiases) almost impossible, when there are some relationship like in the above example.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/fc1adc56/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Okay I got it now, generics made my had spin. I also received no feedback on my proposal to that specific case, which I misunderstood. Thank you for clarifying that to me. That said it makes now sense to force the first requirement, which I dropped in my proposal. <br></p><p>I’d fix that tomorrow.<br></p><p>I’m fine with your proposal now. =) <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 23:17:47, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>I&#39;m not sure what your objections actually are, but my responses are inline.<br></p><p>On Wed, May 18, 2016 at 1:57 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>So without any initial constraints how would one use this generic function??<br></p><p>extension UIButton: ProtocolA {}<br></p><p>let button = UIButton()<br>let shadowedButton: ProtocolA = UIButton()<br></p><p>// creates a set of a least one element if the generic type could be inferred<br>func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br></p><p>You would not be able to form Any&lt;T, U&gt; here because T and U are generic arguments unknown.  We don’t accept those, only `class`, specific classes, and specific protocols (and recursively, other Any).<br></p><p>Why would Any&lt;…&gt; does not work with the generic system here? To me it makes no sense, I as a developer would assume I can use a generic Type anywhere a type can be used (protocols and their associated types are a special case).<br></p><p>Because what existentials are trying to model and what generic type parameters are trying to model are two different things. You already cannot use arbitrary types within a Any&lt;&gt; existential as the proposal stands.<br></p><p>This doesn&#39;t currently work in Swift, and it shouldn&#39;t: &quot;func foo&lt;A, B&gt;() -&gt; protocol&lt;A, B&gt;&quot;. There is no useful way to generically compose instances of two protocol types at runtime to form an instance of a type that conforms to both protocols, like there is a way to compose instances of two types to form a tuple containing those types. Therefore, writing a generic function to do this makes no sense.<br></p><p><br>I would assume that:<br></p><p>func foo&lt;T: UIView&gt;(value: Any&lt;T, SomeProtocol&gt;)<br></p><p>should be equal to (without the need of generics):<br></p><p>func foo(value: Any&lt;UIView, SomeProtocol&gt;)<br></p><p><br>// this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br></p><p>// this won’t be possible because of the restriction<br>let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br></p><p>Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br></p><p>&quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br></p><p>This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br></p><p>class A: ClassB, ProtocolA {}<br></p><p>Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br></p><p>`Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is provided it must come first.<br></p><p>`Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than one class.<br>Not true, take a look at the nested section of the proposal again.<br></p><p>We discussed that this is valid:<br></p><p><br>// Allowed, but pointless.<br>// Identical to Any&lt;ProtocolA, ProtocolB&gt;<br>let b : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>This implies that also this would be valid:<br></p><p>Any&lt;Any&lt;ClassA, ProtocolA&gt;&gt; inferred as Any&lt;ClassA, ProtocolA&gt;<br></p><p>Yes, this is valid.<br> <br></p><p>There is another example:<br></p><p><br>// Can be any type that is a UITableView conforming to ProtocolA.<br>// UITableView is the most specific class, and it is a subclass of the other<br>// two classes.<br>let a : Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br></p><p>Which followed by the mentioned rule can als be:<br></p><p>Any&lt;UIScrollView, UITableView, Any&lt;UIView, ProtocolA&gt;&gt; or<br>Any&lt;UIScrollView, UITableView, UIView, ProtocolA&gt;<br></p><p>This would force us to allow multiple classes inside Any&lt;…&gt; if there is a inheritance relationship between them.<br></p><p>Yes. As explained in the proposal, there is already a way to handle resolving the single &#39;effective&#39; class constraint. You can only &#39;explicitly&#39; declare one class constraint, but you can pull in other class constraints from nested existentials for the sake of making composition easier. In the end it doesn&#39;t matter, because if the class constraints don&#39;t form a valid inheritance hierarchy the compiler will complain, and if they do the most specific type will be chosen.<br> <br></p><p>And because this is a inheritance relationship it can be simplified to:<br></p><p>Any&lt;UITableView, ProtocolA&gt; which is valid. <br></p><p>And by the way since the order in your proposal would matter, this example won’t work at all, because its not:<br></p><p>Any&lt;UITableView, Any&lt;UIScrollView, Any&lt;UIView, ProtocolA&gt;&gt;&gt; <br></p><p>The order does not affect the semantic meaning of the existential. There is a section in the proposal on how existentials are conceptually &#39;reduced&#39; from whatever form they take when the programmer types them in, please read it. I am not proposing a macro system. The compiler does not do textual replacement in order to flatten nested existential definitions.<br></p><p>This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other generic type or aggregate type in Swift.<br> <br></p><p>In my proposal I explicitly banned multiple reference types and inheritance branches like this. I would need to simplify that type to Any&lt;UITableView, ProtocolA&gt; by myself.<br>Ingeneral this is a good idea, but it makes nesting (with typealiases) almost impossible, when there are some relationship like in the above example.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/a28e4a7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Please excuse me for my horrible writing. I guess I’m to tired right now and write a ton strange sentences and typos. :/<br></p><p>Anyways, when the right time comes, I’ll fully support this feature. Any is defiantly worth being part of Swift.<br></p><p>Good n8 everyone.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 23:30:57, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Okay I got it now, generics made my head spin. I also received no feedback on my proposal to that specific case, which I misunderstood. Thank you for clarifying that to me. That said it makes now sense to force the first requirement, which I dropped in my proposal. <br></p><p>I’ll fix that tomorrow.<br></p><p>I’m fine with your proposal now. =) <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Mai 2016 bei 23:17:47, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>I&#39;m not sure what your objections actually are, but my responses are inline.<br></p><p>On Wed, May 18, 2016 at 1:57 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>So without any initial constraints how would one use this generic function??<br></p><p>extension UIButton: ProtocolA {}<br></p><p>let button = UIButton()<br>let shadowedButton: ProtocolA = UIButton()<br></p><p>// creates a set of a least one element if the generic type could be inferred<br>func unionIfPossible&lt;T, U&gt;(_ a: T, _ b: U) -&gt; Set&lt;Any&lt;T, U&gt;&gt;? { /* merge somehow if possible */ }<br></p><p>You would not be able to form Any&lt;T, U&gt; here because T and U are generic arguments unknown.  We don’t accept those, only `class`, specific classes, and specific protocols (and recursively, other Any).<br></p><p>Why would Any&lt;…&gt; does not work with the generic system here? To me it makes no sense, I as a developer would assume I can use a generic Type anywhere a type can be used (protocols and their associated types are a special case).<br></p><p>Because what existentials are trying to model and what generic type parameters are trying to model are two different things. You already cannot use arbitrary types within a Any&lt;&gt; existential as the proposal stands.<br></p><p>This doesn&#39;t currently work in Swift, and it shouldn&#39;t: &quot;func foo&lt;A, B&gt;() -&gt; protocol&lt;A, B&gt;&quot;. There is no useful way to generically compose instances of two protocol types at runtime to form an instance of a type that conforms to both protocols, like there is a way to compose instances of two types to form a tuple containing those types. Therefore, writing a generic function to do this makes no sense.<br></p><p><br>I would assume that:<br></p><p>func foo&lt;T: UIView&gt;(value: Any&lt;T, SomeProtocol&gt;)<br></p><p>should be equal to (without the need of generics):<br></p><p>func foo(value: Any&lt;UIView, SomeProtocol&gt;)<br></p><p><br>// this should be valid because the compiler will assume Any&lt;UIView, ProtocolA&gt; where T == UIView and U == ProtocolA<br>let merged_1: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible( /* UIView subtype */ button, /* ProtocolA */ shadowedButton) <br></p><p>// this won’t be possible because of the restriction<br>let merged_2: Set&lt;Any&lt;UIView, ProtocolA&gt;&gt; = unionIfPossible(shadowedButton, button) <br></p><p>Any&lt;UIView, ProtocolA&gt; != Any&lt;ProtocolA, UIView&gt; isn’t right. Sure it may feel right for readability but the types should be equal.<br></p><p>&quot;Can be any class type that is a UIView or a subclass of UIView, that also conforms to ProtocolA.“ == &quot;Type that conforms to ProtocolA and that is a UIView or a subclass of UIView.“<br></p><p>This is also a nesting problem where you will be forced to choose the right place inside the angle brackets where to add a nested `Any&lt;…&gt;`.<br></p><p>class A: ClassB, ProtocolA {}<br></p><p>Any&lt;A, Any&lt;ClassB, ProtocolA&gt;&gt; == A != Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt; == Any&lt;ClassB, ProtocolA, A&gt; which should be reorder by the compiler and inferred as A<br></p><p>`Any&lt;Any&lt;ClassB, ProtocolA&gt;, A&gt;` is not allowed because if a class is provided it must come first.<br></p><p>`Any&lt;ClassB, ProtocolA, A&gt;` is not allowed because it contains more than one class.<br>Not true, take a look at the nested section of the proposal again.<br></p><p>We discussed that this is valid:<br></p><p><br>// Allowed, but pointless.<br>// Identical to Any&lt;ProtocolA, ProtocolB&gt;<br>let b : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br></p><p>This implies that also this would be valid:<br></p><p>Any&lt;Any&lt;ClassA, ProtocolA&gt;&gt; inferred as Any&lt;ClassA, ProtocolA&gt;<br></p><p>Yes, this is valid.<br> <br></p><p>There is another example:<br></p><p><br>// Can be any type that is a UITableView conforming to ProtocolA.<br>// UITableView is the most specific class, and it is a subclass of the other<br>// two classes.<br>let a : Any&lt;UIScrollView, Any&lt;UITableView, Any&lt;UIView, ProtocolA&gt;&gt;&gt;<br></p><p>Which followed by the mentioned rule can als be:<br></p><p>Any&lt;UIScrollView, UITableView, Any&lt;UIView, ProtocolA&gt;&gt; or<br>Any&lt;UIScrollView, UITableView, UIView, ProtocolA&gt;<br></p><p>This would force us to allow multiple classes inside Any&lt;…&gt; if there is a inheritance relationship between them.<br></p><p>Yes. As explained in the proposal, there is already a way to handle resolving the single &#39;effective&#39; class constraint. You can only &#39;explicitly&#39; declare one class constraint, but you can pull in other class constraints from nested existentials for the sake of making composition easier. In the end it doesn&#39;t matter, because if the class constraints don&#39;t form a valid inheritance hierarchy the compiler will complain, and if they do the most specific type will be chosen.<br> <br></p><p>And because this is a inheritance relationship it can be simplified to:<br></p><p>Any&lt;UITableView, ProtocolA&gt; which is valid. <br></p><p>And by the way since the order in your proposal would matter, this example won’t work at all, because its not:<br></p><p>Any&lt;UITableView, Any&lt;UIScrollView, Any&lt;UIView, ProtocolA&gt;&gt;&gt; <br></p><p>The order does not affect the semantic meaning of the existential. There is a section in the proposal on how existentials are conceptually &#39;reduced&#39; from whatever form they take when the programmer types them in, please read it. I am not proposing a macro system. The compiler does not do textual replacement in order to flatten nested existential definitions.<br></p><p>This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other generic type or aggregate type in Swift.<br> <br></p><p>In my proposal I explicitly banned multiple reference types and inheritance branches like this. I would need to simplify that type to Any&lt;UITableView, ProtocolA&gt; by myself.<br>Ingeneral this is a good idea, but it makes nesting (with typealiases) almost impossible, when there are some relationship like in the above example.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/1cc5436e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 18.05.2016 um 23:17 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The order does not affect the semantic meaning of the existential. There is a section in the proposal on how existentials are conceptually &#39;reduced&#39; from whatever form they take when the programmer types them in, please read it. I am not proposing a macro system. The compiler does not do textual replacement in order to flatten nested existential definitions.<br>&gt; <br>&gt; This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other generic type or aggregate type in Swift.<br></p><p>Shouldn’t that be a reason to use `any&lt;&gt;` (using a keyword `any`) instead of `Any&lt;&gt;`? Because `Any&lt;&gt;` would just look like/be a generic type with all normal expectations, e.g. `Any&lt;T, U&gt;` would *not* be equal to `Any&lt;U, T&gt;` which is different behavior from `protocol&lt;&gt;`, as I can write <br></p><p>func foo(p: protocol&lt;A, B&gt;) -&gt; protocol&lt;B, A&gt; {<br>    return p<br>}<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/066049fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Can we use `Any&lt;…&gt;` for protocol conformance like this: <br></p><p>protocol A: Any&lt;class&gt; {} &lt;— this makes a little sense, but I’d rather write protocol A: class {} instead<br></p><p>protocol B: Any&lt;UIView, SomeProtocol&gt;  &lt;— this is confusing. One could argue we could apply B only on any UIView subclass which conforms to SomeProtocol, but why can’t we do also this: protocol C: Any&lt;UIView&gt; <br></p><p>One downside here is that `Any&lt;UIView&gt; == UIView` and should be banned because its redundant.<br></p><p>We cannot write something like this:<br></p><p>protocol C: UIView <br></p><p>Or can we?<br></p><p>I’d propose we should ban this in Swift 3. <br>This implies that `typealias AnyObject = Any&lt;class&gt;` won’t work anymore on protocols. This is a breaking change. <br>I’d write a small proposal as another follow up to SE-0095 if my thoughts are right.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/abc0c7cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Actually I’ve done my homework and I can tell you that it will be possible if SE-0095 is accepted.<br></p><p>Here is how to abuse this:<br></p><p>protocol A {}<br>protocol B {}<br></p><p>typealias AB = protocol&lt;A, B&gt;<br></p><p>protocol C: AB {}<br></p><p>That renamed will be:<br></p><p>protocol A {}<br>protocol B {}<br></p><p>typealias AB = Any&lt;A, B&gt;<br></p><p>protocol C: AB {}<br></p><p>Do we need this or should we ban this?<br></p><p>I’m not sure, because we can’t use `Any&lt;…&gt;` directly on a protocol. Using a typealias was a workaround that worked.<br></p><p>If we keep it that way, it will be fine with my proposal of disallowing redundant types `Any&lt;…&gt;` could create: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018280.html<br></p><p>It looks strange if you can only use typealias for that. If we change that so we could use `Any&lt;…&gt;` directly one would ask why can’t we use `Any&lt;UIView&gt;` on protocols? This is a different story, because we never talked if we can build protocols with type requirement.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 15:02:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Can we use `Any&lt;…&gt;` for protocol conformance like this: <br></p><p>protocol A: Any&lt;class&gt; {} &lt;— this makes a little sense, but I’d rather write protocol A: class {} instead<br></p><p>protocol B: Any&lt;UIView, SomeProtocol&gt;  &lt;— this is confusing. One could argue we could apply B only on any UIView subclass which conforms to SomeProtocol, but why can’t we do also this: protocol C: Any&lt;UIView&gt; <br></p><p>One downside here is that `Any&lt;UIView&gt; == UIView` and should be banned because its redundant.<br></p><p>We cannot write something like this:<br></p><p>protocol C: UIView <br></p><p>Or can we?<br></p><p>I’d propose we should ban this in Swift 3. <br>This implies that `typealias AnyObject = Any&lt;class&gt;` won’t work anymore on protocols. This is a breaking change. <br>I’d write a small proposal as another follow up to SE-0095 if my thoughts are right.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/ffccad56/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 20, 2016, at 5:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 18.05.2016 um 23:17 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; The order does not affect the semantic meaning of the existential. There is a section in the proposal on how existentials are conceptually &#39;reduced&#39; from whatever form they take when the programmer types them in, please read it. I am not proposing a macro system. The compiler does not do textual replacement in order to flatten nested existential definitions.<br>&gt;&gt; <br>&gt;&gt; This is also why it makes no sense to have a generic &quot;Any&lt;T, U&gt;&quot;, because such a type is identical to &quot;Any&lt;U, T&gt;&quot;, which is not true for any other generic type or aggregate type in Swift.<br>&gt; <br>&gt; Shouldn’t that be a reason to use `any&lt;&gt;` (using a keyword `any`) instead of `Any&lt;&gt;`? Because `Any&lt;&gt;` would just look like/be a generic type with all normal expectations, e.g. `Any&lt;T, U&gt;` would *not* be equal to `Any&lt;U, T&gt;` which is different behavior from `protocol&lt;&gt;`, as I can write <br>&gt; <br>&gt; func foo(p: protocol&lt;A, B&gt;) -&gt; protocol&lt;B, A&gt; {<br>&gt;     return p<br>&gt; }<br>&gt; <br></p><p>This is a very good point.  +1 to the idea of lowercasing &#39;any&#39;.<br></p><p>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/6ee86f33/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 11:30 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I made heavy revisions to my proposal to reflect all the great feedback I got from you and several other folks (https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;).<br></p><p>Great to see the progress here!  This will be a huge step forward for Swift.  It will be great to get it moving at the beginning of the Swift 4 cycle.<br></p><p>typealias IntCollection = Any&lt;Collection where .Element == Int&gt;<br></p><p>let b : Any&lt;Collection where .Element : Any&lt;IntCollection, Equatatable&gt;&gt;<br></p><p>In order to conform generic collection types to `IntCollection` and `Equatable` we need conditional conformance which we do not currently have.  You should either use a different example or make a comment that this example is hypothetical, assuming that is possible.<br></p><p><br>&gt; <br>&gt; Here are a couple of thoughts:<br>&gt; <br>&gt; - I used &#39;requirements&#39; because that&#39;s how the grammar describes similar constructs elsewhere in Swift. Open to change, though.<br></p><p>Hmm.  I thought we usually speak of “generic constraints” after the where clause.  If I am wrong about this, fair enough.  The important thing is to use terminology consistent with what we use in other places `where` appears.<br></p><p>&gt; <br>&gt; - Having only one where clause makes complete sense. Protocol extensions and generics all use one where clause, so should this construct.<br>&gt; <br>&gt; - The &quot;P can be used in lieu of Any&lt;P&gt;&quot; just means you can declare e.g. &quot;x : Equatable&quot; if you want, instead of &quot;x : Any&lt;Equatable&gt;&quot;, just like you can with protocols without associated types or self requirements today.<br></p><p>Yes, exactly.  And with generalized existentials you should be able to declare `x: Sequence` with no constraints.  <br></p><p>&gt; <br>&gt; - I&#39;ve come to the conclusion that it&#39;s probably best to propose the proposal in the most general form, and allow any reviewers on the core team to excise parts they don&#39;t think are useful enough or are too difficult to implement. In that spirit, the &#39;simple Any&lt;...&gt;&#39; construct is gone and Any usage is fully general.<br></p><p>Great!  I agree with this approach. <br></p><p>&gt; <br>&gt; - I moved discussion of typealiases back into the main protocol, like you said, because typealiases using existentials are *not* actually generic and can be done today.<br>&gt; - I added some stuff about &#39;narrowing&#39; existentials at point of use using as?. This isn&#39;t part of &#39;opening existentials&#39; and should fit in this proposal nicely.<br>&gt; <br>&gt; - I want a type expert to look at the &#39;usage&#39; section, but I&#39;m reasonably sure there&#39;s not much more flexibility we can give the user. Parameter associated types can&#39;t be treated as covariant (they are almost always invariant or contravariant IIRC) and therefore they should only be accessible if fully bound. Return types can be treated as covariant; some languages do and some don&#39;t. (Swift falls into the second bucket.) I would love to be wrong, though.<br></p><p>Yes, what we want here is to give the user the maximum flexibility possible without violating soundness.  Type system experts will have to be involved in determining how to define this precisely.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On May 18, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 18, 2016, at 2:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Thank you for working on this!  Great progress.<br>&gt;&gt; <br>&gt;&gt; Minor nit, but I think the proper word is constraint rather than requirement here:<br>&gt;&gt; <br>&gt;&gt; &quot;Within the angle brackets &lt; and &gt; are zero or more requirements. Requirements are separated by commas.&quot;<br>&gt;&gt; <br>&gt;&gt; Another tweak: <br>&gt;&gt; <br>&gt;&gt; &quot;P can be used in lieu of Any&lt;P&gt;, where P is a protocol with or without associated type or self requirements.&quot;<br>&gt;&gt; <br>&gt;&gt; This proposal is introducing generalized existentials.  P and Any&lt;P&gt; should be interchangeable for any protocol regardless of requirements of the protocol.  Existentials of protocols with self or associated type requirements that do not include constraints will just expose limited direct functionality.  It would still be possible to attempt cast them to concrete types to recover more functionality.  In the future (after a follow on proposal) it will also be possible to open the existential.<br>&gt;&gt; <br>&gt;&gt; Thorsten pointed out that there should only be one where clause for the whole existential.  This follows the structure of generic type and function constraints.  It may also be worth removing the &#39;as&#39; alias from this proposal.  This could be introduced as a stand alone proposal where it would apply to any context with generic constraints.<br>&gt;&gt; <br>&gt;&gt; Another item:<br>&gt;&gt; // NOT ALLOWED let a : Any&lt;Any&lt;ProtocolA, ProtocolB&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Why is this not allowed?  It is pointless, but should be allowed and considered identical to the flattened syntax.<br>&gt;&gt; <br>&gt;&gt; On dynamic casting, I don&#39;t believe it should be restricted in the way you have defined here.  Casting *to* an existential doesn&#39;t have anything to do with opening an existential.  We should allow casting to any existential type.  <br>&gt;&gt; <br>&gt;&gt; On a similar note, I completely disagree with the limitation you specify for use of Any in generic constraints precisely because of your counterargument.  In the discussion about moving the where clause it has been noted that sometime it is necessary to apply a lot of constraints to get the necessary effect.  A mechanism for factoring constraints is highly desirable and will greatly improve the readability of generic code.  Typealiases bound to Any can provide such a mechanism.  Let&#39;s not artificially restrict the use of it.<br>&gt;&gt; <br>&gt;&gt; The section regarding members of a partly constrained existential needs to be more fleshed out.  We can&#39;t simply punt it to a future proposal.  However, I do think it is a good idea to wait until the core team has time to participate in the discussion.<br>&gt;&gt; <br>&gt;&gt; The section about defining typealias also should not be left to the future.  It is possible to define typealias with protocol&lt;&gt; today and to use that alias in a generic constraint.  Removing that capability would be a regression.  In fact, it&#39;s utility will increase significantly with this proposal.<br>&gt;&gt; <br>&gt;&gt; In general, I don&#39;t think we need the distinction between simple and full Any.  The whole idea of this proposal IMO should be fully generalizing existentials.  If restrictions are necessary they should be due to (hopefully temporary) implementation considerations.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/111540c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt; <br>&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br></p><p>This is very much Swift 4 territory, but I can’t help myself… so…<br></p><p>The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br></p><p>Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br></p><p>// Okay<br>// Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br></p><p>// NOT ALLOWED<br>// Both Collection and OptionSetType have associated types.<br>let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br></p><p>Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br></p><p>“Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br></p><p>“Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br></p><p>	let x: Equatable = …<br>	let y: Equatable = …<br>	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br></p><p>which is (almost?) as powerful as a general “open” expression.<br></p><p>I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br></p><p>FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br></p><p>I was a little surprised you didn’t point out that AnyObject could become<br></p><p>	typealias AnyObject = Any&lt;class&gt;<br></p><p>or give the nice “AnyCollection” syntax:<br></p><p>	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br></p><p>the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br></p><p>	- Doug<br></p><p>[*] That generally comes in as “Swift should have parameterized protocols…”<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt; <br>&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt; <br>&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt; <br>&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;  <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt; <br>&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt; <br>&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt; <br>&gt; Absolutely.<br>&gt;  <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt; <br>&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;  <br>&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt; <br>&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt; <br>&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt; <br>&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt; <br>&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt; <br>&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt; <br>&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt; <br>&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt; <br>&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt; <br>&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt; <br>&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt; <br>&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt; <br>&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;  <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt; <br>&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt; <br>&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt; <br>&gt; Another result of rushing to compose an email. Sorry!<br>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt; <br>&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt; <br>&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt; <br>&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt; <br>&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt; <br>&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt; <br>&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt; <br>&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt; <br>&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt; <br>&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt; <br>&gt; A simple example of what I was referring to there is something like this:<br>&gt; <br>&gt; protocol P {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt; }<br>&gt; <br>&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt; <br>&gt; Yes. I have some ideas regarding this topic.<br>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt; <br>&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt; <br>&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt; <br>&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/44f2136b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt; <br>&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt; <br>&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt; <br>&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt; <br>&gt; // Okay<br>&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; // Both Collection and OptionSetType have associated types.<br>&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt; <br>&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt; <br>&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt; <br>&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt; <br>&gt; 	let x: Equatable = …<br>&gt; 	let y: Equatable = …<br>&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt; <br>&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt; <br>&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt; <br>&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt; <br>&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt; <br>&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt; <br>&gt; or give the nice “AnyCollection” syntax:<br>&gt; <br>&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt; <br>&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br></p><p>Great feedback here Doug.<br></p><p>FWIW, we also occasionally get &quot;Swift should have parameterized protocols&quot; in the context of multiple conformances by the same concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/c075f2e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  5, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt; <br>&gt;&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt;&gt; <br>&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt; <br>&gt;&gt; // Okay<br>&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt; <br>&gt;&gt; // NOT ALLOWED<br>&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt;&gt; <br>&gt;&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt;&gt; <br>&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt; <br>&gt;&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	let x: Equatable = …<br>&gt;&gt; 	let y: Equatable = …<br>&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt; <br>&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt; <br>&gt;&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt;&gt; <br>&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt;&gt; <br>&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt; <br>&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt; <br>&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt; <br>&gt;&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt; <br>&gt; Great feedback here Doug.<br>&gt; <br>&gt; FWIW, we also occasionally get &quot;Swift should have parameterized protocols&quot; in the context of multiple conformances by the same concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br></p><p>I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for &quot;any collection of some element type&quot; as for any actually reason why one would need parameterize a protocols. <br></p><p>  - Doug<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/43cac94f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you for your feedback, Doug! I appreciate you taking the time to read<br>through everything and write up your thoughts. I&#39;ll revise the proposal and<br>plan for a 2017 time frame.<br></p><p>I would also be happy to see someone from the core team write up a proposal<br>when the time is right, should they feel this one isn&#39;t in the spirit of<br>the desired feature.<br></p><p>Austin<br></p><p>On Sun, Jun 5, 2016 at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into<br>&gt; account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;<br>&gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;<br>&gt; Since there is no chance this will come up for review anytime soon, I<br>&gt; expect to make significant revisions to it over the next month or so. Any<br>&gt; feedback would be greatly appreciated.<br>&gt;<br>&gt;<br>&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;<br>&gt; The actual feature description is spread out through this very long<br>&gt; document, with user-facing ideas (e.g., using “anonymous associated types”)<br>&gt; intermixed with deeper technical details (existential type equivalence), so<br>&gt; it’s very daunting to read. Please bring the user-facing features to the<br>&gt; front (“Proposed Solution”) with examples, and save the deeper technical<br>&gt; details for “Detailed Design”. You want more readers to make it through the<br>&gt; part that affects them.<br>&gt;<br>&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated<br>&gt; types specified in the requirements, and there are no nested Any&lt;...&gt; requirements<br>&gt; with where clauses of their own, that protocol&#39;s name can be omitted from<br>&gt; the whereclause constraints:<br>&gt;<br>&gt; // Okay// Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt; // NOT ALLOWED// Both Collection and OptionSetType have associated types.let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;<br>&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic<br>&gt; signatures, if you have two different protocols with same-named associated<br>&gt; types, and a given type parameter (or associated type) conforms to both<br>&gt; protocols, the associated types are (implicitly) made equivalent via an<br>&gt; inferred same-type constraint. So there’s no reason to introduce the<br>&gt; “Collection.Element == Int” syntax, because the “Collection” part is<br>&gt; basically irrelevant.<br>&gt;<br>&gt; Once existentials have been suitably enhanced, there is a strong analogy<br>&gt; between an existential and a generic signature with a single type parameter<br>&gt; that you can’t name. An existential Any&lt;Collection where .Element :<br>&gt; Equatable&gt; has most of the same characteristics as a generic something with<br>&gt; the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically,<br>&gt; the sections on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt; anonymous associated types”, “Anonymous associated types to real types”.<br>&gt; could be reduced to a few small, simple examples and a mention of the<br>&gt; analogous behavior of generics. It will be far easier to explain this way,<br>&gt; and readers don’t need to get immersed in the details. Where there are<br>&gt; differences vs. generics, that’s important to point out.<br>&gt;<br>&gt; “Associated typealias rewriting”: this also falls out of the equivalence<br>&gt; with generics + SE-0092.<br>&gt;<br>&gt; “Associated types and member exposure”: you don’t make the point that it<br>&gt; only makes sense to refer to the associated types of a *let* constant; a<br>&gt; *var* could change its type dynamically, which would invalidate the<br>&gt; typing rules. Did you consider just using “x.dynamicType” in the type<br>&gt; grammar for this? It’s more general, in that you can refer to associated<br>&gt; types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt;<br>&gt; let x: Equatable = …<br>&gt; let y: Equatable = …<br>&gt; if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;<br>&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;<br>&gt; I’m not a fan of the “anonymous associated types” terminology: these are<br>&gt; associated types of a type of some runtime-defined value. The only thing<br>&gt; “anonymous” about them is that it’s harder to spell the base type;<br>&gt; otherwise, they’re just like associated types of a generic type parameter.<br>&gt; Again, the generics analogy is strong here.<br>&gt;<br>&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what<br>&gt; you’ve described here. Also, remember that a method of a protocol extension<br>&gt; essentially opens “Self”, so we already have one way to open an existential<br>&gt; (and that’s probably enough).<br>&gt;<br>&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;<br>&gt; typealias AnyObject = Any&lt;class&gt;<br>&gt;<br>&gt; or give the nice “AnyCollection” syntax:<br>&gt;<br>&gt; typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;<br>&gt; the latter of which is fairly important, because it gives nice syntactic<br>&gt; sure to one of the most highly-requested features [*]. I’d suggest having<br>&gt; that example very, very early.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are<br>&gt;&gt;&gt;&gt; separated by semicolons. (This is so commas can be used in where<br>&gt;&gt;&gt;&gt; constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we<br>&gt;&gt;&gt;&gt; can use commas exclusively.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.<br>&gt;&gt;&gt;&gt; The `where` keyword separates the protocol list from the constraints just<br>&gt;&gt;&gt;&gt; fine.  The list on either side should be able to use commas with no problem<br>&gt;&gt;&gt;&gt; (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write<br>&gt;&gt;&gt; out a few &#39;dummy&#39; examples to see if there are any readability issues that<br>&gt;&gt;&gt; arise.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work<br>&gt;&gt;&gt; for the protocol list but it feels inconsistent with the rest of Swift.<br>&gt;&gt;&gt; Commas plus (hopefully) the alternative of newline seem like the right<br>&gt;&gt;&gt; direction to me.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of<br>&gt;&gt; the semicolons and use commas. I&#39;ve come to the conclusion that there are<br>&gt;&gt; no readability issues, protocol&lt;&gt; already uses commas, and semicolons used<br>&gt;&gt; in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - &#39;class&#39;. Must be the first clause, if present. Places a<br>&gt;&gt;&gt;&gt;    constraint on the existential to be any class type. (Implies: Only one can<br>&gt;&gt;&gt;&gt;    exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39;<br>&gt;&gt;&gt;&gt; as a counterpart.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value`<br>&gt;&gt;&gt;&gt; would allow either of those.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact<br>&gt;&gt;&gt; details as to how struct, value, or enum specifiers should work.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we<br>&gt;&gt;&gt; should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Absolutely.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Class name. Must be the first clause, if present. (Implies: Only<br>&gt;&gt;&gt;&gt;    one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the<br>&gt;&gt;&gt;&gt;    existential (not really an existential anymore) to be an instance of the<br>&gt;&gt;&gt;&gt;    class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that<br>&gt;&gt;&gt;&gt; the class does not fulfill.  For example, you might have Any&lt;UIView,<br>&gt;&gt;&gt;&gt; SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various<br>&gt;&gt;&gt;&gt; subclasses do.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s<br>&gt;&gt;&gt;&gt; did like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type<br>&gt;&gt;&gt; is a type &#39;expression&#39; just like any other, and should be allowed to<br>&gt;&gt;&gt; participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out<br>&gt;&gt;&gt;&gt; constraints.  If we are going to do that we should allow a class to be<br>&gt;&gt;&gt;&gt; specified in the composition as long is it is a subclass of all class<br>&gt;&gt;&gt;&gt; requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class<br>&gt;&gt;&gt;&gt; requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a good point. There should be clarification as to how special<br>&gt;&gt;&gt; cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you<br>&gt;&gt;&gt; said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid.<br>&gt;&gt;&gt; This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also<br>&gt;&gt;&gt; cases of incompatible associated type constraints which need to be rejected<br>&gt;&gt;&gt; (such as composing two Any’s where one has Element == String and another<br>&gt;&gt;&gt; has Element == Int).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource;<br>&gt;&gt;&gt;&gt; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view<br>&gt;&gt;&gt;&gt; data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Dynamic protocol. This is entirely composed of the name of a<br>&gt;&gt;&gt;&gt;    protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and<br>&gt;&gt;&gt;&gt; BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with<br>&gt;&gt;&gt;&gt; associated types or self requirements. Feel free to propose a more sound<br>&gt;&gt;&gt;&gt; name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Self-contained static protocol, simple. This is composed of the<br>&gt;&gt;&gt;&gt;    name of a static protocol, optionally followed by a &#39;where&#39; clause in which<br>&gt;&gt;&gt;&gt;    the associated types can be constrained (with any of the three basic<br>&gt;&gt;&gt;&gt;    conformance types: subclassing, protocol conformance, or type equality).<br>&gt;&gt;&gt;&gt;    Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static<br>&gt;&gt;&gt;&gt; protocol”.  We want to support existentials of protocols that have self or<br>&gt;&gt;&gt;&gt; associated type requirements.  The dynamic vs static distinction is a<br>&gt;&gt;&gt;&gt; limitation of the current implementation of Swift and doesn’t make sense<br>&gt;&gt;&gt;&gt; for the long term vision.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At<br>&gt;&gt;&gt; the same time &quot;protocols with self or associated type requirements&quot; is<br>&gt;&gt;&gt; cumbersome to work with and it would be nice for someone to come up with a<br>&gt;&gt;&gt; descriptive term of art for referring to them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would<br>&gt;&gt;&gt; prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with<br>&gt;&gt; better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject,<br>&gt;&gt;&gt;&gt; .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their<br>&gt;&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions<br>&gt;&gt;&gt;&gt; are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects *and* their<br>&gt;&gt;&gt;&gt; subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their<br>&gt;&gt;&gt; subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence<br>&gt;&gt; could be ambiguously parsed.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Bound static protocol. This is the same as a self-contained<br>&gt;&gt;&gt;&gt;    static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol<br>&gt;&gt;&gt;&gt;    to a generic typealias. The name can be then be used in subsequent clauses<br>&gt;&gt;&gt;&gt;    to build constraints.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where<br>&gt;&gt;&gt;&gt; .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer<br>&gt;&gt;&gt;&gt; literal, in which the collection elements are the same type as the type of<br>&gt;&gt;&gt;&gt; the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the<br>&gt;&gt;&gt;&gt; other way around: `Collection as T` with the alias *after* the name of<br>&gt;&gt;&gt;&gt; the protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int,<br>&gt;&gt;&gt; Protocol.Bar : Baz”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean<br>&gt;&gt;&gt; &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type<br>&gt;&gt;&gt;&gt; of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to<br>&gt;&gt;&gt;&gt; cases where there is only one protocol that is getting constrained.  In<br>&gt;&gt;&gt;&gt; other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right,<br>&gt;&gt;&gt; it should only be allowed if there is one protocol with associated types or<br>&gt;&gt;&gt; self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and<br>&gt;&gt;&gt; possibly even to one protocol and no type names (as types can have nested<br>&gt;&gt;&gt; types and typealiases).  When we allow shorthand it should be immediately<br>&gt;&gt;&gt; unambiguous what the shorthand references with no need to look at type or<br>&gt;&gt;&gt; protocol declarations.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It might be desirable to propose the proposal with no allowance for<br>&gt;&gt; shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if<br>&gt;&gt;&gt;&gt; generic typealiases are allowed, they cannot refer to each other in a<br>&gt;&gt;&gt;&gt; circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t<br>&gt;&gt;&gt;&gt; create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided<br>&gt;&gt;&gt;&gt; by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if<br>&gt;&gt;&gt;&gt; there were any methods on Equatable that did not use the associated types<br>&gt;&gt;&gt;&gt; at all you&#39;d be able to call them, but that&#39;s about it. However,<br>&gt;&gt;&gt;&gt; &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on<br>&gt;&gt;&gt;&gt; instances. (This is a stupid example, since Any&lt;Equatable where .Self ==<br>&gt;&gt;&gt;&gt; String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful<br>&gt;&gt;&gt;&gt; examples one could come up with.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Don&#39;t constrain any associated types. You can pass around<br>&gt;&gt;&gt;&gt;    Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;    - Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;    - Fully constrain associated types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to<br>&gt;&gt;&gt;&gt; be available or not available.  This section probably needs the most design<br>&gt;&gt;&gt;&gt; and elaboration.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated<br>&gt;&gt;&gt;&gt; type as an input unless it is constrained to a specific type.  On the other<br>&gt;&gt;&gt;&gt; hand output types probably don’t need to limit access to a member.<br>&gt;&gt;&gt;&gt; However, if the output type is Self or an associated type the visible<br>&gt;&gt;&gt;&gt; signature would have an output type which has the relevant constraints of<br>&gt;&gt;&gt;&gt; the existential applied, but no more.  In some cases this means the output<br>&gt;&gt;&gt;&gt; type would simply be Any.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get<br>&gt;&gt;&gt; something down first. Thanks for thinking through some of the implications<br>&gt;&gt;&gt; :).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating<br>&gt;&gt;&gt; expectations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions,<br>&gt;&gt;&gt;&gt; generic types, etc.  Working out the details in these cases is pretty<br>&gt;&gt;&gt;&gt; complex.  I will defer to Doug on whether it is best to just defer those<br>&gt;&gt;&gt;&gt; cases to the future, leave them up to the implementer, or try to work out<br>&gt;&gt;&gt;&gt; all of the relevant details in the proposal (in which case we probably need<br>&gt;&gt;&gt;&gt; a type system expert to help!).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols<br>&gt;&gt;&gt; with associated types or self requirements be used within generic function<br>&gt;&gt;&gt; or type definitions? Maybe there&#39;s an argument that existential types of<br>&gt;&gt;&gt; this nature are redundant if you have access to generics (e.g. defining a<br>&gt;&gt;&gt; property on a generic type that is a Collection containing Ints; you should<br>&gt;&gt;&gt; be able to do that today). On the other hand, maybe there are use cases I<br>&gt;&gt;&gt; haven&#39;t thought of…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For<br>&gt;&gt;&gt; example, you may want to store instances in a heterogeneous collection.<br>&gt;&gt;&gt; You need existentials to do that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex<br>&gt;&gt;&gt; types that reference Self or associated types.  I think you really need a<br>&gt;&gt;&gt; formal understanding of the type system to understand how to expose these<br>&gt;&gt;&gt; members through a constrained existential.  We can probably understand the<br>&gt;&gt;&gt; expected behavior in some of the simpler cases on a case by case basis, but<br>&gt;&gt;&gt; that approach doesn’t scale at all and is arbitrary.  If they’re going to<br>&gt;&gt;&gt; be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out<br>&gt;&gt;&gt;&gt; of scope for this proposal?  That would be fine with me as this proposal is<br>&gt;&gt;&gt;&gt; already taking on a lot.  But if so, you should mention something about<br>&gt;&gt;&gt;&gt; future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I<br>&gt;&gt;&gt; wanted to mention it in the section where I talk about how Any&lt;Equatable&gt;<br>&gt;&gt;&gt; is not very useful). But you are absolutely right, this proposal should<br>&gt;&gt;&gt; discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and<br>&gt;&gt;&gt;&gt; typealiases referring to them) should be usable as generic constraints.  I<br>&gt;&gt;&gt;&gt; would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some<br>&gt;&gt;&gt; point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of<br>&gt;&gt;&gt; the Any into the list of generic constraints.  Maybe I’m missing something,<br>&gt;&gt;&gt; but I don’t think so.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/d23a7a5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 5, 2016, at 7:02 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thank you for your feedback, Doug! I appreciate you taking the time to read through everything and write up your thoughts. I&#39;ll revise the proposal and plan for a 2017 time frame.<br></p><p>It should be sooner than that. <br></p><p>&gt; I would also be happy to see someone from the core team write up a proposal when the time is right, should they feel this one isn&#39;t in the spirit of the desired feature.<br></p><p>I think you&#39;re on the right track and don&#39;t want to duplicate effort. <br></p><p>  - Doug<br></p><p>&gt; Austin<br>&gt; <br>&gt;&gt; On Sun, Jun 5, 2016 at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt; <br>&gt;&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt;&gt; <br>&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt; <br>&gt;&gt; // Okay<br>&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt; <br>&gt;&gt; // NOT ALLOWED<br>&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt;&gt; <br>&gt;&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt;&gt; <br>&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt; <br>&gt;&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	let x: Equatable = …<br>&gt;&gt; 	let y: Equatable = …<br>&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt; <br>&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt; <br>&gt;&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt;&gt; <br>&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt;&gt; <br>&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt; <br>&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt; <br>&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt; <br>&gt;&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/2362e857/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 08:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br>&gt; On Jun 6, 2016, at 1:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt; <br>&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt; <br>&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read.<br></p><p>My reading was further complicated by the fact that some of these details seemed incomplete or predicated on different mechanisms than what I have gathered of the current compiler&#39;s inners, leaving me to wonder in what manner they constitute a proposal for changing them.<br></p><p>&gt; Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt; <br>&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt; <br>&gt; // Okay<br>&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; // Both Collection and OptionSetType have associated types.<br>&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt; <br>&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics.<br></p><p>The &quot;member exposure&quot; section would also have made it to this list (statements like &#39;Their metatypes are also available, although subject to the same restrictions as the types themselves&#39; is an example of what felt incomplete in the context it was presented in). <br></p><p>&gt; It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt; <br>&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt; <br>&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt; <br>&gt; 	let x: Equatable = …<br>&gt; 	let y: Equatable = …<br>&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt; <br>&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt; <br>&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br></p><p>Isn&#39;t an &#39;anonymous associated type&#39; as presented synonymous for &#39;an existential type used in the position of associated type to another existential type&#39;? The section on &#39;anonymous associated types to real type&#39; would become partially redundant with the general notion of existentials, baring a few possible extra usage limitations.<br></p><p>&gt; <br>&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt; <br>&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt; <br>&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt; <br>&gt; or give the nice “AnyCollection” syntax:<br>&gt; <br>&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt; <br>&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br></p><p>I am unclear about the Metatype section. I was under the impressions that all reflective knownledge of a given type was esposed via Mirrors.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/b7da5370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 11:27 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; On Jun 6, 2016, at 1:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt; […]<br>&gt;&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt; <br>&gt; Isn&#39;t an &#39;anonymous associated type&#39; as presented synonymous for &#39;an existential type used in the position of associated type to another existential type’?<br></p><p>Somewhat. I find it confusing even to talk about it as being “existential”, because it’s not like “x.Index” is any type at run-time: it’s a particular associated type for the runtime type of the existential value “x”. Thinking of it more like a type “T.Index”, where T is effectively a generic parameter describing the runtime type of “x” that cannot really be named directly, makes it fit into a framework I can understand.<br></p><p>It also happens to precisely match the implementation model we’re using for existentials in the compiler, so perhaps I’m biased :)<br></p><p>&gt; The section on &#39;anonymous associated types to real type&#39; would become partially redundant with the general notion of existentials, baring a few possible extra usage limitations.<br></p><p>That’s what I expect, yeah.<br></p><p>&gt;&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt; <br>&gt; I am unclear about the Metatype section. I was under the impressions that all reflective knownledge of a given type was esposed via Mirrors.<br></p><p>The Metatype section could probably use examples—again, I think it mostly falls out from the analogy with generics. If the protocol has static methods/properties or initializers, those are operations on the metatype.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/24b510a5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 10, 2016 at 01:00:00pm</p></header><div class="content"><p>an alternative to the Any&lt;&gt; syntax with tentative grammar and some examples (still a WIP)<br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p><br>&gt; On Jun 6, 2016, at 1:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt; <br>&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt; <br>&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt; <br>&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt; <br>&gt; // Okay<br>&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; // Both Collection and OptionSetType have associated types.<br>&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt; <br>&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt; <br>&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt; <br>&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt; <br>&gt; 	let x: Equatable = …<br>&gt; 	let y: Equatable = …<br>&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt; <br>&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt; <br>&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt; <br>&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt; <br>&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt; <br>&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt; <br>&gt; or give the nice “AnyCollection” syntax:<br>&gt; <br>&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt; <br>&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 9:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt; <br>&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt; <br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are five different possible clauses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;class&#39;. Must be the first clause, if present. Places a constraint on the existential to be any class type. (Implies: Only one can exist. Mutually exclusive with class name clause.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (In the future a follow-up proposal should add in &#39;struct&#39; or &#39;value&#39; as a counterpart.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we’re going to allow `struct` we should also allow `enum`.  `value` would allow either of those.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course. A future proposal can allow list members to discuss the exact details as to how struct, value, or enum specifiers should work. <br>&gt;&gt; <br>&gt;&gt; Yep, agree.  Just mentioning that if we’re going to reference it we should not leave obvious holes in what would be considered.  :)<br>&gt;&gt; <br>&gt;&gt; Absolutely.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Class name. Must be the first clause, if present. (Implies: Only one can exist. Mutually exclusive with &#39;class&#39;.) Places a constraint on the existential (not really an existential anymore) to be an instance of the class, or one of its subclasses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is still be an existential if it includes protocol requirements that the class does not fulfill.  For example, you might have Any&lt;UIView, SomeProtocol&gt; where UIView does not conform to SomeProtocol, but various subclasses do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough. (I don&#39;t think the way things work would be affected.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your proposal doesn’t discuss composing Any in the way that Adrian’s did like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Foo = Any&lt;SomeClass, SomeProtocol, OtherProtocol&gt;<br>&gt;&gt;&gt; Any&lt;AnotherProtocol, Foo&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t think it needed to be discussed. An Any&lt;...&gt; existential type is a type &#39;expression&#39; just like any other, and should be allowed to participate in other Any&lt;...&gt;s.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of composition as it allows us to factor out constraints.  If we are going to do that we should allow a class to be specified in the composition as long is it is a subclass of all class requirements of Any types it composes.  For example, this should be allowed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Bar = Any&lt;SubclassOfSomeClass, Foo, AnotherProtocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is still one class requirement for Bar, it just refines the class requirement of Foo to be SubclassOfSomeClass rather than just SomeClass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a good point. There should be clarification as to how special cases of Any&lt;...&gt; used in another Any&lt;...&gt; behave. For example, like you said Any&lt;MyClass, Any&lt;SomeSubclassOfMyClass, Protocol&gt;&gt; should be valid. This will go into any proposal that emerges from the discussion.<br>&gt;&gt; <br>&gt;&gt; Yes, this is why we need to discuss Any composition.  There are also cases of incompatible associated type constraints which need to be rejected (such as composing two Any’s where one has Element == String and another has Element == Int).<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;UIViewController; UITableViewDataSource; UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; &quot;Any UIViewController or subclass which also satisfies the table view data source and delegate protocols&quot;<br>&gt;&gt;&gt;&gt; Dynamic protocol. This is entirely composed of the name of a protocol which has no associated types or Self requirement.<br>&gt;&gt;&gt;&gt; Example: Any&lt;CustomStringConvertible; BooleanType&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type which conforms to both the CustomStringConvertible and BooleanType protocols&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to use &#39;static protocol&#39; to refer to a protocol with associated types or self requirements. Feel free to propose a more sound name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Self-contained static protocol, simple. This is composed of the name of a static protocol, optionally followed by a &#39;where&#39; clause in which the associated types can be constrained (with any of the three basic conformance types: subclassing, protocol conformance, or type equality). Associated types are referred to with a leading dot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please do not introduce terms “dynamic protocol” and “static protocol”.  We want to support existentials of protocols that have self or associated type requirements.  The dynamic vs static distinction is a limitation of the current implementation of Swift and doesn’t make sense for the long term vision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not trying to introduce new terms, these are just placeholders. At the same time &quot;protocols with self or associated type requirements&quot; is cumbersome to work with and it would be nice for someone to come up with a descriptive term of art for referring to them.<br>&gt;&gt; <br>&gt;&gt; I agree that a better term would be useful.  In the meantime, I would prefer something like “trivial” and “nontrivial” protocols.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve decided to just use the full name until the community comes up with better names. Clarity is preferable to brevity in this case.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;Collection where .Generator.Element : NSObject, .Generator.Element : SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects or their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not allow disjunction of requirements.  Only conjunctions are supported.  That means the correct reading is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Any type that is a Collection, whose elements are NSObjects and their subclasses conforming to SomeProtocol.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that is what I meant. &quot;whose elements are (NSObjects or their subclasses) conforming to SomeProtocol”.<br>&gt;&gt; <br>&gt;&gt; Ok, good.  Wasn’t quite clear to me.<br>&gt;&gt; <br>&gt;&gt; Yes, the verbiage will need to be clearer in the future. That sentence could be ambiguously parsed.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Bound static protocol. This is the same as a self-contained static protocol, but with a leading &quot;&lt;name&gt; as &quot; which binds the protocol to a generic typealias. The name can be then be used in subsequent clauses to build constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: Any&lt;T as Collection; IntegerLiteralConvertible where .IntegerLiteralType == T.Element&gt;.<br>&gt;&gt;&gt;&gt; &quot;Any type that is a Collection, and also can be built from an integer literal, in which the collection elements are the same type as the type of the integer used for the integer literal conformance.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure about this, but if we’re going to do it it should be the other way around: `Collection as T` with the alias after the name of the protocol.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this, it flows better. &quot;Protocol as T where Protocol.Foo == Int, Protocol.Bar : Baz”.<br>&gt;&gt; <br>&gt;&gt; Why did you introduce an alias here and then not use it?  Did you mean &quot;Protocol as T where T.Foo == Int, T.Bar : Baz&quot;<br>&gt;&gt; <br>&gt;&gt; Another result of rushing to compose an email. Sorry!<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; You are also using “dot shorthand” here to refer to an associated type of IntegerLiteralConvertible.  I think “dot shorthand” should be limited to cases where there is only one protocol that is getting constrained.  In other cases, we need to be clear about which protocol we are referring to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I borrowed dot shorthand from the generics manifesto. But you are right, it should only be allowed if there is one protocol with associated types or self requirements clause in the Any&lt;...&gt; construction.<br>&gt;&gt; <br>&gt;&gt; I would actually go further and limit it to one protocol period, and possibly even to one protocol and no type names (as types can have nested types and typealiases).  When we allow shorthand it should be immediately unambiguous what the shorthand references with no need to look at type or protocol declarations.<br>&gt;&gt; <br>&gt;&gt; It might be desirable to propose the proposal with no allowance for shorthand, and have the dot shorthand be a smaller follow-up proposal.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There will be rules to prevent recursive nesting. For example, if generic typealiases are allowed, they cannot refer to each other in a circular manner (like how structs can&#39;t contain themeselves, and you can&#39;t create a cyclic graph of enums containing themselves).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How an existential can be used depends on what guarantees are provided by the clauses. For example, &#39;Any&lt;Equatable&gt;&#39; can&#39;t be used for much; if there were any methods on Equatable that did not use the associated types at all you&#39;d be able to call them, but that&#39;s about it. However, &#39;Any&lt;Equatable where .Self == String&gt;&#39; would allow for == to be called on instances. (This is a stupid example, since Any&lt;Equatable where .Self == String&gt; is equivalent to &#39;String&#39;, but there are almost certainly useful examples one could come up with.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order of increasing &#39;power&#39;:<br>&gt;&gt;&gt;&gt; Don&#39;t constrain any associated types. You can pass around Any&lt;Equatable&gt;s, but that&#39;s about it.<br>&gt;&gt;&gt;&gt; Constrain associated types to conform to protocols.<br>&gt;&gt;&gt;&gt; Fully constrain associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we need to spell out pretty clearly what members we expect to be available or not available.  This section probably needs the most design and elaboration.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, we probably can’t access a member who uses an associated type as an input unless it is constrained to a specific type.  On the other hand output types probably don’t need to limit access to a member.  However, if the output type is Self or an associated type the visible signature would have an output type which has the relevant constraints of the existential applied, but no more.  In some cases this means the output type would simply be Any.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely. This is vaguely what I had in mind but I wanted to get something down first. Thanks for thinking through some of the implications :).<br>&gt;&gt; <br>&gt;&gt; That’s what I thought.  Just wanted to start the process of elaborating expectations.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where this really gets tricky is for compound types like functions, generic types, etc.  Working out the details in these cases is pretty complex.  I will defer to Doug on whether it is best to just defer those cases to the future, leave them up to the implementer, or try to work out all of the relevant details in the proposal (in which case we probably need a type system expert to help!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, exactly! For example, can Any&lt;...&gt; existentials involving protocols with associated types or self requirements be used within generic function or type definitions? Maybe there&#39;s an argument that existential types of this nature are redundant if you have access to generics (e.g. defining a property on a generic type that is a Collection containing Ints; you should be able to do that today). On the other hand, maybe there are use cases I haven&#39;t thought of…<br>&gt;&gt; <br>&gt;&gt; I see no reason they shouldn’t be.  They are not redundant at all.  For example, you may want to store instances in a heterogeneous collection.  You need existentials to do that.<br>&gt;&gt; <br>&gt;&gt; A simple example of what I was referring to there is something like this:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; <br>&gt;&gt;     func bar(callback: (Foo) -&gt; ())<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In other words, types in the signature of a protocol member are complex types that reference Self or associated types.  I think you really need a formal understanding of the type system to understand how to expose these members through a constrained existential.  We can probably understand the expected behavior in some of the simpler cases on a case by case basis, but that approach doesn’t scale at all and is arbitrary.  If they’re going to be supported an expert is going to need to be involved in the design.<br>&gt;&gt; <br>&gt;&gt; Yes. I have some ideas regarding this topic.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One area you didn’t touch on is “opening” the existential?  Is that out of scope for this proposal?  That would be fine with me as this proposal is already taking on a lot.  But if so, you should mention something about future directions as it is pretty closely related to this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, existential opening is explicitly separate from this (although I wanted to mention it in the section where I talk about how Any&lt;Equatable&gt; is not very useful). But you are absolutely right, this proposal should discuss how it wants to interact with possible future directions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another area you didn’t touch on is whether Any constructs (and typealiases referring to them) should be usable as generic constraints.  I would expect this to be possible but I think we need to spell it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m hoping for community input. This is a tricky subject, and at some point we&#39;ll bump into implementation limitations.<br>&gt;&gt; <br>&gt;&gt; I don’t think it’s too tricky.  You can just unpack the constraints of the Any into the list of generic constraints.  Maybe I’m missing something, but I don’t think so.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/b814812e/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 17, 2016 at 11:00:00pm</p></header><div class="content"><p>added a few comments to https://gist.github.com/lmihalkovic/68c321ea7ffe27e553e37b794309b051 to clarify the rational. it is by no mean the only way or a good way, but IMO there are far worse ways to do the same.<br></p><p><br>&gt; On Jun 6, 2016, at 1:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal, taking into account as much of Matthew&#39;s feedback as I could. You can find it below:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br>&gt;&gt; <br>&gt;&gt; Since there is no chance this will come up for review anytime soon, I expect to make significant revisions to it over the next month or so. Any feedback would be greatly appreciated.<br>&gt; <br>&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt; <br>&gt; The actual feature description is spread out through this very long document, with user-facing ideas (e.g., using “anonymous associated types”) intermixed with deeper technical details (existential type equivalence), so it’s very daunting to read. Please bring the user-facing features to the front (“Proposed Solution”) with examples, and save the deeper technical details for “Detailed Design”. You want more readers to make it through the part that affects them.<br>&gt; <br>&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with associated types specified in the requirements, and there are no nested Any&lt;...&gt; requirements with where clauses of their own, that protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt; <br>&gt; // Okay<br>&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt; <br>&gt; // NOT ALLOWED<br>&gt; // Both Collection and OptionSetType have associated types.<br>&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt; FWIW, I think “.Element == Int” should be the only syntax. In generic signatures, if you have two different protocols with same-named associated types, and a given type parameter (or associated type) conforms to both protocols, the associated types are (implicitly) made equivalent via an inferred same-type constraint. So there’s no reason to introduce the “Collection.Element == Int” syntax, because the “Collection” part is basically irrelevant.<br>&gt; <br>&gt; Once existentials have been suitably enhanced, there is a strong analogy between an existential and a generic signature with a single type parameter that you can’t name. An existential Any&lt;Collection where .Element : Equatable&gt; has most of the same characteristics as a generic something with the signature &lt;T : Collection where T.Element : Equatable&gt;. Specifically, the sections on “Existential type equivalence”, “Ordering”, “Real types to anonymous associated types”, “Anonymous associated types to real types”. could be reduced to a few small, simple examples and a mention of the analogous behavior of generics. It will be far easier to explain this way, and readers don’t need to get immersed in the details. Where there are differences vs. generics, that’s important to point out.<br>&gt; <br>&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt; <br>&gt; “Associated types and member exposure”: you don’t make the point that it only makes sense to refer to the associated types of a let constant; a var could change its type dynamically, which would invalidate the typing rules. Did you consider just using “x.dynamicType” in the type grammar for this? It’s more general, in that you can refer to associated types but also talk about the dynamic type of “x” itself, e.g.,<br>&gt; <br>&gt; 	let x: Equatable = …<br>&gt; 	let y: Equatable = …<br>&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt; <br>&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt; <br>&gt; I’m not a fan of the “anonymous associated types” terminology: these are associated types of a type of some runtime-defined value. The only thing “anonymous” about them is that it’s harder to spell the base type; otherwise, they’re just like associated types of a generic type parameter. Again, the generics analogy is strong here.<br>&gt; <br>&gt; FWIW, I don’t think we’ll ever need “opening existentials” with what you’ve described here. Also, remember that a method of a protocol extension essentially opens “Self”, so we already have one way to open an existential (and that’s probably enough).<br>&gt; <br>&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt; <br>&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt; <br>&gt; or give the nice “AnyCollection” syntax:<br>&gt; <br>&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt; <br>&gt; the latter of which is fairly important, because it gives nice syntactic sure to one of the most highly-requested features [*]. I’d suggest having that example very, very early.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt; <br></p><p><br>@doug : watched and very much appreciated your presentation on what makes a good API… reminded me of a job interview with Bertand Serlet a few years ago.. you guys have managed to remain very consistent over a very long period of time, and it looks like Swift is following in the foot-steps.  <br> <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/12f6968f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 18.05.2016 um 06:52 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt; <br>&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt; <br>&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br></p><p>Shouldn&#39;t there be just a single `where` in the whole `Any&lt;&gt;` clause, separating the constraints on the type itself from the constraints on associated types?<br>This would be similar to the current use of the `where` clause in generics.<br></p><p>Otherwise it at least looks ambiguous whether a comma separates constraints on associated types from each other or from constraints on the type (it might still be unambiguous for the type checker).<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/d72c4758/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 18, 2016, at 9:35 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 18.05.2016 um 06:52 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 17, 2016 at 1:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Within the angle brackets are zero or more &#39;clauses&#39;. Clauses are separated by semicolons. (This is so commas can be used in where constraints, below. Better ideas are welcome. Maybe it&#39;s not necessary; we can use commas exclusively.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not a fan of the semicolon idea.  I don’t see any reason for this.  The `where` keyword separates the protocol list from the constraints just fine.  The list on either side should be able to use commas with no problem (or line breaks if that proposal goes through).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m leaning towards getting rid of the commas, but would like to write out a few &#39;dummy&#39; examples to see if there are any readability issues that arise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replaced with what?  Whitespace separation?  I suppose that might work for the protocol list but it feels inconsistent with the rest of Swift.  Commas plus (hopefully) the alternative of newline seem like the right direction to me.<br>&gt;&gt; <br>&gt;&gt; Sorry, I completely misspoke (mistyped?). I meant I want to get rid of the semicolons and use commas. I&#39;ve come to the conclusion that there are no readability issues, protocol&lt;&gt; already uses commas, and semicolons used in this manner don&#39;t have a precedent anywhere else in the language.<br>&gt; <br>&gt; Shouldn&#39;t there be just a single `where` in the whole `Any&lt;&gt;` clause, separating the constraints on the type itself from the constraints on associated types?<br>&gt; This would be similar to the current use of the `where` clause in generics.<br>&gt; <br>&gt; Otherwise it at least looks ambiguous whether a comma separates constraints on associated types from each other or from constraints on the type (it might still be unambiguous for the type checker).<br></p><p>Yes, a single where clause is what I would expect as well.<br></p><p>&gt; <br>&gt; -Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/87cc3378/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 17, 2016, at 11:52 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I put together the skeleton of a proposal detailing enhancements to how associated types can be referenced in Swift 3+. It&#39;s certainly not ready for submission, but I think it gets across my ideas pretty well. Would love to gather feedback and especially improvements.<br>&gt; <br></p><p>Austin, these comments are on the updated proposal (86d209e).<br></p><p><br>&gt; In such a case, it is not allowed to define constraints that create a relation between different existential values:<br>&gt; // NOT ALLOWED; each constraint can reference at most a single existential<br>&gt; // value (argument or return value)<br>&gt; func doSomething(x: Collection, y: Collection)<br>&gt;     where x.Element == y.Element<br>&gt; {<br>&gt;     // ...<br>&gt; }<br></p><p><br>What is the rationale for this restriction? I’m not arguing against it, but I’d like to understand it better… maybe the proposal should include a small explanation?<br></p><p><br></p><p>&gt; Unconditional casting to covariant generic output types (i.e. Optional&lt;T&gt;) is allowed, even without concrete type constraints.<br></p><p><br>Maybe it’s just me but this might warrant a little bit of explanation. Swift doesn’t have a mechanism for specifying covariant/contravariant type parameters so I assume that’s just inferred if SomeType&lt;AssociatedType&gt; appears in output position anywhere in the protocol? I also assume you must constrain all the type parameters of the generic type to use it this way.<br></p><p><br></p><p>&gt; Existentials cannot be used with generics in the following ways:<br>&gt; Passed as arguments of generic type T to generic functions, unless T is completely unconstrained and the argument&#39;s type is T or a generic type covariant on T.<br>&gt; <br>I’m not quite parsing this one. If the existential is constrained enough to satisfy the function’s generic constraints why can’t the compiler call the non-specialized version? (I’m probably just misunderstanding)<br></p><p><br></p><p>&gt; A type A is a subtype of another type B iff B can be used anywhere A can without changing the semantics of the program.<br></p><p><br>Is this correct? It might be my confusion but it seems like &quot;A type A is a subtype of B iff A can be used anywhere B can without changing the semantics of the program”. That seems to fit with the example of “String is a subtype of Streamable” because “String can be used anywhere Streamable can”.<br></p><p><br></p><p><br>Thanks to everyone for their work on this proposal, it looks fantastic!<br></p><p>Russ <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/8b8f5af6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
