<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>Thoughts on property behavior out-of-band members</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 19, 2016 at 06:00:00pm</p></header><div class="content"><p>I would like to echo these concerns. I like the direction of these suggestions are going. They feel much more in line with Swift and the syntax is by far more appealing.<br></p><p>Myles<br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 19, 2016, at 3:45 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; This was originally going to be part of my recent email on the SE-0030 review thread, but it got very long and convoluted, so I decided to split it off.<br>&gt; <br>&gt; ***<br>&gt; <br>&gt; If we&#39;re going to use an `@runcible` syntax for properties, we should think about what will happen to behavior members.<br>&gt; <br>&gt; The basic syntax itself is simple enough; `foo at runcible` and `foo. at runcible` are both reasonable options. (I slightly favor the dotless version because it doesn&#39;t make it look like you could capture `foo` in a variable and access `@runcible` from it, but that&#39;s a minor issue.)<br>&gt; <br>&gt; More interesting is controlling the behavior members&#39; visibility. The square bracket syntax had the advantage that you could put access control keywords alongside the declarations, like `[public resettable]`; with the `@` syntax that&#39;s now lost. We could echo `private(set)`, but the naive version of that is ridiculously wordy:<br>&gt; <br>&gt;   public public(@resettable) @resettable var counter = 0<br>&gt; <br>&gt; Maybe we could drop the second `@resettable`窶品t&#39;s implied by the one in the access control list:<br>&gt; <br>&gt;   public public(@resettable) var counter = 0<br>&gt; <br>&gt; And maybe we could drop the first `public`窶品t&#39;s implied, since the behavior can&#39;t be more visible than the property it&#39;s on窶付o get:<br>&gt; <br>&gt;   public(@resettable) var counter = 0<br>&gt; <br>&gt; However, there are downsides to both of those. If we decide to support accessor vars with the `@json(key=)` syntax I described in the SE-0030 review thread, you start seeing things like `public(@json(key=&quot;fooBarBaz&quot;))`, which kind of mixes unrelated things together.<br>&gt; <br>&gt; And as for omitting the first `public`, well, I&#39;m not entirely sure about the &quot;can&#39;t be more visible&quot; thing either. Sometimes you actually *don&#39;t* want to expose a property, but you *do* want to expose a behavior method. For instance:<br>&gt; <br>&gt;   public class NetworkDatabase {<br>&gt;       private public(@resettable) var recordCache: NSCache<br>&gt;       // You can&#39;t access the cache, but you can throw it out.<br>&gt;   }<br>&gt; <br>&gt; If that&#39;s the case, I&#39;m not sure it&#39;s a good idea to have `public(@resettable)` imply the property is public, too.<br>&gt; <br>&gt; ***<br>&gt; <br>&gt; Actually, I&#39;m beginning to think that the `foo. at runcible` thing isn&#39;t a good idea at all.<br>&gt; <br>&gt; One thing I&#39;ve been thinking about lately is the ways we normally do behavior method-like things in Cocoa. For example, if you have a resettable property, you&#39;ll probably have something like this:<br>&gt; <br>&gt;   @property (assign) NSUInteger foo;<br>&gt;   - (void)resetFoo;<br>&gt; <br>&gt; It&#39;s pretty obvious, though, that we&#39;re not going to be able to Swiftify that窶付he clang importer isn&#39;t going to translate that into `@resettable var foo: Int`, or any other special syntax like that. It&#39;s just not going to be a realistic thing to detect and adjust during bridging.<br>&gt; <br>&gt; And even if it could, that only exposes another problem: behaviors tie you *very* tightly to a particular implementation. If your property is `@resettable` and you decide you need to reset in a different way, you have no way to make that change without breaking all of your call sites. In particular, that means a public behavior in a resilient library can never be removed or even substituted for another behavior with a compatible interface.<br>&gt; <br>&gt; So I&#39;m thinking that we should try to sidestep the problem entirely and instead expose behavior members alongside the property they belong to, Cocoa-style.<br>&gt; <br>&gt; Within the behavior, all of the members behave exactly as you would expect. But members with a visibility specifier are exposed on the instance using the behavior with the same visibility (capped by the property&#39;s access control), only with an uppercased version of the property&#39;s name appended to the member&#39;s name. Members with no visibility modifier, on the other hand, are not exposed outside the behavior.<br>&gt; <br>&gt; For example, let&#39;s define, apply, and use `@resettable`:<br>&gt; <br>&gt;   public var behavior resettable&lt;Value&gt;: Value {<br>&gt;       var value: Value = initialValue                // no access control, so invisible<br>&gt; <br>&gt;       get { return value }<br>&gt;       set { value = newValue }<br>&gt; <br>&gt;       public mutating func reset() {                // visible at up to `public` scope<br>&gt;           value = initialValue<br>&gt;       }<br>&gt;   }<br>&gt; <br>&gt;   struct Foo {<br>&gt;       @resettable var bar: Int<br>&gt;       // has a resetBar() method, which is internal because `bar` is internal.<br>&gt;   }<br>&gt; <br>&gt;   var myFoo = Foo()<br>&gt;   myFoo.resetBar()<br>&gt; <br>&gt; With this in place, all behaviors are pure implementation details; you can remove them and manually implement the members they provided and nobody would be the wiser. You probably wouldn&#39;t even see behaviors in the generated headers.<br>&gt; <br>&gt; (By the way, while I&#39;m here, I&#39;ll note that it might be a good idea to bridge Objective-C null_resettable as Swift @resettable in both directions. That would mean the setter would have to accept `nil` in Objective-C only; I&#39;m not sure if it&#39;s worth inventing a general mechanism for that.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/9a651a14/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
