<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 18, 2016 at 09:00:00am</p></header><div class="content"><p>For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 11:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression.<br></p><p>I guess you are implying here that we would be forwarding along self in the complicated computation? Wouldn&#39;t we at most have one retain/release for the expression on the value due to SILGen peepholes/SGFContexts (maybe my memory is wrong)?<br></p><p>&gt; Using +0 also prevents us from reusing self&#39;s resources<br></p><p>Can you elaborate?<br></p><p>&gt; and doing in-place mutation if it&#39;s uniquely referenced<br></p><p>I thought we were talking about non-mutating value type methods? (I am confused). Can you elaborate here?<br></p><p>&gt; , which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br></p><p>We need to be very careful here. We saw large reductions in the number of dynamic retains/releases at -Onone and significant improvements at -O across many benchmarks.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 8:47 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 11:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression.<br>&gt; <br>&gt; I guess you are implying here that we would be forwarding along self in the complicated computation? Wouldn&#39;t we at most have one retain/release for the expression on the value due to SILGen peepholes/SGFContexts (maybe my memory is wrong)?<br></p><p>Yeah.<br></p><p>&gt; <br>&gt;&gt; Using +0 also prevents us from reusing self&#39;s resources<br>&gt; <br>&gt; Can you elaborate?<br>&gt; <br>&gt;&gt; and doing in-place mutation if it&#39;s uniquely referenced<br>&gt; <br>&gt; I thought we were talking about non-mutating value type methods? (I am confused). Can you elaborate here?<br></p><p>A nonmutating operation on an Array can mutate its &#39;self&#39; parameter&#39;s buffer to build its return value if the parameter is uniquely referenced, for instance:<br></p><p>extension Array {<br>  func appending(x: Array) -&gt; Array {<br>    var myself = self // should take self&#39;s refcount<br>    if isUniquelyReferenced(&amp;myself.buffer) {<br>      myself.append(x)<br>      return myself<br>    }<br>    ...<br>  }<br>}<br></p><p>The effect is still semantically nonmutating, but we get the benefits of in-place mutation.<br></p><p>&gt; <br>&gt;&gt; , which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt; <br>&gt; We need to be very careful here. We saw large reductions in the number of dynamic retains/releases at -Onone and significant improvements at -O across many benchmarks.<br></p><p>I know we&#39;ve done all-or-nothing tests for +0 vs +1. I think it&#39;d be worthwhile to experiment with selectively using +1 for value type methods and seeing what the impact is. My hypothesis is that most value type &#39;self&#39;s are effectively forwarded and can be more efficiently callee-consumed than caller-guaranteed.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br></p><p>I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt; <br>&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br></p><p>We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:05 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt; <br>&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt; <br>&gt; We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br></p><p>Sure, but we’re talking about very narrow heuristics for changing the defaults here.  At most, maybe your Self rule, although there are conspicuous cases (func clone() -&gt; Self) where it would not be appropriate.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 10:05 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt;&gt; <br>&gt;&gt; We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br>&gt; <br>&gt; Sure, but we’re talking about very narrow heuristics for changing the defaults here.  At most, maybe your Self rule, although there are conspicuous cases (func clone() -&gt; Self) where it would not be appropriate.<br></p><p>It&#39;s also worth investigating whether it&#39;s profitable to apply to all nonmutating value type methods. I think nonmutating &#39;self&#39; is more likely to be consumed in general than it is for class or mutating methods.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:34 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 10:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 10:05 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br>&gt;&gt; <br>&gt;&gt; Sure, but we’re talking about very narrow heuristics for changing the defaults here.  At most, maybe your Self rule, although there are conspicuous cases (func clone() -&gt; Self) where it would not be appropriate.<br>&gt; <br>&gt; It&#39;s also worth investigating whether it&#39;s profitable to apply to all nonmutating value type methods. I think nonmutating &#39;self&#39; is more likely to be consumed in general than it is for class or mutating methods.<br></p><p>Are you imagining, like, a heroic Array.map implementation that applies the transform in-place?  Because honestly I think there are very few nonmutating operations that would actually consume self.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:59 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 10:34 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Jan 19, 2016, at 10:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 10:05 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but we’re talking about very narrow heuristics for changing the defaults here.  At most, maybe your Self rule, although there are conspicuous cases (func clone() -&gt; Self) where it would not be appropriate.<br>&gt;&gt; <br>&gt;&gt; It&#39;s also worth investigating whether it&#39;s profitable to apply to all nonmutating value type methods. I think nonmutating &#39;self&#39; is more likely to be consumed in general than it is for class or mutating methods.<br>&gt; <br>&gt; Are you imagining, like, a heroic Array.map implementation that applies the transform in-place?  Because honestly I think there are very few nonmutating operations that would actually consume self.<br></p><p>Almost every operation with an efficient in-place form for uniquely-referenced mutation could also use that in-place variant for nonmutating operations—nonmutating variants of appending, removing, uppercaseString, etc. could all benefit.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/6c34bacf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 11:04 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 10:59 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 10:34 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 10:29 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 10:05 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 9:53 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could do that, but we should still make sure the defaults give the best overall system performance and optimization opportunity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, but we’re talking about very narrow heuristics for changing the defaults here.  At most, maybe your Self rule, although there are conspicuous cases (func clone() -&gt; Self) where it would not be appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s also worth investigating whether it&#39;s profitable to apply to all nonmutating value type methods. I think nonmutating &#39;self&#39; is more likely to be consumed in general than it is for class or mutating methods.<br>&gt;&gt; <br>&gt;&gt; Are you imagining, like, a heroic Array.map implementation that applies the transform in-place?  Because honestly I think there are very few nonmutating operations that would actually consume self.<br>&gt; <br>&gt; Almost every operation with an efficient in-place form for uniquely-referenced mutation could also use that in-place variant for nonmutating operations—nonmutating variants of appending, removing, uppercaseString, etc. could all benefit.<br></p><p>1. Many of the in-place proposals have discussed having special optimization rules for turning functional-style operations to in-place ones.  I don’t know where those stand, but it’s something I think we’d want to pursue directly.<br></p><p>2. I don’t think those operations dominate the set of all nonmutating operations on value types.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/1ffbb8ac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 11:53 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt; <br>&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br></p><p>TBH if we do that I would rather us take this 1 step further and allow any function/method to opt-in to a different calling convention for specific parameters.<br></p><p>Michael<br></p><p>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 1:32 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 19, 2016, at 11:53 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt; <br>&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt; <br>&gt; TBH if we do that I would rather us take this 1 step further and allow any function/method to opt-in to a different calling convention for specific parameters.<br></p><p>Resilience makes this even more important since we can not perform the @owned -&gt; @guaranteed optimization over resilience boundaries.<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/02ea25fc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>@owned vs @guaranteed convention for &#39;self&#39; in nonmutating value type methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 11:32 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 11:53 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 9:28 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; For Swift 2, we changed the default reference counting convention for &#39;self&#39; parameters from +1 &quot;owned&quot; (caller retains, callee releases) to +0 &quot;guaranteed&quot; (caller retains and releases). This makes a lot of sense for class methods, since it&#39;s common to invoke a number of methods on the same object in turn. Similarly for value types, it&#39;s common to want to perform a bunch of mutations in a row, but we get a &quot;+0&quot;-like convention naturally due to the way &#39;inout&#39; works. For nonmutating value type operations, it&#39;s a bit less clear-cut—a pure operation is more likely to appear once as part of a larger expression. Using +0 also prevents us from reusing self&#39;s resources and doing in-place mutation if it&#39;s uniquely referenced, which is an extremely useful optimization for a number of operations on strings and containers. We may want to consider whether +1 is a better default, if not for all nonmutating value type methods, maybe some subset where inplace mutation is likely to be profitable. One possible heuristic would be to look at whether a method returns the Self type (possibly including tuples and fragile structs containing Self, or different instantiations of the same Self type).<br>&gt;&gt; <br>&gt;&gt; I feel like the right language solution here is probably just to add attributes to allow methods to opt-in to a different default self convention.<br>&gt; <br>&gt; TBH if we do that I would rather us take this 1 step further and allow any function/method to opt-in to a different calling convention for specific parameters.<br></p><p>Yes, I think that would also be reasonable.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
