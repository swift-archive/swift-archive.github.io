<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>August 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I’ve been working on getting Siesta up and running with SwiftPM, and have hit snags running the tests. At Ankit Aggarwal’s encouragement, I’m opening a discussion thread here.<br></p><p>By “test-only dependencies,” I mean external packages required by a package’s tests, but not by the package&#39;s exported targets. For example, Siesta’s tests depend on Quick, Nimble, and Nocilla, but apps that use Siesta should not have to build those dependencies and would very much not want them baked into the resulting binary.<br></p><p>Proper support for test-only dependencies would have three essential features:<br></p><p>They are not downloaded or built by “swift build,” but are downloaded and built by “swift test.”<br>Any modules they define do not end up in the compiled binary, and are not available for the package’s non-test targets to import.<br>A package ignores the test-only dependencies of its dependencies.<br></p><p>Those are the essentials. Also nice to have:<br></p><p>The ability to limit test-only dependencies to specific test modules (e.g. an integration test module might pull in some heavyweight context that isn’t necessary or desirable for basic regression tests).<br>The ability to import / run tests defined in an external module. (Probably a separate discussion.)<br></p><p>To open the discussion, I see three general approaches:<br></p><p>Approach 1: Special testDependencies attribute<br></p><p>It looks like SwiftPM flirted with this, then abandoned it?<br></p><p>Pros: Clear.<br></p><p>Cons: Creates (another) special exception for tests. Doesn’t obviously generalize to handle the “specific test modules” nice-to-have above.<br></p><p>Approach 2: Per-target external dependencies<br></p><p>SwiftPM could allow individual targets to specify external dependencies, something like this:<br></p><p>    targets: [<br>      Target(<br>        name: &quot;SiestaTests&quot;,<br>        dependencies: [<br>          .Package(url: &quot;https://github.com/Quick/Quick&quot;, majorVersion: 0)<br>        ])<br>    ],<br></p><p>Pros: Covers the “essential features” above in a way that generalizes nicely to other interesting use cases beside testing.<br></p><p>Cons: Requires redundant dependency declarations across test targets.<br></p><p>Approach 3: Target groups<br></p><p>Bundler provides arbitrary logical gem groupings, which Rails uses to isolate dependencies to development, test, and/or production environments. For example:<br></p><p>    group :development, :test do<br>      gem &#39;byebug&#39;<br>      gem &#39;spring&#39;<br>    end<br></p><p>    group :test do<br>      gem &#39;minitest-spec-rails&#39;<br>      gem &#39;factory_girl_rails&#39;<br>    end<br></p><p>    group :development<br>      gem &#39;letter_opener&#39;<br>    end<br></p><p>    group :production<br>      gem &#39;puma&#39;<br>    end<br></p><p>Apps can then decide which groups to include depending on their runtime environment.<br></p><p>Pros: Gives the clarity &amp; conciseness of #1 with the generality benefits of #2.<br></p><p>Cons: Lots of additional structure here, both explicit and implicit. Not clear how useful this would be in SwiftPM: because Ruby is so dynamic, all dependencies are runtime dependencies, so code can decide whether it’s “in test mode” or “in production” before looking for modules. In SwiftPM, all dependencies are compile-time dependencies, so arbitrary logical groups lose the benefits that come with runtime resolution.<br></p><p>________<br></p><p><br>I’m throwing all of this out there in a state of general ignorance about SwiftPM’s direction and status. Hopefully it spurs some useful discussion.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160828/e3aaf46e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30aa7afb91d7cf736566fa69a4459a07?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Ankit Aggarwal</string> &lt;ankit_aggarwal at apple.com&gt;<p>August 29, 2016 at 07:00:00am</p></header><div class="content"><p>Hi Paul,<br></p><p>Thanks for opening this discussion.<br></p><p>&gt; On 29-Aug-2016, at 1:36 AM, Paul Cantrell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been working on getting Siesta up and running with SwiftPM, and have hit snags running the tests. At Ankit Aggarwal’s encouragement, I’m opening a discussion thread here.<br>&gt; <br>&gt; By “test-only dependencies,” I mean external packages required by a package’s tests, but not by the package&#39;s exported targets. For example, Siesta’s tests depend on Quick, Nimble, and Nocilla, but apps that use Siesta should not have to build those dependencies and would very much not want them baked into the resulting binary.<br></p><p>I agree that building test specific dependencies is not useful for packages which just uses the some package, however I think that should be controlled by some other general mechanism like specifying exact external package/target the target in question depends on. That way all the unused targets in an external package will not build. See thread “Proposal: SwiftPM Target Access Control“ for some more discussion on this idea.<br></p><p>&gt; <br>&gt; Proper support for test-only dependencies would have three essential features:<br>&gt; <br>&gt; They are not downloaded or built by “swift build,” but are downloaded and built by “swift test.”<br>&gt; Any modules they define do not end up in the compiled binary, and are not available for the package’s non-test targets to import.<br>&gt; A package ignores the test-only dependencies of its dependencies.<br></p><p>I think instead of it being test-only dependency this could be a feature which lets you define dependencies to be used only by the current package (including test targets) which will be helpful for developers to try or play with some external dependency. And in that case it should probably be called something else like for e.g.: `localDependencies`<br></p><p>What do you think?<br></p><p>—<br></p><p>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/f68d0bc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>August 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 28, 2016, at 9:23 PM, Ankit Aggarwal &lt;ankit_aggarwal at apple.com&gt; wrote:<br>&gt; <br>&gt; I agree that building test specific dependencies is not useful for packages which just uses the some package, however I think that should be controlled by some other general mechanism like specifying exact external package/target the target in question depends on.<br></p><p>That’s what I had in mind with “Approach 2” in my original message. Approach 3 is a related but different alternative.<br></p><p>Please see remarks in the original message for my take on the pros and cons.<br></p><p>&gt; That way all the unused targets in an external package will not build. See thread “Proposal: SwiftPM Target Access Control“ for some more discussion on this idea.<br></p><p>That proposal is getting warm — especially if test packages are _not_ exposed by default, something it seems to me that proposal should specify.<br></p><p>The new “External” in that proposal has the right semantics, but seems to me to add yet more complexity to a package DSL whose readability is already a bit strained. In particular, this seems likely to cause confusion:<br></p><p>&gt; An external package dependency declaration implicitly becomes dependency of each target in the package. We propose this behaviour should be retained but if a target dependency contains an External declaration then all other targets which wants to use that external dependency should explicitly state their dependency on that external package using External.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>August 28, 2016 at 10:00:00pm</p></header><div class="content"><p>I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br></p><p>We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br></p><p>On the other hand, that has proven more complicated than approach #1, and is likely to take longer to get right. I wonder if there are reasons we might end up wanting #1 even if we had a working #2 (one reason might be if we couldn&#39;t solve the duplicate declaration problem).<br></p><p>My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us, but I could probably be persuaded that the problem is pressing enough we should consider a more targeted fix sooner.<br></p><p> - Daniel<br></p><p>&gt; On Aug 28, 2016, at 7:48 PM, Paul Cantrell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 28, 2016, at 9:23 PM, Ankit Aggarwal &lt;ankit_aggarwal at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that building test specific dependencies is not useful for packages which just uses the some package, however I think that should be controlled by some other general mechanism like specifying exact external package/target the target in question depends on.<br>&gt; <br>&gt; That’s what I had in mind with “Approach 2” in my original message. Approach 3 is a related but different alternative.<br>&gt; <br>&gt; Please see remarks in the original message for my take on the pros and cons.<br>&gt; <br>&gt;&gt; That way all the unused targets in an external package will not build. See thread “Proposal: SwiftPM Target Access Control“ for some more discussion on this idea.<br>&gt; <br>&gt; That proposal is getting warm — especially if test packages are _not_ exposed by default, something it seems to me that proposal should specify.<br>&gt; <br>&gt; The new “External” in that proposal has the right semantics, but seems to me to add yet more complexity to a package DSL whose readability is already a bit strained. In particular, this seems likely to cause confusion:<br>&gt; <br>&gt;&gt; An external package dependency declaration implicitly becomes dependency of each target in the package. We propose this behaviour should be retained but if a target dependency contains an External declaration then all other targets which wants to use that external dependency should explicitly state their dependency on that external package using External.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>Not sure if already mentioned, but the issue of duplicated dependencies in<br>targets can be easily handled like this:<br></p><p>import PackageDescription<br></p><p>let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;,<br>majorVersion: 1)<br></p><p>let package = Package(<br>    name: &quot;MyPkg&quot;,<br>    targets: [<br>        .Target(name: &quot;First&quot;),<br>        .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>        .Target(name: &quot;Third&quot;, dependencies: [sharedDependency])<br>    ]<br>)<br></p><p>That&#39;s assuming we&#39;ll be able to add external deps to targets.<br></p><p>- Honza<br></p><p>On Mon, Aug 29, 2016 at 7:07 AM Daniel Dunbar via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; I completely agree with your original email, and agree the target-access<br>&gt; control proposal amounts to a variant of #2.<br>&gt;<br>&gt; We definitely need a per-target dependency solution, and if we got one<br>&gt; that included some kind of solution for managing the duplicate declaration,<br>&gt; that would solve the con you list with #2. That might suggest that one<br>&gt; approach here is to add it the list of reasons we should do a per-target<br>&gt; dependency proposal.<br>&gt;<br>&gt; On the other hand, that has proven more complicated than approach #1, and<br>&gt; is likely to take longer to get right. I wonder if there are reasons we<br>&gt; might end up wanting #1 even if we had a working #2 (one reason might be if<br>&gt; we couldn&#39;t solve the duplicate declaration problem).<br>&gt;<br>&gt; My leaning here is towards trying to figure out a good approach for #2<br>&gt; first, and see where that leaves us, but I could probably be persuaded that<br>&gt; the problem is pressing enough we should consider a more targeted fix<br>&gt; sooner.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; &gt; On Aug 28, 2016, at 7:48 PM, Paul Cantrell via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Aug 28, 2016, at 9:23 PM, Ankit Aggarwal &lt;ankit_aggarwal at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I agree that building test specific dependencies is not useful for<br>&gt; packages which just uses the some package, however I think that should be<br>&gt; controlled by some other general mechanism like specifying exact external<br>&gt; package/target the target in question depends on.<br>&gt; &gt;<br>&gt; &gt; That’s what I had in mind with “Approach 2” in my original message.<br>&gt; Approach 3 is a related but different alternative.<br>&gt; &gt;<br>&gt; &gt; Please see remarks in the original message for my take on the pros and<br>&gt; cons.<br>&gt; &gt;<br>&gt; &gt;&gt; That way all the unused targets in an external package will not build.<br>&gt; See thread “Proposal: SwiftPM Target Access Control“ for some more<br>&gt; discussion on this idea.<br>&gt; &gt;<br>&gt; &gt; That proposal is getting warm — especially if test packages are _not_<br>&gt; exposed by default, something it seems to me that proposal should specify.<br>&gt; &gt;<br>&gt; &gt; The new “External” in that proposal has the right semantics, but seems<br>&gt; to me to add yet more complexity to a package DSL whose readability is<br>&gt; already a bit strained. In particular, this seems likely to cause confusion:<br>&gt; &gt;<br>&gt; &gt;&gt; An external package dependency declaration implicitly becomes<br>&gt; dependency of each target in the package. We propose this behaviour should<br>&gt; be retained but if a target dependency contains an External declaration<br>&gt; then all other targets which wants to use that external dependency should<br>&gt; explicitly state their dependency on that external package using External.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; Paul<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-build-dev mailing list<br>&gt; &gt; swift-build-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/94a0fde8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>August 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt; <br>&gt; Not sure if already mentioned, but the issue of duplicated dependencies in targets can be easily handled like this:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;, majorVersion: 1)<br>&gt; <br>&gt; let package = Package(<br>&gt;     name: &quot;MyPkg&quot;,<br>&gt;     targets: [<br>&gt;         .Target(name: &quot;First&quot;),<br>&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt;         .Target(name: &quot;Third&quot;, dependencies: [sharedDependency])<br>&gt;     ]<br>&gt; )<br>&gt; <br>&gt; That&#39;s assuming we&#39;ll be able to add external deps to targets.<br></p><p>I&#39;m not sure that is a syntax we want to support per the long term plans to split the manifest into a &quot;leading package specification&quot; which, while Swift, is a restricted subset we know we can parse into a machine editable form.<br></p><p>I would like it if the syntax for all common things was representable as a readable declarative initializer.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; - Honza<br>&gt; <br>&gt; On Mon, Aug 29, 2016 at 7:07 AM Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt; <br>&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt; <br>&gt; On the other hand, that has proven more complicated than approach #1, and is likely to take longer to get right. I wonder if there are reasons we might end up wanting #1 even if we had a working #2 (one reason might be if we couldn&#39;t solve the duplicate declaration problem).<br>&gt; <br>&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us, but I could probably be persuaded that the problem is pressing enough we should consider a more targeted fix sooner.<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt; &gt; On Aug 28, 2016, at 7:48 PM, Paul Cantrell via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Aug 28, 2016, at 9:23 PM, Ankit Aggarwal &lt;ankit_aggarwal at apple.com &lt;mailto:ankit_aggarwal at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I agree that building test specific dependencies is not useful for packages which just uses the some package, however I think that should be controlled by some other general mechanism like specifying exact external package/target the target in question depends on.<br>&gt; &gt;<br>&gt; &gt; That’s what I had in mind with “Approach 2” in my original message. Approach 3 is a related but different alternative.<br>&gt; &gt;<br>&gt; &gt; Please see remarks in the original message for my take on the pros and cons.<br>&gt; &gt;<br>&gt; &gt;&gt; That way all the unused targets in an external package will not build. See thread “Proposal: SwiftPM Target Access Control“ for some more discussion on this idea.<br>&gt; &gt;<br>&gt; &gt; That proposal is getting warm — especially if test packages are _not_ exposed by default, something it seems to me that proposal should specify.<br>&gt; &gt;<br>&gt; &gt; The new “External” in that proposal has the right semantics, but seems to me to add yet more complexity to a package DSL whose readability is already a bit strained. In particular, this seems likely to cause confusion:<br>&gt; &gt;<br>&gt; &gt;&gt; An external package dependency declaration implicitly becomes dependency of each target in the package. We propose this behaviour should be retained but if a target dependency contains an External declaration then all other targets which wants to use that external dependency should explicitly state their dependency on that external package using External.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; Paul<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-build-dev mailing list<br>&gt; &gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/7f824a97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>August 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Good point, I forgot about that.<br>On Mon, Aug 29, 2016 at 5:36 PM Daniel Dunbar &lt;daniel_dunbar at apple.com&gt;<br>wrote:<br></p><p>&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt;<br>&gt; Not sure if already mentioned, but the issue of duplicated dependencies in<br>&gt; targets can be easily handled like this:<br>&gt;<br>&gt; import PackageDescription<br>&gt;<br>&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;,<br>&gt; majorVersion: 1)<br>&gt;<br>&gt; let package = Package(<br>&gt;     name: &quot;MyPkg&quot;,<br>&gt;     targets: [<br>&gt;         .Target(name: &quot;First&quot;),<br>&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt;         .Target(name: &quot;Third&quot;, dependencies: [sharedDependency])<br>&gt;     ]<br>&gt; )<br>&gt;<br>&gt; That&#39;s assuming we&#39;ll be able to add external deps to targets.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure that is a syntax we want to support per the long term plans<br>&gt; to split the manifest into a &quot;leading package specification&quot; which, while<br>&gt; Swift, is a restricted subset we know we can parse into a machine editable<br>&gt; form.<br>&gt;<br>&gt; I would like it if the syntax for all common things was representable as a<br>&gt; readable declarative initializer.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt;<br>&gt; - Honza<br>&gt;<br>&gt; On Mon, Aug 29, 2016 at 7:07 AM Daniel Dunbar via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I completely agree with your original email, and agree the target-access<br>&gt;&gt; control proposal amounts to a variant of #2.<br>&gt;&gt;<br>&gt;&gt; We definitely need a per-target dependency solution, and if we got one<br>&gt;&gt; that included some kind of solution for managing the duplicate declaration,<br>&gt;&gt; that would solve the con you list with #2. That might suggest that one<br>&gt;&gt; approach here is to add it the list of reasons we should do a per-target<br>&gt;&gt; dependency proposal.<br>&gt;&gt;<br>&gt;&gt; On the other hand, that has proven more complicated than approach #1, and<br>&gt;&gt; is likely to take longer to get right. I wonder if there are reasons we<br>&gt;&gt; might end up wanting #1 even if we had a working #2 (one reason might be if<br>&gt;&gt; we couldn&#39;t solve the duplicate declaration problem).<br>&gt;&gt;<br>&gt;&gt; My leaning here is towards trying to figure out a good approach for #2<br>&gt;&gt; first, and see where that leaves us, but I could probably be persuaded that<br>&gt;&gt; the problem is pressing enough we should consider a more targeted fix<br>&gt;&gt; sooner.<br>&gt;&gt;<br>&gt;&gt;  - Daniel<br>&gt;&gt;<br>&gt;&gt; &gt; On Aug 28, 2016, at 7:48 PM, Paul Cantrell via swift-build-dev &lt;<br>&gt;&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Aug 28, 2016, at 9:23 PM, Ankit Aggarwal &lt;ankit_aggarwal at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I agree that building test specific dependencies is not useful for<br>&gt;&gt; packages which just uses the some package, however I think that should be<br>&gt;&gt; controlled by some other general mechanism like specifying exact external<br>&gt;&gt; package/target the target in question depends on.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That’s what I had in mind with “Approach 2” in my original message.<br>&gt;&gt; Approach 3 is a related but different alternative.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Please see remarks in the original message for my take on the pros and<br>&gt;&gt; cons.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; That way all the unused targets in an external package will not build.<br>&gt;&gt; See thread “Proposal: SwiftPM Target Access Control“ for some more<br>&gt;&gt; discussion on this idea.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That proposal is getting warm — especially if test packages are _not_<br>&gt;&gt; exposed by default, something it seems to me that proposal should specify.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The new “External” in that proposal has the right semantics, but seems<br>&gt;&gt; to me to add yet more complexity to a package DSL whose readability is<br>&gt;&gt; already a bit strained. In particular, this seems likely to cause confusion:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; An external package dependency declaration implicitly becomes<br>&gt;&gt; dependency of each target in the package. We propose this behaviour should<br>&gt;&gt; be retained but if a target dependency contains an External declaration<br>&gt;&gt; then all other targets which wants to use that external dependency should<br>&gt;&gt; explicitly state their dependency on that external package using External.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Cheers,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Paul<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-build-dev mailing list<br>&gt;&gt; &gt; swift-build-dev at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/2692b1a4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>August 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 12:07 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt; <br>&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt; <br>&gt; …<br>&gt; <br>&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us<br></p><p>I’m not up on all the discussion, but that certainly seems to me like the right direction.<br></p><p>&gt; On Aug 29, 2016, at 10:36 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com &lt;mailto:jan.dvorsky at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not sure if already mentioned, but the issue of duplicated dependencies in targets can be easily handled like this:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; <br>&gt;&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;, majorVersion: 1)<br>&gt;&gt; …<br>&gt;&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt; <br>&gt; I&#39;m not sure that is a syntax we want to support per the long term plans to split the manifest into a &quot;leading package specification&quot; which, while Swift, is a restricted subset we know we can parse into a machine editable form.<br></p><p>It’s a tangent, but … doesn’t that defeat the advantage of having the syntax be Swift, namely being able to execute code within the package declaration to eliminate redundancy and conditionally declare things?<br></p><p>The package syntax is already a bit hard on the eyes, and quite finicky. (When do you use “.”? What is the correct order for all those named args?) If it’s going to be a bespoke syntax anyway, I’d vote for abandoning Swift syntax altogether and focusing on readability.<br></p><p>(Apologies if I’m reopening a well-trodden discussion.)<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/6ef93302/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 9:00 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 12:07 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt;&gt; <br>&gt;&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt; <br>&gt;&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us<br>&gt; <br>&gt; I’m not up on all the discussion, but that certainly seems to me like the right direction.<br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 10:36 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com &lt;mailto:jan.dvorsky at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure if already mentioned, but the issue of duplicated dependencies in targets can be easily handled like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import PackageDescription<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;, majorVersion: 1)<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure that is a syntax we want to support per the long term plans to split the manifest into a &quot;leading package specification&quot; which, while Swift, is a restricted subset we know we can parse into a machine editable form.<br>&gt; <br>&gt; It’s a tangent, but … doesn’t that defeat the advantage of having the syntax be Swift, namely being able to execute code within the package declaration to eliminate redundancy and conditionally declare things?<br></p><p>No, the intent was to support both cases, but to prioritize the leading package specification being able to describe most scenarios. See:<br>  https://github.com/apple/swift-package-manager/blob/master/Documentation/Internals/SwiftBasedManifestFormat.md<br></p><p>&gt; The package syntax is already a bit hard on the eyes, and quite finicky. (When do you use “.”? What is the correct order for all those named args?) If it’s going to be a bespoke syntax anyway, I’d vote for abandoning Swift syntax altogether and focusing on readability.<br></p><p>I am pretty happy with the decision to use Swift, and don&#39;t see a reason to abandon it here.<br></p><p>What I think is true is that we need to revisit exactly how the APIs are spelled to be more consistent with Swift3. That is part of the things we know we need to tackle next. We also hope to eventually be able to automatically help manage the manifest, which I believe will mitigate this problem.<br></p><p>If you have concrete examples of things you think are finicky or spelled badly, that is worth raising separately and feeding into a discussion of cleaning up the manifest API.<br></p><p> - Daniel<br></p><p>&gt; (Apologies if I’m reopening a well-trodden discussion.)<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160829/c46243b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 11:10 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 29, 2016, at 9:00 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 29, 2016, at 12:07 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us<br>&gt;&gt; <br>&gt;&gt; I’m not up on all the discussion, but that certainly seems to me like the right direction.<br></p><p>One way to remove the redundant declarations from #2:<br></p><p>(1) Allow virtual targets that have no corresponding source directory, but declare external dependencies.<br></p><p>(2) Allow other targets to depend on virtual targets.<br></p><p>So, for this directory structure:<br></p><p>    Source/<br>        ...<br>    Tests/<br>        FooTests/<br>        BarTests/<br></p><p>…a manifest could declare:<br></p><p>    targets: [<br>      Target(<br>        name: &quot;Tests&quot;,   // Note that /Tests/Tests does not exist!<br>        dependencies: [<br>          .Package(url: &quot;https://github.com/Quick/Quick&quot;, majorVersion: 0)<br>        ]),<br>      Target(<br>        name: &quot;FooTests&quot;,<br>        dependencies: [&quot;Tests&quot;])<br>      Target(<br>        name: &quot;BarTests&quot;,<br>        dependencies: [&quot;Tests&quot;]),<br>    ],<br></p><p>To that, you could also add:<br></p><p>(3) All test targets implicitly depend on a virtual target named “Tests.”<br></p><p>…which would allow this simplification:<br></p><p>    targets: [<br>      Target(<br>        name: &quot;Tests”,<br>        dependencies: [<br>          .Package(url: &quot;https://github.com/Quick/Quick&quot;, majorVersion: 0)<br>        ])<br>    ],<br></p><p>Note that there’s no longer any need to override convention-based defaults for FooTests and BarTests.<br></p><p>What do you think?<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; On Aug 29, 2016, at 10:36 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com &lt;mailto:jan.dvorsky at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure if already mentioned, but the issue of duplicated dependencies in targets can be easily handled like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import PackageDescription<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;, majorVersion: 1)<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure that is a syntax we want to support per the long term plans to split the manifest into a &quot;leading package specification&quot; which, while Swift, is a restricted subset we know we can parse into a machine editable form.<br>&gt;&gt; <br>&gt;&gt; It’s a tangent, but … doesn’t that defeat the advantage of having the syntax be Swift, namely being able to execute code within the package declaration to eliminate redundancy and conditionally declare things?<br>&gt; <br>&gt; No, the intent was to support both cases, but to prioritize the leading package specification being able to describe most scenarios. See:<br>&gt;   https://github.com/apple/swift-package-manager/blob/master/Documentation/Internals/SwiftBasedManifestFormat.md &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/Internals/SwiftBasedManifestFormat.md&gt;<br>Thanks for the link. The “Editor Support” section did clarify things quite a bit.<br></p><p>&gt; If you have concrete examples of things you think are finicky or spelled badly, that is worth raising separately and feeding into a discussion of cleaning up the manifest API.<br></p><p>The obvious one is knowing which things are enums and which are structs. It’s hard to know when to include the leading dots.<br></p><p>I’ll give this some separate thought in another thread, as you suggest.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160906/93770e55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>September  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 6, 2016, at 1:36 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 29, 2016, at 11:10 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 29, 2016, at 9:00 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 29, 2016, at 12:07 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not up on all the discussion, but that certainly seems to me like the right direction.<br>&gt; <br>&gt; One way to remove the redundant declarations from #2:<br>&gt; <br>&gt; (1) Allow virtual targets that have no corresponding source directory, but declare external dependencies.<br>&gt; <br>&gt; (2) Allow other targets to depend on virtual targets.<br></p><p>This works, but would it be obvious to newcomers? It feels more like a hack rather than something we would explicitly want to be the definitive model for solving the sharing problem.<br></p><p>I do think that allowing such kinds of targets is something that may make sense, I&#39;m just not sure it is the right answer to the redundant declaration.<br></p><p>&gt; So, for this directory structure:<br>&gt; <br>&gt;     Source/<br>&gt;         ...<br>&gt;     Tests/<br>&gt;         FooTests/<br>&gt;         BarTests/<br>&gt; <br>&gt; …a manifest could declare:<br>&gt; <br>&gt;     targets: [<br>&gt;       Target(<br>&gt;         name: &quot;Tests&quot;,   // Note that /Tests/Tests does not exist!<br>&gt;         dependencies: [<br>&gt;           .Package(url: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot;, majorVersion: 0)<br>&gt;         ]),<br>&gt;       Target(<br>&gt;         name: &quot;FooTests&quot;,<br>&gt;         dependencies: [&quot;Tests&quot;])<br>&gt;       Target(<br>&gt;         name: &quot;BarTests&quot;,<br>&gt;         dependencies: [&quot;Tests&quot;]),<br>&gt;     ],<br>&gt; <br>&gt; To that, you could also add:<br>&gt; <br>&gt; (3) All test targets implicitly depend on a virtual target named “Tests.”<br>&gt; <br>&gt; …which would allow this simplification:<br>&gt; <br>&gt;     targets: [<br>&gt;       Target(<br>&gt;         name: &quot;Tests”,<br>&gt;         dependencies: [<br>&gt;           .Package(url: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot;, majorVersion: 0)<br>&gt;         ])<br>&gt;     ],<br>&gt; <br>&gt; Note that there’s no longer any need to override convention-based defaults for FooTests and BarTests.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 29, 2016, at 10:36 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 29, 2016, at 2:35 AM, Honza Dvorsky &lt;jan.dvorsky at me.com &lt;mailto:jan.dvorsky at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not sure if already mentioned, but the issue of duplicated dependencies in targets can be easily handled like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import PackageDescription<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let sharedDependency: Package.Dependency = .Package(url: &quot;...&quot;, majorVersion: 1)<br>&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;         .Target(name: &quot;Second&quot;, dependencies: [&quot;First&quot;, sharedDependency]),<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure that is a syntax we want to support per the long term plans to split the manifest into a &quot;leading package specification&quot; which, while Swift, is a restricted subset we know we can parse into a machine editable form.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a tangent, but … doesn’t that defeat the advantage of having the syntax be Swift, namely being able to execute code within the package declaration to eliminate redundancy and conditionally declare things?<br>&gt;&gt; <br>&gt;&gt; No, the intent was to support both cases, but to prioritize the leading package specification being able to describe most scenarios. See:<br>&gt;&gt;   https://github.com/apple/swift-package-manager/blob/master/Documentation/Internals/SwiftBasedManifestFormat.md &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/Internals/SwiftBasedManifestFormat.md&gt;<br>&gt; Thanks for the link. The “Editor Support” section did clarify things quite a bit.<br>&gt; <br>&gt;&gt; If you have concrete examples of things you think are finicky or spelled badly, that is worth raising separately and feeding into a discussion of cleaning up the manifest API.<br>&gt; <br>&gt; The obvious one is knowing which things are enums and which are structs. It’s hard to know when to include the leading dots.<br></p><p>Yes, that is an example of something we know is broken (especially post Swift3 rename) but haven&#39;t had time to clean up yet.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; I’ll give this some separate thought in another thread, as you suggest.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160906/2a465954/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Test-only dependencies</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September  6, 2016 at 10:00:00pm</p></header><div class="content"><p>[resend; forgot to copy list]<br></p><p>&gt; On Sep 6, 2016, at 4:27 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 6, 2016, at 1:36 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 29, 2016, at 11:10 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 29, 2016, at 9:00 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 29, 2016, at 12:07 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I completely agree with your original email, and agree the target-access control proposal amounts to a variant of #2.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We definitely need a per-target dependency solution, and if we got one that included some kind of solution for managing the duplicate declaration, that would solve the con you list with #2. That might suggest that one approach here is to add it the list of reasons we should do a per-target dependency proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My leaning here is towards trying to figure out a good approach for #2 first, and see where that leaves us<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not up on all the discussion, but that certainly seems to me like the right direction.<br>&gt;&gt; <br>&gt;&gt; One way to remove the redundant declarations from #2:<br>&gt;&gt; <br>&gt;&gt; (1) Allow virtual targets that have no corresponding source directory, but declare external dependencies.<br>&gt;&gt; <br>&gt;&gt; (2) Allow other targets to depend on virtual targets.<br>&gt; <br>&gt; This works, but would it be obvious to newcomers? It feels more like a hack rather than something we would explicitly want to be the definitive model for solving the sharing problem.<br>&gt; <br>&gt; I do think that allowing such kinds of targets is something that may make sense, I&#39;m just not sure it is the right answer to the redundant declaration.<br></p><p>It feels like the a natural solution to me. I mean, it is the first one that came to mind….<br></p><p>In particular, this syntax, likely to be copied around and posted on Stack Overflow more than once, strikes me as reasonably self-explanatory even if you don’t know how it generalizes to arbitrary virtual targets:<br></p><p>    targets: [<br>      Target(<br>        name: &quot;Tests”,<br>        dependencies: [<br>          .Package(url: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot;, majorVersion: 0)<br>        ])<br>    ],<br></p><p>One small thing that might help with newcomer friendliness: allow (or require?) virtual targets to have a “group” arg instead of “name:”<br></p><p>    targets: [<br>      Target(<br>        group: &quot;Tests”,<br>        dependencies: [<br>          .Package(url: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot;, majorVersion: 0)<br>        ])<br>    ],<br></p><p>That does feel a bit hackish to me, though. I’d rather the package manifest have as few constructs and as few twists as possible.<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160906/28c9a769/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
