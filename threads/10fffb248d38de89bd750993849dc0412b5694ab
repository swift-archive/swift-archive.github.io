<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Custom didSet methods</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 12, 2016 at 11:00:00am</p></header><div class="content"><p>When declaring a collection, it would be nice to have a way of knowing when<br>an item is set/added and removed.<br></p><p>For example you could trigger a layer to be added to the layer hiearchy.<br></p><p>var shapeLayers: [CAShapeLayer] {<br></p><p>didAdd(item) {<br> addSubLayer(item)<br>}<br></p><p>willRemove(item){<br> item.removeFromSuperlayer()<br>}<br>}<br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/10ff94ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I don&#39;t know if this is a good idea. If you insert an item to an array,<br>what should happen? The items after the inserted item should be considered<br>as removed or not? They indexes are changed but the values not.<br></p><p>zhaoxin<br></p><p>On Tue, Jan 12, 2016 at 7:24 PM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; When declaring a collection, it would be nice to have a way of knowing<br>&gt; when an item is set/added and removed.<br>&gt;<br>&gt; For example you could trigger a layer to be added to the layer hiearchy.<br>&gt;<br>&gt; var shapeLayers: [CAShapeLayer] {<br>&gt;<br>&gt; didAdd(item) {<br>&gt;  addSubLayer(item)<br>&gt; }<br>&gt;<br>&gt; willRemove(item){<br>&gt;  item.removeFromSuperlayer()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/3dda33f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Currently, didSet already gets called when a set property is mutated. <br>The only difference I see in this proposal is that it lets you know more <br>precisely what changed, so that you can more efficiently update the UI <br>to reflect the change; i.e. if each item is represented by a view <br>object, and you insert an object, the redraw only needs to occur for the <br>view corresponding to the newly inserted item instead of having to <br>recreate all the views.<br></p><p>Seems reasonable to me. KVO currently provides this facility in <br>Objective-C.<br></p><p>Charles<br></p><p>On 2016-01-12 07:33, 肇鑫 via swift-evolution wrote:<br>&gt; I don&#39;t know if this is a good idea. If you insert an item to an<br>&gt; array, what should happen? The items after the inserted item should be<br>&gt; considered as removed or not? They indexes are changed but the values<br>&gt; not.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; On Tue, Jan 12, 2016 at 7:24 PM, James Campbell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; When declaring a collection, it would be nice to have a way of<br>&gt;&gt; knowing when an item is set/added and removed.<br>&gt;&gt; <br>&gt;&gt; For example you could trigger a layer to be added to the layer<br>&gt;&gt; hiearchy.<br>&gt;&gt; <br>&gt;&gt; var shapeLayers: [CAShapeLayer] {<br>&gt;&gt; <br>&gt;&gt; didAdd(item) {<br>&gt;&gt; addSubLayer(item)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; willRemove(item){<br>&gt;&gt; item.removeFromSuperlayer()<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt;  Wizard<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com<br>&gt;&gt; +44 7523 279 698 [1]<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution [2]<br>&gt; <br>&gt; --<br>&gt; <br>&gt; Owen Zhao<br>&gt; <br>&gt; <br>&gt; Links:<br>&gt; ------<br>&gt; [1] tel:%2B44%207523%20279%20698<br>&gt; [2] https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Custom didSet methods</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 12, 2016 at 07:00:00pm</p></header><div class="content"><p>What about did/willAdd for all collection types, did/willSetAtIndex for collection types with indexes, and <br>did/willSetAtIndexRange for collection types that support subscripting with ranges?<br></p><p>- Dave<br></p><p>&gt; On Jan 12, 2016, at 13:26, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, didSet already gets called when a set property is mutated. The only difference I see in this proposal is that it lets you know more precisely what changed, so that you can more efficiently update the UI to reflect the change; i.e. if each item is represented by a view object, and you insert an object, the redraw only needs to occur for the view corresponding to the newly inserted item instead of having to recreate all the views.<br>&gt; <br>&gt; Seems reasonable to me. KVO currently provides this facility in Objective-C.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On 2016-01-12 07:33, 肇鑫 via swift-evolution wrote:<br>&gt;&gt; I don&#39;t know if this is a good idea. If you insert an item to an<br>&gt;&gt; array, what should happen? The items after the inserted item should be<br>&gt;&gt; considered as removed or not? They indexes are changed but the values<br>&gt;&gt; not.<br>&gt;&gt; zhaoxin<br>&gt;&gt; On Tue, Jan 12, 2016 at 7:24 PM, James Campbell via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; When declaring a collection, it would be nice to have a way of<br>&gt;&gt;&gt; knowing when an item is set/added and removed.<br>&gt;&gt;&gt; For example you could trigger a layer to be added to the layer<br>&gt;&gt;&gt; hiearchy.<br>&gt;&gt;&gt; var shapeLayers: [CAShapeLayer] {<br>&gt;&gt;&gt; didAdd(item) {<br>&gt;&gt;&gt; addSubLayer(item)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; willRemove(item){<br>&gt;&gt;&gt; item.removeFromSuperlayer()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;  Wizard<br>&gt;&gt;&gt; james at supmenow.com<br>&gt;&gt;&gt; +44 7523 279 698 [1]<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution [2]<br>&gt;&gt; --<br>&gt;&gt; Owen Zhao<br>&gt;&gt; Links:<br>&gt;&gt; ------<br>&gt;&gt; [1] tel:%2B44%207523%20279%20698<br>&gt;&gt; [2] https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>did/willSetAtIndex could be redundant, since that information could be <br>equally well expressed with a range having a length of 1.<br></p><p>The other thing it&#39;s missing is a way to tell what kind of change it <br>was. If something were inserted or removed such that the number of items <br>in the collection were changed, you&#39;d need to know about it to avoid <br>having to redraw whatever view correspond to every single element in the <br>collection coming after the index you&#39;ve changed.<br></p><p>What KVO did was to offer an NSKeyValueSetMutationKind enum containing <br>constants for insertion and removal as well as OR and AND operations <br>with other sets. If you don&#39;t want to do that, another possible <br>interface could be to provide two ranges, one representing the range of <br>the affected region before the change, and another representing it <br>afterward. If you had an empty range for &quot;before&quot; and a non-empty range <br>for &quot;after&quot;, that would represent an insertion. The reverse would be <br>removal, and anything else would be a replacement of some kind.<br></p><p>Charles<br></p><p>On 2016-01-12 22:04, David Sweeris wrote:<br>&gt; What about did/willAdd for all collection types, did/willSetAtIndex<br>&gt; for collection types with indexes, and<br>&gt; did/willSetAtIndexRange for collection types that support subscripting<br>&gt; with ranges?<br>&gt; <br>&gt; - Dave<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 13:26, Charles Srstka via swift-evolution <br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, didSet already gets called when a set property is mutated. <br>&gt;&gt; The only difference I see in this proposal is that it lets you know <br>&gt;&gt; more precisely what changed, so that you can more efficiently update <br>&gt;&gt; the UI to reflect the change; i.e. if each item is represented by a <br>&gt;&gt; view object, and you insert an object, the redraw only needs to occur <br>&gt;&gt; for the view corresponding to the newly inserted item instead of <br>&gt;&gt; having to recreate all the views.<br>&gt;&gt; <br>&gt;&gt; Seems reasonable to me. KVO currently provides this facility in <br>&gt;&gt; Objective-C.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-12 07:33, 肇鑫 via swift-evolution wrote:<br>&gt;&gt;&gt; I don&#39;t know if this is a good idea. If you insert an item to an<br>&gt;&gt;&gt; array, what should happen? The items after the inserted item should <br>&gt;&gt;&gt; be<br>&gt;&gt;&gt; considered as removed or not? They indexes are changed but the values<br>&gt;&gt;&gt; not.<br>&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt; On Tue, Jan 12, 2016 at 7:24 PM, James Campbell via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; When declaring a collection, it would be nice to have a way of<br>&gt;&gt;&gt;&gt; knowing when an item is set/added and removed.<br>&gt;&gt;&gt;&gt; For example you could trigger a layer to be added to the layer<br>&gt;&gt;&gt;&gt; hiearchy.<br>&gt;&gt;&gt;&gt; var shapeLayers: [CAShapeLayer] {<br>&gt;&gt;&gt;&gt; didAdd(item) {<br>&gt;&gt;&gt;&gt; addSubLayer(item)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; willRemove(item){<br>&gt;&gt;&gt;&gt; item.removeFromSuperlayer()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;  Wizard<br>&gt;&gt;&gt;&gt; james at supmenow.com<br>&gt;&gt;&gt;&gt; +44 7523 279 698 [1]<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution [2]<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt; Links:<br>&gt;&gt;&gt; ------<br>&gt;&gt;&gt; [1] tel:%2B44%207523%20279%20698<br>&gt;&gt;&gt; [2] https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Custom didSet methods</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 12, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 19:17, cocoadev at charlessoft.com wrote:<br>&gt; <br>&gt; did/willSetAtIndex could be redundant, since that information could be equally well expressed with a range having a length of 1.<br>Good point… Conceptually, I actually really like it. On the other hand, you could make the same argument about subscript, and the fact that the collection types implement separate functions for Index and Range&lt;Index&gt; makes me think there are good reasons to keep them separate (specifically I wonder about the performance implications for wrapping the common case of one Index in a Range&lt;Index&gt;).<br></p><p><br>&gt; The other thing it&#39;s missing is a way to tell what kind of change it was. If something were inserted or removed such that the number of items in the collection were changed, you’d need to know about it to avoid having to redraw whatever view correspond to every single element in the collection coming after the index you&#39;ve changed.<br>&gt; <br>&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing constants for insertion and removal as well as OR and AND operations with other sets. If you don&#39;t want to do that, another possible interface could be to provide two ranges, one representing the range of the affected region before the change, and another representing it afterward. If you had an empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would represent an insertion. The reverse would be removal, and anything else would be a replacement of some kind.<br>&gt; <br>&gt; Charles<br>Also, good points. I guess my idea then is:<br>“did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you don’t care about which element was changed (and for types that aren’t indexable anyway)<br>“did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and “did/WillRemoveAtIndex” for single elements<br>“did/willUpdateInRange”, “did/WillInsertInRange”, and “did/WillRemoveInRange” for multiple elements<br></p><p>That’s a lot of new keywords, though… Oh! What if it was *only* did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>var foo: [Int] {<br>	didUpdate(atIndex: Int) {<br>		…<br>	}<br>	didInsert(inRange: Range&lt;Int&gt;) {<br>		…<br>	}<br>}<br></p><p>Actually, could the “inRange” cases be handled simply by having the runtime call the did/will function multiple times? How much of efficiency hit would it be to have multiple function calls, compared to one function call that iterates through a range?<br></p><p>I like the idea of supporting this kind of “extended” did/willSet functionality, but I don’t think there should be *language features* — stuff that gets its own keyword — that necessarily have lots of runtime overhead.<br></p><p>- Dave<br></p><p>&gt; On 2016-01-12 22:04, David Sweeris wrote:<br>&gt;&gt; What about did/willAdd for all collection types, did/willSetAtIndex<br>&gt;&gt; for collection types with indexes, and<br>&gt;&gt; did/willSetAtIndexRange for collection types that support subscripting<br>&gt;&gt; with ranges?<br>&gt;&gt; - Dave<br>&gt;&gt;&gt; On Jan 12, 2016, at 13:26, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Currently, didSet already gets called when a set property is mutated. The only difference I see in this proposal is that it lets you know more precisely what changed, so that you can more efficiently update the UI to reflect the change; i.e. if each item is represented by a view object, and you insert an object, the redraw only needs to occur for the view corresponding to the newly inserted item instead of having to recreate all the views.<br>&gt;&gt;&gt; Seems reasonable to me. KVO currently provides this facility in Objective-C.<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; On 2016-01-12 07:33, 肇鑫 via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; I don&#39;t know if this is a good idea. If you insert an item to an<br>&gt;&gt;&gt;&gt; array, what should happen? The items after the inserted item should be<br>&gt;&gt;&gt;&gt; considered as removed or not? They indexes are changed but the values<br>&gt;&gt;&gt;&gt; not.<br>&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt; On Tue, Jan 12, 2016 at 7:24 PM, James Campbell via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; When declaring a collection, it would be nice to have a way of<br>&gt;&gt;&gt;&gt;&gt; knowing when an item is set/added and removed.<br>&gt;&gt;&gt;&gt;&gt; For example you could trigger a layer to be added to the layer<br>&gt;&gt;&gt;&gt;&gt; hiearchy.<br>&gt;&gt;&gt;&gt;&gt; var shapeLayers: [CAShapeLayer] {<br>&gt;&gt;&gt;&gt;&gt; didAdd(item) {<br>&gt;&gt;&gt;&gt;&gt; addSubLayer(item)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; willRemove(item){<br>&gt;&gt;&gt;&gt;&gt; item.removeFromSuperlayer()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;  Wizard<br>&gt;&gt;&gt;&gt;&gt; james at supmenow.com<br>&gt;&gt;&gt;&gt;&gt; +44 7523 279 698 [1]<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution [2]<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;&gt; Links:<br>&gt;&gt;&gt;&gt; ------<br>&gt;&gt;&gt;&gt; [1] tel:%2B44%207523%20279%20698<br>&gt;&gt;&gt;&gt; [2] https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 12, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing constants for insertion and removal as well as OR and AND operations with other sets. If you don&#39;t want to do that, another possible interface could be to provide two ranges, one representing the range of the affected region before the change, and another representing it afterward. If you had an empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would represent an insertion. The reverse would be removal, and anything else would be a replacement of some kind.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt; Also, good points. I guess my idea then is:<br>&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you don’t care about which element was changed (and for types that aren’t indexable anyway)<br>&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and “did/WillRemoveAtIndex” for single elements<br>&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and “did/WillRemoveInRange” for multiple elements<br>&gt; <br>&gt; That’s a lot of new keywords, though… Oh! What if it was *only* did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br></p><p>Just a random comment on this thread:  our desire is to introduce property behaviors, and “demote” things like property observers into library features.  This is great because it makes it much easier to extend these capabilities without hacking on the compiler, and will allow you to define custom behaviors in your own code.<br></p><p>I don’t know if the first round of behaviors will actually allow us to eliminate willset/didset though, simply given that they need to poke at the super implementation.  That said, we’d rather work towards fixing those problems: proposals to make the existing property observers richer aren’t likely to be accepted.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 13, 2016 at 03:00:00am</p></header><div class="content"><p>On 2016-01-12 23:45, Chris Lattner wrote:<br>&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum <br>&gt;&gt;&gt; containing constants for insertion and removal as well as OR and AND <br>&gt;&gt;&gt; operations with other sets. If you don&#39;t want to do that, another <br>&gt;&gt;&gt; possible interface could be to provide two ranges, one representing <br>&gt;&gt;&gt; the range of the affected region before the change, and another <br>&gt;&gt;&gt; representing it afterward. If you had an empty range for &quot;before&quot; and <br>&gt;&gt;&gt; a non-empty range for &quot;after&quot;, that would represent an insertion. The <br>&gt;&gt;&gt; reverse would be removal, and anything else would be a replacement of <br>&gt;&gt;&gt; some kind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt; Also, good points. I guess my idea then is:<br>&gt;&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you <br>&gt;&gt; don’t care about which element was changed (and for types that aren’t <br>&gt;&gt; indexable anyway)<br>&gt;&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and <br>&gt;&gt; “did/WillRemoveAtIndex” for single elements<br>&gt;&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and <br>&gt;&gt; “did/WillRemoveInRange” for multiple elements<br>&gt;&gt; <br>&gt;&gt; That’s a lot of new keywords, though… Oh! What if it was *only* <br>&gt;&gt; did/willUpdate, did/willAdd, and did/willRemove, and they were <br>&gt;&gt; overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) <br>&gt;&gt; forms? Like this:<br>&gt; <br>&gt; Just a random comment on this thread:  our desire is to introduce<br>&gt; property behaviors, and “demote” things like property observers into<br>&gt; library features.  This is great because it makes it much easier to<br>&gt; extend these capabilities without hacking on the compiler, and will<br>&gt; allow you to define custom behaviors in your own code.<br>&gt; <br>&gt; I don’t know if the first round of behaviors will actually allow us to<br>&gt; eliminate willset/didset though, simply given that they need to poke<br>&gt; at the super implementation.  That said, we’d rather work towards<br>&gt; fixing those problems: proposals to make the existing property<br>&gt; observers richer aren’t likely to be accepted.<br>&gt; <br>&gt; -Chris<br></p><p>Is the proposal document for the property behaviors concept available <br>online anywhere? I&#39;m intrigued by it, and would like to read about the <br>specifics.<br></p><p>Thanks,<br>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 13, 2016 at 12:00:00am</p></header><div class="content"><p>https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3 &lt;https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3&gt;<br></p><p>&gt; On Jan 13, 2016, at 12:49 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-01-12 23:45, Chris Lattner wrote:<br>&gt;&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing constants for insertion and removal as well as OR and AND operations with other sets. If you don&#39;t want to do that, another possible interface could be to provide two ranges, one representing the range of the affected region before the change, and another representing it afterward. If you had an empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would represent an insertion. The reverse would be removal, and anything else would be a replacement of some kind.<br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; Also, good points. I guess my idea then is:<br>&gt;&gt;&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you don’t care about which element was changed (and for types that aren’t indexable anyway)<br>&gt;&gt;&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and “did/WillRemoveAtIndex” for single elements<br>&gt;&gt;&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and “did/WillRemoveInRange” for multiple elements<br>&gt;&gt;&gt; That’s a lot of new keywords, though… Oh! What if it was *only* did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>&gt;&gt; Just a random comment on this thread:  our desire is to introduce<br>&gt;&gt; property behaviors, and “demote” things like property observers into<br>&gt;&gt; library features.  This is great because it makes it much easier to<br>&gt;&gt; extend these capabilities without hacking on the compiler, and will<br>&gt;&gt; allow you to define custom behaviors in your own code.<br>&gt;&gt; I don’t know if the first round of behaviors will actually allow us to<br>&gt;&gt; eliminate willset/didset though, simply given that they need to poke<br>&gt;&gt; at the super implementation.  That said, we’d rather work towards<br>&gt;&gt; fixing those problems: proposals to make the existing property<br>&gt;&gt; observers richer aren’t likely to be accepted.<br>&gt;&gt; -Chris<br>&gt; <br>&gt; Is the proposal document for the property behaviors concept available online anywhere? I&#39;m intrigued by it, and would like to read about the specifics.<br>&gt; <br>&gt; Thanks,<br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/42df7c4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>This proposal of Property Behaviors is amazing! Thanks a lot Joe Groff<br>&lt;https://github.com/jckarter&gt; (and others).<br></p><p><br>Em qua, 13 de jan de 2016 às 06:50, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;<br>&gt; On Jan 13, 2016, at 12:49 AM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 2016-01-12 23:45, Chris Lattner wrote:<br>&gt;<br>&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing<br>&gt; constants for insertion and removal as well as OR and AND operations with<br>&gt; other sets. If you don&#39;t want to do that, another possible interface could<br>&gt; be to provide two ranges, one representing the range of the affected region<br>&gt; before the change, and another representing it afterward. If you had an<br>&gt; empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would<br>&gt; represent an insertion. The reverse would be removal, and anything else<br>&gt; would be a replacement of some kind.<br>&gt; Charles<br>&gt;<br>&gt; Also, good points. I guess my idea then is:<br>&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you<br>&gt; don’t care about which element was changed (and for types that aren’t<br>&gt; indexable anyway)<br>&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and<br>&gt; “did/WillRemoveAtIndex” for single elements<br>&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and<br>&gt; “did/WillRemoveInRange” for multiple elements<br>&gt; That’s a lot of new keywords, though… Oh! What if it was *only*<br>&gt; did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded<br>&gt; with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>&gt;<br>&gt; Just a random comment on this thread:  our desire is to introduce<br>&gt; property behaviors, and “demote” things like property observers into<br>&gt; library features.  This is great because it makes it much easier to<br>&gt; extend these capabilities without hacking on the compiler, and will<br>&gt; allow you to define custom behaviors in your own code.<br>&gt; I don’t know if the first round of behaviors will actually allow us to<br>&gt; eliminate willset/didset though, simply given that they need to poke<br>&gt; at the super implementation.  That said, we’d rather work towards<br>&gt; fixing those problems: proposals to make the existing property<br>&gt; observers richer aren’t likely to be accepted.<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Is the proposal document for the property behaviors concept available<br>&gt; online anywhere? I&#39;m intrigued by it, and would like to read about the<br>&gt; specifics.<br>&gt;<br>&gt; Thanks,<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/3ec7118e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Custom didSet methods</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Charles,<br></p><p>I believe you can find the latest version (as of yesterday) here:<br></p><p>https://gist.github.com/jckarter/50b838e7f036fe85eaa3 &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt;<br>See also this email from Joe Groff summarizing the changes:<br></p><p>&gt; On Jan 13, 2016, at 5:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3 &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt;<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br></p><p><br>&gt; On Jan 13, 2016, at 3:49 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-01-12 23:45, Chris Lattner wrote:<br>&gt;&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing constants for insertion and removal as well as OR and AND operations with other sets. If you don&#39;t want to do that, another possible interface could be to provide two ranges, one representing the range of the affected region before the change, and another representing it afterward. If you had an empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would represent an insertion. The reverse would be removal, and anything else would be a replacement of some kind.<br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; Also, good points. I guess my idea then is:<br>&gt;&gt;&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you don’t care about which element was changed (and for types that aren’t indexable anyway)<br>&gt;&gt;&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and “did/WillRemoveAtIndex” for single elements<br>&gt;&gt;&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and “did/WillRemoveInRange” for multiple elements<br>&gt;&gt;&gt; That’s a lot of new keywords, though… Oh! What if it was *only* did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>&gt;&gt; Just a random comment on this thread:  our desire is to introduce<br>&gt;&gt; property behaviors, and “demote” things like property observers into<br>&gt;&gt; library features.  This is great because it makes it much easier to<br>&gt;&gt; extend these capabilities without hacking on the compiler, and will<br>&gt;&gt; allow you to define custom behaviors in your own code.<br>&gt;&gt; I don’t know if the first round of behaviors will actually allow us to<br>&gt;&gt; eliminate willset/didset though, simply given that they need to poke<br>&gt;&gt; at the super implementation.  That said, we’d rather work towards<br>&gt;&gt; fixing those problems: proposals to make the existing property<br>&gt;&gt; observers richer aren’t likely to be accepted.<br>&gt;&gt; -Chris<br>&gt; <br>&gt; Is the proposal document for the property behaviors concept available online anywhere? I&#39;m intrigued by it, and would like to read about the specifics.<br>&gt; <br>&gt; Thanks,<br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/bd64b741/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Custom didSet methods</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>I understand and I am aware of this proposal. I only raised this since<br>collections are a primitive object type that are used quite frequently in<br>swift. I think it would be acceptable to introduce a generic way of knowing<br>when an item was added, updated or removed which could be demoted with set<br>and get.<br></p><p>I think the pros outweigh the cons. Previous proposals such as default<br>initialisers are either too complex / niche or can already be done via the<br>swift language. So are better implemented with property behaviours.<br></p><p><br>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Jan 13, 2016 at 4:45 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing<br>&gt; constants for insertion and removal as well as OR and AND operations with<br>&gt; other sets. If you don&#39;t want to do that, another possible interface could<br>&gt; be to provide two ranges, one representing the range of the affected region<br>&gt; before the change, and another representing it afterward. If you had an<br>&gt; empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would<br>&gt; represent an insertion. The reverse would be removal, and anything else<br>&gt; would be a replacement of some kind.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Charles<br>&gt; &gt; Also, good points. I guess my idea then is:<br>&gt; &gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you<br>&gt; don’t care about which element was changed (and for types that aren’t<br>&gt; indexable anyway)<br>&gt; &gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and<br>&gt; “did/WillRemoveAtIndex” for single elements<br>&gt; &gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and<br>&gt; “did/WillRemoveInRange” for multiple elements<br>&gt; &gt;<br>&gt; &gt; That’s a lot of new keywords, though… Oh! What if it was *only*<br>&gt; did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded<br>&gt; with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>&gt;<br>&gt; Just a random comment on this thread:  our desire is to introduce property<br>&gt; behaviors, and “demote” things like property observers into library<br>&gt; features.  This is great because it makes it much easier to extend these<br>&gt; capabilities without hacking on the compiler, and will allow you to define<br>&gt; custom behaviors in your own code.<br>&gt;<br>&gt; I don’t know if the first round of behaviors will actually allow us to<br>&gt; eliminate willset/didset though, simply given that they need to poke at the<br>&gt; super implementation.  That said, we’d rather work towards fixing those<br>&gt; problems: proposals to make the existing property observers richer aren’t<br>&gt; likely to be accepted.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/087adc1e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Custom didSet methods</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Agreed. I hadn’t read that thread yet (or at least hadn’t thought about it enough) when I posted my comments. I know I’m not the OP, but for FWIW I’m more than willing to for this to get merged into the “Behaviors” suggestion. I don’t even think Behaviors would have to be changed… Seems like a proper superset of this idea.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 12, 2016, at 20:45, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 12, 2016, at 8:07 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; What KVO did was to offer an NSKeyValueSetMutationKind enum containing constants for insertion and removal as well as OR and AND operations with other sets. If you don&#39;t want to do that, another possible interface could be to provide two ranges, one representing the range of the affected region before the change, and another representing it afterward. If you had an empty range for &quot;before&quot; and a non-empty range for &quot;after&quot;, that would represent an insertion. The reverse would be removal, and anything else would be a replacement of some kind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt; Also, good points. I guess my idea then is:<br>&gt;&gt; “did/willUpdate”, “did/willInsert”, and “did/willRemove” for when you don’t care about which element was changed (and for types that aren’t indexable anyway)<br>&gt;&gt; “did/willUpdateAtIndex”, “did/WillInsertAtIndex”, and “did/WillRemoveAtIndex” for single elements<br>&gt;&gt; “did/willUpdateInRange”, “did/WillInsertInRange”, and “did/WillRemoveInRange” for multiple elements<br>&gt;&gt; <br>&gt;&gt; That’s a lot of new keywords, though… Oh! What if it was *only* did/willUpdate, did/willAdd, and did/willRemove, and they were overloaded with (), (atIndex: Index), and (inRange: Range&lt;Index&gt;) forms? Like this:<br>&gt; <br>&gt; Just a random comment on this thread:  our desire is to introduce property behaviors, and “demote” things like property observers into library features.  This is great because it makes it much easier to extend these capabilities without hacking on the compiler, and will allow you to define custom behaviors in your own code.<br>&gt; <br>&gt; I don’t know if the first round of behaviors will actually allow us to eliminate willset/didset though, simply given that they need to poke at the super implementation.  That said, we’d rather work towards fixing those problems: proposals to make the existing property observers richer aren’t likely to be accepted.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
