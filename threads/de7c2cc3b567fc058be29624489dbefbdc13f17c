<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Late Pitch] open/public protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>August 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello dear Swift community,<br></p><p>I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br></p><p>Conformances to protocols is logically the same as inheritances on classes.<br></p><p>Conformances == (abstract) inheritance<br>That said we should allow protocols to be open/public like we now allow this distinction for classes.<br></p><p>open protocol from module A should mean that I’m allowed to conform to it in module B<br>public protocol will act as an interface in module B<br>Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br></p><p>A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable.<br></p><p>// Before:<br></p><p>// In module A<br>public protocol Proto {<br>  func doSomething()<br>}<br></p><p>open class Base : Proto {<br>  // Dissallow to override - this would be a common mistake<br>  public func doSomething() {}<br>}<br></p><p>// Used in module B - so it should be `open` after all<br>class Test : Proto {<br> func doSomething() {}<br>}<br></p><p>// After:<br>// In module A<br>open protocol Proto {<br>  func doSomething()<br>}<br></p><p>open class Base : Proto {<br>  // Whops we have to grant the ability to override this method now<br>  // I made a mistake designing my protocol in Swift 3.0 :/<br>  open func doSomething() {}<br>}<br></p><p>// In module B<br>class Test2 : Base {<br>  // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>  override func doSomething() {}<br>}<br>Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/de7cf17c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Late Pitch] open/public protocols</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt; <br>&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt; <br>At least it is very, very similar, and most of the syntax is identical.<br>Considering the demand for &quot;sealed&quot; protocols, imho this inconsistency should be addressed as soon as possible.<br></p><p>Afair, the decision for &quot;public as restriction of open&quot; happened quite quickly… I guess simply adding &quot;sealed&quot; would have spared Swift from a huge, breaking change and avoided the protocol-issue as well.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/2bc84e41/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Late Pitch] open/public protocols</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>August 25, 2016 at 01:00:00am</p></header><div class="content"><p>On 8/22/2016 2:40 PM, Adrian Zubarev via swift-evolution wrote:<br>&gt;<br>&gt; Hello dear Swift community,<br>&gt;<br>&gt; I was updating some of my libraries where I noticed that the new<br>&gt; |open| access modifier made the |public| modifier inconsistent in one way.<br>&gt;<br>&gt; Conformances to protocols is logically the same as inheritances on<br>&gt; classes.<br>&gt;<br>I don&#39;t understand why this is the case. From a practical perspective,<br>non-open classes by default were pushed in order to guard against the<br>fragile base class problem. Classes always carry implementations with<br>the methods you can override, while protocols don&#39;t (in the same way). A<br>&quot;fragile base protocol extension implementation&quot; problem can be avoided<br>today by designing your protocols properly. Not to mention that by<br>definition, protocols are designed to be conformed to by other types,<br>while not all classes are designed to be subclassed. What problem aside<br>from a perceived inconsistency would allowing for non-open protocols by<br>default solve?<br></p><p>&gt;   * |Conformances == (abstract) inheritance|<br>&gt;<br>&gt; That said we should allow protocols to be |open/public| like we now<br>&gt; allow this distinction for classes.<br>&gt;<br>&gt;   * |open protocol| from module A should mean that I’m allowed to<br>&gt;     conform to it in module B<br>&gt;   * |public protocol| will act as an interface in module B<br>&gt;<br>&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency<br>&gt; and it’s a ‘really need’ + a source breaking change in general.<br>&gt;<br>&gt; A common mistake in Swift 3.0 would be to hide protocol members behind<br>&gt; |public| modifier for protocols that meant to be |open|. If a protocol<br>&gt; member in an open class is disallowed to be overridden by the |public|<br>&gt; modifier and this behavior is fixed, that will imply that you’ll have<br>&gt; to open the member which you intended to be not overridable.<br>&gt;<br>&gt; |// Before: // In module A public protocol Proto { func doSomething() }<br>&gt; open class Base : Proto { // Dissallow to override - this would be a<br>&gt; common mistake public func doSomething() {} } // Used in module B - so<br>&gt; it should be `open` after all class Test : Proto { func doSomething()<br>&gt; {} } // After: // In module A open protocol Proto { func doSomething()<br>&gt; } open class Base : Proto { // Whops we have to grant the ability to<br>&gt; override this method now // I made a mistake designing my protocol in<br>&gt; Swift 3.0 :/ open func doSomething() {} } // In module B class Test2 :<br>&gt; Base { // Uuuuuuh I can do bad things with this now if the module A<br>&gt; was not redesigned to fix this. :))) override func doSomething() {} } |<br>This example is a little confusing; do you mean that if protocols are<br>given the same open semantics as classes that there would be a<br>cross-module implementation problem? If so, isn&#39;t that an argument<br>against this?<br></p><p>I don&#39;t see a problem with just letting the class&#39;s open/public modifier<br>be the last word on any implemented public protocols. If a public<br>protocol is applied to an open class, then that protocol method should<br>be allowed to be declared as either open or public, which should be<br>enough to satisfy the protocol conformance from the protocol&#39;s perspective.<br>&gt;<br>&gt; Personally I don’t have any feeling of how huge the impact might be on<br>&gt; Swift if this behavior will be fixed. I also cannot tell if it’s<br>&gt; something for Swift 3.x or Swift 4.0.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/c62aa35e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Late Pitch] open/public protocols</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 25, 2016 at 11:00:00am</p></header><div class="content"><p>This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br></p><p>Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br></p><p>Karl<br></p><p>&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello dear Swift community,<br>&gt; <br>&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt; <br>&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt; <br>&gt; Conformances == (abstract) inheritance<br>&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt; <br>&gt; open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt; public protocol will act as an interface in module B<br>&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt; <br>&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt; <br>&gt; // Before:<br>&gt; <br>&gt; // In module A<br>&gt; public protocol Proto {<br>&gt;   func doSomething()<br>&gt; }<br>&gt; <br>&gt; open class Base : Proto {<br>&gt;   // Dissallow to override - this would be a common mistake<br>&gt;   public func doSomething() {}<br>&gt; }<br>&gt; <br>&gt; // Used in module B - so it should be `open` after all<br>&gt; class Test : Proto {<br>&gt;  func doSomething() {}<br>&gt; }<br>&gt; <br>&gt; // After:<br>&gt; // In module A<br>&gt; open protocol Proto {<br>&gt;   func doSomething()<br>&gt; }<br>&gt; <br>&gt; open class Base : Proto {<br>&gt;   // Whops we have to grant the ability to override this method now<br>&gt;   // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;   open func doSomething() {}<br>&gt; }<br>&gt; <br>&gt; // In module B<br>&gt; class Test2 : Base {<br>&gt;   // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;   override func doSomething() {}<br>&gt; }<br>&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/9ac87157/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Late Pitch] open/public protocols</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br>&gt; <br>&gt; Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br></p><p>Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br></p><p>John.<br></p><p>&gt; <br>&gt; Karl<br>&gt; <br>&gt;&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello dear Swift community,<br>&gt;&gt; <br>&gt;&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt;&gt; <br>&gt;&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt;&gt; <br>&gt;&gt; Conformances == (abstract) inheritance<br>&gt;&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt;&gt; <br>&gt;&gt; open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt;&gt; public protocol will act as an interface in module B<br>&gt;&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt;&gt; <br>&gt;&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt;&gt; <br>&gt;&gt; // Before:<br>&gt;&gt; <br>&gt;&gt; // In module A<br>&gt;&gt; public protocol Proto {<br>&gt;&gt;   func doSomething()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; open class Base : Proto {<br>&gt;&gt;   // Dissallow to override - this would be a common mistake<br>&gt;&gt;   public func doSomething() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Used in module B - so it should be `open` after all<br>&gt;&gt; class Test : Proto {<br>&gt;&gt;  func doSomething() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // After:<br>&gt;&gt; // In module A<br>&gt;&gt; open protocol Proto {<br>&gt;&gt;   func doSomething()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; open class Base : Proto {<br>&gt;&gt;   // Whops we have to grant the ability to override this method now<br>&gt;&gt;   // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;&gt;   open func doSomething() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // In module B<br>&gt;&gt; class Test2 : Base {<br>&gt;&gt;   // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;&gt;   override func doSomething() {}<br>&gt;&gt; }<br>&gt;&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/7b9aa020/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Shall we revive this discussion?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. August 2016 um 19:29:13, John McCall (rjmccall at apple.com) schrieb:<br></p><p>On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br></p><p>Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br></p><p>Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br></p><p>John.<br></p><p><br>Karl<br></p><p>On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hello dear Swift community,<br></p><p>I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br></p><p>Conformances to protocols is logically the same as inheritances on classes. <br></p><p>Conformances == (abstract) inheritance<br>That said we should allow protocols to be open/public like we now allow this distinction for classes.<br></p><p>open protocol from module A should mean that I’m allowed to conform to it in module B<br>public protocol will act as an interface in module B<br>Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br></p><p>A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br></p><p>// Before:<br></p><p>// In module A<br>public protocol Proto {<br>  func doSomething()<br>}<br></p><p>open class Base : Proto {<br>  // Dissallow to override - this would be a common mistake<br>  public func doSomething() {}<br>}<br></p><p>// Used in module B - so it should be `open` after all<br>class Test : Proto {<br> func doSomething() {}<br>}<br></p><p>// After:<br>// In module A<br>open protocol Proto {<br>  func doSomething()<br>}<br></p><p>open class Base : Proto {<br>  // Whops we have to grant the ability to override this method now<br>  // I made a mistake designing my protocol in Swift 3.0 :/<br>  open func doSomething() {}<br>}<br></p><p>// In module B<br>class Test2 : Base {<br>  // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>  override func doSomething() {}<br>}<br>Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/d8e0e888/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I would say we should, I think we moved a bit hastily and the strict push for non subclassable by default and the sealed by default discussion may still yield nasty side effects that are exponentially costlier as we move to Swift 4+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Oct 2016, at 17:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Shall we revive this discussion?<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 25. August 2016 um 19:29:13, John McCall (rjmccall at apple.com) schrieb:<br>&gt; <br>&gt;&gt;&gt; On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br>&gt;&gt; <br>&gt;&gt; Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conformances == (abstract) inheritance<br>&gt;&gt;&gt;&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt;&gt;&gt;&gt; public protocol will act as an interface in module B<br>&gt;&gt;&gt;&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Before:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt; public protocol Proto {<br>&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;   // Dissallow to override - this would be a common mistake<br>&gt;&gt;&gt;&gt;   public func doSomething() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Used in module B - so it should be `open` after all<br>&gt;&gt;&gt;&gt; class Test : Proto {<br>&gt;&gt;&gt;&gt;  func doSomething() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // After:<br>&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt; open protocol Proto {<br>&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;   // Whops we have to grant the ability to override this method now<br>&gt;&gt;&gt;&gt;   // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;&gt;&gt;&gt;   open func doSomething() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // In module B<br>&gt;&gt;&gt;&gt; class Test2 : Base {<br>&gt;&gt;&gt;&gt;   // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;&gt;&gt;&gt;   override func doSomething() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/3781c7e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>October  7, 2016 at 12:00:00pm</p></header><div class="content"><p>I don’t disagree that there may have been some hasty movement on this originally, but I don’t think the solution is to move hastily again and second-guess everything before the dust has even had time to settle.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Oct 7, 2016, at 12:44 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would say we should, I think we moved a bit hastily and the strict push for non subclassable by default and the sealed by default discussion may still yield nasty side effects that are exponentially costlier as we move to Swift 4+<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 7 Oct 2016, at 17:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Shall we revive this discussion?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 25. August 2016 um 19:29:13, John McCall (rjmccall at apple.com) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• Conformances == (abstract) inheritance<br>&gt;&gt;&gt;&gt;&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt;&gt;&gt;&gt;&gt; 	• public protocol will act as an interface in module B<br>&gt;&gt;&gt;&gt;&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Before:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt; public protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;   // Dissallow to override - this would be a common mistake<br>&gt;&gt;&gt;&gt;&gt;   public func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Used in module B - so it should be `open` after all<br>&gt;&gt;&gt;&gt;&gt; class Test : Proto {<br>&gt;&gt;&gt;&gt;&gt;  func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // After:<br>&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt; open protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;   // Whops we have to grant the ability to override this method now<br>&gt;&gt;&gt;&gt;&gt;   // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;&gt;&gt;&gt;&gt;   open func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // In module B<br>&gt;&gt;&gt;&gt;&gt; class Test2 : Base {<br>&gt;&gt;&gt;&gt;&gt;   // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;&gt;&gt;&gt;&gt;   override func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  7, 2016 at 07:00:00pm</p></header><div class="content"><p>True too, but dust settling will mean that for each speck the justification burden will rise quite massively. Not fixing this for Swift 4 phase 1 may mean a breaking change very very hard to justify for Swift 4 phase 2 which is for additive changes IIRC and even harder for Swift 5 and harder again on Swift 6 unless I am missing the core team vision for Swift&#39;s evolution.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Oct 2016, at 18:50, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; I don’t disagree that there may have been some hasty movement on this originally, but I don’t think the solution is to move hastily again and second-guess everything before the dust has even had time to settle.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 12:44 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would say we should, I think we moved a bit hastily and the strict push for non subclassable by default and the sealed by default discussion may still yield nasty side effects that are exponentially costlier as we move to Swift 4+<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Oct 2016, at 17:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Shall we revive this discussion?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 25. August 2016 um 19:29:13, John McCall (rjmccall at apple.com) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • Conformances == (abstract) inheritance<br>&gt;&gt;&gt;&gt;&gt;&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt;&gt;&gt;&gt;&gt;&gt;    • public protocol will act as an interface in module B<br>&gt;&gt;&gt;&gt;&gt;&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Before:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt;&gt; public protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;&gt;  func doSomething()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Dissallow to override - this would be a common mistake<br>&gt;&gt;&gt;&gt;&gt;&gt;  public func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Used in module B - so it should be `open` after all<br>&gt;&gt;&gt;&gt;&gt;&gt; class Test : Proto {<br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // After:<br>&gt;&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt;&gt; open protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;&gt;  func doSomething()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Whops we have to grant the ability to override this method now<br>&gt;&gt;&gt;&gt;&gt;&gt;  // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;&gt;&gt;&gt;&gt;&gt;  open func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // In module B<br>&gt;&gt;&gt;&gt;&gt;&gt; class Test2 : Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;&gt;&gt;&gt;&gt;&gt;  override func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 11:05 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; True too, but dust settling will mean that for each speck the justification burden will rise quite massively. Not fixing this for Swift 4 phase 1 may mean a breaking change very very hard to justify for Swift 4 phase 2 which is for additive changes IIRC and even harder for Swift 5 and harder again on Swift 6 unless I am missing the core team vision for Swift&#39;s evolution.<br></p><p>We haven’t planned what Swift 4 phase 2 will be, but I am pretty sure that important model changes will always be considered.  That said, reopening this discussion only makes sense if there is no insight or information.  “fileprivate” and “open” were both *extensively* discussed when the decision was made, I don’t think they were “rushed”.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] open/public protocols</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:44 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; I would say we should, I think we moved a bit hastily and the strict push for non subclassable by default and the sealed by default discussion may still yield nasty side effects that are exponentially costlier as we move to Swift 4+<br></p><p>It sounds like you&#39;re talking about re-opening the public/open class discussion, which is not the discussion I understand Adrian to be asking about.<br></p><p>If people would like to talk about adding some way to express a protocol that can be implemented only internally but still used elsewhere, they should feel free.  The core team isn&#39;t inviting that kind of formal proposal yet, but that shouldn&#39;t prevent any discussion here.  However, please understand that changing the interpretation of &quot;public&quot; would be a source-breaking change and therefore needs to meet a much higher bar in 4.0 than it would have in 3.0; that may significantly shape your discussion.<br></p><p>John.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 7 Oct 2016, at 17:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Shall we revive this discussion?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 25. August 2016 um 19:29:13, John McCall (rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 25, 2016, at 2:29 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; This is not a new inconsistency. We’ve known about this since “open” was first proposed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having sealed protocols would be nice, but it’s too late for Swift 3 IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything is too late for Swift 3.  Bug fixes are about to be too late for Swift 3, much less any actual language changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22 Aug 2016, at 20:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was updating some of my libraries where I noticed that the new open access modifier made the public modifier inconsistent in one way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conformances to protocols is logically the same as inheritances on classes. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conformances == (abstract) inheritance<br>&gt;&gt;&gt;&gt;&gt; That said we should allow protocols to be open/public like we now allow this distinction for classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; open protocol from module A should mean that I’m allowed to conform to it in module B<br>&gt;&gt;&gt;&gt;&gt; public protocol will act as an interface in module B<br>&gt;&gt;&gt;&gt;&gt; Not only sounds this behavior like ‘nice to have’, it’s inconsistency and it’s a ‘really need’ + a source breaking change in general.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A common mistake in Swift 3.0 would be to hide protocol members behind public modifier for protocols that meant to be open. If a protocol member in an open class is disallowed to be overridden by the public modifier and this behavior is fixed, that will imply that you’ll have to open the member which you intended to be not overridable. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Before:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt; public protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;   // Dissallow to override - this would be a common mistake<br>&gt;&gt;&gt;&gt;&gt;   public func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Used in module B - so it should be `open` after all<br>&gt;&gt;&gt;&gt;&gt; class Test : Proto {<br>&gt;&gt;&gt;&gt;&gt;  func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // After:<br>&gt;&gt;&gt;&gt;&gt; // In module A<br>&gt;&gt;&gt;&gt;&gt; open protocol Proto {<br>&gt;&gt;&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; open class Base : Proto {<br>&gt;&gt;&gt;&gt;&gt;   // Whops we have to grant the ability to override this method now<br>&gt;&gt;&gt;&gt;&gt;   // I made a mistake designing my protocol in Swift 3.0 :/<br>&gt;&gt;&gt;&gt;&gt;   open func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // In module B<br>&gt;&gt;&gt;&gt;&gt; class Test2 : Base {<br>&gt;&gt;&gt;&gt;&gt;   // Uuuuuuh I can do bad things with this now if the module A was not redesigned to fix this. :)))<br>&gt;&gt;&gt;&gt;&gt;   override func doSomething() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Personally I don’t have any feeling of how huge the impact might be on Swift if this behavior will be fixed. I also cannot tell if it’s something for Swift 3.x or Swift 4.0.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/02960392/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
