<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>Swift currently requires a default pattern matching clause when you switch on an existential or a non-final class even if the protocol or class is non-public and all cases are covered.  It would be really nice if the default clause were not necessary in this case.  The compiler has the necessary information to prove exhaustiveness.<br></p><p>Related to this is the idea of introducing something like a `sealed` modifier that could be applied to public protocols and classes.  The protocol or class would be visible when the module is imported, but conformances or subclasses outside the declaring module would be prohibited.  Internal and private protocols and classes would implicitly be sealed since they are not visible outside the module.  Any protocols that inherit from a sealed protocol or classes that inherit from a sealed class would also be implicitly sealed (if we didn’t do this the sealing of the superprotocol / superclass could be violated by conforming to or inheriting from a subprotocol / subclass).<br></p><p>Here are examples that I would like to see be valid:<br></p><p>protocol P {} <br>// alternatively public sealed protocol P {}<br>struct P1: P {}<br>struct P2: P {}<br></p><p>func p(p: P) -&gt; Int {<br>    switch p {<br>    case is P1: return 1 // alternatively an `as` cast<br>    case is P2: return 2 // alternatively an `as` cast<br>    }<br>}<br></p><p>class C {}<br>// alternatively public sealed class C {}<br>class C1: C {}<br>class C2: C {}<br></p><p>func c(c: C) -&gt; Int {<br>    switch c {<br>    case is C1: return 1 // alternatively an `as` cast<br>    case is C2: return 2 // alternatively an `as` cast<br>    case is C: return 0   // alternatively an `as` cast<br>    }<br>}<br></p><p>I am wondering if this is something the community is interested in.  If so, I am wondering if this is something that might be possible in the Swift 3 timeframe (maybe just for private and internal protocols and classes) or if it should wait for Swift 4 (this is likely the case).<br></p><p>-Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>I have been hoping for the exhaustive pattern matching feature for a while<br>now, and would love to see a proposal.<br></p><p>Austin<br></p><p>On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt; on an existential or a non-final class even if the protocol or class is<br>&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt; default clause were not necessary in this case.  The compiler has the<br>&gt; necessary information to prove exhaustiveness.<br>&gt;<br>&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt; modifier that could be applied to public protocols and classes.  The<br>&gt; protocol or class would be visible when the module is imported, but<br>&gt; conformances or subclasses outside the declaring module would be<br>&gt; prohibited.  Internal and private protocols and classes would implicitly be<br>&gt; sealed since they are not visible outside the module.  Any protocols that<br>&gt; inherit from a sealed protocol or classes that inherit from a sealed class<br>&gt; would also be implicitly sealed (if we didn’t do this the sealing of the<br>&gt; superprotocol / superclass could be violated by conforming to or inheriting<br>&gt; from a subprotocol / subclass).<br>&gt;<br>&gt; Here are examples that I would like to see be valid:<br>&gt;<br>&gt; protocol P {}<br>&gt; // alternatively public sealed protocol P {}<br>&gt; struct P1: P {}<br>&gt; struct P2: P {}<br>&gt;<br>&gt; func p(p: P) -&gt; Int {<br>&gt;     switch p {<br>&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class C {}<br>&gt; // alternatively public sealed class C {}<br>&gt; class C1: C {}<br>&gt; class C2: C {}<br>&gt;<br>&gt; func c(c: C) -&gt; Int {<br>&gt;     switch c {<br>&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; I am wondering if this is something the community is interested in.  If<br>&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;<br>&gt; -Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/ca02a97b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 24, 2016 at 05:00:00pm</p></header><div class="content"><p>I like this but I think it would be a lot hard to ensure you have all<br>subclasses covered. Think of frameworks that could provide many<br>unsealed classes. You could also have an object that would have to<br>handle a large subtree (NSObject?) and the order in which the cases<br>are evaluated would matter just as in exception handling in languages<br>such as Java (or require some evaluation from the compiler to raise<br>warnings). I&#39;m +1 for this but these should be open-ended like strings<br>and require the default case.<br></p><p>On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt; now, and would love to see a proposal.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;<br>&gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; subprotocol / subclass).<br>&gt;&gt;<br>&gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;<br>&gt;&gt; protocol P {}<br>&gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; struct P1: P {}<br>&gt;&gt; struct P2: P {}<br>&gt;&gt;<br>&gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;     switch p {<br>&gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C {}<br>&gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; class C1: C {}<br>&gt;&gt; class C2: C {}<br>&gt;&gt;<br>&gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;     switch c {<br>&gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>If you pattern match on a type that is declared internal or private, it is<br>impossible for the compiler to not have an exhaustive list of subclasses<br>that it can check against.<br></p><p>Austin<br></p><p>On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt; subclasses covered. Think of frameworks that could provide many<br>&gt; unsealed classes. You could also have an object that would have to<br>&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt; are evaluated would matter just as in exception handling in languages<br>&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt; and require the default case.<br>&gt;<br>&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a<br>&gt; while<br>&gt; &gt; now, and would love to see a proposal.<br>&gt; &gt;<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you<br>&gt; switch<br>&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt; &gt;&gt; conformances or subclasses outside the declaring module would be<br>&gt; prohibited.<br>&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed<br>&gt; since<br>&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit<br>&gt; from a<br>&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also<br>&gt; be<br>&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the<br>&gt; superprotocol /<br>&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt; &gt;&gt; subprotocol / subclass).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol P {}<br>&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt; &gt;&gt; struct P1: P {}<br>&gt; &gt;&gt; struct P2: P {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt; &gt;&gt;     switch p {<br>&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class C {}<br>&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt; &gt;&gt; class C1: C {}<br>&gt; &gt;&gt; class C2: C {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt; &gt;&gt;     switch c {<br>&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the<br>&gt; Swift<br>&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes)<br>&gt; or<br>&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Matthew<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/ba1d646a/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 24, 2016 at 09:00:00pm</p></header><div class="content"><p>Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt; and require the default case.<br>&gt;&gt; <br>&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/01263ce0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 24, 2016, at 9:01 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br></p><p>Yes, that is why I suggest introducing &#39;sealed&#39;.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/7a5294fb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br></p><p><br>-----Original Message-----<br>From: &quot;David Sweeris&quot; &lt;davesweeris at mac.com&gt;<br>Sent: ‎24/‎05/‎2016 11:01 PM<br>To: &quot;Austin Zheng&quot; &lt;austinzheng at gmail.com&gt;<br>Cc: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br></p><p>Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br></p><p>Sent from my iPhone<br></p><p>On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br></p><p><br>Austin<br></p><p><br>On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>I like this but I think it would be a lot hard to ensure you have all<br>subclasses covered. Think of frameworks that could provide many<br>unsealed classes. You could also have an object that would have to<br>handle a large subtree (NSObject?) and the order in which the cases<br>are evaluated would matter just as in exception handling in languages<br>such as Java (or require some evaluation from the compiler to raise<br>warnings). I&#39;m +1 for this but these should be open-ended like strings<br>and require the default case.<br></p><p>On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br></p><p>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt; now, and would love to see a proposal.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;<br>&gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; subprotocol / subclass).<br>&gt;&gt;<br>&gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;<br>&gt;&gt; protocol P {}<br>&gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; struct P1: P {}<br>&gt;&gt; struct P2: P {}<br>&gt;&gt;<br>&gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;     switch p {<br>&gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C {}<br>&gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; class C1: C {}<br>&gt;&gt; class C2: C {}<br>&gt;&gt;<br>&gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;     switch c {<br>&gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/786172f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 07:00:00am</p></header><div class="content"><p>There are legit cases where you want to be able to subclass the class within a module (framework), but you don&#39;t want others to subclass it out of the framework in order to provide some integrity. This is usually done nowadays (on many places within Apple&#39;s frameworks) by an assertion in init.<br></p><p>It is very similar to declaring public internal(set) var - but with a class and subclassing instead of modifying the contents of a var.<br></p><p>And without it, you can&#39;t do this efficiently - the default case is dangerous if you have a variable that returns non-nil value depending on the class - the default case usually has fatalError() inside - forgetting to add the clause for a new class won&#39;t be discovered until runtime.<br></p><p>I personally bypass this currently by having an enum of classes defined with an initializer init(instance:) and then switch by the enum, which is safer than switch by type - but it&#39;s extra work.<br></p><p>Charlie<br></p><p><br>&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt; <br>&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt; and require the default case.<br>&gt;&gt; <br>&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/a6830ddc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 12:38 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are legit cases where you want to be able to subclass the class within a module (framework), but you don&#39;t want others to subclass it out of the framework in order to provide some integrity. This is usually done nowadays (on many places within Apple&#39;s frameworks) by an assertion in init.<br>&gt; <br>&gt; It is very similar to declaring public internal(set) var - but with a class and subclassing instead of modifying the contents of a var.<br>&gt; <br>&gt; And without it, you can&#39;t do this efficiently - the default case is dangerous if you have a variable that returns non-nil value depending on the class - the default case usually has fatalError() inside - forgetting to add the clause for a new class won&#39;t be discovered until runtime.<br></p><p>+1 about not being notified of missing cases if you add a new conforming type or subclass.  This is a big part of the reason for doing tis.<br></p><p>&gt; <br>&gt; I personally bypass this currently by having an enum of classes defined with an initializer init(instance:) and then switch by the enum, which is safer than switch by type - but it&#39;s extra work.<br></p><p>Do you mean safer because you con’t forget to add new cases?  Or just safer in general?<br></p><p>One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br></p><p>&gt; <br>&gt; Charlie<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt; <br>&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/4c84c560/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; I personally bypass this currently by having an enum of classes defined with an initializer init(instance:) and then switch by the enum, which is safer than switch by type - but it&#39;s extra work.<br>&gt; <br>&gt; Do you mean safer because you con’t forget to add new cases?  Or just safer in general?<br></p><p>Safer as in only having to update one place. When you add one of these classes, you only update the enum (which calls fatalError if it gets an unknown class in the initializer - see example below) - the rest is handled by the compiler. As opposed to searching for all the switches based on type.<br></p><p>Note that this is just a workaround for not having sealed classes for now - I do not mean that this is better than having sealed classes.<br></p><p>enum AnimalSubclasses {<br>	<br>	case Dog<br>	case Cat<br></p><p>	init(instance: Animal) {<br>		switch instance {<br>		case is Dog: self = .Dog<br>		case is Cat: self = .Cat<br>		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>	}<br></p><p>}<br></p><p>&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c34f62b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:10 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I personally bypass this currently by having an enum of classes defined with an initializer init(instance:) and then switch by the enum, which is safer than switch by type - but it&#39;s extra work.<br>&gt;&gt; <br>&gt;&gt; Do you mean safer because you con’t forget to add new cases?  Or just safer in general?<br>&gt; <br>&gt; Safer as in only having to update one place. When you add one of these classes, you only update the enum (which calls fatalError if it gets an unknown class in the initializer - see example below) - the rest is handled by the compiler. As opposed to searching for all the switches based on type.<br>&gt; <br>&gt; Note that this is just a workaround for not having sealed classes for now - I do not mean that this is better than having sealed classes.<br></p><p>Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br></p><p>&gt; <br>&gt; enum AnimalSubclasses {<br>&gt; 	<br>&gt; 	case Dog<br>&gt; 	case Cat<br>&gt; <br>&gt; 	init(instance: Animal) {<br>&gt; 		switch instance {<br>&gt; 		case is Dog: self = .Dog<br>&gt; 		case is Cat: self = .Cat<br>&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt; 	}<br>&gt; <br>&gt; }<br>&gt; <br>&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt; From: David Sweeris<br>&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt; To: Austin Zheng<br>&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa; swift-evolution<br>&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c330219d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br></p><p>This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt; 	<br>&gt;&gt; 	case Dog<br>&gt;&gt; 	case Cat<br>&gt;&gt; <br>&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt; 		switch instance {<br>&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/3483f308/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt; <br>&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br></p><p>Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng<br>&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b74a9ed6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, May 25, 2016 at 12:49 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype<br>&gt; case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would<br>&gt; prevent this possibility.<br>&gt;<br>&gt;<br>&gt; This still can be an issue since you still need to do the switch in<br>&gt; init(instance:), but it&#39;s just one place within the entire module, so it<br>&gt; can be more easily managed...<br>&gt;<br>&gt;<br>&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact<br>&gt; type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a<br>&gt; bit verbose but are very clear.  I can&#39;t think of anything I like that is<br>&gt; more concise.<br>&gt;<br>&gt;<br>This doesn&#39;t at all solve the parent issue of switching exhaustively, but<br>switching over dynamicType distinguishes subclasses from base classes quite<br>adequately:<br></p><p>```<br>class Foo { }<br></p><p>class Bar : Foo { }<br></p><p>class Baz : Foo { }<br></p><p>let b = Bar()<br></p><p>switch b.dynamicType {<br>case let t where t == Foo.self:<br>    print(&quot;Foo!&quot;)<br>case let t where t == Bar.self:<br>    print(&quot;Bar!&quot;)<br>case let t where t == Baz.self:<br>    print(&quot;Baz!&quot;)<br>default:<br>    print(&quot;Boo...&quot;)<br>}<br>```<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt; enum AnimalSubclasses {<br>&gt; case Dog<br>&gt; case Cat<br>&gt;<br>&gt; init(instance: Animal) {<br>&gt; switch instance {<br>&gt; case is Dog: self = .Dog<br>&gt; case is Cat: self = .Cat<br>&gt; default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt; }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; One thing I have considered that might also be worth introducing is an<br>&gt; exact match cast.  This would prevent the possibility of putting a<br>&gt; superclass case first and having it “steal” subclasses which were intended<br>&gt; to be covered by a case later in the switch.  If we introduce exact match<br>&gt; you would be able to write a switch that must always cover every concrete<br>&gt; type, including all subclasses.<br>&gt;<br>&gt;<br>&gt; Charlie<br>&gt;<br>&gt;<br>&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Limiting the amount of subclasses is not really a good idea as you would<br>&gt; need to introduce another mechanism in the language while the proposed<br>&gt; feature requires much less. And you&#39;re thinking only about the restrictive<br>&gt; set (internal and private) and forgetting the more open end (public). Why<br>&gt; is it so bad for this proposal to support requiring the default case? If<br>&gt; its possible for the compiler to discover you covered all possible cases it<br>&gt; would be fine not having default but IMHO in most cases it will find out<br>&gt; there are more not explicitly covered.<br>&gt; ------------------------------<br>&gt; From: David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt; To: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; Cc: Leonardo Pessoa &lt;me at lmpessoa.com&gt;; swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching<br>&gt; forprotocols and classes<br>&gt;<br>&gt; Or if there was a way to declare that a class/protocol can only have a<br>&gt; defined set of subclasses/conforming types.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; If you pattern match on a type that is declared internal or private, it is<br>&gt; impossible for the compiler to not have an exhaustive list of subclasses<br>&gt; that it can check against.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt; and require the default case.<br>&gt;&gt;<br>&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a<br>&gt;&gt; while<br>&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you<br>&gt;&gt; switch<br>&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be<br>&gt;&gt; prohibited.<br>&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed<br>&gt;&gt; since<br>&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit<br>&gt;&gt; from a<br>&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also<br>&gt;&gt; be<br>&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the<br>&gt;&gt; superprotocol /<br>&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the<br>&gt;&gt; Swift<br>&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and<br>&gt;&gt; classes) or<br>&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/cd428b53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 1:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, May 25, 2016 at 12:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt; <br>&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt; <br>&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt; <br>&gt; <br>&gt; This doesn&#39;t at all solve the parent issue of switching exhaustively, but switching over dynamicType distinguishes subclasses from base classes quite adequately:<br>&gt; <br>&gt; ```<br>&gt; class Foo { }<br>&gt; <br>&gt; class Bar : Foo { }<br>&gt; <br>&gt; class Baz : Foo { }<br>&gt; <br>&gt; let b = Bar()<br>&gt; <br>&gt; switch b.dynamicType {<br>&gt; case let t where t == Foo.self:<br>&gt;     print(&quot;Foo!&quot;)<br>&gt; case let t where t == Bar.self:<br>&gt;     print(&quot;Bar!&quot;)<br>&gt; case let t where t == Baz.self:<br>&gt;     print(&quot;Baz!&quot;)<br>&gt; default:<br>&gt;     print(&quot;Boo...&quot;)<br>&gt; }<br>&gt; ```<br></p><p>It’s good to know about this capability, but it  isn’t really a solution.  It doesn’t give you a name bound to `b` with the appropriate type for the case.  `t` is bound to `Bar.self`.<br></p><p>&gt; <br>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/10408416/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br></p><p>You use case instace.dynamicType == Dog.self. It&#39;s a bit more verbose, but makes sure that the exact type is matched.<br></p><p>I really wish, though for Xcode to feature something like the HHEnumeration plugin does - as soon as you type switch &lt;variable&gt;, it will create all the case statements. And with sealed classes, it could ensure the correct order so that some case isn&#39;t shadowed by the other. But that&#39;s kind of off topic.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/5efecbf5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 1:09 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt; <br>&gt; You use case instace.dynamicType == Dog.self. It&#39;s a bit more verbose, but makes sure that the exact type is matched.<br></p><p>It could replace the `is` cast, but not the `as` cast where we get a name with the correct type bound to the value.  If we’re going to introduce `asExactly` we might as well also introduce `isExactly` for consistency and convenience.<br></p><p>&gt; <br>&gt; I really wish, though for Xcode to feature something like the HHEnumeration plugin does - as soon as you type switch &lt;variable&gt;, it will create all the case statements. And with sealed classes, it could ensure the correct order so that some case isn&#39;t shadowed by the other. But that&#39;s kind of off topic.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/e291288f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; It could replace the `is` cast, but not the `as` cast where we get a name with the correct type bound to the value.  If we’re going to introduce `asExactly` we might as well also introduce `isExactly` for consistency and convenience.<br></p><p>It can:<br></p><p>case let dog as Dog where dog.dynamicType == Dog.self:<br></p><p>Again, is a bit more verbose, but can be done.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I really wish, though for Xcode to feature something like the HHEnumeration plugin does - as soon as you type switch &lt;variable&gt;, it will create all the case statements. And with sealed classes, it could ensure the correct order so that some case isn&#39;t shadowed by the other. But that&#39;s kind of off topic.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/ec8b4e71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 3:02 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; It could replace the `is` cast, but not the `as` cast where we get a name with the correct type bound to the value.  If we’re going to introduce `asExactly` we might as well also introduce `isExactly` for consistency and convenience.<br>&gt; <br>&gt; It can:<br>&gt; <br>&gt; case let dog as Dog where dog.dynamicType == Dog.self:<br>&gt; <br>&gt; Again, is a bit more verbose, but can be done.<br></p><p>Sure, if you want to repeat the type twice.  But good to keep in mind anyway.  I think if we’re going to introduce exhaustive switch for classes and protocols we should make it roughly as convenient to use as for enums.  <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really wish, though for Xcode to feature something like the HHEnumeration plugin does - as soon as you type switch &lt;variable&gt;, it will create all the case statements. And with sealed classes, it could ensure the correct order so that some case isn&#39;t shadowed by the other. But that&#39;s kind of off topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/dbc36699/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br></p><p>FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br></p><p>-Thorsten<br></p><p> <br>&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt; <br>&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt; <br>&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/09a7a9e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt; <br>&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br></p><p>Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br></p><p>sealed abstract class A {}<br>class B : A {}<br>class C : A {}<br>class D : B {}<br>class E : B {}<br></p><p>With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br></p><p>I don&#39;t think that solution is appropriate to Swift.  <br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;  <br>&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt; <br>&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/38d42911/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt; <br>&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt; <br>&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt; <br>&gt; sealed abstract class A {}<br>&gt; class B : A {}<br>&gt; class C : A {}<br>&gt; class D : B {}<br>&gt; class E : B {}<br>&gt; <br>&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br></p><p>Why?<br></p><p>switch a {<br>case C: …<br>case D: …<br>case E: …<br>}<br></p><p>is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>Abstractness seems not to be necessary for that IMO.<br>Either you match against B *or* against all its subclasses.<br></p><p>Example in Ceylon:<br>abstract class Parent() of Child1 | Child2 {}<br></p><p>class Child1() extends Parent() {}<br></p><p>abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br></p><p>class Grandchild1() extends Child2() {}<br></p><p>class Grandchild2() extends Child2() {}<br></p><p>void main() {<br>    Parent foo = Child1();<br></p><p>    switch (foo)<br>    case (is Child1) {<br>        print(&quot;Child1&quot;);<br>    }<br>    case (is Grandchild1) {<br>        print(&quot;Grandchild1&quot;);<br>    }<br>    case (is Grandchild2) {<br>        print(&quot;Grandchild2&quot;);<br>    }<br>}<br></p><p>-Thorsten<br></p><p> <br>&gt; <br>&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/376e41f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 9:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt;&gt; <br>&gt;&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt;&gt; <br>&gt;&gt; sealed abstract class A {}<br>&gt;&gt; class B : A {}<br>&gt;&gt; class C : A {}<br>&gt;&gt; class D : B {}<br>&gt;&gt; class E : B {}<br>&gt;&gt; <br>&gt;&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br>&gt; <br>&gt; Why?<br>&gt; <br>&gt; switch a {<br>&gt; case C: …<br>&gt; case D: …<br>&gt; case E: …<br>&gt; }<br>&gt; <br>&gt; is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>&gt; Abstractness seems not to be necessary for that IMO.<br>&gt; Either you match against B *or* against all its subclasses.<br></p><p>In my example `B` is not abstract.  `a` might have dynamic type of `B` which would not match any of those cases.  You didn’t mention that you have to make all non-leaf classes `abstract` (or at least I didn’t understand that from what you wrote).  <br></p><p>I don’t like a design that requires non-leaf classes to be abstract.  First, it would require introducing abstract classes into Swift, which is a totally separate conversation and something I am not convinced is a good idea.  But it is also overly restrictive.  There are valid cases where you might want an exhaustive switch for a sealed hierarchy that has concrete parent classes.<br></p><p>If you want all non-leaf types to be abstract you should probably consider using protocols in Swift.  <br></p><p>&gt; <br>&gt; Example in Ceylon:<br>&gt; abstract class Parent() of Child1 | Child2 {}<br>&gt; <br>&gt; class Child1() extends Parent() {}<br>&gt; <br>&gt; abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br>&gt; <br>&gt; class Grandchild1() extends Child2() {}<br>&gt; <br>&gt; class Grandchild2() extends Child2() {}<br>&gt; <br>&gt; void main() {<br>&gt;     Parent foo = Child1();<br>&gt; <br>&gt;     switch (foo)<br>&gt;     case (is Child1) {<br>&gt;         print(&quot;Child1&quot;);<br>&gt;     }<br>&gt;     case (is Grandchild1) {<br>&gt;         print(&quot;Grandchild1&quot;);<br>&gt;     }<br>&gt;     case (is Grandchild2) {<br>&gt;         print(&quot;Grandchild2&quot;);<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/f5999bbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 26.05.2016 um 16:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 9:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sealed abstract class A {}<br>&gt;&gt;&gt; class B : A {}<br>&gt;&gt;&gt; class C : A {}<br>&gt;&gt;&gt; class D : B {}<br>&gt;&gt;&gt; class E : B {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br>&gt;&gt; <br>&gt;&gt; Why?<br>&gt;&gt; <br>&gt;&gt; switch a {<br>&gt;&gt; case C: …<br>&gt;&gt; case D: …<br>&gt;&gt; case E: …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>&gt;&gt; Abstractness seems not to be necessary for that IMO.<br>&gt;&gt; Either you match against B *or* against all its subclasses.<br>&gt; <br>&gt; In my example `B` is not abstract.  `a` might have dynamic type of `B` which would not match any of those cases.  <br></p><p>Ah, now I realize why the requirement for abstractness makes sense. Of course. Thanks for pointing that out!<br></p><p><br>&gt; You didn’t mention that you have to make all non-leaf classes `abstract` (or at least I didn’t understand that from what you wrote).  <br></p><p>The requirement in Ceylon is for classes with enumerated subclasses. B would have to declare D and E as enumerated subclasses (like I did for Child2 in the Ceylon example). In Ceylon this is not required, B could have normal subclasses D and E, but then you could not match against D or E at all because these would not be exhaustive (B might have other subclasses). The problem therefore is not stemming from disjointness requirements.<br>As soon as D and E are declared as disjoint (i.e. if B would be declared `sealed`) matching against them would be possible but B would have to be abstract.<br></p><p>If I remove the enumerated subclasses from Child2 in the example I am allowed to make Child2 non-abstract. This of course results in the type error that the cases Child1 | Grandchild1 | Grandchild2 are not covering Parent anymore and I have to change the cases to match Child1 | Child2, removing the grandchildren matches because they are not disjoint with Child2.<br></p><p><br>&gt; I don’t like a design that requires non-leaf classes to be abstract.  First, it would require introducing abstract classes into Swift, which is a totally separate conversation and something I am not convinced is a good idea.  <br></p><p>Well, I think abstract classes are something that is sorely missing in Swift! Very sorely missing...<br>But as you say that is a separate conversation and an easy fix would be to restrict `sealed` to protocols first.<br></p><p><br>&gt; But it is also overly restrictive.  There are valid cases where you might want an exhaustive switch for a sealed hierarchy that has concrete parent classes.<br></p><p>In that case your suggestion of `isExactly` (or something shorter :-) would indeed be the solution.<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt; If you want all non-leaf types to be abstract you should probably consider using protocols in Swift.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Example in Ceylon:<br>&gt;&gt; abstract class Parent() of Child1 | Child2 {}<br>&gt;&gt; <br>&gt;&gt; class Child1() extends Parent() {}<br>&gt;&gt; <br>&gt;&gt; abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br>&gt;&gt; <br>&gt;&gt; class Grandchild1() extends Child2() {}<br>&gt;&gt; <br>&gt;&gt; class Grandchild2() extends Child2() {}<br>&gt;&gt; <br>&gt;&gt; void main() {<br>&gt;&gt;     Parent foo = Child1();<br>&gt;&gt; <br>&gt;&gt;     switch (foo)<br>&gt;&gt;     case (is Child1) {<br>&gt;&gt;         print(&quot;Child1&quot;);<br>&gt;&gt;     }<br>&gt;&gt;     case (is Grandchild1) {<br>&gt;&gt;         print(&quot;Grandchild1&quot;);<br>&gt;&gt;     }<br>&gt;&gt;     case (is Grandchild2) {<br>&gt;&gt;         print(&quot;Grandchild2&quot;);<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/3f445f88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 10:13 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 26.05.2016 um 16:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 9:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sealed abstract class A {}<br>&gt;&gt;&gt;&gt; class B : A {}<br>&gt;&gt;&gt;&gt; class C : A {}<br>&gt;&gt;&gt;&gt; class D : B {}<br>&gt;&gt;&gt;&gt; class E : B {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch a {<br>&gt;&gt;&gt; case C: …<br>&gt;&gt;&gt; case D: …<br>&gt;&gt;&gt; case E: …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>&gt;&gt;&gt; Abstractness seems not to be necessary for that IMO.<br>&gt;&gt;&gt; Either you match against B *or* against all its subclasses.<br>&gt;&gt; <br>&gt;&gt; In my example `B` is not abstract.  `a` might have dynamic type of `B` which would not match any of those cases.  <br>&gt; <br>&gt; Ah, now I realize why the requirement for abstractness makes sense. Of course. Thanks for pointing that out!<br>&gt; <br>&gt; <br>&gt;&gt; You didn’t mention that you have to make all non-leaf classes `abstract` (or at least I didn’t understand that from what you wrote).  <br>&gt; <br>&gt; The requirement in Ceylon is for classes with enumerated subclasses. B would have to declare D and E as enumerated subclasses (like I did for Child2 in the Ceylon example). In Ceylon this is not required, B could have normal subclasses D and E, but then you could not match against D or E at all because these would not be exhaustive (B might have other subclasses). The problem therefore is not stemming from disjointness requirements.<br>&gt; As soon as D and E are declared as disjoint (i.e. if B would be declared `sealed`) matching against them would be possible but B would have to be abstract.<br></p><p>In my example B is implicitly sealed because it has a sealed ancestor.  If it weren’t you would be able to violate the sealed property of the ancestor by inheriting from B.<br></p><p>&gt; <br>&gt; If I remove the enumerated subclasses from Child2 in the example I am allowed to make Child2 non-abstract. This of course results in the type error that the cases Child1 | Grandchild1 | Grandchild2 are not covering Parent anymore and I have to change the cases to match Child1 | Child2, removing the grandchildren matches because they are not disjoint with Child2.<br></p><p>Got it.  The enumerated subclasses are “partial sealing”.  They seal one level of one branch of the inheritance hierarchy.  Interesting.  You can get exhaustive matching without needing to seal the entire hierarchy.  I’m not sure if I like this or not.  It is something to consider though, and it is more flexible.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; I don’t like a design that requires non-leaf classes to be abstract.  First, it would require introducing abstract classes into Swift, which is a totally separate conversation and something I am not convinced is a good idea.  <br>&gt; <br>&gt; Well, I think abstract classes are something that is sorely missing in Swift! Very sorely missing…<br></p><p>I’ll keep my mind open about it.  My concern is that people will gravitate to the familiar where protocols would be a better design.  I haven’t yet missed abstract classes in Swift.<br></p><p>&gt; But as you say that is a separate conversation and an easy fix would be to restrict `sealed` to protocols first.<br></p><p>Why do that?  We can have exhaustive switches without requiring abstract.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; But it is also overly restrictive.  There are valid cases where you might want an exhaustive switch for a sealed hierarchy that has concrete parent classes.<br>&gt; <br>&gt; In that case your suggestion of `isExactly` (or something shorter :-) would indeed be the solution.<br></p><p>Yep.  Any ideas for something more concise?<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If you want all non-leaf types to be abstract you should probably consider using protocols in Swift.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example in Ceylon:<br>&gt;&gt;&gt; abstract class Parent() of Child1 | Child2 {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Child1() extends Parent() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Grandchild1() extends Child2() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Grandchild2() extends Child2() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; void main() {<br>&gt;&gt;&gt;     Parent foo = Child1();<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     switch (foo)<br>&gt;&gt;&gt;     case (is Child1) {<br>&gt;&gt;&gt;         print(&quot;Child1&quot;);<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     case (is Grandchild1) {<br>&gt;&gt;&gt;         print(&quot;Grandchild1&quot;);<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     case (is Grandchild2) {<br>&gt;&gt;&gt;         print(&quot;Grandchild2&quot;);<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/fb464082/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 26.05.2016 um 17:29 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 10:13 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 16:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 9:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sealed abstract class A {}<br>&gt;&gt;&gt;&gt;&gt; class B : A {}<br>&gt;&gt;&gt;&gt;&gt; class C : A {}<br>&gt;&gt;&gt;&gt;&gt; class D : B {}<br>&gt;&gt;&gt;&gt;&gt; class E : B {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch a {<br>&gt;&gt;&gt;&gt; case C: …<br>&gt;&gt;&gt;&gt; case D: …<br>&gt;&gt;&gt;&gt; case E: …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>&gt;&gt;&gt;&gt; Abstractness seems not to be necessary for that IMO.<br>&gt;&gt;&gt;&gt; Either you match against B *or* against all its subclasses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my example `B` is not abstract.  `a` might have dynamic type of `B` which would not match any of those cases.  <br>&gt;&gt; <br>&gt;&gt; Ah, now I realize why the requirement for abstractness makes sense. Of course. Thanks for pointing that out!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; You didn’t mention that you have to make all non-leaf classes `abstract` (or at least I didn’t understand that from what you wrote).  <br>&gt;&gt; <br>&gt;&gt; The requirement in Ceylon is for classes with enumerated subclasses. B would have to declare D and E as enumerated subclasses (like I did for Child2 in the Ceylon example). In Ceylon this is not required, B could have normal subclasses D and E, but then you could not match against D or E at all because these would not be exhaustive (B might have other subclasses). The problem therefore is not stemming from disjointness requirements.<br>&gt;&gt; As soon as D and E are declared as disjoint (i.e. if B would be declared `sealed`) matching against them would be possible but B would have to be abstract.<br>&gt; <br>&gt; In my example B is implicitly sealed because it has a sealed ancestor.  If it weren’t you would be able to violate the sealed property of the ancestor by inheriting from B.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If I remove the enumerated subclasses from Child2 in the example I am allowed to make Child2 non-abstract. This of course results in the type error that the cases Child1 | Grandchild1 | Grandchild2 are not covering Parent anymore and I have to change the cases to match Child1 | Child2, removing the grandchildren matches because they are not disjoint with Child2.<br>&gt; <br>&gt; Got it.  The enumerated subclasses are “partial sealing”.  They seal one level of one branch of the inheritance hierarchy.  Interesting.  You can get exhaustive matching without needing to seal the entire hierarchy.  I’m not sure if I like this or not.  It is something to consider though, and it is more flexible.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I don’t like a design that requires non-leaf classes to be abstract.  First, it would require introducing abstract classes into Swift, which is a totally separate conversation and something I am not convinced is a good idea.  <br>&gt;&gt; <br>&gt;&gt; Well, I think abstract classes are something that is sorely missing in Swift! Very sorely missing…<br>&gt; <br>&gt; I’ll keep my mind open about it.  My concern is that people will gravitate to the familiar where protocols would be a better design.  I haven’t yet missed abstract classes in Swift.<br>&gt; <br>&gt;&gt; But as you say that is a separate conversation and an easy fix would be to restrict `sealed` to protocols first.<br>&gt; <br>&gt; Why do that?  We can have exhaustive switches without requiring abstract.<br></p><p>That’s right. So, exhaustiveness in case of non-abstract B would be given by matching either for B or for exactly B and all its subclasses, i.e.<br></p><p>Either<br></p><p>switch a {<br>case is C: ...<br>case is B: ...<br>}<br></p><p>or<br></p><p>switch a {<br>case is C: …<br>case isexactly B: …<br>case is D: …<br>case is E: …<br>}<br></p><p>In case of abstract B (in case this would be added to Swift one day) we would have:<br></p><p>switch a {<br>case is C: …<br>case is D: …<br>case is E: …<br>}<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; But it is also overly restrictive.  There are valid cases where you might want an exhaustive switch for a sealed hierarchy that has concrete parent classes.<br>&gt;&gt; <br>&gt;&gt; In that case your suggestion of `isExactly` (or something shorter :-) would indeed be the solution.<br>&gt; <br>&gt; Yep.  Any ideas for something more concise?<br></p><p>Maybe `iss` for „is strictly“? Probably too cryptic, though.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you want all non-leaf types to be abstract you should probably consider using protocols in Swift.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example in Ceylon:<br>&gt;&gt;&gt;&gt; abstract class Parent() of Child1 | Child2 {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Child1() extends Parent() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Grandchild1() extends Child2() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Grandchild2() extends Child2() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; void main() {<br>&gt;&gt;&gt;&gt;     Parent foo = Child1();<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     switch (foo)<br>&gt;&gt;&gt;&gt;     case (is Child1) {<br>&gt;&gt;&gt;&gt;         print(&quot;Child1&quot;);<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     case (is Grandchild1) {<br>&gt;&gt;&gt;&gt;         print(&quot;Grandchild1&quot;);<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     case (is Grandchild2) {<br>&gt;&gt;&gt;&gt;         print(&quot;Grandchild2&quot;);<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/f6f9495a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 10:45 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 26.05.2016 um 17:29 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 10:13 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 16:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 9:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 15:40 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 8:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ceylon requires checks whether cases are disjoint, i.e. when one case contains a superclass of another case then this will be a type error „cases are not disjoint“.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW: Ceylon requires classes with enumerated subclasses to be abstract. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Interesting, thanks for mentioning this.  The abstract requirement is what makes disjointedness at least partly possible (what if a subclass has further descendants though?).  But it still only works for a single level of inheritance:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sealed abstract class A {}<br>&gt;&gt;&gt;&gt;&gt;&gt; class B : A {}<br>&gt;&gt;&gt;&gt;&gt;&gt; class C : A {}<br>&gt;&gt;&gt;&gt;&gt;&gt; class D : B {}<br>&gt;&gt;&gt;&gt;&gt;&gt; class E : B {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With a disjoint requirement I cannot ever match D and E because that would not be exhaustive and I am prohibited from matching them along side B which would be exhaustive but isn&#39;t disjoint.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch a {<br>&gt;&gt;&gt;&gt;&gt; case C: …<br>&gt;&gt;&gt;&gt;&gt; case D: …<br>&gt;&gt;&gt;&gt;&gt; case E: …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is exhaustive because B has to be sealed as well (I would require this to be declared explicitly).<br>&gt;&gt;&gt;&gt;&gt; Abstractness seems not to be necessary for that IMO.<br>&gt;&gt;&gt;&gt;&gt; Either you match against B *or* against all its subclasses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my example `B` is not abstract.  `a` might have dynamic type of `B` which would not match any of those cases.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, now I realize why the requirement for abstractness makes sense. Of course. Thanks for pointing that out!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You didn’t mention that you have to make all non-leaf classes `abstract` (or at least I didn’t understand that from what you wrote).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirement in Ceylon is for classes with enumerated subclasses. B would have to declare D and E as enumerated subclasses (like I did for Child2 in the Ceylon example). In Ceylon this is not required, B could have normal subclasses D and E, but then you could not match against D or E at all because these would not be exhaustive (B might have other subclasses). The problem therefore is not stemming from disjointness requirements.<br>&gt;&gt;&gt; As soon as D and E are declared as disjoint (i.e. if B would be declared `sealed`) matching against them would be possible but B would have to be abstract.<br>&gt;&gt; <br>&gt;&gt; In my example B is implicitly sealed because it has a sealed ancestor.  If it weren’t you would be able to violate the sealed property of the ancestor by inheriting from B.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I remove the enumerated subclasses from Child2 in the example I am allowed to make Child2 non-abstract. This of course results in the type error that the cases Child1 | Grandchild1 | Grandchild2 are not covering Parent anymore and I have to change the cases to match Child1 | Child2, removing the grandchildren matches because they are not disjoint with Child2.<br>&gt;&gt; <br>&gt;&gt; Got it.  The enumerated subclasses are “partial sealing”.  They seal one level of one branch of the inheritance hierarchy.  Interesting.  You can get exhaustive matching without needing to seal the entire hierarchy.  I’m not sure if I like this or not.  It is something to consider though, and it is more flexible.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t like a design that requires non-leaf classes to be abstract.  First, it would require introducing abstract classes into Swift, which is a totally separate conversation and something I am not convinced is a good idea.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I think abstract classes are something that is sorely missing in Swift! Very sorely missing…<br>&gt;&gt; <br>&gt;&gt; I’ll keep my mind open about it.  My concern is that people will gravitate to the familiar where protocols would be a better design.  I haven’t yet missed abstract classes in Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; But as you say that is a separate conversation and an easy fix would be to restrict `sealed` to protocols first.<br>&gt;&gt; <br>&gt;&gt; Why do that?  We can have exhaustive switches without requiring abstract.<br>&gt; <br>&gt; That’s right. So, exhaustiveness in case of non-abstract B would be given by matching either for B or for exactly B and all its subclasses, i.e.<br></p><p>Yep<br></p><p>&gt; <br>&gt; Either<br>&gt; <br>&gt; switch a {<br>&gt; case is C: ...<br>&gt; case is B: ...<br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; switch a {<br>&gt; case is C: …<br>&gt; case isexactly B: …<br>&gt; case is D: …<br>&gt; case is E: …<br>&gt; }<br>&gt; <br>&gt; In case of abstract B (in case this would be added to Swift one day) we would have:<br>&gt; <br>&gt; switch a {<br>&gt; case is C: …<br>&gt; case is D: …<br>&gt; case is E: …<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it is also overly restrictive.  There are valid cases where you might want an exhaustive switch for a sealed hierarchy that has concrete parent classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In that case your suggestion of `isExactly` (or something shorter :-) would indeed be the solution.<br>&gt;&gt; <br>&gt;&gt; Yep.  Any ideas for something more concise?<br>&gt; <br>&gt; Maybe `iss` for „is strictly“? Probably too cryptic, though.<br></p><p>Yeah, too cryptic.  I’m continuing to try and think of something better.  But Swift favors clarity over conciseness.  I’m not sure we’ll find something more concise that is also at least as clear.  Let me know if you think of anything else!<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you want all non-leaf types to be abstract you should probably consider using protocols in Swift.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example in Ceylon:<br>&gt;&gt;&gt;&gt;&gt; abstract class Parent() of Child1 | Child2 {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Child1() extends Parent() {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; abstract class Child2() of Grandchild1 | Grandchild2 extends Parent() {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Grandchild1() extends Child2() {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Grandchild2() extends Child2() {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; void main() {<br>&gt;&gt;&gt;&gt;&gt;     Parent foo = Child1();<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     switch (foo)<br>&gt;&gt;&gt;&gt;&gt;     case (is Child1) {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;Child1&quot;);<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     case (is Grandchild1) {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;Grandchild1&quot;);<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     case (is Grandchild2) {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;Grandchild2&quot;);<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think that solution is appropriate to Swift.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 19:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:41 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Got it.  You could also say it is safer because you can&#39;t have a supertype case &quot;swallow&quot; a subtype value accidentally.  An &quot;exact type&quot; cast would prevent this possibility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This still can be an issue since you still need to do the switch in init(instance:), but it&#39;s just one place within the entire module, so it can be more easily managed...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, agree.  That&#39;s why your enum is safer.  I think we do need an exact type cast to prevent this problem.  &#39;isExaclty&#39; and &#39;asExactly&#39; seem are a bit verbose but are very clear.  I can&#39;t think of anything I like that is more concise.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum AnimalSubclasses {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	case Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	init(instance: Animal) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		switch instance {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Dog: self = .Dog<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		case is Cat: self = .Cat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		default: fatalError(&quot;Unhandled instance \(instance)!&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thing I have considered that might also be worth introducing is an exact match cast.  This would prevent the possibility of putting a superclass case first and having it “steal” subclasses which were intended to be covered by a case later in the switch.  If we introduce exact match you would be able to write a switch that must always cover every concrete type, including all subclasses.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 4:41 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Limiting the amount of subclasses is not really a good idea as you would need to introduce another mechanism in the language while the proposed feature requires much less. And you&#39;re thinking only about the restrictive set (internal and private) and forgetting the more open end (public). Why is it so bad for this proposal to support requiring the default case? If its possible for the compiler to discover you covered all possible cases it would be fine not having default but IMHO in most cases it will find out there are more not explicitly covered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: David Sweeris &lt;mailto:davesweeris at mac.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent: ‎24/‎05/‎2016 11:01 PM<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To: Austin Zheng &lt;mailto:austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/771c2269/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br></p><p>class C of C1 | C2 {...}<br></p><p>where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br></p><p>-Thorsten <br></p><p>&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/3dcd16a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br></p><p>-Thorsten <br></p><p>&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt; <br>&gt; class C of C1 | C2 {...}<br>&gt; <br>&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/667c0431/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 25, 2016 at 02:00:00pm</p></header><div class="content"><p>I like the idea of sealed types but I think much better is Ceylon&#39;s concept of previously declaring the many subclasses that are going to exist both because I can have a bunch of public classes in a framework and restrict their subclasses and because there are threads in this group discussing the idea of a union type (perhaps both ideas could benefit from one another).<br></p><p>Another idea could be to add a single simple keyword to the root class (could even be sealed but I don&#39;t think it grabs this concept) to declare all its subclasses must exist within the same module. That would restrict the number of subclasses to the compiler without requiring us to revisit the root class each time we need to create a subclass and would still allow for every subclass to be public.<br></p><p>Sealed wouldn&#39;t be a good idea because the root class would still enable subclassing and it would be ideal that the switch could only work with these &quot;sealed&quot; types.<br></p><p>+1 for enabling this for protocols too.<br></p><p>Just a few issues: <br>- here we&#39;re considering having subclasses of subclasses, or not? <br>-what about public protocols being adopted outside the module, should we just ignore them or completely forbid the adoption?<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Thorsten Seitz via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎25/‎05/‎2016 01:18 PM<br>To: &quot;Thorsten Seitz&quot; &lt;tseitz42 at icloud.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br></p><p>Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br></p><p><br>-Thorsten <br></p><p>Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br>Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br></p><p><br>class C of C1 | C2 {...}<br></p><p><br>where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br></p><p><br>-Thorsten <br></p><p>Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br>Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br></p><p>Sent from my iPhone<br></p><p>On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br></p><p><br>Austin<br></p><p><br>On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>I like this but I think it would be a lot hard to ensure you have all<br>subclasses covered. Think of frameworks that could provide many<br>unsealed classes. You could also have an object that would have to<br>handle a large subtree (NSObject?) and the order in which the cases<br>are evaluated would matter just as in exception handling in languages<br>such as Java (or require some evaluation from the compiler to raise<br>warnings). I&#39;m +1 for this but these should be open-ended like strings<br>and require the default case.<br></p><p>On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br></p><p>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt; now, and would love to see a proposal.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;<br>&gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; subprotocol / subclass).<br>&gt;&gt;<br>&gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;<br>&gt;&gt; protocol P {}<br>&gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; struct P1: P {}<br>&gt;&gt; struct P2: P {}<br>&gt;&gt;<br>&gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;     switch p {<br>&gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C {}<br>&gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; class C1: C {}<br>&gt;&gt; class C2: C {}<br>&gt;&gt;<br>&gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;     switch c {<br>&gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/f0518112/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:04 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea of sealed types but I think much better is Ceylon&#39;s concept of previously declaring the many subclasses that are going to exist both because I can have a bunch of public classes in a framework and restrict their subclasses and because there are threads in this group discussing the idea of a union type (perhaps both ideas could benefit from one another).<br></p><p>I think there are reasonable arguments both for and against forcing the programmer to declare all subclasses in one location.  The argument for it is that it provides documentation value by listing all possible cases in the same place.  The argument against it is that this could get annoying as you add subclasses inside the module and the compiler will tell you when you miss a case in your switches anyway.<br></p><p>&gt; <br>&gt; Another idea could be to add a single simple keyword to the root class (could even be sealed but I don&#39;t think it grabs this concept) to declare all its subclasses must exist within the same module. That would restrict the number of subclasses to the compiler without requiring us to revisit the root class each time we need to create a subclass and would still allow for every subclass to be public.<br>&gt; <br>&gt; Sealed wouldn&#39;t be a good idea because the root class would still enable subclassing and it would be ideal that the switch could only work with these &quot;sealed&quot; types.<br></p><p>I proposed &#39;sealed&#39; for this using the definition we have seen previously on the list - closed to inheritance outside the module.  It doesn&#39;t mean &#39;final&#39;.<br></p><p>&gt; <br>&gt; +1 for enabling this for protocols too.<br>&gt; <br>&gt; Just a few issues: <br>&gt; - here we&#39;re considering having subclasses of subclasses, or not? <br></p><p>Yes, as long as they&#39;re within the same module as the &#39;sealed&#39; type.<br></p><p>&gt; -what about public protocols being adopted outside the module, should we just ignore them or completely forbid the adoption?<br></p><p>The ability to have &#39;public sealed&#39; is the only reason to have &#39;sealed&#39; at all.  &#39;private&#39; and &#39;internal&#39; are implicitly &#39;sealed&#39; by lack of external visibility.  If your users need to be able to conform to your protocol you wouldn&#39;t be able to make it &#39;sealed&#39; and would have to include the default clause in a switch statement.  &#39;sealed&#39; is for times where your design requires a fixed set of conformances that are all packed together in the same module as the protocol, but the protocol must be visible publicly.<br></p><p>&gt; <br>&gt; From: Thorsten Seitz via swift-evolution<br>&gt; Sent: ‎25/‎05/‎2016 01:18 PM<br>&gt; To: Thorsten Seitz<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt; <br>&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt; <br>&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt; <br>&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/8e32aad8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:04 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea of sealed types but I think much better is Ceylon&#39;s concept of previously declaring the many subclasses that are going to exist both because I can have a bunch of public classes in a framework and restrict their subclasses and because there are threads in this group discussing the idea of a union type (perhaps both ideas could benefit from one another).<br></p><p>I forgot to mention this in my last reply.  What I am proposing allows sealed classes to be viewed as similar to nominal sum types.  This is like Scala&#39;s case classes.  <br></p><p>Ceylon&#39;s unions are structural sum types (the sum type analogue of a Tuple, which is a structural product type).  I really want to see these as well (I recently ran into a use case where they are far superior to what we can do today).  But they are not the same as sealed classes and protocols.<br></p><p>&gt; <br>&gt; Another idea could be to add a single simple keyword to the root class (could even be sealed but I don&#39;t think it grabs this concept) to declare all its subclasses must exist within the same module. That would restrict the number of subclasses to the compiler without requiring us to revisit the root class each time we need to create a subclass and would still allow for every subclass to be public.<br>&gt; <br>&gt; Sealed wouldn&#39;t be a good idea because the root class would still enable subclassing and it would be ideal that the switch could only work with these &quot;sealed&quot; types.<br>&gt; <br>&gt; +1 for enabling this for protocols too.<br>&gt; <br>&gt; Just a few issues: <br>&gt; - here we&#39;re considering having subclasses of subclasses, or not? <br>&gt; -what about public protocols being adopted outside the module, should we just ignore them or completely forbid the adoption?<br>&gt; <br>&gt; From: Thorsten Seitz via swift-evolution<br>&gt; Sent: ‎25/‎05/‎2016 01:18 PM<br>&gt; To: Thorsten Seitz<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt; <br>&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt; <br>&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt; <br>&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/7b6176d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching forprotocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 25.05.2016 um 19:38 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 25, 2016, at 12:04 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I like the idea of sealed types but I think much better is Ceylon&#39;s concept of previously declaring the many subclasses that are going to exist both because I can have a bunch of public classes in a framework and restrict their subclasses and because there are threads in this group discussing the idea of a union type (perhaps both ideas could benefit from one another).<br>&gt; <br>&gt; I forgot to mention this in my last reply.  What I am proposing allows sealed classes to be viewed as similar to nominal sum types.  This is like Scala&#39;s case classes.  <br>&gt; <br>&gt; Ceylon&#39;s unions are structural sum types (the sum type analogue of a Tuple, which is a structural product type).  I really want to see these as well (I recently ran into a use case where they are far superior to what we can do today).  But they are not the same as sealed classes and protocols.<br></p><p>That’s true and readily demonstrated by Ceylon which has both :-)<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Another idea could be to add a single simple keyword to the root class (could even be sealed but I don&#39;t think it grabs this concept) to declare all its subclasses must exist within the same module. That would restrict the number of subclasses to the compiler without requiring us to revisit the root class each time we need to create a subclass and would still allow for every subclass to be public.<br>&gt;&gt; <br>&gt;&gt; Sealed wouldn&#39;t be a good idea because the root class would still enable subclassing and it would be ideal that the switch could only work with these &quot;sealed&quot; types.<br>&gt;&gt; <br>&gt;&gt; +1 for enabling this for protocols too.<br>&gt;&gt; <br>&gt;&gt; Just a few issues: <br>&gt;&gt; - here we&#39;re considering having subclasses of subclasses, or not? <br>&gt;&gt; -what about public protocols being adopted outside the module, should we just ignore them or completely forbid the adoption?<br>&gt;&gt; <br>&gt;&gt; From: Thorsten Seitz via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎25/‎05/‎2016 01:18 PM<br>&gt;&gt; To: Thorsten Seitz &lt;mailto:tseitz42 at icloud.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt; <br>&gt;&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b0e0147a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 11:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br></p><p>Yeah, and it doesn&#39;t require repeating the subclass all in one place which I think is a better fit for Swift.<br></p><p>I&#39;m thinking the &quot;exact type&quot; cast (not in my original post) should also be a part of the solution.  What do you think of that?<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt; <br>&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt; <br>&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/603df440/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 25.05.2016 um 19:13 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 25, 2016, at 11:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt; <br>&gt; Yeah, and it doesn&#39;t require repeating the subclass all in one place which I think is a better fit for Swift.<br></p><p>On the other hand I like that I can see at a glance which subclasses belong to the `sealed` class.<br></p><p><br>&gt; <br>&gt; I&#39;m thinking the &quot;exact type&quot; cast (not in my original post) should also be a part of the solution.  What do you think of that?<br></p><p>What do you mean by &quot;exact type“ cast?<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/4b3e4416/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 8:06 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 19:13 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 11:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt;&gt; <br>&gt;&gt; Yeah, and it doesn&#39;t require repeating the subclass all in one place which I think is a better fit for Swift.<br>&gt; <br>&gt; On the other hand I like that I can see at a glance which subclasses belong to the `sealed` class.<br></p><p>Yeah, the value of this is the documents on value.  The question is whether maintaining it is worth the effort, especially when tools could provide the same information.  Reasonable people can disagree on this.  I don&#39;t feel too strongly about it, but lean slightly towards not requiring the explicit list.  <br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m thinking the &quot;exact type&quot; cast (not in my original post) should also be a part of the solution.  What do you think of that?<br>&gt; <br>&gt; What do you mean by &quot;exact type“ cast?<br></p><p>I mean a cast operator where a subclass will not match a cast to any of its ancestor types.  That would let you be sure to provide a case for each individual type and ensure the correct case is selected regardless of order.  It can be done today but is verbose and error prone:<br></p><p>case let dog as Dog where dog.dynamicType == Dog.self:<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/321f89ef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
