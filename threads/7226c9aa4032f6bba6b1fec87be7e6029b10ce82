<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pre-proposal] Fix function type grammar</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; OK.. could you clarify, so, after the changes, we will not be able to <br>pass <br>&gt; `func f()-&gt;()` as parameter where parameter of type `typealias <br>MyFunc&lt;T&gt; = <br>&gt; (T) -&gt; Void` is expected, right?<br></p><p>Right. But the change is not as dramatic as you suppose.<br>Consider this example:<br></p><p>func async&lt;T&gt;(with: T, do: (T) -&gt; Void)<br></p><p>async(with: (), do: { ... })<br></p><p>With this change, it will become:<br></p><p>async(with: (), do: { _ in ... })<br></p><p>This is what will change in practise. With enough luck, even the first <br>version will typecheck.<br></p><p>&gt; And what about the result type? What does `-&gt; ()` now will mean? still <br>&gt; &quot;implicitly returns Void&quot; or &quot;returns nothing&quot;? Or in case you want to <br>&gt; return Void you&#39;ll need to write `-&gt; Void` ?<br></p><p>Parameter part will become a list of types; result will still be a <br>single type, including unit type and closure types. So no changes on <br>this part.<br></p><p>&gt; And most likely I&#39;m missing something, but I don&#39;t see where SE-0066 <br>&gt; mentions this aspect (disallow implicit Void argument in function <br>which is <br>&gt; defined as &#39;()-&gt;()&#39;), as I understand it is only about requirement of <br>&gt; parentheses in declaration like Int-&gt;Int. Could you point me please?<br></p><p>Citation:<br></p><p>Allowing this sugar introduces ambiguities in the language that require <br>special rules to disambiguate. For example:<br></p><p>() -&gt; Int // Takes zero arguments, or one zero-argument parameter?<br></p><p>This syntactic sugar reduces consistency with other parts of the <br>language, since declarations always require parentheses, and calls <br>requires parentheses as well.<br></p><p>Finally, while it is straight-forward to remove this in Swift 3 (given <br>the other migration that will be necessary to move Swift 2 code to Swift <br>3), removing this after Swift 3 will be much harder since we won&#39;t want <br>to break code then. It is now or never.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pre-proposal] Fix function type grammar</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  3, 2016 at 11:00:00pm</p></header><div class="content"><p>On 03.07.2016 22:56, Anton Zhilin via swift-evolution wrote:<br>&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt;&gt; OK.. could you clarify, so, after the changes, we will not be able to<br>&gt; pass<br>&gt;&gt; `func f()-&gt;()` as parameter where parameter of type `typealias<br>&gt; MyFunc&lt;T&gt; =<br>&gt;&gt; (T) -&gt; Void` is expected, right?<br>&gt;<br>&gt; Right. But the change is not as dramatic as you suppose.<br>&gt; Consider this example:<br>&gt;<br>&gt; func async&lt;T&gt;(with: T, do: (T) -&gt; Void)<br>&gt;<br>&gt; async(with: (), do: { ... })<br>&gt;<br>&gt; With this change, it will become:<br>&gt;<br>&gt; async(with: (), do: { _ in ... })<br>&gt;<br>&gt; This is what will change in practise. With enough luck, even the first<br>&gt; version will typecheck.<br></p><p>If we are separating () and (()) in function call/declaration, then if <br>SE-0110 will be accepted, I believe first should not be allowed for <br>argument defined as (T)-&gt;Void.<br>As I understand, in case you have a code that relies on current <br>syntax/behavior and uses functions(not closures), you&#39;ll need a lot of <br>wrappers like `{_ in funcThatWasUsedAsIs()}`<br></p><p>&gt;<br>&gt;&gt; And what about the result type? What does `-&gt; ()` now will mean? still<br>&gt;&gt; &quot;implicitly returns Void&quot; or &quot;returns nothing&quot;? Or in case you want to<br>&gt;&gt; return Void you&#39;ll need to write `-&gt; Void` ?<br>&gt;<br>&gt; Parameter part will become a list of types; result will still be a<br>&gt; single type, including unit type and closure types. So no changes on<br>&gt; this part.<br>&gt;<br></p><p>Got it. OK, so when reading &#39;()-&gt;()&#39; we should now read &#39;emtpy list of <br>parameters(0 parameters) to Void&#39;. And only `(())-&gt;()` as &#39;1 explicit Void <br>argument to Void&#39;.<br></p><p>Btw, in case of &#39;func f(())-&gt;() {}&#39;, will call without explicit Void <br>parameter be allowed? I.e. `f()` or only `f(())`?<br></p><p>&gt;&gt; And most likely I&#39;m missing something, but I don&#39;t see where SE-0066<br>&gt;&gt; mentions this aspect (disallow implicit Void argument in function<br>&gt; which is<br>&gt;&gt; defined as &#39;()-&gt;()&#39;), as I understand it is only about requirement of<br>&gt;&gt; parentheses in declaration like Int-&gt;Int. Could you point me please?<br>&gt;<br>&gt; Citation:<br>&gt;<br>&gt; Allowing this sugar introduces ambiguities in the language that require<br>&gt; special rules to disambiguate. For example:<br>&gt;<br>&gt; () -&gt; Int // Takes zero arguments, or one zero-argument parameter?<br></p><p>Hm.. I do understand exactly this example as ambiguity *in case* we are not <br>require parentheses. But not after.<br></p><p>I.e. in case we can have `Int-&gt;Int` it is not clear if in `()-&gt;()` there is <br>a zero parameters or explicit `Void` parameter.<br>After we decided to require parentheses, `()-&gt;()` clearly means empty list <br>of parameters.<br>*But*, I feel like implicit Void parameter for function with empty list of <br>parameters - is an implementation detail which is currently used and <br>changing this will produce much more problems for current code than &quot;Just <br>require parentheses on function types&quot; as stated in the proposal in <br>&quot;Proposed solution and Impact on existing code&quot;.<br></p><p>I really feel like I&#39;ve missed something or don&#39;t understand :-) and this <br>is why only I is warring about this change(disallowing Void parameter for <br>func with empty argument list in declaration)<br></p><p>&gt;<br>&gt; This syntactic sugar reduces consistency with other parts of the<br>&gt; language, since declarations always require parentheses, and calls<br>&gt; requires parentheses as well.<br>&gt;<br>&gt; Finally, while it is straight-forward to remove this in Swift 3 (given<br>&gt; the other migration that will be necessary to move Swift 2 code to Swift<br>&gt; 3), removing this after Swift 3 will be much harder since we won&#39;t want<br>&gt; to break code then. It is now or never.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
