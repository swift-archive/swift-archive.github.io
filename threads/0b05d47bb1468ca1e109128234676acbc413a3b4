<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c1588abf9a26bee7288e320962425954?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Sam Dods</string> &lt;sam at theappbusiness.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br></p><p>At present the type of properties and variables can be inferred as below:<br></p><p>class EvolutionManager {<br>  let proposalManager = ProposalManager()           // type is inferred<br></p><p>  func proposeTopic(topic: String) {<br>    let evolution = Evolution(topic: topic)         // type is inferred<br>    proposalManager.proposeEvolution(evolution)<br>  }<br>}<br></p><p>However, function arguments cannot be inferred, as below:<br></p><p>class EvolutionManager {<br>  func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager()) {       // compiler error, cannot infer type<br>    proposalManager.proposeEvolution(evolution)<br>  }<br>}<br></p><p>It&#39;s a nice feature of the language that the type can be inferred for properties and variables, so I don&#39;t see any reason not to allow the same for function arguments. It allows for more concise code, and adds consistency with other language features. And I don&#39;t personally think it would make our code any harder to read.<br></p><p>There are of course some cases where the type cannot be inferred, i.e. when the type should actually be a protocol type and the default value is a concrete type. Consider the following:<br></p><p>protocol ProposalHandler {<br>  associatedType P : Proposable<br>  propose(p: P)<br>}<br></p><p>class EvolutionManager {<br>  // the type would be inferred as the concrete type `ProposalManager` and could not be<br>  // called with any other argument type that conforms to the `ProposalHandler` protocol,<br>  // as may have been the intention<br>  func proposeEvolution(evolution: Evolution, proposalHandler = ProposalManager())<br></p><p>  // instead it should be written as follows:<br>  func proposeEvolution(evolution: Evolution, proposalHandler: ProposalHandler = ProposalManager())<br>}<br></p><p>But this is the same for properties and variables, so it should not be a reason to not allow inferring of function arguments. For example:<br></p><p>class EvolutionManager {<br>  // the property is inferred as the concrete type `ProposalManager` and may not<br>  // be set to any other value of type that conforms to the `ProposalHandler` protocol,<br>  // as may have been the intention.<br>  var proposalHandler = ProposalManager()<br></p><p>  // instead it should be written as follows:<br>  var proposalHandler: ProposalHandler = ProposalManager()<br>}<br></p><p>What do people think of this?<br></p><p>It would have no impact on existing code, and it&#39;s not the kind of thing that needs an alternative solution.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d128cffeaf768e0ad7c47488aaa95f13?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Dominik Pich</string> &lt;dominik at pich.info&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>I think it would add consistence… everywhere else types can be inferred… why not here<br></p><p>&gt; On May 10, 2016, at 12:02 PM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br>&gt; <br>&gt; At present the type of properties and variables can be inferred as below:<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  let proposalManager = ProposalManager()           // type is inferred<br>&gt; <br>&gt;  func proposeTopic(topic: String) {<br>&gt;    let evolution = Evolution(topic: topic)         // type is inferred<br>&gt;    proposalManager.proposeEvolution(evolution)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; However, function arguments cannot be inferred, as below:<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager()) {       // compiler error, cannot infer type<br>&gt;    proposalManager.proposeEvolution(evolution)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; It&#39;s a nice feature of the language that the type can be inferred for properties and variables, so I don&#39;t see any reason not to allow the same for function arguments. It allows for more concise code, and adds consistency with other language features. And I don&#39;t personally think it would make our code any harder to read.<br>&gt; <br>&gt; There are of course some cases where the type cannot be inferred, i.e. when the type should actually be a protocol type and the default value is a concrete type. Consider the following:<br>&gt; <br>&gt; protocol ProposalHandler {<br>&gt;  associatedType P : Proposable<br>&gt;  propose(p: P)<br>&gt; }<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  // the type would be inferred as the concrete type `ProposalManager` and could not be<br>&gt;  // called with any other argument type that conforms to the `ProposalHandler` protocol,<br>&gt;  // as may have been the intention<br>&gt;  func proposeEvolution(evolution: Evolution, proposalHandler = ProposalManager())<br>&gt; <br>&gt;  // instead it should be written as follows:<br>&gt;  func proposeEvolution(evolution: Evolution, proposalHandler: ProposalHandler = ProposalManager())<br>&gt; }<br>&gt; <br>&gt; But this is the same for properties and variables, so it should not be a reason to not allow inferring of function arguments. For example:<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  // the property is inferred as the concrete type `ProposalManager` and may not<br>&gt;  // be set to any other value of type that conforms to the `ProposalHandler` protocol,<br>&gt;  // as may have been the intention.<br>&gt;  var proposalHandler = ProposalManager()<br>&gt; <br>&gt;  // instead it should be written as follows:<br>&gt;  var proposalHandler: ProposalHandler = ProposalManager()<br>&gt; }<br>&gt; <br>&gt; What do people think of this?<br>&gt; <br>&gt; It would have no impact on existing code, and it&#39;s not the kind of thing that needs an alternative solution.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br>&gt; <br>&gt; At present the type of properties and variables can be inferred as below:<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  let proposalManager = ProposalManager()           // type is inferred<br>&gt; <br>&gt;  func proposeTopic(topic: String) {<br>&gt;    let evolution = Evolution(topic: topic)         // type is inferred<br>&gt;    proposalManager.proposeEvolution(evolution)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; However, function arguments cannot be inferred, as below:<br>&gt; <br>&gt; class EvolutionManager {<br>&gt;  func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager()) {       // compiler error, cannot infer type<br></p><p>We have a pretty strict rule here: types are allowed to be inferred in implementations, but not interfaces.  This is important for efficient compilation, encourages people to think about their API interfaces, and somewhat reduces the damage when they don’t.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On May 10, 2016, at 8:33 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br>&gt;&gt; <br>&gt;&gt; At present the type of properties and variables can be inferred as below:<br>&gt;&gt; <br>&gt;&gt; class EvolutionManager {<br>&gt;&gt; let proposalManager = ProposalManager()           // type is inferred<br>&gt;&gt; <br>&gt;&gt; func proposeTopic(topic: String) {<br>&gt;&gt;   let evolution = Evolution(topic: topic)         // type is inferred<br>&gt;&gt;   proposalManager.proposeEvolution(evolution)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, function arguments cannot be inferred, as below:<br>&gt;&gt; <br>&gt;&gt; class EvolutionManager {<br>&gt;&gt; func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager()) {       // compiler error, cannot infer type<br>&gt; <br>&gt; We have a pretty strict rule here: types are allowed to be inferred in implementations, but not interfaces.  This is important for efficient compilation, encourages people to think about their API interfaces, and somewhat reduces the damage when they don’t.<br></p><p>We broke this rule when we started allowing properties at type and module scope to have inferred types. I was moderately opposed to it at the time, but we have it, we&#39;re going to keep it, and this suggestion for inferring parameter types from default arguments seems to fit in the same category. <br></p><p>That said, I have implementation concerns: we don&#39;t want the expression type checker to be involved when figuring out the type of a generic function, so we would need to define this in a way that doesn&#39;t affect the computation of generic signatures for a function. Probably, such types just aren&#39;t involved in inferring generic constraints. <br></p><p>  - Doug<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c1588abf9a26bee7288e320962425954?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Sam Dods</string> &lt;sam at theappbusiness.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>yes, exactly Doug... the properties at type level are part of the interface and their types can be inferred, so i don&#39;t see the difference with function argument types.<br></p><p>i just find it really bulky when writing something like this:<br></p><p>func doSomething(thing, withManager: SomethingManager = SomethingManager()) {<br>  // prepare the thing<br>}<br></p><p>I think this meets the API guidelines for &quot;omitting needless words&quot;<br></p><p>And it should be invalid syntax to expect the type to be inferred for a generic argument (i.e. no change from current behaviour)<br></p><p><br>&gt; On 11 May 2016, at 04:53, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 10, 2016, at 8:33 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At present the type of properties and variables can be inferred as below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class EvolutionManager {<br>&gt;&gt;&gt; let proposalManager = ProposalManager()           // type is inferred<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func proposeTopic(topic: String) {<br>&gt;&gt;&gt;  let evolution = Evolution(topic: topic)         // type is inferred<br>&gt;&gt;&gt;  proposalManager.proposeEvolution(evolution)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, function arguments cannot be inferred, as below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class EvolutionManager {<br>&gt;&gt;&gt; func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager()) {       // compiler error, cannot infer type<br>&gt;&gt; <br>&gt;&gt; We have a pretty strict rule here: types are allowed to be inferred in implementations, but not interfaces.  This is important for efficient compilation, encourages people to think about their API interfaces, and somewhat reduces the damage when they don’t.<br>&gt; <br>&gt; We broke this rule when we started allowing properties at type and module scope to have inferred types. I was moderately opposed to it at the time, but we have it, we&#39;re going to keep it, and this suggestion for inferring parameter types from default arguments seems to fit in the same category. <br>&gt; <br>&gt; That said, I have implementation concerns: we don&#39;t want the expression type checker to be involved when figuring out the type of a generic function, so we would need to define this in a way that doesn&#39;t affect the computation of generic signatures for a function. Probably, such types just aren&#39;t involved in inferring generic constraints. <br>&gt; <br>&gt;  - Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/16eb6f42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 07 Jun 2016, at 22:08, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; yes, exactly Doug... the properties at type level are part of the interface and their types can be inferred, so i don&#39;t see the difference with function argument types.<br>&gt; <br>&gt; i just find it really bulky when writing something like this:<br>&gt; <br>&gt; func doSomething(thing, withManager: SomethingManager = SomethingManager()) {<br>&gt;   // prepare the thing<br>&gt; }<br></p><p>You can get rid of the repetition here by using the implicit member expression syntax (i.e. dot-prefixing the initialiser):<br></p><p>    func doSomething(thing, withManager: SomethingManager = .init()) { ... }<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/d7fa7034/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>If seen several suggestions to extend inference now, and although it is convenient, it can make it harder to understand what&#39;s happening.<br>Imho it would be possible to combine the benefits of both ways without their disadvantages:<br>Xcode already has the ability to correct some errors and warnings, but always asks the user first (&quot;hey, shall I replace this var with let?&quot;), and this is good in general, because silently changing code could lead to errors (when I declare something as constant, it&#39;s most likely an error when I try to modify the value afterwards).<br></p><p>Coming back to this specific proposal:<br>&gt;  func proposeEvolution(evolution: Evolution, proposalManager = ProposalManager())<br>is an easy case - but what about<br>func proposeEvolution(evolution: Evolution, proposalManager = someFunctionWhoseReturnTypeIsntObvious())<br></p><p>It would be possible to create a tool that complements the source by adding the type, but I don&#39;t think Swift-evolution is the right place to discuss this, as it&#39;s not actually about the language itself.<br>But: Swift has the benefit that not only the development of the language, but also the compiler, IDE and all essential tools are driven by a single company. Therefore it easier (at least I hope so) to evolve language and tools side by side, and it would be possible to add features that only work in combination.<br>One problem with inferred information is that its origin can&#39;t be recognized unless it is annotated, so that tools could see that (for example) the user didn&#39;t care wether x is a variable or constant, and could change the type whenever it makes sense to do so.<br>The only way to achieve this now would be a special comment like<br>/*?*/let x = 0<br>which, of course, is way to ugly to be useful.<br></p><p>I did not investigate how big the performance-penalty for compilation of code that makes heavy use of type inference is, but I guess &quot;caching&quot; could help here as well.<br>This could be done by adding special characters (I&#39;ve no good idea for this, so I&#39;ll use the general-purpose special character ;-):<br>func proposeEvolution(evolution: Evolution, proposalManager: #ProposalManager = someFunctionWhoseReturnTypeIsntObvious())<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
