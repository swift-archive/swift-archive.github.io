<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/019f9103a2e36c35bcf1c713fd5d4812?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Raphaël Wach</string> &lt;raphael.wach at icloud.com&gt;<p>June 13, 2016 at 09:00:00am</p></header><div class="content"><p>Hello Swifters,<br></p><p>While working on some framework programming, I had this idea that I would like to share with you.<br>If some other people like it, I would be more than happy to write a proposal.<br></p><p>Here is a little draft I wrote as a starting point to discuss.<br>Sorry if there is mistakes, I am not an english native speaker.<br>Thank you for your feedback.<br></p><p>————————————————————————————————————<br></p><p>Swift proposal: Access modifier blocks<br></p><p>This proposal introduces a refinement of the way to define access modifier and visibility scope.<br></p><p>The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br></p><p>If a class A has only a few members, that’s ok to write <br></p><p>class A {<br>	public var member1: Int<br>	var member2: Int<br>	private var member3: Int<br>}<br></p><p>With a bigger class B, it will looks far less nice<br></p><p>class B {<br>	public var member1: Int<br>	var member2: Int<br>	private var member3: Int<br>	public var member4: Int<br>	var member5: Int<br>	private var member6: Int<br>	public var member7: Int<br>	var member8: Int<br>	private var member9: Int<br>	public var member10: Int<br>	private var member11: Int<br>	var member12: Int<br>	public var member13: Int<br>	var member14: Int<br>	private var member15: Int<br>}<br></p><p>And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br></p><p>The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>Then our class B could be:<br></p><p>class B {<br>	// Ok then this is part of the public interface of my framework<br>	public { <br>		var member1: Int<br>		var member4: Int<br>		var member7: Int<br>		var member10: Int<br>		var member13: Int<br>	}<br>	// This can be used anywhere in my framework<br>	internal {<br>		var member2: Int<br>		var member5: Int<br>		var member8: Int<br>		var member12: Int<br>		var member14: Int<br>	}<br>	// Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>	private {<br>		var member3: Int<br>		var member6: Int<br>		var member9: Int<br>		var member11: Int<br>		var member15: Int<br>	}<br>}<br></p><p>It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br></p><p>It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>Classes defined outside of the framework could only implement the public stuff in the protocol.<br></p><p>It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br></p><p>————————————————————————————————————<br></p><p>Please, let me know if you like the idea.<br></p><p>Cheers,<br></p><p>Raph<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 13, 2016 at 12:00:00am</p></header><div class="content"><p>What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br></p><p>~Robert Widmann<br></p><p>2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Hello Swifters,<br>&gt; <br>&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt; <br>&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt; Thank you for your feedback.<br>&gt; <br>&gt; ————————————————————————————————————<br>&gt; <br>&gt; Swift proposal: Access modifier blocks<br>&gt; <br>&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt; <br>&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt; <br>&gt; If a class A has only a few members, that’s ok to write <br>&gt; <br>&gt; class A {<br>&gt;    public var member1: Int<br>&gt;    var member2: Int<br>&gt;    private var member3: Int<br>&gt; }<br>&gt; <br>&gt; With a bigger class B, it will looks far less nice<br>&gt; <br>&gt; class B {<br>&gt;    public var member1: Int<br>&gt;    var member2: Int<br>&gt;    private var member3: Int<br>&gt;    public var member4: Int<br>&gt;    var member5: Int<br>&gt;    private var member6: Int<br>&gt;    public var member7: Int<br>&gt;    var member8: Int<br>&gt;    private var member9: Int<br>&gt;    public var member10: Int<br>&gt;    private var member11: Int<br>&gt;    var member12: Int<br>&gt;    public var member13: Int<br>&gt;    var member14: Int<br>&gt;    private var member15: Int<br>&gt; }<br>&gt; <br>&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt; <br>&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt; Then our class B could be:<br>&gt; <br>&gt; class B {<br>&gt;    // Ok then this is part of the public interface of my framework<br>&gt;    public { <br>&gt;        var member1: Int<br>&gt;        var member4: Int<br>&gt;        var member7: Int<br>&gt;        var member10: Int<br>&gt;        var member13: Int<br>&gt;    }<br>&gt;    // This can be used anywhere in my framework<br>&gt;    internal {<br>&gt;        var member2: Int<br>&gt;        var member5: Int<br>&gt;        var member8: Int<br>&gt;        var member12: Int<br>&gt;        var member14: Int<br>&gt;    }<br>&gt;    // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;    private {<br>&gt;        var member3: Int<br>&gt;        var member6: Int<br>&gt;        var member9: Int<br>&gt;        var member11: Int<br>&gt;        var member15: Int<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt; <br>&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt; <br>&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt; <br>&gt; ————————————————————————————————————<br>&gt; <br>&gt; Please, let me know if you like the idea.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Raph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 13, 2016 at 10:00:00am</p></header><div class="content"><p>Extensions can&#39;t have stored properties.<br></p><p>&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Hello Swifters,<br>&gt;&gt; <br>&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt; <br>&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt; Thank you for your feedback.<br>&gt;&gt; <br>&gt;&gt; ————————————————————————————————————<br>&gt;&gt; <br>&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt; <br>&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt; <br>&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt; <br>&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt;   public var member1: Int<br>&gt;&gt;   var member2: Int<br>&gt;&gt;   private var member3: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt; <br>&gt;&gt; class B {<br>&gt;&gt;   public var member1: Int<br>&gt;&gt;   var member2: Int<br>&gt;&gt;   private var member3: Int<br>&gt;&gt;   public var member4: Int<br>&gt;&gt;   var member5: Int<br>&gt;&gt;   private var member6: Int<br>&gt;&gt;   public var member7: Int<br>&gt;&gt;   var member8: Int<br>&gt;&gt;   private var member9: Int<br>&gt;&gt;   public var member10: Int<br>&gt;&gt;   private var member11: Int<br>&gt;&gt;   var member12: Int<br>&gt;&gt;   public var member13: Int<br>&gt;&gt;   var member14: Int<br>&gt;&gt;   private var member15: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt; <br>&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt; Then our class B could be:<br>&gt;&gt; <br>&gt;&gt; class B {<br>&gt;&gt;   // Ok then this is part of the public interface of my framework<br>&gt;&gt;   public { <br>&gt;&gt;       var member1: Int<br>&gt;&gt;       var member4: Int<br>&gt;&gt;       var member7: Int<br>&gt;&gt;       var member10: Int<br>&gt;&gt;       var member13: Int<br>&gt;&gt;   }<br>&gt;&gt;   // This can be used anywhere in my framework<br>&gt;&gt;   internal {<br>&gt;&gt;       var member2: Int<br>&gt;&gt;       var member5: Int<br>&gt;&gt;       var member8: Int<br>&gt;&gt;       var member12: Int<br>&gt;&gt;       var member14: Int<br>&gt;&gt;   }<br>&gt;&gt;   // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;   private {<br>&gt;&gt;       var member3: Int<br>&gt;&gt;       var member6: Int<br>&gt;&gt;       var member9: Int<br>&gt;&gt;       var member11: Int<br>&gt;&gt;       var member15: Int<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt; <br>&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt; <br>&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt; <br>&gt;&gt; ————————————————————————————————————<br>&gt;&gt; <br>&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Raph<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/019f9103a2e36c35bcf1c713fd5d4812?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Raphaël Wach</string> &lt;raphael.wach at icloud.com&gt;<p>June 13, 2016 at 10:00:00am</p></header><div class="content"><p>Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br></p><p>Raph<br></p><p><br></p><p>&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt; <br>&gt; Extensions can&#39;t have stored properties.<br>&gt; <br>&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;  public var member1: Int<br>&gt;&gt;&gt;  var member2: Int<br>&gt;&gt;&gt;  private var member3: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;  public var member1: Int<br>&gt;&gt;&gt;  var member2: Int<br>&gt;&gt;&gt;  private var member3: Int<br>&gt;&gt;&gt;  public var member4: Int<br>&gt;&gt;&gt;  var member5: Int<br>&gt;&gt;&gt;  private var member6: Int<br>&gt;&gt;&gt;  public var member7: Int<br>&gt;&gt;&gt;  var member8: Int<br>&gt;&gt;&gt;  private var member9: Int<br>&gt;&gt;&gt;  public var member10: Int<br>&gt;&gt;&gt;  private var member11: Int<br>&gt;&gt;&gt;  var member12: Int<br>&gt;&gt;&gt;  public var member13: Int<br>&gt;&gt;&gt;  var member14: Int<br>&gt;&gt;&gt;  private var member15: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;  // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;  public { <br>&gt;&gt;&gt;      var member1: Int<br>&gt;&gt;&gt;      var member4: Int<br>&gt;&gt;&gt;      var member7: Int<br>&gt;&gt;&gt;      var member10: Int<br>&gt;&gt;&gt;      var member13: Int<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  // This can be used anywhere in my framework<br>&gt;&gt;&gt;  internal {<br>&gt;&gt;&gt;      var member2: Int<br>&gt;&gt;&gt;      var member5: Int<br>&gt;&gt;&gt;      var member8: Int<br>&gt;&gt;&gt;      var member12: Int<br>&gt;&gt;&gt;      var member14: Int<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;  private {<br>&gt;&gt;&gt;      var member3: Int<br>&gt;&gt;&gt;      var member6: Int<br>&gt;&gt;&gt;      var member9: Int<br>&gt;&gt;&gt;      var member11: Int<br>&gt;&gt;&gt;      var member15: Int<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Raph<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Access modifier blocks</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 14, 2016 at 01:00:00pm</p></header><div class="content"><p>I dont agree. I think extensions serve this purpose very well. Here is what I do:<br></p><p>I start with the type declaration only containing properties (public or private). I then create one extension per access level required and one per protocol conformance and per superclass overrides. We get:<br></p><p>class MyViewController: UIViewController {<br>    public let publicProp: Int = 0<br>    @IBOutlet private var tableView: UITableView!<br>}<br></p><p>//MARK: - Public<br>public extension MyViewController {<br>    // Public functions<br>}<br></p><p>//MARK: - UIViewController<br>public extension MyViewController {<br>    override func viewDidLoad() {<br>    }<br>}<br></p><p>//MARK: UITableViewDataSource<br>extension MyViewController: UITableViewDataSource {<br>    override func numberOfSectionsInTableView(tableView: UITableView) {<br>        return 1<br>    }<br>}<br></p><p>//MARK: Private<br>private extension MyViewController {<br>    // Private functions<br>}<br></p><p>&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>&gt; It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br>&gt; <br>&gt; Raph<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt; public var member4: Int<br>&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt; private var member6: Int<br>&gt;&gt;&gt;&gt; public var member7: Int<br>&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt; private var member9: Int<br>&gt;&gt;&gt;&gt; public var member10: Int<br>&gt;&gt;&gt;&gt; private var member11: Int<br>&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt; public var member13: Int<br>&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt; private var member15: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;&gt; public { <br>&gt;&gt;&gt;&gt;     var member1: Int<br>&gt;&gt;&gt;&gt;     var member4: Int<br>&gt;&gt;&gt;&gt;     var member7: Int<br>&gt;&gt;&gt;&gt;     var member10: Int<br>&gt;&gt;&gt;&gt;     var member13: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt;&gt;&gt;&gt; internal {<br>&gt;&gt;&gt;&gt;     var member2: Int<br>&gt;&gt;&gt;&gt;     var member5: Int<br>&gt;&gt;&gt;&gt;     var member8: Int<br>&gt;&gt;&gt;&gt;     var member12: Int<br>&gt;&gt;&gt;&gt;     var member14: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;&gt; private {<br>&gt;&gt;&gt;&gt;     var member3: Int<br>&gt;&gt;&gt;&gt;     var member6: Int<br>&gt;&gt;&gt;&gt;     var member9: Int<br>&gt;&gt;&gt;&gt;     var member11: Int<br>&gt;&gt;&gt;&gt;     var member15: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Access modifier blocks</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 14, 2016 at 01:00:00pm</p></header><div class="content"><p>And if you want to be able to declare properties in extensions, which I&#39;m not a fan of, I think it would still be more a appropriate proposal than one that adds another way to group access modifiers.<br></p><p>&gt; On 14 Jun 2016, at 13:18, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I dont agree. I think extensions serve this purpose very well. Here is what I do:<br>&gt; <br>&gt; I start with the type declaration only containing properties (public or private). I then create one extension per access level required and one per protocol conformance and per superclass overrides. We get:<br>&gt; <br>&gt; class MyViewController: UIViewController {<br>&gt;    public let publicProp: Int = 0<br>&gt;    @IBOutlet private var tableView: UITableView!<br>&gt; }<br>&gt; <br>&gt; //MARK: - Public<br>&gt; public extension MyViewController {<br>&gt;    // Public functions<br>&gt; }<br>&gt; <br>&gt; //MARK: - UIViewController<br>&gt; public extension MyViewController {<br>&gt;    override func viewDidLoad() {<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; //MARK: UITableViewDataSource<br>&gt; extension MyViewController: UITableViewDataSource {<br>&gt;    override func numberOfSectionsInTableView(tableView: UITableView) {<br>&gt;        return 1<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; //MARK: Private<br>&gt; private extension MyViewController {<br>&gt;    // Private functions<br>&gt; }<br>&gt; <br>&gt;&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>&gt;&gt; It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br>&gt;&gt; <br>&gt;&gt; Raph<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt; public var member4: Int<br>&gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt;&gt; private var member6: Int<br>&gt;&gt;&gt;&gt;&gt; public var member7: Int<br>&gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt;&gt; private var member9: Int<br>&gt;&gt;&gt;&gt;&gt; public var member10: Int<br>&gt;&gt;&gt;&gt;&gt; private var member11: Int<br>&gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt;&gt; public var member13: Int<br>&gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt;&gt; private var member15: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;&gt;&gt; public { <br>&gt;&gt;&gt;&gt;&gt;    var member1: Int<br>&gt;&gt;&gt;&gt;&gt;    var member4: Int<br>&gt;&gt;&gt;&gt;&gt;    var member7: Int<br>&gt;&gt;&gt;&gt;&gt;    var member10: Int<br>&gt;&gt;&gt;&gt;&gt;    var member13: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt;&gt;&gt;&gt;&gt; internal {<br>&gt;&gt;&gt;&gt;&gt;    var member2: Int<br>&gt;&gt;&gt;&gt;&gt;    var member5: Int<br>&gt;&gt;&gt;&gt;&gt;    var member8: Int<br>&gt;&gt;&gt;&gt;&gt;    var member12: Int<br>&gt;&gt;&gt;&gt;&gt;    var member14: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;&gt;&gt; private {<br>&gt;&gt;&gt;&gt;&gt;    var member3: Int<br>&gt;&gt;&gt;&gt;&gt;    var member6: Int<br>&gt;&gt;&gt;&gt;&gt;    var member9: Int<br>&gt;&gt;&gt;&gt;&gt;    var member11: Int<br>&gt;&gt;&gt;&gt;&gt;    var member15: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>June 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Your style may vary, but in my experience the access level of two functions<br>has very little effect on how they should be grouped.<br></p><p>Let&#39;s take an example: a class with two init functions. (If you want a<br>concrete example: a subclass of UIView has init(frame) and init(coder)).<br>While the inits take different arguments, they share a lot of<br>initialisation steps, so to avoid unnecessary duplication, we create a<br>private &#39;sharedInitialisation()&#39; function which both init()s call once<br>they&#39;ve set the class&#39;s values.<br></p><p>For readability&#39;s sake, in the Swift file, I write the two init() functions<br>one after the other, and then I write the sharedInitialisation() function<br>immediately below them. That way they&#39;re all on the screen simultaneously -<br>I don&#39;t need to click or scroll to the &#39;private extension&#39; to understand<br>how this class is set up.<br></p><p>If the intent of this is to group functions together so that it&#39;s easier to<br>find only the ones which can be called from the internal/public levels,<br>then I think there are better ways. Xcode generates interface counterpart<br>files of Swift types which strip the type and its functions to just their<br>declarations.<br></p><p>Are there other advantages to segregating functions by access levels?<br></p><p>Ross<br></p><p>On Tue, Jun 14, 2016 at 9:21 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; And if you want to be able to declare properties in extensions, which I&#39;m<br>&gt; not a fan of, I think it would still be more a appropriate proposal than<br>&gt; one that adds another way to group access modifiers.<br>&gt;<br>&gt; &gt; On 14 Jun 2016, at 13:18, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I dont agree. I think extensions serve this purpose very well. Here is<br>&gt; what I do:<br>&gt; &gt;<br>&gt; &gt; I start with the type declaration only containing properties (public or<br>&gt; private). I then create one extension per access level required and one per<br>&gt; protocol conformance and per superclass overrides. We get:<br>&gt; &gt;<br>&gt; &gt; class MyViewController: UIViewController {<br>&gt; &gt;    public let publicProp: Int = 0<br>&gt; &gt;    @IBOutlet private var tableView: UITableView!<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; //MARK: - Public<br>&gt; &gt; public extension MyViewController {<br>&gt; &gt;    // Public functions<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; //MARK: - UIViewController<br>&gt; &gt; public extension MyViewController {<br>&gt; &gt;    override func viewDidLoad() {<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; //MARK: UITableViewDataSource<br>&gt; &gt; extension MyViewController: UITableViewDataSource {<br>&gt; &gt;    override func numberOfSectionsInTableView(tableView: UITableView) {<br>&gt; &gt;        return 1<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; //MARK: Private<br>&gt; &gt; private extension MyViewController {<br>&gt; &gt;    // Private functions<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, extensions serve a different purposes. It doesn’t seem right for<br>&gt; me to just split every class content into 3 different extensions only to<br>&gt; group together items with a similar access level.<br>&gt; &gt;&gt; It would just make the codebase of a framework more messy. Access<br>&gt; modifier block allows to not break the structure of a class but make it<br>&gt; more easy to organize, to write and to read which seems nice for our «<br>&gt; write less, achieve more » new favorite language, Swift. :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Raph<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a<br>&gt; écrit :<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; What does this do that breaking a structure down into local<br>&gt; extensions with the appropriate level of access control doesn&#39;t?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I<br>&gt; would like to share with you.<br>&gt; &gt;&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a<br>&gt; proposal.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt; &gt;&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt; &gt;&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access<br>&gt; modifier and visibility scope.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple<br>&gt; to use and makes sense. But, especially in the context of framework<br>&gt; development, it can quickly becomes messy and confusing to define the<br>&gt; visibility for each member variable, function or enum. Also it takes more<br>&gt; time to write and is not ideal to visualize the public interface of a class.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; class A {<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; class B {<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member4: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member6: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member7: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member9: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member10: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member11: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; public var member13: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; private var member15: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to<br>&gt; think twice to visualize what could be the public interface of our<br>&gt; framework.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the<br>&gt; access modifiers for a block of declarations.<br>&gt; &gt;&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; class B {<br>&gt; &gt;&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt; &gt;&gt;&gt;&gt;&gt; public {<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member1: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member4: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member7: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member10: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member13: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt; &gt;&gt;&gt;&gt;&gt; internal {<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member2: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member5: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member8: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member12: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member14: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone !<br>&gt; My preciouuusss<br>&gt; &gt;&gt;&gt;&gt;&gt; private {<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member3: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member6: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member9: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member11: Int<br>&gt; &gt;&gt;&gt;&gt;&gt;    var member15: Int<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same<br>&gt; keywords, which is quiet boring, and helps visualizing the architecture of<br>&gt; the framework by highlighting what can create a dependency with other<br>&gt; classes inside the framework and with code outside of the framework.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could<br>&gt; define a set of methods that can be called only inside the framework and<br>&gt; another public one that can be called from outside of the framework.<br>&gt; &gt;&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the<br>&gt; public stuff in the protocol.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing<br>&gt; private/internal/public on every single line would still work outside of an<br>&gt; access modifier block so developers could move to use this smoothly.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Raph<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160614/d23eaf72/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Your approach has a major flaw: methods from extensions can&#39;t be overridden (at least for now). As long as you want to your controller to be subclassed and allow overriding your public/internal methods, you need to move them from extensions to the main class scope. Which simply sucks and may be fine for final classes (or classes that you don&#39;t plan on subclassing), but is in no way a good way to design a root class which is meant to be subclassed.<br></p><p>I am kind of on and off on this proposal - I like the way you can group vars together based on access control, but I&#39;d leave it at that, not extending it to methodsm since it would introduce horizontal space issues (code starting at indentation level 4).<br></p><p>&gt; On Jun 14, 2016, at 10:18 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I dont agree. I think extensions serve this purpose very well. Here is what I do:<br>&gt; <br>&gt; I start with the type declaration only containing properties (public or private). I then create one extension per access level required and one per protocol conformance and per superclass overrides. We get:<br>&gt; <br>&gt; class MyViewController: UIViewController {<br>&gt;    public let publicProp: Int = 0<br>&gt;    @IBOutlet private var tableView: UITableView!<br>&gt; }<br>&gt; <br>&gt; //MARK: - Public<br>&gt; public extension MyViewController {<br>&gt;    // Public functions<br>&gt; }<br>&gt; <br>&gt; //MARK: - UIViewController<br>&gt; public extension MyViewController {<br>&gt;    override func viewDidLoad() {<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; //MARK: UITableViewDataSource<br>&gt; extension MyViewController: UITableViewDataSource {<br>&gt;    override func numberOfSectionsInTableView(tableView: UITableView) {<br>&gt;        return 1<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; //MARK: Private<br>&gt; private extension MyViewController {<br>&gt;    // Private functions<br>&gt; }<br>&gt; <br>&gt;&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>&gt;&gt; It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br>&gt;&gt; <br>&gt;&gt; Raph<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt; public var member4: Int<br>&gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt;&gt; private var member6: Int<br>&gt;&gt;&gt;&gt;&gt; public var member7: Int<br>&gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt;&gt; private var member9: Int<br>&gt;&gt;&gt;&gt;&gt; public var member10: Int<br>&gt;&gt;&gt;&gt;&gt; private var member11: Int<br>&gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt;&gt; public var member13: Int<br>&gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt;&gt; private var member15: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;&gt;&gt; public { <br>&gt;&gt;&gt;&gt;&gt;    var member1: Int<br>&gt;&gt;&gt;&gt;&gt;    var member4: Int<br>&gt;&gt;&gt;&gt;&gt;    var member7: Int<br>&gt;&gt;&gt;&gt;&gt;    var member10: Int<br>&gt;&gt;&gt;&gt;&gt;    var member13: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt;&gt;&gt;&gt;&gt; internal {<br>&gt;&gt;&gt;&gt;&gt;    var member2: Int<br>&gt;&gt;&gt;&gt;&gt;    var member5: Int<br>&gt;&gt;&gt;&gt;&gt;    var member8: Int<br>&gt;&gt;&gt;&gt;&gt;    var member12: Int<br>&gt;&gt;&gt;&gt;&gt;    var member14: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;&gt;&gt; private {<br>&gt;&gt;&gt;&gt;&gt;    var member3: Int<br>&gt;&gt;&gt;&gt;&gt;    var member6: Int<br>&gt;&gt;&gt;&gt;&gt;    var member9: Int<br>&gt;&gt;&gt;&gt;&gt;    var member11: Int<br>&gt;&gt;&gt;&gt;&gt;    var member15: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/019f9103a2e36c35bcf1c713fd5d4812?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Raphaël Wach</string> &lt;raphael.wach at icloud.com&gt;<p>June 19, 2016 at 08:00:00pm</p></header><div class="content"><p>Also, even if the sample code with the 3 extensions might looks ok, think that if you’re working on a 300 classes project, declaring 900 extensions seems a crazy thing to do. I would not have to do this on a big project.<br></p><p>@Charlie: Agree with you, on second thought, the implication of extending the use of access modifier blocks to functions and protocols seems a bit tricky and could increase the indentation level of the code in an annoying way. So, I would go with a proposal limited to vars/constants/properties items.<br></p><p><br></p><p><br>&gt; Le 14 juin 2016 à 23:46, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt; <br>&gt; Your approach has a major flaw: methods from extensions can&#39;t be overridden (at least for now). As long as you want to your controller to be subclassed and allow overriding your public/internal methods, you need to move them from extensions to the main class scope. Which simply sucks and may be fine for final classes (or classes that you don&#39;t plan on subclassing), but is in no way a good way to design a root class which is meant to be subclassed.<br>&gt; <br>&gt; I am kind of on and off on this proposal - I like the way you can group vars together based on access control, but I&#39;d leave it at that, not extending it to methodsm since it would introduce horizontal space issues (code starting at indentation level 4).<br>&gt; <br>&gt;&gt; On Jun 14, 2016, at 10:18 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I dont agree. I think extensions serve this purpose very well. Here is what I do:<br>&gt;&gt; <br>&gt;&gt; I start with the type declaration only containing properties (public or private). I then create one extension per access level required and one per protocol conformance and per superclass overrides. We get:<br>&gt;&gt; <br>&gt;&gt; class MyViewController: UIViewController {<br>&gt;&gt;   public let publicProp: Int = 0<br>&gt;&gt;   @IBOutlet private var tableView: UITableView!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: - Public<br>&gt;&gt; public extension MyViewController {<br>&gt;&gt;   // Public functions<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: - UIViewController<br>&gt;&gt; public extension MyViewController {<br>&gt;&gt;   override func viewDidLoad() {<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: UITableViewDataSource<br>&gt;&gt; extension MyViewController: UITableViewDataSource {<br>&gt;&gt;   override func numberOfSectionsInTableView(tableView: UITableView) {<br>&gt;&gt;       return 1<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: Private<br>&gt;&gt; private extension MyViewController {<br>&gt;&gt;   // Private functions<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>&gt;&gt;&gt; It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Raph<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member4: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member6: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member7: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member9: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member10: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member11: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member13: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member15: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;&gt;&gt;&gt; public { <br>&gt;&gt;&gt;&gt;&gt;&gt;   var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member4: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member7: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member10: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member13: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt;&gt;&gt;&gt;&gt;&gt; internal {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member5: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member8: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member12: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member14: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;&gt;&gt;&gt; private {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member6: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member9: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member11: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   var member15: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Access modifier blocks</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Feel free to move the further discussion into my thread with an enhanced mechanism called group. Thread link.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Juni 2016 um 20:24:31, Raphaël Wach via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Also, even if the sample code with the 3 extensions might looks ok, think that if you’re working on a 300 classes project, declaring 900 extensions seems a crazy thing to do. I would not have to do this on a big project.<br></p><p>@Charlie: Agree with you, on second thought, the implication of extending the use of access modifier blocks to functions and protocols seems a bit tricky and could increase the indentation level of the code in an annoying way. So, I would go with a proposal limited to vars/constants/properties items.<br></p><p><br></p><p><br>&gt; Le 14 juin 2016 à 23:46, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;  <br>&gt; Your approach has a major flaw: methods from extensions can&#39;t be overridden (at least for now). As long as you want to your controller to be subclassed and allow overriding your public/internal methods, you need to move them from extensions to the main class scope. Which simply sucks and may be fine for final classes (or classes that you don&#39;t plan on subclassing), but is in no way a good way to design a root class which is meant to be subclassed.<br>&gt;  <br>&gt; I am kind of on and off on this proposal - I like the way you can group vars together based on access control, but I&#39;d leave it at that, not extending it to methodsm since it would introduce horizontal space issues (code starting at indentation level 4).<br>&gt;  <br>&gt;&gt; On Jun 14, 2016, at 10:18 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;  <br>&gt;&gt; I dont agree. I think extensions serve this purpose very well. Here is what I do:<br>&gt;&gt;  <br>&gt;&gt; I start with the type declaration only containing properties (public or private). I then create one extension per access level required and one per protocol conformance and per superclass overrides. We get:<br>&gt;&gt;  <br>&gt;&gt; class MyViewController: UIViewController {<br>&gt;&gt; public let publicProp: Int = 0<br>&gt;&gt; @IBOutlet private var tableView: UITableView!<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; //MARK: - Public<br>&gt;&gt; public extension MyViewController {<br>&gt;&gt; // Public functions<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; //MARK: - UIViewController<br>&gt;&gt; public extension MyViewController {<br>&gt;&gt; override func viewDidLoad() {<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; //MARK: UITableViewDataSource<br>&gt;&gt; extension MyViewController: UITableViewDataSource {<br>&gt;&gt; override func numberOfSectionsInTableView(tableView: UITableView) {<br>&gt;&gt; return 1<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; //MARK: Private<br>&gt;&gt; private extension MyViewController {<br>&gt;&gt; // Private functions<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt;&gt; On 13 Jun 2016, at 01:14, Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Yes, extensions serve a different purposes. It doesn’t seem right for me to just split every class content into 3 different extensions only to group together items with a similar access level.<br>&gt;&gt;&gt; It would just make the codebase of a framework more messy. Access modifier block allows to not break the structure of a class but make it more easy to organize, to write and to read which seems nice for our « write less, achieve more » new favorite language, Swift. :)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Le 13 juin 2016 à 10:04, Charlie Monroe &lt;charlie at charliemonroe.net&gt; a écrit :<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Extensions can&#39;t have stored properties.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jun 13, 2016, at 9:59 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; What does this do that breaking a structure down into local extensions with the appropriate level of access control doesn&#39;t?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; 2016/06/13 0:55、Raphaël Wach via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swifters,<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; While working on some framework programming, I had this idea that I would like to share with you.<br>&gt;&gt;&gt;&gt;&gt;&gt; If some other people like it, I would be more than happy to write a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is a little draft I wrote as a starting point to discuss.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry if there is mistakes, I am not an english native speaker.<br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you for your feedback.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift proposal: Access modifier blocks<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; This proposal introduces a refinement of the way to define access modifier and visibility scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The current keywords private, internal and public are nice, simple to use and makes sense. But, especially in the context of framework development, it can quickly becomes messy and confusing to define the visibility for each member variable, function or enum. Also it takes more time to write and is not ideal to visualize the public interface of a class.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; If a class A has only a few members, that’s ok to write  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; With a bigger class B, it will looks far less nice<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member4: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member6: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member7: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member9: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member10: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member11: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; public var member13: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; private var member15: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; And now, it’s really messy, takes more time to write and we need to think twice to visualize what could be the public interface of our framework.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The purpose of this proposal is to allow the definition of the access modifiers for a block of declarations.<br>&gt;&gt;&gt;&gt;&gt;&gt; Then our class B could be:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;&gt;&gt; // Ok then this is part of the public interface of my framework<br>&gt;&gt;&gt;&gt;&gt;&gt; public {  <br>&gt;&gt;&gt;&gt;&gt;&gt; var member1: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member4: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member7: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member10: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member13: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; // This can be used anywhere in my framework<br>&gt;&gt;&gt;&gt;&gt;&gt; internal {<br>&gt;&gt;&gt;&gt;&gt;&gt; var member2: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member5: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member8: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member12: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member14: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; // Here remains my private stuff. Don’t touch it ! Leave me alone ! My preciouuusss<br>&gt;&gt;&gt;&gt;&gt;&gt; private {<br>&gt;&gt;&gt;&gt;&gt;&gt; var member3: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member6: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member9: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member11: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var member15: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; It increases readability, avoid to write many times the same keywords, which is quiet boring, and helps visualizing the architecture of the framework by highlighting what can create a dependency with other classes inside the framework and with code outside of the framework.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; It might also be useful in protocols. For exemple, a protocol could define a set of methods that can be called only inside the framework and another public one that can be called from outside of the framework.<br>&gt;&gt;&gt;&gt;&gt;&gt; Classes defined outside of the framework could only implement the public stuff in the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; It would have no impact on the existing code as the existing private/internal/public on every single line would still work outside of an access modifier block so developers could move to use this smoothly.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; ————————————————————————————————————<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Please, let me know if you like the idea.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Raph<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  <br>&gt;  <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/f1560eb5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
