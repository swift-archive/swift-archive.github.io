<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/253ccd238d164ec69666c327a779756c?s=50"></div><header><strong>$self</strong> from <string>Paul Jack</string> &lt;paul.jack at pobox.com&gt;<p>September 28, 2016 at 04:00:00pm</p></header><div class="content"><p>So previously there were a few threads on the &quot;strong self/weak self<br>dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br></p><p>...and possibly others.<br></p><p>I&#39;d like to propose something even easier (and more specific) than all<br>of the above discussions. Specifically, I&#39;d like to introduce a new<br>automagic closure variable, $self, whose presence in a closure would<br>cause that closure to weakly capture self in a safe manner.<br></p><p>As a concrete example, let&#39;s imagine a UIViewController for a login<br>form. Under this proposal, the following code:<br></p><p>func viewDidLoad() {<br>    self.loginForm.onSubmit = {<br>         let f = $self.loginForm<br>         $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>    }<br>}<br></p><p>...would be treated by the compiler as equivalent to:<br></p><p>func viewDidLoad() {<br>    self.loginForm.onSubmit = {<br>         [weak self] in<br>         if let selfie = self {<br>             let f = selfie.loginForm<br>             selfie.startLoginRequest(email:f.email.text,<br>             pwd:f.pwd.text)<br>         }<br>    }<br>}<br></p><p>Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>execute at all, but if self does exist, then it exists for the entirety<br>of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>of some statement in the closure.) I think these semantics obey the<br>principle of least surprise; $self can be treated by the developer as a<br>strong reference.<br></p><p>However, that does mean that $self can only be used in a closure that&#39;s<br>(a) Void or (b) Optional. In the latter case, returning nil when self<br>doesn&#39;t exist seems like reasonable/expected behavior.<br></p><p>It would be a compile-time error to use both $self and normal self in<br>the same closure.<br></p><p>I&#39;d like to keep this simple, meaning $self always does the above and<br>nothing else. So, if you need an unowned self, you still need the<br>original syntax; if your closure needs a non-Optional return type, you<br>still need the original syntax; etc.<br></p><p>Thoughts?<br></p><p>-Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>$self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 4:05 PM, Paul Jack via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt; <br>&gt; ...and possibly others.<br>&gt; <br>&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt; cause that closure to weakly capture self in a safe manner.<br></p><p>This is an additive proposal, so weâ€™d prefer for you to hold off until we get the core work for Swift 4 stage 1 under control.  We need to focus on making sure ABI and Source Stability takes priority.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>$self</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 28, 2016 at 11:00:00pm</p></header><div class="content"><p>It could potentially be a breaking change if the default for @escaping<br>closures were made to be weak-capturing.<br></p><p>Since the weak-capturing pattern is only really desirable for @escaping<br>closures, and (I think) it would be the usual preference, could @escaping<br>also imply weak-capturing for all references (not just self)? Then there<br>would be another syntax for strong-capturing-escaping closures.<br>Non-escaping closures could a) strongly capture references; or b) existing<br>strong references stay strong and weak ones stay weak, meaning no<br>ref-counts need to change at all when passing them.<br></p><p><br>On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;<br>&gt; ...and possibly others.<br>&gt;<br>&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;<br>&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt; form. Under this proposal, the following code:<br>&gt;<br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {<br>&gt;          let f = $self.loginForm<br>&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; ...would be treated by the compiler as equivalent to:<br>&gt;<br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {<br>&gt;          [weak self] in<br>&gt;          if let selfie = self {<br>&gt;              let f = selfie.loginForm<br>&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;              pwd:f.pwd.text)<br>&gt;          }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt; of some statement in the closure.) I think these semantics obey the<br>&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt; strong reference.<br>&gt;<br>&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;<br>&gt; It would be a compile-time error to use both $self and normal self in<br>&gt; the same closure.<br>&gt;<br>&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt; still need the original syntax; etc.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Paul<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/e8daa680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>$self</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Pretty sure this is all way out of scope, but something about this made me think about this idea (which maybe isn&#39;t unique or is maybe even unworkable), but imagine something like where a new capture type is added such as &quot;required&quot; (for lack of another name right now). And the way this works is similar to unowned, but it makes the entire closure &quot;weak&quot; in such a way that the moment any of the required captures go nil, any references to that closure instance also effectively become nil.<br></p><p>So modifying the example:<br></p><p>func viewDidLoad() {<br>    self.loginForm.onSubmit = {[required self]<br>         let f = self.loginForm<br>         self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>    }<br>}<br></p><p>So in this case, &quot;required self&quot; means self is effectively &quot;unowned&quot; but any references to this closure would have to be weak optional like: weak var onSubmit: (()-&gt;Void)? So that when the view controller gets deallocated, the closure goes with it and references become nil.<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Sep 28, 2016, at 6:42 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It could potentially be a breaking change if the default for @escaping closures were made to be weak-capturing.<br>&gt; <br>&gt; Since the weak-capturing pattern is only really desirable for @escaping closures, and (I think) it would be the usual preference, could @escaping also imply weak-capturing for all references (not just self)? Then there would be another syntax for strong-capturing-escaping closures. Non-escaping closures could a) strongly capture references; or b) existing strong references stay strong and weak ones stay weak, meaning no ref-counts need to change at all when passing them.<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt;&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;&gt; <br>&gt;&gt; ...and possibly others.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt;&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt;&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt;&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;&gt; <br>&gt;&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt;&gt; form. Under this proposal, the following code:<br>&gt;&gt; <br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          let f = $self.loginForm<br>&gt;&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ...would be treated by the compiler as equivalent to:<br>&gt;&gt; <br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          [weak self] in<br>&gt;&gt;          if let selfie = self {<br>&gt;&gt;              let f = selfie.loginForm<br>&gt;&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;&gt;              pwd:f.pwd.text)<br>&gt;&gt;          }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt;&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt;&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt;&gt; of some statement in the closure.) I think these semantics obey the<br>&gt;&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt;&gt; strong reference.<br>&gt;&gt; <br>&gt;&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt;&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt;&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;&gt; <br>&gt;&gt; It would be a compile-time error to use both $self and normal self in<br>&gt;&gt; the same closure.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt;&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt;&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt;&gt; still need the original syntax; etc.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Paul<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/957e341b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>$self</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Now that I think about this, wouldn&#39;t that be a better default behavior? All captures are this &quot;required&quot; type which means all closures are typed as optional. To override that behavior, you&#39;d have to explicitly declare a weak or unowned capture instead and if you did that for all reference captures, the closure&#39;s type would be non-optional as they are now. Seems like that&#39;d be safer. I&#39;ll shut up now.<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Sep 28, 2016, at 7:25 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Pretty sure this is all way out of scope, but something about this made me think about this idea (which maybe isn&#39;t unique or is maybe even unworkable), but imagine something like where a new capture type is added such as &quot;required&quot; (for lack of another name right now). And the way this works is similar to unowned, but it makes the entire closure &quot;weak&quot; in such a way that the moment any of the required captures go nil, any references to that closure instance also effectively become nil.<br>&gt; <br>&gt; So modifying the example:<br>&gt; <br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {[required self]<br>&gt;          let f = self.loginForm<br>&gt;          self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; So in this case, &quot;required self&quot; means self is effectively &quot;unowned&quot; but any references to this closure would have to be weak optional like: weak var onSubmit: (()-&gt;Void)? So that when the view controller gets deallocated, the closure goes with it and references become nil.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 6:42 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It could potentially be a breaking change if the default for @escaping closures were made to be weak-capturing.<br>&gt;&gt; <br>&gt;&gt; Since the weak-capturing pattern is only really desirable for @escaping closures, and (I think) it would be the usual preference, could @escaping also imply weak-capturing for all references (not just self)? Then there would be another syntax for strong-capturing-escaping closures. Non-escaping closures could a) strongly capture references; or b) existing strong references stay strong and weak ones stay weak, meaning no ref-counts need to change at all when passing them.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt;&gt;&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...and possibly others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt;&gt;&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt;&gt;&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt;&gt;&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt;&gt;&gt; form. Under this proposal, the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;&gt;          let f = $self.loginForm<br>&gt;&gt;&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...would be treated by the compiler as equivalent to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;&gt;          [weak self] in<br>&gt;&gt;&gt;          if let selfie = self {<br>&gt;&gt;&gt;              let f = selfie.loginForm<br>&gt;&gt;&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;&gt;&gt;              pwd:f.pwd.text)<br>&gt;&gt;&gt;          }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt;&gt;&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt;&gt;&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt;&gt;&gt; of some statement in the closure.) I think these semantics obey the<br>&gt;&gt;&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt;&gt;&gt; strong reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt;&gt;&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt;&gt;&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be a compile-time error to use both $self and normal self in<br>&gt;&gt;&gt; the same closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt;&gt;&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt;&gt;&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt;&gt;&gt; still need the original syntax; etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Paul<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/504a17af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>$self</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 29, 2016 at 12:00:00am</p></header><div class="content"><p>Sean, yeah that&#39;s kind of what I was suggesting for @escaping closures - it<br>should be the default... but it is a breaking change and as Chris pointed<br>out that would need extreme justification... plus it would be a behaviour<br>change with no syntax change, so code that was never &quot;upgraded&quot; would be<br>very difficult to tell the original intention. I like the idea but I don&#39;t<br>know if I can come up with &quot;extreme justification&quot; for it.<br></p><p>On Thu, 29 Sep 2016 at 01:46 Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; Now that I think about this, wouldn&#39;t that be a better default behavior?<br>&gt; All captures are this &quot;required&quot; type which means all closures are typed as<br>&gt; optional. To override that behavior, you&#39;d have to explicitly declare a<br>&gt; weak or unowned capture instead and if you did that for all reference<br>&gt; captures, the closure&#39;s type would be non-optional as they are now. Seems<br>&gt; like that&#39;d be safer. I&#39;ll shut up now.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Sep 28, 2016, at 7:25 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt; Pretty sure this is all way out of scope, but something about this made me<br>&gt; think about this idea (which maybe isn&#39;t unique or is maybe even<br>&gt; unworkable), but imagine something like where a new capture type is added<br>&gt; such as &quot;required&quot; (for lack of another name right now). And the way this<br>&gt; works is similar to unowned, but it makes the entire closure &quot;weak&quot; in such<br>&gt; a way that the moment any of the required captures go nil, any references<br>&gt; to that closure instance also effectively become nil.<br>&gt;<br>&gt; So modifying the example:<br>&gt;<br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {[required self]<br>&gt;          let f = self.loginForm<br>&gt;          self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; So in this case, &quot;required self&quot; means self is effectively &quot;unowned&quot; but<br>&gt; any references to this closure would have to be weak optional like: weak<br>&gt; var onSubmit: (()-&gt;Void)? So that when the view controller gets<br>&gt; deallocated, the closure goes with it and references become nil.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Sep 28, 2016, at 6:42 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It could potentially be a breaking change if the default for @escaping<br>&gt; closures were made to be weak-capturing.<br>&gt;<br>&gt; Since the weak-capturing pattern is only really desirable for @escaping<br>&gt; closures, and (I think) it would be the usual preference, could @escaping<br>&gt; also imply weak-capturing for all references (not just self)? Then there<br>&gt; would be another syntax for strong-capturing-escaping closures.<br>&gt; Non-escaping closures could a) strongly capture references; or b) existing<br>&gt; strong references stay strong and weak ones stay weak, meaning no<br>&gt; ref-counts need to change at all when passing them.<br>&gt;<br>&gt;<br>&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt;&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;&gt;<br>&gt;&gt; ...and possibly others.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt;&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt;&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt;&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;&gt;<br>&gt;&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt;&gt; form. Under this proposal, the following code:<br>&gt;&gt;<br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          let f = $self.loginForm<br>&gt;&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ...would be treated by the compiler as equivalent to:<br>&gt;&gt;<br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          [weak self] in<br>&gt;&gt;          if let selfie = self {<br>&gt;&gt;              let f = selfie.loginForm<br>&gt;&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;&gt;              pwd:f.pwd.text)<br>&gt;&gt;          }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt;&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt;&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt;&gt; of some statement in the closure.) I think these semantics obey the<br>&gt;&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt;&gt; strong reference.<br>&gt;&gt;<br>&gt;&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt;&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt;&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;&gt;<br>&gt;&gt; It would be a compile-time error to use both $self and normal self in<br>&gt;&gt; the same closure.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt;&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt;&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt;&gt; still need the original syntax; etc.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Paul<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/d88f8461/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>$self</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 7:48 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sean, yeah that&#39;s kind of what I was suggesting for @escaping closures - it should be the default... but it is a breaking change and as Chris pointed out that would need extreme justification... plus it would be a behaviour change with no syntax change, so code that was never &quot;upgraded&quot; would be very difficult to tell the original intention. I like the idea but I don&#39;t know if I can come up with &quot;extreme justification&quot; for it.<br></p><p>How do reference cycles created by accidental implicit captures rank in the list of commonly encountered runtime issues? Itâ€™s gotta be high, isnâ€™t it? Especially if you limit the scope to memory leaksâ€”it seems every time Iâ€™ve had to track down one of those since ARC came out, itâ€™s been either an unintended closure capture or something KVO-related.<br></p><p>Closures are, for me, the #1 time that I switch to super-defensive coding mode. Requiring explicit semantics to capture variables would surely reduce a lot of memory issues, and also fix crashes that could be caused by objects being deallocated in the wrong order. The quality of code in general would improve. Is that extreme? I donâ€™t know, but I certainly wouldnâ€™t complain if it happened.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/4f52b316/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>$self</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>September 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Yeah, hard to say how extreme it needs to be to justify this sort of change. Does running into unintentional retain cycles when using closures for event handlers *constantly* count as extreme? :)<br></p><p>In a typical garbage collected language, using closures like this is common and a non-issue, but in Swift the ownership in these situations is something you have to actively think about which is a distraction when you want to spend your time thinking about what you&#39;re building instead. It reminds me of manual memory management (which of course it is).<br></p><p>l8r<br>Sean <br></p><p>Sent from my iPad<br></p><p>&gt; On Sep 28, 2016, at 7:48 PM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Sean, yeah that&#39;s kind of what I was suggesting for @escaping closures - it should be the default... but it is a breaking change and as Chris pointed out that would need extreme justification... plus it would be a behaviour change with no syntax change, so code that was never &quot;upgraded&quot; would be very difficult to tell the original intention. I like the idea but I don&#39;t know if I can come up with &quot;extreme justification&quot; for it.<br>&gt; <br>&gt;&gt; On Thu, 29 Sep 2016 at 01:46 Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; Now that I think about this, wouldn&#39;t that be a better default behavior? All captures are this &quot;required&quot; type which means all closures are typed as optional. To override that behavior, you&#39;d have to explicitly declare a weak or unowned capture instead and if you did that for all reference captures, the closure&#39;s type would be non-optional as they are now. Seems like that&#39;d be safer. I&#39;ll shut up now.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 28, 2016, at 7:25 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pretty sure this is all way out of scope, but something about this made me think about this idea (which maybe isn&#39;t unique or is maybe even unworkable), but imagine something like where a new capture type is added such as &quot;required&quot; (for lack of another name right now). And the way this works is similar to unowned, but it makes the entire closure &quot;weak&quot; in such a way that the moment any of the required captures go nil, any references to that closure instance also effectively become nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So modifying the example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;     self.loginForm.onSubmit = {[required self]<br>&gt;&gt;&gt;          let f = self.loginForm<br>&gt;&gt;&gt;          self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So in this case, &quot;required self&quot; means self is effectively &quot;unowned&quot; but any references to this closure would have to be weak optional like: weak var onSubmit: (()-&gt;Void)? So that when the view controller gets deallocated, the closure goes with it and references become nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 28, 2016, at 6:42 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It could potentially be a breaking change if the default for @escaping closures were made to be weak-capturing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the weak-capturing pattern is only really desirable for @escaping closures, and (I think) it would be the usual preference, could @escaping also imply weak-capturing for all references (not just self)? Then there would be another syntax for strong-capturing-escaping closures. Non-escaping closures could a) strongly capture references; or b) existing strong references stay strong and weak ones stay weak, meaning no ref-counts need to change at all when passing them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt;&gt;&gt;&gt;&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...and possibly others.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt;&gt;&gt;&gt;&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt;&gt;&gt;&gt;&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt;&gt;&gt;&gt;&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt;&gt;&gt;&gt;&gt; form. Under this proposal, the following code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;&gt;&gt;&gt;          let f = $self.loginForm<br>&gt;&gt;&gt;&gt;&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...would be treated by the compiler as equivalent to:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;&gt;&gt;&gt;          [weak self] in<br>&gt;&gt;&gt;&gt;&gt;          if let selfie = self {<br>&gt;&gt;&gt;&gt;&gt;              let f = selfie.loginForm<br>&gt;&gt;&gt;&gt;&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;&gt;&gt;&gt;&gt;              pwd:f.pwd.text)<br>&gt;&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt;&gt;&gt;&gt;&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt;&gt;&gt;&gt;&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt;&gt;&gt;&gt;&gt; of some statement in the closure.) I think these semantics obey the<br>&gt;&gt;&gt;&gt;&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt;&gt;&gt;&gt;&gt; strong reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt;&gt;&gt;&gt;&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt;&gt;&gt;&gt;&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be a compile-time error to use both $self and normal self in<br>&gt;&gt;&gt;&gt;&gt; the same closure.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt;&gt;&gt;&gt;&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt;&gt;&gt;&gt;&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt;&gt;&gt;&gt;&gt; still need the original syntax; etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Paul<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/73819a53/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>$self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 4:42 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It could potentially be a breaking change if the default for @escaping closures were made to be weak-capturing.<br></p><p>Ok, but source breaking changes need extreme justification.  A primary goal of Swift 3 was to provide source compatibility going forward.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Since the weak-capturing pattern is only really desirable for @escaping closures, and (I think) it would be the usual preference, could @escaping also imply weak-capturing for all references (not just self)? Then there would be another syntax for strong-capturing-escaping closures. Non-escaping closures could a) strongly capture references; or b) existing strong references stay strong and weak ones stay weak, meaning no ref-counts need to change at all when passing them.<br>&gt; <br>&gt; <br>&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;<br>&gt; <br>&gt; ...and possibly others.<br>&gt; <br>&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt; cause that closure to weakly capture self in a safe manner.<br>&gt; <br>&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt; form. Under this proposal, the following code:<br>&gt; <br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {<br>&gt;          let f = $self.loginForm<br>&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; ...would be treated by the compiler as equivalent to:<br>&gt; <br>&gt; func viewDidLoad() {<br>&gt;     self.loginForm.onSubmit = {<br>&gt;          [weak self] in<br>&gt;          if let selfie = self {<br>&gt;              let f = selfie.loginForm<br>&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;              pwd:f.pwd.text)<br>&gt;          }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt; of some statement in the closure.) I think these semantics obey the<br>&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt; strong reference.<br>&gt; <br>&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt; <br>&gt; It would be a compile-time error to use both $self and normal self in<br>&gt; the same closure.<br>&gt; <br>&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt; still need the original syntax; etc.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Paul<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/db068700/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>$self</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 29, 2016 at 12:00:00am</p></header><div class="content"><p>I think Sean&#39;s idea for [required refName] on this is the better one in<br>terms of syntax and clarity of what&#39;s going on. It&#39;s fairly clear that the<br>required refs are weak but become strong during the closure execution, and<br>that since they&#39;re &#39;required&#39; the closure goes away if they do.<br></p><p>In practice, with lazy zeroing I think it would not be viable to zero the<br>closure ref until calling it was attempted and the strong ref on its<br>required captures failed.<br>One for the &#39;deferred&#39; pile I guess :P<br></p><p>On Thu, 29 Sep 2016 at 01:27 Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Sep 28, 2016, at 4:42 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It could potentially be a breaking change if the default for @escaping<br>&gt; closures were made to be weak-capturing.<br>&gt;<br>&gt;<br>&gt; Ok, but source breaking changes need extreme justification.  A primary<br>&gt; goal of Swift 3 was to provide source compatibility going forward.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; Since the weak-capturing pattern is only really desirable for @escaping<br>&gt; closures, and (I think) it would be the usual preference, could @escaping<br>&gt; also imply weak-capturing for all references (not just self)? Then there<br>&gt; would be another syntax for strong-capturing-escaping closures.<br>&gt; Non-escaping closures could a) strongly capture references; or b) existing<br>&gt; strong references stay strong and weak ones stay weak, meaning no<br>&gt; ref-counts need to change at all when passing them.<br>&gt;<br>&gt;<br>&gt; On Thu, 29 Sep 2016 at 00:06 Paul Jack via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; So previously there were a few threads on the &quot;strong self/weak self<br>&gt;&gt; dance&quot; but they didn&#39;t seem to get anywhere. For instance:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html<br>&gt;&gt;<br>&gt;&gt; ...and possibly others.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to propose something even easier (and more specific) than all<br>&gt;&gt; of the above discussions. Specifically, I&#39;d like to introduce a new<br>&gt;&gt; automagic closure variable, $self, whose presence in a closure would<br>&gt;&gt; cause that closure to weakly capture self in a safe manner.<br>&gt;&gt;<br>&gt;&gt; As a concrete example, let&#39;s imagine a UIViewController for a login<br>&gt;&gt; form. Under this proposal, the following code:<br>&gt;&gt;<br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          let f = $self.loginForm<br>&gt;&gt;          $self.startLoginRequest(email:f.email.text, pwd:f.pwd.text)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ...would be treated by the compiler as equivalent to:<br>&gt;&gt;<br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt;     self.loginForm.onSubmit = {<br>&gt;&gt;          [weak self] in<br>&gt;&gt;          if let selfie = self {<br>&gt;&gt;              let f = selfie.loginForm<br>&gt;&gt;              selfie.startLoginRequest(email:f.email.text,<br>&gt;&gt;              pwd:f.pwd.text)<br>&gt;&gt;          }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Note the &quot;if let&quot; there: If self no longer exists, the closure does not<br>&gt;&gt; execute at all, but if self does exist, then it exists for the entirety<br>&gt;&gt; of the execution of the closure (ie, self won&#39;t vanish as a side-effect<br>&gt;&gt; of some statement in the closure.) I think these semantics obey the<br>&gt;&gt; principle of least surprise; $self can be treated by the developer as a<br>&gt;&gt; strong reference.<br>&gt;&gt;<br>&gt;&gt; However, that does mean that $self can only be used in a closure that&#39;s<br>&gt;&gt; (a) Void or (b) Optional. In the latter case, returning nil when self<br>&gt;&gt; doesn&#39;t exist seems like reasonable/expected behavior.<br>&gt;&gt;<br>&gt;&gt; It would be a compile-time error to use both $self and normal self in<br>&gt;&gt; the same closure.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to keep this simple, meaning $self always does the above and<br>&gt;&gt; nothing else. So, if you need an unowned self, you still need the<br>&gt;&gt; original syntax; if your closure needs a non-Optional return type, you<br>&gt;&gt; still need the original syntax; etc.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Paul<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/d71228eb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
