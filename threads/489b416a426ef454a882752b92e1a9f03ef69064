<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  3, 2016 at 12:00:00pm</p></header><div class="content"><p>Swift 2.2 is out, and I restart discussion on syntax for custom operators.<br>I insist that this time we should focus less on linguistic aspects.<br></p><p>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br></p><p>Introduction<br></p><p>Replace syntax of operator definition:<br></p><p>infix operator &lt;&gt; { precedence 100 associativity left }<br></p><p>With a directive:<br></p><p>#operator(&lt;&gt;, fixity: infix, associativity: left)<br></p><p>Also replace numeric definition of precedence with separate comparative<br>precedence definitions:<br></p><p>#precedence(+, lessThan: *)<br>#precedence(+, equalTo: -)<br></p><p>Swift-evolution thread: link to the discussion thread for that proposal<br>&lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;<br>Motivation<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems<br>with numeric definition of precedence<br></p><p>In the beginning, operators had nice precedence values: 90, 100, 110, 120,<br>130, 140, 150, 160.<br></p><p>As time went, new and new operators were introduced. Precedence could not<br>be simply changed, as this would be a breaking change. Ranges got<br>precedence 135, as got precedence 132. ?? had precedence greater than &lt;,<br>but less thanas, so it had to be given precedence 131.<br></p><p>Now it is not possible to insert any custom operator between &lt; and ??. It<br>is an inevitable consequence of current design: it will be impossible to<br>insert an operator between two existing ones at some point.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems<br>with a single precedence hierarchy<br></p><p>Currently, if an operator wants to define precedence by comparison to one<br>operator, it must do so for all other operators.<br></p><p>In many cases, this is not wished. Example: a &amp; b &lt; c is a common error<br>pattern. a / b as Double is another one. C++ compilers sometimes emit<br>warnings on these. Swift does not.<br></p><p>The root of the problem is that precedence is defined between all<br>operators. If &amp; had precedence defined only by comparison to other bitwise<br>operators and / – only to arithmetic operators, we would have to place<br>parentheses in such places, not get subtle bugs, and not ever have to look<br>at the huge operator precedence table.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems<br>with current operator definition syntax<br></p><p>Some argue that current operator syntax is not consistent with other<br>language constructs. Properties of operators have dictionary semantics and<br>should be defined as such. It is a rather weak argument right now, but<br>after reworking of precedence, the new syntax will be more to place. More<br>reasons are given below.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts<br>of operator definitions<br></p><p>Consider two operator definitions in different modules.<br></p><p>Module A:<br></p><p>infix operator |&gt; { precedence 137 associativity left }<br></p><p>Module B:<br></p><p>infix operator |&gt; { precedence 138 associativity left }<br></p><p>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed<br>solution<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change<br>syntax for operator definition<br></p><p>#operator(&lt;&gt;, fixity: infix, associativity: left)<br>#operator(!, fixity: postfix)<br></p><p>First parameter of #operator directive is name of the operator. Then goes<br>required parameter fixity that can be infix,prefix, or postfix. Then, for<br>infix operators, goes optional associativity parameter that can be left or<br>right.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative<br>precedence<br></p><p>Remove precedence property from operator definitions. Instead, introduce<br>#precedence directive:<br></p><p>#precedence(+, lessThan: *)<br>#precedence(*, equalTo: /)<br></p><p>Omission of parentheses is allowed only when precedence between the two<br>operators is defined.<br></p><p>1 + 2 * 3  // ok1 + 2 - 3  // error!<br>#precedence(-, equalTo: +)1 + 2 - 3  // now ok<br></p><p>Precedence equality can only be defined for operators with same<br>associativity.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict<br>resolution<br></p><p>Precedence rules can be added freely across modules. Ability to omit<br>parentheses around more operators will not break any code in included<br>modules. On the other hand, conflicting precedence rules result in an error:<br></p><p>#precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br></p><p>Operator definitions do nut cause conflicts, unless they are infix and one<br>of them has associativity: left, but another one has associativity: right.<br></p><p>#operator(!, fixity: prefix)  // ok, duplicated definitions<br>#operator(&lt;&gt;, fixity: infix)<br>#operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>#operator(+, fixity: infix, associativity: right)  // error:<br>associativity conflict<br></p><p>So, if two modules define a custom operator with somewhat similar semantics<br>(at least associativity), they can be used together. Prefix and postfix<br>operators can never have conflicts in definitions. If they define different<br>precedence by comparison to same operators, then, most probably, they had<br>completely different semantics, and the situation is similar to conflict of<br>functions.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed<br>design<br></p><p>operator keyword and local keywords associativity, precedence, left, right will<br>be removed.<br></p><p>Directives with following (informal) syntax will be added:<br></p><p>#operator(OPERATOR_NAME, fixity: FIXITY)<br>#operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>#precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>#precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br></p><p>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>Standard library operator declarations will need to be rewritten. Some of<br>the existing precedence rules will need to be rewritten using #precedence<br> directive.<br></p><p>More importantly, it needs to be discussed what operator precedence rules<br>do *not* need to be retained.<br></p><p>User defined operators will need to be rewritten as well. But precedence<br>will have to be defined by the user. Meanwhile, we can automatically insert<br>parentheses to user code where needed.<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives<br>considered<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave<br>current operator syntax (but change precedence)<br></p><p>#precedence does not make sense to be defined inside of operator<br>definition, as it describes relationship of two operators. If so, then we<br>are left with the following declaration syntax:<br></p><p>prefix operator ! { }infix operator |&gt; { }infix operator &lt;&gt; {<br>associativity left }<br></p><p>If body of operator can only contain associativity (in some cases), then<br>the existence of body itself makes no sense.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/489b9064/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  3, 2016 at 11:00:00am</p></header><div class="content"><p>Interesting, I like the idea of changing how precedence is defined, but I’m curious how under the new scheme we would go about inserting a new operator unambiguously? For example:<br></p><p>	#precedence(•, lessThan: *)<br>	#precedence(~, lessThan: *)<br></p><p>Assuming these are defined in separate modules, how do we determine the order of • and ~?<br></p><p>On a related note, I never encounter precedence issues because I always use parenthesis, since I know I’ll just forget the precedence rules so it’d be a mistake for me to rely on them. If we’re adding operators in precedence hierarchies then that only makes it even harder to learn/remember, so I wonder if we might actually be better served by removing precedence entirely? i.e- the compiler would instead require the use of parenthesis to eliminate ambiguity like so:<br></p><p>	let a = 5 + 6			// Correct, as there aren’t enough operators for ambiguity<br>	let b = 5 + 6 * 7 + 8		// Incorrect, as it relies on precedence to be meaningful<br>	let c = (5 + 6) * (7 + 8)	// Correct, as parenthesis eliminates ambiguity/the need for precedence<br></p><p>This not only eliminates the need to learn, remember and/or lookup precedence, but it’s clearer and avoids mistakes, and IMO it’s actually more readable despite the added noise.<br></p><p>&gt; On 3 Apr 2016, at 10:36, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators. I insist that this time we should focus less on linguistic aspects.<br>&gt; <br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Replace syntax of operator definition:<br>&gt; <br>&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt; With a directive:<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; Also replace numeric definition of precedence with separate comparative precedence definitions:<br>&gt; <br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(+, equalTo: -)<br>&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;Motivation<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems with numeric definition of precedence<br>&gt; <br>&gt; In the beginning, operators had nice precedence values: 90, 100, 110, 120, 130, 140, 150, 160.<br>&gt; <br>&gt; As time went, new and new operators were introduced. Precedence could not be simply changed, as this would be a breaking change. Ranges got precedence 135, as got precedence 132. ?? had precedence greater than &lt;, but less thanas, so it had to be given precedence 131.<br>&gt; <br>&gt; Now it is not possible to insert any custom operator between &lt; and ??. It is an inevitable consequence of current design: it will be impossible to insert an operator between two existing ones at some point.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems with a single precedence hierarchy<br>&gt; <br>&gt; Currently, if an operator wants to define precedence by comparison to one operator, it must do so for all other operators.<br>&gt; <br>&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error pattern. a / b as Double is another one. C++ compilers sometimes emit warnings on these. Swift does not.<br>&gt; <br>&gt; The root of the problem is that precedence is defined between all operators. If &amp; had precedence defined only by comparison to other bitwise operators and / – only to arithmetic operators, we would have to place parentheses in such places, not get subtle bugs, and not ever have to look at the huge operator precedence table.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems with current operator definition syntax<br>&gt; <br>&gt; Some argue that current operator syntax is not consistent with other language constructs. Properties of operators have dictionary semantics and should be defined as such. It is a rather weak argument right now, but after reworking of precedence, the new syntax will be more to place. More reasons are given below.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts of operator definitions<br>&gt; <br>&gt; Consider two operator definitions in different modules.<br>&gt; <br>&gt; Module A:<br>&gt; <br>&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt; Module B:<br>&gt; <br>&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change syntax for operator definition<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; #operator(!, fixity: postfix)<br>&gt; First parameter of #operator directive is name of the operator. Then goes required parameter fixity that can be infix,prefix, or postfix. Then, for infix operators, goes optional associativity parameter that can be left or right.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative precedence<br>&gt; <br>&gt; Remove precedence property from operator definitions. Instead, introduce #precedence directive:<br>&gt; <br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, equalTo: /)<br>&gt; Omission of parentheses is allowed only when precedence between the two operators is defined.<br>&gt; <br>&gt; 1 + 2 * 3  // ok<br>&gt; 1 + 2 - 3  // error!<br>&gt; #precedence(-, equalTo: +)<br>&gt; 1 + 2 - 3  // now ok<br>&gt; Precedence equality can only be defined for operators with same associativity.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict resolution<br>&gt; <br>&gt; Precedence rules can be added freely across modules. Ability to omit parentheses around more operators will not break any code in included modules. On the other hand, conflicting precedence rules result in an error:<br>&gt; <br>&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt; Operator definitions do nut cause conflicts, unless they are infix and one of them has associativity: left, but another one has associativity: right.<br>&gt; <br>&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt; So, if two modules define a custom operator with somewhat similar semantics (at least associativity), they can be used together. Prefix and postfix operators can never have conflicts in definitions. If they define different precedence by comparison to same operators, then, most probably, they had completely different semantics, and the situation is similar to conflict of functions.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; operator keyword and local keywords associativity, precedence, left, right will be removed.<br>&gt; <br>&gt; Directives with following (informal) syntax will be added:<br>&gt; <br>&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Standard library operator declarations will need to be rewritten. Some of the existing precedence rules will need to be rewritten using #precedence directive.<br>&gt; <br>&gt; More importantly, it needs to be discussed what operator precedence rules do not need to be retained.<br>&gt; <br>&gt; User defined operators will need to be rewritten as well. But precedence will have to be defined by the user. Meanwhile, we can automatically insert parentheses to user code where needed.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave current operator syntax (but change precedence)<br>&gt; <br>&gt; #precedence does not make sense to be defined inside of operator definition, as it describes relationship of two operators. If so, then we are left with the following declaration syntax:<br>&gt; <br>&gt; prefix operator ! { }<br>&gt; infix operator |&gt; { }<br>&gt; infix operator &lt;&gt; { associativity left }<br>&gt; If body of operator can only contain associativity (in some cases), then the existence of body itself makes no sense.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/42f82b9a/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Assuming these are defined in separate modules, how do we determine the<br>order of • and ~?<br></p><p>By default, priority between any two operators is undefined. If two modules<br>don&#39;t know about each other, but the user wishes to prioritize them, then<br>he will write:<br></p><p>#precedence(•, lessThan: ~)<br></p><p>If • suddenly wishes to cooperate with ~, then it will add directives:<br></p><p>#operator(~, fixity: infix, associativity: left)<br>#precedence(•, lessThan: ~)<br></p><p>It doesn&#39;t matter if ~ or user have already added them: if they do not<br>contain contradictory information, there will be no conflict.<br></p><p>&gt; On a related note, I never encounter precedence issues because I always<br>use parenthesis, since I know I’ll just forget the precedence rules so it’d<br>be a mistake for me to rely on them. If we’re adding operators in<br>precedence hierarchies then that only makes it even harder to<br>learn/remember, so I wonder if we might actually be better served by<br>removing precedence entirely?<br></p><p>That&#39;s exactly what I&#39;m trying to do! I propose that there should be no<br>hierarchy. Each pair of operators will have to define priority explicitly,<br>if they need it.<br></p><p>I&#39;ll give an example of what I mean by &quot;removing hierarchy&quot;:<br></p><p>#precedence(+, lessThan: *)<br>#precedence(*, lessThan: ^)<br>2 ^ 3 + 6   # error<br>#precedence(+, lessThan: ^)<br>2 ^ 3 + 6   # now ok<br></p><p>- Anton<br></p><p>2016-04-03 13:31 GMT+03:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br></p><p>&gt; Interesting, I like the idea of changing how precedence is defined, but<br>&gt; I’m curious how under the new scheme we would go about inserting a new<br>&gt; operator unambiguously? For example:<br>&gt;<br>&gt; #precedence(•, lessThan: *)<br>&gt; #precedence(~, lessThan: *)<br>&gt;<br>&gt; Assuming these are defined in separate modules, how do we determine the<br>&gt; order of • and ~?<br>&gt;<br>&gt; On a related note, I never encounter precedence issues because I always<br>&gt; use parenthesis, since I know I’ll just forget the precedence rules so it’d<br>&gt; be a mistake for me to rely on them. If we’re adding operators in<br>&gt; precedence hierarchies then that only makes it even harder to<br>&gt; learn/remember, so I wonder if we might actually be better served by<br>&gt; removing precedence entirely? i.e- the compiler would instead require the<br>&gt; use of parenthesis to eliminate ambiguity like so:<br>&gt;<br>&gt; let a = 5 + 6 // Correct, as there aren’t enough operators for ambiguity<br>&gt; let b = 5 + 6 * 7 + 8 // Incorrect, as it relies on precedence to be<br>&gt; meaningful<br>&gt; let c = (5 + 6) * (7 + 8) // Correct, as parenthesis eliminates<br>&gt; ambiguity/the need for precedence<br>&gt;<br>&gt; This not only eliminates the need to learn, remember and/or lookup<br>&gt; precedence, but it’s clearer and avoids mistakes, and IMO it’s actually<br>&gt; more readable despite the added noise.<br>&gt;<br>&gt; On 3 Apr 2016, at 10:36, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators.<br>&gt; I insist that this time we should focus less on linguistic aspects.<br>&gt;<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Replace syntax of operator definition:<br>&gt;<br>&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt;<br>&gt; With a directive:<br>&gt;<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;<br>&gt; Also replace numeric definition of precedence with separate comparative<br>&gt; precedence definitions:<br>&gt;<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(+, equalTo: -)<br>&gt;<br>&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;<br>&gt; Motivation<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems<br>&gt; with numeric definition of precedence<br>&gt;<br>&gt; In the beginning, operators had nice precedence values: 90, 100, 110, 120,<br>&gt; 130, 140, 150, 160.<br>&gt;<br>&gt; As time went, new and new operators were introduced. Precedence could not<br>&gt; be simply changed, as this would be a breaking change. Ranges got<br>&gt; precedence 135, as got precedence 132. ?? had precedence greater than &lt;,<br>&gt; but less thanas, so it had to be given precedence 131.<br>&gt;<br>&gt; Now it is not possible to insert any custom operator between &lt; and ??. It<br>&gt; is an inevitable consequence of current design: it will be impossible to<br>&gt; insert an operator between two existing ones at some point.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems<br>&gt; with a single precedence hierarchy<br>&gt;<br>&gt; Currently, if an operator wants to define precedence by comparison to one<br>&gt; operator, it must do so for all other operators.<br>&gt;<br>&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error<br>&gt; pattern. a / b as Double is another one. C++ compilers sometimes emit<br>&gt; warnings on these. Swift does not.<br>&gt;<br>&gt; The root of the problem is that precedence is defined between all<br>&gt; operators. If &amp; had precedence defined only by comparison to other<br>&gt; bitwise operators and / – only to arithmetic operators, we would have to<br>&gt; place parentheses in such places, not get subtle bugs, and not ever have to<br>&gt; look at the huge operator precedence table.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems<br>&gt; with current operator definition syntax<br>&gt;<br>&gt; Some argue that current operator syntax is not consistent with other<br>&gt; language constructs. Properties of operators have dictionary semantics and<br>&gt; should be defined as such. It is a rather weak argument right now, but<br>&gt; after reworking of precedence, the new syntax will be more to place. More<br>&gt; reasons are given below.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts<br>&gt; of operator definitions<br>&gt;<br>&gt; Consider two operator definitions in different modules.<br>&gt;<br>&gt; Module A:<br>&gt;<br>&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt;<br>&gt; Module B:<br>&gt;<br>&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change<br>&gt; syntax for operator definition<br>&gt;<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; #operator(!, fixity: postfix)<br>&gt;<br>&gt; First parameter of #operator directive is name of the operator. Then goes<br>&gt; required parameter fixity that can be infix,prefix, or postfix. Then, for<br>&gt; infix operators, goes optional associativity parameter that can be left<br>&gt;  or right.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative<br>&gt; precedence<br>&gt;<br>&gt; Remove precedence property from operator definitions. Instead, introduce<br>&gt; #precedence directive:<br>&gt;<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, equalTo: /)<br>&gt;<br>&gt; Omission of parentheses is allowed only when precedence between the two<br>&gt; operators is defined.<br>&gt;<br>&gt; 1 + 2 * 3  // ok1 + 2 - 3  // error!<br>&gt; #precedence(-, equalTo: +)1 + 2 - 3  // now ok<br>&gt;<br>&gt; Precedence equality can only be defined for operators with same<br>&gt; associativity.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict<br>&gt; resolution<br>&gt;<br>&gt; Precedence rules can be added freely across modules. Ability to omit<br>&gt; parentheses around more operators will not break any code in included<br>&gt; modules. On the other hand, conflicting precedence rules result in an error:<br>&gt;<br>&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt;<br>&gt; Operator definitions do nut cause conflicts, unless they are infix and<br>&gt; one of them has associativity: left, but another one has associativity:<br>&gt; right.<br>&gt;<br>&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt;<br>&gt; So, if two modules define a custom operator with somewhat similar<br>&gt; semantics (at least associativity), they can be used together. Prefix and<br>&gt; postfix operators can never have conflicts in definitions. If they define<br>&gt; different precedence by comparison to same operators, then, most probably,<br>&gt; they had completely different semantics, and the situation is similar to<br>&gt; conflict of functions.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; operator keyword and local keywords associativity, precedence, left, right will<br>&gt; be removed.<br>&gt;<br>&gt; Directives with following (informal) syntax will be added:<br>&gt;<br>&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Standard library operator declarations will need to be rewritten. Some of<br>&gt; the existing precedence rules will need to be rewritten using #precedence<br>&gt;  directive.<br>&gt;<br>&gt; More importantly, it needs to be discussed what operator precedence rules<br>&gt; do *not* need to be retained.<br>&gt;<br>&gt; User defined operators will need to be rewritten as well. But precedence<br>&gt; will have to be defined by the user. Meanwhile, we can automatically insert<br>&gt; parentheses to user code where needed.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave<br>&gt; current operator syntax (but change precedence)<br>&gt;<br>&gt; #precedence does not make sense to be defined inside of operator<br>&gt; definition, as it describes relationship of two operators. If so, then we<br>&gt; are left with the following declaration syntax:<br>&gt;<br>&gt; prefix operator ! { }infix operator |&gt; { }infix operator &lt;&gt; { associativity left }<br>&gt;<br>&gt; If body of operator can only contain associativity (in some cases), then<br>&gt; the existence of body itself makes no sense.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/f5e299ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 3 Apr 2016, at 11:45, Антон Жилин &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; Assuming these are defined in separate modules, how do we determine the order of • and ~?<br>&gt; <br>&gt; By default, priority between any two operators is undefined. If two modules don&#39;t know about each other, but the user wishes to prioritize them, then he will write:<br>&gt; <br>&gt; #precedence(•, lessThan: ~)<br>&gt; <br>&gt; If • suddenly wishes to cooperate with ~, then it will add directives:<br>&gt; <br>&gt; #operator(~, fixity: infix, associativity: left)<br>&gt; #precedence(•, lessThan: ~)<br>&gt; <br>&gt; It doesn&#39;t matter if ~ or user have already added them: if they do not contain contradictory information, there will be no conflict.<br></p><p>Ah, I misunderstood then, so a warning/error will be raised if no precedence exists? Thanks for the explanation! I’ll probably still favour overkill brackets, but this makes sense.<br></p><p>In any event I’m on +1 for the more standardised syntax and the switch to using #directives, makes a lot of sense since these are really just customisable compiler symbols.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/63b5cddb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  3, 2016 at 01:00:00pm</p></header><div class="content"><p>I think this is a great suggestion! One potential problem I can see (if I understood this correctly) is that modules are allowed to set up their own precedence rules for operators defined elsewhere. I think this might lead to some difficult to debug errors if a developer of one module (who is used to certain conventions) then has to work with a different, independent module (where the conventions are different). This is one area where numerical precedence weights seem to be superior as they at least refer to a common subjective coordinate system. <br></p><p>Maybe one should also have visibility for precedence, for instance having precedence module-internal by default?<br></p><p>Best, <br></p><p> — Taras  <br></p><p>&gt; On 03 Apr 2016, at 11:36, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators. I insist that this time we should focus less on linguistic aspects.<br>&gt; <br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Replace syntax of operator definition:<br>&gt; <br>&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt; With a directive:<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; Also replace numeric definition of precedence with separate comparative precedence definitions:<br>&gt; <br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(+, equalTo: -)<br>&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;Motivation<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems with numeric definition of precedence<br>&gt; <br>&gt; In the beginning, operators had nice precedence values: 90, 100, 110, 120, 130, 140, 150, 160.<br>&gt; <br>&gt; As time went, new and new operators were introduced. Precedence could not be simply changed, as this would be a breaking change. Ranges got precedence 135, as got precedence 132. ?? had precedence greater than &lt;, but less thanas, so it had to be given precedence 131.<br>&gt; <br>&gt; Now it is not possible to insert any custom operator between &lt; and ??. It is an inevitable consequence of current design: it will be impossible to insert an operator between two existing ones at some point.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems with a single precedence hierarchy<br>&gt; <br>&gt; Currently, if an operator wants to define precedence by comparison to one operator, it must do so for all other operators.<br>&gt; <br>&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error pattern. a / b as Double is another one. C++ compilers sometimes emit warnings on these. Swift does not.<br>&gt; <br>&gt; The root of the problem is that precedence is defined between all operators. If &amp; had precedence defined only by comparison to other bitwise operators and / – only to arithmetic operators, we would have to place parentheses in such places, not get subtle bugs, and not ever have to look at the huge operator precedence table.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems with current operator definition syntax<br>&gt; <br>&gt; Some argue that current operator syntax is not consistent with other language constructs. Properties of operators have dictionary semantics and should be defined as such. It is a rather weak argument right now, but after reworking of precedence, the new syntax will be more to place. More reasons are given below.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts of operator definitions<br>&gt; <br>&gt; Consider two operator definitions in different modules.<br>&gt; <br>&gt; Module A:<br>&gt; <br>&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt; Module B:<br>&gt; <br>&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change syntax for operator definition<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; #operator(!, fixity: postfix)<br>&gt; First parameter of #operator directive is name of the operator. Then goes required parameter fixity that can be infix,prefix, or postfix. Then, for infix operators, goes optional associativity parameter that can be left or right.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative precedence<br>&gt; <br>&gt; Remove precedence property from operator definitions. Instead, introduce #precedence directive:<br>&gt; <br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, equalTo: /)<br>&gt; Omission of parentheses is allowed only when precedence between the two operators is defined.<br>&gt; <br>&gt; 1 + 2 * 3  // ok<br>&gt; 1 + 2 - 3  // error!<br>&gt; #precedence(-, equalTo: +)<br>&gt; 1 + 2 - 3  // now ok<br>&gt; Precedence equality can only be defined for operators with same associativity.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict resolution<br>&gt; <br>&gt; Precedence rules can be added freely across modules. Ability to omit parentheses around more operators will not break any code in included modules. On the other hand, conflicting precedence rules result in an error:<br>&gt; <br>&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt; Operator definitions do nut cause conflicts, unless they are infix and one of them has associativity: left, but another one has associativity: right.<br>&gt; <br>&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt; So, if two modules define a custom operator with somewhat similar semantics (at least associativity), they can be used together. Prefix and postfix operators can never have conflicts in definitions. If they define different precedence by comparison to same operators, then, most probably, they had completely different semantics, and the situation is similar to conflict of functions.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; operator keyword and local keywords associativity, precedence, left, right will be removed.<br>&gt; <br>&gt; Directives with following (informal) syntax will be added:<br>&gt; <br>&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Standard library operator declarations will need to be rewritten. Some of the existing precedence rules will need to be rewritten using #precedence directive.<br>&gt; <br>&gt; More importantly, it needs to be discussed what operator precedence rules do not need to be retained.<br>&gt; <br>&gt; User defined operators will need to be rewritten as well. But precedence will have to be defined by the user. Meanwhile, we can automatically insert parentheses to user code where needed.<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave current operator syntax (but change precedence)<br>&gt; <br>&gt; #precedence does not make sense to be defined inside of operator definition, as it describes relationship of two operators. If so, then we are left with the following declaration syntax:<br>&gt; <br>&gt; prefix operator ! { }<br>&gt; infix operator |&gt; { }<br>&gt; infix operator &lt;&gt; { associativity left }<br>&gt; If body of operator can only contain associativity (in some cases), then the existence of body itself makes no sense.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/709f7829/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  3, 2016 at 12:00:00pm</p></header><div class="content"><p>There is a problem here of duplicated operators or custom precedence, and<br>how that gets passed between modules.<br>Assume there are three modules, A, B and C. B defines a custom operator **.<br>A and C each define a custom operator ++, and their meanings are different<br>(though, even if their meanings were the same, I&#39;m not sure if they could<br>unify).<br></p><p>Module D uses A and B as dependencies and sets a custom precedence on ++<br>and **. Module E uses B and C and has a different precedence on ++ and **.<br>You&#39;re working on Module F which uses D and E. Which ++ and which<br>precedence does F get implicitly?<br></p><p>I&#39;m wondering whether we can treat operators the way we recently decided to<br>treat selectors: if there is an ambiguity, it should be possible not just<br>to specify which module they came from, but their fixity or argument types.<br>If module D decides that &#39;++&#39; should refer to &#39;traditional postfix number<br>incrementation&#39;, and F decides that it should be an infix &#39;conjoin two<br>numbers as a string and turn the result into a number (e.g. 5 ++ 4 -&gt; 54)&#39;<br>then a #selector-like operator signature would come in really handy.<br></p><p><br>On Sun, Apr 3, 2016 at 12:10 PM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think this is a great suggestion! One potential problem I can see (if I<br>&gt; understood this correctly) is that modules are allowed to set up their own<br>&gt; precedence rules for operators defined elsewhere. I think this might lead<br>&gt; to some difficult to debug errors if a developer of one module (who is used<br>&gt; to certain conventions) then has to work with a different, independent<br>&gt; module (where the conventions are different). This is one area where<br>&gt; numerical precedence weights seem to be superior as they at least refer to<br>&gt; a common subjective coordinate system.<br>&gt;<br>&gt; Maybe one should also have visibility for precedence, for instance having<br>&gt; precedence module-internal by default?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  — Taras<br>&gt;<br>&gt; On 03 Apr 2016, at 11:36, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators.<br>&gt; I insist that this time we should focus less on linguistic aspects.<br>&gt;<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Replace syntax of operator definition:<br>&gt;<br>&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt;<br>&gt; With a directive:<br>&gt;<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;<br>&gt; Also replace numeric definition of precedence with separate comparative<br>&gt; precedence definitions:<br>&gt;<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(+, equalTo: -)<br>&gt;<br>&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;<br>&gt; Motivation<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems<br>&gt; with numeric definition of precedence<br>&gt;<br>&gt; In the beginning, operators had nice precedence values: 90, 100, 110, 120,<br>&gt; 130, 140, 150, 160.<br>&gt;<br>&gt; As time went, new and new operators were introduced. Precedence could not<br>&gt; be simply changed, as this would be a breaking change. Ranges got<br>&gt; precedence 135, as got precedence 132. ?? had precedence greater than &lt;,<br>&gt; but less thanas, so it had to be given precedence 131.<br>&gt;<br>&gt; Now it is not possible to insert any custom operator between &lt; and ??. It<br>&gt; is an inevitable consequence of current design: it will be impossible to<br>&gt; insert an operator between two existing ones at some point.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems<br>&gt; with a single precedence hierarchy<br>&gt;<br>&gt; Currently, if an operator wants to define precedence by comparison to one<br>&gt; operator, it must do so for all other operators.<br>&gt;<br>&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error<br>&gt; pattern. a / b as Double is another one. C++ compilers sometimes emit<br>&gt; warnings on these. Swift does not.<br>&gt;<br>&gt; The root of the problem is that precedence is defined between all<br>&gt; operators. If &amp; had precedence defined only by comparison to other<br>&gt; bitwise operators and / – only to arithmetic operators, we would have to<br>&gt; place parentheses in such places, not get subtle bugs, and not ever have to<br>&gt; look at the huge operator precedence table.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems<br>&gt; with current operator definition syntax<br>&gt;<br>&gt; Some argue that current operator syntax is not consistent with other<br>&gt; language constructs. Properties of operators have dictionary semantics and<br>&gt; should be defined as such. It is a rather weak argument right now, but<br>&gt; after reworking of precedence, the new syntax will be more to place. More<br>&gt; reasons are given below.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts<br>&gt; of operator definitions<br>&gt;<br>&gt; Consider two operator definitions in different modules.<br>&gt;<br>&gt; Module A:<br>&gt;<br>&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt;<br>&gt; Module B:<br>&gt;<br>&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change<br>&gt; syntax for operator definition<br>&gt;<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt; #operator(!, fixity: postfix)<br>&gt;<br>&gt; First parameter of #operator directive is name of the operator. Then goes<br>&gt; required parameter fixity that can be infix,prefix, or postfix. Then, for<br>&gt; infix operators, goes optional associativity parameter that can be left<br>&gt;  or right.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative<br>&gt; precedence<br>&gt;<br>&gt; Remove precedence property from operator definitions. Instead, introduce<br>&gt; #precedence directive:<br>&gt;<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, equalTo: /)<br>&gt;<br>&gt; Omission of parentheses is allowed only when precedence between the two<br>&gt; operators is defined.<br>&gt;<br>&gt; 1 + 2 * 3  // ok1 + 2 - 3  // error!<br>&gt; #precedence(-, equalTo: +)1 + 2 - 3  // now ok<br>&gt;<br>&gt; Precedence equality can only be defined for operators with same<br>&gt; associativity.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict<br>&gt; resolution<br>&gt;<br>&gt; Precedence rules can be added freely across modules. Ability to omit<br>&gt; parentheses around more operators will not break any code in included<br>&gt; modules. On the other hand, conflicting precedence rules result in an error:<br>&gt;<br>&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt;<br>&gt; Operator definitions do nut cause conflicts, unless they are infix and<br>&gt; one of them has associativity: left, but another one has associativity:<br>&gt; right.<br>&gt;<br>&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt;<br>&gt; So, if two modules define a custom operator with somewhat similar<br>&gt; semantics (at least associativity), they can be used together. Prefix and<br>&gt; postfix operators can never have conflicts in definitions. If they define<br>&gt; different precedence by comparison to same operators, then, most probably,<br>&gt; they had completely different semantics, and the situation is similar to<br>&gt; conflict of functions.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; operator keyword and local keywords associativity, precedence, left, right will<br>&gt; be removed.<br>&gt;<br>&gt; Directives with following (informal) syntax will be added:<br>&gt;<br>&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Standard library operator declarations will need to be rewritten. Some of<br>&gt; the existing precedence rules will need to be rewritten using #precedence<br>&gt;  directive.<br>&gt;<br>&gt; More importantly, it needs to be discussed what operator precedence rules<br>&gt; do *not* need to be retained.<br>&gt;<br>&gt; User defined operators will need to be rewritten as well. But precedence<br>&gt; will have to be defined by the user. Meanwhile, we can automatically insert<br>&gt; parentheses to user code where needed.<br>&gt;<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave<br>&gt; current operator syntax (but change precedence)<br>&gt;<br>&gt; #precedence does not make sense to be defined inside of operator<br>&gt; definition, as it describes relationship of two operators. If so, then we<br>&gt; are left with the following declaration syntax:<br>&gt;<br>&gt; prefix operator ! { }infix operator |&gt; { }infix operator &lt;&gt; { associativity left }<br>&gt;<br>&gt; If body of operator can only contain associativity (in some cases), then<br>&gt; the existence of body itself makes no sense.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/5864a16b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>April  3, 2016 at 12:00:00pm</p></header><div class="content"><p>In these case of module operator conflicts perhaps there could be a way we<br>could import these operators ?<br></p><p>Likes a #importOperators(OtherModule) or some kind of build flag.<br></p><p>*___________________________________*<br></p><p>*James⎥Future Prime Minister*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Sun, Apr 3, 2016 at 12:26 PM, Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is a problem here of duplicated operators or custom precedence, and<br>&gt; how that gets passed between modules.<br>&gt; Assume there are three modules, A, B and C. B defines a custom operator<br>&gt; **. A and C each define a custom operator ++, and their meanings are<br>&gt; different (though, even if their meanings were the same, I&#39;m not sure if<br>&gt; they could unify).<br>&gt;<br>&gt; Module D uses A and B as dependencies and sets a custom precedence on ++<br>&gt; and **. Module E uses B and C and has a different precedence on ++ and **.<br>&gt; You&#39;re working on Module F which uses D and E. Which ++ and which<br>&gt; precedence does F get implicitly?<br>&gt;<br>&gt; I&#39;m wondering whether we can treat operators the way we recently decided<br>&gt; to treat selectors: if there is an ambiguity, it should be possible not<br>&gt; just to specify which module they came from, but their fixity or argument<br>&gt; types. If module D decides that &#39;++&#39; should refer to &#39;traditional postfix<br>&gt; number incrementation&#39;, and F decides that it should be an infix &#39;conjoin<br>&gt; two numbers as a string and turn the result into a number (e.g. 5 ++ 4 -&gt;<br>&gt; 54)&#39; then a #selector-like operator signature would come in really handy.<br>&gt;<br>&gt;<br>&gt; On Sun, Apr 3, 2016 at 12:10 PM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think this is a great suggestion! One potential problem I can see (if I<br>&gt;&gt; understood this correctly) is that modules are allowed to set up their own<br>&gt;&gt; precedence rules for operators defined elsewhere. I think this might lead<br>&gt;&gt; to some difficult to debug errors if a developer of one module (who is used<br>&gt;&gt; to certain conventions) then has to work with a different, independent<br>&gt;&gt; module (where the conventions are different). This is one area where<br>&gt;&gt; numerical precedence weights seem to be superior as they at least refer to<br>&gt;&gt; a common subjective coordinate system.<br>&gt;&gt;<br>&gt;&gt; Maybe one should also have visibility for precedence, for instance having<br>&gt;&gt; precedence module-internal by default?<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt;<br>&gt;&gt;  — Taras<br>&gt;&gt;<br>&gt;&gt; On 03 Apr 2016, at 11:36, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift 2.2 is out, and I restart discussion on syntax for custom<br>&gt;&gt; operators. I insist that this time we should focus less on linguistic<br>&gt;&gt; aspects.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Replace syntax of operator definition:<br>&gt;&gt;<br>&gt;&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt;&gt;<br>&gt;&gt; With a directive:<br>&gt;&gt;<br>&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;&gt;<br>&gt;&gt; Also replace numeric definition of precedence with separate comparative<br>&gt;&gt; precedence definitions:<br>&gt;&gt;<br>&gt;&gt; #precedence(+, lessThan: *)<br>&gt;&gt; #precedence(+, equalTo: -)<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-numeric-definition-of-precedence&gt;Problems<br>&gt;&gt; with numeric definition of precedence<br>&gt;&gt;<br>&gt;&gt; In the beginning, operators had nice precedence values: 90, 100, 110,<br>&gt;&gt; 120, 130, 140, 150, 160.<br>&gt;&gt;<br>&gt;&gt; As time went, new and new operators were introduced. Precedence could not<br>&gt;&gt; be simply changed, as this would be a breaking change. Ranges got<br>&gt;&gt; precedence 135, as got precedence 132. ?? had precedence greater than &lt;,<br>&gt;&gt; but less thanas, so it had to be given precedence 131.<br>&gt;&gt;<br>&gt;&gt; Now it is not possible to insert any custom operator between &lt; and ??.<br>&gt;&gt; It is an inevitable consequence of current design: it will be impossible to<br>&gt;&gt; insert an operator between two existing ones at some point.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-a-single-precedence-hierarchy&gt;Problems<br>&gt;&gt; with a single precedence hierarchy<br>&gt;&gt;<br>&gt;&gt; Currently, if an operator wants to define precedence by comparison to one<br>&gt;&gt; operator, it must do so for all other operators.<br>&gt;&gt;<br>&gt;&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error<br>&gt;&gt; pattern. a / b as Double is another one. C++ compilers sometimes emit<br>&gt;&gt; warnings on these. Swift does not.<br>&gt;&gt;<br>&gt;&gt; The root of the problem is that precedence is defined between all<br>&gt;&gt; operators. If &amp; had precedence defined only by comparison to other<br>&gt;&gt; bitwise operators and / – only to arithmetic operators, we would have to<br>&gt;&gt; place parentheses in such places, not get subtle bugs, and not ever have to<br>&gt;&gt; look at the huge operator precedence table.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#problems-with-current-operator-definition-syntax&gt;Problems<br>&gt;&gt; with current operator definition syntax<br>&gt;&gt;<br>&gt;&gt; Some argue that current operator syntax is not consistent with other<br>&gt;&gt; language constructs. Properties of operators have dictionary semantics and<br>&gt;&gt; should be defined as such. It is a rather weak argument right now, but<br>&gt;&gt; after reworking of precedence, the new syntax will be more to place. More<br>&gt;&gt; reasons are given below.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflicts-of-operator-definitions&gt;Conflicts<br>&gt;&gt; of operator definitions<br>&gt;&gt;<br>&gt;&gt; Consider two operator definitions in different modules.<br>&gt;&gt;<br>&gt;&gt; Module A:<br>&gt;&gt;<br>&gt;&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt;&gt;<br>&gt;&gt; Module B:<br>&gt;&gt;<br>&gt;&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#change-syntax-for-operator-definition&gt;Change<br>&gt;&gt; syntax for operator definition<br>&gt;&gt;<br>&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;&gt; #operator(!, fixity: postfix)<br>&gt;&gt;<br>&gt;&gt; First parameter of #operator directive is name of the operator. Then<br>&gt;&gt; goes required parameter fixity that can be infix,prefix, or postfix.<br>&gt;&gt; Then, for infix operators, goes optional associativity parameter that<br>&gt;&gt; can be left or right.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#comparative-precedence&gt;Comparative<br>&gt;&gt; precedence<br>&gt;&gt;<br>&gt;&gt; Remove precedence property from operator definitions. Instead, introduce<br>&gt;&gt; #precedence directive:<br>&gt;&gt;<br>&gt;&gt; #precedence(+, lessThan: *)<br>&gt;&gt; #precedence(*, equalTo: /)<br>&gt;&gt;<br>&gt;&gt; Omission of parentheses is allowed only when precedence between the two<br>&gt;&gt; operators is defined.<br>&gt;&gt;<br>&gt;&gt; 1 + 2 * 3  // ok1 + 2 - 3  // error!<br>&gt;&gt; #precedence(-, equalTo: +)1 + 2 - 3  // now ok<br>&gt;&gt;<br>&gt;&gt; Precedence equality can only be defined for operators with same<br>&gt;&gt; associativity.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#conflict-resolution&gt;Conflict<br>&gt;&gt; resolution<br>&gt;&gt;<br>&gt;&gt; Precedence rules can be added freely across modules. Ability to omit<br>&gt;&gt; parentheses around more operators will not break any code in included<br>&gt;&gt; modules. On the other hand, conflicting precedence rules result in an error:<br>&gt;&gt;<br>&gt;&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt;&gt;<br>&gt;&gt; Operator definitions do nut cause conflicts, unless they are infix and<br>&gt;&gt; one of them has associativity: left, but another one has associativity:<br>&gt;&gt; right.<br>&gt;&gt;<br>&gt;&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt;&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt;&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt;&gt;<br>&gt;&gt; So, if two modules define a custom operator with somewhat similar<br>&gt;&gt; semantics (at least associativity), they can be used together. Prefix and<br>&gt;&gt; postfix operators can never have conflicts in definitions. If they define<br>&gt;&gt; different precedence by comparison to same operators, then, most probably,<br>&gt;&gt; they had completely different semantics, and the situation is similar to<br>&gt;&gt; conflict of functions.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; operator keyword and local keywords associativity, precedence, left,<br>&gt;&gt; right will be removed.<br>&gt;&gt;<br>&gt;&gt; Directives with following (informal) syntax will be added:<br>&gt;&gt;<br>&gt;&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt;&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt;&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt;&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Standard library operator declarations will need to be rewritten. Some of<br>&gt;&gt; the existing precedence rules will need to be rewritten using #precedence<br>&gt;&gt;  directive.<br>&gt;&gt;<br>&gt;&gt; More importantly, it needs to be discussed what operator precedence rules<br>&gt;&gt; do *not* need to be retained.<br>&gt;&gt;<br>&gt;&gt; User defined operators will need to be rewritten as well. But precedence<br>&gt;&gt; will have to be defined by the user. Meanwhile, we can automatically insert<br>&gt;&gt; parentheses to user code where needed.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#leave-current-operator-syntax-but-change-precedence&gt;Leave<br>&gt;&gt; current operator syntax (but change precedence)<br>&gt;&gt;<br>&gt;&gt; #precedence does not make sense to be defined inside of operator<br>&gt;&gt; definition, as it describes relationship of two operators. If so, then we<br>&gt;&gt; are left with the following declaration syntax:<br>&gt;&gt;<br>&gt;&gt; prefix operator ! { }infix operator |&gt; { }infix operator &lt;&gt; { associativity left }<br>&gt;&gt;<br>&gt;&gt; If body of operator can only contain associativity (in some cases), then<br>&gt;&gt; the existence of body itself makes no sense.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/ac82c863/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Right, the proposal in its current form does not really aim to resolve such<br>conflicts, although it makes them occur less often by &quot;merging&quot; precedence<br>and associativity when possible.<br></p><p>At first, I also tried to resolve such conflicts by naming operators. But I<br>found that compiler instructions will be too complex in some cases:<br></p><p>#operator(+, name: numericAdd, fixity: infix, associativity: left)<br>#operator(+, name: arrayAppend, fixity: infix, associativity: right)<br></p><p>func numericAdd(left: A, right: B) -&gt; C<br>func numericAdd(left: B, right: C) -&gt; B<br>func arrayAppend(left: A, right: A) -&gt; B<br>func arrayAppend(left: B, right: C) -&gt; A<br></p><p>A() + B() + C()<br></p><p>Compiler will have to find by brute-force that this expression can only<br>represent arrayAppend(A(), arrayAppend(B(), C())), and others result in<br>errors. To me, this scheme seems pretty absurd.<br></p><p>That said, it might be a good idea to add visibility for operators.<br>Hiding already imported operators, on the other hand, would be inconsistent<br>with othr elements of the language. It is currently impossible to hide<br>contents of module A from C where C imports B and B imports A. Not that I&#39;m<br>against such a feature in general.<br></p><p>- Anton<br></p><p><br>2016-04-03 14:26 GMT+03:00 Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;:<br></p><p>&gt; There is a problem here of duplicated operators or custom precedence, and<br>&gt; how that gets passed between modules.<br>&gt; Assume there are three modules, A, B and C. B defines a custom operator<br>&gt; **. A and C each define a custom operator ++, and their meanings are<br>&gt; different (though, even if their meanings were the same, I&#39;m not sure if<br>&gt; they could unify).<br>&gt;<br>&gt; Module D uses A and B as dependencies and sets a custom precedence on ++<br>&gt; and **. Module E uses B and C and has a different precedence on ++ and **.<br>&gt; You&#39;re working on Module F which uses D and E. Which ++ and which<br>&gt; precedence does F get implicitly?<br>&gt;<br>&gt; I&#39;m wondering whether we can treat operators the way we recently decided<br>&gt; to treat selectors: if there is an ambiguity, it should be possible not<br>&gt; just to specify which module they came from, but their fixity or argument<br>&gt; types. If module D decides that &#39;++&#39; should refer to &#39;traditional postfix<br>&gt; number incrementation&#39;, and F decides that it should be an infix &#39;conjoin<br>&gt; two numbers as a string and turn the result into a number (e.g. 5 ++ 4 -&gt;<br>&gt; 54)&#39; then a #selector-like operator signature would come in really handy.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/7967b46e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April  4, 2016 at 07:00:00am</p></header><div class="content"><p>See inline<br></p><p>&gt; Am 03.04.2016 um 13:26 schrieb Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; There is a problem here of duplicated operators or custom precedence, and how that gets passed between modules.<br>&gt; Assume there are three modules, A, B and C. B defines a custom operator **. A and C each define a custom operator ++, and their meanings are different (though, even if their meanings were the same, I&#39;m not sure if they could unify).<br>&gt; <br>&gt; Module D uses A and B as dependencies and sets a custom precedence on ++ and **. Module E uses B and C and has a different precedence on ++ and **. You&#39;re working on Module F which uses D and E. Which ++ and which precedence does F get implicitly?<br>&gt; <br></p><p>We could allow operator precedence overriding to resolve ambiguity. However this overriding should only be module internal since it would override the existing precedences in the other modules.<br></p><p>@AHTOH<br>Why do you use #keyword ?<br>I think defining a operator with<br></p><p>    infix operator + {<br>         associativity: left<br>    }<br></p><p>is perfectly fine since it is similar to class/struct/enum declaration.<br></p><p>    // and it&#39;s precedence<br>    precedence(+ lessThan *)<br></p><p>Note the missing &quot;,&quot; and &quot;:&quot; before and after &quot;lessThan&quot; in order to give both operators the same importance (minor issue).<br></p><p>I feel that<br></p><p>    #precedence(+, lessThan: *)<br></p><p>puts too much importance on the first operator.<br></p><p>Best regards<br>- Maximilian<br></p><p>&gt; I&#39;m wondering whether we can treat operators the way we recently decided to treat selectors: if there is an ambiguity, it should be possible not just to specify which module they came from, but their fixity or argument types. If module D decides that &#39;++&#39; should refer to &#39;traditional postfix number incrementation&#39;, and F decides that it should be an infix &#39;conjoin two numbers as a string and turn the result into a number (e.g. 5 ++ 4 -&gt; 54)&#39; then a #selector-like operator signature would come in really handy.<br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Apr 3, 2016 at 12:10 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think this is a great suggestion! One potential problem I can see (if I understood this correctly) is that modules are allowed to set up their own precedence rules for operators defined elsewhere. I think this might lead to some difficult to debug errors if a developer of one module (who is used to certain conventions) then has to work with a different, independent module (where the conventions are different). This is one area where numerical precedence weights seem to be superior as they at least refer to a common subjective coordinate system. <br>&gt;&gt; <br>&gt;&gt; Maybe one should also have visibility for precedence, for instance having precedence module-internal by default?<br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; <br>&gt;&gt;  — Taras  <br>&gt;&gt; <br>&gt;&gt;&gt; On 03 Apr 2016, at 11:36, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators. I insist that this time we should focus less on linguistic aspects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replace syntax of operator definition:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator &lt;&gt; { precedence 100 associativity left }<br>&gt;&gt;&gt; With a directive:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;&gt;&gt; Also replace numeric definition of precedence with separate comparative precedence definitions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #precedence(+, lessThan: *)<br>&gt;&gt;&gt; #precedence(+, equalTo: -)<br>&gt;&gt;&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problems with numeric definition of precedence<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the beginning, operators had nice precedence values: 90, 100, 110, 120, 130, 140, 150, 160.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As time went, new and new operators were introduced. Precedence could not be simply changed, as this would be a breaking change. Ranges got precedence 135, as got precedence 132. ?? had precedence greater than &lt;, but less thanas, so it had to be given precedence 131.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now it is not possible to insert any custom operator between &lt; and ??. It is an inevitable consequence of current design: it will be impossible to insert an operator between two existing ones at some point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problems with a single precedence hierarchy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, if an operator wants to define precedence by comparison to one operator, it must do so for all other operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many cases, this is not wished. Example: a &amp; b &lt; c is a common error pattern. a / b as Double is another one. C++ compilers sometimes emit warnings on these. Swift does not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The root of the problem is that precedence is defined between all operators. If &amp; had precedence defined only by comparison to other bitwise operators and / – only to arithmetic operators, we would have to place parentheses in such places, not get subtle bugs, and not ever have to look at the huge operator precedence table.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problems with current operator definition syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some argue that current operator syntax is not consistent with other language constructs. Properties of operators have dictionary semantics and should be defined as such. It is a rather weak argument right now, but after reworking of precedence, the new syntax will be more to place. More reasons are given below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conflicts of operator definitions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider two operator definitions in different modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Module A:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator |&gt; { precedence 137 associativity left }<br>&gt;&gt;&gt; Module B:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator |&gt; { precedence 138 associativity left }<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Change syntax for operator definition<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)<br>&gt;&gt;&gt; #operator(!, fixity: postfix)<br>&gt;&gt;&gt; First parameter of #operator directive is name of the operator. Then goes required parameter fixity that can be infix,prefix, or postfix. Then, for infix operators, goes optional associativity parameter that can be left or right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comparative precedence<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remove precedence property from operator definitions. Instead, introduce #precedence directive:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #precedence(+, lessThan: *)<br>&gt;&gt;&gt; #precedence(*, equalTo: /)<br>&gt;&gt;&gt; Omission of parentheses is allowed only when precedence between the two operators is defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1 + 2 * 3  // ok<br>&gt;&gt;&gt; 1 + 2 - 3  // error!<br>&gt;&gt;&gt; #precedence(-, equalTo: +)<br>&gt;&gt;&gt; 1 + 2 - 3  // now ok<br>&gt;&gt;&gt; Precedence equality can only be defined for operators with same associativity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conflict resolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Precedence rules can be added freely across modules. Ability to omit parentheses around more operators will not break any code in included modules. On the other hand, conflicting precedence rules result in an error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #precedence(*, lessThan: +)  // error, previously defined `+` &lt; `*`<br>&gt;&gt;&gt; Operator definitions do nut cause conflicts, unless they are infix and one of them has associativity: left, but another one has associativity: right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #operator(!, fixity: prefix)  // ok, duplicated definitions<br>&gt;&gt;&gt; #operator(&lt;&gt;, fixity: infix)<br>&gt;&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left)  // ok, now left associative<br>&gt;&gt;&gt; #operator(+, fixity: infix, associativity: right)  // error: associativity conflict<br>&gt;&gt;&gt; So, if two modules define a custom operator with somewhat similar semantics (at least associativity), they can be used together. Prefix and postfix operators can never have conflicts in definitions. If they define different precedence by comparison to same operators, then, most probably, they had completely different semantics, and the situation is similar to conflict of functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; operator keyword and local keywords associativity, precedence, left, right will be removed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Directives with following (informal) syntax will be added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #operator(OPERATOR_NAME, fixity: FIXITY)<br>&gt;&gt;&gt; #operator(OPERATOR_NAME, fixity: infix, associativity: ASSOCIATIVITY)<br>&gt;&gt;&gt; #precedence(OPERATOR_NAME, lessThan: OPERATOR_NAME)<br>&gt;&gt;&gt; #precedence(OPERATOR_NAME, equalTo: OPERATOR_NAME)<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Standard library operator declarations will need to be rewritten. Some of the existing precedence rules will need to be rewritten using #precedence directive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More importantly, it needs to be discussed what operator precedence rules do not need to be retained.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; User defined operators will need to be rewritten as well. But precedence will have to be defined by the user. Meanwhile, we can automatically insert parentheses to user code where needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Leave current operator syntax (but change precedence)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #precedence does not make sense to be defined inside of operator definition, as it describes relationship of two operators. If so, then we are left with the following declaration syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; prefix operator ! { }<br>&gt;&gt;&gt; infix operator |&gt; { }<br>&gt;&gt;&gt; infix operator &lt;&gt; { associativity left }<br>&gt;&gt;&gt; If body of operator can only contain associativity (in some cases), then the existence of body itself makes no sense.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/f55eb392/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  4, 2016 at 09:00:00am</p></header><div class="content"><p>Thank you for a helpful answer!<br>I like the idea of overriding precedence from another module. We won&#39;t need<br>to introduce additional keywords or visibility for operators. I will add it<br>to the proposal.<br></p><p>I assume you mean precedence inside braces of operator, then operator scope<br>makes sense. Self operator could be omit as well, following the idea that<br>we are introducing a new operator and want to compare it to others:<br></p><p>infix operator * {<br>    associativity: left<br>    precedenceLess: ^<br>    precedenceEqual: /<br>    precedenceGreater: +<br>}<br>infix operator / {<br>    associativity: left<br>    precedenceLess: ^<br>    precedenceEqual: *<br>    precedenceGreater: +<br>}<br></p><p>Equivalent precedence rules would be allowed for symmetry in the operator<br>definitions.<br>We would still be able to reopen the scope and add precedence and<br>associativity rules.<br>I agree that this scheme has advantage of being a smaller change.<br></p><p>I&#39;m still concerned about syntax.<br>Is it OK to have &quot;less, equal, greater&quot; in precedence name?<br>Is it OK to have both curly brackets and dictionary syntax (a precedent, I<br>guess)?<br>Is it OK to leave prefix and postfix operators always with empty braces?<br></p><p>Would it be better to have multiple precedence comparisons at once:<br>precedenceGreater: +, -, *, /<br>Or one comparison per line will be more readable?<br></p><p>I will add this to alternatives, but will not swap it with currently stated<br>syntax for now, waiting for some more response.<br></p><p>What do you think?<br></p><p>- Anton<br></p><p>2016-04-04 8:06 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br></p><p>&gt; See inline<br>&gt;<br>&gt; Am 03.04.2016 um 13:26 schrieb Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; There is a problem here of duplicated operators or custom precedence, and<br>&gt; how that gets passed between modules.<br>&gt; Assume there are three modules, A, B and C. B defines a custom operator<br>&gt; **. A and C each define a custom operator ++, and their meanings are<br>&gt; different (though, even if their meanings were the same, I&#39;m not sure if<br>&gt; they could unify).<br>&gt;<br>&gt; Module D uses A and B as dependencies and sets a custom precedence on ++<br>&gt; and **. Module E uses B and C and has a different precedence on ++ and **.<br>&gt; You&#39;re working on Module F which uses D and E. Which ++ and which<br>&gt; precedence does F get implicitly?<br>&gt;<br>&gt;<br>&gt; We could allow operator precedence overriding to resolve ambiguity.<br>&gt; However this overriding should only be module internal since it would<br>&gt; override the existing precedences in the other modules.<br>&gt;<br>&gt; @AHTOH<br>&gt; Why do you use #keyword ?<br>&gt; I think defining a operator with<br>&gt;<br>&gt;     infix operator + {<br>&gt;          associativity: left<br>&gt;     }<br>&gt;<br>&gt; is perfectly fine since it is similar to class/struct/enum declaration.<br>&gt;<br>&gt;     // and it&#39;s precedence<br>&gt;     precedence(+ lessThan *)<br>&gt;<br>&gt; Note the missing &quot;,&quot; and &quot;:&quot; before and after &quot;lessThan&quot; in order to give<br>&gt; both operators the same importance (minor issue).<br>&gt;<br>&gt; I feel that<br>&gt;<br>&gt;     #precedence(+, lessThan: *)<br>&gt;<br>&gt; puts too much importance on the first operator.<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/903b5cdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April  4, 2016 at 11:00:00pm</p></header><div class="content"><p>Inline<br></p><p>&gt; Am 04.04.2016 um 08:06 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; <br>&gt; Thank you for a helpful answer!<br>&gt; I like the idea of overriding precedence from another module. We won&#39;t need to introduce additional keywords or visibility for operators. I will add it to the proposal.<br>&gt; <br>&gt; I assume you mean precedence inside braces of operator, then operator scope makes sense. Self operator could be omit as well, following the idea that we are introducing a new operator and want to compare it to others:<br>&gt; <br>&gt; infix operator * {<br>&gt;     associativity: left<br>&gt;     precedenceLess: ^<br>&gt;     precedenceEqual: /<br>&gt;     precedenceGreater: +<br>&gt; }<br>&gt; infix operator / {<br>&gt;     associativity: left<br>&gt;     precedenceLess: ^<br>&gt;     precedenceEqual: *<br>&gt;     precedenceGreater: +<br>&gt; }<br>&gt; <br>&gt; Equivalent precedence rules would be allowed for symmetry in the operator definitions.<br>&gt; We would still be able to reopen the scope and add precedence and associativity rules.<br>&gt; I agree that this scheme has advantage of being a smaller change.<br>&gt; <br>&gt; I&#39;m still concerned about syntax.<br>&gt; Is it OK to have &quot;less, equal, greater&quot; in precedence name?<br></p><p>What do you mean by OK? Other operators like == are weird:<br></p><p>precedence(== == &lt;)<br>// in comparison to<br>precedence(== equalTo &lt;)<br></p><p>&gt; Is it OK to have both curly brackets and dictionary syntax (a precedent, I guess)?<br></p><p>That could be a consistency problem. However I&#39;d like to keep a declaration syntax instead of defining operators through compiler directives.<br></p><p>&gt; Is it OK to leave prefix and postfix operators always with empty braces?<br>&gt; <br></p><p>I&#39;m fine with that.<br></p><p>&gt; Would it be better to have multiple precedence comparisons at once:<br>&gt; precedenceGreater: +, -, *, /<br>&gt; Or one comparison per line will be more readable?<br>&gt; <br>&gt; I will add this to alternatives, but will not swap it with currently stated syntax for now, waiting for some more response.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; - Anton<br></p><p>After thinking more about it I came to the conclusion that we should have something like &quot;precedence groups&quot; where all operators have the same precedence:<br></p><p>precedenceGroup Additive {<br>    +, -<br>}<br></p><p>precedenceGroup Multiplicative {<br>    *, /<br>}<br></p><p>// first we could allow an operator to be only<br>// in one p.Group. Later when we can infer<br>// precedences we can allow operators to be<br>// in more than one p.Group (if that is even necessary)<br></p><p><br>// precedence declaration<br>precedence(Additive lessThan Multiplicative)<br></p><p>// precedence declarations take<br>// &quot;precedenceGroup&quot;s and &quot;operator&quot;s.<br></p><p><br>// It could also work with extensions so you<br>// can easily insert it in the precedence hierarchy:<br></p><p>infix operator +- {<br>    associativity: left<br>}<br></p><p>// more operator declarations ...<br></p><p>extension Additive {<br>    +-, -+, ++, --<br>}<br></p><p>// the syntax I used is highly discussable.<br>// this should mainly be a concept suggestion.<br>// I think it allows for greater flexibility since you can define<br>// operator precedences much easier.<br></p><p>With kind regards<br>- Maximilian<br>&gt; <br>&gt; 2016-04-04 8:06 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br>&gt;&gt; See inline<br>&gt;&gt; <br>&gt;&gt;&gt; Am 03.04.2016 um 13:26 schrieb Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a problem here of duplicated operators or custom precedence, and how that gets passed between modules.<br>&gt;&gt;&gt; Assume there are three modules, A, B and C. B defines a custom operator **. A and C each define a custom operator ++, and their meanings are different (though, even if their meanings were the same, I&#39;m not sure if they could unify).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Module D uses A and B as dependencies and sets a custom precedence on ++ and **. Module E uses B and C and has a different precedence on ++ and **. You&#39;re working on Module F which uses D and E. Which ++ and which precedence does F get implicitly?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We could allow operator precedence overriding to resolve ambiguity. However this overriding should only be module internal since it would override the existing precedences in the other modules.<br>&gt;&gt; <br>&gt;&gt; @AHTOH<br>&gt;&gt; Why do you use #keyword ?<br>&gt;&gt; I think defining a operator with<br>&gt;&gt; <br>&gt;&gt;     infix operator + {<br>&gt;&gt;          associativity: left<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; is perfectly fine since it is similar to class/struct/enum declaration.<br>&gt;&gt; <br>&gt;&gt;     // and it&#39;s precedence<br>&gt;&gt;     precedence(+ lessThan *)<br>&gt;&gt; <br>&gt;&gt; Note the missing &quot;,&quot; and &quot;:&quot; before and after &quot;lessThan&quot; in order to give both operators the same importance (minor issue).<br>&gt;&gt; <br>&gt;&gt; I feel that<br>&gt;&gt; <br>&gt;&gt;     #precedence(+, lessThan: *)<br>&gt;&gt; <br>&gt;&gt; puts too much importance on the first operator.<br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; - Maximilian<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/8df2308c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  5, 2016 at 12:00:00am</p></header><div class="content"><p>Sorry for breaking the thread, next time please mail me a copy :)<br>Link to the proposal:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br></p><p>1.  I strongly agree that the numeric precedence system is not great. From<br>&gt;     a implementation point of view, the way to specify them in your<br>&gt; proposal<br>&gt;     essentially gave all visible operators a partial order, in which we can<br>&gt;     draw a directed gragh with operators being the nodes and their relation<br>&gt;     being arcs. A part of the graph might look like: &#39;^&#39; --&gt; &#39;*&#39; --&gt; &#39;+&#39;,<br>&gt; the<br>&gt;     nodes being the math operators. We can tell &#39;*&#39; has a higher precedence<br>&gt;     than &#39;+&#39;, &#39;^&#39; has a higher precedence than &#39;*&#39; and &#39;+&#39;, by follwing the<br>&gt;     arcs. If one operator is not reachable from another, and vice versa,<br>&gt; then<br>&gt;     composing these two is illegal. We need to teach the compiler this<br>&gt; concept.<br>&gt;<br></p><p>Right, that semantics was actually the main driver of the proposal.<br></p><p>2.  Currently, it&#39;s not possible to specify precedence for pre- and postfix<br>&gt;     operators. Chris Lattner has mentioned that the<br>&gt;     following result is not desirable:<br>&gt;         ∆x + y<br>&gt;     … where ∆ has a lower precendence than + while it&#39;s required to have no<br>&gt;     space between ∆ and the operand. My understanding is that if spaces<br>&gt; were<br>&gt;     to be allowed here, parsing such expression without ambiguity is a<br>&gt;     non-trivial challenge. So, will it be possible to specify precedence<br>&gt; for<br>&gt;     pre/postfix operators under your proposal?<br>&gt;<br></p><p>No, I currently leave prefix and postfix operators unchanged (apart from<br>syntax shuffling). I will add this as a future direction.<br>Prefix and postfix operators would behave the same as infix, but have<br>higher precedence than any infix operator by default.<br>This feature, if added, would be non-breaking.<br></p><p><br>&gt; 3.  It may be a good exercise to work out how would each of the builtin<br>&gt;     operators would be defined with this change and mention it (not the<br>&gt; entire<br>&gt;     definition, but the fact that it&#39;s possible, or reasons why it produces<br>&gt;     any difference) in the proposal.<br></p><p><br>Operators `is`, `as`, `as?`, `as!`, which are not actually Swift custom<br>operators (they contain letters), will not participate in this exercise.<br>(Let&#39;s not discuss allowing letters in operators here.)<br>That being said, great idea. I will add example declarations of standard<br>library operators.<br></p><p> - Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/0a9b944d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  5, 2016 at 02:00:00am</p></header><div class="content"><p>Apr 5, 2016, Maximilian Hünenberger wrote:<br></p><p>&gt;<br>&gt; Am 04.04.2016 um 08:06 schrieb Антон Жилин &lt;antonyzhilin at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;antonyzhilin at gmail.com&#39;);&gt;&gt;:<br>&gt;<br>&gt; Is it OK to have &quot;less, equal, greater&quot; in precedence name?<br>&gt;<br>&gt; What do you mean by OK? Other operators like == are weird:<br>&gt;<br>&gt; precedence(== == &lt;)<br>&gt; // in comparison to<br>&gt; precedence(== equalTo &lt;)<br>&gt;<br></p><p>I meant, are names `precedenceLessThan`, `precedenceEqualTo` a bit clunky?<br>Maybe:<br></p><p>associativity(left)<br>precedence(lessThan: +)<br>precedence(equalTo: +)<br></p><p>It also solves my concern about dictionary inside braces.<br></p><p>After thinking more about it I came to the conclusion that we should have<br>&gt; something like &quot;precedence groups&quot; where all operators have the same<br>&gt; precedence:<br>&gt;<br>&gt; precedenceGroup Additive {<br>&gt;     +, -<br>&gt; }<br>&gt;<br>&gt; precedenceGroup Multiplicative {<br>&gt;     *, /<br>&gt; }<br>&gt;<br>&gt; precedence(Additive lessThan Multiplicative)<br>&gt;<br>&gt; infix operator +- {<br>&gt;     associativity: left<br>&gt; }<br>&gt;<br>&gt; extension Additive {<br>&gt;     +-, -+, ++, --<br>&gt; }<br>&gt;<br></p><p>Precedence groups have a great benefit of additional symmetry. Transitive<br>precedence propagation, on the other hand, also has benefits:<br></p><p>1. It does not introduce new entities, just some rules for compiler<br>2. It does not add new keywords. In your current wording, we have to take<br>precedence and precedenceGroup as keywords, that&#39;s why I<br>originally preferred directives<br>3. We actually think in terms of operators, not groups.<br>If I want to say that my operator should have the same priority as `+`, I&#39;d<br>rather say that I want it to have priority of plus and minus, not &quot;belong<br>to multiplicative group&quot;.<br>If I declare &lt;$&gt; and want it to have same priority as &lt;*&gt;, it would be more<br>difficult to invent some name for their group like FunctorManipulator.<br></p><p>On the other hand, in your solution you have a list of global rules<br>and don&#39;t really need braces. How about this?<br></p><p>#precedenceGroup(Additive)<br>#precedenceGroup(Multiplicative)<br>#precedence(Additive, less, Multiplicative)<br>#operator(+, infix, associativity: left, group: Additive)<br>#operator(*, infix, associativity: left, group: Multiplicative)<br>#operator(&lt;&gt;, infix)<br></p><p>So precedence group is just a tag that can be used in precedence rules and<br>assigned to operators at declaration.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/374ca585/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>David Waite stated a major drawback of precedence groups.<br></p><p>People will often create tiny precedence groups for their modules, and user<br>will find that some of them should actually be the same. They will add<br>precedenceEqualTo, but all these equivalent groups will still exist. This<br>problem cannot occur with transitive precedence propagation. So precedence<br>groups really create more problems than solve.<br></p><p>- Anton<br></p><p>Apr 5, 2016, Антон Жилин wrote:<br>&gt;<br>&gt; On the other hand, in your solution you have a list of global rules<br>&gt; and don&#39;t really need braces. How about this?<br></p><p><br>&gt; #precedenceGroup(Additive)<br>&gt; #precedenceGroup(Multiplicative)<br>&gt; #precedence(Additive, less, Multiplicative)<br>&gt; #operator(+, infix, associativity: left, group: Additive)<br>&gt; #operator(*, infix, associativity: left, group: Multiplicative)<br>&gt; #operator(&lt;&gt;, infix)<br>&gt;<br>&gt; So precedence group is just a tag that can be used in precedence rules and<br>&gt; assigned to operators at declaration.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/afa406e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 05.04.2016 um 17:29 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; <br>&gt; David Waite stated a major drawback of precedence groups.<br>&gt; <br>&gt; People will often create tiny precedence groups for their modules, and user will find that some of them should actually be the same. They will add precedenceEqualTo, but all these equivalent groups will still exist. This problem cannot occur with transitive precedence propagation. So precedence groups really create more problems than solve.<br>&gt; <br>&gt; - Anton<br></p><p>Do you mean these drawbacks?<br></p><p>&quot;<br>&gt; However, this may create more issues than it solves (two frameworks creating their own custom operators, putting them in custom precedence groups, and the consumer decides the two precedence groups are really equivalent)<br>&gt; <br>&gt; -DW<br>&quot;<br></p><p>What is the problem? Changing the relative precedence of external operators in your file? Doesn&#39;t the same &quot;problem&quot; occur in your proposal (only with one operator)?<br></p><p>What is the difference between overriding an operator function like this:<br></p><p>func + (l: Int, r: Int) -&gt; Int {<br>       return 0<br>}<br></p><p>This can also mess up your code...<br>I&#39;m sorry if I haven&#39;t understood your point.<br></p><p>From the other email:<br></p><p>&gt; I meant, are names `precedenceLessThan`, `precedenceEqualTo` a bit clunky? Maybe:<br>&gt; <br>&gt; associativity(left)<br>&gt; precedence(lessThan: +)<br>&gt; precedence(equalTo: +)<br>&gt; <br>&gt; It also solves my concern about dictionary inside braces.<br></p><p>I prefer &quot;precedence(+ lessThan *)&quot;. However I don&#39;t think it&#39;s Swift style since &quot;lessThan&quot; is like an infix operator with letters although the symmetry between &quot;+&quot; and &quot;*&quot; would be nicely handled by such operator.<br></p><p>&gt; Precedence groups have a great benefit of additional symmetry. Transitive precedence propagation, on the other hand, also has benefits:<br>&gt; <br>&gt; 1. It does not introduce new entities, just some rules for compiler<br>&gt; 2. It does not add new keywords. In your current wording, we have to take precedence and precedenceGroup as keywords, that&#39;s why I originally preferred directives<br></p><p>Both 1 and 2 are true but I still prefer to use declarations since they provide exactly one location where to put operators with equal precedence.<br></p><p>By the way &quot;precedence&quot; is already a keyword... One more to go :)<br></p><p>&gt; 3. We actually think in terms of operators, not groups.<br>&gt; If I want to say that my operator should have the same priority as `+`, I&#39;d rather say that I want it to have priority of plus and minus, not &quot;belong to multiplicative group&quot;.<br>&gt; If I declare &lt;$&gt; and want it to have same priority as &lt;*&gt;, it would be more difficult to invent some name for their group like FunctorManipulator.<br>&gt; <br></p><p>I think this deserves more discussion:<br>Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have precedence groups?<br></p><p>Such a precedence declaration would be contrary to my argument above: declare equal operator precedences in one place, which is more maintainable.<br></p><p>&gt; On the other hand, in your solution you have a list of global rules and don&#39;t really need braces. How about this?<br>&gt; <br>&gt; #precedenceGroup(Additive)<br>&gt; #precedenceGroup(Multiplicative)<br>&gt; #precedence(Additive, less, Multiplicative)<br>&gt; #operator(+, infix, associativity: left, group: Additive)<br>&gt; #operator(*, infix, associativity: left, group: Multiplicative)<br>&gt; #operator(&lt;&gt;, infix)<br>&gt; <br>&gt; So precedence group is just a tag that can be used in precedence rules and assigned to operators at declaration.<br></p><p>Although it is consistent with your proposal for me it is too much repetition and &quot;code noise&quot;. Compare:<br></p><p>infix operator + { associativity: left }<br>infix operator * { associativity: left }<br>infix operator &lt;&gt; {}<br>precedenceGroup Additive { + }<br>precedenceGroup Multiplicative { * }<br>precedence(Additive lessThan Multiplicative)<br></p><p>Which is in my opinion way more readable even without syntax highlighting.<br></p><p><br>Thank You for sharing Your thoughts which have enriched me! :)<br></p><p>Best regards<br>- Maximilian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/03e08c53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  5, 2016 at 11:00:00pm</p></header><div class="content"><p>Added<br>&lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#use-precedence-groups&gt;<br>group version, &quot;lessThan&quot; problem can be solved nicely. `&lt;`, `=`, `&gt;` signs<br>would be allowed there.<br></p><p>&gt; Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have<br>precedence groups?<br>I think no.<br></p><p>I have a question to your group syntax.<br>Since all operators in a precedence group must have equal associativity for<br>parsing to work and look logically (right?), wouldn&#39;t it be better to<br>declare associativity in groups?<br>If so, then body of operator declaration won&#39;t contain anything, and we can<br>remove it:<br></p><p>precedenceGroup Additive {<br>    associativity(left)<br>    +, -<br>}<br>infix operator +<br>infix operator -<br></p><p>Does this body of precedenceGroup look OK from syntactic PoV?<br></p><p>Now, I have another idea.<br>As operator declarations themselves don&#39;t contain anything anymore, remove<br>operator declarations at all. We don&#39;t need to pre-declare function names,<br>for example.<br>Next, `precedenceGroup` could be as well replaced with `precedenceLevel`,<br>or just `precedence`, and I would not worry about additional keywords.<br>So, our example would look like this:<br></p><p>precedence Additive {<br>    associativity(left)<br>    +, -<br>}<br>precedence Multiplicative {<br>    associativity(left)<br>    *, /<br>}<br>precedence(Additive &lt; Multiplicative)<br></p><p>As a future direction, we could add extensions to precedence levels.<br>We could go further and replace `precedence` with `operator`, abandoning<br>the idea of priority for prefix and postfix operators (that I honestly<br>don&#39;t like).<br></p><p>infix operator Additive {<br>    members(+, -)<br>    associativity(left)<br>}<br>infix operator Multiplicative {<br>    members(*, /)<br>    associativity(left)<br>    precedence(&gt; Additive)<br>}<br></p><p>Some other questions:<br>Do we need transitive precedence propagation?<br>Do we need resolution of conflicts, i.e. merging multiple definitions of<br>same operators and groups, where possible?<br></p><p>2016-04-05 22:52 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br></p><p>&gt;<br>&gt; Am 05.04.2016 um 17:29 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt;<br>&gt; David Waite stated a major drawback of precedence groups.<br>&gt;<br>&gt; People will often create tiny precedence groups for their modules, and<br>&gt; user will find that some of them should actually be the same. They will add<br>&gt; precedenceEqualTo, but all these equivalent groups will still exist. This<br>&gt; problem cannot occur with transitive precedence propagation. So precedence<br>&gt; groups really create more problems than solve.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt;<br>&gt; Do you mean these drawbacks?<br>&gt;<br>&gt; &quot;<br>&gt;<br>&gt; However, this may create more issues than it solves (two frameworks<br>&gt; creating their own custom operators, putting them in custom precedence<br>&gt; groups, and the consumer decides the two precedence groups are really<br>&gt; equivalent)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; &quot;<br>&gt;<br>&gt; What is the problem? Changing the relative precedence of external<br>&gt; operators in your file? Doesn&#39;t the same &quot;problem&quot; occur in your proposal<br>&gt; (only with one operator)?<br>&gt;<br>&gt; What is the difference between overriding an operator function like this:<br>&gt;<br>&gt; func + (l: Int, r: Int) -&gt; Int {<br>&gt;        return 0<br>&gt; }<br>&gt;<br>&gt; This can also mess up your code...<br>&gt; I&#39;m sorry if I haven&#39;t understood your point.<br>&gt;<br>&gt; From the other email:<br>&gt;<br>&gt; I meant, are names `precedenceLessThan`, `precedenceEqualTo` a bit clunky?<br>&gt; Maybe:<br>&gt;<br>&gt; associativity(left)<br>&gt; precedence(lessThan: +)<br>&gt; precedence(equalTo: +)<br>&gt;<br>&gt; It also solves my concern about dictionary inside braces.<br>&gt;<br>&gt;<br>&gt; I prefer &quot;precedence(+ lessThan *)&quot;. However I don&#39;t think it&#39;s Swift<br>&gt; style since &quot;lessThan&quot; is like an infix operator *with letters *although<br>&gt; the symmetry between &quot;+&quot; and &quot;*&quot; would be nicely handled by such operator.<br>&gt;<br>&gt; Precedence groups have a great benefit of additional symmetry. Transitive<br>&gt; precedence propagation, on the other hand, also has benefits:<br>&gt;<br>&gt; 1. It does not introduce new entities, just some rules for compiler<br>&gt; 2. It does not add new keywords. In your current wording, we have to take<br>&gt; precedence and precedenceGroup as keywords, that&#39;s why I<br>&gt; originally preferred directives<br>&gt;<br>&gt;<br>&gt; Both 1 and 2 are true but I still prefer to use declarations since they<br>&gt; provide exactly one location where to put operators with equal precedence.<br>&gt;<br>&gt; By the way &quot;precedence&quot; is already a keyword... One more to go :)<br>&gt;<br>&gt; 3. We actually think in terms of operators, not groups.<br>&gt; If I want to say that my operator should have the same priority as `+`,<br>&gt; I&#39;d rather say that I want it to have priority of plus and minus, not<br>&gt; &quot;belong to multiplicative group&quot;.<br>&gt; If I declare &lt;$&gt; and want it to have same priority as &lt;*&gt;, it would be<br>&gt; more difficult to invent some name for their group like FunctorManipulator.<br>&gt;<br>&gt;<br>&gt; I think this deserves more discussion:<br>&gt; Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have<br>&gt; precedence groups?<br>&gt;<br>&gt; Such a precedence declaration would be contrary to my argument above:<br>&gt; declare equal operator precedences in one place, which is more maintainable.<br>&gt;<br>&gt; On the other hand, in your solution you have a list of global rules<br>&gt; and don&#39;t really need braces. How about this?<br>&gt;<br>&gt; #precedenceGroup(Additive)<br>&gt; #precedenceGroup(Multiplicative)<br>&gt; #precedence(Additive, less, Multiplicative)<br>&gt; #operator(+, infix, associativity: left, group: Additive)<br>&gt; #operator(*, infix, associativity: left, group: Multiplicative)<br>&gt; #operator(&lt;&gt;, infix)<br>&gt;<br>&gt; So precedence group is just a tag that can be used in precedence rules and<br>&gt; assigned to operators at declaration.<br>&gt;<br>&gt;<br>&gt; Although it is consistent with your proposal for me it is too much<br>&gt; repetition and &quot;code noise&quot;. Compare:<br>&gt;<br>&gt; infix operator + { associativity: left }<br>&gt; infix operator * { associativity: left }<br>&gt; infix operator &lt;&gt; {}<br>&gt; precedenceGroup Additive { + }<br>&gt; precedenceGroup Multiplicative { * }<br>&gt; precedence(Additive lessThan Multiplicative)<br>&gt;<br>&gt; Which is in my opinion way more readable even without syntax highlighting.<br>&gt;<br>&gt;<br>&gt; Thank You for sharing Your thoughts which have enriched me! :)<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/3361d67e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April  6, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 05.04.2016 um 22:32 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; <br>&gt; Added group version, &quot;lessThan&quot; problem can be solved nicely. `&lt;`, `=`, `&gt;` signs would be allowed there.<br>&gt; <br>&gt; &gt; Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have precedence groups?<br>&gt; I think no.<br>&gt; <br>&gt; I have a question to your group syntax.<br>&gt; Since all operators in a precedence group must have equal associativity for parsing to work and look logically (right?), wouldn&#39;t it be better to declare associativity in groups?<br>&gt; If so, then body of operator declaration won&#39;t contain anything, and we can remove it:<br>&gt; <br>&gt; precedenceGroup Additive {<br>&gt;     associativity(left)<br>&gt;     +, -<br>&gt; }<br>&gt; infix operator +<br>&gt; infix operator -<br>&gt; <br>&gt; Does this body of precedenceGroup look OK from syntactic PoV?<br></p><p>Associativity in precedence groups is fine however the operators should then be grouped possibly: &quot;operators(+, -)&quot;<br></p><p>&gt; <br>&gt; Now, I have another idea.<br>&gt; As operator declarations themselves don&#39;t contain anything anymore, remove operator declarations at all. We don&#39;t need to pre-declare function names, for example.<br>&gt; Next, `precedenceGroup` could be as well replaced with `precedenceLevel`, or just `precedence`, and I would not worry about additional keywords.<br>&gt; So, our example would look like this:<br>&gt; <br>&gt; precedence Additive {<br>&gt;     associativity(left)<br>&gt;     +, -<br>&gt; }<br>&gt; precedence Multiplicative {<br>&gt;     associativity(left)<br>&gt;     *, /<br>&gt; }<br>&gt; precedence(Additive &lt; Multiplicative)<br>&gt; <br>&gt; As a future direction, we could add extensions to precedence levels.<br>&gt; We could go further and replace `precedence` with `operator`, abandoning the idea of priority for prefix and postfix operators (that I honestly don&#39;t like).<br></p><p>Regarding pre- and postfix operators: there was a separate thread which discussed exactly this. The biggest problem was that if a prefix &quot;-&quot; has lower precedence than an infix operator like &quot;^&quot; this calculation is ambiguous from a human perspective:<br></p><p>-3 ^ 3<br></p><p>&quot;-&quot; has visually the higher precedence and the result would be 9. However the actual result is -9.<br></p><p>If we have precedence on pre- and postfix operators we would break existing code. A migratory could then enforce the old precedence levels with braces. But then we can resolve existing (visual) ambiguities and &quot;mathematical incorrectness&quot; by making the precedence of prefix &quot;-&quot; higher than the current comparative operators and not declare its precedence to higher precedence operators (precedence &gt; 140)<br></p><p>Such that this expression is ambiguous to the compiler:<br></p><p>3 - -3 // also mathematically incorrect<br>// and should be rewritten to<br>3 - (-3)<br>// or just<br>3 + 3<br></p><p>&gt; infix operator Additive {<br>&gt;     members(+, -)<br>&gt;     associativity(left)<br>&gt; }<br>&gt; infix operator Multiplicative {<br>&gt;     members(*, /)<br>&gt;     associativity(left)<br>&gt;     precedence(&gt; Additive)<br>&gt; }<br>&gt; <br>&gt; Some other questions:<br>&gt; Do we need transitive precedence propagation?<br></p><p>Yes because it would be quite a pain to declare every precedence between all precedence groups:<br>#needed precedence declarations ~ O(#of precedence groups ^ 2)<br></p><p>&gt; Do we need resolution of conflicts, i.e. merging multiple definitions of same operators and groups, where possible?<br>&gt; <br></p><p>I think we shouldn&#39;t define operators in a precedence group because if we want to have an operator in two different groups then we have two operator definitions which can result in a conflict.<br>I&#39;m not sure if we need the same operator in different groups. Therefore I&#39;d suggest to declare all standard library operators in this form in order to see if we need this.<br></p><p>So my current syntax suggestion is:<br></p><p>infix operator + { associativity(left) }<br>prefix operator -<br>infix operator &amp;&amp; { associativity(left) }<br></p><p>infix precedenceGroup Additive {<br>        associativity(left)<br>        members(+)<br>}<br></p><p>infix precedenceGroup Logical {<br>        associativity(left)<br>        members(&amp;&amp;)<br>}<br></p><p>prefix precedenceGroup Sign {<br>        members(-)<br>}<br></p><p>precedence(Additive &gt; Logical)<br>precedence(Sign &gt; Logical)<br></p><p>// warning: duplicate precedence declarations<br>precedence(Logical &lt; Additive)<br></p><p>--------<br></p><p>I declare associativity in operator declarations and precedence group declarations since it lets the compiler check whether the &quot;members&quot; have the right associativity.<br></p><p>Best regards<br>- Maximilian <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/95604588/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  7, 2016 at 11:00:00pm</p></header><div class="content"><p>First of all, sorry for the delay. I still hope to finish the discussion<br>and push the proposal to review for Swift 3.0.<br>Link for newcomers:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br></p><p>Sadly, I&#39;ve moved into the territory opposite to what I had in mind in the<br>beginning: absense of conflict resolution.<br>I wanted lightweight directives, but am moving to closed precedence groups.<br></p><p>It&#39;s just IMHO, and I think I just need input on this from more people. I<br>still have not heard anything from Core team.<br></p><p>My main question would be: maximally &quot;mergeable&quot; directives or closed<br>declarations?<br></p><p>Now, another iteration of syntax discussion.<br>I&#39;ve created a sample of definitions of precedence operators for standard<br>library, using precedence groups (at the end of the proposal).<br></p><p>There is no evidence that an operator could logically belong to multiple<br>precedence groups.<br>Really, precedence groups are just a way of writing multiple identical<br>operator declarations in a shorter way.<br></p><p>Precedence groups will be closed, meaning that no precedence relations can<br>be added to them outside of their bodies.<br>It will make merging all standard library operators in a giant hierarchy<br>less tempting, although possible.<br>Still, that would be possible. We could disallow that specifically as a<br>future direction (only for standard library).<br></p><p>Still, new operators must be able to be added to existing precedence groups.<br>Extensions cannot be used, because namespaces of types and precedencegroups<br>will not intersect.<br>So I have to return to declaration of operators, if noone finds a better<br>way and if noone objects:<br></p><p>precedencegroup Additive {<br>    members(+, -)<br>    associativity(left)<br>    precedence(&gt; Comparative)<br>}<br>infix operator +<br>infix operator -<br>infix operator &amp;+ { precedencegroup(Additive) }<br></p><p>All operators must have precedence groups.<br>I thought of allowing operators to be single-operator precedence groups,<br>but it wouldn&#39;t give any real benefits.<br>I also thought of allowing operators without precedence, but almost all<br>operators will want at least `precedence(&gt;Assignment)`.<br></p><p>Now, what questions did arise from standard library operator declarations?<br></p><p>1. All precedence groups have a &quot;parent&quot;.<br>It means, all operators will want to have precedence higher than<br>Comparative or Ternary, or, at least, Assignment.<br></p><p>2. Moreover, I could not find any case where I had to write anything other<br>than precedence(&gt;, ...)<br>Of cause, I cheated, because I can control all these declarations.<br>Mere people will have to use `&lt;` to say that Additive, for example, should<br>have less priority than their custom operator.<br></p><p>But... can you build a custom operator where `&lt;` will actually be needed? I<br>have even stronger doubts on `=`.<br>Maybe we can even contract this feature to `parent(Comparative)` or<br>something without losing any expressivity?<br></p><p>3. Can we allow operators to have less priority than `=`?<br>If yes, can you give an example of such operator?<br></p><p>4. Operators `is`, `as`, `as?`, `as!`, `?:`, `=` are not proper Swift<br>operators.<br>But we can still support these tokens for consistency.<br>Their only appearence would be in the standard library.<br>Alternatively, we can hide their precedence groups and make them a special<br>case.<br>It&#39;s more a question of implementation complexity.<br></p><p>5. I removed associativity from Ternary, removed BitwiseXor from bitwise<br>hierarchy.<br>And made numerous other changes that probably need to be reviewed.<br></p><p>2016-04-06 9:17 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br></p><p>&gt;<br>&gt;<br>&gt; Am 05.04.2016 um 22:32 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt;<br>&gt; Added<br>&gt; &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#use-precedence-groups&gt;<br>&gt; group version, &quot;lessThan&quot; problem can be solved nicely. `&lt;`, `=`, `&gt;` signs<br>&gt; would be allowed there.<br>&gt;<br>&gt; &gt; Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have<br>&gt; precedence groups?<br>&gt; I think no.<br>&gt;<br>&gt; I have a question to your group syntax.<br>&gt; Since all operators in a precedence group must have equal associativity<br>&gt; for parsing to work and look logically (right?), wouldn&#39;t it be better to<br>&gt; declare associativity in groups?<br>&gt; If so, then body of operator declaration won&#39;t contain anything, and we<br>&gt; can remove it:<br>&gt;<br>&gt; precedenceGroup Additive {<br>&gt;     associativity(left)<br>&gt;     +, -<br>&gt; }<br>&gt; infix operator +<br>&gt; infix operator -<br>&gt;<br>&gt; Does this body of precedenceGroup look OK from syntactic PoV?<br>&gt;<br>&gt;<br>&gt; Associativity in precedence groups is fine however the operators should<br>&gt; then be grouped possibly: &quot;operators(+, -)&quot;<br>&gt;<br>&gt;<br>&gt; Now, I have another idea.<br>&gt; As operator declarations themselves don&#39;t contain anything anymore, remove<br>&gt; operator declarations at all. We don&#39;t need to pre-declare function names,<br>&gt; for example.<br>&gt; Next, `precedenceGroup` could be as well replaced with `precedenceLevel`,<br>&gt; or just `precedence`, and I would not worry about additional keywords.<br>&gt; So, our example would look like this:<br>&gt;<br>&gt; precedence Additive {<br>&gt;     associativity(left)<br>&gt;     +, -<br>&gt; }<br>&gt; precedence Multiplicative {<br>&gt;     associativity(left)<br>&gt;     *, /<br>&gt; }<br>&gt; precedence(Additive &lt; Multiplicative)<br>&gt;<br>&gt; As a future direction, we could add extensions to precedence levels.<br>&gt; We could go further and replace `precedence` with `operator`, abandoning<br>&gt; the idea of priority for prefix and postfix operators (that I honestly<br>&gt; don&#39;t like).<br>&gt;<br>&gt;<br>&gt; Regarding pre- and postfix operators: there was a separate thread which<br>&gt; discussed exactly this. The biggest problem was that if a prefix &quot;-&quot; has<br>&gt; lower precedence than an infix operator like &quot;^&quot; this calculation is<br>&gt; ambiguous from a human perspective:<br>&gt;<br>&gt; -3 ^ 3<br>&gt;<br>&gt; &quot;-&quot; has visually the higher precedence and the result would be 9. However<br>&gt; the actual result is -9.<br>&gt;<br>&gt; If we have precedence on pre- and postfix operators we would break<br>&gt; existing code. A migratory could then enforce the old precedence levels<br>&gt; with braces. But then we can resolve existing (visual) ambiguities and<br>&gt; &quot;mathematical incorrectness&quot; by making the precedence of prefix &quot;-&quot; higher<br>&gt; than the current comparative operators and not declare its precedence to<br>&gt; higher precedence operators (precedence &gt; 140)<br>&gt;<br>&gt; Such that this expression is ambiguous to the compiler:<br>&gt;<br>&gt; 3 - -3 // also mathematically incorrect<br>&gt; // and should be rewritten to<br>&gt; 3 - (-3)<br>&gt; // or just<br>&gt; 3 + 3<br>&gt;<br>&gt; infix operator Additive {<br>&gt;     members(+, -)<br>&gt;     associativity(left)<br>&gt; }<br>&gt; infix operator Multiplicative {<br>&gt;     members(*, /)<br>&gt;     associativity(left)<br>&gt;     precedence(&gt; Additive)<br>&gt; }<br>&gt;<br>&gt; Some other questions:<br>&gt; Do we need transitive precedence propagation?<br>&gt;<br>&gt;<br>&gt; Yes because it would be quite a pain to declare every precedence between<br>&gt; all precedence groups:<br>&gt; #needed precedence declarations ~ O(#of precedence groups ^ 2)<br>&gt;<br>&gt; Do we need resolution of conflicts, i.e. merging multiple definitions of<br>&gt; same operators and groups, where possible?<br>&gt;<br>&gt;<br>&gt; I think we shouldn&#39;t define operators in a precedence group because if we<br>&gt; want to have an operator in two different groups then we have two operator<br>&gt; definitions which can result in a conflict.<br>&gt; I&#39;m not sure if we need the same operator in different groups. Therefore<br>&gt; I&#39;d suggest to declare all standard library operators in this form in order<br>&gt; to see if we need this.<br>&gt;<br>&gt; So my current syntax suggestion is:<br>&gt;<br>&gt; infix operator + { associativity(left) }<br>&gt; prefix operator -<br>&gt; infix operator &amp;&amp; { associativity(left) }<br>&gt;<br>&gt; infix precedenceGroup Additive {<br>&gt;         associativity(left)<br>&gt;         members(+)<br>&gt; }<br>&gt;<br>&gt; infix precedenceGroup Logical {<br>&gt;         associativity(left)<br>&gt;         members(&amp;&amp;)<br>&gt; }<br>&gt;<br>&gt; prefix precedenceGroup Sign {<br>&gt;         members(-)<br>&gt; }<br>&gt;<br>&gt; precedence(Additive &gt; Logical)<br>&gt; precedence(Sign &gt; Logical)<br>&gt;<br>&gt; // warning: duplicate precedence declarations<br>&gt; precedence(Logical &lt; Additive)<br>&gt;<br>&gt; --------<br>&gt;<br>&gt; I declare associativity in operator declarations and precedence group<br>&gt; declarations since it lets the compiler check whether the &quot;members&quot; have<br>&gt; the right associativity.<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/60f8a801/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First of all, sorry for the delay. I still hope to finish the discussion and push the proposal to review for Swift 3.0.<br>&gt; Link for newcomers:<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt; <br>&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in the beginning: absense of conflict resolution.<br>&gt; I wanted lightweight directives, but am moving to closed precedence groups.<br>&gt; <br>&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I still have not heard anything from Core team.<br></p><p>Hi Антон,<br></p><p>I’m sorry for the delay, I have been out of town recently.  I haven’t read the upstream thread so I hope this isn’t too duplicative.  Here is my 2c:<br></p><p>- I completely agree that numeric precedences are lame, it was always the “plan” that they’d be removed someday, but that obviously still hasn’t happened :-)<br>- I definitely agree that a partial ordering between precedences is all that we need/want, and that unspecified relations should be an error.<br></p><p>That said, I feel like #operator is a major syntactic regression, both in consistency and predictability.  We use # for two things: directives (like #if) and for expressions (#file).  The #operator is a declaration of an operator, not an expression or a directive.  For declarations, we consistently use a keyword, which allows contextual modifiers before them, along with a body (which is sometimes optional for certain kinds of decls).  I feel like you’re trying to syntactically reduce the weight of something that doesn’t occur very often, which is no real win in expressiveness, and harms consistency.<br></p><p>Likewise #precedence is a relationship between two operators.  I’d suggest putting them into the body of the operator declaration.<br></p><p>OTOH, the stuff inside the current operator declaration is a random series of tokens with no apparent structure.  I think it would be reasonable to end up with something like:<br></p><p>infix operator &lt;&gt; {<br>  associativity: left<br>  precedenceLessThan: *<br>  precedenceEqualTo: -<br> }<br></p><p>Or whatever.  The rationale here is that “infix” is primal on the operator decl (and thus is outside the braces) but the rest of the stuff can be omitted, so it goes inside.<br></p><p>Just in terms of the writing of the proposal, in the &quot;Change precedence mechanism” keep in mind that swift code generally doesn’t care about the order of declarations (it doesn’t parse top down in the file like C does) so the example is a bit misleading.<br></p><p>Question for you: have you considered introducing named precedence groups, and having the relationships be between those groups?  For example, I could see something like:<br></p><p>	operator group additive {}<br>	operator group multiplicative { greaterThan: additive }<br>	operator group exponential { greaterThan: additive }<br></p><p>Then:<br></p><p>infix operator + {<br>  associativity: left<br>  precedence: additive<br> }<br>infix operator - {<br>  associativity: left<br>  precedence: additive<br> }<br></p><p>etc.<br></p><p>-Chris<br></p><p><br>&gt; Still, new operators must be able to be added to existing precedence groups.<br>&gt; Extensions cannot be used, because namespaces of types and precedencegroups will not intersect.<br>&gt; So I have to return to declaration of operators, if noone finds a better way and if noone objects:<br>&gt; <br>&gt; precedencegroup Additive {<br>&gt;     members(+, -)<br>&gt;     associativity(left)<br>&gt;     precedence(&gt; Comparative)<br>&gt; }<br>&gt; infix operator +<br>&gt; infix operator -<br>&gt; infix operator &amp;+ { precedencegroup(Additive) }<br>&gt; <br>&gt; All operators must have precedence groups.<br>&gt; I thought of allowing operators to be single-operator precedence groups, but it wouldn&#39;t give any real benefits.<br>&gt; I also thought of allowing operators without precedence, but almost all operators will want at least `precedence(&gt;Assignment)`.<br>&gt; <br>&gt; Now, what questions did arise from standard library operator declarations?<br>&gt; <br>&gt; 1. All precedence groups have a &quot;parent&quot;.<br>&gt; It means, all operators will want to have precedence higher than Comparative or Ternary, or, at least, Assignment.<br>&gt; <br>&gt; 2. Moreover, I could not find any case where I had to write anything other than precedence(&gt;, ...)<br>&gt; Of cause, I cheated, because I can control all these declarations.<br>&gt; Mere people will have to use `&lt;` to say that Additive, for example, should have less priority than their custom operator.<br>&gt; <br>&gt; But... can you build a custom operator where `&lt;` will actually be needed? I have even stronger doubts on `=`.<br>&gt; Maybe we can even contract this feature to `parent(Comparative)` or something without losing any expressivity?<br>&gt; <br>&gt; 3. Can we allow operators to have less priority than `=`?<br>&gt; If yes, can you give an example of such operator?<br>&gt; <br>&gt; 4. Operators `is`, `as`, `as?`, `as!`, `?:`, `=` are not proper Swift operators.<br>&gt; But we can still support these tokens for consistency.<br>&gt; Their only appearence would be in the standard library.<br>&gt; Alternatively, we can hide their precedence groups and make them a special case.<br>&gt; It&#39;s more a question of implementation complexity.<br>&gt; <br>&gt; 5. I removed associativity from Ternary, removed BitwiseXor from bitwise hierarchy.<br>&gt; And made numerous other changes that probably need to be reviewed.<br>&gt; <br>&gt; 2016-04-06 9:17 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt;:<br>&gt; <br>&gt; <br>&gt; Am 05.04.2016 um 22:32 schrieb Антон Жилин &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt;:<br>&gt; <br>&gt;&gt; Added &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#use-precedence-groups&gt; group version, &quot;lessThan&quot; problem can be solved nicely. `&lt;`, `=`, `&gt;` signs would be allowed there.<br>&gt;&gt; <br>&gt;&gt; &gt; Should we allow &quot;precedence(... equalTo ...)&quot; for operators if we have precedence groups?<br>&gt;&gt; I think no.<br>&gt;&gt; <br>&gt;&gt; I have a question to your group syntax.<br>&gt;&gt; Since all operators in a precedence group must have equal associativity for parsing to work and look logically (right?), wouldn&#39;t it be better to declare associativity in groups?<br>&gt;&gt; If so, then body of operator declaration won&#39;t contain anything, and we can remove it:<br>&gt;&gt; <br>&gt;&gt; precedenceGroup Additive {<br>&gt;&gt;     associativity(left)<br>&gt;&gt;     +, -<br>&gt;&gt; }<br>&gt;&gt; infix operator +<br>&gt;&gt; infix operator -<br>&gt;&gt; <br>&gt;&gt; Does this body of precedenceGroup look OK from syntactic PoV?<br>&gt; <br>&gt; Associativity in precedence groups is fine however the operators should then be grouped possibly: &quot;operators(+, -)&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Now, I have another idea.<br>&gt;&gt; As operator declarations themselves don&#39;t contain anything anymore, remove operator declarations at all. We don&#39;t need to pre-declare function names, for example.<br>&gt;&gt; Next, `precedenceGroup` could be as well replaced with `precedenceLevel`, or just `precedence`, and I would not worry about additional keywords.<br>&gt;&gt; So, our example would look like this:<br>&gt;&gt; <br>&gt;&gt; precedence Additive {<br>&gt;&gt;     associativity(left)<br>&gt;&gt;     +, -<br>&gt;&gt; }<br>&gt;&gt; precedence Multiplicative {<br>&gt;&gt;     associativity(left)<br>&gt;&gt;     *, /<br>&gt;&gt; }<br>&gt;&gt; precedence(Additive &lt; Multiplicative)<br>&gt;&gt; <br>&gt;&gt; As a future direction, we could add extensions to precedence levels.<br>&gt;&gt; We could go further and replace `precedence` with `operator`, abandoning the idea of priority for prefix and postfix operators (that I honestly don&#39;t like).<br>&gt;&gt; <br>&gt; <br>&gt; Regarding pre- and postfix operators: there was a separate thread which discussed exactly this. The biggest problem was that if a prefix &quot;-&quot; has lower precedence than an infix operator like &quot;^&quot; this calculation is ambiguous from a human perspective:<br>&gt; <br>&gt; -3 ^ 3<br>&gt; <br>&gt; &quot;-&quot; has visually the higher precedence and the result would be 9. However the actual result is -9.<br>&gt; <br>&gt; If we have precedence on pre- and postfix operators we would break existing code. A migratory could then enforce the old precedence levels with braces. But then we can resolve existing (visual) ambiguities and &quot;mathematical incorrectness&quot; by making the precedence of prefix &quot;-&quot; higher than the current comparative operators and not declare its precedence to higher precedence operators (precedence &gt; 140)<br>&gt; <br>&gt; Such that this expression is ambiguous to the compiler:<br>&gt; <br>&gt; 3 - -3 // also mathematically incorrect<br>&gt; // and should be rewritten to<br>&gt; 3 - (-3)<br>&gt; // or just<br>&gt; 3 + 3<br>&gt; <br>&gt;&gt; infix operator Additive {<br>&gt;&gt;     members(+, -)<br>&gt;&gt;     associativity(left)<br>&gt;&gt; }<br>&gt;&gt; infix operator Multiplicative {<br>&gt;&gt;     members(*, /)<br>&gt;&gt;     associativity(left)<br>&gt;&gt;     precedence(&gt; Additive)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Some other questions:<br>&gt;&gt; Do we need transitive precedence propagation?<br>&gt; <br>&gt; Yes because it would be quite a pain to declare every precedence between all precedence groups:<br>&gt; #needed precedence declarations ~ O(#of precedence groups ^ 2)<br>&gt; <br>&gt;&gt; Do we need resolution of conflicts, i.e. merging multiple definitions of same operators and groups, where possible?<br>&gt;&gt; <br>&gt; <br>&gt; I think we shouldn&#39;t define operators in a precedence group because if we want to have an operator in two different groups then we have two operator definitions which can result in a conflict.<br>&gt; I&#39;m not sure if we need the same operator in different groups. Therefore I&#39;d suggest to declare all standard library operators in this form in order to see if we need this.<br>&gt; <br>&gt; So my current syntax suggestion is:<br>&gt; <br>&gt; infix operator + { associativity(left) }<br>&gt; prefix operator -<br>&gt; infix operator &amp;&amp; { associativity(left) }<br>&gt; <br>&gt; infix precedenceGroup Additive {<br>&gt;         associativity(left)<br>&gt;         members(+)<br>&gt; }<br>&gt; <br>&gt; infix precedenceGroup Logical {<br>&gt;         associativity(left)<br>&gt;         members(&amp;&amp;)<br>&gt; }<br>&gt; <br>&gt; prefix precedenceGroup Sign {<br>&gt;         members(-)<br>&gt; }<br>&gt; <br>&gt; precedence(Additive &gt; Logical)<br>&gt; precedence(Sign &gt; Logical)<br>&gt; <br>&gt; // warning: duplicate precedence declarations<br>&gt; precedence(Logical &lt; Additive)<br>&gt; <br>&gt; --------<br>&gt; <br>&gt; I declare associativity in operator declarations and precedence group declarations since it lets the compiler check whether the &quot;members&quot; have the right associativity.<br>&gt; <br>&gt; Best regards<br>&gt; - Maximilian <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/654456fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>April  8, 2016 at 09:00:00am</p></header><div class="content"><p>On 4/8/16 02:59, Chris Lattner via swift-evolution wrote:<br>&gt;&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Link for newcomers:<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt;&gt;<br>&gt;&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in the beginning: absense of conflict resolution.<br>&gt;&gt; I wanted lightweight directives, but am moving to closed precedence groups.<br>&gt;&gt;<br>&gt;&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I still have not heard anything from Core team.<br>&gt; ... <br>&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t read the upstream thread so I hope this isn’t too duplicative.  Here is my 2c:<br>&gt; <br>&gt; - I completely agree that numeric precedences are lame, it was always the “plan” that they’d be removed someday, but that obviously still hasn’t happened :-)<br></p><p>+10!<br></p><p>&gt; - I definitely agree that a partial ordering between precedences is all that we need/want, and that unspecified relations should be an error.<br>&gt; ...<br>&gt; Question for you: have you considered introducing named precedence groups, and having the relationships be between those groups?  For example, I could see something like:<br>&gt; <br>&gt; 	operator group additive {}<br>&gt; 	operator group multiplicative { greaterThan: additive }<br>&gt; 	operator group exponential { greaterThan: additive }<br></p><p>Also +10, would be interested in your opinion about:<br></p><p>1) disallowing adding new operator groups outside the stdlib;<br></p><p>2) disallowing adding operators to uncommon groups like subscripting,<br>function calls, etc.<br></p><p>TIA...<br>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Apr 8, 2016, at 5:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; - I definitely agree that a partial ordering between precedences is all that we need/want, and that unspecified relations should be an error.<br>&gt;&gt; ...<br>&gt;&gt; Question for you: have you considered introducing named precedence groups, and having the relationships be between those groups?  For example, I could see something like:<br>&gt;&gt; <br>&gt;&gt; 	operator group additive {}<br>&gt;&gt; 	operator group multiplicative { greaterThan: additive }<br>&gt;&gt; 	operator group exponential { greaterThan: additive }<br>&gt; <br>&gt; Also +10, would be interested in your opinion about:<br>&gt; <br>&gt; 1) disallowing adding new operator groups outside the stdlib;<br>&gt; <br></p><p>I don’t see why we would do that.  This would lead us directly into the world of C++ operator overloading, where everyone reuses existing operators instead of defining their new and unique operators.  IMO it is much better to &quot;know that you don’t know” what a symbol is, rather than assuming it has the obvious semantics and being surprised because it was overloaded.<br></p><p>&gt; 2) disallowing adding operators to uncommon groups like subscripting,<br>&gt; function calls, etc.<br></p><p><br>Subscripting and function calls are not operators.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>April  9, 2016 at 11:00:00am</p></header><div class="content"><p>Chris, thanks for commenting, but see below:<br></p><p>On 4/9/16 10:33, Chris Lattner via swift-evolution wrote:<br>&gt;&gt; On Apr 8, 2016, at 5:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; - I definitely agree that a partial ordering between precedences is all that we need/want, and that unspecified relations should be an error.<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; Question for you: have you considered introducing named precedence groups, and having the relationships be between those groups?  For example, I could see something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 	operator group additive {}<br>&gt;&gt;&gt; 	operator group multiplicative { greaterThan: additive }<br>&gt;&gt;&gt; 	operator group exponential { greaterThan: additive }<br>&gt;&gt;<br>&gt;&gt; Also +10, would be interested in your opinion about:<br>&gt;&gt;<br>&gt;&gt; 1) disallowing adding new operator groups outside the stdlib;<br>&gt; <br>&gt; I don’t see why we would do that.  This would lead us directly into<br>&gt; the world of C++ operator overloading, where everyone reuses existing<br>&gt; operators instead of defining their new and unique operators.  IMO it<br>&gt; is much better to &quot;know that you don’t know” what a symbol is, rather<br>&gt; than assuming it has the obvious semantics and being surprised<br>&gt; because it was overloaded.<br></p><p>I agree with you a 100% regarding new operators, but notice I said<br>&quot;adding new operator GROUPS&quot;. I don&#39;t see much sense in adding a new<br>precedence group beyond the ones already defined.<br></p><p>This goes along with your comment later in this thread:<br>&gt; ...This would require using parentheses to disambiguate...<br>which I always do — I never remember most of the precedences.<br></p><p><br>&gt;&gt; 2) disallowing adding operators to uncommon groups like subscripting,<br>&gt;&gt; function calls, etc.<br>&gt; Subscripting and function calls are not operators.<br></p><p>Oops, right. I meant in the context of &quot;expressions&quot;, as used in the<br>Swift book.<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  8, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you for your reply, Chris!<br>I was thinking about purging directives from the proposal, and that was<br>what I needed to do it.<br>So, the proposal is now completely overhauled:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br></p><p>Yes, Maximilian and I have considered operator/precedence groups and they<br>have now moved from alternatives to main part of the proposal.<br></p><p>Questions:<br>1. Is it OK that associativity is moved to precedence groups and that every<br>operator must belong to a precedence group?<br>2. Dictionary-like or &quot;functional keywords&quot;? That is, `associativity: left`<br>or `associativity(left)`? So far, only second form has been used somewhere<br>inside declarations.<br>3. First-lower or first-upper? `additive` or `Additive`?<br>4. Empty body or no body? `prefix operator ! { }` or `prefix operator !`?<br></p><p>Just in case, some questions/concerns copied from previous discussion:<br></p><p>1. All precedence groups have a &quot;parent&quot;.<br>It means, all operators will want to have precedence higher than<br>Comparative or Ternary, or, at least, Assignment.<br></p><p>2. Moreover, I could not find any case where I had to write anything other<br>than precedence(&gt;, ...)<br>Of cause, I cheated, because I can control all these declarations.<br>Mere people will have to use `&lt;` to say that Additive, for example, should<br>have less priority than their custom operator.<br></p><p>But... can you build a custom operator where `&lt;` will actually be needed? I<br>have even stronger doubts on `=`.<br>Maybe we can even contract this feature to `parent(Comparative)` or<br>something without losing any expressivity?<br></p><p>3. Can we allow operators to have less priority than `=`?<br>If yes, can you give an example of such operator?<br></p><p>- Anton<br></p><p>2016-04-08 8:59 GMT+03:00 Chris Lattner &lt;clattner at apple.com&gt;:<br></p><p>&gt;<br>&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; First of all, sorry for the delay. I still hope to finish the discussion<br>&gt; and push the proposal to review for Swift 3.0.<br>&gt; Link for newcomers:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in the<br>&gt; beginning: absense of conflict resolution.<br>&gt; I wanted lightweight directives, but am moving to closed precedence groups.<br>&gt;<br>&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I<br>&gt; still have not heard anything from Core team.<br>&gt;<br>&gt;<br>&gt; Hi Антон,<br>&gt;<br>&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t read<br>&gt; the upstream thread so I hope this isn’t too duplicative.  Here is my 2c:<br>&gt;<br>&gt; - I completely agree that numeric precedences are lame, it was always the<br>&gt; “plan” that they’d be removed someday, but that obviously still hasn’t<br>&gt; happened :-)<br>&gt; - I definitely agree that a partial ordering between precedences is all<br>&gt; that we need/want, and that unspecified relations should be an error.<br>&gt;<br>&gt; That said, I feel like #operator is a major syntactic regression, both in<br>&gt; consistency and predictability.  We use # for two things: directives (like<br>&gt; #if) and for expressions (#file).  The #operator is a declaration of an<br>&gt; operator, not an expression or a directive.  For declarations, we<br>&gt; consistently use a keyword, which allows contextual modifiers before them,<br>&gt; along with a body (which is sometimes optional for certain kinds of<br>&gt; decls).  I feel like you’re trying to syntactically reduce the weight of<br>&gt; something that doesn’t occur very often, which is no real win in<br>&gt; expressiveness, and harms consistency.<br>&gt;<br>&gt; Likewise #precedence is a relationship between two operators.  I’d suggest<br>&gt; putting them into the body of the operator declaration.<br>&gt;<br>&gt; OTOH, the stuff inside the current operator declaration is a random series<br>&gt; of tokens with no apparent structure.  I think it would be reasonable to<br>&gt; end up with something like:<br>&gt;<br>&gt; infix operator &lt;&gt; {<br>&gt;   associativity: left<br>&gt;   precedenceLessThan: *<br>&gt;   precedenceEqualTo: -<br>&gt;  }<br>&gt;<br>&gt; Or whatever.  The rationale here is that “infix” is primal on the operator<br>&gt; decl (and thus is outside the braces) but the rest of the stuff can be<br>&gt; omitted, so it goes inside.<br>&gt;<br>&gt; Just in terms of the writing of the proposal, in the &quot;Change precedence<br>&gt; mechanism” keep in mind that swift code generally doesn’t care about the<br>&gt; order of declarations (it doesn’t parse top down in the file like C does)<br>&gt; so the example is a bit misleading.<br>&gt;<br>&gt; Question for you: have you considered introducing named precedence groups,<br>&gt; and having the relationships be between those groups?  For example, I could<br>&gt; see something like:<br>&gt;<br>&gt; operator group additive {}<br>&gt; operator group multiplicative { greaterThan: additive }<br>&gt; operator group exponential { greaterThan: additive }<br>&gt;<br>&gt; Then:<br>&gt;<br>&gt; infix operator + {<br>&gt;   associativity: left<br>&gt;   precedence: additive<br>&gt;  }<br>&gt; infix operator - {<br>&gt;   associativity: left<br>&gt;   precedence: additive<br>&gt;  }<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/d9358216/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  8, 2016 at 06:00:00pm</p></header><div class="content"><p>If I want to define a new operator, it seems like an unnecessary overhead<br>to have to immediately decide which precedence group it should belong to<br>before it can be used (assuming it doesn&#39;t interact with other operators).<br>At the moment, new operators are implicitly assigned a &#39;default&#39; precedence<br>of 100; can we make it so that new operators are implicitly assigned to a<br>&#39;default&#39; group with an effective precedence of 100? (I believe this is<br>currently the precedence of Ternary, but I&#39;m not sure if I&#39;d have Ternary<br>be the default group).<br></p><p>On Fri, Apr 8, 2016 at 5:59 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Thank you for your reply, Chris!<br>&gt; I was thinking about purging directives from the proposal, and that was<br>&gt; what I needed to do it.<br>&gt; So, the proposal is now completely overhauled:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt; Yes, Maximilian and I have considered operator/precedence groups and they<br>&gt; have now moved from alternatives to main part of the proposal.<br>&gt;<br>&gt; Questions:<br>&gt; 1. Is it OK that associativity is moved to precedence groups and that<br>&gt; every operator must belong to a precedence group?<br>&gt; 2. Dictionary-like or &quot;functional keywords&quot;? That is, `associativity:<br>&gt; left` or `associativity(left)`? So far, only second form has been used<br>&gt; somewhere inside declarations.<br>&gt; 3. First-lower or first-upper? `additive` or `Additive`?<br>&gt; 4. Empty body or no body? `prefix operator ! { }` or `prefix operator !`?<br>&gt;<br>&gt; Just in case, some questions/concerns copied from previous discussion:<br>&gt;<br>&gt; 1. All precedence groups have a &quot;parent&quot;.<br>&gt; It means, all operators will want to have precedence higher than<br>&gt; Comparative or Ternary, or, at least, Assignment.<br>&gt;<br>&gt; 2. Moreover, I could not find any case where I had to write anything other<br>&gt; than precedence(&gt;, ...)<br>&gt; Of cause, I cheated, because I can control all these declarations.<br>&gt; Mere people will have to use `&lt;` to say that Additive, for example, should<br>&gt; have less priority than their custom operator.<br>&gt;<br>&gt; But... can you build a custom operator where `&lt;` will actually be needed?<br>&gt; I have even stronger doubts on `=`.<br>&gt; Maybe we can even contract this feature to `parent(Comparative)` or<br>&gt; something without losing any expressivity?<br>&gt;<br>&gt; 3. Can we allow operators to have less priority than `=`?<br>&gt; If yes, can you give an example of such operator?<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; 2016-04-08 8:59 GMT+03:00 Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; First of all, sorry for the delay. I still hope to finish the discussion<br>&gt;&gt; and push the proposal to review for Swift 3.0.<br>&gt;&gt; Link for newcomers:<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;<br>&gt;&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in<br>&gt;&gt; the beginning: absense of conflict resolution.<br>&gt;&gt; I wanted lightweight directives, but am moving to closed precedence<br>&gt;&gt; groups.<br>&gt;&gt;<br>&gt;&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I<br>&gt;&gt; still have not heard anything from Core team.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Антон,<br>&gt;&gt;<br>&gt;&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t<br>&gt;&gt; read the upstream thread so I hope this isn’t too duplicative.  Here is my<br>&gt;&gt; 2c:<br>&gt;&gt;<br>&gt;&gt; - I completely agree that numeric precedences are lame, it was always the<br>&gt;&gt; “plan” that they’d be removed someday, but that obviously still hasn’t<br>&gt;&gt; happened :-)<br>&gt;&gt; - I definitely agree that a partial ordering between precedences is all<br>&gt;&gt; that we need/want, and that unspecified relations should be an error.<br>&gt;&gt;<br>&gt;&gt; That said, I feel like #operator is a major syntactic regression, both in<br>&gt;&gt; consistency and predictability.  We use # for two things: directives (like<br>&gt;&gt; #if) and for expressions (#file).  The #operator is a declaration of an<br>&gt;&gt; operator, not an expression or a directive.  For declarations, we<br>&gt;&gt; consistently use a keyword, which allows contextual modifiers before them,<br>&gt;&gt; along with a body (which is sometimes optional for certain kinds of<br>&gt;&gt; decls).  I feel like you’re trying to syntactically reduce the weight of<br>&gt;&gt; something that doesn’t occur very often, which is no real win in<br>&gt;&gt; expressiveness, and harms consistency.<br>&gt;&gt;<br>&gt;&gt; Likewise #precedence is a relationship between two operators.  I’d<br>&gt;&gt; suggest putting them into the body of the operator declaration.<br>&gt;&gt;<br>&gt;&gt; OTOH, the stuff inside the current operator declaration is a random<br>&gt;&gt; series of tokens with no apparent structure.  I think it would be<br>&gt;&gt; reasonable to end up with something like:<br>&gt;&gt;<br>&gt;&gt; infix operator &lt;&gt; {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedenceLessThan: *<br>&gt;&gt;   precedenceEqualTo: -<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; Or whatever.  The rationale here is that “infix” is primal on the<br>&gt;&gt; operator decl (and thus is outside the braces) but the rest of the stuff<br>&gt;&gt; can be omitted, so it goes inside.<br>&gt;&gt;<br>&gt;&gt; Just in terms of the writing of the proposal, in the &quot;Change precedence<br>&gt;&gt; mechanism” keep in mind that swift code generally doesn’t care about the<br>&gt;&gt; order of declarations (it doesn’t parse top down in the file like C does)<br>&gt;&gt; so the example is a bit misleading.<br>&gt;&gt;<br>&gt;&gt; Question for you: have you considered introducing named precedence<br>&gt;&gt; groups, and having the relationships be between those groups?  For example,<br>&gt;&gt; I could see something like:<br>&gt;&gt;<br>&gt;&gt; operator group additive {}<br>&gt;&gt; operator group multiplicative { greaterThan: additive }<br>&gt;&gt; operator group exponential { greaterThan: additive }<br>&gt;&gt;<br>&gt;&gt; Then:<br>&gt;&gt;<br>&gt;&gt; infix operator + {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedence: additive<br>&gt;&gt;  }<br>&gt;&gt; infix operator - {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedence: additive<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; etc.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/b08cfa06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Right, `infix` operators without a precedence group logically should be<br>able to be used, just with parentheses everywhere.<br></p><p>But users will most likely want to use such operators with `=` without<br>parentheses. It means, such operators should still belong to some<br>precedence groups.<br></p><p>I suggest that for each such operator, an separate unnamed group should be<br>created. It will have no associativity and precedence greater than Ternary<br>(I actually agree this is the right choice).<br></p><p>I also think it is OK that other operators will not be able to specify<br>precedence relation with such &quot;unprecedented&quot; operators.<br></p><p>- Anton<br></p><p>8 Apr 2016, Ross O&#39;Brien wrote:<br></p><p>&gt; If I want to define a new operator, it seems like an unnecessary overhead<br>&gt; to have to immediately decide which precedence group it should belong to<br>&gt; before it can be used (assuming it doesn&#39;t interact with other operators).<br>&gt; At the moment, new operators are implicitly assigned a &#39;default&#39; precedence<br>&gt; of 100; can we make it so that new operators are implicitly assigned to a<br>&gt; &#39;default&#39; group with an effective precedence of 100? (I believe this is<br>&gt; currently the precedence of Ternary, but I&#39;m not sure if I&#39;d have Ternary<br>&gt; be the default group).<br>&gt;<br>&gt; On Fri, Apr 8, 2016 at 5:59 PM, Антон Жилин &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Thank you for your reply, Chris!<br>&gt;&gt; I was thinking about purging directives from the proposal, and that was<br>&gt;&gt; what I needed to do it.<br>&gt;&gt; So, the proposal is now completely overhauled:<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;<br>&gt;&gt; Yes, Maximilian and I have considered operator/precedence groups and they<br>&gt;&gt; have now moved from alternatives to main part of the proposal.<br>&gt;&gt;<br>&gt;&gt; Questions:<br>&gt;&gt; 1. Is it OK that associativity is moved to precedence groups and that<br>&gt;&gt; every operator must belong to a precedence group?<br>&gt;&gt; 2. Dictionary-like or &quot;functional keywords&quot;? That is, `associativity:<br>&gt;&gt; left` or `associativity(left)`? So far, only second form has been used<br>&gt;&gt; somewhere inside declarations.<br>&gt;&gt; 3. First-lower or first-upper? `additive` or `Additive`?<br>&gt;&gt; 4. Empty body or no body? `prefix operator ! { }` or `prefix operator !`?<br>&gt;&gt;<br>&gt;&gt; Just in case, some questions/concerns copied from previous discussion:<br>&gt;&gt;<br>&gt;&gt; 1. All precedence groups have a &quot;parent&quot;.<br>&gt;&gt; It means, all operators will want to have precedence higher than<br>&gt;&gt; Comparative or Ternary, or, at least, Assignment.<br>&gt;&gt;<br>&gt;&gt; 2. Moreover, I could not find any case where I had to write anything<br>&gt;&gt; other than precedence(&gt;, ...)<br>&gt;&gt; Of cause, I cheated, because I can control all these declarations.<br>&gt;&gt; Mere people will have to use `&lt;` to say that Additive, for example,<br>&gt;&gt; should have less priority than their custom operator.<br>&gt;&gt;<br>&gt;&gt; But... can you build a custom operator where `&lt;` will actually be needed?<br>&gt;&gt; I have even stronger doubts on `=`.<br>&gt;&gt; Maybe we can even contract this feature to `parent(Comparative)` or<br>&gt;&gt; something without losing any expressivity?<br>&gt;&gt;<br>&gt;&gt; 3. Can we allow operators to have less priority than `=`?<br>&gt;&gt; If yes, can you give an example of such operator?<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; 2016-04-08 8:59 GMT+03:00 Chris Lattner &lt;clattner at apple.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; First of all, sorry for the delay. I still hope to finish the discussion<br>&gt;&gt;&gt; and push the proposal to review for Swift 3.0.<br>&gt;&gt;&gt; Link for newcomers:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in<br>&gt;&gt;&gt; the beginning: absense of conflict resolution.<br>&gt;&gt;&gt; I wanted lightweight directives, but am moving to closed precedence<br>&gt;&gt;&gt; groups.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s just IMHO, and I think I just need input on this from more people.<br>&gt;&gt;&gt; I still have not heard anything from Core team.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Антон,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t<br>&gt;&gt;&gt; read the upstream thread so I hope this isn’t too duplicative.  Here is my<br>&gt;&gt;&gt; 2c:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - I completely agree that numeric precedences are lame, it was always<br>&gt;&gt;&gt; the “plan” that they’d be removed someday, but that obviously still hasn’t<br>&gt;&gt;&gt; happened :-)<br>&gt;&gt;&gt; - I definitely agree that a partial ordering between precedences is all<br>&gt;&gt;&gt; that we need/want, and that unspecified relations should be an error.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said, I feel like #operator is a major syntactic regression, both<br>&gt;&gt;&gt; in consistency and predictability.  We use # for two things: directives<br>&gt;&gt;&gt; (like #if) and for expressions (#file).  The #operator is a declaration of<br>&gt;&gt;&gt; an operator, not an expression or a directive.  For declarations, we<br>&gt;&gt;&gt; consistently use a keyword, which allows contextual modifiers before them,<br>&gt;&gt;&gt; along with a body (which is sometimes optional for certain kinds of<br>&gt;&gt;&gt; decls).  I feel like you’re trying to syntactically reduce the weight of<br>&gt;&gt;&gt; something that doesn’t occur very often, which is no real win in<br>&gt;&gt;&gt; expressiveness, and harms consistency.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Likewise #precedence is a relationship between two operators.  I’d<br>&gt;&gt;&gt; suggest putting them into the body of the operator declaration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; OTOH, the stuff inside the current operator declaration is a random<br>&gt;&gt;&gt; series of tokens with no apparent structure.  I think it would be<br>&gt;&gt;&gt; reasonable to end up with something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator &lt;&gt; {<br>&gt;&gt;&gt;   associativity: left<br>&gt;&gt;&gt;   precedenceLessThan: *<br>&gt;&gt;&gt;   precedenceEqualTo: -<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or whatever.  The rationale here is that “infix” is primal on the<br>&gt;&gt;&gt; operator decl (and thus is outside the braces) but the rest of the stuff<br>&gt;&gt;&gt; can be omitted, so it goes inside.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Just in terms of the writing of the proposal, in the &quot;Change precedence<br>&gt;&gt;&gt; mechanism” keep in mind that swift code generally doesn’t care about the<br>&gt;&gt;&gt; order of declarations (it doesn’t parse top down in the file like C does)<br>&gt;&gt;&gt; so the example is a bit misleading.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Question for you: have you considered introducing named precedence<br>&gt;&gt;&gt; groups, and having the relationships be between those groups?  For example,<br>&gt;&gt;&gt; I could see something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; operator group additive {}<br>&gt;&gt;&gt; operator group multiplicative { greaterThan: additive }<br>&gt;&gt;&gt; operator group exponential { greaterThan: additive }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator + {<br>&gt;&gt;&gt;   associativity: left<br>&gt;&gt;&gt;   precedence: additive<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; infix operator - {<br>&gt;&gt;&gt;   associativity: left<br>&gt;&gt;&gt;   precedence: additive<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/b609313a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Apr 8, 2016, at 10:46 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right, `infix` operators without a precedence group logically should be able to be used, just with parentheses everywhere.<br>&gt; <br>&gt; But users will most likely want to use such operators with `=` without parentheses. It means, such operators should still belong to some precedence groups.<br>&gt; <br>&gt; I suggest that for each such operator, an separate unnamed group should be created. It will have no associativity and precedence greater than Ternary (I actually agree this is the right choice).<br>&gt; <br>&gt; I also think it is OK that other operators will not be able to specify precedence relation with such &quot;unprecedented&quot; operators<br></p><p>Right, I agree.  I consider it to be the &quot;safe default&quot; for an operator to be non-associative and unordered with respect to all other operators.  This would require using parentheses to disambiguate, which seems safer than a default precedence level.  This proposal also eliminates the notion of a strictly ordered set of precedences.<br></p><p>I do think it is useful to be able to specify precedence relationships without having to define a “group”, to avoid boilerplate when you have one operator at a logical level (“??” for example).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Apr 9, 2016, at 6:36 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I do think it is useful to be able to specify precedence relationships without having to define a “group”, to avoid boilerplate when you have one operator at a logical level (“??” for example).<br></p><p>Thought there is the obvious counterpoint: sugaring this one case doesn’t seem worthwhile, given how infrequently operators are defined.  It is quite reasonable to start simple and always require an operator to be a member of a group.  We could eliminate that boilerplate at some point down the road if it is an issue in practice.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  9, 2016 at 08:00:00pm</p></header><div class="content"><p>As always, link to the proposal:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br></p><p>Without further ado, I changed syntax for declaring that an operator<br>belongs to a group. It now looks like:<br>infix operator &lt;&gt; : Comparative<br></p><p>Next, I added a notion of default precedence group for infix operators:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#default-precedence-group<br></p><p>Next, I added a notion of special operatrors that will allow nice<br>declarations in the Standard Library:<br>https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md#special-operators<br></p><p>I have a question on this: is that right? Because corresponding operator<br>functions still won&#39;t be declared anywhere.<br></p><p>Now, I see only 1 large question/problem risen by David Waite:<br>Should precedence relationships be defined inside or outside of precedence<br>groups?<br>That is: should we be able to add arbitrary relationships between existing<br>groups?<br></p><p>If we discuss this and no more problems are discovered, then I think, we<br>will be ready for review.<br></p><p>2016-04-09 16:40 GMT+03:00 Chris Lattner &lt;clattner at apple.com&gt;:<br></p><p>&gt; &gt; On Apr 9, 2016, at 6:36 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I do think it is useful to be able to specify precedence relationships<br>&gt; without having to define a “group”, to avoid boilerplate when you have one<br>&gt; operator at a logical level (“??” for example).<br>&gt;<br>&gt; Thought there is the obvious counterpoint: sugaring this one case doesn’t<br>&gt; seem worthwhile, given how infrequently operators are defined.  It is quite<br>&gt; reasonable to start simple and always require an operator to be a member of<br>&gt; a group.  We could eliminate that boilerplate at some point down the road<br>&gt; if it is an issue in practice.<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/ab938ad5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 10, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Am 09.04.2016 um 19:43 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; [...]<br>&gt; Now, I see only 1 large question/problem risen by David Waite:<br>&gt; Should precedence relationships be defined inside or outside of precedence groups?<br>&gt; That is: should we be able to add arbitrary relationships between existing groups?<br>&gt; [...]<br></p><p>I&#39;m in favor of declaring precedence relationships inside precedencegroup declarations. So they have a fixed place where they are defined.<br></p><p><br>The only minor syntax issue I have is that it is not immediately clear which operators belong to a precedence group. The former syntax with the &quot;members(+, -)&quot; solved this issue. However this has (currently) an extensibility problem:<br>If you define a new operator and it should belong to a precedencegroup where you have no access to its source (like Additive) then the whole argument about having operators in one place.<br></p><p><br>Another minor issue regarding your implementation of the standard library operators: &quot;Additive&quot; and all &quot;Bitwise&quot; precedencegroups should be above &quot;Range&quot;<br></p><p>// so this is also possible without parentheses<br>(1+2) ... (3+5)<br></p><p>This issue can be brought up again during another proposal which implements this proposal. So the standard library changes should not belong to this proposal (or least be clarified).<br></p><p>Kind regards<br>- Maximilian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/eb94f869/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Inline:<br></p><p>2016-04-10 2:27 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br></p><p>&gt;<br>&gt; Am 09.04.2016 um 19:43 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; [...]<br>&gt;<br>&gt; Now, I see only 1 large question/problem risen by David Waite:<br>&gt; Should precedence relationships be defined inside or outside of precedence<br>&gt; groups?<br>&gt; That is: should we be able to add arbitrary relationships between existing<br>&gt; groups?<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; I&#39;m in favor of declaring precedence relationships inside precedencegroup<br>&gt; declarations. So they have a fixed place where they are defined.<br>&gt;<br></p><p>I&#39;m inclined to agree, but still not completely sure. Maybe someone else<br>could add a vote? Chris? :)<br></p><p>The only minor syntax issue I have is that it is not immediately clear<br>&gt; which operators belong to a precedence group. The former syntax with the<br>&gt; &quot;members(+, -)&quot; solved this issue. However this has (currently) an<br>&gt; extensibility problem:<br>&gt;<br>If you define a new operator and it should belong to a precedencegroup<br>&gt; where you have no access to its source (like Additive) then the whole<br>&gt; argument about having operators in one place.<br>&gt;<br></p><p>My thoughts went as follows.<br>We should be able to add operators to existing groups, for example, defined<br>in the Standard Library.<br>If so, then this this statement should belong to operator, not precedence<br>group.<br>But we have to declare the operator anyway, so adding `: Additive` or<br>something to the declaration does not cause huge code bloat. Especially<br>considering operators are not defined very often.<br>Now, we have two ways to do the same thing. External declaration is<br>necessary and not so bad. So, following a widely known principle, I remove<br>`members`.<br></p><p>Another minor issue regarding your implementation of the standard library<br>&gt; operators: &quot;Additive&quot; and all &quot;Bitwise&quot; precedencegroups should be above<br>&gt; &quot;Range&quot;<br>&gt;<br>&gt; // so this is also possible without parentheses<br>&gt; (1+2) ... (3+5)<br>&gt;<br>&gt; This issue can be brought up again during another proposal which<br>&gt; implements this proposal. So the standard library changes *should not*<br>&gt; belong to this proposal (or least be clarified).<br>&gt;<br></p><p>Agreed. I will edit that part to form a hierarchy that exactky matches<br>current state of things.<br></p><p><br>&gt;<br>&gt; Kind regards<br>&gt; - Maximilian<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/dfdd7fb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 10.04.2016 um 11:48 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt; <br>&gt;&gt; 2016-04-10 2:27 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br>&gt; <br>&gt; [...]<br>&gt; <br>&gt;&gt; The only minor syntax issue I have is that it is not immediately clear which operators belong to a precedence group. The former syntax with the &quot;members(+, -)&quot; solved this issue. However this has (currently) an extensibility problem:<br>&gt;&gt; If you define a new operator and it should belong to a precedencegroup where you have no access to its source (like Additive) then the whole argument about having operators in one place.<br>&gt; <br>&gt; My thoughts went as follows.<br>&gt; We should be able to add operators to existing groups, for example, defined in the Standard Library.<br>&gt; If so, then this this statement should belong to operator, not precedence group.<br>&gt; But we have to declare the operator anyway, so adding `: Additive` or something to the declaration does not cause huge code bloat. Especially considering operators are not defined very often.<br>&gt; Now, we have two ways to do the same thing. External declaration is necessary and not so bad. So, following a widely known principle, I remove `members`.<br>&gt; <br>&gt; [...]<br></p><p><br>My issue can be solved by the IDE: It could display all operators which are contained in a precedencegroup with quick look or the new interface view in Xcode. However this excludes other IDEs which don&#39;t have such features.<br></p><p>But as I said it is only a minor issue.<br></p><p>Best regards<br>- Maximilian<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/2481c8d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April 12, 2016 at 02:00:00pm</p></header><div class="content"><p>No new suggestions have come in 2 days, and so I have created a pull<br>request! Here it is:<br>https://github.com/apple/swift-evolution/pull/253<br></p><p>If new glitches are suddenly discovered, Core team will still have the<br>ability to correct them.<br>So far we have mostly come to consensus.<br></p><p>- Anton<br></p><p>2016-04-10 13:18 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br></p><p>&gt;<br>&gt; Am 10.04.2016 um 11:48 schrieb Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br>&gt;<br>&gt;<br>&gt; 2016-04-10 2:27 GMT+03:00 Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br>&gt;<br>&gt;<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; The only minor syntax issue I have is that it is not immediately clear<br>&gt;&gt; which operators belong to a precedence group. The former syntax with the<br>&gt;&gt; &quot;members(+, -)&quot; solved this issue. However this has (currently) an<br>&gt;&gt; extensibility problem:<br>&gt;&gt;<br>&gt; If you define a new operator and it should belong to a precedencegroup<br>&gt;&gt; where you have no access to its source (like Additive) then the whole<br>&gt;&gt; argument about having operators in one place.<br>&gt;&gt;<br>&gt;<br>&gt; My thoughts went as follows.<br>&gt; We should be able to add operators to existing groups, for example,<br>&gt; defined in the Standard Library.<br>&gt; If so, then this this statement should belong to operator, not precedence<br>&gt; group.<br>&gt; But we have to declare the operator anyway, so adding `: Additive` or<br>&gt; something to the declaration does not cause huge code bloat. Especially<br>&gt; considering operators are not defined very often.<br>&gt; Now, we have two ways to do the same thing. External declaration is<br>&gt; necessary and not so bad. So, following a widely known principle, I remove<br>&gt; `members`.<br>&gt;<br>&gt;<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; My issue can be solved by the IDE: It could display all operators which<br>&gt; are contained in a precedencegroup with quick look or the new interface<br>&gt; view in Xcode. However this excludes other IDEs which don&#39;t have such<br>&gt; features.<br>&gt;<br>&gt; But as I said it is only a minor issue.<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/bce992b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Just want to make sure the pull request is noticed.<br>The proposal is ready for merge. Note that we can now &quot;squash and merge&quot; on<br>Github.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/8eb216c6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  8, 2016 at 10:00:00pm</p></header><div class="content"><p>The question 4 (`prefix operator ! { }` or `prefix operator !`) seems dead<br>simple, because if we need to declare precedence group in body of infix<br>operators, then other operators should have it for consistency.<br></p><p>It&#39;s not.<br>I suggest an alternative syntax for that:<br>infix operator &lt;&gt; : Comparative<br></p><p>Colon immediately after the operator may not look the best, but it&#39;s the<br>only disadvantage I can find. It looks like inheritance and has similar<br>meaning.<br>So, in this scheme, all operators will have no body.<br></p><p>I also described two methods to declare that operator belongs to a<br>precedence group: in `members` and in operator declaration.<br>I suggest that this new syntax looks brief/natural enough to remove<br>`members` option entirely. &quot;There should be one - and preferably only one -<br>obvious way to do it.&quot;<br></p><p>- Anton<br></p><p>2016-04-08 19:59 GMT+03:00 Антон Жилин &lt;antonyzhilin at gmail.com&gt;:<br></p><p>&gt; Thank you for your reply, Chris!<br>&gt; I was thinking about purging directives from the proposal, and that was<br>&gt; what I needed to do it.<br>&gt; So, the proposal is now completely overhauled:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt; Yes, Maximilian and I have considered operator/precedence groups and they<br>&gt; have now moved from alternatives to main part of the proposal.<br>&gt;<br>&gt; Questions:<br>&gt; 1. Is it OK that associativity is moved to precedence groups and that<br>&gt; every operator must belong to a precedence group?<br>&gt; 2. Dictionary-like or &quot;functional keywords&quot;? That is, `associativity:<br>&gt; left` or `associativity(left)`? So far, only second form has been used<br>&gt; somewhere inside declarations.<br>&gt; 3. First-lower or first-upper? `additive` or `Additive`?<br>&gt; 4. Empty body or no body? `prefix operator ! { }` or `prefix operator !`?<br>&gt;<br>&gt; Just in case, some questions/concerns copied from previous discussion:<br>&gt;<br>&gt; 1. All precedence groups have a &quot;parent&quot;.<br>&gt; It means, all operators will want to have precedence higher than<br>&gt; Comparative or Ternary, or, at least, Assignment.<br>&gt;<br>&gt; 2. Moreover, I could not find any case where I had to write anything other<br>&gt; than precedence(&gt;, ...)<br>&gt; Of cause, I cheated, because I can control all these declarations.<br>&gt; Mere people will have to use `&lt;` to say that Additive, for example, should<br>&gt; have less priority than their custom operator.<br>&gt;<br>&gt; But... can you build a custom operator where `&lt;` will actually be needed?<br>&gt; I have even stronger doubts on `=`.<br>&gt; Maybe we can even contract this feature to `parent(Comparative)` or<br>&gt; something without losing any expressivity?<br>&gt;<br>&gt; 3. Can we allow operators to have less priority than `=`?<br>&gt; If yes, can you give an example of such operator?<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; 2016-04-08 8:59 GMT+03:00 Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; First of all, sorry for the delay. I still hope to finish the discussion<br>&gt;&gt; and push the proposal to review for Swift 3.0.<br>&gt;&gt; Link for newcomers:<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;<br>&gt;&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in<br>&gt;&gt; the beginning: absense of conflict resolution.<br>&gt;&gt; I wanted lightweight directives, but am moving to closed precedence<br>&gt;&gt; groups.<br>&gt;&gt;<br>&gt;&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I<br>&gt;&gt; still have not heard anything from Core team.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Антон,<br>&gt;&gt;<br>&gt;&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t<br>&gt;&gt; read the upstream thread so I hope this isn’t too duplicative.  Here is my<br>&gt;&gt; 2c:<br>&gt;&gt;<br>&gt;&gt; - I completely agree that numeric precedences are lame, it was always the<br>&gt;&gt; “plan” that they’d be removed someday, but that obviously still hasn’t<br>&gt;&gt; happened :-)<br>&gt;&gt; - I definitely agree that a partial ordering between precedences is all<br>&gt;&gt; that we need/want, and that unspecified relations should be an error.<br>&gt;&gt;<br>&gt;&gt; That said, I feel like #operator is a major syntactic regression, both in<br>&gt;&gt; consistency and predictability.  We use # for two things: directives (like<br>&gt;&gt; #if) and for expressions (#file).  The #operator is a declaration of an<br>&gt;&gt; operator, not an expression or a directive.  For declarations, we<br>&gt;&gt; consistently use a keyword, which allows contextual modifiers before them,<br>&gt;&gt; along with a body (which is sometimes optional for certain kinds of<br>&gt;&gt; decls).  I feel like you’re trying to syntactically reduce the weight of<br>&gt;&gt; something that doesn’t occur very often, which is no real win in<br>&gt;&gt; expressiveness, and harms consistency.<br>&gt;&gt;<br>&gt;&gt; Likewise #precedence is a relationship between two operators.  I’d<br>&gt;&gt; suggest putting them into the body of the operator declaration.<br>&gt;&gt;<br>&gt;&gt; OTOH, the stuff inside the current operator declaration is a random<br>&gt;&gt; series of tokens with no apparent structure.  I think it would be<br>&gt;&gt; reasonable to end up with something like:<br>&gt;&gt;<br>&gt;&gt; infix operator &lt;&gt; {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedenceLessThan: *<br>&gt;&gt;   precedenceEqualTo: -<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; Or whatever.  The rationale here is that “infix” is primal on the<br>&gt;&gt; operator decl (and thus is outside the braces) but the rest of the stuff<br>&gt;&gt; can be omitted, so it goes inside.<br>&gt;&gt;<br>&gt;&gt; Just in terms of the writing of the proposal, in the &quot;Change precedence<br>&gt;&gt; mechanism” keep in mind that swift code generally doesn’t care about the<br>&gt;&gt; order of declarations (it doesn’t parse top down in the file like C does)<br>&gt;&gt; so the example is a bit misleading.<br>&gt;&gt;<br>&gt;&gt; Question for you: have you considered introducing named precedence<br>&gt;&gt; groups, and having the relationships be between those groups?  For example,<br>&gt;&gt; I could see something like:<br>&gt;&gt;<br>&gt;&gt; operator group additive {}<br>&gt;&gt; operator group multiplicative { greaterThan: additive }<br>&gt;&gt; operator group exponential { greaterThan: additive }<br>&gt;&gt;<br>&gt;&gt; Then:<br>&gt;&gt;<br>&gt;&gt; infix operator + {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedence: additive<br>&gt;&gt;  }<br>&gt;&gt; infix operator - {<br>&gt;&gt;   associativity: left<br>&gt;&gt;   precedence: additive<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; etc.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/bc7c8ee2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Based on commit ‘01317e1a’:<br></p><p>I think that it makes sense for membership to live outside of a precedence group. An example is if I wanted to add a new assignment operator ( maybe ??= &#39;assign if nil’), I would want it to have the same precedence as existing assignment operators, including precedence with other custom operators.<br></p><p>Secondly, I think the relationships between precedence groups should be defined outside of an existing precedence group. If I have two libraries that declare operators in their own custom groups, I may need to define a relationship between those groups.<br></p><p>This leads the group declaration itself being just of a name and associativity.<br></p><p>If group precedence is declared externally, there isn’t a need to support ‘&gt;’. Since we are declaring a relationship and not evaluating a relationship, there are side-effects that developers will need to understand if they are trying to comprehend precedence groups in aggregate. Having the groups appear consistently in the same order when defining precedence may help with this.<br></p><p>I still assume these relationships are meant to be constrained to a DAG, although there might be cases where cycles (or even having multiple graphs) would still be unambiguous. I can’t wrap my head around implementation to the point of understanding evaluation if not a DAG yet, nor practical reasons to have cycles in relations.<br></p><p>Two groups may be unable to be declared to be equivalent. First, they need to be of the same associativity. Second are also possibilities of graph cycles once the relationships of both groups are overlaid. This is actually the trouble I alluded to in my first email in the thread.<br></p><p>Finally, an infix operator is part of one and only one group. It might make sense to have a default group (with no associativity) for operators to fall into if they do not declare a precedence group.<br></p><p>Oh wait, Yet another quasi-syntax based on the above:<br></p><p>precedencegroup Additive, associativity: left<br>precedencerelation Additive &lt; Multiplicative<br>precedencerelation Range &lt; Additive<br></p><p>infix operator +, group: Additive<br></p><p>-DW<br></p><p>&gt; On Apr 8, 2016, at 1:28 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The question 4 (`prefix operator ! { }` or `prefix operator !`) seems dead simple, because if we need to declare precedence group in body of infix operators, then other operators should have it for consistency.<br>&gt; <br>&gt; It&#39;s not.<br>&gt; I suggest an alternative syntax for that:<br>&gt; infix operator &lt;&gt; : Comparative<br>&gt; <br>&gt; Colon immediately after the operator may not look the best, but it&#39;s the only disadvantage I can find. It looks like inheritance and has similar meaning.<br>&gt; So, in this scheme, all operators will have no body.<br>&gt; <br>&gt; I also described two methods to declare that operator belongs to a precedence group: in `members` and in operator declaration.<br>&gt; I suggest that this new syntax looks brief/natural enough to remove `members` option entirely. &quot;There should be one - and preferably only one - obvious way to do it.&quot;<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; 2016-04-08 19:59 GMT+03:00 Антон Жилин &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt;:<br>&gt; Thank you for your reply, Chris!<br>&gt; I was thinking about purging directives from the proposal, and that was what I needed to do it.<br>&gt; So, the proposal is now completely overhauled:<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt; <br>&gt; Yes, Maximilian and I have considered operator/precedence groups and they have now moved from alternatives to main part of the proposal.<br>&gt; <br>&gt; Questions:<br>&gt; 1. Is it OK that associativity is moved to precedence groups and that every operator must belong to a precedence group?<br>&gt; 2. Dictionary-like or &quot;functional keywords&quot;? That is, `associativity: left` or `associativity(left)`? So far, only second form has been used somewhere inside declarations.<br>&gt; 3. First-lower or first-upper? `additive` or `Additive`?<br>&gt; 4. Empty body or no body? `prefix operator ! { }` or `prefix operator !`?<br>&gt; <br>&gt; Just in case, some questions/concerns copied from previous discussion:<br>&gt; <br>&gt; 1. All precedence groups have a &quot;parent&quot;.<br>&gt; It means, all operators will want to have precedence higher than Comparative or Ternary, or, at least, Assignment.<br>&gt; <br>&gt; 2. Moreover, I could not find any case where I had to write anything other than precedence(&gt;, ...)<br>&gt; Of cause, I cheated, because I can control all these declarations.<br>&gt; Mere people will have to use `&lt;` to say that Additive, for example, should have less priority than their custom operator.<br>&gt; <br>&gt; But... can you build a custom operator where `&lt;` will actually be needed? I have even stronger doubts on `=`.<br>&gt; Maybe we can even contract this feature to `parent(Comparative)` or something without losing any expressivity?<br>&gt; <br>&gt; 3. Can we allow operators to have less priority than `=`?<br>&gt; If yes, can you give an example of such operator?<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; 2016-04-08 8:59 GMT+03:00 Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt; <br>&gt;&gt; On Apr 7, 2016, at 1:39 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First of all, sorry for the delay. I still hope to finish the discussion and push the proposal to review for Swift 3.0.<br>&gt;&gt; Link for newcomers:<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt;&gt; <br>&gt;&gt; Sadly, I&#39;ve moved into the territory opposite to what I had in mind in the beginning: absense of conflict resolution.<br>&gt;&gt; I wanted lightweight directives, but am moving to closed precedence groups.<br>&gt;&gt; <br>&gt;&gt; It&#39;s just IMHO, and I think I just need input on this from more people. I still have not heard anything from Core team.<br>&gt; <br>&gt; Hi Антон,<br>&gt; <br>&gt; I’m sorry for the delay, I have been out of town recently.  I haven’t read the upstream thread so I hope this isn’t too duplicative.  Here is my 2c:<br>&gt; <br>&gt; - I completely agree that numeric precedences are lame, it was always the “plan” that they’d be removed someday, but that obviously still hasn’t happened :-)<br>&gt; - I definitely agree that a partial ordering between precedences is all that we need/want, and that unspecified relations should be an error.<br>&gt; <br>&gt; That said, I feel like #operator is a major syntactic regression, both in consistency and predictability.  We use # for two things: directives (like #if) and for expressions (#file).  The #operator is a declaration of an operator, not an expression or a directive.  For declarations, we consistently use a keyword, which allows contextual modifiers before them, along with a body (which is sometimes optional for certain kinds of decls).  I feel like you’re trying to syntactically reduce the weight of something that doesn’t occur very often, which is no real win in expressiveness, and harms consistency.<br>&gt; <br>&gt; Likewise #precedence is a relationship between two operators.  I’d suggest putting them into the body of the operator declaration.<br>&gt; <br>&gt; OTOH, the stuff inside the current operator declaration is a random series of tokens with no apparent structure.  I think it would be reasonable to end up with something like:<br>&gt; <br>&gt; infix operator &lt;&gt; {<br>&gt;   associativity: left<br>&gt;   precedenceLessThan: *<br>&gt;   precedenceEqualTo: -<br>&gt;  }<br>&gt; <br>&gt; Or whatever.  The rationale here is that “infix” is primal on the operator decl (and thus is outside the braces) but the rest of the stuff can be omitted, so it goes inside.<br>&gt; <br>&gt; Just in terms of the writing of the proposal, in the &quot;Change precedence mechanism” keep in mind that swift code generally doesn’t care about the order of declarations (it doesn’t parse top down in the file like C does) so the example is a bit misleading.<br>&gt; <br>&gt; Question for you: have you considered introducing named precedence groups, and having the relationships be between those groups?  For example, I could see something like:<br>&gt; <br>&gt; 	operator group additive {}<br>&gt; 	operator group multiplicative { greaterThan: additive }<br>&gt; 	operator group exponential { greaterThan: additive }<br>&gt; <br>&gt; Then:<br>&gt; <br>&gt; infix operator + {<br>&gt;   associativity: left<br>&gt;   precedence: additive<br>&gt;  }<br>&gt; infix operator - {<br>&gt;   associativity: left<br>&gt;   precedence: additive<br>&gt;  }<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/dc16a82f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/dc16a82f/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Inline:<br></p><p>2016-04-09 0:17 GMT+03:00 David Waite &lt;david at alkaline-solutions.com&gt;:<br></p><p>&gt; Based on commit ‘01317e1a’:<br>&gt;<br>&gt; I think that it makes sense for membership to live outside of a precedence<br>&gt; group. An example is if I wanted to add a new assignment operator ( maybe<br>&gt; ??= &#39;assign if nil’), I would want it to have the same precedence as<br>&gt; existing assignment operators, including precedence with other custom<br>&gt; operators.<br>&gt;<br></p><p>Right, the proposal currently allows defining membership both inside and<br>outside the precedence group, but I agree that with terse enough syntax,<br>&quot;outside only&quot; will suffice.<br></p><p>Secondly, I think the relationships between precedence groups should be<br>&gt; defined outside of an existing precedence group. If I have two libraries<br>&gt; that declare operators in their own custom groups, I may need to define a<br>&gt; relationship between those groups.<br>&gt;<br></p><p>This is a highly discussable question. &quot;Outside&quot; option makes it easy to<br>merge standard library operators into a single hierarchy again. Maybe this<br>question can be formulated as follows: should module creator have total<br>control over its operators, or can their behaviour be modified by user?<br></p><p><br>&gt; This leads the group declaration itself being just of a name and<br>&gt; associativity.<br>&gt;<br>&gt; If group precedence is declared externally, there isn’t a need to support<br>&gt; ‘&gt;’. Since we are declaring a relationship and not evaluating a<br>&gt; relationship, there are side-effects that developers will need to<br>&gt; understand if they are trying to comprehend precedence groups in aggregate.<br>&gt; Having the groups appear consistently in the same order when defining<br>&gt; precedence may help with this.<br>&gt;<br></p><p>I don&#39;t think supporting `&gt;` puts much burden on grammar and consistency,<br>but yeah, it gets some points for external precedence.<br></p><p><br>&gt; I still assume these relationships are meant to be constrained to a DAG,<br>&gt; although there might be cases where cycles (or even having multiple graphs)<br>&gt; would still be unambiguous. I can’t wrap my head around implementation to<br>&gt; the point of understanding evaluation if not a DAG yet, nor practical<br>&gt; reasons to have cycles in relations.<br>&gt;<br>&gt; Two groups may be unable to be declared to be equivalent. First, they need<br>&gt; to be of the same associativity. Second are also possibilities of graph<br>&gt; cycles once the relationships of both groups are overlaid. This is actually<br>&gt; the trouble I alluded to in my first email in the thread.<br>&gt;<br></p><p>This time the proposal actually reflects these ideas.<br></p><p>Finally, an infix operator is part of one and only one group. It might make<br>&gt; sense to have a default group (with no associativity) for operators to fall<br>&gt; into if they do not declare a precedence group.<br>&gt;<br></p><p>I have written about creating a separate unnamed group for each operator.<br>That is nonsense, of course, that should be a single named group without<br>associativity.<br></p><p>Oh wait, Yet another quasi-syntax based on the above:<br>&gt;<br>&gt; precedencegroup Additive, associativity: left<br>&gt; precedencerelation Additive &lt; Multiplicative<br>&gt; precedencerelation Range &lt; Additive<br>&gt; infix operator +, group: Additive<br>&gt;<br></p><p>I actually like this syntax (the absence of body, especially), but that<br>commas are inconsistent with the rest of the language. My take at it (hope<br>somebody can do better):<br></p><p>precedencegroup Additive : associativity(left)<br>precedencerelation Additive &lt; Multiplicative<br>precedencerelation Range &lt; Additive<br>infix operator + : Additive<br></p><p><br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Apr 8, 2016, at 1:28 PM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The question 4 (`prefix operator ! { }` or `prefix operator !`) seems<br>&gt; dead simple, because if we need to declare precedence group in body of<br>&gt; infix operators, then other operators should have it for consistency.<br>&gt;<br>&gt; It&#39;s not.<br>&gt; I suggest an alternative syntax for that:<br>&gt; infix operator &lt;&gt; : Comparative<br>&gt;<br>&gt; Colon immediately after the operator may not look the best, but it&#39;s the<br>&gt; only disadvantage I can find. It looks like inheritance and has similar<br>&gt; meaning.<br>&gt; So, in this scheme, all operators will have no body.<br>&gt;<br>&gt; I also described two methods to declare that operator belongs to a<br>&gt; precedence group: in `members` and in operator declaration.<br>&gt; I suggest that this new syntax looks brief/natural enough to remove<br>&gt; `members` option entirely. &quot;There should be one - and preferably only one -<br>&gt; obvious way to do it.&quot;<br>&gt;<br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/1875731b/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  9, 2016 at 06:00:00am</p></header><div class="content"><p>On Apr 8, 2016, at 12:28 PM, Антон Жилин &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; The question 4 (`prefix operator ! { }` or `prefix operator !`) seems dead simple, because if we need to declare precedence group in body of infix operators, then other operators should have it for consistency.<br>&gt; <br>&gt; It&#39;s not.<br>&gt; I suggest an alternative syntax for that:<br>&gt; infix operator &lt;&gt; : Comparative<br>&gt; <br>&gt; Colon immediately after the operator may not look the best, but it&#39;s the only disadvantage I can find. It looks like inheritance and has similar meaning.<br></p><p>I agree, this is an nice approach.  You’re basically saying that the &lt;&gt; operator is a member of the set of Comparative operators, thereby “inheriting” its precedence behaviors.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/e63ab8f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>Interesting model!<br></p><p>If I understand correctly: this changes the precedence from being based on a numeric value, to being represented as a bit of a DAG of precedence groups. A precedence group is defined implicitly for each operator, with one group around each set of operators where equalTo has been declared.<br></p><p>The groups are lazily evaluated, so if an expression can be resolved without ambiguity due to lack of reachability between two individual operators in the DAG, there is no issue/error.<br></p><p>Comments:<br>- I wonder if there are cases in the standard operators which would be better modeled as a non-linear chain.  The compiler could warn around usage which is defined by operator precedence, but is commonly considered ambiguous or error prone. <br></p><p>For example, if users commonly get confused about the conjunctive and disjunctive levels (logical ‘and’ and ‘or’) being different levels with precedence, you could just omit the lessThan relationship between the two of them. The compiler would then error on ambiguous cases, prompting the user to use parenthesis.<br></p><p>- I’d prefer instead of operator precedence groups just being implicit by use of #precedence equalTo, that the operators are bound to a group explicitly. Something like<br>#precedence(+, group: “additive”)<br>#precedence(“additive”, lessThan: “multiplicative”)<br></p><p>However, this may create more issues than it solves (two frameworks creating their own custom operators, putting them in custom precedence groups, and the consumer decides the two precedence groups are really equivalent)<br></p><p>-DW<br></p><p>&gt; On Apr 3, 2016, at 3:36 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators. I insist that this time we should focus less on linguistic aspects.<br>&gt; <br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md &lt;https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/faeeaeb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  4, 2016 at 09:00:00am</p></header><div class="content"><p>In the poposed model, all relations are not transitive. Example:<br></p><p>#precedence(+, lessThan: *)<br>#precedence(*, lessThan: ^)<br>1 ^ 2 + 3  // error<br>#precedence(+, lessThan: ^)<br>1 ^ 2 + 3  // now ok<br></p><p>Would it be better to have such indirect relations inferred? Or would it<br>put too much responsibility on the compiler?<br>Maybe add it to future directions?<br></p><p>Cycles of length &gt;2 are also allowed. This was not added intentionally, but<br>follows from other specified rules.<br>Example: ^ (binary) &lt; &amp; (binary) &lt; + &lt; * &lt; ^ (power). OK, &amp; &lt; + is a bit<br>stretched, otherwise quite logical.<br></p><p>&gt; - I wonder if there are cases in the standard operators which would be<br>better modeled as a non-linear chain.<br>In the standard library, non-linearity will be primarily used to break a<br>single hierarchy into multiple small ones. I doubt that any trees or cycles<br>will form, although that would be good news.<br></p><p>- Anton<br></p><p>2016-04-04 8:55 GMT+03:00 David Waite &lt;david at alkaline-solutions.com&gt;:<br></p><p>&gt; Interesting model!<br>&gt;<br>&gt; If I understand correctly: this changes the precedence from being based on<br>&gt; a numeric value, to being represented as a bit of a DAG of precedence<br>&gt; groups. A precedence group is defined implicitly for each operator, with<br>&gt; one group around each set of operators where equalTo has been declared.<br>&gt;<br>&gt; The groups are lazily evaluated, so if an expression can be resolved<br>&gt; without ambiguity due to lack of reachability between two individual<br>&gt; operators in the DAG, there is no issue/error.<br>&gt;<br>&gt; Comments:<br>&gt; - I wonder if there are cases in the standard operators which would be<br>&gt; better modeled as a non-linear chain.  The compiler could warn around usage<br>&gt; which is defined by operator precedence, but is commonly considered<br>&gt; ambiguous or error prone.<br>&gt;<br>&gt; For example, if users commonly get confused about the conjunctive and<br>&gt; disjunctive levels (logical ‘and’ and ‘or’) being different levels with<br>&gt; precedence, you could just omit the lessThan relationship between the two<br>&gt; of them. The compiler would then error on ambiguous cases, prompting the<br>&gt; user to use parenthesis.<br>&gt;<br>&gt; - I’d prefer instead of operator precedence groups just being implicit by<br>&gt; use of #precedence equalTo, that the operators are bound to a group<br>&gt; explicitly. Something like<br>&gt; #precedence(+, group: “additive”)<br>&gt; #precedence(“additive”, lessThan: “multiplicative”)<br>&gt;<br>&gt; However, this may create more issues than it solves (two frameworks<br>&gt; creating their own custom operators, putting them in custom precedence<br>&gt; groups, and the consumer decides the two precedence groups are really<br>&gt; equivalent)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Apr 3, 2016, at 3:36 AM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift 2.2 is out, and I restart discussion on syntax for custom operators.<br>&gt; I insist that this time we should focus less on linguistic aspects.<br>&gt;<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/64bfd8ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>How is a non-transitive relation different from a conflict?<br>If we use:<br>#precedence(+, lessThan: *)<br>#precedence(*, lessThan: ^)<br>#precedence(^, lessThan: +)<br>Surely that should be an error, even with none of the operators actually<br>used?<br></p><p>The compiler would be asked to verify two things: that the relationships of<br>all operators in the program can be expressed with a topological ordering,<br>and any pair of operators used together in an expression in the program has<br>an unambiguous precedence in that ordering. (I have no idea how relatable<br>this comparison actually is, but it seems like it would be a simpler<br>problem than analysing NSLayoutConstraints for violations.)<br></p><p>On Mon, Apr 4, 2016 at 7:49 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; In the poposed model, all relations are not transitive. Example:<br>&gt;<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, lessThan: ^)<br>&gt; 1 ^ 2 + 3  // error<br>&gt; #precedence(+, lessThan: ^)<br>&gt; 1 ^ 2 + 3  // now ok<br>&gt;<br>&gt; Would it be better to have such indirect relations inferred? Or would it<br>&gt; put too much responsibility on the compiler?<br>&gt; Maybe add it to future directions?<br>&gt;<br>&gt; Cycles of length &gt;2 are also allowed. This was not added intentionally,<br>&gt; but follows from other specified rules.<br>&gt; Example: ^ (binary) &lt; &amp; (binary) &lt; + &lt; * &lt; ^ (power). OK, &amp; &lt; + is a bit<br>&gt; stretched, otherwise quite logical.<br>&gt;<br>&gt; &gt; - I wonder if there are cases in the standard operators which would be<br>&gt; better modeled as a non-linear chain.<br>&gt; In the standard library, non-linearity will be primarily used to break a<br>&gt; single hierarchy into multiple small ones. I doubt that any trees or cycles<br>&gt; will form, although that would be good news.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; 2016-04-04 8:55 GMT+03:00 David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;<br>&gt;&gt; Interesting model!<br>&gt;&gt;<br>&gt;&gt; If I understand correctly: this changes the precedence from being based<br>&gt;&gt; on a numeric value, to being represented as a bit of a DAG of precedence<br>&gt;&gt; groups. A precedence group is defined implicitly for each operator, with<br>&gt;&gt; one group around each set of operators where equalTo has been declared.<br>&gt;&gt;<br>&gt;&gt; The groups are lazily evaluated, so if an expression can be resolved<br>&gt;&gt; without ambiguity due to lack of reachability between two individual<br>&gt;&gt; operators in the DAG, there is no issue/error.<br>&gt;&gt;<br>&gt;&gt; Comments:<br>&gt;&gt; - I wonder if there are cases in the standard operators which would be<br>&gt;&gt; better modeled as a non-linear chain.  The compiler could warn around usage<br>&gt;&gt; which is defined by operator precedence, but is commonly considered<br>&gt;&gt; ambiguous or error prone.<br>&gt;&gt;<br>&gt;&gt; For example, if users commonly get confused about the conjunctive and<br>&gt;&gt; disjunctive levels (logical ‘and’ and ‘or’) being different levels with<br>&gt;&gt; precedence, you could just omit the lessThan relationship between the two<br>&gt;&gt; of them. The compiler would then error on ambiguous cases, prompting the<br>&gt;&gt; user to use parenthesis.<br>&gt;&gt;<br>&gt;&gt; - I’d prefer instead of operator precedence groups just being implicit by<br>&gt;&gt; use of #precedence equalTo, that the operators are bound to a group<br>&gt;&gt; explicitly. Something like<br>&gt;&gt; #precedence(+, group: “additive”)<br>&gt;&gt; #precedence(“additive”, lessThan: “multiplicative”)<br>&gt;&gt;<br>&gt;&gt; However, this may create more issues than it solves (two frameworks<br>&gt;&gt; creating their own custom operators, putting them in custom precedence<br>&gt;&gt; groups, and the consumer decides the two precedence groups are really<br>&gt;&gt; equivalent)<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt; On Apr 3, 2016, at 3:36 AM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift 2.2 is out, and I restart discussion on syntax for custom<br>&gt;&gt; operators. I insist that this time we should focus less on linguistic<br>&gt;&gt; aspects.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/643500cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Custom operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April  4, 2016 at 01:00:00pm</p></header><div class="content"><p>Just to clarify, with currently proposed<br>behaviour, corresponding expressions would be parsed as follows:<br></p><p>a + b * c  // a + (b * c)<br>a * b ^ c  // a * (b ^ c)<br>a ^ b + c  // a ^ (b + c)<br></p><p>The compiler would look only at explicitly stated precedence between two<br>given operators and would not try to use transcendency.<br></p><p>Having said that, at least two opinions were that operators should form a<br>DAG by precedence. If no objections are stated, I will change the proposal<br>accordingly, also without future directions.<br></p><p>On, Apr 4, 2016, Ross O&#39;Brien wrote:<br></p><p>&gt; How is a non-transitive relation different from a conflict?<br>&gt; If we use:<br>&gt; #precedence(+, lessThan: *)<br>&gt; #precedence(*, lessThan: ^)<br>&gt; #precedence(^, lessThan: +)<br>&gt; Surely that should be an error, even with none of the operators actually<br>&gt; used?<br>&gt;<br>&gt; The compiler would be asked to verify two things: that the relationships<br>&gt; of all operators in the program can be expressed with a topological<br>&gt; ordering, and any pair of operators used together in an expression in the<br>&gt; program has an unambiguous precedence in that ordering. (I have no idea how<br>&gt; relatable this comparison actually is, but it seems like it would be a<br>&gt; simpler problem than analysing NSLayoutConstraints for violations.)<br>&gt;<br>&gt; On Mon, Apr 4, 2016 at 7:49 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; In the poposed model, all relations are not transitive. Example:<br>&gt;&gt;<br>&gt;&gt; #precedence(+, lessThan: *)<br>&gt;&gt; #precedence(*, lessThan: ^)<br>&gt;&gt; 1 ^ 2 + 3  // error<br>&gt;&gt; #precedence(+, lessThan: ^)<br>&gt;&gt; 1 ^ 2 + 3  // now ok<br>&gt;&gt;<br>&gt;&gt; Would it be better to have such indirect relations inferred? Or would it<br>&gt;&gt; put too much responsibility on the compiler?<br>&gt;&gt; Maybe add it to future directions?<br>&gt;&gt;<br>&gt;&gt; Cycles of length &gt;2 are also allowed. This was not added intentionally,<br>&gt;&gt; but follows from other specified rules.<br>&gt;&gt; Example: ^ (binary) &lt; &amp; (binary) &lt; + &lt; * &lt; ^ (power). OK, &amp; &lt; + is a bit<br>&gt;&gt; stretched, otherwise quite logical.<br>&gt;&gt;<br>&gt;&gt; &gt; - I wonder if there are cases in the standard operators which would be<br>&gt;&gt; better modeled as a non-linear chain.<br>&gt;&gt; In the standard library, non-linearity will be primarily used to break a<br>&gt;&gt; single hierarchy into multiple small ones. I doubt that any trees or cycles<br>&gt;&gt; will form, although that would be good news.<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; 2016-04-04 8:55 GMT+03:00 David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; Interesting model!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If I understand correctly: this changes the precedence from being based<br>&gt;&gt;&gt; on a numeric value, to being represented as a bit of a DAG of precedence<br>&gt;&gt;&gt; groups. A precedence group is defined implicitly for each operator, with<br>&gt;&gt;&gt; one group around each set of operators where equalTo has been declared.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The groups are lazily evaluated, so if an expression can be resolved<br>&gt;&gt;&gt; without ambiguity due to lack of reachability between two individual<br>&gt;&gt;&gt; operators in the DAG, there is no issue/error.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Comments:<br>&gt;&gt;&gt; - I wonder if there are cases in the standard operators which would be<br>&gt;&gt;&gt; better modeled as a non-linear chain.  The compiler could warn around usage<br>&gt;&gt;&gt; which is defined by operator precedence, but is commonly considered<br>&gt;&gt;&gt; ambiguous or error prone.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, if users commonly get confused about the conjunctive and<br>&gt;&gt;&gt; disjunctive levels (logical ‘and’ and ‘or’) being different levels with<br>&gt;&gt;&gt; precedence, you could just omit the lessThan relationship between the two<br>&gt;&gt;&gt; of them. The compiler would then error on ambiguous cases, prompting the<br>&gt;&gt;&gt; user to use parenthesis.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - I’d prefer instead of operator precedence groups just being implicit<br>&gt;&gt;&gt; by use of #precedence equalTo, that the operators are bound to a group<br>&gt;&gt;&gt; explicitly. Something like<br>&gt;&gt;&gt; #precedence(+, group: “additive”)<br>&gt;&gt;&gt; #precedence(“additive”, lessThan: “multiplicative”)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this may create more issues than it solves (two frameworks<br>&gt;&gt;&gt; creating their own custom operators, putting them in custom precedence<br>&gt;&gt;&gt; groups, and the consumer decides the two precedence groups are really<br>&gt;&gt;&gt; equivalent)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 3, 2016, at 3:36 AM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift 2.2 is out, and I restart discussion on syntax for custom<br>&gt;&gt;&gt; operators. I insist that this time we should focus less on linguistic<br>&gt;&gt;&gt; aspects.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/operator-precedence/proposals/NNNN-operator-precedence.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/94de8511/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
