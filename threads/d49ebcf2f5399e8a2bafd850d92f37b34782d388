<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0cb372b61e8fab9285dd7660f3b73af?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at brentdax.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>A discussion in the &quot;mapValues&quot; thread reminded me of a longstanding issue I have with Swift.<br></p><p>`enumerate()` is an attractive nuisance. (That is, it looks like the thing you want, but it&#39;s not actually the right one.) Most people use it because they want to enumerate over indices and elements at the same time. In reality, though, the first element of an `enumerate()` tuple is not the index—it&#39;s a monotonically increasing integer starting at 0. That *happens* to work for `Array`:<br></p><p>&gt; 	  1&gt;     let array = Array(0..&lt;10) <br>&gt; 	  2.     for (i, elem) in array.enumerate() { <br>&gt; 	  3.         print(array[i]) <br>&gt; 	  4.     }<br>&gt; 	0<br>&gt; 	1<br>&gt; 	2<br>&gt; 	3<br>&gt; 	4<br>&gt; 	5<br>&gt; 	6<br>&gt; 	7<br>&gt; 	8<br>&gt; 	9<br></p><p>But if you stray even a little bit from the golden path, things start to go wrong:<br></p><p>&gt; 	  5&gt;     let range = array[2..&lt;8]<br>&gt; 	  6.     for (i, elem) in range.enumerate() { <br>&gt; 	  7.         print(range[i])<br>&gt; 	  8.     } <br>&gt; 	fatal error: Index out of bounds<br></p><p>You can scarcely blame users for making this mistake, though—&quot;The Swift Programming Language&quot; encourages the misconception. &quot;Iterating Over an Array&quot; in &quot;Collection Types&quot;:<br></p><p>&gt; If you need the integer index of each item as well as its value, use the `enumerate()` method to iterate over the array instead. For each item in the array, the `enumerate()` method returns a tuple composed of the index and the value for that item.<br></p><p><br>While the text is technically accurate—it only talks about iterating over arrays and the numbers generated by `enumerate()` happen to correspond to array indices—it creates a false implication that `enumerate()` is defined to return indices, which isn&#39;t true of other collections.<br></p><p>This is made worse by the fact that `enumerate()` is not really a good name. It is not a common word, so people don&#39;t read it and immediately understand what it does; they memorize a Swift-specific meaning, and that meaning may incorporate the misconception that `enumerate()` includes indices. It is also not technically accurate: although it has &quot;number&quot; in its Latin roots, &quot;enumerate&quot; means either &quot;to count&quot; or &quot;to list&quot;, not &quot;to number&quot; (i.e. assign numbers to). I know `enumerate()` is used in a couple of other languages (certainly Python, possibly others), but I don&#39;t think that overrides the fact that it&#39;s confusing.<br></p><p>I have three possible solutions to propose.<br></p><p><br></p><p>OPTION ONE<br></p><p>* Remove `enumerate()`.<br></p><p>* Provide a type and postfix operator which allows you to write an infinite sequence as `0...`. (This might call a ClosedRange constructor which constrains the type to a protocol which provides `max`. This would imply that `FloatingPoint` and `Integer` protocols would need to conform to a common protocol declaring a `max` property, and in the case of `FloatingPoint`, `max` should probably be positive infinity.)<br></p><p>* Fix-It calls to `x.enumerate()` as `zip(0..., x)`. This is more complicated to look at, but it&#39;s *far* more explicit about what the operation actually does. (For bonus points, we could perhaps look at how the EnumerateSequence is used, and if the number is used as an index, go with `zip(x.indices, x)` instead.)<br></p><p><br></p><p>OPTION TWO<br></p><p>* Rename `enumerate()` to something more explicit, like `withIntegers()` or `numbered()`. (It might even make sense to add a `from:` parameter which defaults to 0.)<br></p><p>* Add to Collection an equivalent method with a similar name that provides indices, like `withIndices()` or `indexed()`.<br></p><p>* Fix-It calls to `enumerate()` into either `numbered()` or `indexed()` (or whatever they end up being called) depending on the way they are used.<br></p><p><br></p><p>OPTION THREE<br></p><p>Combine the other two options:<br></p><p>* Provide the infinite numeric sequence type from Option One.<br></p><p>* Provide `numbered()` and `indexed()` (or whatever) methods which are explicitly typed to merely zip over the sequence/collection with an infinite integer sequence/Indices collection.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 16, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m in support of a method of getting a sequence of (Index,Value) pairs (as<br>you know from the other thread). I think I&#39;m leaning toward option three if<br>it&#39;s equivalent to `zip(self.indices, self)`, ideally as a concise property<br>like keys/values on a Dictionary.<br></p><p>I&#39;ve been using zip in production. I presumed enumerate was intended for<br>enumerating indices, and that it had just been forgotten when the slice<br>changes went through. I&#39;m in favour of removing it.<br></p><p><br>On Sat, Apr 16, 2016 at 7:59 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A discussion in the &quot;mapValues&quot; thread reminded me of a longstanding issue<br>&gt; I have with Swift.<br>&gt;<br>&gt; `enumerate()` is an attractive nuisance. (That is, it looks like the thing<br>&gt; you want, but it&#39;s not actually the right one.) Most people use it because<br>&gt; they want to enumerate over indices and elements at the same time. In<br>&gt; reality, though, the first element of an `enumerate()` tuple is not the<br>&gt; index—it&#39;s a monotonically increasing integer starting at 0. That *happens*<br>&gt; to work for `Array`:<br>&gt;<br>&gt; &gt;         1&gt;     let array = Array(0..&lt;10)<br>&gt; &gt;         2.     for (i, elem) in array.enumerate() {<br>&gt; &gt;         3.         print(array[i])<br>&gt; &gt;         4.     }<br>&gt; &gt;       0<br>&gt; &gt;       1<br>&gt; &gt;       2<br>&gt; &gt;       3<br>&gt; &gt;       4<br>&gt; &gt;       5<br>&gt; &gt;       6<br>&gt; &gt;       7<br>&gt; &gt;       8<br>&gt; &gt;       9<br>&gt;<br>&gt; But if you stray even a little bit from the golden path, things start to<br>&gt; go wrong:<br>&gt;<br>&gt; &gt;         5&gt;     let range = array[2..&lt;8]<br>&gt; &gt;         6.     for (i, elem) in range.enumerate() {<br>&gt; &gt;         7.         print(range[i])<br>&gt; &gt;         8.     }<br>&gt; &gt;       fatal error: Index out of bounds<br>&gt;<br>&gt; You can scarcely blame users for making this mistake, though—&quot;The Swift<br>&gt; Programming Language&quot; encourages the misconception. &quot;Iterating Over an<br>&gt; Array&quot; in &quot;Collection Types&quot;:<br>&gt;<br>&gt; &gt; If you need the integer index of each item as well as its value, use the<br>&gt; `enumerate()` method to iterate over the array instead. For each item in<br>&gt; the array, the `enumerate()` method returns a tuple composed of the index<br>&gt; and the value for that item.<br>&gt;<br>&gt;<br>&gt; While the text is technically accurate—it only talks about iterating over<br>&gt; arrays and the numbers generated by `enumerate()` happen to correspond to<br>&gt; array indices—it creates a false implication that `enumerate()` is defined<br>&gt; to return indices, which isn&#39;t true of other collections.<br>&gt;<br>&gt; This is made worse by the fact that `enumerate()` is not really a good<br>&gt; name. It is not a common word, so people don&#39;t read it and immediately<br>&gt; understand what it does; they memorize a Swift-specific meaning, and that<br>&gt; meaning may incorporate the misconception that `enumerate()` includes<br>&gt; indices. It is also not technically accurate: although it has &quot;number&quot; in<br>&gt; its Latin roots, &quot;enumerate&quot; means either &quot;to count&quot; or &quot;to list&quot;, not &quot;to<br>&gt; number&quot; (i.e. assign numbers to). I know `enumerate()` is used in a couple<br>&gt; of other languages (certainly Python, possibly others), but I don&#39;t think<br>&gt; that overrides the fact that it&#39;s confusing.<br>&gt;<br>&gt; I have three possible solutions to propose.<br>&gt;<br>&gt;<br>&gt;<br>&gt; OPTION ONE<br>&gt;<br>&gt; * Remove `enumerate()`.<br>&gt;<br>&gt; * Provide a type and postfix operator which allows you to write an<br>&gt; infinite sequence as `0...`. (This might call a ClosedRange constructor<br>&gt; which constrains the type to a protocol which provides `max`. This would<br>&gt; imply that `FloatingPoint` and `Integer` protocols would need to conform to<br>&gt; a common protocol declaring a `max` property, and in the case of<br>&gt; `FloatingPoint`, `max` should probably be positive infinity.)<br>&gt;<br>&gt; * Fix-It calls to `x.enumerate()` as `zip(0..., x)`. This is more<br>&gt; complicated to look at, but it&#39;s *far* more explicit about what the<br>&gt; operation actually does. (For bonus points, we could perhaps look at how<br>&gt; the EnumerateSequence is used, and if the number is used as an index, go<br>&gt; with `zip(x.indices, x)` instead.)<br>&gt;<br>&gt;<br>&gt;<br>&gt; OPTION TWO<br>&gt;<br>&gt; * Rename `enumerate()` to something more explicit, like `withIntegers()`<br>&gt; or `numbered()`. (It might even make sense to add a `from:` parameter which<br>&gt; defaults to 0.)<br>&gt;<br>&gt; * Add to Collection an equivalent method with a similar name that provides<br>&gt; indices, like `withIndices()` or `indexed()`.<br>&gt;<br>&gt; * Fix-It calls to `enumerate()` into either `numbered()` or `indexed()`<br>&gt; (or whatever they end up being called) depending on the way they are used.<br>&gt;<br>&gt;<br>&gt;<br>&gt; OPTION THREE<br>&gt;<br>&gt; Combine the other two options:<br>&gt;<br>&gt; * Provide the infinite numeric sequence type from Option One.<br>&gt;<br>&gt; * Provide `numbered()` and `indexed()` (or whatever) methods which are<br>&gt; explicitly typed to merely zip over the sequence/collection with an<br>&gt; infinite integer sequence/Indices collection.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/3bf2985d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 8:09 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m in support of a method of getting a sequence of (Index,Value) pairs (as you know from the other thread). I think I&#39;m leaning toward option three if it&#39;s equivalent to `zip(self.indices, self)`, ideally as a concise property like keys/values on a Dictionary.<br>&gt; <br>&gt; I&#39;ve been using zip in production. I presumed enumerate was intended for enumerating indices, and that it had just been forgotten when the slice changes went through. I&#39;m in favour of removing it.<br></p><p>Instead of removing it, how about just fixing it so that it returns the proper indexes rather than arbitrary numbers?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/641a5bf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 16, 2016 at 11:00:00am</p></header><div class="content"><p>I support a fixed version. I don&#39;t think that&#39;s mutually exclusive with<br>removing enumerate.<br></p><p>This thread seems to be a result of a misused API, so I think it&#39;s<br>necessary to make it obvious when that API changes. I think we&#39;d want a<br>period of deprecation with both enumerate() and a new (hopefully more clear<br>and concise) method, so that people can fix their code.<br></p><p>I think this would be a good change:<br></p><p>+ @available(*, deprecated, message=&quot;it will be removed in Swift 3&quot;)<br>  public func enumerate() -&gt; EnumerateSequence&lt;Self&gt;<br>+ public func indexed() -&gt; Zip2Sequence&lt;Self.Index,Self&gt; { return<br>zip(self.indices, self) }<br></p><p><br></p><p>On Sat, Apr 16, 2016 at 11:12 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Apr 15, 2016, at 8:09 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I&#39;m in support of a method of getting a sequence of (Index,Value) pairs<br>&gt; (as you know from the other thread). I think I&#39;m leaning toward option<br>&gt; three if it&#39;s equivalent to `zip(self.indices, self)`, ideally as a concise<br>&gt; property like keys/values on a Dictionary.<br>&gt;<br>&gt; I&#39;ve been using zip in production. I presumed enumerate was intended for<br>&gt; enumerating indices, and that it had just been forgotten when the slice<br>&gt; changes went through. I&#39;m in favour of removing it.<br>&gt;<br>&gt;<br>&gt; Instead of removing it, how about just fixing it so that it returns the<br>&gt; proper indexes rather than arbitrary numbers?<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/4bf7fe39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 16, 2016 at 12:00:00pm</p></header><div class="content"><p>I would suggest an alternative; changing Range so that it is indexed like<br>an array, an Int from 0 to count - 1. Such that aRange[index] is defined as<br>start + index * stride. This will eliminate the problems with enumerate. A<br>Range&#39;s generic type would be constrained to be an Arithmetic type, see<br>extended floating point proposal.<br></p><p>On Saturday, 16 April 2016, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I support a fixed version. I don&#39;t think that&#39;s mutually exclusive with<br>&gt; removing enumerate.<br>&gt;<br>&gt; This thread seems to be a result of a misused API, so I think it&#39;s<br>&gt; necessary to make it obvious when that API changes. I think we&#39;d want a<br>&gt; period of deprecation with both enumerate() and a new (hopefully more clear<br>&gt; and concise) method, so that people can fix their code.<br>&gt;<br>&gt; I think this would be a good change:<br>&gt;<br>&gt; + @available(*, deprecated, message=&quot;it will be removed in Swift 3&quot;)<br>&gt;   public func enumerate() -&gt; EnumerateSequence&lt;Self&gt;<br>&gt; + public func indexed() -&gt; Zip2Sequence&lt;Self.Index,Self&gt; { return zip(self.indices, self) }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Apr 16, 2016 at 11:12 AM, Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cocoadev at charlessoft.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; On Apr 15, 2016, at 8:09 PM, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m in support of a method of getting a sequence of (Index,Value) pairs<br>&gt;&gt; (as you know from the other thread). I think I&#39;m leaning toward option<br>&gt;&gt; three if it&#39;s equivalent to `zip(self.indices, self)`, ideally as a concise<br>&gt;&gt; property like keys/values on a Dictionary.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve been using zip in production. I presumed enumerate was intended for<br>&gt;&gt; enumerating indices, and that it had just been forgotten when the slice<br>&gt;&gt; changes went through. I&#39;m in favour of removing it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Instead of removing it, how about just fixing it so that it returns the<br>&gt;&gt; proper indexes rather than arbitrary numbers?<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/8ac13134/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; I would suggest an alternative; changing Range so that it is indexed like an array, an Int from 0 to count - 1. Such that aRange[index] is defined as start + index * stride. This will eliminate the problems with enumerate. A Range&#39;s generic type would be constrained to be an Arithmetic type, see extended floating point proposal. <br></p><p>That papers over the problem for Slice/Range specifically, but it doesn&#39;t fix it for types with non-integer indices, like Dictionary and Set. enumerate() is not meant to be used for the purpose to which it is usually put.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 17, 2016 at 08:00:00am</p></header><div class="content"><p>I would suggest enumerate only for types that are subscriptable and that it<br>be defined as their (index, value) set that iterates in the collection&#39;s<br>indices order. IE:<br></p><p>    for index in collection.indices {<br>        let value = collection[index]<br>        ...<br>    }<br></p><p>and<br></p><p>    for (index, value) in collection.enumerate {<br>        ...<br>    }<br></p><p>are equivalent.<br></p><p>With the above definition I would suggest a name change to entries, since a<br>Dictionary&#39;s keys are not necessarily numbers, hence enumerate is<br>misleading.<br></p><p>Nothing for Set since it isn&#39;t subscriptable.<br></p><p>On Saturday, 16 April 2016, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I would suggest an alternative; changing Range so that it is indexed<br>&gt; like an array, an Int from 0 to count - 1. Such that aRange[index] is<br>&gt; defined as start + index * stride. This will eliminate the problems with<br>&gt; enumerate. A Range&#39;s generic type would be constrained to be an Arithmetic<br>&gt; type, see extended floating point proposal.<br>&gt;<br>&gt; That papers over the problem for Slice/Range specifically, but it doesn&#39;t<br>&gt; fix it for types with non-integer indices, like Dictionary and Set.<br>&gt; enumerate() is not meant to be used for the purpose to which it is usually<br>&gt; put.<br></p><p><br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/ba7691a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 16, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; With the above definition I would suggest a name change to entries, since a Dictionary&#39;s keys are not necessarily numbers, hence enumerate is misleading. <br>&gt; <br>&gt; Nothing for Set since it isn&#39;t subscriptable. <br></p><p>I think you&#39;re slightly confused. All Collections have an Index. Dictionary&#39;s Index is not its Key; it is an opaque type which references an entry in its internal table. Set also has an Index; again, it is an opaque type which references an entry in its internal table. Your `enumerate()` (or my `indexed()`) would return these opaque `Index`es on all of these types.<br></p><p>If you want Array to return `(Int, Element)`, Dictionary to return `(Key, Value)`, and Set to not have the operation at all, you&#39;re describing something ad-hoc and entirely disconnected from the Collection type.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 18, 2016 at 08:00:00am</p></header><div class="content"><p>Yes I am proposing something like protocol Subscriptable that defines the<br>subscript operation and indices and entries properties.<br></p><p>On Sunday, 17 April 2016, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt; &gt; With the above definition I would suggest a name change to entries,<br>&gt; since a Dictionary&#39;s keys are not necessarily numbers, hence enumerate is<br>&gt; misleading.<br>&gt; &gt;<br>&gt; &gt; Nothing for Set since it isn&#39;t subscriptable.<br>&gt;<br>&gt; I think you&#39;re slightly confused. All Collections have an Index.<br>&gt; Dictionary&#39;s Index is not its Key; it is an opaque type which references an<br>&gt; entry in its internal table. Set also has an Index; again, it is an opaque<br>&gt; type which references an entry in its internal table. Your `enumerate()`<br>&gt; (or my `indexed()`) would return these opaque `Index`es on all of these<br>&gt; types.<br>&gt;<br>&gt; If you want Array to return `(Int, Element)`, Dictionary to return `(Key,<br>&gt; Value)`, and Set to not have the operation at all, you&#39;re describing<br>&gt; something ad-hoc and entirely disconnected from the Collection type.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/8f69b022/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 16, 2016 at 03:00:00pm</p></header><div class="content"><p>I have to agree with those that simply want enumerate() fixed. There are many modern languages that have a similar function, such as Ruby.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 17, 2016 at 06:00:00pm</p></header><div class="content"><p>If something is to happen I cast my vote for #2.<br></p><p>I actually—and intentionally—use what that would call `numbered()` rather frequently; it’s not hard to write but not having to write it is nicer.<br></p><p>Since the “indexed” version is also useful it’d be nice to have both, and with unambiguous names.<br></p><p>&gt; On Apr 15, 2016, at 4:59 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A discussion in the &quot;mapValues&quot; thread reminded me of a longstanding issue I have with Swift.<br>&gt; <br>&gt; `enumerate()` is an attractive nuisance. (That is, it looks like the thing you want, but it&#39;s not actually the right one.) Most people use it because they want to enumerate over indices and elements at the same time. In reality, though, the first element of an `enumerate()` tuple is not the index—it&#39;s a monotonically increasing integer starting at 0. That *happens* to work for `Array`:<br>&gt; <br>&gt;&gt; 	  1&gt;     let array = Array(0..&lt;10) <br>&gt;&gt; 	  2.     for (i, elem) in array.enumerate() { <br>&gt;&gt; 	  3.         print(array[i]) <br>&gt;&gt; 	  4.     }<br>&gt;&gt; 	0<br>&gt;&gt; 	1<br>&gt;&gt; 	2<br>&gt;&gt; 	3<br>&gt;&gt; 	4<br>&gt;&gt; 	5<br>&gt;&gt; 	6<br>&gt;&gt; 	7<br>&gt;&gt; 	8<br>&gt;&gt; 	9<br>&gt; <br>&gt; But if you stray even a little bit from the golden path, things start to go wrong:<br>&gt; <br>&gt;&gt; 	  5&gt;     let range = array[2..&lt;8]<br>&gt;&gt; 	  6.     for (i, elem) in range.enumerate() { <br>&gt;&gt; 	  7.         print(range[i])<br>&gt;&gt; 	  8.     } <br>&gt;&gt; 	fatal error: Index out of bounds<br>&gt; <br>&gt; You can scarcely blame users for making this mistake, though—&quot;The Swift Programming Language&quot; encourages the misconception. &quot;Iterating Over an Array&quot; in &quot;Collection Types&quot;:<br>&gt; <br>&gt;&gt; If you need the integer index of each item as well as its value, use the `enumerate()` method to iterate over the array instead. For each item in the array, the `enumerate()` method returns a tuple composed of the index and the value for that item.<br>&gt; <br>&gt; <br>&gt; While the text is technically accurate—it only talks about iterating over arrays and the numbers generated by `enumerate()` happen to correspond to array indices—it creates a false implication that `enumerate()` is defined to return indices, which isn&#39;t true of other collections.<br>&gt; <br>&gt; This is made worse by the fact that `enumerate()` is not really a good name. It is not a common word, so people don&#39;t read it and immediately understand what it does; they memorize a Swift-specific meaning, and that meaning may incorporate the misconception that `enumerate()` includes indices. It is also not technically accurate: although it has &quot;number&quot; in its Latin roots, &quot;enumerate&quot; means either &quot;to count&quot; or &quot;to list&quot;, not &quot;to number&quot; (i.e. assign numbers to). I know `enumerate()` is used in a couple of other languages (certainly Python, possibly others), but I don&#39;t think that overrides the fact that it&#39;s confusing.<br>&gt; <br>&gt; I have three possible solutions to propose.<br>&gt; <br>&gt; <br>&gt; <br>&gt; OPTION ONE<br>&gt; <br>&gt; * Remove `enumerate()`.<br>&gt; <br>&gt; * Provide a type and postfix operator which allows you to write an infinite sequence as `0...`. (This might call a ClosedRange constructor which constrains the type to a protocol which provides `max`. This would imply that `FloatingPoint` and `Integer` protocols would need to conform to a common protocol declaring a `max` property, and in the case of `FloatingPoint`, `max` should probably be positive infinity.)<br>&gt; <br>&gt; * Fix-It calls to `x.enumerate()` as `zip(0..., x)`. This is more complicated to look at, but it&#39;s *far* more explicit about what the operation actually does. (For bonus points, we could perhaps look at how the EnumerateSequence is used, and if the number is used as an index, go with `zip(x.indices, x)` instead.)<br>&gt; <br>&gt; <br>&gt; <br>&gt; OPTION TWO<br>&gt; <br>&gt; * Rename `enumerate()` to something more explicit, like `withIntegers()` or `numbered()`. (It might even make sense to add a `from:` parameter which defaults to 0.)<br>&gt; <br>&gt; * Add to Collection an equivalent method with a similar name that provides indices, like `withIndices()` or `indexed()`.<br>&gt; <br>&gt; * Fix-It calls to `enumerate()` into either `numbered()` or `indexed()` (or whatever they end up being called) depending on the way they are used.<br>&gt; <br>&gt; <br>&gt; <br>&gt; OPTION THREE<br>&gt; <br>&gt; Combine the other two options:<br>&gt; <br>&gt; * Provide the infinite numeric sequence type from Option One.<br>&gt; <br>&gt; * Provide `numbered()` and `indexed()` (or whatever) methods which are explicitly typed to merely zip over the sequence/collection with an infinite integer sequence/Indices collection.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>April 17, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 15 avr. 2016 à 17:59, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; A discussion in the &quot;mapValues&quot; thread reminded me of a longstanding issue I have with Swift.<br>&gt; <br>&gt; `enumerate()` is an attractive nuisance. (That is, it looks like the thing you want, but it&#39;s not actually the right one.) Most people use it because they want to enumerate over indices and elements at the same time. In reality, though, the first element of an `enumerate()` tuple is not the index—it&#39;s a monotonically increasing integer starting at 0. That *happens* to work for `Array`:<br>&gt; <br>&gt;&gt;    1&gt;     let array = Array(0..&lt;10) <br>&gt;&gt;    2.     for (i, elem) in array.enumerate() { <br>&gt;&gt;    3.         print(array[i]) <br>&gt;&gt;    4.     }<br>&gt;&gt;  0<br>&gt;&gt;  1<br>&gt;&gt;  2<br>&gt;&gt;  3<br>&gt;&gt;  4<br>&gt;&gt;  5<br>&gt;&gt;  6<br>&gt;&gt;  7<br>&gt;&gt;  8<br>&gt;&gt;  9<br>&gt; <br>&gt; But if you stray even a little bit from the golden path, things start to go wrong:<br>&gt; <br>&gt;&gt;    5&gt;     let range = array[2..&lt;8]<br>&gt;&gt;    6.     for (i, elem) in range.enumerate() { <br>&gt;&gt;    7.         print(range[i])<br>&gt;&gt;    8.     } <br>&gt;&gt;  fatal error: Index out of bounds<br>&gt; <br>&gt; You can scarcely blame users for making this mistake, though—&quot;The Swift Programming Language&quot; encourages the misconception. &quot;Iterating Over an Array&quot; in &quot;Collection Types&quot;:<br>&gt; <br>&gt;&gt; If you need the integer index of each item as well as its value, use the `enumerate()` method to iterate over the array instead. For each item in the array, the `enumerate()` method returns a tuple composed of the index and the value for that item.<br>&gt; <br>&gt; <br>&gt; While the text is technically accurate—it only talks about iterating over arrays and the numbers generated by `enumerate()` happen to correspond to array indices—it creates a false implication that `enumerate()` is defined to return indices, which isn&#39;t true of other collections.<br>&gt; <br>&gt; This is made worse by the fact that `enumerate()` is not really a good name. It is not a common word, so people don&#39;t read it and immediately understand what it does; they memorize a Swift-specific meaning, and that meaning may incorporate the misconception that `enumerate()` includes indices. It is also not technically accurate: although it has &quot;number&quot; in its Latin roots, &quot;enumerate&quot; means either &quot;to count&quot; or &quot;to list&quot;, not &quot;to number&quot; (i.e. assign numbers to). I know `enumerate()` is used in a couple of other languages (certainly Python, possibly others), but I don&#39;t think that overrides the fact that it&#39;s confusing.<br></p><p>I see this purely as a documentation issue. It should clearly state the number is not to be used to subscript into the array. Even &#39;indices&#39; likely warrant a warning that it is pointless to use in some construct such as:<br></p><p>for i in array.filter({ $0 % 2 == 0 }).indices { print(&quot;\(i) is not to index array&quot;) }<br></p><p>Which of course can be safely be written as<br></p><p>for i in array.indices where array[i] % 2 == 0 { print(&quot;\(i) can be used as subscript&quot;) }<br></p><p>If we want to have a way to safely subscript into the original array for all possible use cases, we may need a way to &quot;dictionarize&quot; the array.<br></p><p>Providing a new &#39;enumerated()&#39; which returns the proper array subscript for the simple case where the array is not post-processed (with filter for example) could lead to a false sense of safety when using such construct as subscript into the array.<br></p><p><br>Dany<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
