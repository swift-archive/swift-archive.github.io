<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt; except for the renaming of precondition() to require(). I think it is<br>&gt; an improvement that it describes an action now, just like assert().<br></p><p>Interestingly, I was the one that insisted on that change, as I felt<br>“precondition” was too much of a term-of-art and “require” would be more<br>accessible, but I am now regretting that decision.  This function is not<br>conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>“precondition” conveyed that aspect much better, IMO.<br></p><p>&gt;<br>&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt;&gt; On Jan 25, 2016, at 7:40 AM, Radosław Pietruszewski via<br>&gt;&gt; swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Just like with SE-0005<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;,<br>&gt;&gt; I’m overwhelmingly for this proposal. The Guidelines, as a whole do<br>&gt;&gt; a great job at making Swift APIs more consistent and clearer, and<br>&gt;&gt; applying them to the Swift stdlib is an important first step.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Nitpicks, criticisms and suggestions:<br>&gt;&gt; <br>&gt;&gt; == precondition was renamed to require ==<br>&gt;&gt; <br>&gt;&gt; This might be confusing to newcomers, as many languages use the word<br>&gt;&gt; `require` as a keyword for what we&#39;d call `import`. Although a bit<br>&gt;&gt; more technical, `precondition` is unambiguous and still easily<br>&gt;&gt; understandable. I feel like `required` does more damage than good.<br>&gt;&gt; <br>&gt;&gt; == Removed Type from protocol names ==<br>&gt;&gt; <br>&gt;&gt; Perhaps I’ve missed some discussion about this and I don’t see the<br>&gt;&gt; context, but I’m not sure this is a positive change.<br>&gt;&gt; <br>&gt;&gt; I fear this might be confusing in practice, at least in some<br>&gt;&gt; contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or<br>&gt;&gt; &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”,<br>&gt;&gt; “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will<br>&gt;&gt; naturally go for `Bool`, `Int`, and `Array` anyway. But I can<br>&gt;&gt; imagine a lot of confusion if someone tried that anyway, or perhaps<br>&gt;&gt; saw that in the autocompletion, or the standard library browser<br>&gt;&gt; (with no intention of using the protocol).<br>&gt;&gt; <br>&gt;&gt; I’m all for removing unnecessary noise and verbosity, but I think I<br>&gt;&gt; would err on explicitness side here. It seemed like the -able/-Type<br>&gt;&gt; convention did a good job disambiguating types you can actually<br>&gt;&gt; instantiate from protocols, with very little “verbosity cost”.<br>&gt;&gt; <br>&gt;&gt; == sort() =&gt; sorted(), sortInPlace() =&gt; sort() etc ==<br>&gt;&gt; <br>&gt;&gt; I’m torn on this.<br>&gt;&gt; <br>&gt;&gt; Frankly, I find both the “foo/fooInPlace” and “bar/barred”<br>&gt;&gt; conventions awkward. Both seem weird. “InPlace” isn’t something I<br>&gt;&gt; recall seeing anywhere else in API naming, and seems a bizarre way<br>&gt;&gt; of signifying mutability. “-ed” doesn’t work with all words, so you<br>&gt;&gt; sometimes have to go with “-ing”, or give up and cry. And then you<br>&gt;&gt; have inconsistency that “-InPlace” doesn’t seem to have. Also,<br>&gt;&gt; -ed/-ing can sometimes be difficult to write, especially for<br>&gt;&gt; non-natives because of the “last letter is doubled” rule for some<br>&gt;&gt; words.<br>&gt;&gt; <br>&gt;&gt; But my biggest problem with this change is that IMHO we should<br>&gt;&gt; encourage to use the transforming (non-mutating) variants by<br>&gt;&gt; default. One way to achieve this as an API designer and slightly<br>&gt;&gt; push people towards doing what’s considered best practice is to make<br>&gt;&gt; the preferable variant easier to type. This might be a subtle<br>&gt;&gt; change, but I think it matters. Before, if you really wanted to<br>&gt;&gt; mutate something in place, you had to do that extra little bit of<br>&gt;&gt; work typing “sortInPlace”, whereas what would be preferable most of<br>&gt;&gt; the time had a simpler, shorter form: “sort” and would appear<br>&gt;&gt; earlier in autocomplete.<br>&gt;&gt; <br>&gt;&gt; == -ings in argument names ==<br>&gt;&gt; <br>&gt;&gt; I’ve noticed these few tweaks in naming:<br>&gt;&gt; <br>&gt;&gt;&gt; -  mutating func removeAll(keepCapacity keepCapacity: Bool = false)<br>&gt;&gt;&gt; +  mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public func transcode&lt;...&gt;(...<br>&gt;&gt;&gt; -  stopOnError: Bool<br>&gt;&gt;&gt; +  stoppingOnError: Bool<br>&gt;&gt;&gt;  ) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  +  public init(allocatingCapacity count: Int)<br>&gt;&gt; <br>&gt;&gt; I&#39;m against this change. While I&#39;m not fully convinced of the<br>&gt;&gt; -ed/-ing rule for methods and properties, it does an important job<br>&gt;&gt; by conveying the non-mutating semantics of a symbol described. In<br>&gt;&gt; case of argument names, this rationale no longer applies.<br>&gt;&gt; <br>&gt;&gt; The only reason to write &quot;stoppingOnError&quot; instead of &quot;stopOnError&quot;<br>&gt;&gt; is to make method invocations sound more like real English<br>&gt;&gt; sentences. This is the conventional Objective-C thinking the<br>&gt;&gt; Guidelines largely step back from. In my opinion, this is futile and<br>&gt;&gt; provides no readability benefits in this context. Method invocations<br>&gt;&gt; are _not_ sentences. It&#39;s not English, it&#39;s code. And while making<br>&gt;&gt; method names blatantly gramatically incorrect doesn&#39;t help<br>&gt;&gt; readability, neither does forcing `-ing` endings to all boolean<br>&gt;&gt; function arguments.<br>&gt;&gt; <br>&gt;&gt; The only thing it does is it adds a few extra characters, an extra<br>&gt;&gt; word ending the reader has to parse and understand. I know that it&#39;s<br>&gt;&gt; a non-goal to make Swift code as terse as possible, and I&#39;m not<br>&gt;&gt; arguing for that. But the Guidelines seem to agree that adding extra<br>&gt;&gt; verbosity _without a good reason_ is a bad thing. Because every<br>&gt;&gt; extra word and symbol in code just adds to the cognitive load of the<br>&gt;&gt; reader. And when it doesn&#39;t serve a purpose, it just decreases the<br>&gt;&gt; signal-to-noise ratio.<br>&gt;&gt; <br>&gt;&gt; Plus, as mentioned before, `-ed/-ing` can be tricky to spell for<br>&gt;&gt; non-natives. This might not be a big deal, but given that this<br>&gt;&gt; change provides no benefits, it&#39;s one more tiny thing you have to be<br>&gt;&gt; careful not to get wrong when writing Swift.<br>&gt;&gt; <br>&gt;&gt; And it&#39;s unnecessary:<br>&gt;&gt; <br>&gt;&gt;    removeAll(keepCapacity: true)<br>&gt;&gt;    transcode(foo, bar, stopOnError: true)<br>&gt;&gt; <br>&gt;&gt; Are just as clear and readable as:<br>&gt;&gt; <br>&gt;&gt;    removeAll(keepingCapacity: true)<br>&gt;&gt;    transcode(foo, bar, stoppingOnError: true)<br>&gt;&gt; <br>&gt;&gt; And the former isn&#39;t gramatically incorrect, because this isn&#39;t a sentence.<br>&gt;&gt; <br>&gt;&gt; Apologies for nitpicking on this tiniest possible detail. I just<br>&gt;&gt; care a lot that we don&#39;t create a precedent of trying to make<br>&gt;&gt; everything sound like English unnecessarily and add verbosity bit by<br>&gt;&gt; bit.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; Yes, and yes, with small details still worth reconsidering.<br>&gt;&gt; <br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I’ve read the whole proposal, as well as the related proposals, and<br>&gt;&gt; read the thread for this review.<br>&gt;&gt; <br>&gt;&gt; Cross-linking to my SE-0005 review:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard<br>&gt;&gt;&gt; Library&quot; begins now and runs through January 31, 2016. The proposal<br>&gt;&gt;&gt; is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to<br>&gt;&gt;&gt; the review manager. When replying, please try to keep the proposal<br>&gt;&gt;&gt; link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt;&gt; goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt; review through constructive criticism and, eventually, determine<br>&gt;&gt;&gt; the direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ca2b61444636352b0092712de201d553?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Dany St-Amant</string> &lt;dstamant at mac.com&gt;<p>January 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 26 janv. 2016 à 19:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt;&gt; except for the renaming of precondition() to require(). I think it is<br>&gt;&gt; an improvement that it describes an action now, just like assert().<br>&gt; <br>&gt; Interestingly, I was the one that insisted on that change, as I felt<br>&gt; “precondition” was too much of a term-of-art and “require” would be more<br>&gt; accessible, but I am now regretting that decision.  This function is not<br>&gt; conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>&gt; “precondition” conveyed that aspect much better, IMO.<br></p><p>How about expect()? Should not have much string attached to it. Only thing coming to mind is the <br>TCL extension used for automation.<br></p><p>Dany<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;&gt; <br>&gt;&gt; —CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 7:40 AM, Radosław Pietruszewski via<br>&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like with SE-0005<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;,<br>&gt;&gt;&gt; I’m overwhelmingly for this proposal. The Guidelines, as a whole do<br>&gt;&gt;&gt; a great job at making Swift APIs more consistent and clearer, and<br>&gt;&gt;&gt; applying them to the Swift stdlib is an important first step.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nitpicks, criticisms and suggestions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == precondition was renamed to require ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This might be confusing to newcomers, as many languages use the word<br>&gt;&gt;&gt; `require` as a keyword for what we&#39;d call `import`. Although a bit<br>&gt;&gt;&gt; more technical, `precondition` is unambiguous and still easily<br>&gt;&gt;&gt; understandable. I feel like `required` does more damage than good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == Removed Type from protocol names ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps I’ve missed some discussion about this and I don’t see the<br>&gt;&gt;&gt; context, but I’m not sure this is a positive change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I fear this might be confusing in practice, at least in some<br>&gt;&gt;&gt; contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or<br>&gt;&gt;&gt; &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”,<br>&gt;&gt;&gt; “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will<br>&gt;&gt;&gt; naturally go for `Bool`, `Int`, and `Array` anyway. But I can<br>&gt;&gt;&gt; imagine a lot of confusion if someone tried that anyway, or perhaps<br>&gt;&gt;&gt; saw that in the autocompletion, or the standard library browser<br>&gt;&gt;&gt; (with no intention of using the protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m all for removing unnecessary noise and verbosity, but I think I<br>&gt;&gt;&gt; would err on explicitness side here. It seemed like the -able/-Type<br>&gt;&gt;&gt; convention did a good job disambiguating types you can actually<br>&gt;&gt;&gt; instantiate from protocols, with very little “verbosity cost”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == sort() =&gt; sorted(), sortInPlace() =&gt; sort() etc ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m torn on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Frankly, I find both the “foo/fooInPlace” and “bar/barred”<br>&gt;&gt;&gt; conventions awkward. Both seem weird. “InPlace” isn’t something I<br>&gt;&gt;&gt; recall seeing anywhere else in API naming, and seems a bizarre way<br>&gt;&gt;&gt; of signifying mutability. “-ed” doesn’t work with all words, so you<br>&gt;&gt;&gt; sometimes have to go with “-ing”, or give up and cry. And then you<br>&gt;&gt;&gt; have inconsistency that “-InPlace” doesn’t seem to have. Also,<br>&gt;&gt;&gt; -ed/-ing can sometimes be difficult to write, especially for<br>&gt;&gt;&gt; non-natives because of the “last letter is doubled” rule for some<br>&gt;&gt;&gt; words.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But my biggest problem with this change is that IMHO we should<br>&gt;&gt;&gt; encourage to use the transforming (non-mutating) variants by<br>&gt;&gt;&gt; default. One way to achieve this as an API designer and slightly<br>&gt;&gt;&gt; push people towards doing what’s considered best practice is to make<br>&gt;&gt;&gt; the preferable variant easier to type. This might be a subtle<br>&gt;&gt;&gt; change, but I think it matters. Before, if you really wanted to<br>&gt;&gt;&gt; mutate something in place, you had to do that extra little bit of<br>&gt;&gt;&gt; work typing “sortInPlace”, whereas what would be preferable most of<br>&gt;&gt;&gt; the time had a simpler, shorter form: “sort” and would appear<br>&gt;&gt;&gt; earlier in autocomplete.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == -ings in argument names ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve noticed these few tweaks in naming:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func removeAll(keepCapacity keepCapacity: Bool = false)<br>&gt;&gt;&gt;&gt; +  mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func transcode&lt;...&gt;(...<br>&gt;&gt;&gt;&gt; -  stopOnError: Bool<br>&gt;&gt;&gt;&gt; +  stoppingOnError: Bool<br>&gt;&gt;&gt;&gt; ) -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +  public init(allocatingCapacity count: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m against this change. While I&#39;m not fully convinced of the<br>&gt;&gt;&gt; -ed/-ing rule for methods and properties, it does an important job<br>&gt;&gt;&gt; by conveying the non-mutating semantics of a symbol described. In<br>&gt;&gt;&gt; case of argument names, this rationale no longer applies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only reason to write &quot;stoppingOnError&quot; instead of &quot;stopOnError&quot;<br>&gt;&gt;&gt; is to make method invocations sound more like real English<br>&gt;&gt;&gt; sentences. This is the conventional Objective-C thinking the<br>&gt;&gt;&gt; Guidelines largely step back from. In my opinion, this is futile and<br>&gt;&gt;&gt; provides no readability benefits in this context. Method invocations<br>&gt;&gt;&gt; are _not_ sentences. It&#39;s not English, it&#39;s code. And while making<br>&gt;&gt;&gt; method names blatantly gramatically incorrect doesn&#39;t help<br>&gt;&gt;&gt; readability, neither does forcing `-ing` endings to all boolean<br>&gt;&gt;&gt; function arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only thing it does is it adds a few extra characters, an extra<br>&gt;&gt;&gt; word ending the reader has to parse and understand. I know that it&#39;s<br>&gt;&gt;&gt; a non-goal to make Swift code as terse as possible, and I&#39;m not<br>&gt;&gt;&gt; arguing for that. But the Guidelines seem to agree that adding extra<br>&gt;&gt;&gt; verbosity _without a good reason_ is a bad thing. Because every<br>&gt;&gt;&gt; extra word and symbol in code just adds to the cognitive load of the<br>&gt;&gt;&gt; reader. And when it doesn&#39;t serve a purpose, it just decreases the<br>&gt;&gt;&gt; signal-to-noise ratio.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Plus, as mentioned before, `-ed/-ing` can be tricky to spell for<br>&gt;&gt;&gt; non-natives. This might not be a big deal, but given that this<br>&gt;&gt;&gt; change provides no benefits, it&#39;s one more tiny thing you have to be<br>&gt;&gt;&gt; careful not to get wrong when writing Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And it&#39;s unnecessary:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   removeAll(keepCapacity: true)<br>&gt;&gt;&gt;   transcode(foo, bar, stopOnError: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are just as clear and readable as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   removeAll(keepingCapacity: true)<br>&gt;&gt;&gt;   transcode(foo, bar, stoppingOnError: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the former isn&#39;t gramatically incorrect, because this isn&#39;t a sentence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for nitpicking on this tiniest possible detail. I just<br>&gt;&gt;&gt; care a lot that we don&#39;t create a precedent of trying to make<br>&gt;&gt;&gt; everything sound like English unnecessarily and add verbosity bit by<br>&gt;&gt;&gt; bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; Yes, and yes, with small details still worth reconsidering.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve read the whole proposal, as well as the related proposals, and<br>&gt;&gt;&gt; read the thread for this review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cross-linking to my SE-0005 review:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard<br>&gt;&gt;&gt;&gt; Library&quot; begins now and runs through January 31, 2016. The proposal<br>&gt;&gt;&gt;&gt; is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to<br>&gt;&gt;&gt;&gt; the review manager. When replying, please try to keep the proposal<br>&gt;&gt;&gt;&gt; link at the top of the message:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt;&gt;&gt; goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt;&gt; review through constructive criticism and, eventually, determine<br>&gt;&gt;&gt;&gt; the direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 18:06, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 26 janv. 2016 à 19:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt;&gt;&gt; except for the renaming of precondition() to require(). I think it is<br>&gt;&gt;&gt; an improvement that it describes an action now, just like assert().<br>&gt;&gt; <br>&gt;&gt; Interestingly, I was the one that insisted on that change, as I felt<br>&gt;&gt; “precondition” was too much of a term-of-art and “require” would be more<br>&gt;&gt; accessible, but I am now regretting that decision.  This function is not<br>&gt;&gt; conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>&gt;&gt; “precondition” conveyed that aspect much better, IMO.<br>&gt; <br>&gt; How about expect()? Should not have much string attached to it. Only thing coming to mind is the <br>&gt; TCL extension used for automation.<br></p><p>That&#39;s not bad, but to me &quot;expect&quot; seems more open-ended than &quot;require&quot; or &quot;precondition&quot;, i.e. &quot;if it isn&#39;t true, then what?&quot;. I don&#39;t assume that it&#39;s going to be fatal.<br></p><p>(It even feels a little like an optimization hint to me, like &quot;expect(self.dynamicType === BaseClass.self)&quot;. It could still be a subclass, but the compiler would know what the common case is.)<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>January 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 3:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 26, 2016, at 18:06, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 26 janv. 2016 à 19:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt;&gt;&gt;&gt; except for the renaming of precondition() to require(). I think it is<br>&gt;&gt;&gt;&gt; an improvement that it describes an action now, just like assert().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interestingly, I was the one that insisted on that change, as I felt<br>&gt;&gt;&gt; “precondition” was too much of a term-of-art and “require” would be more<br>&gt;&gt;&gt; accessible, but I am now regretting that decision.  This function is not<br>&gt;&gt;&gt; conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>&gt;&gt;&gt; “precondition” conveyed that aspect much better, IMO.<br>&gt;&gt; <br>&gt;&gt; How about expect()? Should not have much string attached to it. Only thing coming to mind is the <br>&gt;&gt; TCL extension used for automation.<br>&gt; <br>&gt; That&#39;s not bad, but to me &quot;expect&quot; seems more open-ended than &quot;require&quot; or &quot;precondition&quot;, i.e. &quot;if it isn&#39;t true, then what?&quot;. I don&#39;t assume that it&#39;s going to be fatal.<br>&gt; <br>&gt; (It even feels a little like an optimization hint to me, like &quot;expect(self.dynamicType === BaseClass.self)&quot;. It could still be a subclass, but the compiler would know what the common case is.)<br></p><p>Someone I spoke with had a good idea about this IMO. They recommended we have debugAssert and releaseAssert (or debugRequire and releaseRequire). I think this makes the semantics obvious and has consistent terminology between the functions. There’s no question at the call site what was intended.<br></p><p>- Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/eb7e5b23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 10:03 PM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 3:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 18:06, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 26 janv. 2016 à 19:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt;&gt;&gt;&gt;&gt; except for the renaming of precondition() to require(). I think it is<br>&gt;&gt;&gt;&gt;&gt; an improvement that it describes an action now, just like assert().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interestingly, I was the one that insisted on that change, as I felt<br>&gt;&gt;&gt;&gt; “precondition” was too much of a term-of-art and “require” would be more<br>&gt;&gt;&gt;&gt; accessible, but I am now regretting that decision.  This function is not<br>&gt;&gt;&gt;&gt; conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>&gt;&gt;&gt;&gt; “precondition” conveyed that aspect much better, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about expect()? Should not have much string attached to it. Only thing coming to mind is the <br>&gt;&gt;&gt; TCL extension used for automation.<br>&gt;&gt; <br>&gt;&gt; That&#39;s not bad, but to me &quot;expect&quot; seems more open-ended than &quot;require&quot; or &quot;precondition&quot;, i.e. &quot;if it isn&#39;t true, then what?&quot;. I don&#39;t assume that it&#39;s going to be fatal.<br>&gt;&gt; <br>&gt;&gt; (It even feels a little like an optimization hint to me, like &quot;expect(self.dynamicType === BaseClass.self)&quot;. It could still be a subclass, but the compiler would know what the common case is.)<br>&gt; <br>&gt; Someone I spoke with had a good idea about this IMO. They recommended we have debugAssert and releaseAssert (or debugRequire and releaseRequire). I think this makes the semantics obvious and has consistent terminology between the functions. There’s no question at the call site what was intended.<br></p><p>I think something like this is ideal as well, but the names should be something like:<br></p><p>- debugAssert (for today’s assert)<br>- assert (for today’s precondition)<br></p><p>…since arguably using `debugAssert` and `releaseAssert` is misleading (a `releaseAssert` is included in both debug-and-release).<br></p><p>It seems like something of a migration nightmare to map the `assert` =&gt; `debugAssert` and `precondition` =&gt; `assert`, but at least it’d match the semantics (and you could change the `assert` base to `require` or `enforce` or `expect`, etc., if you wanted).<br></p><p>I do think `precondition` has been a poor naming choice, because there’s nothing in its name that hints at its semantics in Swift (as an assert active even in release conditions), and guessing the meaning isn’t any easier regardless of whether<br></p><p>- you know its term-of-art use (which arguably says nothing about its relative “strength” vis-a-vis assert)<br>- you look at the word’s structure (which seems to suggest it most be placed @ the start of a function or method)<br></p><p>…but I don’t think moving to e.g. assert-vs-require really does the needle very far, b/c you’re still in a bit of a mystery-meat scenario if you don’t already know the difference between the two.<br></p><p>&gt; <br>&gt; - Alex<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/196e8d18/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m fine with &quot;require&quot;, especially as I&#39;ve been introduced to pre- and postconditions by Bertrand Meyer&#39;s Eiffel, which uses &quot;require&quot; for preconditions and &quot;ensure&quot; for postconditions and is still the only language that I know that has these baked into the language including proper behavior in the face of inheritance.<br></p><p>-Thorsten <br></p><p>&gt; Am 27.01.2016 um 01:39 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; on Tue Jan 26 2016, Charles Kissinger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with all of the small criticisms mentioned below by Radoslaw<br>&gt;&gt; except for the renaming of precondition() to require(). I think it is<br>&gt;&gt; an improvement that it describes an action now, just like assert().<br>&gt; <br>&gt; Interestingly, I was the one that insisted on that change, as I felt<br>&gt; “precondition” was too much of a term-of-art and “require” would be more<br>&gt; accessible, but I am now regretting that decision.  This function is not<br>&gt; conceptually an action; like “assert,” it&#39;s a declarative statement, and<br>&gt; “precondition” conveyed that aspect much better, IMO.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;&gt; <br>&gt;&gt; —CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 7:40 AM, Radosław Pietruszewski via<br>&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like with SE-0005<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;,<br>&gt;&gt;&gt; I’m overwhelmingly for this proposal. The Guidelines, as a whole do<br>&gt;&gt;&gt; a great job at making Swift APIs more consistent and clearer, and<br>&gt;&gt;&gt; applying them to the Swift stdlib is an important first step.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nitpicks, criticisms and suggestions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == precondition was renamed to require ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This might be confusing to newcomers, as many languages use the word<br>&gt;&gt;&gt; `require` as a keyword for what we&#39;d call `import`. Although a bit<br>&gt;&gt;&gt; more technical, `precondition` is unambiguous and still easily<br>&gt;&gt;&gt; understandable. I feel like `required` does more damage than good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == Removed Type from protocol names ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps I’ve missed some discussion about this and I don’t see the<br>&gt;&gt;&gt; context, but I’m not sure this is a positive change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I fear this might be confusing in practice, at least in some<br>&gt;&gt;&gt; contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or<br>&gt;&gt;&gt; &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”,<br>&gt;&gt;&gt; “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will<br>&gt;&gt;&gt; naturally go for `Bool`, `Int`, and `Array` anyway. But I can<br>&gt;&gt;&gt; imagine a lot of confusion if someone tried that anyway, or perhaps<br>&gt;&gt;&gt; saw that in the autocompletion, or the standard library browser<br>&gt;&gt;&gt; (with no intention of using the protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m all for removing unnecessary noise and verbosity, but I think I<br>&gt;&gt;&gt; would err on explicitness side here. It seemed like the -able/-Type<br>&gt;&gt;&gt; convention did a good job disambiguating types you can actually<br>&gt;&gt;&gt; instantiate from protocols, with very little “verbosity cost”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == sort() =&gt; sorted(), sortInPlace() =&gt; sort() etc ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m torn on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Frankly, I find both the “foo/fooInPlace” and “bar/barred”<br>&gt;&gt;&gt; conventions awkward. Both seem weird. “InPlace” isn’t something I<br>&gt;&gt;&gt; recall seeing anywhere else in API naming, and seems a bizarre way<br>&gt;&gt;&gt; of signifying mutability. “-ed” doesn’t work with all words, so you<br>&gt;&gt;&gt; sometimes have to go with “-ing”, or give up and cry. And then you<br>&gt;&gt;&gt; have inconsistency that “-InPlace” doesn’t seem to have. Also,<br>&gt;&gt;&gt; -ed/-ing can sometimes be difficult to write, especially for<br>&gt;&gt;&gt; non-natives because of the “last letter is doubled” rule for some<br>&gt;&gt;&gt; words.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But my biggest problem with this change is that IMHO we should<br>&gt;&gt;&gt; encourage to use the transforming (non-mutating) variants by<br>&gt;&gt;&gt; default. One way to achieve this as an API designer and slightly<br>&gt;&gt;&gt; push people towards doing what’s considered best practice is to make<br>&gt;&gt;&gt; the preferable variant easier to type. This might be a subtle<br>&gt;&gt;&gt; change, but I think it matters. Before, if you really wanted to<br>&gt;&gt;&gt; mutate something in place, you had to do that extra little bit of<br>&gt;&gt;&gt; work typing “sortInPlace”, whereas what would be preferable most of<br>&gt;&gt;&gt; the time had a simpler, shorter form: “sort” and would appear<br>&gt;&gt;&gt; earlier in autocomplete.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; == -ings in argument names ==<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve noticed these few tweaks in naming:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func removeAll(keepCapacity keepCapacity: Bool = false)<br>&gt;&gt;&gt;&gt; +  mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func transcode&lt;...&gt;(...<br>&gt;&gt;&gt;&gt; -  stopOnError: Bool<br>&gt;&gt;&gt;&gt; +  stoppingOnError: Bool<br>&gt;&gt;&gt;&gt; ) -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +  public init(allocatingCapacity count: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m against this change. While I&#39;m not fully convinced of the<br>&gt;&gt;&gt; -ed/-ing rule for methods and properties, it does an important job<br>&gt;&gt;&gt; by conveying the non-mutating semantics of a symbol described. In<br>&gt;&gt;&gt; case of argument names, this rationale no longer applies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only reason to write &quot;stoppingOnError&quot; instead of &quot;stopOnError&quot;<br>&gt;&gt;&gt; is to make method invocations sound more like real English<br>&gt;&gt;&gt; sentences. This is the conventional Objective-C thinking the<br>&gt;&gt;&gt; Guidelines largely step back from. In my opinion, this is futile and<br>&gt;&gt;&gt; provides no readability benefits in this context. Method invocations<br>&gt;&gt;&gt; are _not_ sentences. It&#39;s not English, it&#39;s code. And while making<br>&gt;&gt;&gt; method names blatantly gramatically incorrect doesn&#39;t help<br>&gt;&gt;&gt; readability, neither does forcing `-ing` endings to all boolean<br>&gt;&gt;&gt; function arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only thing it does is it adds a few extra characters, an extra<br>&gt;&gt;&gt; word ending the reader has to parse and understand. I know that it&#39;s<br>&gt;&gt;&gt; a non-goal to make Swift code as terse as possible, and I&#39;m not<br>&gt;&gt;&gt; arguing for that. But the Guidelines seem to agree that adding extra<br>&gt;&gt;&gt; verbosity _without a good reason_ is a bad thing. Because every<br>&gt;&gt;&gt; extra word and symbol in code just adds to the cognitive load of the<br>&gt;&gt;&gt; reader. And when it doesn&#39;t serve a purpose, it just decreases the<br>&gt;&gt;&gt; signal-to-noise ratio.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Plus, as mentioned before, `-ed/-ing` can be tricky to spell for<br>&gt;&gt;&gt; non-natives. This might not be a big deal, but given that this<br>&gt;&gt;&gt; change provides no benefits, it&#39;s one more tiny thing you have to be<br>&gt;&gt;&gt; careful not to get wrong when writing Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And it&#39;s unnecessary:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   removeAll(keepCapacity: true)<br>&gt;&gt;&gt;   transcode(foo, bar, stopOnError: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are just as clear and readable as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   removeAll(keepingCapacity: true)<br>&gt;&gt;&gt;   transcode(foo, bar, stoppingOnError: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the former isn&#39;t gramatically incorrect, because this isn&#39;t a sentence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for nitpicking on this tiniest possible detail. I just<br>&gt;&gt;&gt; care a lot that we don&#39;t create a precedent of trying to make<br>&gt;&gt;&gt; everything sound like English unnecessarily and add verbosity bit by<br>&gt;&gt;&gt; bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; Yes, and yes, with small details still worth reconsidering.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve read the whole proposal, as well as the related proposals, and<br>&gt;&gt;&gt; read the thread for this review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cross-linking to my SE-0005 review:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard<br>&gt;&gt;&gt;&gt; Library&quot; begins now and runs through January 31, 2016. The proposal<br>&gt;&gt;&gt;&gt; is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to<br>&gt;&gt;&gt;&gt; the review manager. When replying, please try to keep the proposal<br>&gt;&gt;&gt;&gt; link at the top of the message:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt;&gt;&gt; goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt;&gt; review through constructive criticism and, eventually, determine<br>&gt;&gt;&gt;&gt; the direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
