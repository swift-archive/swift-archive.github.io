<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f97f836226f42a4e2c7de03e04abd3e2?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Charlotte Tortorella</string> &lt;charlotte.tortorella at icloud.com&gt;<p>October 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br></p><p>Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br></p><p>gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br></p><p>Replace the `?:` operator with an in-language function<br></p><p>Proposal: TBD<br>Author: [Charlotte Tortorella](https://github.com/qata)<br>Editor: [Soroush Khanlou](https://github.com/khanlou)<br>Review Manager: TBD<br>Status: TBD<br></p><p>Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br></p><p>The ternary operator in Swift was added early in development, as a holdover<br>from C.  This document is an attempt to provide a clear look at the ternary<br>operator without the baggage of the languages that came before, and comes<br>to the conclusion that we should deprecate and remove the ternary operator<br>in favor of an extension to `Bool`.<br></p><p>As a quick refresher, here&#39;s what the ternary operator looks like:<br></p><p>let a = 10<br>let b = 20<br>// If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br></p><p>Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br></p><p>The primary advantage of this operator is its terseness and expressive<br>capability. It&#39;s shorthand for (e.g.):<br></p><p>let a = 10<br>let b = 20<br>let e: String<br>if a &lt; b {<br>  e = &quot;foo&quot;<br>} else {<br>  e = &quot;bar&quot;<br>}<br></p><p>The second advantage of Swift supporting the ternary operator is continuity<br>with C, and other common languages in the extended C family (C++, Objective-C,<br>Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>may reasonably expect this operator to exist.  That said, there are also<br>popular languages which have kept the majority of C operators but dropped the<br>ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form) and [Rust](https://github.com/rust-lang/rfcs/issues/1362)).<br></p><p><br>Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br></p><p>1. The existence of the ternary operator as a holdover from C is to increase<br>the familiarity of the Swift language for C family developers, at the expense<br>of newcomers.  Established developers do much better with learning concepts<br>than newcomers to programming and probably don&#39;t need their hands held<br>with this carry over of an operator.<br></p><p>2. The ternary operator adds complexity to the compiler, because it requires<br>special handling.  It is the only operator that requires two components to<br>work (both the `?` and the `:`), it uses a character that is excluded from<br>being used in other operators (`:`), and it isn&#39;t defined in the standard<br>library.<br></p><p>3. The ternary operator&#39;s usage of `?` can be confusing<br>to new users.  Every other instance of `?` is associated with<br>`Optional` values.<br></p><p>4. The ternary operator uses `:`, which is already a heavily overloaded<br>symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>class inheritance, and protocol conformance.<br></p><p>5. The ternary operator&#39;s short length lends it to being abused in the<br>nested ternary operator anti-pattern.  This is similar to the `++` and<br>`--` operators, which were removed in Swift 3.  While they worked fine and were<br>readable enough when used alone, using them multiple times in a single<br>expression like `function(a++, ++a)` made them highly unreadable and<br>confusing.<br></p><p>6. This operator is only applicable to a single type, `Bool`.<br></p><p>7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>for Swift.  Higher clarity can be achieved with common language features by<br>creating an extension to `Bool`.<br></p><p>8. The ternary operator was created for and is much more suited to a language<br>like C, where there were no generics and as such no alternative to an<br>unintuitive operator.<br></p><p>9. Several other modern languages, like Rust and Go discussed earlier, have<br>eschewed the usage of the ternary operator entirely.  Other languages that have<br>special constructs similar to `?:`, such as `if then else` in Haskell have<br>[discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F).  `if then else` is identical to the `?:` operator,<br>excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br></p><p> Example: `if True then 10 else 20`<br></p><p>10. On a more personal and anecdotal note, the ternary operator gave me more<br>trouble than any other operator when I was first learning how to program.<br>I’ve also spoken to several other people who expressed similar sentiments<br>about this operator’s inscrutability.<br></p><p>Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br></p><p>We should drop the ternary operator in favor of a new extension to `Bool`.<br>There are a few possibilities for the naming of this function.  We&#39;ve provided<br>four for consideration in this proposal, but are open to other options as well.<br>This proposal is much more about the concept than the naming of the replacement<br>function.<br></p><p>extension Bool {<br>    /// If `self == true`, returns `t`, otherwise, returns `f`.<br>    func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>        if self {<br>            return t()<br>        } else {<br>            return f()  <br>        }<br>    }<br></p><p>    func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>      ...<br>    }<br></p><p>    func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>      ...<br>    }<br></p><p>    func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>      ...<br>    }<br>}<br></p><p>Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>functions that achieve the same thing.<br></p><p>Example usage:<br></p><p>let a = 10<br>let b = 20<br>_ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>_ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>_ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>_ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br></p><p>Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br></p><p>This proposal is breaking and would require migration.<br></p><p>Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br></p><p>Simplest alternative: we could leave the ternary operator as is and not<br>introduce any new concepts.<br></p><p>It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>This would have the disadvantages of still needing special handling by the<br>compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>complexity, this would be counterproductive and would probably confuse new<br>users in a similar way to how `?:` does.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/4d167ee0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>October 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Strong -1. I don&#39;t feel like stylistic concerns alone are a good enough reason to introduce a change that will undoubtedly break source compatibility for many, many projects come Swift 4.<br></p><p>That aside, I don&#39;t agree with the arguments that the ternary operator is confusing.<br></p><p>1. If you don&#39;t know that it exists, you aren&#39;t hampered in writing code. The most straightforward solution, and a perfectly good one, is to use an if-else to assign a value to either a `var` or a `let`.<br></p><p>2. If someone new to Swift thinks `?` and `:` are confusing, I really doubt they will react any better to a generic extension method on a type (which is a primitive in other languages) which takes two &quot;@autoclosure&quot; higher-order function parameters.<br></p><p>Finally, if you don&#39;t find any of the arguments above confusing, why force a breaking change by removing ?: instead of just adding the bool extension, especially given the source stability goals of Swift 4 and beyond?<br></p><p>Best,<br>Austin<br></p><p>&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt; <br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt; <br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt; <br>&gt; Replace the `?:` operator with an in-language function<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt; Review Manager: TBD<br>&gt; Status: TBD<br>&gt; <br>&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt; <br>&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt; operator without the baggage of the languages that came before, and comes<br>&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt; in favor of an extension to `Bool`.<br>&gt; <br>&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt; <br>&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt; <br>&gt; The primary advantage of this operator is its terseness and expressive<br>&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; let e: String<br>&gt; if a &lt; b {<br>&gt;   e = &quot;foo&quot;<br>&gt; } else {<br>&gt;   e = &quot;bar&quot;<br>&gt; }<br>&gt; <br>&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt; <br>&gt; <br>&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt; <br>&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt; with this carry over of an operator.<br>&gt; <br>&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt; special handling.  It is the only operator that requires two components to<br>&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt; library.<br>&gt; <br>&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt; to new users.  Every other instance of `?` is associated with<br>&gt; `Optional` values.<br>&gt; <br>&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt; class inheritance, and protocol conformance.<br>&gt; <br>&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt; readable enough when used alone, using them multiple times in a single<br>&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt; confusing.<br>&gt; <br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt; <br>&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt; creating an extension to `Bool`.<br>&gt; <br>&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt; like C, where there were no generics and as such no alternative to an<br>&gt; unintuitive operator.<br>&gt; <br>&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt; <br>&gt;  Example: `if True then 10 else 20`<br>&gt; <br>&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt; trouble than any other operator when I was first learning how to program.<br>&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt; about this operator’s inscrutability.<br>&gt; <br>&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt; <br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt; function.<br>&gt; <br>&gt; extension Bool {<br>&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;         if self {<br>&gt;             return t()<br>&gt;         } else {<br>&gt;             return f()  <br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt; functions that achieve the same thing.<br>&gt; <br>&gt; Example usage:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt; <br>&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt; <br>&gt; This proposal is breaking and would require migration.<br>&gt; <br>&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt; <br>&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt; introduce any new concepts.<br>&gt; <br>&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt; This would have the disadvantages of still needing special handling by the<br>&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt; users in a similar way to how `?:` does.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/f86e4006/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f97f836226f42a4e2c7de03e04abd3e2?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Charlotte Tortorella</string> &lt;charlotte.tortorella at icloud.com&gt;<p>October 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Addressing breaking source code: this is something that an auto migrator could extremely easily be written for.<br></p><p>Addressing your first point, `?:` has the advantage of terseness. Your solution requires a lot of code repetition and invariably a programmer will eventually have to deal with `?:` when interacting with literally anyone else&#39;s code.<br></p><p>Addressing your second point, `?:` has no function signature. Thus we should be comparing at call-site value. A Bool extension that mentions `true` and `false` in the function signature is far more readable than the magical operator of `?:`.<br></p><p>Addressing your &quot;finally&quot;, you&#39;ve completely missed the argument about removing complexity from the compiler, considering how `?:` requires special handling.<br></p><p>&gt; On 26 Oct. 2016, at 4:04 pm, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Strong -1. I don&#39;t feel like stylistic concerns alone are a good enough reason to introduce a change that will undoubtedly break source compatibility for many, many projects come Swift 4.<br>&gt; <br>&gt; That aside, I don&#39;t agree with the arguments that the ternary operator is confusing.<br>&gt; <br>&gt; 1. If you don&#39;t know that it exists, you aren&#39;t hampered in writing code. The most straightforward solution, and a perfectly good one, is to use an if-else to assign a value to either a `var` or a `let`.<br>&gt; <br>&gt; 2. If someone new to Swift thinks `?` and `:` are confusing, I really doubt they will react any better to a generic extension method on a type (which is a primitive in other languages) which takes two &quot;@autoclosure&quot; higher-order function parameters.<br>&gt; <br>&gt; Finally, if you don&#39;t find any of the arguments above confusing, why force a breaking change by removing ?: instead of just adding the bool extension, especially given the source stability goals of Swift 4 and beyond?<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt; <br>&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt; <br>&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt;&gt; <br>&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt; <br>&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt; <br>&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt; <br>&gt;&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt; <br>&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; let e: String<br>&gt;&gt; if a &lt; b {<br>&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt; } else {<br>&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt; <br>&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt; with this carry over of an operator.<br>&gt;&gt; <br>&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt; library.<br>&gt;&gt; <br>&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt; `Optional` values.<br>&gt;&gt; <br>&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt; <br>&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt; confusing.<br>&gt;&gt; <br>&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt; <br>&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt; <br>&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt; unintuitive operator.<br>&gt;&gt; <br>&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt; <br>&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt; <br>&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt; <br>&gt;&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt; <br>&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt; function.<br>&gt;&gt; <br>&gt;&gt; extension Bool {<br>&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;         if self {<br>&gt;&gt;             return t()<br>&gt;&gt;         } else {<br>&gt;&gt;             return f()  <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt; functions that achieve the same thing.<br>&gt;&gt; <br>&gt;&gt; Example usage:<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt; <br>&gt;&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt; <br>&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt; <br>&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt; introduce any new concepts.<br>&gt;&gt; <br>&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/0940792f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>October 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 10:13 PM, Charlotte Angela Tortorella &lt;charlotte.tortorella at icloud.com&gt; wrote:<br>&gt; <br>&gt; Addressing breaking source code: this is something that an auto migrator could extremely easily be written for.<br></p><p>Auto migrators are:<br>- Specific to Xcode, and therefore OS X Swift development using a very specific toolchain<br>- Less than reliable for large projects<br>- Not a replacement for the Swift 4 source stability goal.<br></p><p>&gt; <br>&gt; Addressing your first point, `?:` has the advantage of terseness. Your solution requires a lot of code repetition and invariably a programmer will eventually have to deal with `?:` when interacting with literally anyone else&#39;s code.<br></p><p>So, a programmer learns what &#39;?:&#39; means the first time she encounters it and knows what it does for the rest of her life, can recognize it when she sees it in the many other languages which support it, and can take advantage of its terseness if she chooses. I don&#39;t see any downsides.<br></p><p>&gt; <br>&gt; Addressing your second point, `?:` has no function signature. Thus we should be comparing at call-site value. A Bool extension that mentions `true` and `false` in the function signature is far more readable than the magical operator of `?:`.<br></p><p>I don&#39;t agree that any of your functions are more readable than &quot;?:&quot;, to any significantly greater degree than a `plus()` function would be more readable than `+`, but that&#39;s probably just a matter of taste. `??` is another magic operator, one that has far less prior art than `?:`; why not kill that one first?<br></p><p>&gt; <br>&gt; Addressing your &quot;finally&quot;, you&#39;ve completely missed the argument about removing complexity from the compiler, considering how `?:` requires special handling.<br></p><p>I don&#39;t think it&#39;s a worthwhile tradeoff. We had a proposal a few months back to remove associated type inference, which would have greatly simplified the type checker and fixed a number of critical bugs. It was rejected due to the impact it would have on developer ergonomics. Compiler complexity is not necessarily a more important goal than user experience.<br></p><p>&gt; <br>&gt;&gt; On 26 Oct. 2016, at 4:04 pm, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Strong -1. I don&#39;t feel like stylistic concerns alone are a good enough reason to introduce a change that will undoubtedly break source compatibility for many, many projects come Swift 4.<br>&gt;&gt; <br>&gt;&gt; That aside, I don&#39;t agree with the arguments that the ternary operator is confusing.<br>&gt;&gt; <br>&gt;&gt; 1. If you don&#39;t know that it exists, you aren&#39;t hampered in writing code. The most straightforward solution, and a perfectly good one, is to use an if-else to assign a value to either a `var` or a `let`.<br>&gt;&gt; <br>&gt;&gt; 2. If someone new to Swift thinks `?` and `:` are confusing, I really doubt they will react any better to a generic extension method on a type (which is a primitive in other languages) which takes two &quot;@autoclosure&quot; higher-order function parameters.<br>&gt;&gt; <br>&gt;&gt; Finally, if you don&#39;t find any of the arguments above confusing, why force a breaking change by removing ?: instead of just adding the bool extension, especially given the source stability goals of Swift 4 and beyond?<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt;&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; let e: String<br>&gt;&gt;&gt; if a &lt; b {<br>&gt;&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt;&gt; with this carry over of an operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt;&gt; library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt;&gt; `Optional` values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt;&gt; confusing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt;&gt; unintuitive operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt;&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt;&gt; function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bool {<br>&gt;&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;         if self {<br>&gt;&gt;&gt;             return t()<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return f()  <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt;&gt; functions that achieve the same thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example usage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt;&gt; introduce any new concepts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/efeb56d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f97f836226f42a4e2c7de03e04abd3e2?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Charlotte Tortorella</string> &lt;charlotte.tortorella at icloud.com&gt;<p>October 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;  Not a replacement for the Swift 4 source stability goal.<br></p><p>Swift 4 doesn&#39;t actually have a source stability goal. It has an ABI stability goal. These are two very different things. ABI is the calling conventions of the language.<br></p><p>&gt; So, a programmer learns what &#39;?:&#39; means the first time she encounters it and knows what it does for the rest of her life, can recognize it when she sees it in the many other languages which support it, and can take advantage of its terseness if she chooses. I don&#39;t see any downsides.<br></p><p>It&#39;s still confusing to learn and conveys no meaning by virtue of its symbols. Sure, everyone learns what something does and then knows how to use it, that doesn&#39;t change that certain things are less intuitive and create a higher barrier of entry to the language until one can be considered &quot;fluent&quot;.<br></p><p>&gt; I don&#39;t agree that any of your functions are more readable than &quot;?:&quot;<br></p><p>A function that explicitly states what is being returned for certain states of the `Bool` are implicitly more readable than nothing at all.<br></p><p>&gt; to any significantly greater degree than a `plus()` function would be more readable than `+`<br></p><p>`+` is a familiar mathematical concept and conveys its meaning to the layperson quite well. `?:` has no such analogue and conveys nothing to the layperson.<br></p><p>&gt; `??` is another magic operator, one that has far less prior art than `?:`; why not kill that one first?<br></p><p>Prior art is no guarantor of quality, case in point `?:`.<br></p><p><br>&gt; On 26 Oct. 2016, at 4:20 pm, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 25, 2016, at 10:13 PM, Charlotte Angela Tortorella &lt;charlotte.tortorella at icloud.com &lt;mailto:charlotte.tortorella at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Addressing breaking source code: this is something that an auto migrator could extremely easily be written for.<br>&gt; <br>&gt; Auto migrators are:<br>&gt; - Specific to Xcode, and therefore OS X Swift development using a very specific toolchain<br>&gt; - Less than reliable for large projects<br>&gt; - Not a replacement for the Swift 4 source stability goal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Addressing your first point, `?:` has the advantage of terseness. Your solution requires a lot of code repetition and invariably a programmer will eventually have to deal with `?:` when interacting with literally anyone else&#39;s code.<br>&gt; <br>&gt; So, a programmer learns what &#39;?:&#39; means the first time she encounters it and knows what it does for the rest of her life, can recognize it when she sees it in the many other languages which support it, and can take advantage of its terseness if she chooses. I don&#39;t see any downsides.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Addressing your second point, `?:` has no function signature. Thus we should be comparing at call-site value. A Bool extension that mentions `true` and `false` in the function signature is far more readable than the magical operator of `?:`.<br>&gt; <br>&gt; I don&#39;t agree that any of your functions are more readable than &quot;?:&quot;, to any significantly greater degree than a `plus()` function would be more readable than `+`, but that&#39;s probably just a matter of taste. `??` is another magic operator, one that has far less prior art than `?:`; why not kill that one first?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Addressing your &quot;finally&quot;, you&#39;ve completely missed the argument about removing complexity from the compiler, considering how `?:` requires special handling.<br>&gt; <br>&gt; I don&#39;t think it&#39;s a worthwhile tradeoff. We had a proposal a few months back to remove associated type inference, which would have greatly simplified the type checker and fixed a number of critical bugs. It was rejected due to the impact it would have on developer ergonomics. Compiler complexity is not necessarily a more important goal than user experience.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Oct. 2016, at 4:04 pm, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strong -1. I don&#39;t feel like stylistic concerns alone are a good enough reason to introduce a change that will undoubtedly break source compatibility for many, many projects come Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That aside, I don&#39;t agree with the arguments that the ternary operator is confusing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If you don&#39;t know that it exists, you aren&#39;t hampered in writing code. The most straightforward solution, and a perfectly good one, is to use an if-else to assign a value to either a `var` or a `let`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. If someone new to Swift thinks `?` and `:` are confusing, I really doubt they will react any better to a generic extension method on a type (which is a primitive in other languages) which takes two &quot;@autoclosure&quot; higher-order function parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, if you don&#39;t find any of the arguments above confusing, why force a breaking change by removing ?: instead of just adding the bool extension, especially given the source stability goals of Swift 4 and beyond?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt;&gt;&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt;&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt;&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt;&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt;&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt;&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt;&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt; let e: String<br>&gt;&gt;&gt;&gt; if a &lt; b {<br>&gt;&gt;&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt;&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt;&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt;&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt;&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt;&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt;&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt;&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt;&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt;&gt;&gt; with this carry over of an operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt;&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt;&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt;&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt;&gt;&gt; library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt;&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt;&gt;&gt; `Optional` values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt;&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt;&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt;&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt;&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt;&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt;&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt;&gt;&gt; confusing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt;&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt;&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt;&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt;&gt;&gt; unintuitive operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt;&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt;&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt;&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt;&gt;&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt;&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt;&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt;&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt;&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt;&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt;&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt;&gt;&gt; function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Bool {<br>&gt;&gt;&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;         if self {<br>&gt;&gt;&gt;&gt;             return t()<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;             return f()  <br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt;&gt;&gt; functions that achieve the same thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example usage:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt;&gt;&gt; introduce any new concepts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt;&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt;&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt;&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt;&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/47e61eff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>October 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 10:30 PM, Charlotte Angela Tortorella &lt;charlotte.tortorella at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt;  Not a replacement for the Swift 4 source stability goal.<br>&gt; <br>&gt; Swift 4 doesn&#39;t actually have a source stability goal. It has an ABI stability goal. These are two very different things. ABI is the calling conventions of the language.<br></p><p>It has both.<br></p><p>From https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html&gt;<br></p><p>&quot;For Swift 4, the primary goals are to deliver on the promise of source stability from 3.0 on, and to provide ABI stability for the standard library.&quot;<br></p><p>&gt; <br>&gt;&gt; So, a programmer learns what &#39;?:&#39; means the first time she encounters it and knows what it does for the rest of her life, can recognize it when she sees it in the many other languages which support it, and can take advantage of its terseness if she chooses. I don&#39;t see any downsides.<br>&gt; <br>&gt; It&#39;s still confusing to learn and conveys no meaning by virtue of its symbols. Sure, everyone learns what something does and then knows how to use it, that doesn&#39;t change that certain things are less intuitive and create a higher barrier of entry to the language until one can be considered &quot;fluent&quot;.<br></p><p>Swift is as much a language for professional programmers as it is for learners. The interests of both must be balanced against each other.<br></p><p>&gt; <br>&gt;&gt; I don&#39;t agree that any of your functions are more readable than &quot;?:&quot;<br>&gt; <br>&gt; A function that explicitly states what is being returned for certain states of the `Bool` are implicitly more readable than nothing at all.<br></p><p>Once you learn what &#39;?:&#39; does, something which is not conceptually difficult by any means, you don&#39;t need to be reminded what is being returned.<br></p><p>&gt; <br>&gt;&gt; to any significantly greater degree than a `plus()` function would be more readable than `+`<br>&gt; <br>&gt; `+` is a familiar mathematical concept and conveys its meaning to the layperson quite well. `?:` has no such analogue and conveys nothing to the layperson.<br></p><p>&#39;?:&#39; is a familiar concept to anyone who has experience with the C family languages. There are many &#39;new to Swift&#39; programmers, just as there are many &#39;new to programming&#39; Swift programmers.<br></p><p>&gt; <br>&gt;&gt; `??` is another magic operator, one that has far less prior art than `?:`; why not kill that one first?<br>&gt; <br>&gt; Prior art is no guarantor of quality, case in point `?:`.<br></p><p>Prior art (specifically, familiarity to programmers from C-family languages) is the explicit reason for many, many &quot;sub-optimal&quot; decisions Swift made, like calling ADTs &#39;enums&#39; and supporting both &#39;default&#39; and &#39;case _&#39; as the catchall case in switch statements. You can do a search through the mailing list archives if you want to see Chris Lattner talk about this, although I certainly won&#39;t blame you if you don&#39;t want to dig through the archives; it&#39;s a pity gmane is dead.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 26 Oct. 2016, at 4:20 pm, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 25, 2016, at 10:13 PM, Charlotte Angela Tortorella &lt;charlotte.tortorella at icloud.com &lt;mailto:charlotte.tortorella at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addressing breaking source code: this is something that an auto migrator could extremely easily be written for.<br>&gt;&gt; <br>&gt;&gt; Auto migrators are:<br>&gt;&gt; - Specific to Xcode, and therefore OS X Swift development using a very specific toolchain<br>&gt;&gt; - Less than reliable for large projects<br>&gt;&gt; - Not a replacement for the Swift 4 source stability goal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addressing your first point, `?:` has the advantage of terseness. Your solution requires a lot of code repetition and invariably a programmer will eventually have to deal with `?:` when interacting with literally anyone else&#39;s code.<br>&gt;&gt; <br>&gt;&gt; So, a programmer learns what &#39;?:&#39; means the first time she encounters it and knows what it does for the rest of her life, can recognize it when she sees it in the many other languages which support it, and can take advantage of its terseness if she chooses. I don&#39;t see any downsides.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addressing your second point, `?:` has no function signature. Thus we should be comparing at call-site value. A Bool extension that mentions `true` and `false` in the function signature is far more readable than the magical operator of `?:`.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t agree that any of your functions are more readable than &quot;?:&quot;, to any significantly greater degree than a `plus()` function would be more readable than `+`, but that&#39;s probably just a matter of taste. `??` is another magic operator, one that has far less prior art than `?:`; why not kill that one first?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addressing your &quot;finally&quot;, you&#39;ve completely missed the argument about removing complexity from the compiler, considering how `?:` requires special handling.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think it&#39;s a worthwhile tradeoff. We had a proposal a few months back to remove associated type inference, which would have greatly simplified the type checker and fixed a number of critical bugs. It was rejected due to the impact it would have on developer ergonomics. Compiler complexity is not necessarily a more important goal than user experience.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Oct. 2016, at 4:04 pm, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Strong -1. I don&#39;t feel like stylistic concerns alone are a good enough reason to introduce a change that will undoubtedly break source compatibility for many, many projects come Swift 4.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That aside, I don&#39;t agree with the arguments that the ternary operator is confusing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. If you don&#39;t know that it exists, you aren&#39;t hampered in writing code. The most straightforward solution, and a perfectly good one, is to use an if-else to assign a value to either a `var` or a `let`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. If someone new to Swift thinks `?` and `:` are confusing, I really doubt they will react any better to a generic extension method on a type (which is a primitive in other languages) which takes two &quot;@autoclosure&quot; higher-order function parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, if you don&#39;t find any of the arguments above confusing, why force a breaking change by removing ?: instead of just adding the bool extension, especially given the source stability goals of Swift 4 and beyond?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt;&gt;&gt;&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt;&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt;&gt;&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt;&gt;&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt;&gt;&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt;&gt;&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt;&gt;&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt;&gt;&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt;&gt; let e: String<br>&gt;&gt;&gt;&gt;&gt; if a &lt; b {<br>&gt;&gt;&gt;&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt;&gt;&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt;&gt;&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt;&gt;&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt;&gt;&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt;&gt;&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt;&gt;&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt;&gt;&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt;&gt;&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt;&gt;&gt;&gt; with this carry over of an operator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt;&gt;&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt;&gt;&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt;&gt;&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt;&gt;&gt;&gt; library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt;&gt;&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt;&gt;&gt;&gt; `Optional` values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt;&gt;&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt;&gt;&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt;&gt;&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt;&gt;&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt;&gt;&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt;&gt;&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt;&gt;&gt;&gt; confusing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt;&gt;&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt;&gt;&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt;&gt;&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt;&gt;&gt;&gt; unintuitive operator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt;&gt;&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt;&gt;&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt;&gt;&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt;&gt;&gt;&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt;&gt;&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt;&gt;&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt;&gt;&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt;&gt;&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt;&gt;&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt;&gt;&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt;&gt;&gt;&gt; function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Bool {<br>&gt;&gt;&gt;&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;&gt;&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;         if self {<br>&gt;&gt;&gt;&gt;&gt;             return t()<br>&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;             return f()  <br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt;&gt;&gt;&gt; functions that achieve the same thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example usage:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt;&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt;&gt;&gt;&gt; introduce any new concepts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt;&gt;&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt;&gt;&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt;&gt;&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt;&gt;&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/611dc5fb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 10:30 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;  Not a replacement for the Swift 4 source stability goal.<br>&gt; <br>&gt; Swift 4 doesn&#39;t actually have a source stability goal. It has an ABI stability goal. These are two very different things. ABI is the calling conventions of the language.<br></p><p>Hi Charlotte,<br></p><p>Swift 4 has a strong source level compatibility goal.  This is explained in the main swift-evolution page and also in the proposal template:<br>https://github.com/apple/swift-evolution/blob/master/0000-template.md &lt;https://github.com/apple/swift-evolution/blob/master/0000-template.md&gt;<br></p><p>&quot;Relative to the Swift 3 evolution process, the source compatibility requirements for Swift 4 are much more stringent: we should only break source compatibility if the Swift 3 constructs were actively harmful in some way, the volume of affected Swift 3 code is relatively small, and we can provide source compatibility (in Swift 3 compatibility mode) and migration.”<br></p><p>I agree with you that a migrator could handle this change, but such a significant source breaking change still needs major justification for doing so.  Further in the Swift 3 timeframe, this very topic was hotly debated by the folks who wanted to turn the if statement into an expression (eliminating the need for the ?: operator).<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/99b1e236/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f97f836226f42a4e2c7de03e04abd3e2?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Charlotte Tortorella</string> &lt;charlotte.tortorella at icloud.com&gt;<p>October 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>I see, well with that in mind the proposal does set out how ?: is harmful to comprehension of code for new programmers and I hope the pros and cons of keeping it are thoroughly vetted. <br></p><p>Regards,<br>Charlotte<br></p><p>&gt; On 26 Oct. 2016, at 16:52, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Oct 25, 2016, at 10:30 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Not a replacement for the Swift 4 source stability goal.<br>&gt;&gt; <br>&gt;&gt; Swift 4 doesn&#39;t actually have a source stability goal. It has an ABI stability goal. These are two very different things. ABI is the calling conventions of the language.<br>&gt; <br>&gt; Hi Charlotte,<br>&gt; <br>&gt; Swift 4 has a strong source level compatibility goal.  This is explained in the main swift-evolution page and also in the proposal template:<br>&gt; https://github.com/apple/swift-evolution/blob/master/0000-template.md<br>&gt; <br>&gt; &quot;Relative to the Swift 3 evolution process, the source compatibility requirements for Swift 4 are much more stringent: we should only break source compatibility if the Swift 3 constructs were actively harmful in some way, the volume of affected Swift 3 code is relatively small, and we can provide source compatibility (in Swift 3 compatibility mode) and migration.”<br>&gt; <br>&gt; I agree with you that a migrator could handle this change, but such a significant source breaking change still needs major justification for doing so.  Further in the Swift 3 timeframe, this very topic was hotly debated by the folks who wanted to turn the if statement into an expression (eliminating the need for the ?: operator).<br>&gt; <br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/de026b8f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October 26, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 26 Oct 2016, at 06:56, Charlotte Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; I see, well with that in mind the proposal does set out how ?: is harmful to comprehension of code for new programmers and I hope the pros and cons of keeping it are thoroughly vetted. <br>&gt; <br></p><p>They will be throughly vetted as any request is, but 1) I think the operator in question is easier to reason about that the alternative provided 2) this operator is not even in the league of the elements of the language which are important but may let you puzzled at first (good luck with explaining Swift unique take on protocol extension default methods to name one) and 3) I do not share a latent distaste for what C languages do and feel a need to distance ourselves from it (I would have kept the C style for loop, so I may not be the best one to ask about it ;)... or seen as things brewing when people argue about who is holier... I mean Swiftier and resulting Orthodoxy wars :P).<br></p><p>&gt; Regards,<br>&gt; Charlotte<br>&gt; <br>&gt;&gt; On 26 Oct. 2016, at 16:52, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 25, 2016, at 10:30 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  Not a replacement for the Swift 4 source stability goal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift 4 doesn&#39;t actually have a source stability goal. It has an ABI stability goal. These are two very different things. ABI is the calling conventions of the language.<br>&gt;&gt; <br>&gt;&gt; Hi Charlotte,<br>&gt;&gt; <br>&gt;&gt; Swift 4 has a strong source level compatibility goal.  This is explained in the main swift-evolution page and also in the proposal template:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/0000-template.md<br>&gt;&gt; <br>&gt;&gt; &quot;Relative to the Swift 3 evolution process, the source compatibility requirements for Swift 4 are much more stringent: we should only break source compatibility if the Swift 3 constructs were actively harmful in some way, the volume of affected Swift 3 code is relatively small, and we can provide source compatibility (in Swift 3 compatibility mode) and migration.”<br>&gt;&gt; <br>&gt;&gt; I agree with you that a migrator could handle this change, but such a significant source breaking change still needs major justification for doing so.  Further in the Swift 3 timeframe, this very topic was hotly debated by the folks who wanted to turn the if statement into an expression (eliminating the need for the ?: operator).<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/32c621ac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>October 26, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 9:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt; <br></p><p>You state the issue beautifully. Previous attempts have been &quot;Complete mess&quot; I agree. This is a commonly proposed feature and your solution unfortunately is not new. :( <br></p><p>Replace ?: ternary operator: Definitely magical, but it serves a very important use-case for terse selection of different values. Proposals for alternatives have been intensely discussed, but none have been &quot;better enough&quot; for it to make sense to diverge from the precedent established by the C family of languages.<br></p><p><br></p><p>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt; <br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c<br>&gt; <br>&gt; Replace the `?:` operator with an in-language function<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: [Charlotte Tortorella](https://github.com/qata)<br>&gt; Editor: [Soroush Khanlou](https://github.com/khanlou)<br>&gt; Review Manager: TBD<br>&gt; Status: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt; operator without the baggage of the languages that came before, and comes<br>&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt; in favor of an extension to `Bool`.<br>&gt; <br>&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt; <br>&gt; Advantages of The Ternary Operator<br>&gt; <br>&gt; The primary advantage of this operator is its terseness and expressive<br>&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; let e: String<br>&gt; if a &lt; b {<br>&gt;   e = &quot;foo&quot;<br>&gt; } else {<br>&gt;   e = &quot;bar&quot;<br>&gt; }<br>&gt; <br>&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form) and [Rust](https://github.com/rust-lang/rfcs/issues/1362)).<br>&gt; <br>&gt; <br>&gt; Disadvantages of The Ternary Operator<br>&gt; <br>&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt; with this carry over of an operator.<br>&gt; <br>&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt; special handling.  It is the only operator that requires two components to<br>&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt; library.<br>&gt; <br>&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt; to new users.  Every other instance of `?` is associated with<br>&gt; `Optional` values.<br>&gt; <br>&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt; class inheritance, and protocol conformance.<br>&gt; <br>&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt; readable enough when used alone, using them multiple times in a single<br>&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt; confusing.<br>&gt; <br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt; <br>&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt; creating an extension to `Bool`.<br>&gt; <br>&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt; like C, where there were no generics and as such no alternative to an<br>&gt; unintuitive operator.<br>&gt; <br>&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F).  `if then else` is identical to the `?:` operator,<br>&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt; <br>&gt;  Example: `if True then 10 else 20`<br>&gt; <br>&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt; trouble than any other operator when I was first learning how to program.<br>&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt; about this operator’s inscrutability.<br>&gt; <br>&gt; Proposed Approach<br>&gt; <br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt; function.<br>&gt; <br>&gt; extension Bool {<br>&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;         if self {<br>&gt;             return t()<br>&gt;         } else {<br>&gt;             return f()  <br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt; functions that achieve the same thing.<br>&gt; <br>&gt; Example usage:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This proposal is breaking and would require migration.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt; introduce any new concepts.<br>&gt; <br>&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt; This would have the disadvantages of still needing special handling by the<br>&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt; users in a similar way to how `?:` does.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/7a05974a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 26, 2016 at 12:00:00pm</p></header><div class="content"><p>infix operator ♠️ : LogicalDisjunctionPrecedenceinfix operator ♥ :<br>LogicalDisjunctionPrecedence<br>func ♠️&lt;T&gt;(lhs: Bool, rhs: @autoclosure () throws -&gt; T) rethrows -&gt; T? {<br>    if lhs { return rhs() } else { return nil }<br>}func ♥&lt;T&gt;(lhs: T?, rhs: @autoclosure () throws -&gt; T) rethrows -&gt; T {<br>    return lhs ?? rhs<br>}<br>// Equivalent statements:<br>condition() ? first() : second()<br>condition() ♠️ first() ♥ second()<br></p><p>By removal of ?:, we could simplify our system of operators and prevent<br>some ternary-related bugs/unexpected stuff. We could modify reserved<br>operators to allow ? instead of ♠️ and : instead of ♥.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/6be45571/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec5a599777854c540fd102ef4691fe10?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Rimantas Liubertas</string> &lt;rimantas at gmail.com&gt;<p>October 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning<br>&gt; curve for newcomers when it comes to dealing with the ternary function. The<br>&gt; best way to do that, in my opinion, is to remove it entirely and add a new<br>&gt; function with better semantics that takes care of ternary operations<br>&gt; entirely within the Swift language.<br>&gt;<br></p><p>-1<br></p><p>A lot of things can and will be confusing for newcomers, that&#39;s not the<br>reason to remove them. Being a newbie is a transitional state.<br>OTOH, I&#39;ve never got why ternary is considered especially confusing, for me<br>it never was a problem and I love the terseness of it.<br>Only total novices in programming may be surprised by it, but they will be<br>suprised by a lot of things anyway, so ternary is the least of their<br>problems. Those with experiene in other languages will be most likely<br>already familiar with the<br>operator.<br>Also, many come to Swift from Objective C, which not only has ternary, but<br>also supports a variant where you can use it kind of like ?? in Swift:<br>NSString *other = someString ?: @&quot;default string&quot;.<br></p><p>Removing ?: gains nothing and loses a lot, I&#39;d say.<br></p><p>Best regards,<br>Rimantas<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/9229064c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 26, 2016 at 07:00:00am</p></header><div class="content"><p>-1 as well, particularly agreeing with Rimantas that removing something of use because it confuses new programmers is not a good motivation.  To paraphrase Einstein, “A programming language should be as simple as possible, but no simpler.”<br></p><p>-d<br></p><p>&gt; On Oct 26, 2016, at 6:26 AM, Rimantas Liubertas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; A lot of things can and will be confusing for newcomers, that&#39;s not the reason to remove them. Being a newbie is a transitional state.<br>&gt; OTOH, I&#39;ve never got why ternary is considered especially confusing, for me it never was a problem and I love the terseness of it.<br>&gt; Only total novices in programming may be surprised by it, but they will be suprised by a lot of things anyway, so ternary is the least of their problems. Those with experiene in other languages will be most likely already familiar with the<br>&gt; operator.<br>&gt; Also, many come to Swift from Objective C, which not only has ternary, but also supports a variant where you can use it kind of like ?? in Swift: NSString *other = someString ?: @&quot;default string&quot;.<br>&gt; <br>&gt; Removing ?: gains nothing and loses a lot, I&#39;d say.<br>&gt; <br>&gt; Best regards,<br>&gt; Rimantas<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/875527b1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>October 26, 2016 at 08:00:00am</p></header><div class="content"><p>I like the idea in theory, but I also like the existing ternary operator.<br>Could some of this be accomplished without drastic changes?<br></p><p>Some alternative ideas-<br></p><p>1) Codify ternary operator declaration in the language, but make some<br>common-sense restrictions to reduce expression parsing complexity (no line<br>breaks, enforced parens, &#39;simple&#39; arguments, stuff like that).  If there<br>were an extension like you propose in addition, my preference would be a<br>verb like &quot;select&quot;.<br></p><p>2) Make it a binary operator with autoclosure tuple on the RHS (is it<br>possible to put autoclosure within a tuple?):<br></p><p>public static func ?&lt;T&gt;(_ value: Bool, _ branches: (_ t: @autoclosure () -&gt;<br>T, _ f: @autoclosure () -&gt; T)) -&gt; T {<br>        if value {<br>            return branches.t()<br>        } else {<br>            return branches.f()<br>        }<br>    }<br></p><p><br></p><p>On Tue, Oct 25, 2016 at 11:51 PM, Charlotte Angela Tortorella via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary<br>&gt; operator and to be honest they&#39;re a complete mess without a single fully<br>&gt; formed proposal.<br>&gt;<br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning<br>&gt; curve for newcomers when it comes to dealing with the ternary function. The<br>&gt; best way to do that, in my opinion, is to remove it entirely and add a new<br>&gt; function with better semantics that takes care of ternary operations<br>&gt; entirely within the Swift language.<br>&gt;<br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c<br>&gt;<br>&gt; Replace the `?:` operator with an in-language function<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author: [Charlotte Tortorella](https://github.com/qata)<br>&gt; Editor: [Soroush Khanlou](https://github.com/khanlou)<br>&gt; Review Manager: TBD<br>&gt; Status: TBD<br>&gt;<br>&gt; Introduction<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;<br>&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt; operator without the baggage of the languages that came before, and comes<br>&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt; in favor of an extension to `Bool`.<br>&gt;<br>&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;<br>&gt; Advantages of The Ternary Operator<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;<br>&gt; The primary advantage of this operator is its terseness and expressive<br>&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; let e: String<br>&gt; if a &lt; b {<br>&gt;   e = &quot;foo&quot;<br>&gt; } else {<br>&gt;   e = &quot;bar&quot;<br>&gt; }<br>&gt;<br>&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt; with C, and other common languages in the extended C family (C++,<br>&gt; Objective-C,<br>&gt; Java, C#, Javascript, etc).  People coming to Swift from these other<br>&gt; languages<br>&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt; popular languages which have kept the majority of C operators but dropped<br>&gt; the<br>&gt; ternary operator (e.g. [Go](https://golang.org/doc/<br>&gt; faq#Does_Go_have_a_ternary_form) and [Rust](https://github.com/<br>&gt; rust-lang/rfcs/issues/1362)).<br>&gt;<br>&gt;<br>&gt; Disadvantages of The Ternary Operator<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;<br>&gt; 1. The existence of the ternary operator as a holdover from C is to<br>&gt; increase<br>&gt; the familiarity of the Swift language for C family developers, at the<br>&gt; expense<br>&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt; with this carry over of an operator.<br>&gt;<br>&gt; 2. The ternary operator adds complexity to the compiler, because it<br>&gt; requires<br>&gt; special handling.  It is the only operator that requires two components to<br>&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt; library.<br>&gt;<br>&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt; to new users.  Every other instance of `?` is associated with<br>&gt; `Optional` values.<br>&gt;<br>&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt; symbol in Swift.  `:` is used in hash tables, type annotations for<br>&gt; variables,<br>&gt; class inheritance, and protocol conformance.<br>&gt;<br>&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt; `--` operators, which were removed in Swift 3.  While they worked fine and<br>&gt; were<br>&gt; readable enough when used alone, using them multiple times in a single<br>&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt; confusing.<br>&gt;<br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;<br>&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be<br>&gt; proposed<br>&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt; creating an extension to `Bool`.<br>&gt;<br>&gt; 8. The ternary operator was created for and is much more suited to a<br>&gt; language<br>&gt; like C, where there were no generics and as such no alternative to an<br>&gt; unintuitive operator.<br>&gt;<br>&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt; eschewed the usage of the ternary operator entirely.  Other languages that<br>&gt; have<br>&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt; [discussed removing it](https://wiki.haskell.org/<br>&gt; If-then-else#Is_If-Then-Else_so_important.3F).  `if then else` is<br>&gt; identical to the `?:` operator,<br>&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;<br>&gt;  Example: `if True then 10 else 20`<br>&gt;<br>&gt; 10. On a more personal and anecdotal note, the ternary operator gave me<br>&gt; more<br>&gt; trouble than any other operator when I was first learning how to program.<br>&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt; about this operator’s inscrutability.<br>&gt;<br>&gt; Proposed Approach<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;<br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt; There are a few possibilities for the naming of this function.  We&#39;ve<br>&gt; provided<br>&gt; four for consideration in this proposal, but are open to other options as<br>&gt; well.<br>&gt; This proposal is much more about the concept than the naming of the<br>&gt; replacement<br>&gt; function.<br>&gt;<br>&gt; extension Bool {<br>&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f:<br>&gt; @autoclosure () -&gt; T) -&gt; T {<br>&gt;         if self {<br>&gt;             return t()<br>&gt;         } else {<br>&gt;             return f()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt;<br>&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt;<br>&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T)<br>&gt; -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt; functions that achieve the same thing.<br>&gt;<br>&gt; Example usage:<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;<br>&gt; Impact on existing code<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; Alternatives considered<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;<br>&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt; introduce any new concepts.<br>&gt;<br>&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt; This would have the disadvantages of still needing special handling by the<br>&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt; users in a similar way to how `?:` does.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/232e5cce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Mark Sands</string> &lt;marksands07 at gmail.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>Strong *+1* from me.<br></p><p>This simply feels like the right approach for Swift, as we see the language<br>head in a direction that has abandoned traditional C-style idioms. As swift<br>has already dropped support for the ++/-- operators and C-style for loops<br>it makes logical sense that dropping the ternary operator (or replacing<br>with a more Swift-like idiom) should follow.<br></p><p>As a side note, after upgrading my swift code to Swift 3, I feel as though<br>I&#39;ve become un-phased at future source breaking changes until full<br>stability is met and set in stone. If they&#39;re worth it, bring them on, I<br>say.<br></p><p>Mark<br></p><p>On Wed, Oct 26, 2016 at 8:52 AM, Mike Kasianowicz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like the idea in theory, but I also like the existing ternary operator.<br>&gt; Could some of this be accomplished without drastic changes?<br>&gt;<br>&gt; Some alternative ideas-<br>&gt;<br>&gt; 1) Codify ternary operator declaration in the language, but make some<br>&gt; common-sense restrictions to reduce expression parsing complexity (no line<br>&gt; breaks, enforced parens, &#39;simple&#39; arguments, stuff like that).  If there<br>&gt; were an extension like you propose in addition, my preference would be a<br>&gt; verb like &quot;select&quot;.<br>&gt;<br>&gt; 2) Make it a binary operator with autoclosure tuple on the RHS (is it<br>&gt; possible to put autoclosure within a tuple?):<br>&gt;<br>&gt; public static func ?&lt;T&gt;(_ value: Bool, _ branches: (_ t: @autoclosure ()<br>&gt; -&gt; T, _ f: @autoclosure () -&gt; T)) -&gt; T {<br>&gt;         if value {<br>&gt;             return branches.t()<br>&gt;         } else {<br>&gt;             return branches.f()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Oct 25, 2016 at 11:51 PM, Charlotte Angela Tortorella via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary<br>&gt;&gt; operator and to be honest they&#39;re a complete mess without a single fully<br>&gt;&gt; formed proposal.<br>&gt;&gt;<br>&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning<br>&gt;&gt; curve for newcomers when it comes to dealing with the ternary function. The<br>&gt;&gt; best way to do that, in my opinion, is to remove it entirely and add a new<br>&gt;&gt; function with better semantics that takes care of ternary operations<br>&gt;&gt; entirely within the Swift language.<br>&gt;&gt;<br>&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c<br>&gt;&gt;<br>&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt;<br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata)<br>&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou)<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt;<br>&gt;&gt; The ternary operator in Swift was added early in development, as a<br>&gt;&gt; holdover<br>&gt;&gt; from C.  This document is an attempt to provide a clear look at the<br>&gt;&gt; ternary<br>&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt;<br>&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt;<br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt;<br>&gt;&gt; Advantages of The Ternary Operator<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt;<br>&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt;<br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; let e: String<br>&gt;&gt; if a &lt; b {<br>&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt; } else {<br>&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The second advantage of Swift supporting the ternary operator is<br>&gt;&gt; continuity<br>&gt;&gt; with C, and other common languages in the extended C family (C++,<br>&gt;&gt; Objective-C,<br>&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other<br>&gt;&gt; languages<br>&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt; popular languages which have kept the majority of C operators but dropped<br>&gt;&gt; the<br>&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/fa<br>&gt;&gt; q#Does_Go_have_a_ternary_form) and [Rust](https://github.com/rust<br>&gt;&gt; -lang/rfcs/issues/1362)).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Disadvantages of The Ternary Operator<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt;<br>&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to<br>&gt;&gt; increase<br>&gt;&gt; the familiarity of the Swift language for C family developers, at the<br>&gt;&gt; expense<br>&gt;&gt; of newcomers.  Established developers do much better with learning<br>&gt;&gt; concepts<br>&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt; with this carry over of an operator.<br>&gt;&gt;<br>&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it<br>&gt;&gt; requires<br>&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt; library.<br>&gt;&gt;<br>&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt; `Optional` values.<br>&gt;&gt;<br>&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for<br>&gt;&gt; variables,<br>&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt;<br>&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine<br>&gt;&gt; and were<br>&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt; confusing.<br>&gt;&gt;<br>&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt;<br>&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be<br>&gt;&gt; proposed<br>&gt;&gt; for Swift.  Higher clarity can be achieved with common language features<br>&gt;&gt; by<br>&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt;<br>&gt;&gt; 8. The ternary operator was created for and is much more suited to a<br>&gt;&gt; language<br>&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt; unintuitive operator.<br>&gt;&gt;<br>&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier,<br>&gt;&gt; have<br>&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages<br>&gt;&gt; that have<br>&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt; [discussed removing it](https://wiki.haskell.org/I<br>&gt;&gt; f-then-else#Is_If-Then-Else_so_important.3F).  `if then else` is<br>&gt;&gt; identical to the `?:` operator,<br>&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt;<br>&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt;<br>&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me<br>&gt;&gt; more<br>&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt;<br>&gt;&gt; Proposed Approach<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt;<br>&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve<br>&gt;&gt; provided<br>&gt;&gt; four for consideration in this proposal, but are open to other options as<br>&gt;&gt; well.<br>&gt;&gt; This proposal is much more about the concept than the naming of the<br>&gt;&gt; replacement<br>&gt;&gt; function.<br>&gt;&gt;<br>&gt;&gt; extension Bool {<br>&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f:<br>&gt;&gt; @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;         if self {<br>&gt;&gt;             return t()<br>&gt;&gt;         } else {<br>&gt;&gt;             return f()<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure ()<br>&gt;&gt; -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt;<br>&gt;&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt;<br>&gt;&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt; functions that achieve the same thing.<br>&gt;&gt;<br>&gt;&gt; Example usage:<br>&gt;&gt;<br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt;<br>&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt;<br>&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt; introduce any new concepts.<br>&gt;&gt;<br>&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/4b415f0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80fad2a3e52b92c5db146524b3961e37?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Joshua Alvarado</string> &lt;alvaradojoshua0 at gmail.com&gt;<p>October 26, 2016 at 09:00:00am</p></header><div class="content"><p>-1<br></p><p>I love the idea of challenging the syntax but without any real benefit I can see it harder for new devs and it will cause breaking changes that doesn&#39;t outweigh the cause. The syntax z ? x : y is  not hard to comprehend and expresses powerful statements in just a simple line. I do agree it is abused. It is used in places that a fuller if statement would help make sense of the code. It is on the developer to help make the operator easier to understand. The operator is the same across many languages which helps create a standard. <br></p><p>Alvarado, Joshua<br></p><p>&gt; On Oct 26, 2016, at 9:12 AM, Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong +1 from me.<br>&gt; <br>&gt; This simply feels like the right approach for Swift, as we see the language head in a direction that has abandoned traditional C-style idioms. As swift has already dropped support for the ++/-- operators and C-style for loops it makes logical sense that dropping the ternary operator (or replacing with a more Swift-like idiom) should follow.<br>&gt; <br>&gt; As a side note, after upgrading my swift code to Swift 3, I feel as though I&#39;ve become un-phased at future source breaking changes until full stability is met and set in stone. If they&#39;re worth it, bring them on, I say.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; On Wed, Oct 26, 2016 at 8:52 AM, Mike Kasianowicz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I like the idea in theory, but I also like the existing ternary operator. Could some of this be accomplished without drastic changes?<br>&gt;&gt; <br>&gt;&gt; Some alternative ideas-<br>&gt;&gt; <br>&gt;&gt; 1) Codify ternary operator declaration in the language, but make some common-sense restrictions to reduce expression parsing complexity (no line breaks, enforced parens, &#39;simple&#39; arguments, stuff like that).  If there were an extension like you propose in addition, my preference would be a verb like &quot;select&quot;.<br>&gt;&gt; <br>&gt;&gt; 2) Make it a binary operator with autoclosure tuple on the RHS (is it possible to put autoclosure within a tuple?):<br>&gt;&gt; <br>&gt;&gt; public static func ?&lt;T&gt;(_ value: Bool, _ branches: (_ t: @autoclosure () -&gt; T, _ f: @autoclosure () -&gt; T)) -&gt; T {<br>&gt;&gt;         if value {<br>&gt;&gt;             return branches.t()<br>&gt;&gt;         } else {<br>&gt;&gt;             return branches.f()<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Oct 25, 2016 at 11:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata)<br>&gt;&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou)<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages of The Ternary Operator<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; let e: String<br>&gt;&gt;&gt; if a &lt; b {<br>&gt;&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form) and [Rust](https://github.com/rust-lang/rfcs/issues/1362)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disadvantages of The Ternary Operator<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt;&gt; with this carry over of an operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt;&gt; library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt;&gt; `Optional` values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt;&gt; confusing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt;&gt; unintuitive operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F).  `if then else` is identical to the `?:` operator,<br>&gt;&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed Approach<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt;&gt; function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bool {<br>&gt;&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;         if self {<br>&gt;&gt;&gt;             return t()<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return f()  <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;       ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt;&gt; functions that achieve the same thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example usage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = 10<br>&gt;&gt;&gt; let b = 20<br>&gt;&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt;&gt; introduce any new concepts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/1837643f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/84905ff33b4990cd337eeef291d91ff0?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Soroush Khanlou</string> &lt;soroushkhanlou at gmail.com&gt;<p>October 26, 2016 at 11:00:00am</p></header><div class="content"><p>+1 from me as well.<br></p><p>I was initially unconvinced, until Charlotte showed me her proposal. She lays out the case very well, and I agreed to help edit the proposal.<br></p><p>It’s a confusing and bad operator, and it doesn’t give us anything that a function on Bool can’t give us. The way I see it, this isn’t very different from C-style for loops, the ++ operator, or explicit optionality, which are all features where Swift departs from traditional C orthodoxy.<br></p><p>It’s easy to abuse and hard to reason about. Special cases like this operator have to really earn their place in the language. This one doesn’t carry its weight.<br></p><p>Soroush<br></p><p>&gt; On Oct 26, 2016, at 11:42 AM, Joshua Alvarado via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; I love the idea of challenging the syntax but without any real benefit I can see it harder for new devs and it will cause breaking changes that doesn&#39;t outweigh the cause. The syntax z ? x : y is  not hard to comprehend and expresses powerful statements in just a simple line. I do agree it is abused. It is used in places that a fuller if statement would help make sense of the code. It is on the developer to help make the operator easier to understand. The operator is the same across many languages which helps create a standard. <br>&gt; <br>&gt; Alvarado, Joshua<br>&gt; <br>&gt; On Oct 26, 2016, at 9:12 AM, Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Strong +1 from me.<br>&gt;&gt; <br>&gt;&gt; This simply feels like the right approach for Swift, as we see the language head in a direction that has abandoned traditional C-style idioms. As swift has already dropped support for the ++/-- operators and C-style for loops it makes logical sense that dropping the ternary operator (or replacing with a more Swift-like idiom) should follow.<br>&gt;&gt; <br>&gt;&gt; As a side note, after upgrading my swift code to Swift 3, I feel as though I&#39;ve become un-phased at future source breaking changes until full stability is met and set in stone. If they&#39;re worth it, bring them on, I say.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt; On Wed, Oct 26, 2016 at 8:52 AM, Mike Kasianowicz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I like the idea in theory, but I also like the existing ternary operator. Could some of this be accomplished without drastic changes?<br>&gt;&gt; <br>&gt;&gt; Some alternative ideas-<br>&gt;&gt; <br>&gt;&gt; 1) Codify ternary operator declaration in the language, but make some common-sense restrictions to reduce expression parsing complexity (no line breaks, enforced parens, &#39;simple&#39; arguments, stuff like that).  If there were an extension like you propose in addition, my preference would be a verb like &quot;select&quot;.<br>&gt;&gt; <br>&gt;&gt; 2) Make it a binary operator with autoclosure tuple on the RHS (is it possible to put autoclosure within a tuple?):<br>&gt;&gt; <br>&gt;&gt; public static func ?&lt;T&gt;(_ value: Bool, _ branches: (_ t: @autoclosure () -&gt; T, _ f: @autoclosure () -&gt; T)) -&gt; T {<br>&gt;&gt;         if value {<br>&gt;&gt;             return branches.t()<br>&gt;&gt;         } else {<br>&gt;&gt;             return branches.f()<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Oct 25, 2016 at 11:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt;&gt; <br>&gt;&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt;&gt; <br>&gt;&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt;&gt; <br>&gt;&gt; Replace the `?:` operator with an in-language function<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt;&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;&gt; <br>&gt;&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt;&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt;&gt; operator without the baggage of the languages that came before, and comes<br>&gt;&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt;&gt; in favor of an extension to `Bool`.<br>&gt;&gt; <br>&gt;&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt;&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;&gt; <br>&gt;&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;&gt; <br>&gt;&gt; The primary advantage of this operator is its terseness and expressive<br>&gt;&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; let e: String<br>&gt;&gt; if a &lt; b {<br>&gt;&gt;   e = &quot;foo&quot;<br>&gt;&gt; } else {<br>&gt;&gt;   e = &quot;bar&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt;&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt;&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt;&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt;&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt;&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;&gt; <br>&gt;&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt;&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt;&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt;&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt;&gt; with this carry over of an operator.<br>&gt;&gt; <br>&gt;&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt;&gt; special handling.  It is the only operator that requires two components to<br>&gt;&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt;&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt;&gt; library.<br>&gt;&gt; <br>&gt;&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt;&gt; to new users.  Every other instance of `?` is associated with<br>&gt;&gt; `Optional` values.<br>&gt;&gt; <br>&gt;&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt;&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt;&gt; class inheritance, and protocol conformance.<br>&gt;&gt; <br>&gt;&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt;&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt;&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt;&gt; readable enough when used alone, using them multiple times in a single<br>&gt;&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt;&gt; confusing.<br>&gt;&gt; <br>&gt;&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;&gt; <br>&gt;&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt;&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt;&gt; creating an extension to `Bool`.<br>&gt;&gt; <br>&gt;&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt;&gt; like C, where there were no generics and as such no alternative to an<br>&gt;&gt; unintuitive operator.<br>&gt;&gt; <br>&gt;&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt;&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt;&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt;&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt;&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;&gt; <br>&gt;&gt;  Example: `if True then 10 else 20`<br>&gt;&gt; <br>&gt;&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt;&gt; trouble than any other operator when I was first learning how to program.<br>&gt;&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt;&gt; about this operator’s inscrutability.<br>&gt;&gt; <br>&gt;&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;&gt; <br>&gt;&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt;&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt;&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt;&gt; function.<br>&gt;&gt; <br>&gt;&gt; extension Bool {<br>&gt;&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;         if self {<br>&gt;&gt;             return t()<br>&gt;&gt;         } else {<br>&gt;&gt;             return f()  <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt;&gt; functions that achieve the same thing.<br>&gt;&gt; <br>&gt;&gt; Example usage:<br>&gt;&gt; <br>&gt;&gt; let a = 10<br>&gt;&gt; let b = 20<br>&gt;&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt;&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;&gt; <br>&gt;&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;&gt; <br>&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;&gt; <br>&gt;&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt;&gt; introduce any new concepts.<br>&gt;&gt; <br>&gt;&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt;&gt; This would have the disadvantages of still needing special handling by the<br>&gt;&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt;&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt;&gt; users in a similar way to how `?:` does.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/8af31d26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 12:00:00am</p></header><div class="content"><p>As Chris mentioned, such a proposal is entirely out of scope for this phase<br>of Swift 4, it&#39;s a commonly rejected proposal that required a high bar for<br>reconsideration even during the Swift 3 evolution process, and that bar is<br>even higher going forward because source breaking changes will be extremely<br>frowned upon. Because it&#39;s such a high-traffic list, this is really not an<br>ideal thread to resurrect...<br></p><p>On Fri, Oct 28, 2016 at 5:56 PM Soroush Khanlou via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 from me as well.<br>&gt;<br>&gt; I was initially unconvinced, until Charlotte showed me her proposal. She<br>&gt; lays out the case very well, and I agreed to help edit the proposal.<br>&gt;<br>&gt; It’s a confusing and bad operator, and it doesn’t give us anything that a<br>&gt; function on Bool can’t give us. The way I see it, this isn’t very different<br>&gt; from C-style for loops, the ++ operator, or explicit optionality, which are<br>&gt; all features where Swift departs from traditional C orthodoxy.<br>&gt;<br>&gt; It’s easy to abuse and hard to reason about. Special cases like this<br>&gt; operator have to really earn their place in the language. This one doesn’t<br>&gt; carry its weight.<br>&gt;<br>&gt; Soroush<br>&gt;<br>&gt; On Oct 26, 2016, at 11:42 AM, Joshua Alvarado via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; I love the idea of challenging the syntax but without any real benefit I<br>&gt; can see it harder for new devs and it will cause breaking changes that<br>&gt; doesn&#39;t outweigh the cause. The syntax z ? x : y is  not hard to comprehend<br>&gt; and expresses powerful statements in just a simple line. I do agree it is<br>&gt; abused. It is used in places that a fuller if statement would help make<br>&gt; sense of the code. It is on the developer to help make the operator easier<br>&gt; to understand. The operator is the same across many languages which helps<br>&gt; create a standard.<br>&gt;<br>&gt; Alvarado, Joshua<br>&gt;<br>&gt; On Oct 26, 2016, at 9:12 AM, Mark Sands via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Strong *+1* from me.<br>&gt;<br>&gt; This simply feels like the right approach for Swift, as we see the<br>&gt; language head in a direction that has abandoned traditional C-style idioms.<br>&gt; As swift has already dropped support for the ++/-- operators and C-style<br>&gt; for loops it makes logical sense that dropping the ternary operator (or<br>&gt; replacing with a more Swift-like idiom) should follow.<br>&gt;<br>&gt; As a side note, after upgrading my swift code to Swift 3, I feel as though<br>&gt; I&#39;ve become un-phased at future source breaking changes until full<br>&gt; stability is met and set in stone. If they&#39;re worth it, bring them on, I<br>&gt; say.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt; On Wed, Oct 26, 2016 at 8:52 AM, Mike Kasianowicz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like the idea in theory, but I also like the existing ternary operator.<br>&gt; Could some of this be accomplished without drastic changes?<br>&gt;<br>&gt; Some alternative ideas-<br>&gt;<br>&gt; 1) Codify ternary operator declaration in the language, but make some<br>&gt; common-sense restrictions to reduce expression parsing complexity (no line<br>&gt; breaks, enforced parens, &#39;simple&#39; arguments, stuff like that).  If there<br>&gt; were an extension like you propose in addition, my preference would be a<br>&gt; verb like &quot;select&quot;.<br>&gt;<br>&gt; 2) Make it a binary operator with autoclosure tuple on the RHS (is it<br>&gt; possible to put autoclosure within a tuple?):<br>&gt;<br>&gt; public static func ?&lt;T&gt;(_ value: Bool, _ branches: (_ t: @autoclosure ()<br>&gt; -&gt; T, _ f: @autoclosure () -&gt; T)) -&gt; T {<br>&gt;         if value {<br>&gt;             return branches.t()<br>&gt;         } else {<br>&gt;             return branches.f()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Oct 25, 2016 at 11:51 PM, Charlotte Angela Tortorella via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary<br>&gt; operator and to be honest they&#39;re a complete mess without a single fully<br>&gt; formed proposal.<br>&gt;<br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning<br>&gt; curve for newcomers when it comes to dealing with the ternary function. The<br>&gt; best way to do that, in my opinion, is to remove it entirely and add a new<br>&gt; function with better semantics that takes care of ternary operations<br>&gt; entirely within the Swift language.<br>&gt;<br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c<br>&gt;<br>&gt; Replace the `?:` operator with an in-language function<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author: [Charlotte Tortorella](https://github.com/qata)<br>&gt; Editor: [Soroush Khanlou](https://github.com/khanlou)<br>&gt; Review Manager: TBD<br>&gt; Status: TBD<br>&gt;<br>&gt; Introduction<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt;<br>&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt; operator without the baggage of the languages that came before, and comes<br>&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt; in favor of an extension to `Bool`.<br>&gt;<br>&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt;<br>&gt; Advantages of The Ternary Operator<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt;<br>&gt; The primary advantage of this operator is its terseness and expressive<br>&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; let e: String<br>&gt; if a &lt; b {<br>&gt;   e = &quot;foo&quot;<br>&gt; } else {<br>&gt;   e = &quot;bar&quot;<br>&gt; }<br>&gt;<br>&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt; with C, and other common languages in the extended C family (C++,<br>&gt; Objective-C,<br>&gt; Java, C#, Javascript, etc).  People coming to Swift from these other<br>&gt; languages<br>&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt; popular languages which have kept the majority of C operators but dropped<br>&gt; the<br>&gt; ternary operator (e.g. [Go](<br>&gt; https://golang.org/doc/faq#Does_Go_have_a_ternary_form) and [Rust](<br>&gt; https://github.com/rust-lang/rfcs/issues/1362)).<br>&gt;<br>&gt;<br>&gt; Disadvantages of The Ternary Operator<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;<br>&gt; 1. The existence of the ternary operator as a holdover from C is to<br>&gt; increase<br>&gt; the familiarity of the Swift language for C family developers, at the<br>&gt; expense<br>&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt; with this carry over of an operator.<br>&gt;<br>&gt; 2. The ternary operator adds complexity to the compiler, because it<br>&gt; requires<br>&gt; special handling.  It is the only operator that requires two components to<br>&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt; library.<br>&gt;<br>&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt; to new users.  Every other instance of `?` is associated with<br>&gt; `Optional` values.<br>&gt;<br>&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt; symbol in Swift.  `:` is used in hash tables, type annotations for<br>&gt; variables,<br>&gt; class inheritance, and protocol conformance.<br>&gt;<br>&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt; `--` operators, which were removed in Swift 3.  While they worked fine and<br>&gt; were<br>&gt; readable enough when used alone, using them multiple times in a single<br>&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt; confusing.<br>&gt;<br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;<br>&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be<br>&gt; proposed<br>&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt; creating an extension to `Bool`.<br>&gt;<br>&gt; 8. The ternary operator was created for and is much more suited to a<br>&gt; language<br>&gt; like C, where there were no generics and as such no alternative to an<br>&gt; unintuitive operator.<br>&gt;<br>&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt; eschewed the usage of the ternary operator entirely.  Other languages that<br>&gt; have<br>&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt; [discussed removing it](<br>&gt; https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F).<br>&gt;  `if then else` is identical to the `?:` operator,<br>&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt;<br>&gt;  Example: `if True then 10 else 20`<br>&gt;<br>&gt; 10. On a more personal and anecdotal note, the ternary operator gave me<br>&gt; more<br>&gt; trouble than any other operator when I was first learning how to program.<br>&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt; about this operator’s inscrutability.<br>&gt;<br>&gt; Proposed Approach<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;<br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt; There are a few possibilities for the naming of this function.  We&#39;ve<br>&gt; provided<br>&gt; four for consideration in this proposal, but are open to other options as<br>&gt; well.<br>&gt; This proposal is much more about the concept than the naming of the<br>&gt; replacement<br>&gt; function.<br>&gt;<br>&gt; extension Bool {<br>&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f:<br>&gt; @autoclosure () -&gt; T) -&gt; T {<br>&gt;         if self {<br>&gt;             return t()<br>&gt;         } else {<br>&gt;             return f()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt;<br>&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt;<br>&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T)<br>&gt; -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt; functions that achieve the same thing.<br>&gt;<br>&gt; Example usage:<br>&gt;<br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt;<br>&gt; Impact on existing code<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; Alternatives considered<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt;<br>&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt; introduce any new concepts.<br>&gt;<br>&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt; This would have the disadvantages of still needing special handling by the<br>&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt; users in a similar way to how `?:` does.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/2977ca2d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 9:12 AM, Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong +1 from me.<br>&gt; <br>&gt; This simply feels like the right approach for Swift, as we see the language head in a direction that has abandoned traditional C-style idioms. As swift has already dropped support for the ++/-- operators and C-style for loops it makes logical sense that dropping the ternary operator (or replacing with a more Swift-like idiom) should follow.<br>&gt; <br>&gt; As a side note, after upgrading my swift code to Swift 3, I feel as though I&#39;ve become un-phased at future source breaking changes until full stability is met and set in stone. If they&#39;re worth it, bring them on, I say.<br></p><p><br>Training users to expect source-breaking churn would be highly damaging to the language. The removal of C-style for loops and increment/decrement operators came with sufficient justification beyond their being inherited from C. I don’t think there’s a sufficient justification for this change, especially with the bar set high for such changes. <br></p><p>Preston<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/681b48a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Mark Sands</string> &lt;marksands07 at gmail.com&gt;<p>October 26, 2016 at 11:00:00am</p></header><div class="content"><p>Training users to expect source-breaking churn would be highly damaging to<br>&gt; the language. The removal of C-style for loops and increment/decrement<br>&gt; operators came with sufficient justification beyond their being inherited<br>&gt; from C. I don’t think there’s a sufficient justification for this change,<br>&gt; especially with the bar set high for such changes.<br>&gt;<br>&gt; Preston<br>&gt;<br></p><p>My apologies for skewing the conversation off-topic. I think what I meant<br>to imply is that we shouldn&#39;t be afraid of a deprecation warning. Migrating<br>away from a ternary operator is trivial, and the consequences usually come<br>with better readability.<br></p><p>Ignoring my statement about &quot;leftovers from C&quot; opposition, I *do* think<br>there is sufficient and very strong justification from the 10 items that<br>Charlotte has listed. I think it would be more valuable if one could pick<br>apart each bullet point they find excusable and list their reasons why it&#39;s<br>not compelling enough to warrant change.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/1bc653cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f526807a5a76bc96427760ca78707cfb?s=50"></div><header><strong>[External] Re: [Pitch] Replace the ternary operator with an in-language function</strong> from <string>Jon Akhtar</string> &lt;jona at herbalife.com&gt;<p>October 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I think that we need to get past the “leftovers from C” being a bad thing mindset. Familiar constructs make Swift easier for programmers (its target audience) easier to learn.<br></p><p>Point by point:<br></p><p><br>  1.  Being a holdover from C isn’t a bad thing. We can take things that were useful in C and make them part of Swift. Who said C language elements were a non-goal of Swift. And to the “ternary operator is hard to learn” point. This point gets made over and over in proposals to change Swift, ease of learning is like performance and security – you can never have enough so there is no counter-argument. If you can’t learn the ternary operator, Swift isn’t the language for you, because what are you going to do when you get to generics and higher order functions.<br>  2.  If the ternary operator adds complexity to the compiler then it really isn’t a holdover from C. We have quite a long time to know how to parse it from our C legacy.<br>  3.  See #1, new users are always confused about everything. They don’t stay that way. The language doesn’t need to be tuned to support it’s non-users. Most developers understand the ternary operator, and it is useful to them. Who is this language for?<br>  4.  The “:” appears in other places in the grammar. So what. So do parenthesis and brackets. It is just a token used in a grammar rule as a separator, it doesn’t have a meaning on its own, and it shouldn’t have one that isn’t its function.<br>  5.  So your argument is to make the ternary expression longer to discourage nesting. This is much different than the argument for function(a++, ++a) where order of function parameter evaluation influenced the code, but was not expressed by it. Everything is fully expressed by the ternary operator including order of evaluation.<br>  6.  I see no problem with it being limited to bool. I don’t want Javascript’s “” == false.<br>  7.  What would be proposed (and has been) is the if expression which is more verbose but easier to read<br>  8.  Again, the C hate.<br>  9.  You leave out the reason for those languages to leave out the ternary operator. What was their rationale?<br>  10. I’m sorry you had a hard time with it. But you learned it, and now you can apply that knowledge to any language that has it. To add to the anecdotal evidence you provided, I did not have a hard time learning it.<br></p><p>I can distill this down to “C is old and not modern so lets get rid of anything from C” and “I had a hard time learning the ternary operator&quot;<br></p><p>Bottom line, most developers know the ternary expression if they come from C, C++, Obj-C, Java, C# (The list goes on). Why does Swift need to be different for style reasons. We will be making a niche language, because what you learn isn’t portable to another language like it is if you learn Java, then get a job programming in C#.<br></p><p><br></p><p>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Mark Sands via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Mark Sands &lt;marksands07 at gmail.com&lt;mailto:marksands07 at gmail.com&gt;&gt;<br>Date: Wednesday, October 26, 2016 at 09:55<br>To: William Sumner &lt;prestonsumner at me.com&lt;mailto:prestonsumner at me.com&gt;&gt;<br>Cc: Swift-Evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: [External] Re: [swift-evolution] [Pitch] Replace the ternary operator with an in-language function<br></p><p><br></p><p>Training users to expect source-breaking churn would be highly damaging to the language. The removal of C-style for loops and increment/decrement operators came with sufficient justification beyond their being inherited from C. I don’t think there’s a sufficient justification for this change, especially with the bar set high for such changes.<br></p><p>Preston<br></p><p>My apologies for skewing the conversation off-topic. I think what I meant to imply is that we shouldn&#39;t be afraid of a deprecation warning. Migrating away from a ternary operator is trivial, and the consequences usually come with better readability.<br></p><p>Ignoring my statement about &quot;leftovers from C&quot; opposition, I do think there is sufficient and very strong justification from the 10 items that Charlotte has listed. I think it would be more valuable if one could pick apart each bullet point they find excusable and list their reasons why it&#39;s not compelling enough to warrant change.<br>+ V2 Checkin API<br>+ V2 Checkout API<br>+ V2 Get Admission Records [Updated]<br>+ V2 Get Scan Records<br>- New SQLite Data File generation<br>- V2 Get User Events<br>- V2 Scan Record Submission<br></p><p>- GDO Ticket Purchase Integration API<br></p><p>- V2 Get Ticket Record(s) [New]<br>- V2 Ticket Creation API [Updated]<br>- V2 Ticket Info API [New]<br>- V2 Ticket Transfer API [New]<br>- V2 Ticket Re-issue API [New]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/329bb550/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[External] Re: [Pitch] Replace the ternary operator with an in-language function</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Very well said, thanks :)!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 26 Oct 2016, at 18:57, Jon Akhtar via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that we need to get past the “leftovers from C” being a bad thing mindset. Familiar constructs make Swift easier for programmers (its target audience) easier to learn.<br>&gt; <br>&gt; Point by point:<br>&gt; <br>&gt; Being a holdover from C isn’t a bad thing. We can take things that were useful in C and make them part of Swift. Who said C language elements were a non-goal of Swift. And to the “ternary operator is hard to learn” point. This point gets made over and over in proposals to change Swift, ease of learning is like performance and security – you can never have enough so there is no counter-argument. If you can’t learn the ternary operator, Swift isn’t the language for you, because what are you going to do when you get to generics and higher order functions.<br>&gt; If the ternary operator adds complexity to the compiler then it really isn’t a holdover from C. We have quite a long time to know how to parse it from our C legacy.<br>&gt; See #1, new users are always confused about everything. They don’t stay that way. The language doesn’t need to be tuned to support it’s non-users. Most developers understand the ternary operator, and it is useful to them. Who is this language for?<br>&gt; The “:” appears in other places in the grammar. So what. So do parenthesis and brackets. It is just a token used in a grammar rule as a separator, it doesn’t have a meaning on its own, and it shouldn’t have one that isn’t its function.<br>&gt; So your argument is to make the ternary expression longer to discourage nesting. This is much different than the argument for function(a++, ++a) where order of function parameter evaluation influenced the code, but was not expressed by it. Everything is fully expressed by the ternary operator including order of evaluation.<br>&gt; I see no problem with it being limited to bool. I don’t want Javascript’s “” == false.<br>&gt; What would be proposed (and has been) is the if expression which is more verbose but easier to read<br>&gt; Again, the C hate.<br>&gt; You leave out the reason for those languages to leave out the ternary operator. What was their rationale?<br>&gt; I’m sorry you had a hard time with it. But you learned it, and now you can apply that knowledge to any language that has it. To add to the anecdotal evidence you provided, I did not have a hard time learning it.<br>&gt; I can distill this down to “C is old and not modern so lets get rid of anything from C” and “I had a hard time learning the ternary operator&quot;<br>&gt; <br>&gt; Bottom line, most developers know the ternary expression if they come from C, C++, Obj-C, Java, C# (The list goes on). Why does Swift need to be different for style reasons. We will be making a niche language, because what you learn isn’t portable to another language like it is if you learn Java, then get a job programming in C#.<br>&gt; <br>&gt; <br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org&gt; on behalf of Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Reply-To: Mark Sands &lt;marksands07 at gmail.com&gt;<br>&gt; Date: Wednesday, October 26, 2016 at 09:55<br>&gt; To: William Sumner &lt;prestonsumner at me.com&gt;<br>&gt; Cc: Swift-Evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: [External] Re: [swift-evolution] [Pitch] Replace the ternary operator with an in-language function<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Training users to expect source-breaking churn would be highly damaging to the language. The removal of C-style for loops and increment/decrement operators came with sufficient justification beyond their being inherited from C. I don’t think there’s a sufficient justification for this change, especially with the bar set high for such changes. <br>&gt;&gt; <br>&gt;&gt; Preston<br>&gt; <br>&gt; My apologies for skewing the conversation off-topic. I think what I meant to imply is that we shouldn&#39;t be afraid of a deprecation warning. Migrating away from a ternary operator is trivial, and the consequences usually come with better readability.<br>&gt; <br>&gt; Ignoring my statement about &quot;leftovers from C&quot; opposition, I do think there is sufficient and very strong justification from the 10 items that Charlotte has listed. I think it would be more valuable if one could pick apart each bullet point they find excusable and list their reasons why it&#39;s not compelling enough to warrant change.<br>&gt; + V2 Checkin API<br>&gt; + V2 Checkout API<br>&gt; + V2 Get Admission Records [Updated]<br>&gt; + V2 Get Scan Records<br>&gt; - New SQLite Data File generation<br>&gt; - V2 Get User Events<br>&gt; - V2 Scan Record Submission<br>&gt; <br>&gt; - GDO Ticket Purchase Integration API<br>&gt; <br>&gt; - V2 Get Ticket Record(s) [New]<br>&gt; - V2 Ticket Creation API [Updated]<br>&gt; - V2 Ticket Info API [New]<br>&gt; - V2 Ticket Transfer API [New]<br>&gt; - V2 Ticket Re-issue API [New]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/e5c4e94c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[External] Re: [Pitch] Replace the ternary operator with an in-language function</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 26 Oct 2016, at 18:57, Jon Akhtar via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that we need to get past the “leftovers from C” being a bad thing mindset. Familiar constructs make Swift easier for programmers (its target audience) easier to learn.<br>&gt; <br>&gt; Point by point:<br>&gt; <br>&gt; Being a holdover from C isn’t a bad thing. We can take things that were useful in C and make them part of Swift. Who said C language elements were a non-goal of Swift. And to the “ternary operator is hard to learn” point. This point gets made over and over in proposals to change Swift, ease of learning is like performance and security – you can never have enough so there is no counter-argument. If you can’t learn the ternary operator, Swift isn’t the language for you, because what are you going to do when you get to generics and higher order functions.<br>&gt; If the ternary operator adds complexity to the compiler then it really isn’t a holdover from C. We have quite a long time to know how to parse it from our C legacy.<br>&gt; See #1, new users are always confused about everything. They don’t stay that way. The language doesn’t need to be tuned to support it’s non-users. Most developers understand the ternary operator, and it is useful to them. Who is this language for?<br>&gt; The “:” appears in other places in the grammar. So what. So do parenthesis and brackets. It is just a token used in a grammar rule as a separator, it doesn’t have a meaning on its own, and it shouldn’t have one that isn’t its function.<br>&gt; So your argument is to make the ternary expression longer to discourage nesting. This is much different than the argument for function(a++, ++a) where order of function parameter evaluation influenced the code, but was not expressed by it. Everything is fully expressed by the ternary operator including order of evaluation.<br>&gt; I see no problem with it being limited to bool. I don’t want Javascript’s “” == false.<br>&gt; What would be proposed (and has been) is the if expression which is more verbose but easier to read<br>&gt; Again, the C hate.<br>&gt; You leave out the reason for those languages to leave out the ternary operator. What was their rationale?<br>&gt; I’m sorry you had a hard time with it. But you learned it, and now you can apply that knowledge to any language that has it. To add to the anecdotal evidence you provided, I did not have a hard time learning it.<br>&gt; I can distill this down to “C is old and not modern so lets get rid of anything from C” and “I had a hard time learning the ternary operator&quot;<br>&gt; <br>&gt; Bottom line, most developers know the ternary expression if they come from C, C++, Obj-C, Java, C# (The list goes on). Why does Swift need to be different for style reasons. We will be making a niche language, because what you learn isn’t portable to another language like it is if you learn Java, then get a job programming in C#.<br></p><p>While I agree on most of this, I think there is reasonable justification to discuss this on the basis of it using the question-mark; Swift uses the question mark extensively for handling of optionals, so there is an element of confusion present there, it also uses the colon in a somewhat unfamiliar way as well, so it&#39;s a twofold oddity in Swift.<br></p><p>That said, I&#39;m not sure replacing it with a function is superior; this is something you can do yourself easily enough if you feel you need to, and which learners can likewise do if they don&#39;t know about, or don&#39;t like the operator.<br></p><p>So the question really is whether there&#39;s an alternative that is similarly concise, and on that I&#39;m not so sure, so I&#39;d lean towards leaving it as it is, but advising people to be careful about where they use it, as its very advantage in size can be a disadvantage in readability, so it should be used with care at all times.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/15d37f05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[External] Re: [Pitch] Replace the ternary operator with an in-language function</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 26, 2016 at 09:00:00pm</p></header><div class="content"><p>On Oct 26, 2016, at 11:54 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Bottom line, most developers know the ternary expression if they come from C, C++, Obj-C, Java, C# (The list goes on). Why does Swift need to be different for style reasons. We will be making a niche language, because what you learn isn’t portable to another language like it is if you learn Java, then get a job programming in C#.<br>&gt; <br>&gt; While I agree on most of this, I think there is reasonable justification to discuss this on the basis of it using the question-mark; Swift uses the question mark extensively for handling of optionals, so there is an element of confusion present there, it also uses the colon in a somewhat unfamiliar way as well, so it&#39;s a twofold oddity in Swift.<br>&gt; <br>&gt; That said, I&#39;m not sure replacing it with a function is superior; this is something you can do yourself easily enough if you feel you need to, and which learners can likewise do if they don&#39;t know about, or don&#39;t like the operator.<br>&gt; <br>&gt; So the question really is whether there&#39;s an alternative that is similarly concise, and on that I&#39;m not so sure, so I&#39;d lean towards leaving it as it is, but advising people to be careful about where they use it, as its very advantage in size can be a disadvantage in readability, so it should be used with care at all times.<br></p><p>I’ll add a couple of more points:<br></p><p>1. This was extensively discussed in the Swift 3 release cycle, in multiple threads, and never went anywhere.<br>2. Changing this in Swift 4 is extremely unlikely even if there is a good answer, because - unlike in Swift 3 timeframe - any change that breaks source code needs extreme justification of why it is the right long term thing to do.  I can’t fathom a rationale for this in the case of the ?: operator.  Merely being potentially confusing is not enough.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/6d2207b9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[External] Re: [Pitch] Replace the ternary operator with an in-language function</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>October 27, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 to Jon&#39;s answer.<br>-1 to the proposal. I have argued in the past for introducing an if-then-else expression instead of the ternary operator but I wouldn&#39;t replace it with a clunky function which reduces readability a lot IMHO.<br></p><p>-Thorsten <br></p><p>&gt; Am 26.10.2016 um 19:57 schrieb Jon Akhtar via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I think that we need to get past the “leftovers from C” being a bad thing mindset. Familiar constructs make Swift easier for programmers (its target audience) easier to learn.<br>&gt; <br>&gt; Point by point:<br>&gt; <br>&gt; Being a holdover from C isn’t a bad thing. We can take things that were useful in C and make them part of Swift. Who said C language elements were a non-goal of Swift. And to the “ternary operator is hard to learn” point. This point gets made over and over in proposals to change Swift, ease of learning is like performance and security – you can never have enough so there is no counter-argument. If you can’t learn the ternary operator, Swift isn’t the language for you, because what are you going to do when you get to generics and higher order functions.<br>&gt; If the ternary operator adds complexity to the compiler then it really isn’t a holdover from C. We have quite a long time to know how to parse it from our C legacy.<br>&gt; See #1, new users are always confused about everything. They don’t stay that way. The language doesn’t need to be tuned to support it’s non-users. Most developers understand the ternary operator, and it is useful to them. Who is this language for?<br>&gt; The “:” appears in other places in the grammar. So what. So do parenthesis and brackets. It is just a token used in a grammar rule as a separator, it doesn’t have a meaning on its own, and it shouldn’t have one that isn’t its function.<br>&gt; So your argument is to make the ternary expression longer to discourage nesting. This is much different than the argument for function(a++, ++a) where order of function parameter evaluation influenced the code, but was not expressed by it. Everything is fully expressed by the ternary operator including order of evaluation.<br>&gt; I see no problem with it being limited to bool. I don’t want Javascript’s “” == false.<br>&gt; What would be proposed (and has been) is the if expression which is more verbose but easier to read<br>&gt; Again, the C hate.<br>&gt; You leave out the reason for those languages to leave out the ternary operator. What was their rationale?<br>&gt; I’m sorry you had a hard time with it. But you learned it, and now you can apply that knowledge to any language that has it. To add to the anecdotal evidence you provided, I did not have a hard time learning it.<br>&gt; I can distill this down to “C is old and not modern so lets get rid of anything from C” and “I had a hard time learning the ternary operator&quot;<br>&gt; <br>&gt; Bottom line, most developers know the ternary expression if they come from C, C++, Obj-C, Java, C# (The list goes on). Why does Swift need to be different for style reasons. We will be making a niche language, because what you learn isn’t portable to another language like it is if you learn Java, then get a job programming in C#.<br>&gt; <br>&gt; <br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org&gt; on behalf of Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Reply-To: Mark Sands &lt;marksands07 at gmail.com&gt;<br>&gt; Date: Wednesday, October 26, 2016 at 09:55<br>&gt; To: William Sumner &lt;prestonsumner at me.com&gt;<br>&gt; Cc: Swift-Evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: [External] Re: [swift-evolution] [Pitch] Replace the ternary operator with an in-language function<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Training users to expect source-breaking churn would be highly damaging to the language. The removal of C-style for loops and increment/decrement operators came with sufficient justification beyond their being inherited from C. I don’t think there’s a sufficient justification for this change, especially with the bar set high for such changes. <br>&gt;&gt; <br>&gt;&gt; Preston<br>&gt; <br>&gt; My apologies for skewing the conversation off-topic. I think what I meant to imply is that we shouldn&#39;t be afraid of a deprecation warning. Migrating away from a ternary operator is trivial, and the consequences usually come with better readability.<br>&gt; <br>&gt; Ignoring my statement about &quot;leftovers from C&quot; opposition, I do think there is sufficient and very strong justification from the 10 items that Charlotte has listed. I think it would be more valuable if one could pick apart each bullet point they find excusable and list their reasons why it&#39;s not compelling enough to warrant change.<br>&gt; + V2 Checkin API<br>&gt; + V2 Checkout API<br>&gt; + V2 Get Admission Records [Updated]<br>&gt; + V2 Get Scan Records<br>&gt; - New SQLite Data File generation<br>&gt; - V2 Get User Events<br>&gt; - V2 Scan Record Submission<br>&gt; <br>&gt; - GDO Ticket Purchase Integration API<br>&gt; <br>&gt; - V2 Get Ticket Record(s) [New]<br>&gt; - V2 Ticket Creation API [Updated]<br>&gt; - V2 Ticket Info API [New]<br>&gt; - V2 Ticket Transfer API [New]<br>&gt; - V2 Ticket Re-issue API [New]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/c60e421f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>You and I discussed this at length in iOS Folks, but I&#39;ll restate here. I&#39;d be against this proposal. I think it adds unnecessary verbosity vs a simple and elegant representation. As an inherently functional alternative to if-then-else, Swift&#39;s ternary form is clear and parsimonious, perfect for simple expressions. Converting to a more laborious syntax takes away these advantages, and I&#39;d be tempted to write my own operators to mimic their functionality rather than use your syntax.<br></p><p>I&#39;m glad you brought the proposal here and thank you for your effort in writing it up.<br></p><p>-- E<br></p><p><br>&gt; On Oct 25, 2016, at 10:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt; <br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt; <br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt; <br>&gt; Replace the `?:` operator with an in-language function<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/88473402/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 23:51, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Disadvantages of The Ternary Operator<br>&gt; <br>&gt; [...]<br>&gt; <br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt; <br>&gt; [...]<br>&gt; <br>&gt; Proposed Approach<br>&gt; <br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br></p><p>I&#39;m not sure proposals should do exactly what they claim is a downside of the current approach. Especially when the downside in question is inherent to the problem being solved.<br></p><p>FWIW, the only thing I find confusing about the ternary operator is that I can&#39;t overload it. Being able to define my own ternary operators would be great, but I don&#39;t have an answer to obvious potential ambiguities.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/aa8ec938/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 27, 2016 at 02:00:00am</p></header><div class="content"><p>David, you can use two binary operators (or overload the same one twice if<br>you want) to create syntax that behaves like a ternary operator.<br></p><p>Here’s an example of using a pair of operators to interpolate between two<br>CGPoint values:<br></p><p>let interpolatedPoint = p1 &lt;~~ 0.3 ~~&gt; p2<br></p><p>See here<br>&lt;https://github.com/j-h-a/Animation/blob/develop/Animation/Interpolation.swift&gt;<br>for the code that defines them.<br></p><p>I went for two different operators in the end, but when experimenting I<br>also tried using the same one, and it works fine because of overloading,<br>for example:<br></p><p>infix operator ~~&gt; : InterpolationPrecedence<br>public func ~~&gt; &lt;T: Interpolatable&gt;(from: T, alpha: Double) -&gt; (T, Double) {<br>    return (from, alpha)<br>}<br>public func ~~&gt; &lt;T: Interpolatable&gt;(lhs: (T, Double), rhs: T) -&gt; T {<br>    return lerp(from: lhs.0, to: rhs, alpha: lhs.1)<br>}let interpolatedPoint = p1 ~~&gt; 0.3 ~~&gt; p2<br></p><p>And as Anton demonstrated earlier, ?: can be emulated the same way. The<br>errors you would get if you omitted the second operator and third part are<br>not as useful as they can be with ?:. The compiler can probably do a much<br>better job of optimising with ?: as a special case, and it’s a common<br>pattern regardless of syntax, so people would just write their own if it<br>wasn’t there. So I think it makes sense to have it in the language. And if<br>it wasn’t already there, I do think that it would be something we should<br>add (same for ??).<br>​<br></p><p>On Thu, 27 Oct 2016 at 01:44 David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 25, 2016, at 23:51, Charlotte Angela Tortorella via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Disadvantages of The Ternary Operator<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt;<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt;<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; Proposed Approach<br>&gt; &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt;<br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure proposals should do exactly what they claim is a downside of<br>&gt; the current approach. Especially when the downside in question is<br>&gt; inherent to the problem being solved.<br>&gt;<br>&gt; FWIW, the only thing I find confusing about the ternary operator is that I<br>&gt; can&#39;t overload it. Being able to define my own ternary operators would be<br>&gt; great, but I don&#39;t have an answer to obvious potential ambiguities.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/0a647b0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 27, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 21:29, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; David, you can use two binary operators (or overload the same one twice if you want) to create syntax that behaves like a ternary operator.<br>&gt; <br>Oh I know, it&#39;s just kinda clunky and inefficient sometimes, if you need to wrap a value in a struct or something simply to avoid ambiguity or enforce the correct syntax. It&#39;s not quite the same thing a ternary operator, but at one point I&#39;d added `|` as both pre and postfix operators to allow code like &quot;let y = |x|&quot;. The left `|` had to return a `_PartialAbsValueOp` and the right one had to take the same to invalidate the &quot;let y = |x&quot; or &quot;let y = x|&quot; syntax, one of which would&#39;ve otherwise worked (depending on which op actually called &quot;abs()&quot;).<br></p><p>I should&#39;ve been clearer that I was talking about support for &quot;free form&quot; operators in general, including ternary ops, so that we don&#39;t have to fake them by declaring some # of traditional pre/in/postfix operators which all then have to work together (possibly exclusively, depending on the desired syntax), and might have to pass wrapper types around solely to help explain your syntax to the compiler.<br></p><p>Thanks for pointing it out, though. That&#39;s an easy trick to forget about.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/89f36b35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 27, 2016 at 10:00:00am</p></header><div class="content"><p>David,<br></p><p>You make some good points in favour of explicit support for user-defined<br>ternary operators. You&#39;re right that it&#39;s a bit clunky without. Probably a<br>discussion for another thread though, and additive so not for phase 1. But<br>perhaps worth a proposal for phase 2?<br></p><p>On Thu, 27 Oct 2016 at 09:23 David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 26, 2016, at 21:29, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; David, you can use two binary operators (or overload the same one twice if<br>&gt; you want) to create syntax that behaves like a ternary operator.<br>&gt;<br>&gt; Oh I know, it&#39;s just kinda clunky and inefficient sometimes, if you need<br>&gt; to wrap a value in a struct or something simply to avoid ambiguity or<br>&gt; enforce the correct syntax. It&#39;s not quite the same thing a ternary<br>&gt; operator, but at one point I&#39;d added `|` as both pre and postfix operators<br>&gt; to allow code like &quot;let y = |x|&quot;. The left `|` had to return a<br>&gt; `_PartialAbsValueOp` and the right one had to take the same to invalidate<br>&gt; the &quot;let y = |x&quot; or &quot;let y = x|&quot; syntax, one of which would&#39;ve otherwise<br>&gt; worked (depending on which op actually called &quot;abs()&quot;).<br>&gt;<br>&gt; I should&#39;ve been clearer that I was talking about support for &quot;free form&quot;<br>&gt; operators in general, including ternary ops, so that we don&#39;t have to fake<br>&gt; them by declaring some # of traditional pre/in/postfix operators which all<br>&gt; then have to work together (possibly exclusively, depending on the desired<br>&gt; syntax), and might have to pass wrapper types around solely to help explain<br>&gt; your syntax to the compiler.<br>&gt;<br>&gt; Thanks for pointing it out, though. That&#39;s an easy trick to forget about.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/8dc570dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 27, 2016 at 05:00:00am</p></header><div class="content"><p>Oh, yeah, sorry, didn&#39;t mean to get so far OT<br></p><p>Sent from my iPhone<br></p><p>&gt; On Oct 27, 2016, at 05:20, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; David,<br>&gt; <br>&gt; You make some good points in favour of explicit support for user-defined ternary operators. You&#39;re right that it&#39;s a bit clunky without. Probably a discussion for another thread though, and additive so not for phase 1. But perhaps worth a proposal for phase 2?<br>&gt; <br>&gt;&gt; On Thu, 27 Oct 2016 at 09:23 David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 21:29, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David, you can use two binary operators (or overload the same one twice if you want) to create syntax that behaves like a ternary operator.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Oh I know, it&#39;s just kinda clunky and inefficient sometimes, if you need to wrap a value in a struct or something simply to avoid ambiguity or enforce the correct syntax. It&#39;s not quite the same thing a ternary operator, but at one point I&#39;d added `|` as both pre and postfix operators to allow code like &quot;let y = |x|&quot;. The left `|` had to return a `_PartialAbsValueOp` and the right one had to take the same to invalidate the &quot;let y = |x&quot; or &quot;let y = x|&quot; syntax, one of which would&#39;ve otherwise worked (depending on which op actually called &quot;abs()&quot;).<br>&gt;&gt; <br>&gt;&gt; I should&#39;ve been clearer that I was talking about support for &quot;free form&quot; operators in general, including ternary ops, so that we don&#39;t have to fake them by declaring some # of traditional pre/in/postfix operators which all then have to work together (possibly exclusively, depending on the desired syntax), and might have to pass wrapper types around solely to help explain your syntax to the compiler.<br>&gt;&gt; <br>&gt;&gt; Thanks for pointing it out, though. That&#39;s an easy trick to forget about.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/1d2524bb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Pitch] Replace the ternary operator with an in-language function</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 27, 2016 at 11:00:00am</p></header><div class="content"><p>I’d like to put in a word in appreciate of such a careful presentation of the idea. While it doesn’t change the fact that this is out of scope for Swift 4, it’s nice to read something so thoughtfully spelled out. Charlotte, I hope you’ll keep bringing your ideas.<br></p><p>FWIW, while I rather like the ternary operator, I’m also a fan of promoting existing if statements to expressions. I hope that we can revisit that discussion in the future.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>&gt; On Oct 25, 2016, at 11:51 PM, Charlotte Angela Tortorella via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Preamble: I&#39;ve read over the threads that already exist about the ternary operator and to be honest they&#39;re a complete mess without a single fully formed proposal.<br>&gt; <br>&gt; Pitch: I&#39;d like to simplify the syntax, compiler complexity and learning curve for newcomers when it comes to dealing with the ternary function. The best way to do that, in my opinion, is to remove it entirely and add a new function with better semantics that takes care of ternary operations entirely within the Swift language.<br>&gt; <br>&gt; gist: https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c&gt;<br>&gt; <br>&gt; Replace the `?:` operator with an in-language function<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: [Charlotte Tortorella](https://github.com/qata &lt;https://github.com/qata&gt;)<br>&gt; Editor: [Soroush Khanlou](https://github.com/khanlou &lt;https://github.com/khanlou&gt;)<br>&gt; Review Manager: TBD<br>&gt; Status: TBD<br>&gt; <br>&gt; Introduction &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#introduction&gt;<br>&gt; <br>&gt; The ternary operator in Swift was added early in development, as a holdover<br>&gt; from C.  This document is an attempt to provide a clear look at the ternary<br>&gt; operator without the baggage of the languages that came before, and comes<br>&gt; to the conclusion that we should deprecate and remove the ternary operator<br>&gt; in favor of an extension to `Bool`.<br>&gt; <br>&gt; As a quick refresher, here&#39;s what the ternary operator looks like:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; // If a is less than b, sets e to &quot;foo&quot;, else sets e to &quot;bar&quot;<br>&gt; let e = a &lt; b ? &quot;foo&quot; : &quot;bar&quot;<br>&gt; <br>&gt; Advantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#advantages-of-the-ternary-operator&gt;<br>&gt; <br>&gt; The primary advantage of this operator is its terseness and expressive<br>&gt; capability. It&#39;s shorthand for (e.g.):<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; let e: String<br>&gt; if a &lt; b {<br>&gt;   e = &quot;foo&quot;<br>&gt; } else {<br>&gt;   e = &quot;bar&quot;<br>&gt; }<br>&gt; <br>&gt; The second advantage of Swift supporting the ternary operator is continuity<br>&gt; with C, and other common languages in the extended C family (C++, Objective-C,<br>&gt; Java, C#, Javascript, etc).  People coming to Swift from these other languages<br>&gt; may reasonably expect this operator to exist.  That said, there are also<br>&gt; popular languages which have kept the majority of C operators but dropped the<br>&gt; ternary operator (e.g. [Go](https://golang.org/doc/faq#Does_Go_have_a_ternary_form &lt;https://golang.org/doc/faq#Does_Go_have_a_ternary_form&gt;) and [Rust](https://github.com/rust-lang/rfcs/issues/1362 &lt;https://github.com/rust-lang/rfcs/issues/1362&gt;)).<br>&gt; <br>&gt; <br>&gt; Disadvantages of The Ternary Operator &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#disadvantages-of-the-ternary-operator&gt;<br>&gt; <br>&gt; 1. The existence of the ternary operator as a holdover from C is to increase<br>&gt; the familiarity of the Swift language for C family developers, at the expense<br>&gt; of newcomers.  Established developers do much better with learning concepts<br>&gt; than newcomers to programming and probably don&#39;t need their hands held<br>&gt; with this carry over of an operator.<br>&gt; <br>&gt; 2. The ternary operator adds complexity to the compiler, because it requires<br>&gt; special handling.  It is the only operator that requires two components to<br>&gt; work (both the `?` and the `:`), it uses a character that is excluded from<br>&gt; being used in other operators (`:`), and it isn&#39;t defined in the standard<br>&gt; library.<br>&gt; <br>&gt; 3. The ternary operator&#39;s usage of `?` can be confusing<br>&gt; to new users.  Every other instance of `?` is associated with<br>&gt; `Optional` values.<br>&gt; <br>&gt; 4. The ternary operator uses `:`, which is already a heavily overloaded<br>&gt; symbol in Swift.  `:` is used in hash tables, type annotations for variables,<br>&gt; class inheritance, and protocol conformance.<br>&gt; <br>&gt; 5. The ternary operator&#39;s short length lends it to being abused in the<br>&gt; nested ternary operator anti-pattern.  This is similar to the `++` and<br>&gt; `--` operators, which were removed in Swift 3.  While they worked fine and were<br>&gt; readable enough when used alone, using them multiple times in a single<br>&gt; expression like `function(a++, ++a)` made them highly unreadable and<br>&gt; confusing.<br>&gt; <br>&gt; 6. This operator is only applicable to a single type, `Bool`.<br>&gt; <br>&gt; 7. If the ternary operator weren&#39;t in common usage, it would not be proposed<br>&gt; for Swift.  Higher clarity can be achieved with common language features by<br>&gt; creating an extension to `Bool`.<br>&gt; <br>&gt; 8. The ternary operator was created for and is much more suited to a language<br>&gt; like C, where there were no generics and as such no alternative to an<br>&gt; unintuitive operator.<br>&gt; <br>&gt; 9. Several other modern languages, like Rust and Go discussed earlier, have<br>&gt; eschewed the usage of the ternary operator entirely.  Other languages that have<br>&gt; special constructs similar to `?:`, such as `if then else` in Haskell have<br>&gt; [discussed removing it](https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F &lt;https://wiki.haskell.org/If-then-else#Is_If-Then-Else_so_important.3F&gt;).  `if then else` is identical to the `?:` operator,<br>&gt; excepting that it&#39;s prefixed by `if`, while `?:` has no prefix.<br>&gt; <br>&gt;  Example: `if True then 10 else 20`<br>&gt; <br>&gt; 10. On a more personal and anecdotal note, the ternary operator gave me more<br>&gt; trouble than any other operator when I was first learning how to program.<br>&gt; I’ve also spoken to several other people who expressed similar sentiments<br>&gt; about this operator’s inscrutability.<br>&gt; <br>&gt; Proposed Approach &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#proposed-approach&gt;<br>&gt; <br>&gt; We should drop the ternary operator in favor of a new extension to `Bool`.<br>&gt; There are a few possibilities for the naming of this function.  We&#39;ve provided<br>&gt; four for consideration in this proposal, but are open to other options as well.<br>&gt; This proposal is much more about the concept than the naming of the replacement<br>&gt; function.<br>&gt; <br>&gt; extension Bool {<br>&gt;     /// If `self == true`, returns `t`, otherwise, returns `f`.<br>&gt;     func transformed&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;         if self {<br>&gt;             return t()<br>&gt;         } else {<br>&gt;             return f()  <br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func when&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(true t: @autoclosure () -&gt; T, false f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     func if&lt;T&gt;(then t: @autoclosure () -&gt; T, else f: @autoclosure () -&gt; T) -&gt; T {<br>&gt;       ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Only one of these should be chosen.  We&#39;re not proposing adding multiple<br>&gt; functions that achieve the same thing.<br>&gt; <br>&gt; Example usage:<br>&gt; <br>&gt; let a = 10<br>&gt; let b = 20<br>&gt; _ = (a &lt; b).transformed(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).when(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(true: &quot;foo&quot;, false: &quot;bar&quot;)<br>&gt; _ = (a &lt; b).if(then: &quot;foo&quot;, else: &quot;bar&quot;)<br>&gt; <br>&gt; Impact on existing code &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#impact-on-existing-code&gt;<br>&gt; <br>&gt; This proposal is breaking and would require migration.<br>&gt; <br>&gt; Alternatives considered &lt;https://gist.github.com/Qata/25a11c21200f1cf8f43ed78e9ffd727c#alternatives-considered&gt;<br>&gt; <br>&gt; Simplest alternative: we could leave the ternary operator as is and not<br>&gt; introduce any new concepts.<br>&gt; <br>&gt; It&#39;d also be possible to add an `if then else` Haskell-esque expression.<br>&gt; This would have the disadvantages of still needing special handling by the<br>&gt; compiler.  Since this proposal&#39;s intention is partially to remove compiler<br>&gt; complexity, this would be counterproductive and would probably confuse new<br>&gt; users in a similar way to how `?:` does.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/0a86176c/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
