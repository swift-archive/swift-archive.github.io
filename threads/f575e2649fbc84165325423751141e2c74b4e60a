<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Given that we now have error handling and availability checks does it make<br>sense to have Failable Initializers which date back to Swift 1.1?<br></p><p>Take this model<br></p><p>struct MyModel {<br></p><p>let someProperty<br>let anotherProperty<br>}<br></p><p>Lets say we have a Initializers for this structure that takes a JSON<br>structure and returns an i.<br></p><p>We could guarantee that it always returns an instance but then we have to<br>populate this data with dummy values if the JSON is missing values.<br></p><p>I could make these properties optional to reflect that the JSON was missing<br>information but I would be making the structure mutable which adds<br>complexity. On-top of that I wouldn&#39;t be able to tell if the property is<br>nil due to a lack of a value or a bug causing certain JSON information to<br>be missing.<br></p><p>So lets look at the alternatives with a non-guranteed system, well we<br>have Failable Initializers. If any of the properties are missing, we should<br>return nil.<br></p><p>Well we have this issue:<br></p><p>MyModel(json)<br></p><p>It isn&#39;t clear that this is fallable compared to a traditional initializer<br>unless swift was update to, meaning we may forget to handle the nil case:<br></p><p> *MyModel?(json)*<br></p><p>This isn&#39;t all that is wrong with this approach, if this method does a lot<br>of steps to create the object and fails (Like parsing an object from JSON).<br>Returning nil but we have no idea why, it makes it easy to introduce<br>silently failing errors.<br></p><p>Its true some classes may do this when ran on a older version of iOS but<br>with avaliabilty checks, this use case is irrelevant.<br></p><p>So what about throwing an error?<br></p><p>It forces us to handle it failing to initialize for some reason.<br></p><p>- If we forget to handle the error, the app won&#39;t be allowed to continue<br>with this corrupted data - and the error will be informative as it forces<br>us to create an ErrorType.<br>- If we want to ignore this object and convert the error to nil we can<br>still use *try? *(For example in a Chat application you could ignore<br>corrupted messages).<br>- In these cases where we ignore the error using *try?* it makes it super<br>obvious we are ignoring an error and it should be easy to that error<br>causing it to fail by using *try! *<br>- On the whole it encourages us to not return nil and to return useful<br>error codes which we can handle, what if one of the reasons it failed to<br>parse is something we could recover from? If we return nil we will never<br>know.<br>- And it reduces the amount of mutability in swift.<br></p><p><br>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/f575e60a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>I haven’t used a single failable initialiser ever since the try! command was added, as that gave the same convenience as force unwrapping and eliminated the need for big try/catch blocks if you didn’t expect an exception, with try? likewise making it easy to detect that any exception occurred, without caring about what it was.<br></p><p>So I’d probably say that failable initialisers are unnecessary now; they’re a tiny bit cleaner for simpler failable initialisers (one type of failure), but it’s probably not worth keeping as a language feature when it comes up so rarely (at least in my experience).<br></p><p>&gt; On 2 Mar 2016, at 21:11, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt; <br>&gt; Take this model<br>&gt; <br>&gt; struct MyModel {<br>&gt; <br>&gt; let someProperty<br>&gt; let anotherProperty<br>&gt; }<br>&gt; <br>&gt; Lets say we have a Initializers for this structure that takes a JSON structure and returns an i.<br>&gt; <br>&gt; We could guarantee that it always returns an instance but then we have to populate this data with dummy values if the JSON is missing values.<br>&gt; <br>&gt; I could make these properties optional to reflect that the JSON was missing information but I would be making the structure mutable which adds complexity. On-top of that I wouldn&#39;t be able to tell if the property is nil due to a lack of a value or a bug causing certain JSON information to be missing.<br>&gt; <br>&gt; So lets look at the alternatives with a non-guranteed system, well we have Failable Initializers. If any of the properties are missing, we should return nil.<br>&gt; <br>&gt; Well we have this issue:<br>&gt; <br>&gt; MyModel(json) <br>&gt; <br>&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer unless swift was update to, meaning we may forget to handle the nil case:<br>&gt; <br>&gt;  MyModel?(json)<br>&gt; <br>&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot of steps to create the object and fails (Like parsing an object from JSON). Returning nil but we have no idea why, it makes it easy to introduce silently failing errors. <br>&gt; <br>&gt; Its true some classes may do this when ran on a older version of iOS but with avaliabilty checks, this use case is irrelevant. <br>&gt; <br>&gt; So what about throwing an error?<br>&gt; <br>&gt; It forces us to handle it failing to initialize for some reason. <br>&gt; <br>&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue with this corrupted data - and the error will be informative as it forces us to create an ErrorType.<br>&gt; - If we want to ignore this object and convert the error to nil we can still use try? (For example in a Chat application you could ignore corrupted messages).<br>&gt; - In these cases where we ignore the error using try? it makes it super obvious we are ignoring an error and it should be easy to that error causing it to fail by using try! <br>&gt; - On the whole it encourages us to not return nil and to return useful error codes which we can handle, what if one of the reasons it failed to parse is something we could recover from? If we return nil we will never know.<br>&gt; - And it reduces the amount of mutability in swift.<br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head of Trolls<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/2ec0485f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  3, 2016 at 09:00:00am</p></header><div class="content"><p>Not that I personally use failable initializers, but aren&#39;t they needed to<br>interact with Obj-C which returns nil to indicate failure from initializers?<br></p><p>  -- Howard.<br></p><p>On 3 March 2016 at 09:27, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I haven’t used a single failable initialiser ever since the try! command<br>&gt; was added, as that gave the same convenience as force unwrapping and<br>&gt; eliminated the need for big try/catch blocks if you didn’t expect an<br>&gt; exception, with try? likewise making it easy to detect that any exception<br>&gt; occurred, without caring about what it was.<br>&gt;<br>&gt; So I’d probably say that failable initialisers are unnecessary now;<br>&gt; they’re a tiny bit cleaner for simpler failable initialisers (one type of<br>&gt; failure), but it’s probably not worth keeping as a language feature when it<br>&gt; comes up so rarely (at least in my experience).<br>&gt;<br>&gt; On 2 Mar 2016, at 21:11, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Given that we now have error handling and availability checks does it make<br>&gt; sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;<br>&gt; Take this model<br>&gt;<br>&gt; struct MyModel {<br>&gt;<br>&gt; let someProperty<br>&gt; let anotherProperty<br>&gt; }<br>&gt;<br>&gt; Lets say we have a Initializers for this structure that takes a JSON<br>&gt; structure and returns an i.<br>&gt;<br>&gt; We could guarantee that it always returns an instance but then we have to<br>&gt; populate this data with dummy values if the JSON is missing values.<br>&gt;<br>&gt; I could make these properties optional to reflect that the JSON was<br>&gt; missing information but I would be making the structure mutable which adds<br>&gt; complexity. On-top of that I wouldn&#39;t be able to tell if the property is<br>&gt; nil due to a lack of a value or a bug causing certain JSON information to<br>&gt; be missing.<br>&gt;<br>&gt; So lets look at the alternatives with a non-guranteed system, well we<br>&gt; have Failable Initializers. If any of the properties are missing, we should<br>&gt; return nil.<br>&gt;<br>&gt; Well we have this issue:<br>&gt;<br>&gt; MyModel(json)<br>&gt;<br>&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer<br>&gt; unless swift was update to, meaning we may forget to handle the nil case:<br>&gt;<br>&gt;  *MyModel?(json)*<br>&gt;<br>&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot<br>&gt; of steps to create the object and fails (Like parsing an object from JSON).<br>&gt; Returning nil but we have no idea why, it makes it easy to introduce<br>&gt; silently failing errors.<br>&gt;<br>&gt; Its true some classes may do this when ran on a older version of iOS but<br>&gt; with avaliabilty checks, this use case is irrelevant.<br>&gt;<br>&gt; So what about throwing an error?<br>&gt;<br>&gt; It forces us to handle it failing to initialize for some reason.<br>&gt;<br>&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue<br>&gt; with this corrupted data - and the error will be informative as it forces<br>&gt; us to create an ErrorType.<br>&gt; - If we want to ignore this object and convert the error to nil we can<br>&gt; still use *try? *(For example in a Chat application you could ignore<br>&gt; corrupted messages).<br>&gt; - In these cases where we ignore the error using *try?* it makes it super<br>&gt; obvious we are ignoring an error and it should be easy to that error<br>&gt; causing it to fail by using *try! *<br>&gt; - On the whole it encourages us to not return nil and to return useful<br>&gt; error codes which we can handle, what if one of the reasons it failed to<br>&gt; parse is something we could recover from? If we return nil we will never<br>&gt; know.<br>&gt; - And it reduces the amount of mutability in swift.<br>&gt;<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Head of Trolls*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/dabb7f8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>If the feature were being removed, then that could be replaced by some default exception for that purpose I think?<br></p><p>&gt; On 2 Mar 2016, at 22:30, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Not that I personally use failable initializers, but aren&#39;t they needed to interact with Obj-C which returns nil to indicate failure from initializers?<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 3 March 2016 at 09:27, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I haven’t used a single failable initialiser ever since the try! command was added, as that gave the same convenience as force unwrapping and eliminated the need for big try/catch blocks if you didn’t expect an exception, with try? likewise making it easy to detect that any exception occurred, without caring about what it was.<br>&gt; <br>&gt; So I’d probably say that failable initialisers are unnecessary now; they’re a tiny bit cleaner for simpler failable initialisers (one type of failure), but it’s probably not worth keeping as a language feature when it comes up so rarely (at least in my experience).<br>&gt; <br>&gt;&gt; On 2 Mar 2016, at 21:11, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt; <br>&gt;&gt; Take this model<br>&gt;&gt; <br>&gt;&gt; struct MyModel {<br>&gt;&gt; <br>&gt;&gt; let someProperty<br>&gt;&gt; let anotherProperty<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Lets say we have a Initializers for this structure that takes a JSON structure and returns an i.<br>&gt;&gt; <br>&gt;&gt; We could guarantee that it always returns an instance but then we have to populate this data with dummy values if the JSON is missing values.<br>&gt;&gt; <br>&gt;&gt; I could make these properties optional to reflect that the JSON was missing information but I would be making the structure mutable which adds complexity. On-top of that I wouldn&#39;t be able to tell if the property is nil due to a lack of a value or a bug causing certain JSON information to be missing.<br>&gt;&gt; <br>&gt;&gt; So lets look at the alternatives with a non-guranteed system, well we have Failable Initializers. If any of the properties are missing, we should return nil.<br>&gt;&gt; <br>&gt;&gt; Well we have this issue:<br>&gt;&gt; <br>&gt;&gt; MyModel(json) <br>&gt;&gt; <br>&gt;&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer unless swift was update to, meaning we may forget to handle the nil case:<br>&gt;&gt; <br>&gt;&gt;  MyModel?(json)<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot of steps to create the object and fails (Like parsing an object from JSON). Returning nil but we have no idea why, it makes it easy to introduce silently failing errors. <br>&gt;&gt; <br>&gt;&gt; Its true some classes may do this when ran on a older version of iOS but with avaliabilty checks, this use case is irrelevant. <br>&gt;&gt; <br>&gt;&gt; So what about throwing an error?<br>&gt;&gt; <br>&gt;&gt; It forces us to handle it failing to initialize for some reason. <br>&gt;&gt; <br>&gt;&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue with this corrupted data - and the error will be informative as it forces us to create an ErrorType.<br>&gt;&gt; - If we want to ignore this object and convert the error to nil we can still use try? (For example in a Chat application you could ignore corrupted messages).<br>&gt;&gt; - In these cases where we ignore the error using try? it makes it super obvious we are ignoring an error and it should be easy to that error causing it to fail by using try! <br>&gt;&gt; - On the whole it encourages us to not return nil and to return useful error codes which we can handle, what if one of the reasons it failed to parse is something we could recover from? If we return nil we will never know.<br>&gt;&gt; - And it reduces the amount of mutability in swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥Head of Trolls<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/95350b1a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  2, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br></p><p>If I understand correctly, your aim is to simplify the language.  I understand and support that goal generally, but have concerns in this specific case.<br></p><p>Our error handling schema (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error) defines how error conditions are handled, and one important class of them (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.  This works really well in practice for functions/methods in general.  <br></p><p>The problem is that removing failable initializers would simplify initializers, but would add complexity that would drive a wedge between initializers and functions, the end result being that a lot of initializers would have to become static functions on types.  I don’t think that everyone would just use error handling.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt; <br>&gt; Our error handling schema (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error) defines how error conditions are handled, and one important class of them (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.  This works really well in practice for functions/methods in general. <br></p><p>Could you give an example of why failable is the better fit here? To me the following two statements are identical:<br></p><p>	let a = FailableType()<br>	let b = try? ThrowableType()<br></p><p>Except that in the latter case the try? is more explicit about what is happening (and that it can fail), and I have the option of catching the error to find out more about what went wrong. With some optimisation it should be possible for try? to be just as efficient as a failable initialiser I think.<br></p><p>That said, the failable initialiser could have the same explicit call syntax if it required a trailing question-mark, e.g:<br></p><p>	let a = FailableType()?<br></p><p>As currently the only indicator is on the initialiser declaration itself. Still, when it comes to debugging I’ve found it very useful to force myself to use error handling instead, as it means I have to give reasons for why something failed, which can make it easier to track issues when they do arise.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/63f69dc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March  2, 2016 at 11:00:00pm</p></header><div class="content"><p>At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d like<br>to know the answer - is there not a similar argument to be made for any<br>function which returns an optional instead of throwing a more descriptive<br>error? Asking an array for its first element returns an optional because of<br>the possibility it might have no elements in it; should this throw an error<br>instead of being &#39;failable&#39;?<br></p><p>On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Given that we now have error handling and availability checks does it make<br>&gt; sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;<br>&gt;<br>&gt; Our error handling schema (<br>&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error)<br>&gt; defines how error conditions are handled, and one important class of them<br>&gt; (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.<br>&gt; This works really well in practice for functions/methods in general.<br>&gt;<br>&gt;<br>&gt; Could you give an example of why failable is the better fit here? To me<br>&gt; the following two statements are identical:<br>&gt;<br>&gt; let a = FailableType()<br>&gt; let b = try? ThrowableType()<br>&gt;<br>&gt; Except that in the latter case the try? is more explicit about what is<br>&gt; happening (and that it can fail), and I have the option of catching the<br>&gt; error to find out more about what went wrong. With some optimisation it<br>&gt; should be possible for try? to be just as efficient as a failable<br>&gt; initialiser I think.<br>&gt;<br>&gt; That said, the failable initialiser could have the same explicit call<br>&gt; syntax if it required a trailing question-mark, e.g:<br>&gt;<br>&gt; let a = FailableType()?<br>&gt;<br>&gt; As currently the only indicator is on the initialiser declaration itself.<br>&gt; Still, when it comes to debugging I’ve found it very useful to force myself<br>&gt; to use error handling instead, as it means I have to give reasons for why<br>&gt; something failed, which can make it easier to track issues when they do<br>&gt; arise.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/b1d292d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  2, 2016 at 11:00:00pm</p></header><div class="content"><p>To me it depends on if the function returns a value or the result of an<br>action which may have different results not related to the value.<br></p><p>- The first function on an array returns a value, the first item in an<br>array. In this case an optional makes sense as its easy to handle by<br>returning nil since there is no value that exists at index(1)<br>- The subscript operator could return an optional too when we are out of<br>bounds since the value doesn&#39;t exist.<br>- Having a init throw an error makes sense to me, as for complex structures<br>and classes there are many reasons it can fail, its not that simple to say<br>there wasn&#39;t a value (was there some internal validation that failed)<br>- A fetch operation for a network request would throw on the same princible<br>(i.e was networking down?)<br>- However a function that just calculated a value lets say the next URL for<br>the next page in a eBook, would probably want too return nil since all its<br>doing is returning a value (i.e there is a next page for this book).<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Mar 2, 2016 at 11:44 PM, Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d<br>&gt; like to know the answer - is there not a similar argument to be made for<br>&gt; any function which returns an optional instead of throwing a more<br>&gt; descriptive error? Asking an array for its first element returns an<br>&gt; optional because of the possibility it might have no elements in it; should<br>&gt; this throw an error instead of being &#39;failable&#39;?<br>&gt;<br>&gt; On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Given that we now have error handling and availability checks does it<br>&gt;&gt; make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Our error handling schema (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error)<br>&gt;&gt; defines how error conditions are handled, and one important class of them<br>&gt;&gt; (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.<br>&gt;&gt; This works really well in practice for functions/methods in general.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Could you give an example of why failable is the better fit here? To me<br>&gt;&gt; the following two statements are identical:<br>&gt;&gt;<br>&gt;&gt; let a = FailableType()<br>&gt;&gt; let b = try? ThrowableType()<br>&gt;&gt;<br>&gt;&gt; Except that in the latter case the try? is more explicit about what is<br>&gt;&gt; happening (and that it can fail), and I have the option of catching the<br>&gt;&gt; error to find out more about what went wrong. With some optimisation it<br>&gt;&gt; should be possible for try? to be just as efficient as a failable<br>&gt;&gt; initialiser I think.<br>&gt;&gt;<br>&gt;&gt; That said, the failable initialiser could have the same explicit call<br>&gt;&gt; syntax if it required a trailing question-mark, e.g:<br>&gt;&gt;<br>&gt;&gt; let a = FailableType()?<br>&gt;&gt;<br>&gt;&gt; As currently the only indicator is on the initialiser declaration itself.<br>&gt;&gt; Still, when it comes to debugging I’ve found it very useful to force myself<br>&gt;&gt; to use error handling instead, as it means I have to give reasons for why<br>&gt;&gt; something failed, which can make it easier to track issues when they do<br>&gt;&gt; arise.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/80837ada/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  2, 2016 at 05:00:00pm</p></header><div class="content"><p>+1. Keep failable initializers to maintain the existing symmetry with functions, and to handle cases in which an initialization operation can only &#39;fail&#39; in one way that users care about (e.g. the &#39;int-from-string&#39; initializer; either the string contains a representable integer or it doesn&#39;t).<br></p><p>Austin<br></p><p>&gt; On Mar 2, 2016, at 3:44 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d like to know the answer - is there not a similar argument to be made for any function which returns an optional instead of throwing a more descriptive error? Asking an array for its first element returns an optional because of the possibility it might have no elements in it; should this throw an error instead of being &#39;failable&#39;?<br>&gt; <br>&gt; On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt; <br>&gt;&gt; Our error handling schema (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error&gt;) defines how error conditions are handled, and one important class of them (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.  This works really well in practice for functions/methods in general. <br>&gt; <br>&gt; Could you give an example of why failable is the better fit here? To me the following two statements are identical:<br>&gt; <br>&gt; 	let a = FailableType()<br>&gt; 	let b = try? ThrowableType()<br>&gt; <br>&gt; Except that in the latter case the try? is more explicit about what is happening (and that it can fail), and I have the option of catching the error to find out more about what went wrong. With some optimisation it should be possible for try? to be just as efficient as a failable initialiser I think.<br>&gt; <br>&gt; That said, the failable initialiser could have the same explicit call syntax if it required a trailing question-mark, e.g:<br>&gt; <br>&gt; 	let a = FailableType()?<br>&gt; <br>&gt; As currently the only indicator is on the initialiser declaration itself. Still, when it comes to debugging I’ve found it very useful to force myself to use error handling instead, as it means I have to give reasons for why something failed, which can make it easier to track issues when they do arise.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/df289e1e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  3, 2016 at 07:00:00am</p></header><div class="content"><p>The reasoning for me is that they help describe the difference between a function that can return a nil value as part of it&#39;s normal operation and a function that can encounter an unexpected error.<br></p><p>&gt; On 03 Mar 2016, at 00:44, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d like to know the answer - is there not a similar argument to be made for any function which returns an optional instead of throwing a more descriptive error? Asking an array for its first element returns an optional because of the possibility it might have no elements in it; should this throw an error instead of being &#39;failable&#39;?<br>&gt; <br>&gt;&gt; On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our error handling schema (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error) defines how error conditions are handled, and one important class of them (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.  This works really well in practice for functions/methods in general. <br>&gt;&gt; <br>&gt;&gt; Could you give an example of why failable is the better fit here? To me the following two statements are identical:<br>&gt;&gt; <br>&gt;&gt; 	let a = FailableType()<br>&gt;&gt; 	let b = try? ThrowableType()<br>&gt;&gt; <br>&gt;&gt; Except that in the latter case the try? is more explicit about what is happening (and that it can fail), and I have the option of catching the error to find out more about what went wrong. With some optimisation it should be possible for try? to be just as efficient as a failable initialiser I think.<br>&gt;&gt; <br>&gt;&gt; That said, the failable initialiser could have the same explicit call syntax if it required a trailing question-mark, e.g:<br>&gt;&gt; <br>&gt;&gt; 	let a = FailableType()?<br>&gt;&gt; <br>&gt;&gt; As currently the only indicator is on the initialiser declaration itself. Still, when it comes to debugging I’ve found it very useful to force myself to use error handling instead, as it means I have to give reasons for why something failed, which can make it easier to track issues when they do arise.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/221e511c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  3, 2016 at 07:00:00pm</p></header><div class="content"><p>The error handdling model as described in<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error<br>is<br>very sensible and consistently applied throughout the language.<br></p><p>Returning an optional is a simplified form of returning an error when there<br>is only one straightforward way of failing. This is a very common case and<br>is simpler than using an error, for which you need to: 1) call<br>w/ try? 2) add &#39;throws&#39; to the function 3) return some kind of error<br>instance of some type<br></p><p>On Thursday, 3 March 2016, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The reasoning for me is that they help describe the difference between a<br>&gt; function that can return a nil value as part of it&#39;s normal operation and a<br>&gt; function that can encounter an unexpected error.<br>&gt;<br>&gt; On 03 Mar 2016, at 00:44, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d<br>&gt; like to know the answer - is there not a similar argument to be made for<br>&gt; any function which returns an optional instead of throwing a more<br>&gt; descriptive error? Asking an array for its first element returns an<br>&gt; optional because of the possibility it might have no elements in it; should<br>&gt; this throw an error instead of being &#39;failable&#39;?<br>&gt;<br>&gt; On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Given that we now have error handling and availability checks does it<br>&gt;&gt; make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Our error handling schema (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error)<br>&gt;&gt; defines how error conditions are handled, and one important class of them<br>&gt;&gt; (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.<br>&gt;&gt; This works really well in practice for functions/methods in general.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Could you give an example of why failable is the better fit here? To me<br>&gt;&gt; the following two statements are identical:<br>&gt;&gt;<br>&gt;&gt; let a = FailableType()<br>&gt;&gt; let b = try? ThrowableType()<br>&gt;&gt;<br>&gt;&gt; Except that in the latter case the try? is more explicit about what is<br>&gt;&gt; happening (and that it can fail), and I have the option of catching the<br>&gt;&gt; error to find out more about what went wrong. With some optimisation it<br>&gt;&gt; should be possible for try? to be just as efficient as a failable<br>&gt;&gt; initialiser I think.<br>&gt;&gt;<br>&gt;&gt; That said, the failable initialiser could have the same explicit call<br>&gt;&gt; syntax if it required a trailing question-mark, e.g:<br>&gt;&gt;<br>&gt;&gt; let a = FailableType()?<br>&gt;&gt;<br>&gt;&gt; As currently the only indicator is on the initialiser declaration itself.<br>&gt;&gt; Still, when it comes to debugging I’ve found it very useful to force myself<br>&gt;&gt; to use error handling instead, as it means I have to give reasons for why<br>&gt;&gt; something failed, which can make it easier to track issues when they do<br>&gt;&gt; arise.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/3e11e2b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>Just to iterate returning an optional as an error I still think is fine for normal functions.<br>But for the reasons I outlined above I think it&#39;s problematic for inits.<br>Of course two simpler ways towards solving it would to have a guide to explain best practice of when to use fallible init vs a throw.<br>Also all falliable inits perhaps should have ? In their name (and maybe functions who return one too) Or at least be allowed to give the function a name with ? In it.<br>In Ruby ? And ! Were nice explicit ways of saying this returns a Bool or this does something dangerous. Having this in swift or something like it would be a great way of making optional functions easier but I&#39;m not sure how desirable this is.<br>Hence my original proposal is just limited to inits where unexpected errors are far more likely to occur than a function.<br>Sent from Supmenow.com<br></p><p><br></p><p><br>On Thu, Mar 3, 2016 at 12:07 AM -0800, &quot;Patrick Pijnappel via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>The error handdling model as described in https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error is very sensible and consistently applied throughout the language.<br>Returning an optional is a simplified form of returning an error when there is only one straightforward way of failing. This is a very common case and is simpler than using an error, for which you need to: 1) call w/ try? 2) add &#39;throws&#39; to the function 3) return some kind of error instance of some type<br>On Thursday, 3 March 2016, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>The reasoning for me is that they help describe the difference between a function that can return a nil value as part of it&#39;s normal operation and a function that can encounter an unexpected error.<br>On 03 Mar 2016, at 00:44, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d like to know the answer - is there not a similar argument to be made for any function which returns an optional instead of throwing a more descriptive error? Asking an array for its first element returns an optional because of the possibility it might have no elements in it; should this throw an error instead of being &#39;failable&#39;?<br>On Wed, Mar 2, 2016 at 11:35 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>On 2 Mar 2016, at 23:07, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>On Mar 2, 2016, at 1:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br></p><p>Our error handling schema (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#kinds-of-error) defines how error conditions are handled, and one important class of them (e.g. the &quot;string to int&quot; case) is best modeled as returning an optional.  This works really well in practice for functions/methods in general. <br>Could you give an example of why failable is the better fit here? To me the following two statements are identical:<br>	let a = FailableType()	let b = try? ThrowableType()<br>Except that in the latter case the try? is more explicit about what is happening (and that it can fail), and I have the option of catching the error to find out more about what went wrong. With some optimisation it should be possible for try? to be just as efficient as a failable initialiser I think.<br>That said, the failable initialiser could have the same explicit call syntax if it required a trailing question-mark, e.g:<br>	let a = FailableType()?<br>As currently the only indicator is on the initialiser declaration itself. Still, when it comes to debugging I’ve found it very useful to force myself to use error handling instead, as it means I have to give reasons for why something failed, which can make it easier to track issues when they do arise.<br>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/7449a078/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 3 Mar 2016, at 08:07, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Returning an optional is a simplified form of returning an error when there is only one straightforward way of failing. This is a very common case and is simpler than using an error, for which you need to: 1) call w/ try? 2) add &#39;throws&#39; to the function 3) return some kind of error instance of some type<br></p><p>How common is it really though? I hardly ever see it come up, but maybe I’m the one doing something unusual?<br></p><p>For me, checking what the return value of an initialiser is is kind of strange to me, as I just expect it to be an instance of whatever type I asked for. Error handling forces you to do something about the possibility of a failure.<br></p><p>&gt; On 2 Mar 2016, at 23:44, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; At the risk of appearing glib or naive - which isn&#39;t my intention, I&#39;d like to know the answer - is there not a similar argument to be made for any function which returns an optional instead of throwing a more descriptive error? Asking an array for its first element returns an optional because of the possibility it might have no elements in it; should this throw an error instead of being &#39;failable’?<br></p><p>An optional to me represents something perfectly normal and expected happening that just has no result; i.e- in the case of an array it’s perfectly fine for it to contain no elements, so looking at the first one can’t return a concrete result.<br></p><p>This differs from using a subscript into the array with an invalid index, as with Swift’s index type model you’re not supposed to retain invalid indices into an array that has changed (a lot of the methods of Array specifically state that they disassociate indices with respect to self). So attempting to use a subscript to get an element that doesn’t exist means you’re using an invalid index you shouldn’t have retained, so an error makes sense in that case, vs. returning nil. I admit it’s an easy one to forget since Array indices are just Ints, but they could just as easily be of type ArrayIndex, so you really should limit yourself to index-specific features such as .predecessor(), .successor(), .advancedBy(), .distanceTo() and comparisons with startIndex and endIndex.<br></p><p><br>I dunno, it’s not a critical thing to change perhaps, but to me a failable/nilable initialiser doesn’t represent a failure as explicitly as error handling does, it also doesn’t force a developer using it to handle that error (even if it’s just to pop a try? in front) or force developer creating it to give a reason why the failure occurred.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/243f8c96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Error handling forces you to do something about the possibility of a failure.<br></p><p>So does using a failable initializer: the value is in an Optional, so you can&#39;t access it without either testing and unwrapping or just force-unwrapping. The type system, rather than the `try` requirement, is what forces you to handle the error, but it&#39;s the same idea.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  3, 2016 at 09:00:00am</p></header><div class="content"><p>True but in my example above for parsing a JSON into a model I can do this:<br></p><p>class Model {<br></p><p>let property: String<br>let property1: String<br>let property2: String<br>let property3: String<br></p><p>init?(json: [String: AnyObject]) {<br></p><p>guard property = json[&quot;property&quot;] as? String else {<br> return nil<br>}<br></p><p>guard property = json[&quot;property1&quot;] as? String else {<br> return nil<br>}<br></p><p>guard property = json[&quot;property2&quot;] as? String else {<br> return nil<br>}<br></p><p>guard property = json[&quot;property3&quot;] as? String else {<br> return nil<br>}<br></p><p>}<br></p><p>}<br></p><p>There is a lot of boilerplate for very little information and I&#39;m worried<br>by letting people initialize without returning an error we will get complex<br>objects like this being constructed and failing for no reason.<br></p><p>Compare this to error handling:<br></p><p>class Model {<br></p><p>let property: String<br>let property1: String<br>let property2: String<br>let property3: String<br></p><p>init?(json: [String: AnyObject]) throws {<br></p><p>property = try json.require(&quot;property&quot;)<br>property1 = try json.require(&quot;property1&quot;)<br>property2 = try json.require(&quot;property2&quot;)<br>property3 = try json.require(&quot;property3&quot;)<br></p><p>}<br></p><p>}<br></p><p>Require reads the key from the dict and tries to cast it to the same type<br>as the variable its being assigned to and throws an error if this fails<br>(like it doesn&#39;t exist or it can&#39;t be casted). This has much less<br>boilerplate, its easier to read and also we can throw an error saying (&quot;We<br>couldn&#39;t parse property1&quot;).<br></p><p>Some frameworks like Freddy JSON so something similar to this but with a<br>much more complex model using Enums and it involves setting a bunch of<br>parameters to tell the library when to throw a runtime error or not if it<br>can&#39;t find something which if not handled correctly can cause a crash.<br></p><p>We could make this even simpler yet if we could somehow treat casting as an<br>error:<br></p><p>class Model {<br></p><p>let property: String<br>let property1: String<br>let property2: String<br>let property3: String<br></p><p>init?(json: [String: AnyObject]) throws {<br></p><p>property = try json[&quot;property&quot;] as String<br>property1 = try json[&quot;property1&quot;] as String<br>property2 = try json[&quot;property2&quot;] as String<br>property3 = try json[&quot;property3&quot;] as String<br></p><p>}<br></p><p>}<br></p><p>If casting fails it throws an error, unfortunately we lose error<br>information about the key so probably having a casting method like the one<br>above is probable better. But in someways it explains what is happening.<br></p><p><br></p><p><br>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Mar 3, 2016 at 8:59 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Error handling forces you to do something about the possibility of a<br>&gt; failure.<br>&gt;<br>&gt; So does using a failable initializer: the value is in an Optional, so you<br>&gt; can&#39;t access it without either testing and unwrapping or just<br>&gt; force-unwrapping. The type system, rather than the `try` requirement, is<br>&gt; what forces you to handle the error, but it&#39;s the same idea.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/a29bcc51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; class Model {<br>&gt; <br>&gt; let property: String<br>&gt; let property1: String<br>&gt; let property2: String<br>&gt; let property3: String<br>&gt; <br>&gt; init?(json: [String: AnyObject]) throws {<br>&gt; <br>&gt; property = try json.require(&quot;property&quot;)<br>&gt; property1 = try json.require(&quot;property1&quot;)<br>&gt; property2 = try json.require(&quot;property2&quot;)<br>&gt; property3 = try json.require(&quot;property3&quot;)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Require reads the key from the dict and tries to cast it to the same type as the variable its being assigned to and throws an error if this fails (like it doesn&#39;t exist or it can&#39;t be casted). This has much less boilerplate, its easier to read and also we can throw an error saying (&quot;We couldn&#39;t parse property1&quot;). <br></p><p>You&#39;re right, that&#39;s an improvement over the failable initializer. *So make this a throwing init instead.* It&#39;s not like the existence of failable initializers keeps you from using `throws`.<br></p><p>Meanwhile, things like `Int.init(_: String)` and `NSImage.init(data: NSData)` are better off being failable. There&#39;s not much useful detail you can provide for these failures, and it&#39;s really nice to be able to use if-let, guard-let, or ?? to handle them instead of having to write an entire do/catch block.<br></p><p>It&#39;s helpful to have both a hammer *and* a screwdriver in your toolkit, lest you be forced to treat everything like a nail.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 3 Mar 2016, at 09:20, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; it&#39;s really nice to be able to use if-let, guard-let, or ?? to handle them instead of having to write an entire do/catch block.<br></p><p>What’s wrong with:<br></p><p>	guard let myInstance = try? ErrorThrowingType() else { return }<br></p><p>This has the exact same flexibility, and works just as well with the ?? operator as a failable initialiser, in fact that’s one of the main reasons why try? was added I think.<br></p><p>Personally I think what it boils down to for me is that these initialisers are failing, which means that an error has occurred, which means that they should use error handling. On the other side I don’t see optionals as representing errors (and they shouldn’t be used to anymore IMO), but instead the result of something that doesn’t have to return a value (but has been used correctly).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/977a20bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 3 Mar 2016, at 20:53, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; There are established guidelines for Swift error handling.<br></p><p>That’s fine, but this proposal would change that so I’m sure it’s really relevant. No one’s arguing that the current advice is bad, as it’s fine given that failable initialisers currently exist, but if they were to be removed then that advice simply needs to change.<br></p><p>&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br></p><p>If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br></p><p>That means we really have two identical features, one of which has greater flexibility, so does it make sense to keep the less capable variant?<br></p><p>&gt; The duality is that an error reported through the throwing mechanism should be non-trivial.<br></p><p>Is calling an initialiser with invalid values really trivial?<br></p><p>&gt; I am wary of using the try? keyword in general (as it discards potentially meaningful information) and I&#39;m happy that initializers are allowed to be failable.<br></p><p>The difference between try? discarding potentially useful information and a failable initialiser is that the failable initialiser provides no potentially useful information. That to me is a reason against failable initialisers, as they’re simply providing a generic failure condition in the form of nil. Besides, I don’t think that try? has inherent problems, it explicitly indicates that you are aware that the initialiser can fail, and choose to ignore the actual error in favour of working with nil instead (or providing a default with ??). Sometimes the reason for something failing just doesn’t matter to you, only that it did fail.<br></p><p>That’s not to say that throwable initialisers can’t just return a single error type either; they absolutely can. The benefit of them over failable initialisers is that they could produce any number of useful errors depending upon what can actually go wrong.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  3, 2016 at 05:00:00pm</p></header><div class="content"><p>There is no way to encode that an initializer can only fail because of a simple programming error when all you have next to it is &quot;throws&quot;. When I see &quot;init?&quot;, I know that the function can fail because I didn&#39;t check parameters. When I see &quot;init() throws&quot;, I know that it can fail for a more complex reason, like failing to get a handle to some resource. The exception object will tell me why and if I don&#39;t have a shot at recovery, I expect to have at least something to tell the user.<br></p><p>I have no intention of developing a habit of writing try? in front of initializers when I can&#39;t discern the reason that they can fail.<br></p><p>Félix<br></p><p>&gt; Le 3 mars 2016 à 16:43:19, Haravikk &lt;swift-evolution at haravikk.me&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 3 Mar 2016, at 20:53, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are established guidelines for Swift error handling.<br>&gt; <br>&gt; That’s fine, but this proposal would change that so I’m sure it’s really relevant. No one’s arguing that the current advice is bad, as it’s fine given that failable initialisers currently exist, but if they were to be removed then that advice simply needs to change.<br>&gt; <br>&gt;&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br>&gt; <br>&gt; If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br>&gt; <br>&gt; That means we really have two identical features, one of which has greater flexibility, so does it make sense to keep the less capable variant?<br>&gt; <br>&gt;&gt; The duality is that an error reported through the throwing mechanism should be non-trivial.<br>&gt; <br>&gt; Is calling an initialiser with invalid values really trivial?<br>&gt; <br>&gt;&gt; I am wary of using the try? keyword in general (as it discards potentially meaningful information) and I&#39;m happy that initializers are allowed to be failable.<br>&gt; <br>&gt; The difference between try? discarding potentially useful information and a failable initialiser is that the failable initialiser provides no potentially useful information. That to me is a reason against failable initialisers, as they’re simply providing a generic failure condition in the form of nil. Besides, I don’t think that try? has inherent problems, it explicitly indicates that you are aware that the initialiser can fail, and choose to ignore the actual error in favour of working with nil instead (or providing a default with ??). Sometimes the reason for something failing just doesn’t matter to you, only that it did fail.<br>&gt; <br>&gt; That’s not to say that throwable initialisers can’t just return a single error type either; they absolutely can. The benefit of them over failable initialisers is that they could produce any number of useful errors depending upon what can actually go wrong.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/eb25c466/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  5, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree wholeheartedly. <br></p><p>-Thorsten <br></p><p>&gt; Am 03.03.2016 um 23:07 schrieb Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; There is no way to encode that an initializer can only fail because of a simple programming error when all you have next to it is &quot;throws&quot;. When I see &quot;init?&quot;, I know that the function can fail because I didn&#39;t check parameters. When I see &quot;init() throws&quot;, I know that it can fail for a more complex reason, like failing to get a handle to some resource. The exception object will tell me why and if I don&#39;t have a shot at recovery, I expect to have at least something to tell the user.<br>&gt; <br>&gt; I have no intention of developing a habit of writing try? in front of initializers when I can&#39;t discern the reason that they can fail.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt;&gt; Le 3 mars 2016 à 16:43:19, Haravikk &lt;swift-evolution at haravikk.me&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 3 Mar 2016, at 20:53, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are established guidelines for Swift error handling.<br>&gt;&gt; <br>&gt;&gt; That’s fine, but this proposal would change that so I’m sure it’s really relevant. No one’s arguing that the current advice is bad, as it’s fine given that failable initialisers currently exist, but if they were to be removed then that advice simply needs to change.<br>&gt;&gt; <br>&gt;&gt;&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br>&gt;&gt; <br>&gt;&gt; If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br>&gt;&gt; <br>&gt;&gt; That means we really have two identical features, one of which has greater flexibility, so does it make sense to keep the less capable variant?<br>&gt;&gt; <br>&gt;&gt;&gt; The duality is that an error reported through the throwing mechanism should be non-trivial.<br>&gt;&gt; <br>&gt;&gt; Is calling an initialiser with invalid values really trivial?<br>&gt;&gt; <br>&gt;&gt;&gt; I am wary of using the try? keyword in general (as it discards potentially meaningful information) and I&#39;m happy that initializers are allowed to be failable.<br>&gt;&gt; <br>&gt;&gt; The difference between try? discarding potentially useful information and a failable initialiser is that the failable initialiser provides no potentially useful information. That to me is a reason against failable initialisers, as they’re simply providing a generic failure condition in the form of nil. Besides, I don’t think that try? has inherent problems, it explicitly indicates that you are aware that the initialiser can fail, and choose to ignore the actual error in favour of working with nil instead (or providing a default with ??). Sometimes the reason for something failing just doesn’t matter to you, only that it did fail.<br>&gt;&gt; <br>&gt;&gt; That’s not to say that throwable initialisers can’t just return a single error type either; they absolutely can. The benefit of them over failable initialisers is that they could produce any number of useful errors depending upon what can actually go wrong.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/ad8df2ef/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br>&gt; <br>&gt; If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br></p><p>If there&#39;s a &quot;general purpose invalid argument error&quot;, then that error is not communicating anything more than an optional would. It&#39;s merely taking a lot more syntax on both sides of the call, plus complexity in the calling convention and space in memory (40 bytes for a protocol witness, instead of 0-1 bytes for the overhead of an Optional!), to convey the same single bit of information: &quot;Your data was wrong&quot;.<br></p><p>And if there isn&#39;t a general-purpose error, you&#39;re adding even *more* syntax and complexity—an entire new type to conform to ErrorType—and once again only conveying the same single bit of information: &quot;Your data was wrong&quot;.<br></p><p>Forcing simple errors to use `throws` introduces a lot more complexity for no apparent benefit.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 3 Mar 2016, at 22:27, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br>&gt;&gt; <br>&gt;&gt; If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br>&gt; <br>&gt; If there&#39;s a &quot;general purpose invalid argument error&quot;, then that error is not communicating anything more than an optional would. It&#39;s merely taking a lot more syntax on both sides of the call, plus complexity in the calling convention and space in memory (40 bytes for a protocol witness, instead of 0-1 bytes for the overhead of an Optional!), to convey the same single bit of information: &quot;Your data was wrong”.<br></p><p>That’s more an issue of optimisation IMO; if an initialiser (or method) is being called with try? or try! then it should be possible to optimise away the actual error generation and throwing, since it won’t be used anyway. I don’t know enough about that to know what’s currently being done in these cases, but with optimisations in place the only added complexity should be picking a relevant error to throw and then throwing it.*<br></p><p>Also, I’m not convinced by the idea that failable initialisers always represent only a single type of error anyway; the most common example I’ve seen is people using NSImage, but that can actually fail for several different reasons, such as a non-existent file, or the file is unreadable due to permission issues and such. While you could argue that these all stem from the parameter choice being wrong, you can argue that about a lot of things. I’d say in that case at least there should be multiple different error types for different potential types of failure, otherwise you’re left having to figure out why the issue occurred for yourself; consider for example if the file being opened were a temporary file created with the wrong permissions, it may be deleted if execution halts, leaving you only with the knowledge that something failed in NSImage(), which is why I think it’s better practice to use error handling in general as you can instead catch that error to find out what is actually wrong.<br></p><p>This can be true even in the supposedly simple cases; consider a simple type that is initialised from a numeric value in string format. You might say that that’s fine as an optional, but what if the string fails simply because it contains a single space character? This could be pretty non-obvious, and with most failable initialisers you’re left with nothing other than “your data was wrong” (was it malformed, did it contain invalid characters, is the value too large or too small?); this can be even worse if you include other unusual unicode characters that could look valid. If this initialiser instead returned an error type indicating that it encountered a non-numeric string, then it would leave no doubt where the error lies; granted using try? you won’t see this, but you have the option of catching the error instead to find out what it was*.<br></p><p>Of course adding new error types is extra work, but that’s partly an argument for the standard library to contain a good range of general purpose types, which would likely have to be added anyway while replacing failable initialisers. Even if developers fall back to a vague “InvalidParameter” error type, they could at least provide a message with it, which is still more information which is IMO always a good thing.<br></p><p>*Just a note, but ideally when debugging no optimisation of errors should occur, as this would give us the option of finding out what causes a try? statement to fail; this may even already be possible, I’m not sure.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  4, 2016 at 11:00:00am</p></header><div class="content"><p>If anything, the fact that NSImage doesn&#39;t respect the error handling guidelines is an argument in favor of reworking the NSImage interface, not doing away with the guidelines. All (I think?) of the Foundation class initializers accept an inout error parameter, which translate to throws in Swift.<br></p><p>Consider reading Joe Duffy&#39;s writeup on error handling in Midori &lt;http://joeduffyblog.com/2016/02/07/the-error-model/#ambitions-and-learnings&gt;  which presents &quot;abandonments&quot; (what I think failable initializers model best) and actual exceptions (what I think throwing models best).<br></p><p>Félix<br></p><p>&gt; Le 4 mars 2016 à 04:54:52, Haravikk &lt;swift-evolution at haravikk.me&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 3 Mar 2016, at 22:27, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The guidance is that returning nil is appropriate when your function could fail due to simple domain errors, for instance passing a negative value as a parameter where they aren&#39;t allowed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If that’s all you need then what’s wrong with throwing some generic purpose illegal argument type exception and using try? It’s functionally the same, i.e- removing failable initialisers doesn’t actually remove a capability, it just removes what is essentially now a redundant one. In other words, try? on a throwable initialiser is now functionally identical to a failable initialiser and isn&#39;t appreciably more complex, especially if there’s a common exception that can be thrown for general purpose invalid argument errors (not sure if there is one right now, but it could be added to the proposal).<br>&gt;&gt; <br>&gt;&gt; If there&#39;s a &quot;general purpose invalid argument error&quot;, then that error is not communicating anything more than an optional would. It&#39;s merely taking a lot more syntax on both sides of the call, plus complexity in the calling convention and space in memory (40 bytes for a protocol witness, instead of 0-1 bytes for the overhead of an Optional!), to convey the same single bit of information: &quot;Your data was wrong”.<br>&gt; <br>&gt; That’s more an issue of optimisation IMO; if an initialiser (or method) is being called with try? or try! then it should be possible to optimise away the actual error generation and throwing, since it won’t be used anyway. I don’t know enough about that to know what’s currently being done in these cases, but with optimisations in place the only added complexity should be picking a relevant error to throw and then throwing it.*<br>&gt; <br>&gt; Also, I’m not convinced by the idea that failable initialisers always represent only a single type of error anyway; the most common example I’ve seen is people using NSImage, but that can actually fail for several different reasons, such as a non-existent file, or the file is unreadable due to permission issues and such. While you could argue that these all stem from the parameter choice being wrong, you can argue that about a lot of things. I’d say in that case at least there should be multiple different error types for different potential types of failure, otherwise you’re left having to figure out why the issue occurred for yourself; consider for example if the file being opened were a temporary file created with the wrong permissions, it may be deleted if execution halts, leaving you only with the knowledge that something failed in NSImage(), which is why I think it’s better practice to use error handling in general as you can instead catch that error to find out what is actually wrong.<br>&gt; <br>&gt; This can be true even in the supposedly simple cases; consider a simple type that is initialised from a numeric value in string format. You might say that that’s fine as an optional, but what if the string fails simply because it contains a single space character? This could be pretty non-obvious, and with most failable initialisers you’re left with nothing other than “your data was wrong” (was it malformed, did it contain invalid characters, is the value too large or too small?); this can be even worse if you include other unusual unicode characters that could look valid. If this initialiser instead returned an error type indicating that it encountered a non-numeric string, then it would leave no doubt where the error lies; granted using try? you won’t see this, but you have the option of catching the error instead to find out what it was*.<br>&gt; <br>&gt; Of course adding new error types is extra work, but that’s partly an argument for the standard library to contain a good range of general purpose types, which would likely have to be added anyway while replacing failable initialisers. Even if developers fall back to a vague “InvalidParameter” error type, they could at least provide a message with it, which is still more information which is IMO always a good thing.<br>&gt; <br>&gt; *Just a note, but ideally when debugging no optimisation of errors should occur, as this would give us the option of finding out what causes a try? statement to fail; this may even already be possible, I’m not sure.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/2e5354c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 4 Mar 2016, at 16:32, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; If anything, the fact that NSImage doesn&#39;t respect the error handling guidelines is an argument in favor of reworking the NSImage interface, not doing away with the guidelines. All (I think?) of the Foundation class initializers accept an inout error parameter, which translate to throws in Swift.<br></p><p>True, but even when you’re writing a type in pure Swift from the start, once you have a failable initialiser it can be easy to just return nil when you think of other possible error conditions that didn’t occur to you sooner (I did this a couple of times myself before try? was added and I switch to error handling only). While someone might do the same with an InvalidArgument error type, as long as it can take a message it’s trivial to customise each unique error that your initialiser/method can produce.<br></p><p>&gt; Consider reading Joe Duffy&#39;s writeup on error handling in Midori &lt;http://joeduffyblog.com/2016/02/07/the-error-model/#ambitions-and-learnings&gt;  which presents &quot;abandonments&quot; (what I think failable initializers model best) and actual exceptions (what I think throwing models best).<br></p><p>It’s definitely an interesting article but there are a few drawbacks listed to exceptions that I’d like to go over:<br></p><p>&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br></p><p><br>This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br></p><p>I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br></p><p>&gt; 3. Although signatures declare exception types, there is no indication at callsites what calls might throw.<br></p><p><br>This of course isn’t an issue in Swift, as the try keyword is mandatory. Thanks to try? and try! this also eliminates number four (everybody hates exceptions) which is largely a complaint about having to build try/catch blocks around them, but with try? and try! we can easily eliminate that when we know we don’t need any extra information besides whether or not a failure occurred.<br></p><p>Also, regarding overhead of exceptions, I still think that this is something that can be optimised away. All the compiler has to do is identify throw statements, and isolate code specific to them (i.e- variables etc. that are only used as part of a throw); now when you call a method/initialiser with try? or try!, any code identified as being part of the throw can be skipped as all that’s needed is a binary flag (threw vs. succeeded). Of course it sounds a bit easier than it is in reality, but I’m pretty sure it should be possible to change behaviour depending upon how the code is called (i.e- whether an error will actually be used, or simply ignored in favour of its status). When debugging of course the error can be returned in all cases so we can generate and see it.<br>In short, with Swift’s ability to explicitly declare whether we want an error returned vs simply knowing that an error occurred, it should be possible to optimise such that it is just as efficient as a failable initialiser (if not more so, since the return value isn’t an optional).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/ed8212dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br></p><p>I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br></p><p>You would certainly not like me to go into your code and break it, unless I had an excellent reason to do it.<br></p><p>However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better. Can it be faster? Don&#39;t think so. Can it be shorter? Don&#39;t think so.<br></p><p>This is mostly just enforcing a programming style you believe in to the whole Swift community, without regards to whether the rest agrees with it.<br></p><p>Félix<br></p><p>&gt; Le 4 mars 2016 à 17:42:06, Haravikk &lt;swift-evolution at haravikk.me&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 4 Mar 2016, at 16:32, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If anything, the fact that NSImage doesn&#39;t respect the error handling guidelines is an argument in favor of reworking the NSImage interface, not doing away with the guidelines. All (I think?) of the Foundation class initializers accept an inout error parameter, which translate to throws in Swift.<br>&gt; <br>&gt; True, but even when you’re writing a type in pure Swift from the start, once you have a failable initialiser it can be easy to just return nil when you think of other possible error conditions that didn’t occur to you sooner (I did this a couple of times myself before try? was added and I switch to error handling only). While someone might do the same with an InvalidArgument error type, as long as it can take a message it’s trivial to customise each unique error that your initialiser/method can produce.<br>&gt; <br>&gt;&gt; Consider reading Joe Duffy&#39;s writeup on error handling in Midori &lt;http://joeduffyblog.com/2016/02/07/the-error-model/#ambitions-and-learnings&gt;  which presents &quot;abandonments&quot; (what I think failable initializers model best) and actual exceptions (what I think throwing models best).<br>&gt; <br>&gt; It’s definitely an interesting article but there are a few drawbacks listed to exceptions that I’d like to go over:<br>&gt; <br>&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt; <br>&gt; <br>&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt; <br>&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br>&gt; <br>&gt;&gt; 3. Although signatures declare exception types, there is no indication at callsites what calls might throw.<br>&gt; <br>&gt; <br>&gt; This of course isn’t an issue in Swift, as the try keyword is mandatory. Thanks to try? and try! this also eliminates number four (everybody hates exceptions) which is largely a complaint about having to build try/catch blocks around them, but with try? and try! we can easily eliminate that when we know we don’t need any extra information besides whether or not a failure occurred.<br>&gt; <br>&gt; Also, regarding overhead of exceptions, I still think that this is something that can be optimised away. All the compiler has to do is identify throw statements, and isolate code specific to them (i.e- variables etc. that are only used as part of a throw); now when you call a method/initialiser with try? or try!, any code identified as being part of the throw can be skipped as all that’s needed is a binary flag (threw vs. succeeded). Of course it sounds a bit easier than it is in reality, but I’m pretty sure it should be possible to change behaviour depending upon how the code is called (i.e- whether an error will actually be used, or simply ignored in favour of its status). When debugging of course the error can be returned in all cases so we can generate and see it.<br>&gt; In short, with Swift’s ability to explicitly declare whether we want an error returned vs simply knowing that an error occurred, it should be possible to optimise such that it is just as efficient as a failable initialiser (if not more so, since the return value isn’t an optional).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/cba53c2a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt; <br>&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt; <br>&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br></p><p>This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift. They cause your code to crash immediately with no hope of reviving it. The Swift compiler even optimizes your code *assuming* these things will crash, so if you were to somehow catch such an error, your app would likely not function correctly. At the very least, it would leak a bunch of objects because it had missed lots of releases.<br></p><p>If you never have before, please read the Error Handling Rationale design document (https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst). It&#39;s long, but it explains exactly why Swift&#39;s error handling is designed the way it is. The &quot;Kinds of error&quot; section might be especially instructive, particularly in that it exists at all. Not all errors are created equal, and many of the ugliest parts of other languages&#39; error systems stem from their failure to recognize that fact.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 5 Mar 2016, at 01:18, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt;&gt; <br>&gt;&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt;&gt; <br>&gt;&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br>&gt; <br>&gt; This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift.<br></p><p>I think I’ve miscommunicated my meaning; my point is that with error handling you can choose the severity of your error types in terms of whether a caller should handle them or not (though it’s ultimately up to them regardless). They can choose to make any error unrecoverable with try! or an explicit precondition failure too if they like. My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br></p><p>There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities. Even just the name failable initialiser is a bit of an oddity now as it’s not a failure in the same sense as a precondition failure, i.e- in Swift a failure usually means unrecoverable, which puts a “failable” initialiser on the same footing as any other error.<br></p><p><br>&gt; On 4 Mar 2016, at 23:07, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br></p><p>As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal. At best this is an argument to delay the proposal until such optimisations can be added, otherwise it’s not really an argument against the proposal itself. In other words, if the performance of try? were identical to a failable initialiser (which it could be) then what really is the difference between the two?<br></p><p>&gt; I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br></p><p>And other features don&#39;t? There are a bunch of potentially code-breaking proposals on this mailing list, but that doesn’t eliminate them from consideration if they are justified. Besides which, Swift (or Xcode) have provided automatic conversion where possible to ease transitions in the past, which wouldn’t be hard to do in this case. For example, the following is the same initialiser in failable and throwable forms:<br></p><p>	init(numericValue:String)? {<br>		guard isNumeric(numericValue) else { return nil }<br>		…<br>	}<br>	init(numericValue:String) throws {<br>		guard isNumeric(numericValue) else { throw InvalidParameterError() }<br>		…<br>	}<br></p><p>And likewise the following two calls to the respective initialisers:<br></p><p>	let value = Foo(numericValue: number)<br>	let value = try? Foo(numericValue:number)<br></p><p>It’s a fairly straightforward conversion; make failable initialiser throw instead, replacing return nil with throw of a default error type, add try? at previously failable call sites. Of course a developer could (should) go back and tweak the throwable initialiser to throw a more specific error (e.g- InvalidNumberError or such), but the generic error provides just as much information as returning nil did, but with the added option of catching it to find out exactly which part of the initialiser it was thrown from.<br></p><p>&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br></p><p>The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature. Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”) which gives a lot more information about exactly why something has failed, or it could be replaced with a more specific error type.<br></p><p>&gt;  Can it be faster?<br></p><p>Possibly, but it can be just as fast, as I pointed out.<br></p><p>Unless you mean faster to use, i.e- how long it takes to type return nil vs throw SomeError(), but in that case it’s arguably better for that to be slower, as it forces more consideration of what type of error to present, rather than a generic “something went wrong but I’m not going to tell you what or where it came from so you’ll have to rely on documentation instead”. Developers may still be lazy and not provide any extra information, but that’s true of most things.<br></p><p>&gt; Can it be shorter?<br></p><p>No, but that’s arguably a good thing too; by placing try, try? or try! in front of the initialiser it is much clearer at the call site that an error can occur, and how it is being handled. While the optional type system can catch mistakes with failable initialisers, they’re not that common in my experience, so IMO it makes more sense for it to be explicit when an initialiser can’t be relied upon to return a value. You might argue the same thing with methods and any optional return value, but these are much more common.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/3f30ff13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br></p><p>I don&#39;t think it&#39;s an issue of severity, but rather an issue of frequency.<br></p><p>Someone asked a similar question on swift-users, and what I said there was that optionals are best used for errors where failure is *expected*—where it is just as likely that an input will fail as that it will succeed, and both cases deserve equal attention. Thrown errors are for cases where failure is still going to happen regularly, but most of the time the operation will succeed and it doesn&#39;t make sense to clutter the main flow of control with error handling. Preconditions are for cases where failure should be impossible.<br></p><p>Making a choice between these three categories constrains your API&#39;s users. But that is what APIs *do*. Using any API requires you to give up some flexibility and accept the judgement of the API&#39;s creator. The decision of `Int.init(_:radix:)` to return an optional instead of throwing an error is no different from its decision to accept Arabic numerals but not Roman numerals. The API&#39;s designer has an opinion about what you need and designed it to serve those needs as well as it can; you can either accept that opinion or use something else.<br></p><p>&gt; There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities.<br></p><p>You see it as having fewer capabilities; I see it as having different use cases. Most code using `Int.init(_:radix:)` is *better* for it being an optional. By returning an optional, the API makes it clear that it can fail, there is only one way for it to fail, and failure is just a routine part of using this API. `throws` says nothing about what can be thrown, and it also suggests that the error cases are unusual and require special handling. That&#39;s just not true for this API.<br></p><p>&gt; As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal.<br></p><p>It is never going to be possible to fully optimize it in the way you imagine.<br></p><p>Ultimately, the reason throwing isn&#39;t as efficient as optionals is simply that throwing communicates more data. And it communicates more data precisely *because* it is more expressive, because it supports many error cases instead of just one. Ultimately you&#39;re running up against information theory here, and the optimizer can&#39;t change fundamental laws of mathematics.<br></p><p>Now, I suppose it would be possible for the compiler to duplicate the function and provide a second implementation for `try?` to use which signals pass/fail in one bit without any details. In private APIs (or internal APIs with testability disabled), it might even be able to optimize away the unused variant. But this is going to make the app bigger and its cache performance worse.<br></p><p>And if it ever *does* have an opportunity to optimize away the full implementation, all that *really* means is that you&#39;ve wasted programming effort. You took time to carefully model all of the possible errors, but you didn&#39;t actually do anything with that information. Or it means you *didn&#39;t* do that—you just threw `IDontKnowItBroke` everywhere—and so you used a mechanism that burdens both caller and callee with additional syntax without getting an ounce of benefit from it. Either way, you have wasted programmer time and effort. (Not to mention compiler engineer time and effort to implement this hypothetical optimization.)<br></p><p>&gt;&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>&gt; <br>&gt; The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature.<br></p><p>All languages have redundant features. `+` is redundant—we have `appendContentsOf` and `addWithOverflow` (this one even provides additional error information!) and all sorts of other things which make `+` unnecessary. And yet we provide it because it would be cumbersome to require those heavyweight mechanisms everywhere.<br></p><p>&gt; Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors<br></p><p>As I said, this does not guarantee better error handling if you&#39;re just throwing generic `InvalidParameterError`s. And if you *are* taking the time to precisely model all errors, that time may be better spent elsewhere.<br></p><p>Swift goes to great pains to eliminate causes of *incorrect* code. We have optionals because &quot;anything can be nil&quot; causes people to make mistakes; we have trapping arithmetic because people don&#39;t design their code to handle overflows; we have designated and convenience initializers because it&#39;s really easy to accidentally create mutual recursion between parent and child class initializers.<br></p><p>It is also *incorrect* to ignore the possibility of an error, and so none of the three error handling mechanisms allows you to ignore an error without explicitly choosing to do so.* But providing limited error detail is not incorrect—it is merely making a perfectly acceptable tradeoff.<br></p><p>(* This is not quite true of returning an optional (or boolean) value right now because Swift does not yet make `@warn_unused_result` the default, but it looks like that will change in Swift 3. However, if you *do* capture the result, Swift does force you to reckon with the possibility that it may be optional.)<br></p><p>&gt; (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”)<br></p><p>As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br></p><p>Actually providing a useful error would take a lot of careful modeling; in fact, almost any amount of effort you might put into it may prove insufficient for some particular client. Even if requiring `throws` did succeed in encouraging *more* specific error modeling, that doesn&#39;t mean it would provide *enough* error modeling for any particular use case.<br></p><p>And even if we put a magic spell on the Swift compiler to force all programmers using Swift to completely describe errors, *that effort would almost always be wasted*, because most of the time, most of that detail would be ignored.<br></p><p>Completely modeling all sources of error is not always the right solution. At some point, the right solution is to stop answering the &quot;why&quot; questions. We shouldn&#39;t punish people for that, even if the stopping point they choose is right at the top.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 5, 2016, at 7:01 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br>&gt; <br>&gt; I don&#39;t think it&#39;s an issue of severity, but rather an issue of frequency.<br>&gt; <br>&gt; Someone asked a similar question on swift-users, and what I said there was that optionals are best used for errors where failure is *expected*—where it is just as likely that an input will fail as that it will succeed, and both cases deserve equal attention. Thrown errors are for cases where failure is still going to happen regularly, but most of the time the operation will succeed and it doesn&#39;t make sense to clutter the main flow of control with error handling. Preconditions are for cases where failure should be impossible.<br>&gt; <br>&gt; Making a choice between these three categories constrains your API&#39;s users. But that is what APIs *do*. Using any API requires you to give up some flexibility and accept the judgement of the API&#39;s creator. The decision of `Int.init(_:radix:)` to return an optional instead of throwing an error is no different from its decision to accept Arabic numerals but not Roman numerals. The API&#39;s designer has an opinion about what you need and designed it to serve those needs as well as it can; you can either accept that opinion or use something else.<br>&gt; <br>&gt;&gt; There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities.<br>&gt; <br>&gt; You see it as having fewer capabilities; I see it as having different use cases. Most code using `Int.init(_:radix:)` is *better* for it being an optional. By returning an optional, the API makes it clear that it can fail, there is only one way for it to fail, and failure is just a routine part of using this API. `throws` says nothing about what can be thrown, and it also suggests that the error cases are unusual and require special handling. That&#39;s just not true for this API.<br>&gt; <br>&gt;&gt; As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal.<br>&gt; <br>&gt; It is never going to be possible to fully optimize it in the way you imagine.<br>&gt; <br>&gt; Ultimately, the reason throwing isn&#39;t as efficient as optionals is simply that throwing communicates more data. And it communicates more data precisely *because* it is more expressive, because it supports many error cases instead of just one. Ultimately you&#39;re running up against information theory here, and the optimizer can&#39;t change fundamental laws of mathematics.<br>&gt; <br>&gt; Now, I suppose it would be possible for the compiler to duplicate the function and provide a second implementation for `try?` to use which signals pass/fail in one bit without any details. In private APIs (or internal APIs with testability disabled), it might even be able to optimize away the unused variant. But this is going to make the app bigger and its cache performance worse.<br>&gt; <br>&gt; And if it ever *does* have an opportunity to optimize away the full implementation, all that *really* means is that you&#39;ve wasted programming effort. You took time to carefully model all of the possible errors, but you didn&#39;t actually do anything with that information. Or it means you *didn&#39;t* do that—you just threw `IDontKnowItBroke` everywhere—and so you used a mechanism that burdens both caller and callee with additional syntax without getting an ounce of benefit from it. Either way, you have wasted programmer time and effort. (Not to mention compiler engineer time and effort to implement this hypothetical optimization.)<br>&gt; <br>&gt;&gt;&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>&gt;&gt; <br>&gt;&gt; The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature.<br>&gt; <br>&gt; All languages have redundant features. `+` is redundant—we have `appendContentsOf` and `addWithOverflow` (this one even provides additional error information!) and all sorts of other things which make `+` unnecessary. And yet we provide it because it would be cumbersome to require those heavyweight mechanisms everywhere.<br>&gt; <br>&gt;&gt; Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors<br>&gt; <br>&gt; As I said, this does not guarantee better error handling if you&#39;re just throwing generic `InvalidParameterError`s. And if you *are* taking the time to precisely model all errors, that time may be better spent elsewhere.<br>&gt; <br>&gt; Swift goes to great pains to eliminate causes of *incorrect* code. We have optionals because &quot;anything can be nil&quot; causes people to make mistakes; we have trapping arithmetic because people don&#39;t design their code to handle overflows; we have designated and convenience initializers because it&#39;s really easy to accidentally create mutual recursion between parent and child class initializers.<br>&gt; <br>&gt; It is also *incorrect* to ignore the possibility of an error, and so none of the three error handling mechanisms allows you to ignore an error without explicitly choosing to do so.* But providing limited error detail is not incorrect—it is merely making a perfectly acceptable tradeoff.<br>&gt; <br>&gt; (* This is not quite true of returning an optional (or boolean) value right now because Swift does not yet make `@warn_unused_result` the default, but it looks like that will change in Swift 3. However, if you *do* capture the result, Swift does force you to reckon with the possibility that it may be optional.)<br>&gt; <br>&gt;&gt; (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”)<br>&gt; <br>&gt; As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br>&gt; <br>&gt; Actually providing a useful error would take a lot of careful modeling; in fact, almost any amount of effort you might put into it may prove insufficient for some particular client. Even if requiring `throws` did succeed in encouraging *more* specific error modeling, that doesn&#39;t mean it would provide *enough* error modeling for any particular use case.<br>&gt; <br>&gt; And even if we put a magic spell on the Swift compiler to force all programmers using Swift to completely describe errors, *that effort would almost always be wasted*, because most of the time, most of that detail would be ignored.<br>&gt; <br>&gt; Completely modeling all sources of error is not always the right solution. At some point, the right solution is to stop answering the &quot;why&quot; questions. We shouldn&#39;t punish people for that, even if the stopping point they choose is right at the top.<br></p><p>ErrorType does get some special treatment from the compiler and runtime to make throwing errors cheap. ErrorType&#39;s representation is specialized to use a single pointer to a refcounted box, so that it can be returned and passed cheaply, and on Darwin platforms it is laid out to be toll-free-bridgeable as an NSError subclass, so that &#39;as NSError&#39; conversions are free. It&#39;s not implemented yet, but on 64-bit platforms we have enough room to pack a small error enum along with its type metadata into the pointer without allocating at all.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>March  6, 2016 at 10:00:00am</p></header><div class="content"><p>Just my though, but if this is about redundant feature, why limiting the discussion to initializer. Why not remove Optional as a return type, as any method that return a nil optional on failure may as well throw.<br></p><p>&gt; Le 5 mars 2016 à 23:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 5 Mar 2016, at 01:18, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br>&gt;&gt; <br>&gt;&gt; This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift.<br>&gt; <br>&gt; I think I’ve miscommunicated my meaning; my point is that with error handling you can choose the severity of your error types in terms of whether a caller should handle them or not (though it’s ultimately up to them regardless). They can choose to make any error unrecoverable with try! or an explicit precondition failure too if they like. My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br>&gt; <br>&gt; There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities. Even just the name failable initialiser is a bit of an oddity now as it’s not a failure in the same sense as a precondition failure, i.e- in Swift a failure usually means unrecoverable, which puts a “failable” initialiser on the same footing as any other error.<br>&gt; <br>&gt; <br>&gt;&gt; On 4 Mar 2016, at 23:07, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br>&gt; <br>&gt; As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal. At best this is an argument to delay the proposal until such optimisations can be added, otherwise it’s not really an argument against the proposal itself. In other words, if the performance of try? were identical to a failable initialiser (which it could be) then what really is the difference between the two?<br>&gt; <br>&gt;&gt; I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br>&gt; <br>&gt; And other features don&#39;t? There are a bunch of potentially code-breaking proposals on this mailing list, but that doesn’t eliminate them from consideration if they are justified. Besides which, Swift (or Xcode) have provided automatic conversion where possible to ease transitions in the past, which wouldn’t be hard to do in this case. For example, the following is the same initialiser in failable and throwable forms:<br>&gt; <br>&gt; 	init(numericValue:String)? {<br>&gt; 		guard isNumeric(numericValue) else { return nil }<br>&gt; 		…<br>&gt; 	}<br>&gt; 	init(numericValue:String) throws {<br>&gt; 		guard isNumeric(numericValue) else { throw InvalidParameterError() }<br>&gt; 		…<br>&gt; 	}<br>&gt; <br>&gt; And likewise the following two calls to the respective initialisers:<br>&gt; <br>&gt; 	let value = Foo(numericValue: number)<br>&gt; 	let value = try? Foo(numericValue:number)<br>&gt; <br>&gt; It’s a fairly straightforward conversion; make failable initialiser throw instead, replacing return nil with throw of a default error type, add try? at previously failable call sites. Of course a developer could (should) go back and tweak the throwable initialiser to throw a more specific error (e.g- InvalidNumberError or such), but the generic error provides just as much information as returning nil did, but with the added option of catching it to find out exactly which part of the initialiser it was thrown from.<br>&gt; <br>&gt;&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>&gt; <br>&gt; The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature. Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”) which gives a lot more information about exactly why something has failed, or it could be replaced with a more specific error type.<br>&gt; <br>&gt;&gt;  Can it be faster?<br>&gt; <br>&gt; Possibly, but it can be just as fast, as I pointed out.<br>&gt; <br>&gt; Unless you mean faster to use, i.e- how long it takes to type return nil vs throw SomeError(), but in that case it’s arguably better for that to be slower, as it forces more consideration of what type of error to present, rather than a generic “something went wrong but I’m not going to tell you what or where it came from so you’ll have to rely on documentation instead”. Developers may still be lazy and not provide any extra information, but that’s true of most things.<br>&gt; <br>&gt;&gt; Can it be shorter?<br>&gt; <br>&gt; No, but that’s arguably a good thing too; by placing try, try? or try! in front of the initialiser it is much clearer at the call site that an error can occur, and how it is being handled. While the optional type system can catch mistakes with failable initialisers, they’re not that common in my experience, so IMO it makes more sense for it to be explicit when an initialiser can’t be relied upon to return a value. You might argue the same thing with methods and any optional return value, but these are much more common.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/3e9fc4fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>March  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 4:22 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just my though, but if this is about redundant feature, why limiting the discussion to initializer. Why not remove Optional as a return type, as any method that return a nil optional on failure may as well throw.<br></p><p>HUGE Nooooooo, and -1. This is so anti-Swift it hurts Swift&#39;s feelings, haha. I find some redundancy very, very useful. Not every problem is best handled with one methodology. Removing does not always mean improving. To remove fail able initializers would be disappointing. Sometimes you just don&#39;t need an error. What if the init fails because an instance already exists -- the user is just clicking like mad, haha. Well you don&#39;t a screen full of &quot;hey, dude, I&#39;m working on it stop clicking already&quot;.  You just allow for one click, the initializer does it&#39;s thing and the user is happy that system didn&#39;t crash from error overload. Perhaps that&#39;s a poor example, but it&#39;s simple for my simple mind. To remove optional as a return type... Dictionary is broken, so is Set... The language just died. And you killed it. This is not a good idea. It would change a massive amount of code both in the language and in my own projects. Absolutely, no, please. <br></p><p>Myles<br></p><p>&gt; <br>&gt;&gt;&gt; Le 5 mars 2016 à 23:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 5 Mar 2016, at 01:18, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift.<br>&gt;&gt; <br>&gt;&gt; I think I’ve miscommunicated my meaning; my point is that with error handling you can choose the severity of your error types in terms of whether a caller should handle them or not (though it’s ultimately up to them regardless). They can choose to make any error unrecoverable with try! or an explicit precondition failure too if they like. My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br>&gt;&gt; <br>&gt;&gt; There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities. Even just the name failable initialiser is a bit of an oddity now as it’s not a failure in the same sense as a precondition failure, i.e- in Swift a failure usually means unrecoverable, which puts a “failable” initialiser on the same footing as any other error.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 4 Mar 2016, at 23:07, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br>&gt;&gt; <br>&gt;&gt; As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal. At best this is an argument to delay the proposal until such optimisations can be added, otherwise it’s not really an argument against the proposal itself. In other words, if the performance of try? were identical to a failable initialiser (which it could be) then what really is the difference between the two?<br>&gt;&gt; <br>&gt;&gt;&gt; I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br>&gt;&gt; <br>&gt;&gt; And other features don&#39;t? There are a bunch of potentially code-breaking proposals on this mailing list, but that doesn’t eliminate them from consideration if they are justified. Besides which, Swift (or Xcode) have provided automatic conversion where possible to ease transitions in the past, which wouldn’t be hard to do in this case. For example, the following is the same initialiser in failable and throwable forms:<br>&gt;&gt; <br>&gt;&gt; 	init(numericValue:String)? {<br>&gt;&gt; 		guard isNumeric(numericValue) else { return nil }<br>&gt;&gt; 		…<br>&gt;&gt; 	}<br>&gt;&gt; 	init(numericValue:String) throws {<br>&gt;&gt; 		guard isNumeric(numericValue) else { throw InvalidParameterError() }<br>&gt;&gt; 		…<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; And likewise the following two calls to the respective initialisers:<br>&gt;&gt; <br>&gt;&gt; 	let value = Foo(numericValue: number)<br>&gt;&gt; 	let value = try? Foo(numericValue:number)<br>&gt;&gt; <br>&gt;&gt; It’s a fairly straightforward conversion; make failable initialiser throw instead, replacing return nil with throw of a default error type, add try? at previously failable call sites. Of course a developer could (should) go back and tweak the throwable initialiser to throw a more specific error (e.g- InvalidNumberError or such), but the generic error provides just as much information as returning nil did, but with the added option of catching it to find out exactly which part of the initialiser it was thrown from.<br>&gt;&gt; <br>&gt;&gt;&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>&gt;&gt; <br>&gt;&gt; The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature. Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”) which gives a lot more information about exactly why something has failed, or it could be replaced with a more specific error type.<br>&gt;&gt; <br>&gt;&gt;&gt;  Can it be faster?<br>&gt;&gt; <br>&gt;&gt; Possibly, but it can be just as fast, as I pointed out.<br>&gt;&gt; <br>&gt;&gt; Unless you mean faster to use, i.e- how long it takes to type return nil vs throw SomeError(), but in that case it’s arguably better for that to be slower, as it forces more consideration of what type of error to present, rather than a generic “something went wrong but I’m not going to tell you what or where it came from so you’ll have to rely on documentation instead”. Developers may still be lazy and not provide any extra information, but that’s true of most things.<br>&gt;&gt; <br>&gt;&gt;&gt; Can it be shorter?<br>&gt;&gt; <br>&gt;&gt; No, but that’s arguably a good thing too; by placing try, try? or try! in front of the initialiser it is much clearer at the call site that an error can occur, and how it is being handled. While the optional type system can catch mistakes with failable initialisers, they’re not that common in my experience, so IMO it makes more sense for it to be explicit when an initialiser can’t be relied upon to return a value. You might argue the same thing with methods and any optional return value, but these are much more common.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/7fa8d7fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  7, 2016 at 07:00:00am</p></header><div class="content"><p>For me the factory method could still be implemented as a class method that returns an optionalAnd in fact that example used of not creating a duplicate instance would fit here.<br>I limited this to purely to initialisers as there is a lot more that could get wrong and I felt that in some case falliable initlizers were encouraging people to trivialise something that may bite them in the long run like parsing Json for a model it failing and returning nil. They would have to manually insert breakpoints to figure out why and po the Json.<br>For normal functions I think there are many acceptable cases where returning an optional instead of an error is okay.<br>In any case if this is *not* the right approach, I think the upcoming and accepted API design guidelines could be updated from the proposal I am about to submit for this. It would be great to have some guidance of how we should model errors. Right now even after reading the doc I am not sure if throwing an error for my example of parsing Json into a model is correct or if I should just return nil and if I return nil is logging it out to the console a good idea ? <br>I will add a consideration in my proposal for updating the new API Guidelines with guidedence for error handling. At the very least it will help clear things up.<br>Sent from Supmenow.com<br></p><p><br></p><p><br>On Sun, Mar 6, 2016 at 7:27 AM -0800, &quot;Myles Schultz via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>On Mar 6, 2016, at 4:22 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Just my though, but if this is about redundant feature, why limiting the discussion to initializer. Why not remove Optional as a return type, as any method that return a nil optional on failure may as well throw.<br>HUGE Nooooooo, and -1. This is so anti-Swift it hurts Swift&#39;s feelings, haha. I find some redundancy very, very useful. Not every problem is best handled with one methodology. Removing does not always mean improving. To remove fail able initializers would be disappointing. Sometimes you just don&#39;t need an error. What if the init fails because an instance already exists -- the user is just clicking like mad, haha. Well you don&#39;t a screen full of &quot;hey, dude, I&#39;m working on it stop clicking already&quot;.  You just allow for one click, the initializer does it&#39;s thing and the user is happy that system didn&#39;t crash from error overload. Perhaps that&#39;s a poor example, but it&#39;s simple for my simple mind. To remove optional as a return type... Dictionary is broken, so is Set... The language just died. And you killed it. This is not a good idea. It would change a massive amount of code both in the language and in my own projects. Absolutely, no, please. <br>Myles<br></p><p>Le 5 mars 2016 à 23:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>On 5 Mar 2016, at 01:18, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br></p><p>This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br></p><p>I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br></p><p>This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift.<br>I think I’ve miscommunicated my meaning; my point is that with error handling you can choose the severity of your error types in terms of whether a caller should handle them or not (though it’s ultimately up to them regardless). They can choose to make any error unrecoverable with try! or an explicit precondition failure too if they like. My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br>There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities. Even just the name failable initialiser is a bit of an oddity now as it’s not a failure in the same sense as a precondition failure, i.e- in Swift a failure usually means unrecoverable, which puts a “failable” initialiser on the same footing as any other error.<br></p><p>On 4 Mar 2016, at 23:07, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br>As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal. At best this is an argument to delay the proposal until such optimisations can be added, otherwise it’s not really an argument against the proposal itself. In other words, if the performance of try? were identical to a failable initialiser (which it could be) then what really is the difference between the two?<br>I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br>And other features don&#39;t? There are a bunch of potentially code-breaking proposals on this mailing list, but that doesn’t eliminate them from consideration if they are justified. Besides which, Swift (or Xcode) have provided automatic conversion where possible to ease transitions in the past, which wouldn’t be hard to do in this case. For example, the following is the same initialiser in failable and throwable forms:<br>	init(numericValue:String)? {		guard isNumeric(numericValue) else { return nil }		…	}	init(numericValue:String) throws {		guard isNumeric(numericValue) else { throw InvalidParameterError() }		…	}<br>And likewise the following two calls to the respective initialisers:<br>	let value = Foo(numericValue: number)	let value = try? Foo(numericValue:number)<br>It’s a fairly straightforward conversion; make failable initialiser throw instead, replacing return nil with throw of a default error type, add try? at previously failable call sites. Of course a developer could (should) go back and tweak the throwable initialiser to throw a more specific error (e.g- InvalidNumberError or such), but the generic error provides just as much information as returning nil did, but with the added option of catching it to find out exactly which part of the initialiser it was thrown from.<br>However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature. Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”) which gives a lot more information about exactly why something has failed, or it could be replaced with a more specific error type.<br> Can it be faster?<br>Possibly, but it can be just as fast, as I pointed out.<br>Unless you mean faster to use, i.e- how long it takes to type return nil vs throw SomeError(), but in that case it’s arguably better for that to be slower, as it forces more consideration of what type of error to present, rather than a generic “something went wrong but I’m not going to tell you what or where it came from so you’ll have to rely on documentation instead”. Developers may still be lazy and not provide any extra information, but that’s true of most things.<br>Can it be shorter?<br>No, but that’s arguably a good thing too; by placing try, try? or try! in front of the initialiser it is much clearer at the call site that an error can occur, and how it is being handled. While the optional type system can catch mistakes with failable initialisers, they’re not that common in my experience, so IMO it makes more sense for it to be explicit when an initialiser can’t be relied upon to return a value. You might argue the same thing with methods and any optional return value, but these are much more common._______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/f5f6c553/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>March  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 7 mars 2016 à 08:15, James Campbell &lt;james at supmenow.com&gt; a écrit :<br>&gt; <br>&gt; For me the factory method could still be implemented as a class method that returns an optional<br>&gt; And in fact that example used of not creating a duplicate instance would fit here.<br>&gt; <br>&gt; I limited this to purely to initialisers as there is a lot more that could get wrong and I felt that in some case falliable initlizers were encouraging people to trivialise something that may bite them in the long run like parsing Json for a model it failing and returning nil. They would have to manually insert breakpoints to figure out why and po the Json.<br>&gt; <br>&gt; For normal functions I think there are many acceptable cases where returning an optional instead of an error is okay.<br>&gt; <br>&gt; In any case if this is *not* the right approach, I think the upcoming and accepted API design guidelines could be updated from the proposal I am about to submit for this. It would be great to have some guidance of how we should model errors. Right now even after reading the doc I am not sure if throwing an error for my example of parsing Json into a model is correct or if I should just return nil and if I return nil is logging it out to the console a good idea ? <br></p><p>It depends where your JSON come from, what your are doing with it, and a lot of other things. Error model should not be design solely base on the task you perform, but the context too.<br></p><p>For instance, failing to parse a JSON loaded from trusted resource should probably result in a abort(), while failing to load it from user provided URL should result in a error dialog explaining the user what went wrong.<br></p><p>&gt; <br>&gt; I will add a consideration in my proposal for updating the new API Guidelines with guidedence for error handling. At the very least it will help clear things up.<br>&gt; <br>&gt; Sent from Supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Mar 6, 2016 at 7:27 AM -0800, &quot;Myles Schultz via swift-evolution&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mar 6, 2016, at 4:22 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Just my though, but if this is about redundant feature, why limiting the discussion to initializer. Why not remove Optional as a return type, as any method that return a nil optional on failure may as well throw.<br>&gt; <br>&gt; HUGE Nooooooo, and -1. This is so anti-Swift it hurts Swift&#39;s feelings, haha. I find some redundancy very, very useful. Not every problem is best handled with one methodology. Removing does not always mean improving. To remove fail able initializers would be disappointing. Sometimes you just don&#39;t need an error. What if the init fails because an instance already exists -- the user is just clicking like mad, haha. Well you don&#39;t a screen full of &quot;hey, dude, I&#39;m working on it stop clicking already&quot;.  You just allow for one click, the initializer does it&#39;s thing and the user is happy that system didn&#39;t crash from error overload. Perhaps that&#39;s a poor example, but it&#39;s simple for my simple mind. To remove optional as a return type... Dictionary is broken, so is Set... The language just died. And you killed it. This is not a good idea. It would change a massive amount of code both in the language and in my own projects. Absolutely, no, please. <br>&gt; <br>&gt; Myles<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 5 mars 2016 à 23:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 5 Mar 2016, at 01:18, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is really a matter of convention, and also more of a matter of terminology. For example, in Swift, they’re just errors rather than exceptions; i.e- there’s no strict indication of their severity, and like any good “exception” model it’s up to the developer if they want to throw an error onwards, silently hide it, do some recovery etc. If you wish to throw a minor error vs a severe one, then you use different error types and document what they represent.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d also argue that a failable initialiser represents no less severe an issue than an error does, as the initialiser has still failed, and therefore created nothing usable, ultimately requiring some form of recovery (testing for nil, supplying a default etc.). It isn’t clear at all to me that these are different things, as both can be recoverable or unrecoverable depending upon which form you use it in (try? vs try! vs try/catch, or Foo() vs Foo()!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is emphatically not true. Swift represents unrecoverable bugs with precondition failures, not error throwing. Force unwrapping failures (the Swift equivalent of null dereferences), divide-by-zero, and so on are not failures you can catch in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I’ve miscommunicated my meaning; my point is that with error handling you can choose the severity of your error types in terms of whether a caller should handle them or not (though it’s ultimately up to them regardless). They can choose to make any error unrecoverable with try! or an explicit precondition failure too if they like. My point being that if you consider failable initialisers to be somehow less severe than a thrown error, then that’s not really reinforced in any way, as with a throwable initialiser you’re free to throw error types that are minor, e.g- YouProbablyMadeAMistakeError vs SomethingJustExplodedAndPeopleAreDyingError.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s nothing that a failable initialiser represents that is distinct from error handling; before error handling was added it was the only option, but now it’s effectively redundant, with less capabilities. Even just the name failable initialiser is a bit of an oddity now as it’s not a failure in the same sense as a precondition failure, i.e- in Swift a failure usually means unrecoverable, which puts a “failable” initialiser on the same footing as any other error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Mar 2016, at 23:07, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Saying that the optimizer will *probably* make it okay is a very poor justification for replacing a fast feature with a slow one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I pointed out it is possible to optimise error handling to be just as efficient as failable initialisers; if the compiler currently doesn’t do this then it absolutely should irrespective of this proposal. At best this is an argument to delay the proposal until such optimisations can be added, otherwise it’s not really an argument against the proposal itself. In other words, if the performance of try? were identical to a failable initialiser (which it could be) then what really is the difference between the two?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to remind that this proposal amounts to you going into my code, and everyone else&#39;s code, and break it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And other features don&#39;t? There are a bunch of potentially code-breaking proposals on this mailing list, but that doesn’t eliminate them from consideration if they are justified. Besides which, Swift (or Xcode) have provided automatic conversion where possible to ease transitions in the past, which wouldn’t be hard to do in this case. For example, the following is the same initialiser in failable and throwable forms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	init(numericValue:String)? {<br>&gt;&gt;&gt; 		guard isNumeric(numericValue) else { return nil }<br>&gt;&gt;&gt; 		…<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	init(numericValue:String) throws {<br>&gt;&gt;&gt; 		guard isNumeric(numericValue) else { throw InvalidParameterError() }<br>&gt;&gt;&gt; 		…<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And likewise the following two calls to the respective initialisers:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let value = Foo(numericValue: number)<br>&gt;&gt;&gt; 	let value = try? Foo(numericValue:number)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a fairly straightforward conversion; make failable initialiser throw instead, replacing return nil with throw of a default error type, add try? at previously failable call sites. Of course a developer could (should) go back and tweak the throwable initialiser to throw a more specific error (e.g- InvalidNumberError or such), but the generic error provides just as much information as returning nil did, but with the added option of catching it to find out exactly which part of the initialiser it was thrown from.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, so far, I don&#39;t see any technical merit to it. It&#39;s not faster, it&#39;s not shorter, it&#39;s not better error handling. And even if you think that you can say that it&#39;s not worse, you so far have stopped short of showing that it&#39;s better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main reason against failable initialisers is that given that the above assignments are identical, this means that it is a redundant feature. Requiring the use of thrown errors is definitely better error handling, as it’s far more flexible, and encourages developers to think about the type of errors should be thrown and/or the contents of these errors (i.e- that InvalidParameterError could easily take a string describing why the parameter was invalid such as “Value cannot contain non-numeric characters”) which gives a lot more information about exactly why something has failed, or it could be replaced with a more specific error type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  Can it be faster?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Possibly, but it can be just as fast, as I pointed out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless you mean faster to use, i.e- how long it takes to type return nil vs throw SomeError(), but in that case it’s arguably better for that to be slower, as it forces more consideration of what type of error to present, rather than a generic “something went wrong but I’m not going to tell you what or where it came from so you’ll have to rely on documentation instead”. Developers may still be lazy and not provide any extra information, but that’s true of most things.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can it be shorter?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, but that’s arguably a good thing too; by placing try, try? or try! in front of the initialiser it is much clearer at the call site that an error can occur, and how it is being handled. While the optional type system can catch mistakes with failable initialisers, they’re not that common in my experience, so IMO it makes more sense for it to be explicit when an initialiser can’t be relied upon to return a value. You might argue the same thing with methods and any optional return value, but these are much more common.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/3b653b8b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 6 Mar 2016, at 09:22, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; Just my though, but if this is about redundant feature, why limiting the discussion to initializer. Why not remove Optional as a return type, as any method that return a nil optional on failure may as well throw.<br></p><p>Because methods and properties are different; for example, the .indexOf() method on a collection can be called with an element that doesn’t exist within the collection, this isn’t an error as the method doesn’t require you to only request elements that can be found, so forcing that to throw would make no sense.<br></p><p>However every case I’ve seen for failable initialisers seems to be modelling some type of actual error (e.g- invalid data) as opposed to input being valid but the result is nothing, so it still seem to me like it should be using error handling, but I think at this point I’ve said more than enough on the subject.<br></p><p>&gt; On 6 Mar 2016, at 03:01, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I suppose it would be possible for the compiler to duplicate the function and provide a second implementation for `try?` to use which signals pass/fail in one bit without any details. In private APIs (or internal APIs with testability disabled), it might even be able to optimize away the unused variant. But this is going to make the app bigger and its cache performance worse.<br></p><p>A duplicate shouldn’t be necessary; functions/initialisers that can throw just need to be called with a flag indicating whether they should capture or ignore errors as appropriate for try vs try? and try!. Any statement that is identified as being specific to a throw is then wrapped in a conditional based on this flag so it can be skipped if errors are ignored. The throw itself will then either return the error (if it was generated) otherwise it simply indicates that an error occurred and nothing more. The compiler should already be grouping throw-specific statements together where possible, so that they aren’t visited during a non-error path so this shouldn’t add many of these conditional checks at all (in most cases there should only be one, and it will only be tested in the throw branch).<br></p><p>&gt; All languages have redundant features. `+` is redundant—we have `appendContentsOf` and `addWithOverflow` (this one even provides additional error information!) and all sorts of other things which make `+` unnecessary. And yet we provide it because it would be cumbersome to require those heavyweight mechanisms everywhere.<br></p><p>In the case of addWithOverflow that’s not redundant in the same way as its a matter of safety; + implicitly guards against overflow, while addWithOverflow() and &amp;+ explicitly allow it. Regarding operators vs the methods they actually call, that’s sugar; the operator is just a shorter way to do the same thing, i.e- the operator is just a prettier way to write what is exactly the same code.<br></p><p>With the failable initialisers you’re using a distinctly separate feature to achieve the same end result that error handling is capable of, which is where I feel that the overlap produces redundancy.<br></p><p>&gt; As I said, this does not guarantee better error handling if you&#39;re just throwing generic `InvalidParameterError`s. And if you *are* taking the time to precisely model all errors, that time may be better spent elsewhere.<br></p><p>That’s more an issue of developer laziness more than anything, but at least it’s still communicating that that’s exactly what the error is. If the standard library includes a good set of default errors then that should cover most use-cases; anything that isn’t covered by a standard error meanwhile absolutely should be given a new error type IMO.<br></p><p>&gt; As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br></p><p>I’m not sure what you mean by this exactly; if you mean that an error should include extra data that can be extracted from the error instance itself then that depends on the error. If you’re capturing an invalid parameter error then it will be for debugging purposes I think, so the message is for the developer to inform them of which parameter failed (rather than having to have a different error for each parameter) and possibly some info on why, i.e- I’m not talking about text that would be spit out to a user or logged directly (except perhaps as a debug statement), or that you would expect to capture and process extensively. In this case even a simple string should be plenty helpful compared to nothing.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; A duplicate shouldn’t be necessary; functions/initialisers that can throw just need to be called with a flag indicating whether they should capture or ignore errors as appropriate for try vs try? and try!. Any statement that is identified as being specific to a throw is then wrapped in a conditional based on this flag so it can be skipped if errors are ignored.<br></p><p>Okay, so you&#39;re passing in what amounts to a new parameter (which is going to take up a register or some stack space that could be used for something else) and adding a new conditional branch at each throw site. In cases where a `try` is nested directly inside a `throws` function, you might need a conditional branch at the return site, too. (Remember, CPUs hate conditional branches.)<br></p><p>These things aren&#39;t free. In fact, they may end up costing more than the original optimization did.<br></p><p>&gt; That’s more an issue of developer laziness more than anything<br></p><p>I think that your use of the word &quot;laziness&quot; is telling. You are assuming that, if someone doesn&#39;t throw detailed errors, they are being lazy. They are not putting in the work to write good code. They should be judged harshly for this. The language should punish them for their laziness by taking away the tools which allow it.<br></p><p>But sometimes when you don&#39;t do work, it&#39;s not because you&#39;re being lazy; it&#39;s because that work is *unnecessary*. You could spend time slaving over an enum full of error codes which will just be converted to an optional, or you could just return an optional in the first place and use the time you saved to do something that will actually improve the product in ways your users will value.<br></p><p>In many simple error handling situations, doing any work beyond indicating success/failure is *unnecessary*. It provides no additional value. We should not hinder the productivity of developers in situations like that simply because sometimes they might misuse the feature permitting it.<br></p><p>&gt; but at least it’s still communicating that that’s exactly what the error is. If the standard library includes a good set of default errors then that should cover most use-cases; anything that isn’t covered by a standard error meanwhile absolutely should be given a new error type IMO.<br></p><p>But &quot;invalid parameter&quot; only communicates what&#39;s happening because it&#39;s so vague that almost any error can be called an &quot;invalid parameter&quot;. A malformed path, a path to a file that doesn&#39;t exist, and a path to a file in the wrong format are all &quot;invalid parameters&quot;. I mean, I guess it tells you that the problem isn&#39;t in a property or global or something, but that&#39;s not exactly a surprise, is it?<br></p><p>Simply throwing &quot;invalid parameter&quot; conveys no *actually useful* information beyond &quot;that wasn&#39;t right&quot;, which is exactly what `?` does.<br></p><p>&gt;&gt; As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br>&gt; <br>&gt; I’m not sure what you mean by this exactly; if you mean that an error should include extra data that can be extracted from the error instance itself then that depends on the error.<br></p><p>What I&#39;m saying is that *actually* providing errors with enough detail to be useful is hard work. A string typed directly into your source code, addressed to the developer using your API, in one particular language, with the error&#39;s details converted to text and interpolated into it, will not usefully convey the problem. You need to express the problem *programmatically*, and that means carefully cataloguing the causes of errors and deciding for each one how much detail the developer needs.<br></p><p>To illustrate, I spent ten or fifteen minutes examining IntegerParsing.swift.gyb so I could understand the failure cases of `Int.init(_:radix)`. To fully model all of the errors which can cause it to return `nil`, and without including any redundant information you could get from the string itself, you would probably need this enum:<br></p><p>	enum IntFromStringError: ErrorType {<br>		case EmptyString<br>		case NoDigits<br>		case NegativeUnsigned<br>		case TooLarge (at: String.UTF16View.Index)<br>		case NonDigit (at: String.UTF16View.Index)<br>		case DigitBeyondRadix (at: String.UTF16View.Index)<br>	}<br></p><p>(Note that this does *not* include several errors for invalid radixes which are enforced by preconditions. Evidently, a too-small or too-large radix is considered to be a programmer error.)<br></p><p>A couple of those cases could probably be collapsed into others; it could be three or four instead of six. But think about all that has happened here:<br></p><p>• We&#39;ve exposed an implementation detail: the algorithm uses the UTF-16 representation of the string. We could convert the index, but then we would be doing work—I suspect invoking an O(N) algorithm!—purely to provide error information which many users would not need. Similarly, if we ever needed to change the implementation, we would either need to make an incompatible change to the error enum or waste time on a conversion. And if we don&#39;t include an index at all, then we&#39;re not providing enough detail to do anything useful with those errors.<br></p><p>• We still have not modeled the possible errors with full fidelity, because `NegativeUnsigned` is only possible on a `UInt`. We really ought to have separate enums for `IntFromStringError` and `UIntFromStringError`.<br></p><p>• We cannot actually promise that these are the only possible errors this can throw. Currently, you can throw any ErrorType from any throwing function. And in the future, resilience will allow later versions of a library to add cases to enums.<br></p><p>• And we have provided the errors with a level of detail that nearly all callers do not care about. 99.9% of callers will use `try?` and throw away all of this information, so why are we going to so much effort to model it?<br></p><p>And again, if your answer is &quot;Don&#39;t do all that, just lump everything together into one vague error&quot;, then why are we using the throwing mechanism in the first place? Failable initializers convey one vague error just as well and with much less fuss.<br></p><p>&gt; If you’re capturing an invalid parameter error then it will be for debugging purposes I think, so the message is for the developer to inform them of which parameter failed (rather than having to have a different error for each parameter) and possibly some info on why, i.e- I’m not talking about text that would be spit out to a user or logged directly (except perhaps as a debug statement), or that you would expect to capture and process extensively. In this case even a simple string should be plenty helpful compared to nothing.<br></p><p>If an error should only occur during debugging, it should be a precondition, not a failable *or* throwing initializer.<br></p><p>By definition, any throwable error should be something you expect to happen in the normal course of running the code out in the wild. That means there needs to be enough detail to either automatically fix the problem or usefully present it to a user, either textually or with some kind of graphical representation (like pointing to the invalid character).<br></p><p>* * *<br></p><p>Ultimately, here is my point: When faced with a requirement that all errors be thrown, you get two choices.<br></p><p>1. **Throw something super-vague.** This is no better than returning `nil`.<br>2. **Throw something really specific and useful.** This requires engineering effort which might be better spent elsewhere.<br></p><p>Both options waste computer time and programmer time, and they ultimately stem from prejudging how the developer chooses to allocate their time.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>March  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Here, here! *knock, knock, knock of knuckles on table*<br></p><p>Sent from my iPhone<br></p><p>On Mar 7, 2016, at 8:21 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; A duplicate shouldn’t be necessary; functions/initialisers that can throw just need to be called with a flag indicating whether they should capture or ignore errors as appropriate for try vs try? and try!. Any statement that is identified as being specific to a throw is then wrapped in a conditional based on this flag so it can be skipped if errors are ignored.<br>&gt; <br>&gt; Okay, so you&#39;re passing in what amounts to a new parameter (which is going to take up a register or some stack space that could be used for something else) and adding a new conditional branch at each throw site. In cases where a `try` is nested directly inside a `throws` function, you might need a conditional branch at the return site, too. (Remember, CPUs hate conditional branches.)<br>&gt; <br>&gt; These things aren&#39;t free. In fact, they may end up costing more than the original optimization did.<br>&gt; <br>&gt;&gt; That’s more an issue of developer laziness more than anything<br>&gt; <br>&gt; I think that your use of the word &quot;laziness&quot; is telling. You are assuming that, if someone doesn&#39;t throw detailed errors, they are being lazy. They are not putting in the work to write good code. They should be judged harshly for this. The language should punish them for their laziness by taking away the tools which allow it.<br>&gt; <br>&gt; But sometimes when you don&#39;t do work, it&#39;s not because you&#39;re being lazy; it&#39;s because that work is *unnecessary*. You could spend time slaving over an enum full of error codes which will just be converted to an optional, or you could just return an optional in the first place and use the time you saved to do something that will actually improve the product in ways your users will value.<br>&gt; <br>&gt; In many simple error handling situations, doing any work beyond indicating success/failure is *unnecessary*. It provides no additional value. We should not hinder the productivity of developers in situations like that simply because sometimes they might misuse the feature permitting it.<br>&gt; <br>&gt;&gt; but at least it’s still communicating that that’s exactly what the error is. If the standard library includes a good set of default errors then that should cover most use-cases; anything that isn’t covered by a standard error meanwhile absolutely should be given a new error type IMO.<br>&gt; <br>&gt; But &quot;invalid parameter&quot; only communicates what&#39;s happening because it&#39;s so vague that almost any error can be called an &quot;invalid parameter&quot;. A malformed path, a path to a file that doesn&#39;t exist, and a path to a file in the wrong format are all &quot;invalid parameters&quot;. I mean, I guess it tells you that the problem isn&#39;t in a property or global or something, but that&#39;s not exactly a surprise, is it?<br>&gt; <br>&gt; Simply throwing &quot;invalid parameter&quot; conveys no *actually useful* information beyond &quot;that wasn&#39;t right&quot;, which is exactly what `?` does.<br>&gt; <br>&gt;&gt;&gt; As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean by this exactly; if you mean that an error should include extra data that can be extracted from the error instance itself then that depends on the error.<br>&gt; <br>&gt; What I&#39;m saying is that *actually* providing errors with enough detail to be useful is hard work. A string typed directly into your source code, addressed to the developer using your API, in one particular language, with the error&#39;s details converted to text and interpolated into it, will not usefully convey the problem. You need to express the problem *programmatically*, and that means carefully cataloguing the causes of errors and deciding for each one how much detail the developer needs.<br>&gt; <br>&gt; To illustrate, I spent ten or fifteen minutes examining IntegerParsing.swift.gyb so I could understand the failure cases of `Int.init(_:radix)`. To fully model all of the errors which can cause it to return `nil`, and without including any redundant information you could get from the string itself, you would probably need this enum:<br>&gt; <br>&gt;    enum IntFromStringError: ErrorType {<br>&gt;        case EmptyString<br>&gt;        case NoDigits<br>&gt;        case NegativeUnsigned<br>&gt;        case TooLarge (at: String.UTF16View.Index)<br>&gt;        case NonDigit (at: String.UTF16View.Index)<br>&gt;        case DigitBeyondRadix (at: String.UTF16View.Index)<br>&gt;    }<br>&gt; <br>&gt; (Note that this does *not* include several errors for invalid radixes which are enforced by preconditions. Evidently, a too-small or too-large radix is considered to be a programmer error.)<br>&gt; <br>&gt; A couple of those cases could probably be collapsed into others; it could be three or four instead of six. But think about all that has happened here:<br>&gt; <br>&gt; • We&#39;ve exposed an implementation detail: the algorithm uses the UTF-16 representation of the string. We could convert the index, but then we would be doing work—I suspect invoking an O(N) algorithm!—purely to provide error information which many users would not need. Similarly, if we ever needed to change the implementation, we would either need to make an incompatible change to the error enum or waste time on a conversion. And if we don&#39;t include an index at all, then we&#39;re not providing enough detail to do anything useful with those errors.<br>&gt; <br>&gt; • We still have not modeled the possible errors with full fidelity, because `NegativeUnsigned` is only possible on a `UInt`. We really ought to have separate enums for `IntFromStringError` and `UIntFromStringError`.<br>&gt; <br>&gt; • We cannot actually promise that these are the only possible errors this can throw. Currently, you can throw any ErrorType from any throwing function. And in the future, resilience will allow later versions of a library to add cases to enums.<br>&gt; <br>&gt; • And we have provided the errors with a level of detail that nearly all callers do not care about. 99.9% of callers will use `try?` and throw away all of this information, so why are we going to so much effort to model it?<br>&gt; <br>&gt; And again, if your answer is &quot;Don&#39;t do all that, just lump everything together into one vague error&quot;, then why are we using the throwing mechanism in the first place? Failable initializers convey one vague error just as well and with much less fuss.<br>&gt; <br>&gt;&gt; If you’re capturing an invalid parameter error then it will be for debugging purposes I think, so the message is for the developer to inform them of which parameter failed (rather than having to have a different error for each parameter) and possibly some info on why, i.e- I’m not talking about text that would be spit out to a user or logged directly (except perhaps as a debug statement), or that you would expect to capture and process extensively. In this case even a simple string should be plenty helpful compared to nothing.<br>&gt; <br>&gt; If an error should only occur during debugging, it should be a precondition, not a failable *or* throwing initializer.<br>&gt; <br>&gt; By definition, any throwable error should be something you expect to happen in the normal course of running the code out in the wild. That means there needs to be enough detail to either automatically fix the problem or usefully present it to a user, either textually or with some kind of graphical representation (like pointing to the invalid character).<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Ultimately, here is my point: When faced with a requirement that all errors be thrown, you get two choices.<br>&gt; <br>&gt; 1. **Throw something super-vague.** This is no better than returning `nil`.<br>&gt; 2. **Throw something really specific and useful.** This requires engineering effort which might be better spent elsewhere.<br>&gt; <br>&gt; Both options waste computer time and programmer time, and they ultimately stem from prejudging how the developer chooses to allocate their time.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 8 Mar 2016, at 01:21, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; A duplicate shouldn’t be necessary; functions/initialisers that can throw just need to be called with a flag indicating whether they should capture or ignore errors as appropriate for try vs try? and try!. Any statement that is identified as being specific to a throw is then wrapped in a conditional based on this flag so it can be skipped if errors are ignored.<br>&gt; <br>&gt; Okay, so you&#39;re passing in what amounts to a new parameter (which is going to take up a register or some stack space that could be used for something else) and adding a new conditional branch at each throw site. In cases where a `try` is nested directly inside a `throws` function, you might need a conditional branch at the return site, too. (Remember, CPUs hate conditional branches.)<br></p><p>It’s a conditional that should only have an impact when an error is being (or about to be) thrown, also I don’t think that a conditional at the call site would be necessary; if you know that try? or try! was used then you know that the flag was passed and that you’ll get no error instance back, just whatever usually passes the error status.<br></p><p>&gt; I think that your use of the word &quot;laziness&quot; is telling. You are assuming that, if someone doesn&#39;t throw detailed errors, they are being lazy.<br></p><p>You’re assuming that every error has to be as detailed as possible ;)<br></p><p>I’m working from the assumption that part of updating the standard library to remove failable initialisers would include creating a set of common errors that developers can use too if they like. For example, yes, InvalidParameterError wouldn’t be super informative (though it at least informs you that the issue was with the parameter itself, and not something else that failed internally), however if there were errors for non-numeric input and such that this could provide extra information. You can certainly argue that it could still provide more information, but if we’re considering all failable initialisers to be “simple” then there will be a point at which you’re providing more information than anyone is actually going to use; a developer can certainly choose to do-so, but ultimately there may still be cases where just knowing that there was an error, or an error of a particular type, is enough.<br></p><p>&gt; To illustrate, I spent ten or fifteen minutes examining IntegerParsing.swift.gyb so I could understand the failure cases of `Int.init(_:radix)`. To fully model all of the errors which can cause it to return `nil`, and without including any redundant information you could get from the string itself, you would probably need this enum:<br>&gt; <br>&gt; 	enum IntFromStringError: ErrorType {<br>&gt; 		case EmptyString<br>&gt; 		case NoDigits<br>&gt; 		case NegativeUnsigned<br>&gt; 		case TooLarge (at: String.UTF16View.Index)<br>&gt; 		case NonDigit (at: String.UTF16View.Index)<br>&gt; 		case DigitBeyondRadix (at: String.UTF16View.Index)<br>&gt; 	}<br>&gt; <br>&gt; if your answer is &quot;Don&#39;t do all that, just lump everything together into one vague error&quot;, then why are we using the throwing mechanism in the first place? Failable initializers convey one vague error just as well and with much less fuss.<br></p><p>My answer would be more along the lines of “just lump everything together into reasonably specific errors”. For example, EmptyString and NoDigits could easily be handled by a general purpose non-numeric error, while the rest could be handled by an integer out of range error of some kind; that should be plenty to communicate the problem, while detail messages could provide further information to the developer if the error is coming up unexpectedly (e.g- from input you thought was safe).<br></p><p>Instead of “something was wrong” you would then have two possibilities for what was wrong, and the potential to get more information if you need it during testing.<br></p><p>&gt; If an error should only occur during debugging, it should be a precondition, not a failable *or* throwing initializer.<br>&gt; <br>&gt; By definition, any throwable error should be something you expect to happen in the normal course of running the code out in the wild. That means there needs to be enough detail to either automatically fix the problem or usefully present it to a user, either textually or with some kind of graphical representation (like pointing to the invalid character).<br></p><p>Not quite what I meant; I would absolutely expect the error to occur in the wild, and be caught or ignored as appropriate, the message is just for cases where you’re not sure why it’s occurred in the first place, i.e- the error (and its type) is often enough all you need in simpler error cases, but if you’re getting them unexpectedly rather than due to anticipated mistakes in input etc. then you may want the extra detail. You certainly could model it for programmatic inspection and that’s an option too, but it may not be necessary.<br></p><p>Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground. In other words, the work you put in should absolutely reflect some kind of value, but you seem to be assuming that the maximum possible amount of work has to be put into every error type thrown, where I think that most simple errors can be adequately modelled from a decent set of default error types; anything more complex absolutely should go into more detail as appropriate, but again they don’t necessarily have to expose the most minute of details.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>Interestingly what Haravikk describes is mentioned here.<br></p><p>http://ericasadun.com/2015/08/27/capturing-context-swiftlang/<br></p><p>This approach is very similar to Rubys<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Tue, Mar 8, 2016 at 10:07 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 8 Mar 2016, at 01:21, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; A duplicate shouldn’t be necessary; functions/initialisers that can<br>&gt; throw just need to be called with a flag indicating whether they should<br>&gt; capture or ignore errors as appropriate for try vs try? and try!. Any<br>&gt; statement that is identified as being specific to a throw is then wrapped<br>&gt; in a conditional based on this flag so it can be skipped if errors are<br>&gt; ignored.<br>&gt; &gt;<br>&gt; &gt; Okay, so you&#39;re passing in what amounts to a new parameter (which is<br>&gt; going to take up a register or some stack space that could be used for<br>&gt; something else) and adding a new conditional branch at each throw site. In<br>&gt; cases where a `try` is nested directly inside a `throws` function, you<br>&gt; might need a conditional branch at the return site, too. (Remember, CPUs<br>&gt; hate conditional branches.)<br>&gt;<br>&gt; It’s a conditional that should only have an impact when an error is being<br>&gt; (or about to be) thrown, also I don’t think that a conditional at the call<br>&gt; site would be necessary; if you know that try? or try! was used then you<br>&gt; know that the flag was passed and that you’ll get no error instance back,<br>&gt; just whatever usually passes the error status.<br>&gt;<br>&gt; &gt; I think that your use of the word &quot;laziness&quot; is telling. You are<br>&gt; assuming that, if someone doesn&#39;t throw detailed errors, they are being<br>&gt; lazy.<br>&gt;<br>&gt; You’re assuming that every error has to be as detailed as possible ;)<br>&gt;<br>&gt; I’m working from the assumption that part of updating the standard library<br>&gt; to remove failable initialisers would include creating a set of common<br>&gt; errors that developers can use too if they like. For example, yes,<br>&gt; InvalidParameterError wouldn’t be super informative (though it at least<br>&gt; informs you that the issue was with the parameter itself, and not something<br>&gt; else that failed internally), however if there were errors for non-numeric<br>&gt; input and such that this could provide extra information. You can certainly<br>&gt; argue that it could still provide more information, but if we’re<br>&gt; considering all failable initialisers to be “simple” then there will be a<br>&gt; point at which you’re providing more information than anyone is actually<br>&gt; going to use; a developer can certainly choose to do-so, but ultimately<br>&gt; there may still be cases where just knowing that there was an error, or an<br>&gt; error of a particular type, is enough.<br>&gt;<br>&gt; &gt; To illustrate, I spent ten or fifteen minutes examining<br>&gt; IntegerParsing.swift.gyb so I could understand the failure cases of<br>&gt; `Int.init(_:radix)`. To fully model all of the errors which can cause it to<br>&gt; return `nil`, and without including any redundant information you could get<br>&gt; from the string itself, you would probably need this enum:<br>&gt; &gt;<br>&gt; &gt;       enum IntFromStringError: ErrorType {<br>&gt; &gt;               case EmptyString<br>&gt; &gt;               case NoDigits<br>&gt; &gt;               case NegativeUnsigned<br>&gt; &gt;               case TooLarge (at: String.UTF16View.Index)<br>&gt; &gt;               case NonDigit (at: String.UTF16View.Index)<br>&gt; &gt;               case DigitBeyondRadix (at: String.UTF16View.Index)<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; if your answer is &quot;Don&#39;t do all that, just lump everything together into<br>&gt; one vague error&quot;, then why are we using the throwing mechanism in the first<br>&gt; place? Failable initializers convey one vague error just as well and with<br>&gt; much less fuss.<br>&gt;<br>&gt; My answer would be more along the lines of “just lump everything together<br>&gt; into reasonably specific errors”. For example, EmptyString and NoDigits<br>&gt; could easily be handled by a general purpose non-numeric error, while the<br>&gt; rest could be handled by an integer out of range error of some kind; that<br>&gt; should be plenty to communicate the problem, while detail messages could<br>&gt; provide further information to the developer if the error is coming up<br>&gt; unexpectedly (e.g- from input you thought was safe).<br>&gt;<br>&gt; Instead of “something was wrong” you would then have two possibilities for<br>&gt; what was wrong, and the potential to get more information if you need it<br>&gt; during testing.<br>&gt;<br>&gt; &gt; If an error should only occur during debugging, it should be a<br>&gt; precondition, not a failable *or* throwing initializer.<br>&gt; &gt;<br>&gt; &gt; By definition, any throwable error should be something you expect to<br>&gt; happen in the normal course of running the code out in the wild. That means<br>&gt; there needs to be enough detail to either automatically fix the problem or<br>&gt; usefully present it to a user, either textually or with some kind of<br>&gt; graphical representation (like pointing to the invalid character).<br>&gt;<br>&gt; Not quite what I meant; I would absolutely expect the error to occur in<br>&gt; the wild, and be caught or ignored as appropriate, the message is just for<br>&gt; cases where you’re not sure why it’s occurred in the first place, i.e- the<br>&gt; error (and its type) is often enough all you need in simpler error cases,<br>&gt; but if you’re getting them unexpectedly rather than due to anticipated<br>&gt; mistakes in input etc. then you may want the extra detail. You certainly<br>&gt; could model it for programmatic inspection and that’s an option too, but it<br>&gt; may not be necessary.<br>&gt;<br>&gt; Just because someone opts to use error handling over a failable<br>&gt; initialiser doesn’t mean they have to go overboard on the detail of their<br>&gt; errors; it’s entirely possible to pick a reasonable middle-ground. In other<br>&gt; words, the work you put in should absolutely reflect some kind of value,<br>&gt; but you seem to be assuming that the maximum possible amount of work has to<br>&gt; be put into every error type thrown, where I think that most simple errors<br>&gt; can be adequately modelled from a decent set of default error types;<br>&gt; anything more complex absolutely should go into more detail as appropriate,<br>&gt; but again they don’t necessarily have to expose the most minute of details.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/f8196511/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground.<br></p><p>And it is entitely possible to just use an optional. If you prefer to use error handling over failable initializers, fine, just do so, but don&#39;t force it on others who are perfectly happy with the option to use optionals, too.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Failable initializers are great when you don&#39;t care what kind of error<br>happened and can handle it locally and the same way for any error (for<br>example by skipping an element).<br></p><p>I&#39;d be very sad to lose them.<br>On Tue, Mar 8, 2016 at 10:26 AM Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Just because someone opts to use error handling over a failable<br>&gt; initialiser doesn’t mean they have to go overboard on the detail of their<br>&gt; errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;<br>&gt; And it is entitely possible to just use an optional. If you prefer to use<br>&gt; error handling over failable initializers, fine, just do so, but don&#39;t<br>&gt; force it on others who are perfectly happy with the option to use<br>&gt; optionals, too.<br>&gt;<br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/0b89b771/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Or when you’re writing a bit of genericish code where the function in question doesn’t need to care if the init worked or not.<br>&gt; On Mar 8, 2016, at 09:56, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Failable initializers are great when you don&#39;t care what kind of error happened and can handle it locally and the same way for any error (for example by skipping an element).<br>&gt; <br>&gt; I&#39;d be very sad to lose them.<br>&gt; On Tue, Mar 8, 2016 at 10:26 AM Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt; <br>&gt; And it is entitely possible to just use an optional. If you prefer to use error handling over failable initializers, fine, just do so, but don&#39;t force it on others who are perfectly happy with the option to use optionals, too.<br>&gt; <br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/3603aa05/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt; <br>&gt; And it is entitely possible to just use an optional. If you prefer to use error handling over failable initializers, fine, just do so, but don&#39;t force it on others who are perfectly happy with the option to use optionals, too.<br></p><p>It’s not an issue of ideology but of redundancy; the failable initialiser does nothing that error handling can’t do just as easily, the only difference is that instead of returning nil, you throw an appropriate error.<br></p><p>The few extra characters are hardly going to kill you, while a thrown error (with common ones available for simplicity) can describe what went wrong in more detail than just “something went wrong”. Point is that we have two ways of achieving the same goal, but error handling encourages developers to think more about what type(s) of error to throw at each point; even just simple error types with no further detail can provide more information simply by being different, for example if you have a NonNumericError vs EmptyStringError types, the errors themselves tell you all you’re likely to need to know (hopefully there’d be a good set of common types).<br></p><p>There are also some cases where failable initialisers can have subtle errors, for example, can you tell me where I might run into problems with the following:<br></p><p>struct MyType {<br>    let elements:[String]<br></p><p>    func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>        if self.elements.indices.contains(index) {<br>            return Int(self.elements[index])<br>        }<br>        return nil<br>    }<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/efb996c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>If the argument is that taking away &quot;init?()&quot; is going to force Swift users<br>to embrace the One True Path of Error Handling, I don&#39;t think that&#39;s going<br>to happen. The more likely outcome is that people are going to wrap<br>throwable initializers in factory methods returning optionals, and throw<br>away whatever error returns.<br></p><p>Not that this is a bad thing, mind you. In a lot of cases my application<br>does not care why an operation failed, only that it did. This isn&#39;t because<br>I&#39;m lazy, but because the recovery path for each potential type of error is<br>exactly the same. In this case I don&#39;t care about which error was thrown,<br>but I often do care about the ability to compose I get from nil.<br></p><p>As for the sample code, there is absolutely nothing wrong with it IMO. The<br>contract to me for &#39;asInt&#39; reads &quot;return an Int if an item exists at<br>`index` and, if that item exists, it can be represented as an Int&quot;. I think<br>it&#39;s instructional to look at how Dictionary&lt;T?&gt; works - if you try to<br>extract an element you get a double optional. This isn&#39;t a type system bug,<br>it&#39;s completely intentional. The internal optional indicates whether an<br>extant element was Some or None, and the external optional indicates<br>whether or not the element existed in the dictionary to begin with. If I<br>were writing that `asInt` function and I really needed to make the<br>distinction between &quot;invalid index&quot; and &quot;not an integer string&quot;, I&#39;d use<br>either that same double optional pattern, or make the function throws. If I<br>didn&#39;t care, I&#39;d use the optional representation.<br></p><p>Best,<br>Austin<br></p><p>On Tue, Mar 8, 2016 at 1:09 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Just because someone opts to use error handling over a failable<br>&gt; initialiser doesn’t mean they have to go overboard on the detail of their<br>&gt; errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;<br>&gt;<br>&gt; And it is entitely possible to just use an optional. If you prefer to use<br>&gt; error handling over failable initializers, fine, just do so, but don&#39;t<br>&gt; force it on others who are perfectly happy with the option to use<br>&gt; optionals, too.<br>&gt;<br>&gt;<br>&gt; It’s not an issue of ideology but of redundancy; the failable initialiser<br>&gt; does nothing that error handling can’t do just as easily, the only<br>&gt; difference is that instead of returning nil, you throw an appropriate error.<br>&gt;<br>&gt; The few extra characters are hardly going to kill you, while a thrown<br>&gt; error (with common ones available for simplicity) can describe what went<br>&gt; wrong in more detail than just “something went wrong”. Point is that we<br>&gt; have two ways of achieving the same goal, but error handling encourages<br>&gt; developers to think more about what type(s) of error to throw at each<br>&gt; point; even just simple error types with no further detail can provide more<br>&gt; information simply by being different, for example if you have a<br>&gt; NonNumericError vs EmptyStringError types, the errors themselves tell you<br>&gt; all you’re likely to need to know (hopefully there’d be a good set of<br>&gt; common types).<br>&gt;<br>&gt; There are also some cases where failable initialisers can have subtle<br>&gt; errors, for example, can you tell me where I might run into problems with<br>&gt; the following:<br>&gt;<br>&gt; struct MyType {<br>&gt;     let elements:[String]<br>&gt;<br>&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;         if self.elements.indices.contains(index) {<br>&gt;             return Int(self.elements[index])<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/561d64fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 8 Mar 2016, at 21:49, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; The more likely outcome is that people are going to wrap throwable initializers in factory methods returning optionals, and throw away whatever error returns.<br></p><p>I hope not, seeing as try? lets you explicitly ignore the error if you only need to know that an error occurred (vs what it actually was). The key difference here is that it’s explicit, and you have to choose how you’re going to handle it. This is one of the big arguments for error handling vs failable, as both model errors, but error handling forces you to be explicit about what you’re doing about them, even if it’s nothing.<br></p><p>&gt; As for the sample code, there is absolutely nothing wrong with it IMO. The contract to me for &#39;asInt&#39; reads &quot;return an Int if an item exists at `index` and, if that item exists, it can be represented as an Int”.<br></p><p>That&#39;s an assumption; MyType actually expects to only contain valid numeric strings, and I’ve simply forgotten to add a force unwrap on the Int() initialiser, now suddenly my method is returning nil for indices that exist but were supplied incorrectly. With error handling I’m required to pick one of try, try? and try! to decide which suits my needs, in which case I’d put try!. The throws would also clarify that `nil` never indicates an error.<br></p><p>That said, I just realised it’s a poor example because the method shouldn’t return nil if it’s given an invalid index, rather it shouldn’t be given invalid indices in the first place (this would be in keeping with other methods in Array for example), but it’s just an over simplified example to make the point; the possible nil return from the initialiser is accidental.<br></p><p>&gt; struct MyType {<br>&gt;     let elements:[String]<br>&gt; <br>&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;         if self.elements.indices.contains(index) {<br>&gt;             return Int(self.elements[index])<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br></p><p>&gt; I think it&#39;s instructional to look at how Dictionary&lt;T?&gt; works - if you try to extract an element you get a double optional. This isn&#39;t a type system bug, it&#39;s completely intentional. The internal optional indicates whether an extant element was Some or None, and the external optional indicates whether or not the element existed in the dictionary to begin with. If I were writing that `asInt` function and I really needed to make the distinction between &quot;invalid index&quot; and &quot;not an integer string&quot;, I&#39;d use either that same double optional pattern, or make the function throws. If I didn&#39;t care, I&#39;d use the optional representation.<br></p><p>Double optional to me indicates a difference between a return value of “nothing” (didn’t exist) and “stored value was nil”, I’d be very wary about using that to replace errors.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/47272071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>The fact that I&#39;m assigning the result of a failable initializer to a<br>variable of optional type should be clear enough indication that I only<br>care about whether or not an error occurred. In my experience, it is very<br>difficult to accidentally define a T? in place of a T if you intend to use<br>the variable after initialization/assignment, even with type inference.<br></p><p>That being said, my comment was more towards programmer inclination, as<br>opposed to what programmers should be doing. The same issue came up with<br>checked exceptions, where they were considered so much of a burden that<br>programmers just caught everything instead of handling them correctly.<br>(Although, to be fair, I don&#39;t think this would be nearly as much of a<br>sticking point.)<br></p><p>I do like the idea proposed in the alternatives section, that a failable<br>initializer should be denoted as such at the call site (e.g. let a : Int? =<br>Int?(string: &quot;blah&quot;)).<br></p><p>Austin<br></p><p>On Tue, Mar 8, 2016 at 2:19 PM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On 8 Mar 2016, at 21:49, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; The more likely outcome is that people are going to wrap throwable<br>&gt; initializers in factory methods returning optionals, and throw away<br>&gt; whatever error returns.<br>&gt;<br>&gt;<br>&gt; I hope not, seeing as try? lets you explicitly ignore the error if you<br>&gt; only need to know that an error occurred (vs what it actually was). The key<br>&gt; difference here is that it’s explicit, and you have to choose how you’re<br>&gt; going to handle it. This is one of the big arguments for error handling vs<br>&gt; failable, as both model errors, but error handling forces you to be<br>&gt; explicit about what you’re doing about them, even if it’s nothing.<br>&gt;<br>&gt; As for the sample code, there is absolutely nothing wrong with it IMO. The<br>&gt; contract to me for &#39;asInt&#39; reads &quot;return an Int if an item exists at<br>&gt; `index` and, if that item exists, it can be represented as an Int”.<br>&gt;<br>&gt;<br>&gt; That&#39;s an assumption; MyType actually expects to only contain valid<br>&gt; numeric strings, and I’ve simply forgotten to add a force unwrap on the<br>&gt; Int() initialiser, now suddenly my method is returning nil for indices that<br>&gt; exist but were supplied incorrectly. With error handling I’m required to<br>&gt; pick one of try, try? and try! to decide which suits my needs, in which<br>&gt; case I’d put try!. The throws would also clarify that `nil` never indicates<br>&gt; an error.<br>&gt;<br>&gt; That said, I just realised it’s a poor example because the method<br>&gt; shouldn’t return nil if it’s given an invalid index, rather it shouldn’t be<br>&gt; given invalid indices in the first place (this would be in keeping with<br>&gt; other methods in Array for example), but it’s just an over simplified<br>&gt; example to make the point; the possible nil return from the initialiser is<br>&gt; accidental.<br>&gt;<br>&gt; struct MyType {<br>&gt;&gt;     let elements:[String]<br>&gt;&gt;<br>&gt;&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;&gt;         if self.elements.indices.contains(index) {<br>&gt;&gt;             return Int(self.elements[index])<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;<br>&gt; I think it&#39;s instructional to look at how Dictionary&lt;T?&gt; works - if you<br>&gt; try to extract an element you get a double optional. This isn&#39;t a type<br>&gt; system bug, it&#39;s completely intentional. The internal optional indicates<br>&gt; whether an extant element was Some or None, and the external optional<br>&gt; indicates whether or not the element existed in the dictionary to begin<br>&gt; with. If I were writing that `asInt` function and I really needed to make<br>&gt; the distinction between &quot;invalid index&quot; and &quot;not an integer string&quot;, I&#39;d<br>&gt; use either that same double optional pattern, or make the function throws.<br>&gt; If I didn&#39;t care, I&#39;d use the optional representation.<br>&gt;<br>&gt;<br>&gt; Double optional to me indicates a difference between a return value of<br>&gt; “nothing” (didn’t exist) and “stored value was nil”, I’d be very wary about<br>&gt; using that to replace errors.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/c8b87d4b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March  8, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016 at 1:19 PM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Just because someone opts to use error handling over a failable<br>&gt; initialiser doesn’t mean they have to go overboard on the detail of their<br>&gt; errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;<br>&gt;<br>&gt; And it is entitely possible to just use an optional. If you prefer to use<br>&gt; error handling over failable initializers, fine, just do so, but don&#39;t<br>&gt; force it on others who are perfectly happy with the option to use<br>&gt; optionals, too.<br>&gt;<br>&gt;<br>&gt; It’s not an issue of ideology but of redundancy; the failable initialiser<br>&gt; does nothing that error handling can’t do just as easily, the only<br>&gt; difference is that instead of returning nil, you throw an appropriate error.<br>&gt;<br>&gt; The few extra characters are hardly going to kill you, while a thrown<br>&gt; error (with common ones available for simplicity) can describe what went<br>&gt; wrong in more detail than just “something went wrong”. Point is that we<br>&gt; have two ways of achieving the same goal, but error handling encourages<br>&gt; developers to think more about what type(s) of error to throw at each<br>&gt; point; even just simple error types with no further detail can provide more<br>&gt; information simply by being different, for example if you have a<br>&gt; NonNumericError vs EmptyStringError types, the errors themselves tell you<br>&gt; all you’re likely to need to know (hopefully there’d be a good set of<br>&gt; common types).<br>&gt;<br>&gt; There are also some cases where failable initialisers can have subtle<br>&gt; errors, for example, can you tell me where I might run into problems with<br>&gt; the following:<br>&gt;<br>&gt; struct MyType {<br>&gt;     let elements:[String]<br>&gt;<br>&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;         if self.elements.indices.contains(index) {<br>&gt;             return Int(self.elements[index])<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt;<br></p><p>I assume you mean to imply the following...?<br></p><p>let foo = MyType(elements: [&quot;1&quot;, &quot;2&quot;, &quot;bogus&quot;, &quot;4&quot;])<br>for i in 0..&lt;5 {<br>  if let value = foo.asInt(i) {<br>    print( &quot;Value[\(i)] = \(value)&quot; )<br>  }<br>  else {<br>    print( &quot;Value[\(i)] = &lt;no value&gt;&quot; )<br>  }<br>}<br></p><p>Value[0] = 1<br>Value[1] = 2<br>Value[2] = &lt;no value&gt;<br>Value[3] = 4<br>Value[4] = &lt;no value&gt;<br></p><p>When I see asInt(index) -&gt; Int? I personally would only care about getting<br>an Int back if possible for the given index then going on my merry way. If<br>I was confused by something I would debug the problem. I likely wouldn&#39;t<br>attempt to put any code in place to pick apart how it could have failed. If<br>anything I would put in preconditions.<br></p><p>If this API threw exceptions instead I would do that exact same thing.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/480c0f46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March  8, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016 at 2:11 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Mar 8, 2016 at 1:19 PM Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Just because someone opts to use error handling over a failable<br>&gt;&gt; initialiser doesn’t mean they have to go overboard on the detail of their<br>&gt;&gt; errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And it is entitely possible to just use an optional. If you prefer to use<br>&gt;&gt; error handling over failable initializers, fine, just do so, but don&#39;t<br>&gt;&gt; force it on others who are perfectly happy with the option to use<br>&gt;&gt; optionals, too.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s not an issue of ideology but of redundancy; the failable initialiser<br>&gt;&gt; does nothing that error handling can’t do just as easily, the only<br>&gt;&gt; difference is that instead of returning nil, you throw an appropriate error.<br>&gt;&gt;<br>&gt;&gt; The few extra characters are hardly going to kill you, while a thrown<br>&gt;&gt; error (with common ones available for simplicity) can describe what went<br>&gt;&gt; wrong in more detail than just “something went wrong”. Point is that we<br>&gt;&gt; have two ways of achieving the same goal, but error handling encourages<br>&gt;&gt; developers to think more about what type(s) of error to throw at each<br>&gt;&gt; point; even just simple error types with no further detail can provide more<br>&gt;&gt; information simply by being different, for example if you have a<br>&gt;&gt; NonNumericError vs EmptyStringError types, the errors themselves tell you<br>&gt;&gt; all you’re likely to need to know (hopefully there’d be a good set of<br>&gt;&gt; common types).<br>&gt;&gt;<br>&gt;&gt; There are also some cases where failable initialisers can have subtle<br>&gt;&gt; errors, for example, can you tell me where I might run into problems with<br>&gt;&gt; the following:<br>&gt;&gt;<br>&gt;&gt; struct MyType {<br>&gt;&gt;     let elements:[String]<br>&gt;&gt;<br>&gt;&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;&gt;         if self.elements.indices.contains(index) {<br>&gt;&gt;             return Int(self.elements[index])<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;<br>&gt; I assume you mean to imply the following...?<br>&gt;<br>&gt; let foo = MyType(elements: [&quot;1&quot;, &quot;2&quot;, &quot;bogus&quot;, &quot;4&quot;])<br>&gt; for i in 0..&lt;5 {<br>&gt;   if let value = foo.asInt(i) {<br>&gt;     print( &quot;Value[\(i)] = \(value)&quot; )<br>&gt;   }<br>&gt;   else {<br>&gt;     print( &quot;Value[\(i)] = &lt;no value&gt;&quot; )<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Value[0] = 1<br>&gt; Value[1] = 2<br>&gt; Value[2] = &lt;no value&gt;<br>&gt; Value[3] = 4<br>&gt; Value[4] = &lt;no value&gt;<br>&gt;<br>&gt; When I see asInt(index) -&gt; Int? I personally would only care about getting<br>&gt; an Int back if possible for the given index then going on my merry way. If<br>&gt; I was confused by something I would debug the problem. I likely wouldn&#39;t<br>&gt; attempt to put any code in place to pick apart how it could have failed. If<br>&gt; anything I would put in preconditions.<br>&gt;<br>&gt; If this API threw exceptions instead I would do that exact same thing.<br>&gt;<br></p><p>I meant to also state I would design the API the following way since to me<br>a bad index is a logic bug that needs to fixed in the code.<br></p><p>struct MyType {<br>    let elements:[String]<br>    func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>        return Int(self.elements[index])<br>    }<br>}<br></p><p>let foo = MyType(elements: [&quot;1&quot;, &quot;2&quot;, &quot;bogus&quot;, &quot;4&quot;])<br>for i in 0..&lt;5 {<br>  if let value = foo.asInt(i) {<br>    print( &quot;Value[\(i)] = \(value)&quot; )<br>  }<br>  else {<br>    print( &quot;Value[\(i)] = &lt;no value&gt;&quot; )<br>  }<br>}<br></p><p>Value[0] = 1<br>Value[1] = 2<br>Value[2] = &lt;no value&gt;<br>Value[3] = 4<br>fatal error: Array index out of range<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/74fe2aed/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 1:09 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;&gt; <br>&gt;&gt; And it is entitely possible to just use an optional. If you prefer to use error handling over failable initializers, fine, just do so, but don&#39;t force it on others who are perfectly happy with the option to use optionals, too.<br>&gt; <br>&gt; It’s not an issue of ideology but of redundancy; the failable initialiser does nothing that error handling can’t do just as easily, the only difference is that instead of returning nil, you throw an appropriate error.<br></p><p>Are you proposing removing both “init?” and “init!” or just the former?<br></p><p>-Chris<br></p><p>&gt; <br>&gt; The few extra characters are hardly going to kill you, while a thrown error (with common ones available for simplicity) can describe what went wrong in more detail than just “something went wrong”. Point is that we have two ways of achieving the same goal, but error handling encourages developers to think more about what type(s) of error to throw at each point; even just simple error types with no further detail can provide more information simply by being different, for example if you have a NonNumericError vs EmptyStringError types, the errors themselves tell you all you’re likely to need to know (hopefully there’d be a good set of common types).<br>&gt; <br>&gt; There are also some cases where failable initialisers can have subtle errors, for example, can you tell me where I might run into problems with the following:<br>&gt; <br>&gt; struct MyType {<br>&gt;     let elements:[String]<br>&gt; <br>&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;         if self.elements.indices.contains(index) {<br>&gt;             return Int(self.elements[index])<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/3ebebf43/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  9, 2016 at 07:00:00am</p></header><div class="content"><p>Brent already wrote a lengthy mail explaining why the overhead of having to define errors is not &quot;some keystrokes&quot;.<br>Let me add to that the following: <br>If I have a simple case where I just want to skip failed initializations the errors won&#39;t help me anything in unexpected cases because I disregarded them anyway. And when I&#39;m debugging unexpected cases then I will look at the arguments and the control flow and will have the same information an error would have given me. And simple errors or &quot;middle ground&quot; errors won&#39;t help me either.<br>On top of that I don&#39;t think that creating all those errors, possibly with non trivial algorithms like Brent explained, can be easily optimized away.<br></p><p>I don&#39;t think that redundancy is a problem here as it is only a partial overlap of functionality with different properties which both have their use. <br></p><p>-Thorsten <br></p><p>&gt; Am 08.03.2016 um 22:09 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 8 Mar 2016, at 15:26, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 08.03.2016 um 11:07 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just because someone opts to use error handling over a failable initialiser doesn’t mean they have to go overboard on the detail of their errors; it’s entirely possible to pick a reasonable middle-ground.<br>&gt;&gt; <br>&gt;&gt; And it is entitely possible to just use an optional. If you prefer to use error handling over failable initializers, fine, just do so, but don&#39;t force it on others who are perfectly happy with the option to use optionals, too.<br>&gt; <br>&gt; It’s not an issue of ideology but of redundancy; the failable initialiser does nothing that error handling can’t do just as easily, the only difference is that instead of returning nil, you throw an appropriate error.<br>&gt; <br>&gt; The few extra characters are hardly going to kill you, while a thrown error (with common ones available for simplicity) can describe what went wrong in more detail than just “something went wrong”. Point is that we have two ways of achieving the same goal, but error handling encourages developers to think more about what type(s) of error to throw at each point; even just simple error types with no further detail can provide more information simply by being different, for example if you have a NonNumericError vs EmptyStringError types, the errors themselves tell you all you’re likely to need to know (hopefully there’d be a good set of common types).<br>&gt; <br>&gt; There are also some cases where failable initialisers can have subtle errors, for example, can you tell me where I might run into problems with the following:<br>&gt; <br>&gt; struct MyType {<br>&gt;     let elements:[String]<br>&gt; <br>&gt;     func asInt(index:Array&lt;String&gt;.Index) -&gt; Int? {<br>&gt;         if self.elements.indices.contains(index) {<br>&gt;             return Int(self.elements[index])<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/a50412b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Well put!<br></p><p>+1 to everything Brent said!<br></p><p>-Thorsten <br></p><p><br>Am 08.03.2016 um 02:21 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; A duplicate shouldn’t be necessary; functions/initialisers that can throw just need to be called with a flag indicating whether they should capture or ignore errors as appropriate for try vs try? and try!. Any statement that is identified as being specific to a throw is then wrapped in a conditional based on this flag so it can be skipped if errors are ignored.<br>&gt; <br>&gt; Okay, so you&#39;re passing in what amounts to a new parameter (which is going to take up a register or some stack space that could be used for something else) and adding a new conditional branch at each throw site. In cases where a `try` is nested directly inside a `throws` function, you might need a conditional branch at the return site, too. (Remember, CPUs hate conditional branches.)<br>&gt; <br>&gt; These things aren&#39;t free. In fact, they may end up costing more than the original optimization did.<br>&gt; <br>&gt;&gt; That’s more an issue of developer laziness more than anything<br>&gt; <br>&gt; I think that your use of the word &quot;laziness&quot; is telling. You are assuming that, if someone doesn&#39;t throw detailed errors, they are being lazy. They are not putting in the work to write good code. They should be judged harshly for this. The language should punish them for their laziness by taking away the tools which allow it.<br>&gt; <br>&gt; But sometimes when you don&#39;t do work, it&#39;s not because you&#39;re being lazy; it&#39;s because that work is *unnecessary*. You could spend time slaving over an enum full of error codes which will just be converted to an optional, or you could just return an optional in the first place and use the time you saved to do something that will actually improve the product in ways your users will value.<br>&gt; <br>&gt; In many simple error handling situations, doing any work beyond indicating success/failure is *unnecessary*. It provides no additional value. We should not hinder the productivity of developers in situations like that simply because sometimes they might misuse the feature permitting it.<br>&gt; <br>&gt;&gt; but at least it’s still communicating that that’s exactly what the error is. If the standard library includes a good set of default errors then that should cover most use-cases; anything that isn’t covered by a standard error meanwhile absolutely should be given a new error type IMO.<br>&gt; <br>&gt; But &quot;invalid parameter&quot; only communicates what&#39;s happening because it&#39;s so vague that almost any error can be called an &quot;invalid parameter&quot;. A malformed path, a path to a file that doesn&#39;t exist, and a path to a file in the wrong format are all &quot;invalid parameters&quot;. I mean, I guess it tells you that the problem isn&#39;t in a property or global or something, but that&#39;s not exactly a surprise, is it?<br>&gt; <br>&gt; Simply throwing &quot;invalid parameter&quot; conveys no *actually useful* information beyond &quot;that wasn&#39;t right&quot;, which is exactly what `?` does.<br>&gt; <br>&gt;&gt;&gt; As an aside, I hope you realize that adding a human-readable string is *not helpful*. Without a machine-readable representation, the error cannot be expressed in domain-specific terms (&quot;The ID number included an &#39;o&#39;; did you mean &#39;0&#39;?&quot;) or even easily localized.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean by this exactly; if you mean that an error should include extra data that can be extracted from the error instance itself then that depends on the error.<br>&gt; <br>&gt; What I&#39;m saying is that *actually* providing errors with enough detail to be useful is hard work. A string typed directly into your source code, addressed to the developer using your API, in one particular language, with the error&#39;s details converted to text and interpolated into it, will not usefully convey the problem. You need to express the problem *programmatically*, and that means carefully cataloguing the causes of errors and deciding for each one how much detail the developer needs.<br>&gt; <br>&gt; To illustrate, I spent ten or fifteen minutes examining IntegerParsing.swift.gyb so I could understand the failure cases of `Int.init(_:radix)`. To fully model all of the errors which can cause it to return `nil`, and without including any redundant information you could get from the string itself, you would probably need this enum:<br>&gt; <br>&gt;    enum IntFromStringError: ErrorType {<br>&gt;        case EmptyString<br>&gt;        case NoDigits<br>&gt;        case NegativeUnsigned<br>&gt;        case TooLarge (at: String.UTF16View.Index)<br>&gt;        case NonDigit (at: String.UTF16View.Index)<br>&gt;        case DigitBeyondRadix (at: String.UTF16View.Index)<br>&gt;    }<br>&gt; <br>&gt; (Note that this does *not* include several errors for invalid radixes which are enforced by preconditions. Evidently, a too-small or too-large radix is considered to be a programmer error.)<br>&gt; <br>&gt; A couple of those cases could probably be collapsed into others; it could be three or four instead of six. But think about all that has happened here:<br>&gt; <br>&gt; • We&#39;ve exposed an implementation detail: the algorithm uses the UTF-16 representation of the string. We could convert the index, but then we would be doing work—I suspect invoking an O(N) algorithm!—purely to provide error information which many users would not need. Similarly, if we ever needed to change the implementation, we would either need to make an incompatible change to the error enum or waste time on a conversion. And if we don&#39;t include an index at all, then we&#39;re not providing enough detail to do anything useful with those errors.<br>&gt; <br>&gt; • We still have not modeled the possible errors with full fidelity, because `NegativeUnsigned` is only possible on a `UInt`. We really ought to have separate enums for `IntFromStringError` and `UIntFromStringError`.<br>&gt; <br>&gt; • We cannot actually promise that these are the only possible errors this can throw. Currently, you can throw any ErrorType from any throwing function. And in the future, resilience will allow later versions of a library to add cases to enums.<br>&gt; <br>&gt; • And we have provided the errors with a level of detail that nearly all callers do not care about. 99.9% of callers will use `try?` and throw away all of this information, so why are we going to so much effort to model it?<br>&gt; <br>&gt; And again, if your answer is &quot;Don&#39;t do all that, just lump everything together into one vague error&quot;, then why are we using the throwing mechanism in the first place? Failable initializers convey one vague error just as well and with much less fuss.<br>&gt; <br>&gt;&gt; If you’re capturing an invalid parameter error then it will be for debugging purposes I think, so the message is for the developer to inform them of which parameter failed (rather than having to have a different error for each parameter) and possibly some info on why, i.e- I’m not talking about text that would be spit out to a user or logged directly (except perhaps as a debug statement), or that you would expect to capture and process extensively. In this case even a simple string should be plenty helpful compared to nothing.<br>&gt; <br>&gt; If an error should only occur during debugging, it should be a precondition, not a failable *or* throwing initializer.<br>&gt; <br>&gt; By definition, any throwable error should be something you expect to happen in the normal course of running the code out in the wild. That means there needs to be enough detail to either automatically fix the problem or usefully present it to a user, either textually or with some kind of graphical representation (like pointing to the invalid character).<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Ultimately, here is my point: When faced with a requirement that all errors be thrown, you get two choices.<br>&gt; <br>&gt; 1. **Throw something super-vague.** This is no better than returning `nil`.<br>&gt; 2. **Throw something really specific and useful.** This requires engineering effort which might be better spent elsewhere.<br>&gt; <br>&gt; Both options waste computer time and programmer time, and they ultimately stem from prejudging how the developer chooses to allocate their time.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March  4, 2016 at 10:00:00pm</p></header><div class="content"><p>I prefer `try? Int(someString)` over `Int(someString)`.<br></p><p>   - There&#39;s visually nothing to indicate that `Int(someString)` could fail.<br>   - It simplifies the language to not have failable initialisers.<br></p><p>InvalidArgument could be part of the standard library, something like this:<br></p><p>struct InvalidArgument: ErrorType {}<br></p><p><br>Brent makes a good point:<br></p><p>&quot;40 bytes for a protocol witness, instead of 0-1 bytes for the overhead of<br>an Optional&quot;.<br></p><p><br>I wonder if it a typed throw would have similar overhead to an optional,<br>possibly less if the throw only has an overhead if it is thrown<br>&lt;http://llvm.org/docs/ExceptionHandling.html#itanium-abi-zero-cost-exception-handling&gt;<br>:<br></p><p>init (_ fromString: String) throws(InvalidArgument)<br></p><p><br>I don&#39;t know what happened to the proposal to allow throws to specify zero<br>or one type. I&#39;m reluctant to use throws in general without that proposal.<br></p><p><br>On Fri, Mar 4, 2016 at 9:27 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; The guidance is that returning nil is appropriate when your function<br>&gt; could fail due to simple domain errors, for instance passing a negative<br>&gt; value as a parameter where they aren&#39;t allowed.<br>&gt; &gt;<br>&gt; &gt; If that’s all you need then what’s wrong with throwing some generic<br>&gt; purpose illegal argument type exception and using try? It’s functionally<br>&gt; the same, i.e- removing failable initialisers doesn’t actually remove a<br>&gt; capability, it just removes what is essentially now a redundant one. In<br>&gt; other words, try? on a throwable initialiser is now functionally identical<br>&gt; to a failable initialiser and isn&#39;t appreciably more complex, especially if<br>&gt; there’s a common exception that can be thrown for general purpose invalid<br>&gt; argument errors (not sure if there is one right now, but it could be added<br>&gt; to the proposal).<br>&gt;<br>&gt; If there&#39;s a &quot;general purpose invalid argument error&quot;, then that error is<br>&gt; not communicating anything more than an optional would. It&#39;s merely taking<br>&gt; a lot more syntax on both sides of the call, plus complexity in the calling<br>&gt; convention and space in memory (40 bytes for a protocol witness, instead of<br>&gt; 0-1 bytes for the overhead of an Optional!), to convey the same single bit<br>&gt; of information: &quot;Your data was wrong&quot;.<br>&gt;<br>&gt; And if there isn&#39;t a general-purpose error, you&#39;re adding even *more*<br>&gt; syntax and complexity—an entire new type to conform to ErrorType—and once<br>&gt; again only conveying the same single bit of information: &quot;Your data was<br>&gt; wrong&quot;.<br>&gt;<br>&gt; Forcing simple errors to use `throws` introduces a lot more complexity for<br>&gt; no apparent benefit.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/705412d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  4, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m going to write up a formal proposal, at the very least perhaps the<br>documentation everyone is linking to could be made a formal part of the API<br>Guidelines on how to handle returning errors.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Fri, Mar 4, 2016 at 11:13 AM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I prefer `try? Int(someString)` over `Int(someString)`.<br>&gt;<br>&gt;    - There&#39;s visually nothing to indicate that `Int(someString)` could<br>&gt;    fail.<br>&gt;    - It simplifies the language to not have failable initialisers.<br>&gt;<br>&gt; InvalidArgument could be part of the standard library, something like<br>&gt; this:<br>&gt;<br>&gt; struct InvalidArgument: ErrorType {}<br>&gt;<br>&gt;<br>&gt; Brent makes a good point:<br>&gt;<br>&gt; &quot;40 bytes for a protocol witness, instead of 0-1 bytes for the overhead<br>&gt; of an Optional&quot;.<br>&gt;<br>&gt;<br>&gt; I wonder if it a typed throw would have similar overhead to an optional,<br>&gt; possibly less if the throw only has an overhead if it is thrown<br>&gt; &lt;http://llvm.org/docs/ExceptionHandling.html#itanium-abi-zero-cost-exception-handling&gt;<br>&gt; :<br>&gt;<br>&gt; init (_ fromString: String) throws(InvalidArgument)<br>&gt;<br>&gt;<br>&gt; I don&#39;t know what happened to the proposal to allow throws to specify zero<br>&gt; or one type. I&#39;m reluctant to use throws in general without that proposal.<br>&gt;<br>&gt;<br>&gt; On Fri, Mar 4, 2016 at 9:27 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt;&gt; The guidance is that returning nil is appropriate when your function<br>&gt;&gt; could fail due to simple domain errors, for instance passing a negative<br>&gt;&gt; value as a parameter where they aren&#39;t allowed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If that’s all you need then what’s wrong with throwing some generic<br>&gt;&gt; purpose illegal argument type exception and using try? It’s functionally<br>&gt;&gt; the same, i.e- removing failable initialisers doesn’t actually remove a<br>&gt;&gt; capability, it just removes what is essentially now a redundant one. In<br>&gt;&gt; other words, try? on a throwable initialiser is now functionally identical<br>&gt;&gt; to a failable initialiser and isn&#39;t appreciably more complex, especially if<br>&gt;&gt; there’s a common exception that can be thrown for general purpose invalid<br>&gt;&gt; argument errors (not sure if there is one right now, but it could be added<br>&gt;&gt; to the proposal).<br>&gt;&gt;<br>&gt;&gt; If there&#39;s a &quot;general purpose invalid argument error&quot;, then that error is<br>&gt;&gt; not communicating anything more than an optional would. It&#39;s merely taking<br>&gt;&gt; a lot more syntax on both sides of the call, plus complexity in the calling<br>&gt;&gt; convention and space in memory (40 bytes for a protocol witness, instead of<br>&gt;&gt; 0-1 bytes for the overhead of an Optional!), to convey the same single bit<br>&gt;&gt; of information: &quot;Your data was wrong&quot;.<br>&gt;&gt;<br>&gt;&gt; And if there isn&#39;t a general-purpose error, you&#39;re adding even *more*<br>&gt;&gt; syntax and complexity—an entire new type to conform to ErrorType—and once<br>&gt;&gt; again only conveying the same single bit of information: &quot;Your data was<br>&gt;&gt; wrong&quot;.<br>&gt;&gt;<br>&gt;&gt; Forcing simple errors to use `throws` introduces a lot more complexity<br>&gt;&gt; for no apparent benefit.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/3709f120/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 04.03.2016 um 12:13 schrieb Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; There&#39;s visually nothing to indicate that `Int(someString)` could fail.<br></p><p>That&#39;s not true, as the return type is an optional. This is not only visible but even has to be handled explicitly.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/762a7aa7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 13:43, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The duality is that an error reported through the throwing mechanism should be non-trivial.<br>&gt; <br>&gt; Is calling an initialiser with invalid values really trivial?<br></p><p>Without responding to anything else, there are several cases where the work to validate that a parameter is valid is pretty much equivalent to the work to create the instance. It&#39;s a pragmatic decision, then, to accept &quot;invalid&quot; values and return nil rather than trapping out with a precondition(_:).<br></p><p>That doesn&#39;t mean an error couldn&#39;t be thrown either, but such invalid parameters are usually intended to be handled right at the call site, while thrown errors are very often meant to be propagated up to the start of the activity.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/d8e137c6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  5, 2016 at 04:00:00pm</p></header><div class="content"><p>+1 to everything Brent said.<br></p><p>-Thorsten <br></p><p>Am 03.03.2016 um 10:20 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; class Model {<br>&gt;&gt; <br>&gt;&gt; let property: String<br>&gt;&gt; let property1: String<br>&gt;&gt; let property2: String<br>&gt;&gt; let property3: String<br>&gt;&gt; <br>&gt;&gt; init?(json: [String: AnyObject]) throws {<br>&gt;&gt; <br>&gt;&gt; property = try json.require(&quot;property&quot;)<br>&gt;&gt; property1 = try json.require(&quot;property1&quot;)<br>&gt;&gt; property2 = try json.require(&quot;property2&quot;)<br>&gt;&gt; property3 = try json.require(&quot;property3&quot;)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Require reads the key from the dict and tries to cast it to the same type as the variable its being assigned to and throws an error if this fails (like it doesn&#39;t exist or it can&#39;t be casted). This has much less boilerplate, its easier to read and also we can throw an error saying (&quot;We couldn&#39;t parse property1&quot;).<br>&gt; <br>&gt; You&#39;re right, that&#39;s an improvement over the failable initializer. *So make this a throwing init instead.* It&#39;s not like the existence of failable initializers keeps you from using `throws`.<br>&gt; <br>&gt; Meanwhile, things like `Int.init(_: String)` and `NSImage.init(data: NSData)` are better off being failable. There&#39;s not much useful detail you can provide for these failures, and it&#39;s really nice to be able to use if-let, guard-let, or ?? to handle them instead of having to write an entire do/catch block.<br>&gt; <br>&gt; It&#39;s helpful to have both a hammer *and* a screwdriver in your toolkit, lest you be forced to treat everything like a nail.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mar 3, 2016, at 1:09 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; True but in my example above for parsing a JSON into a model I can do this:<br>&gt; <br>&gt; class Model {<br>&gt; <br>&gt; let property: String<br>&gt; let property1: String<br>&gt; let property2: String<br>&gt; let property3: String<br>&gt; <br>&gt; init?(json: [String: AnyObject]) {<br>&gt; <br>&gt; guard property = json[&quot;property&quot;] as? String else {<br>&gt;  return nil<br>&gt; }<br>&gt; <br>&gt; guard property = json[&quot;property1&quot;] as? String else {<br>&gt;  return nil<br>&gt; }<br>&gt; <br>&gt; guard property = json[&quot;property2&quot;] as? String else {<br>&gt;  return nil<br>&gt; }<br>&gt; <br>&gt; guard property = json[&quot;property3&quot;] as? String else {<br>&gt;  return nil<br>&gt; }<br></p><p>Just FYI, but you can of course write this as:<br></p><p>guard let property = json[&quot;property&quot;] as? String,<br>          let property2 = json[&quot;property1&quot;] as? String,<br>          let property3 = json[&quot;property2&quot;] as? String,<br>          let property4 = json[&quot;property3&quot;] as? String else {<br> return nil<br>}<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; There is a lot of boilerplate for very little information and I&#39;m worried by letting people initialize without returning an error we will get complex objects like this being constructed and failing for no reason. <br>&gt; <br>&gt; Compare this to error handling:<br>&gt; <br>&gt; class Model {<br>&gt; <br>&gt; let property: String<br>&gt; let property1: String<br>&gt; let property2: String<br>&gt; let property3: String<br>&gt; <br>&gt; init?(json: [String: AnyObject]) throws {<br>&gt; <br>&gt; property = try json.require(&quot;property&quot;)<br>&gt; property1 = try json.require(&quot;property1&quot;)<br>&gt; property2 = try json.require(&quot;property2&quot;)<br>&gt; property3 = try json.require(&quot;property3&quot;)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Require reads the key from the dict and tries to cast it to the same type as the variable its being assigned to and throws an error if this fails (like it doesn&#39;t exist or it can&#39;t be casted). This has much less boilerplate, its easier to read and also we can throw an error saying (&quot;We couldn&#39;t parse property1&quot;). <br>&gt; <br>&gt; Some frameworks like Freddy JSON so something similar to this but with a much more complex model using Enums and it involves setting a bunch of parameters to tell the library when to throw a runtime error or not if it can&#39;t find something which if not handled correctly can cause a crash.<br>&gt; <br>&gt; We could make this even simpler yet if we could somehow treat casting as an error:<br>&gt; <br>&gt; class Model {<br>&gt; <br>&gt; let property: String<br>&gt; let property1: String<br>&gt; let property2: String<br>&gt; let property3: String<br>&gt; <br>&gt; init?(json: [String: AnyObject]) throws {<br>&gt; <br>&gt; property = try json[&quot;property&quot;] as String<br>&gt; property1 = try json[&quot;property1&quot;] as String<br>&gt; property2 = try json[&quot;property2&quot;] as String<br>&gt; property3 = try json[&quot;property3&quot;] as String<br>&gt; <br>&gt; }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; If casting fails it throws an error, unfortunately we lose error information about the key so probably having a casting method like the one above is probable better. But in someways it explains what is happening.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head of Trolls<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt; On Thu, Mar 3, 2016 at 8:59 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Error handling forces you to do something about the possibility of a failure.<br>&gt; <br>&gt; So does using a failable initializer: the value is in an Optional, so you can&#39;t access it without either testing and unwrapping or just force-unwrapping. The type system, rather than the `try` requirement, is what forces you to handle the error, but it&#39;s the same idea.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/e14feecd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March  3, 2016 at 10:00:00am</p></header><div class="content"><p>-1.<br></p><p>I think throwing initializers are great, but failable initializers are useful too — in the same way throwing errors is great, but sometimes all you want is an optional.<br></p><p>I understand where you’re coming from, but I don’t feel comfortable about the idea of Swift forcing me to throw a dummy error when I don’t care about one, or having to use a special factory method to accomplish what `init?` does very well today.<br></p><p>— Radek<br></p><p>&gt; On 02 Mar 2016, at 22:11, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt; <br>&gt; Take this model<br>&gt; <br>&gt; struct MyModel {<br>&gt; <br>&gt; let someProperty<br>&gt; let anotherProperty<br>&gt; }<br>&gt; <br>&gt; Lets say we have a Initializers for this structure that takes a JSON structure and returns an i.<br>&gt; <br>&gt; We could guarantee that it always returns an instance but then we have to populate this data with dummy values if the JSON is missing values.<br>&gt; <br>&gt; I could make these properties optional to reflect that the JSON was missing information but I would be making the structure mutable which adds complexity. On-top of that I wouldn&#39;t be able to tell if the property is nil due to a lack of a value or a bug causing certain JSON information to be missing.<br>&gt; <br>&gt; So lets look at the alternatives with a non-guranteed system, well we have Failable Initializers. If any of the properties are missing, we should return nil.<br>&gt; <br>&gt; Well we have this issue:<br>&gt; <br>&gt; MyModel(json) <br>&gt; <br>&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer unless swift was update to, meaning we may forget to handle the nil case:<br>&gt; <br>&gt;  MyModel?(json)<br>&gt; <br>&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot of steps to create the object and fails (Like parsing an object from JSON). Returning nil but we have no idea why, it makes it easy to introduce silently failing errors. <br>&gt; <br>&gt; Its true some classes may do this when ran on a older version of iOS but with avaliabilty checks, this use case is irrelevant. <br>&gt; <br>&gt; So what about throwing an error?<br>&gt; <br>&gt; It forces us to handle it failing to initialize for some reason. <br>&gt; <br>&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue with this corrupted data - and the error will be informative as it forces us to create an ErrorType.<br>&gt; - If we want to ignore this object and convert the error to nil we can still use try? (For example in a Chat application you could ignore corrupted messages).<br>&gt; - In these cases where we ignore the error using try? it makes it super obvious we are ignoring an error and it should be easy to that error causing it to fail by using try! <br>&gt; - On the whole it encourages us to not return nil and to return useful error codes which we can handle, what if one of the reasons it failed to parse is something we could recover from? If we return nil we will never know.<br>&gt; - And it reduces the amount of mutability in swift.<br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head of Trolls<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/34cc4cca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 1:24 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1.<br>&gt; <br>&gt; I think throwing initializers are great, but failable initializers are useful too — in the same way throwing errors is great, but sometimes all you want is an optional.<br>&gt; <br>&gt; I understand where you’re coming from, but I don’t feel comfortable about the idea of Swift forcing me to throw a dummy error when I don’t care about one, or having to use a special factory method to accomplish what `init?` does very well today.<br></p><p>I agree. This is a simplification that is actually a complication in my mind. It makes initializers a special case for error handling where they weren’t before. <br></p><p>—CK<br></p><p>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 02 Mar 2016, at 22:11, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt;&gt; <br>&gt;&gt; Take this model<br>&gt;&gt; <br>&gt;&gt; struct MyModel {<br>&gt;&gt; <br>&gt;&gt; let someProperty<br>&gt;&gt; let anotherProperty<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Lets say we have a Initializers for this structure that takes a JSON structure and returns an i.<br>&gt;&gt; <br>&gt;&gt; We could guarantee that it always returns an instance but then we have to populate this data with dummy values if the JSON is missing values.<br>&gt;&gt; <br>&gt;&gt; I could make these properties optional to reflect that the JSON was missing information but I would be making the structure mutable which adds complexity. On-top of that I wouldn&#39;t be able to tell if the property is nil due to a lack of a value or a bug causing certain JSON information to be missing.<br>&gt;&gt; <br>&gt;&gt; So lets look at the alternatives with a non-guranteed system, well we have Failable Initializers. If any of the properties are missing, we should return nil.<br>&gt;&gt; <br>&gt;&gt; Well we have this issue:<br>&gt;&gt; <br>&gt;&gt; MyModel(json) <br>&gt;&gt; <br>&gt;&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer unless swift was update to, meaning we may forget to handle the nil case:<br>&gt;&gt; <br>&gt;&gt;  MyModel?(json)<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot of steps to create the object and fails (Like parsing an object from JSON). Returning nil but we have no idea why, it makes it easy to introduce silently failing errors. <br>&gt;&gt; <br>&gt;&gt; Its true some classes may do this when ran on a older version of iOS but with avaliabilty checks, this use case is irrelevant. <br>&gt;&gt; <br>&gt;&gt; So what about throwing an error?<br>&gt;&gt; <br>&gt;&gt; It forces us to handle it failing to initialize for some reason. <br>&gt;&gt; <br>&gt;&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue with this corrupted data - and the error will be informative as it forces us to create an ErrorType.<br>&gt;&gt; - If we want to ignore this object and convert the error to nil we can still use try? (For example in a Chat application you could ignore corrupted messages).<br>&gt;&gt; - In these cases where we ignore the error using try? it makes it super obvious we are ignoring an error and it should be easy to that error causing it to fail by using try! <br>&gt;&gt; - On the whole it encourages us to not return nil and to return useful error codes which we can handle, what if one of the reasons it failed to parse is something we could recover from? If we return nil we will never know.<br>&gt;&gt; - And it reduces the amount of mutability in swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥Head of Trolls<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/b7f63089/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>March  3, 2016 at 01:00:00pm</p></header><div class="content"><p>-1 for me. I like the flexibility of having both failable and throwable initializers.<br></p><p>&gt; On Mar 2, 2016, at 4:11 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that we now have error handling and availability checks does it make sense to have Failable Initializers which date back to Swift 1.1?<br>&gt; <br>&gt; Take this model<br>&gt; <br>&gt; struct MyModel {<br>&gt; <br>&gt; let someProperty<br>&gt; let anotherProperty<br>&gt; }<br>&gt; <br>&gt; Lets say we have a Initializers for this structure that takes a JSON structure and returns an i.<br>&gt; <br>&gt; We could guarantee that it always returns an instance but then we have to populate this data with dummy values if the JSON is missing values.<br>&gt; <br>&gt; I could make these properties optional to reflect that the JSON was missing information but I would be making the structure mutable which adds complexity. On-top of that I wouldn&#39;t be able to tell if the property is nil due to a lack of a value or a bug causing certain JSON information to be missing.<br>&gt; <br>&gt; So lets look at the alternatives with a non-guranteed system, well we have Failable Initializers. If any of the properties are missing, we should return nil.<br>&gt; <br>&gt; Well we have this issue:<br>&gt; <br>&gt; MyModel(json) <br>&gt; <br>&gt; It isn&#39;t clear that this is fallable compared to a traditional initializer unless swift was update to, meaning we may forget to handle the nil case:<br>&gt; <br>&gt;  MyModel?(json)<br>&gt; <br>&gt; This isn&#39;t all that is wrong with this approach, if this method does a lot of steps to create the object and fails (Like parsing an object from JSON). Returning nil but we have no idea why, it makes it easy to introduce silently failing errors. <br>&gt; <br>&gt; Its true some classes may do this when ran on a older version of iOS but with avaliabilty checks, this use case is irrelevant. <br>&gt; <br>&gt; So what about throwing an error?<br>&gt; <br>&gt; It forces us to handle it failing to initialize for some reason. <br>&gt; <br>&gt; - If we forget to handle the error, the app won&#39;t be allowed to continue with this corrupted data - and the error will be informative as it forces us to create an ErrorType.<br>&gt; - If we want to ignore this object and convert the error to nil we can still use try? (For example in a Chat application you could ignore corrupted messages).<br>&gt; - In these cases where we ignore the error using try? it makes it super obvious we are ignoring an error and it should be easy to that error causing it to fail by using try! <br>&gt; - On the whole it encourages us to not return nil and to return useful error codes which we can handle, what if one of the reasons it failed to parse is something we could recover from? If we return nil we will never know.<br>&gt; - And it reduces the amount of mutability in swift.<br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head of Trolls<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/7befd4c5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  7, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br>Without &quot;try?&quot;, it would be really inconvenient to not have &quot;init?&quot; — but failable initializers as they are now are somewhat odd, because they are half-function and half-procedure:<br>Regular init-methods have no return, so you can basically think of them as a configuration that is called on an allocated object.<br>This isn&#39;t true anymore for &quot;init?&quot;, as it not only it turns a &quot;void-function&quot; into something that returns an optional, but also doesn&#39;t explicitly model the non-nil case (there is no &quot;return self&quot;).<br>Replacing this mechanism with an error would actually make initializers more method-like, and less special.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  7, 2016 at 03:00:00pm</p></header><div class="content"><p>This is my draft proposal.<br></p><p>https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md<br></p><p>Let me know your thoughts.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Mon, Mar 7, 2016 at 2:27 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt; +1<br>&gt; Without &quot;try?&quot;, it would be really inconvenient to not have &quot;init?&quot; — but<br>&gt; failable initializers as they are now are somewhat odd, because they are<br>&gt; half-function and half-procedure:<br>&gt; Regular init-methods have no return, so you can basically think of them as<br>&gt; a configuration that is called on an allocated object.<br>&gt; This isn&#39;t true anymore for &quot;init?&quot;, as it not only it turns a<br>&gt; &quot;void-function&quot; into something that returns an optional, but also doesn&#39;t<br>&gt; explicitly model the non-nil case (there is no &quot;return self&quot;).<br>&gt; Replacing this mechanism with an error would actually make initializers<br>&gt; more method-like, and less special.<br>&gt;<br>&gt; Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/86c4953a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 7:40 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is my draft proposal.<br>&gt; <br>&gt; https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md &lt;https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md&gt;<br>&gt; <br>&gt; Let me know your thoughts.<br></p><p>Please expand your proposal to include a description of the how importing ObjC types to Swift works.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/c6f2c14d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  7, 2016 at 06:00:00pm</p></header><div class="content"><p>So we could try to bridge `init?` from objective-c so they become `init()<br>throws` but perhaps a less disruptive solution is to only allow `init?` for<br>swift classes that inherit from @objc ? I can&#39;t see how it is possible to<br>let `init throw` bridge back to objective-c cleanly.<br></p><p>I have updated my proposal to explore both of these options.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Mon, Mar 7, 2016 at 6:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 7, 2016, at 7:40 AM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is my draft proposal.<br>&gt;<br>&gt;<br>&gt; https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md<br>&gt;<br>&gt; Let me know your thoughts.<br>&gt;<br>&gt;<br>&gt; Please expand your proposal to include a description of the how importing<br>&gt; ObjC types to Swift works.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/5b539a5b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  7, 2016 at 08:00:00pm</p></header><div class="content"><p>I like the alternative, which makes it clear, at the call site, that the initializer is failable:<br>&gt; An alternative is to change the falliable initiliser to have the optional symbol required at the call-site:<br>&gt; <br>&gt; MyModel?()<br></p><p>Here is a rationale: imagine you have a type with a failable initializer AND a function that takes an optional value of this type, with default nil:<br></p><p>protocol P { }<br>struct Value {<br>    init(_ array:[P?]) { … }<br>    init?(_ nsarray: NSArray) { … }<br>}<br>func function(value: Value? = nil) { … }<br></p><p>The problem is that when the failable initializer fails, the function may not behave as expected:<br></p><p>let array: NSArray = …<br>function(Value(array)) // May not do what is expected<br></p><p>With the proposed alternative, the Swift compiler would force the code to read:<br></p><p>let array: NSArray = …<br>function(Value?(array)) // Now this is clearly bad. We need a value.<br></p><p>And the user is more likely to turn it into the correct code:<br></p><p>let array: NSArray = …<br>guard let value = Value(array) else {<br>    // process problem<br>}<br>function(value)<br></p><p><br>With the current state of Swift, how could the code above be fixed? By &quot;fixed&quot; I mean that it’s impossible for the user to trigger the default function value without knowing it:<br></p><p>1. Don’t use nil as a sentinel for the default value, and split the function in two variants:<br></p><p>protocol P { }<br>struct Value {<br>    init(_ array:[P?]) { … }<br>    init?(_ nsarray: NSArray) { … }<br>}<br>func function() { … }<br>func function(value: Value) { … }<br></p><p>let array: NSArray = …<br>function(Value(array)) // OK: does not compile<br></p><p>It works, BUT it may lead to an API explosion.<br></p><p>2. Don’t use nil as a sentinel for the default value, and use a special sentinel value instead:<br></p><p>protocol P { }<br>struct Value {<br>    static var DefaultValue: Value = ...<br>    init(_ array:[P?]) { }<br>    init?(_ nsarray: NSArray) { }<br>}<br>func function(value: Value = Value.DefaultValue) { }<br></p><p>let array: NSArray = …<br>function(Value(array)) // OK: does not compile<br></p><p>It works, BUT not all types can easily lock a value for such a purpose. Plus it’s a very uncommon pattern.<br></p><p>I don’t see any other way to fix the problem.<br></p><p>So I would quite welcome the alternative proposed by James Campbell.<br></p><p>Gwendal<br></p><p><br>&gt; Le 7 mars 2016 à 16:40, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This is my draft proposal.<br>&gt; <br>&gt; https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md &lt;https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md&gt;<br>&gt; <br>&gt; Let me know your thoughts.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/b576a12d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>March  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 7 Mar 2016, at 15:40, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is my draft proposal.<br>&gt; <br>&gt; https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md<br>&gt; <br>&gt; Let me know your thoughts.<br></p><p>You&#39;ve spelled &quot;failable&quot; wrong (both in the proposal and its filename). Were you thinking of &quot;fallible&quot; -- capable of making mistakes or being wrong?<br></p><p>Also, the official definition of a &quot;failable initializer&quot; is written in:<br></p><p>&lt;https://github.com/apple/swift/blob/master/docs/FailableInitializers.rst&gt;<br></p><p>It includes both optional return type and throwing initializers.<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 11:14 AM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Mar 2016, at 15:40, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is my draft proposal.<br>&gt;&gt; <br>&gt;&gt; https://github.com/jcampbell05/swift-evolution/blob/master/proposals/0045-remove-falliable-initilizer.md<br>&gt;&gt; <br>&gt;&gt; Let me know your thoughts.<br>&gt; <br>&gt; You&#39;ve spelled &quot;failable&quot; wrong (both in the proposal and its filename). Were you thinking of &quot;fallible&quot; -- capable of making mistakes or being wrong?<br>&gt; <br>&gt; Also, the official definition of a &quot;failable initializer&quot; is written in:<br>&gt; <br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/FailableInitializers.rst&gt;<br>&gt; <br>&gt; It includes both optional return type and throwing initializers.<br></p><p>We prefer &#39;failable&#39;, which is a perfectly cromulent word, and one more accessible to non-English majors.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>As ease of use and performance implications have been discussed, I would still like to see the question of consistency addressed:<br>In Objective-C, returning nil from an initializer is nothing special — it is a regular function that returns id (self in most cases).<br></p><p>Swift, on the other hand, is different:<br>Init-methods are void-functions in every aspect, with the irregularity that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br></p><p>Am I the only one who has the feeling that this is a little bit odd?<br>What kind of method is a initializer in Swift?<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 9 Mar 2016, at 10:32, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As ease of use and performance implications have been discussed, I would still like to see the question of consistency addressed:<br>&gt; In Objective-C, returning nil from an initializer is nothing special — it is a regular function that returns id (self in most cases).<br>&gt; <br>&gt; Swift, on the other hand, is different:<br>&gt; Init-methods are void-functions in every aspect, with the irregularity that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br>&gt; <br>&gt; Am I the only one who has the feeling that this is a little bit odd?<br>&gt; What kind of method is a initializer in Swift?<br></p><p>A related consideration to this is that we have no choice in how initialisers are named. For example, a method named “search” is pretty clear that it will look for something, but places no guarantee that a result will actually be found, which means that it’s fairly logical that it has an optional return type vs an error (since finding nothing isn’t an error, just one of the possible outcomes).<br></p><p>Initialisers meanwhile are really named for the type they belong to; though we can use more descriptive parameter names I suppose to give the implication of optionality, it can still be messy when you’re dealing with a mixture of regular and failable initialisers that all look very similar. Requiring a trailing question mark to indicate optionality at the call site would partially address this, though the feature still seems redundant to me.<br></p><p>&gt; On 9 Mar 2016, at 06:23, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; If I have a simple case where I just want to skip failed initializations the errors won&#39;t help me anything in unexpected cases because I disregarded them anyway.<br></p><p>You can only guarantee that they’ll be universally disregarded if you’re talking about an internal or private type, in which case you could just as easily throw anything you like if you know you’re never going to actually use it; personally I’d still try to throw something semi-useful, even if it just ends functioning as a useful reminder it’s better than nothing.<br></p><p>In terms of maintainability it can also be useful to other developers even if they have access to the source code of your initialiser, as instead of having to dig into that to find out what’s wrong they can try inspecting the error first to see if that helps; I don’t think we can currently access the error that was thrown into a try? statement, but if the debugger could do this it’d be even easier.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Swift, on the other hand, is different:<br>&gt; Init-methods are void-functions in every aspect, with the irregularity<br>&gt; that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br></p><p>Initializers are clearly not void-functions, as they return a value of type<br>T.<br>And failable initializers return an Optional&lt;T&gt;.<br>Where T is the type to which the initializer belongs.<br></p><p>If initializers where void-functions in every aspect, how would we explain<br>what happens here:<br>let a: Int = Int.init(123)<br>let b: Int? = Int.init(&quot;ff&quot;, radix: 16)<br>print(a) // 123<br>print(b) // 255<br>?<br></p><p>/Jens<br></p><p><br>On Wed, Mar 9, 2016 at 11:32 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As ease of use and performance implications have been discussed, I would<br>&gt; still like to see the question of consistency addressed:<br>&gt; In Objective-C, returning nil from an initializer is nothing special — it<br>&gt; is a regular function that returns id (self in most cases).<br>&gt;<br>&gt; Swift, on the other hand, is different:<br>&gt; Init-methods are void-functions in every aspect, with the irregularity<br>&gt; that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br>&gt;<br>&gt; Am I the only one who has the feeling that this is a little bit odd?<br>&gt; What kind of method is a initializer in Swift?<br>&gt;<br>&gt; Tino<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/e4de3720/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Ehrm, correction:<br>If initializers were void-functions in every aspect, how would we explain<br>what happens here:<br>let a: Int = Int.init(123)<br>let b: Int? = Int.init(&quot;ff&quot;, radix: 16)<br>print(a) // 123<br>print(b) // Optional(255)<br>?<br></p><p>On Wed, Mar 9, 2016 at 12:41 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Swift, on the other hand, is different:<br>&gt; &gt; Init-methods are void-functions in every aspect, with the irregularity<br>&gt; &gt; that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br>&gt;<br>&gt; Initializers are clearly not void-functions, as they return a value of<br>&gt; type T.<br>&gt; And failable initializers return an Optional&lt;T&gt;.<br>&gt; Where T is the type to which the initializer belongs.<br>&gt;<br>&gt; If initializers where void-functions in every aspect, how would we explain<br>&gt; what happens here:<br>&gt; let a: Int = Int.init(123)<br>&gt; let b: Int? = Int.init(&quot;ff&quot;, radix: 16)<br>&gt; print(a) // 123<br>&gt; print(b) // 255<br>&gt; ?<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Wed, Mar 9, 2016 at 11:32 AM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; As ease of use and performance implications have been discussed, I would<br>&gt;&gt; still like to see the question of consistency addressed:<br>&gt;&gt; In Objective-C, returning nil from an initializer is nothing special — it<br>&gt;&gt; is a regular function that returns id (self in most cases).<br>&gt;&gt;<br>&gt;&gt; Swift, on the other hand, is different:<br>&gt;&gt; Init-methods are void-functions in every aspect, with the irregularity<br>&gt;&gt; that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br>&gt;&gt;<br>&gt;&gt; Am I the only one who has the feeling that this is a little bit odd?<br>&gt;&gt; What kind of method is a initializer in Swift?<br>&gt;&gt;<br>&gt;&gt; Tino<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/8ac96209/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Initializers are clearly not void-functions<br>Really?<br>There is no &quot;return ...&quot; in a regular init-method, and every other function declared like &quot;init&quot; won&#39;t return anything but void — so imho the &quot;clearly&quot; is more than questionable:<br>Just replace the magic name with anything else, and you have void function.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/da0a998c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>I think we should not take over this thread with much more of this<br>discussion but eg this:<br>let i: Int = Int.init(123)<br>would not compile if that initializer had a return type of Void rather than<br>Int. The only initializer I can think of that returns Void is Void() /<br>Void.init().<br>/Jens<br></p><p>On Wed, Mar 9, 2016 at 2:15 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt; Initializers are clearly not void-functions<br>&gt;<br>&gt; Really?<br>&gt; There is no &quot;return ...&quot; in a regular init-method, and every other<br>&gt; function declared like &quot;init&quot; won&#39;t return anything but void — so imho the<br>&gt; &quot;clearly&quot; is more than questionable:<br>&gt; Just replace the magic name with anything else, and you have void function.<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/2ecf6f03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; let i: Int = Int.init(123)<br>&gt; would not compile if that initializer had a return type of Void rather than Int.<br>No one can argue the observation that init-methods have return values (although I think it&#39;s rather uncommon to invoke them that way) — but that is not my point:<br>Let&#39;s imagine I write a library with a numeric type, and define the &quot;+&quot;-operator to perform a multiplication.<br>Given this,<br>let x: StringIntLiteralConvertible = 2 + 5<br>should assign x a value of 10: That is how the operation is defined (like &quot;init&quot; is defined to return self), and according to your argumentation, everything is fine.<br>Nonetheless, I&#39;d say this operator is inconsistent, because it contradicts to common behavior, and &quot;+&quot; should be linked to addition.<br>Initializers behave similar (on another level, though):<br>They have the signature of a void function, they have the body of a void function — but yet they return something.<br></p><p>You are right that this is actually a topic on its own, as &quot;init?&quot; just emphasizes the &quot;oddity&quot;, because suddenly there is a need to manually add a return statement for one case...<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/fc236c9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  9, 2016 at 10:00:00am</p></header><div class="content"><p>So you would you be happy if failable inits were declared like this:<br></p><p>init() -&gt; self? {}<br></p><p>Unfortunately, Swift decided to make init() a special case thing. It&#39;s also the only function type that has special rules around accessing properties, the only one that cannot be named differently, the only one that has special rules around recursing or forwarding to other init() calls, and many other special rules and considerations. <br></p><p>The ability to use optionals is one of the key components to Swift&#39;s error handling story. Why should initializers not be able to participate in that story? I don&#39;t agree with your consistency argument; init() is already completely inconsistent from every other function in Swift. It&#39;s a side-effect of all of the other choices around init() that cause the inconsistent syntax with other functions signatures.<br></p><p>-David<br></p><p><br>&gt; On Mar 9, 2016, at 9:20 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; let i: Int = Int.init(123)<br>&gt;&gt; would not compile if that initializer had a return type of Void rather than Int.<br>&gt; No one can argue the observation that init-methods have return values (although I think it&#39;s rather uncommon to invoke them that way) — but that is not my point:<br>&gt; Let&#39;s imagine I write a library with a numeric type, and define the &quot;+&quot;-operator to perform a multiplication.<br>&gt; Given this,<br>&gt; let x: StringIntLiteralConvertible = 2 + 5<br>&gt; should assign x a value of 10: That is how the operation is defined (like &quot;init&quot; is defined to return self), and according to your argumentation, everything is fine.<br>&gt; Nonetheless, I&#39;d say this operator is inconsistent, because it contradicts to common behavior, and &quot;+&quot; should be linked to addition.<br>&gt; Initializers behave similar (on another level, though):<br>&gt; They have the signature of a void function, they have the body of a void function — but yet they return something.<br>&gt; <br>&gt; You are right that this is actually a topic on its own, as &quot;init?&quot; just emphasizes the &quot;oddity&quot;, because suddenly there is a need to manually add a return statement for one case...<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/b4e9674a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  9, 2016 at 06:00:00pm</p></header><div class="content"><p>Given that the Proposal has been rejected I&#39;ve been thinking alot of this<br>may be cleared up if optionals had a consistent syntax.<br></p><p>Object()<br>OptionalObject()<br></p><p>Are the same, as are<br></p><p>value<br>optionalValue<br>forcedUnwrappedValue<br></p><p>and:<br></p><p>function()<br>optionalFunction()<br>forcedUnwrappedValue()<br></p><p>But when it comes to protocols, I&#39;ve had to write it like this:<br></p><p>optionalProtocolMethod()<br>forcedProtocolMethod!()<br></p><p>I would love to take a page out of Ruby&#39;s book which has ! for things that<br>are dangerous and ? for boolean expression. Instead for Swift we could have<br>? for optional returns and ! for forced unwrapped.<br></p><p>So we would have:<br></p><p>Object()<br>OptionalObject?()<br></p><p>value<br>optionalValue?<br>forcedUnwrappedValue!<br></p><p>function()<br>optionalFunction?()<br>forcedUnwrappedValue!()<br></p><p>optionalProtocolMethod?()<br>forcedProtocolMethod!()<br></p><p>You may think this is silly but I&#39;ve had crashes due to function arguments<br>being mapped into swift from objective-c as forced un-wrapped due to the<br>lack of non-null and null marking.<br></p><p>If the name of the property had a &quot;!&quot; in it then I would have noticed it.<br></p><p>The same with falliable initializers. It would be a lot clearer to me that<br>Object?() could fail.<br></p><p>IT also confuses me that some non-optional protocol methods have to have<br>the ! in the name.<br></p><p><br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Mar 9, 2016 at 6:10 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So you would you be happy if failable inits were declared like this:<br>&gt;<br>&gt; init() -&gt; self? {}<br>&gt;<br>&gt;<br>&gt; Unfortunately, Swift decided to make init() a special case thing. It&#39;s<br>&gt; also the only function type that has special rules around accessing<br>&gt; properties, the only one that cannot be named differently, the only one<br>&gt; that has special rules around recursing or forwarding to other init()<br>&gt; calls, and many other special rules and considerations.<br>&gt;<br>&gt; The ability to use optionals is one of the key components to Swift&#39;s error<br>&gt; handling story. Why should initializers not be able to participate in that<br>&gt; story? I don&#39;t agree with your consistency argument; init() is already<br>&gt; completely inconsistent from every other function in Swift. It&#39;s a<br>&gt; side-effect of all of the other choices around init() that cause the<br>&gt; inconsistent syntax with other functions signatures.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>&gt; On Mar 9, 2016, at 9:20 AM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; let i: Int = Int.init(123)<br>&gt; would not compile if that initializer had a return type of Void rather<br>&gt; than Int.<br>&gt;<br>&gt; No one can argue the observation that init-methods have return values<br>&gt; (although I think it&#39;s rather uncommon to invoke them that way) — but that<br>&gt; is not my point:<br>&gt; Let&#39;s imagine I write a library with a numeric type, and define the<br>&gt; &quot;+&quot;-operator to perform a multiplication.<br>&gt; Given this,<br>&gt; let x: StringIntLiteralConvertible = 2 + 5<br>&gt; should assign x a value of 10: That is how the operation is defined (like<br>&gt; &quot;init&quot; is defined to return self), and according to your argumentation,<br>&gt; everything is fine.<br>&gt; Nonetheless, I&#39;d say this operator is inconsistent, because it contradicts<br>&gt; to common behavior, and &quot;+&quot; should be linked to addition.<br>&gt; Initializers behave similar (on another level, though):<br>&gt; They have the signature of a void function, they have the body of a void<br>&gt; function — but yet they return something.<br>&gt;<br>&gt; You are right that this is actually a topic on its own, as &quot;init?&quot; just<br>&gt; emphasizes the &quot;oddity&quot;, because suddenly there is a need to manually add a<br>&gt; return statement for one case...<br>&gt;<br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/230144fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I would love to take a page out of Ruby&#39;s book which has ! for things that are dangerous and ? for boolean expression. Instead for Swift we could have ? for optional returns and ! for forced unwrapped.<br>&gt; <br>&gt; So we would have:<br>&gt; <br>&gt; Object()<br>&gt; OptionalObject?()<br>&gt; <br>&gt; value<br>&gt; optionalValue?<br>&gt; forcedUnwrappedValue!<br>&gt; <br>&gt; function()<br>&gt; optionalFunction?()<br>&gt; forcedUnwrappedValue!()<br>&gt; <br>&gt; optionalProtocolMethod?()<br>&gt; forcedProtocolMethod!()<br></p><p>You do understand that `?` at the end of a symbol already means something else, don&#39;t you? That&#39;s how optional chaining works.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes I understand but I was still able to miss the fact a variable imported<br>from objective C as a !.<br></p><p>Take this example:<br></p><p>//Imported From Obj-C Library<br>typealias MyClosure = (value: NSObject!) -&gt; Void<br></p><p>func loadData(block: MyClosure)<br></p><p>//Implemented In Swift File else where<br>loadData {<br> value in<br> print(value) //Crashes if we try to access it<br>}<br></p><p>This would be clearer to me:<br></p><p>//Imported From Obj-C Library<br>typealias MyClosure = (value: NSObject!) -&gt; Void<br></p><p>func loadData(block: MyClosure)<br></p><p>//Implemented In Swift File else where<br>loadData {<br></p><p>//Since the property is a unwrapped optional, the compiler enforces us to<br>use the ! after the variable name<br> value! in<br> print(value!) //Still crashes if we try to access it but at least we know<br>its an un-wrapped type.<br>}<br></p><p>This has happened to me a few times with Librarys in Objective-C and I have<br>released an app that crashed because of that reason.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Mar 9, 2016 at 8:23 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I would love to take a page out of Ruby&#39;s book which has ! for things<br>&gt; that are dangerous and ? for boolean expression. Instead for Swift we could<br>&gt; have ? for optional returns and ! for forced unwrapped.<br>&gt; &gt;<br>&gt; &gt; So we would have:<br>&gt; &gt;<br>&gt; &gt; Object()<br>&gt; &gt; OptionalObject?()<br>&gt; &gt;<br>&gt; &gt; value<br>&gt; &gt; optionalValue?<br>&gt; &gt; forcedUnwrappedValue!<br>&gt; &gt;<br>&gt; &gt; function()<br>&gt; &gt; optionalFunction?()<br>&gt; &gt; forcedUnwrappedValue!()<br>&gt; &gt;<br>&gt; &gt; optionalProtocolMethod?()<br>&gt; &gt; forcedProtocolMethod!()<br>&gt;<br>&gt; You do understand that `?` at the end of a symbol already means something<br>&gt; else, don&#39;t you? That&#39;s how optional chaining works.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/f182c40f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; So you would you be happy if failable inits were declared like this:<br>&gt; <br>&gt; init() -&gt; self? {}<br></p><p>Not really — afaics, the signature ought to be<br>static init() -&gt; Self? {<br>//…<br>	return self<br>}<br>for maximum consistency ;-) (oh, wait: self is available in the body, so it can&#39;t be static… it&#39;s even more special than that :-)<br>The status quo is definitely convenient, and before this thread, I didn&#39;t brood over possible flaws it might have; now, I have to admit that initialization in Objective-C not only had the downside of being more cumbersome, but also the advantage of being simpler and more lightweight.<br></p><p>&gt; Unfortunately, Swift decided to make init() a special case thing. It&#39;s also the only function type that has special rules around accessing properties, the only one that cannot be named differently, the only one that has special rules around recursing or forwarding to other init() calls<br>True, but I think those rules can&#39;t be removed (maybe it&#39;s possible to generalize some; &quot;required&quot; is a candidate for this).<br></p><p>Apparently, getting init right is tougher than it seems at first sight (I&#39;d love to see a brilliant answer for the &quot;make class initialization complexity more progressively disclosed&quot; thread that magically simplifies the whole thing ;-)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/b462524e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 12:02 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I have to admit that initialization in Objective-C not only had the downside of being more cumbersome, but also the advantage of being simpler and more lightweight.<br></p><p>It is more cumbersome because it&#39;s significantly more powerful and tied to a class-hierarchy. That power also makes it &quot;unsafe&quot;. Like most recent languages, Swift has gone the route of combining both allocation and initialization into one unifying concept. This is primary source of the init() constraints, limitations, and complexity. There&#39;s a lot to get right when your stance is that a type must be fully initialized before returning it to the caller.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/52d3a9d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 12:35, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:02 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have to admit that initialization in Objective-C not only had the downside of being more cumbersome, but also the advantage of being simpler and more lightweight.<br>&gt; <br>&gt; It is more cumbersome because it&#39;s significantly more powerful and tied to a class-hierarchy. That power also makes it &quot;unsafe&quot;. Like most recent languages, Swift has gone the route of combining both allocation and initialization into one unifying concept. This is primary source of the init() constraints, limitations, and complexity. There&#39;s a lot to get right when your stance is that a type must be fully initialized before returning it to the caller.<br></p><p>This is not correct. Even if Swift had separated allocation and initialization, you would still have all of the &quot;constraints, limitations, and complexity&quot;. It&#39;s the full initialization that forces this, not the combination with allocation.<br></p><p>Every rule Swift enforces was a &quot;rule&quot; in Objective-C; you were just free to ignore it there. Between safety and convenience, Swift chooses safety. That said, I&#39;m/we&#39;re still hoping to come with simpler, improved initialization rules. (I should really post my summary of problems with the current model somewhere. It probably doesn&#39;t cover all the problems, but it&#39;s a good starting point for discussion.)<br></p><p>Additionally, from earlier:<br></p><p>&gt; Unfortunately, Swift decided to make init() a special case thing. It&#39;s also the only function type that has special rules around accessing properties, the only one that cannot be named differently, the only one that has special rules around recursing or forwarding to other init() calls, and many other special rules and considerations. <br></p><p>I disagree with most of this. Property and subscript accessors, deinitializers, and closure expressions all have different rules from plain old &#39;func&#39; (which itself behaves differently as a type member vs. top-level). Objective-C makes all of these things methods, which is very uniform but causes problems where they should differ in behavior.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/df42b0ea/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 1:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:35, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 12:02 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have to admit that initialization in Objective-C not only had the downside of being more cumbersome, but also the advantage of being simpler and more lightweight.<br>&gt;&gt; <br>&gt;&gt; It is more cumbersome because it&#39;s significantly more powerful and tied to a class-hierarchy. That power also makes it &quot;unsafe&quot;. Like most recent languages, Swift has gone the route of combining both allocation and initialization into one unifying concept. This is primary source of the init() constraints, limitations, and complexity. There&#39;s a lot to get right when your stance is that a type must be fully initialized before returning it to the caller.<br>&gt; <br>&gt; This is not correct. Even if Swift had separated allocation and initialization, you would still have all of the &quot;constraints, limitations, and complexity&quot;. It&#39;s the full initialization that forces this, not the combination with allocation.<br></p><p>There are the rules for how types are instantiated and there are rules for how they are initialized, both have &quot;constraints, limitations, and complexity&quot;. I agree that what I wrote conflated to the two issues together, and lead to a mostly ambiguous statement.<br></p><p>Part of what I was referring the black-box that is allocation of and lifecycle management of types that we really have no control over today. For instance, I cannot tell Swift to create my object out of a specific data region that Iv&#39;e created. I can pre-allocate, what is essentially an array of those types, but then I cannot use init() anymore to ensure that I have nice, clean instantiations. Of course, I can&#39;t call a shared `reset` either from the init(), so I end up with duplicated code.<br></p><p>ObjC allowed us to implement these, maybe it wasn&#39;t safe or we won&#39;t supposed to, but it was useful. Similarly, we can do this in C or C++. Of course, these methods aren&#39;t &quot;safe&quot; as they don&#39;t guarantee us fully instantiated types. Like you said: trade-off between safety and convenience.<br></p><p>If we get custom allocators, or something similar, then this goes a long way to solving many of those types of limitations for init(). Of course, there&#39;s still the other set of limitations and complexities for ensuring that a type is fully instantiated. This also probably requires some work around owned memory allocations in order to enable the safety that Swift is looking for.<br></p><p>&gt; Every rule Swift enforces was a &quot;rule&quot; in Objective-C; you were just free to ignore it there. Between safety and convenience, Swift chooses safety. That said, I&#39;m/we&#39;re still hoping to come with simpler, improved initialization rules. (I should really post my summary of problems with the current model somewhere. It probably doesn&#39;t cover all the problems, but it&#39;s a good starting point for discussion.)<br></p><p>It would be great to see.<br></p><p>&gt; Additionally, from earlier:<br>&gt; <br>&gt;&gt; Unfortunately, Swift decided to make init() a special case thing. It&#39;s also the only function type that has special rules around accessing properties, the only one that cannot be named differently, the only one that has special rules around recursing or forwarding to other init() calls, and many other special rules and considerations. <br>&gt; <br>&gt; I disagree with most of this. Property and subscript accessors, deinitializers, and closure expressions all have different rules from plain old &#39;func&#39; (which itself behaves differently as a type member vs. top-level). Objective-C makes all of these things methods, which is very uniform but causes problems where they should differ in behavior.<br></p><p>Sure... not all people are happy about those differences =). Regardless, but those are relatively minor compared to how init() works.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/06c04b02/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Remove Failable Initializers</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; What kind of method is a initializer in Swift?<br></p><p>I would say initializers are very similar to static methods taking whatever<br>arguments and returning either T or Optional(T), depending on whether they<br>are failable or not, where T is their enclosing type.<br></p><p>let fnTypeA: (Int) -&gt; Int = { Int.init($0) }<br>let fnTypeB: (String, Int) -&gt; Int? = Int.init<br>let a = fnTypeA(123)<br>let b = fnTypeB(&quot;ff&quot;, 16)<br>print(a) // 123<br>print(b) // Optional(255)<br>print(fnTypeA.dynamicType) // Int -&gt; Int<br>print(fnTypeB.dynamicType) // (String, Int) -&gt; Optional&lt;Int&gt;<br></p><p><br>On Wed, Mar 9, 2016 at 11:32 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As ease of use and performance implications have been discussed, I would<br>&gt; still like to see the question of consistency addressed:<br>&gt; In Objective-C, returning nil from an initializer is nothing special — it<br>&gt; is a regular function that returns id (self in most cases).<br>&gt;<br>&gt; Swift, on the other hand, is different:<br>&gt; Init-methods are void-functions in every aspect, with the irregularity<br>&gt; that we can return &quot;nil&quot; (if the initializer is marked accordingly).<br>&gt;<br>&gt; Am I the only one who has the feeling that this is a little bit odd?<br>&gt; What kind of method is a initializer in Swift?<br>&gt;<br>&gt; Tino<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/dfbf0900/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
