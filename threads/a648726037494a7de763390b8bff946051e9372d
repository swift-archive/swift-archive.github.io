<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>IMHO be careful what you wish for. If the compiler enforces this then we&#39;re<br>just repeating the mistakes of Java&#39;s checked exceptions. All roads would<br>eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br></p><p>russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/a648372d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>Isn&#39;t it better to have the choice of type safety, and perhaps have a<br>compiler option or linter to enforce it (if you choose).<br></p><p>Default syntax:<br>func foo() throws; // defaults to ErrorType<br></p><p>Optional type safety:<br>func foo() throws(MyError); // note, only one type.<br></p><p>When it comes down to it, for me, the problem is that you can catch<br>anything you like, and the check for exhaustivity does not check what may<br>actually be thrown, resulting in excess code and compile-time errors.<br></p><p><br>On Tue, Dec 8, 2015 at 9:24 AM, Russ Bishop via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMHO be careful what you wish for. If the compiler enforces this then<br>&gt; we&#39;re just repeating the mistakes of Java&#39;s checked exceptions. All roads<br>&gt; would eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br>&gt;<br>&gt; russ<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/4c92bc7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>Java mixes the ability to catch catastrophic errors with programming errors; that’s part of the problem. Swift’s approach is that the throws construct is for recoverable errors. <br></p><p>I’m perfectly fine with allowing:<br></p><p>func foo() throws -&gt; () {}<br></p><p>And<br></p><p>func foo() throws MyError -&gt; () {}<br></p><p>The proposal states that.<br></p><p>What the typed version allows is the ability specifically validate that all of the error constructs (assuming an enum ErrorType) have been handled. If you still want to use the “catch-all”, that’s fine, you can do so. I’m not proposing to take away your ability to throw any ErrorType conforming type you want to.<br></p><p>-David<br></p><p>&gt; On Dec 7, 2015, at 4:06 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn&#39;t it better to have the choice of type safety, and perhaps have a compiler option or linter to enforce it (if you choose).<br>&gt; <br>&gt; Default syntax:<br>&gt; func foo() throws; // defaults to ErrorType<br>&gt; <br>&gt; Optional type safety:<br>&gt; func foo() throws(MyError); // note, only one type.<br>&gt; <br>&gt; When it comes down to it, for me, the problem is that you can catch anything you like, and the check for exhaustivity does not check what may actually be thrown, resulting in excess code and compile-time errors.<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:24 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; IMHO be careful what you wish for. If the compiler enforces this then we&#39;re just repeating the mistakes of Java&#39;s checked exceptions. All roads would eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br>&gt; <br>&gt; russ<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/611593d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>Then let&#39;s change my response to simply: :+1:<br></p><p>Thanks!<br></p><p>On Tue, Dec 8, 2015 at 11:28 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; Java mixes the ability to catch catastrophic errors with programming<br>&gt; errors; that’s part of the problem. Swift’s approach is that the throws<br>&gt; construct is for *recoverable* errors.<br>&gt;<br>&gt; I’m perfectly fine with allowing:<br>&gt;<br>&gt; func foo() throws -&gt; () {}<br>&gt;<br>&gt; And<br>&gt;<br>&gt; func foo() throws MyError -&gt; () {}<br>&gt;<br>&gt; The proposal states that.<br>&gt;<br>&gt; What the typed version allows is the ability specifically validate that<br>&gt; all of the error constructs (assuming an enum ErrorType) have been handled.<br>&gt; If you still want to use the “catch-all”, that’s fine, you can do so. I’m<br>&gt; not proposing to take away your ability to throw any ErrorType conforming<br>&gt; type you want to.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 7, 2015, at 4:06 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Isn&#39;t it better to have the choice of type safety, and perhaps have a<br>&gt; compiler option or linter to enforce it (if you choose).<br>&gt;<br>&gt; Default syntax:<br>&gt; func foo() throws; // defaults to ErrorType<br>&gt;<br>&gt; Optional type safety:<br>&gt; func foo() throws(MyError); // note, only one type.<br>&gt;<br>&gt; When it comes down to it, for me, the problem is that you can catch<br>&gt; anything you like, and the check for exhaustivity does not check what may<br>&gt; actually be thrown, resulting in excess code and compile-time errors.<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 9:24 AM, Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; IMHO be careful what you wish for. If the compiler enforces this then<br>&gt;&gt; we&#39;re just repeating the mistakes of Java&#39;s checked exceptions. All roads<br>&gt;&gt; would eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br>&gt;&gt;<br>&gt;&gt; russ<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/440774da/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>Both Java and C# have uncatchable (or un-stoppable) exceptions for various catastrophic errors and in fact Java’s checked exceptions are a lie partially for that reason. C# doesn’t have checked exceptions but go ahead and try to catch StackOverflowException or ThreadAbortException (the former will die immediately, the latter will pretend to be caught then get re-thrown).<br></p><p>As a library author all this does is promote wrapping errors with useless wrappers. If I touch the filesystem, I am subject to any number of filesystem errors. If I touch the network I am subject to any number of network errors. What is gained by wrapping those? If the OS is updated and the system API throws a new type of error does that mean my library is broken? If not, then the supposed contract is a lie. If my library calls another library, I’ve multiplied the boilerplate to handle that error (now the user needs to catch OtherLibraryErrorType and MyLibraryErrorType where e.innerError is OtherLibraryErrorType). Even if you solved the fragile interface problem there’s still pressure to perform the wrapping (and pressure on library authors not to introduce new error types) because I upgraded the library and now all my catch clauses are incomplete, potentially causing massive breakage due to a minor change in some core library function that ripples outward.<br></p><p>I understand the desire to avoid having the general catch-all but IMHO in most cases that is a mistake in design. If you aren’t prepared to handle any possible error and you aren’t rethrowing/throwing or retrying on all errors then you’re probably catching errors in the wrong place and should just pass them up the chain to someone else who can take action based on the error. Almost all error handling responses boil down to some combination of a) log it, b) try again later, or c) give up and die.<br> <br></p><p>russ<br></p><p>&gt; On Dec 7, 2015, at 4:28 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Java mixes the ability to catch catastrophic errors with programming errors; that’s part of the problem. Swift’s approach is that the throws construct is for recoverable errors. <br>&gt; <br>&gt; I’m perfectly fine with allowing:<br>&gt; <br>&gt; func foo() throws -&gt; () {}<br>&gt; <br>&gt; And<br>&gt; <br>&gt; func foo() throws MyError -&gt; () {}<br>&gt; <br>&gt; The proposal states that.<br>&gt; <br>&gt; What the typed version allows is the ability specifically validate that all of the error constructs (assuming an enum ErrorType) have been handled. If you still want to use the “catch-all”, that’s fine, you can do so. I’m not proposing to take away your ability to throw any ErrorType conforming type you want to.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/dc60919f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 9:29 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; As a library author all this does is promote wrapping errors with useless wrappers. If I touch the filesystem, I am subject to any number of filesystem errors. If I touch the network I am subject to any number of network errors. What is gained by wrapping those? If the OS is updated and the system API throws a new type of error does that mean my library is broken? If not, then the supposed contract is a lie. If my library calls another library, I’ve multiplied the boilerplate to handle that error (now the user needs to catch OtherLibraryErrorType and MyLibraryErrorType where e.innerError is OtherLibraryErrorType). Even if you solved the fragile interface problem there’s still pressure to perform the wrapping (and pressure on library authors not to introduce new error types) because I upgraded the library and now all my catch clauses are incomplete, potentially causing massive breakage due to a minor change in some core library function that ripples outward.<br>&gt; <br></p><p>Ok, let’s take an example of what you’re describing; I’ll argue that I believe that what you are doing is leaking implementation details that should not be shared. I believe this to be the general case when you simply wrap errors to propagate them up the call stack. <br></p><p>func nameOfTheDayOfTheWeek() -&gt; String { /* … */ }<br></p><p>Now, let’s say you need to touch the filesystem to implement this because you have a list of days in a text file.<br></p><p>There are several options here:<br></p><p>Mark the func as throws so the IO errors can propagate out.<br>Mark the func as throws so you can “wrap” the error.<br>Mark the func as throws so you can return specific errors for your library.<br>Return an optional value to signify the error.<br>Assume the function always works because an invariant you state and convert the error to a “universal error” (as described in this doc: https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;)<br></p><p>The fact that the function is using IO is an implementation detail, and because of that, it’s my opinion that #1 and #2 are wrong as you’re just propagating the inner implementation details that are subject to change. Option #3 here really seems like overkill for the function as there are only two results: get the name or don’t get the name.<br></p><p>So, this leaves us with #4 and #5.<br></p><p>Of all of the options I listed above, I think all of them have value except #2. However, I would limit the contexts of each of the types of errors because they all have something explicit to say about the contract they are creating. <br></p><p>If you intend for your users of your library to simply be catching you error, logging it, and moving on, what’s the point of using the throws construct in the first place? It would seem that you would be much better of simplifying your API and simply use the optional construct (this is the “Simple Domain Errors” construct).<br></p><p>The question really comes down to the “specificity” section; the primary concern here is #2 from the list above - simply wrapping the errors. I think the danger of throwing this out citing Java as the example, is problematic. Java made many mistakes with how it handled exceptions, and Swift takes a different approach to what errors mean.<br></p><p>What I’m asking for in the proposal is the ability for library authors to chose to make a strong contract or a weak contract about the type of errors it can throw. Also, the other vital thing to note here is this: if I’m returning an enum that implements ErrorType, I’ve explicitly stated that these are the sum of the errors that I want to handle. Further, it only impacts the places in my code where I’ve explicitly chosen to handle the different cases of the error differently. If I were to instead specify a protocol or another type, the thing I’m getting out of that is the ability to use the APIs for those types without casting (that is also the exhaustive case, but suffers from none of the breaking change concerns you had above).<br></p><p>It’s up to the library author to determine if their error types are a set of potential issues or a type that simply holds some information so that new error types can be added later. <br></p><p>&gt;  If the OS is updated and the system API throws a new type of error does that mean my library is broken?<br></p><p>Yes (if that error was defined as an enum), just like your libraries are broken if a library you use adds a new enum case; that’s a breaking change. You have the same problem today with this code:<br></p><p>func f() -&gt; MyEnum { /* … */ }<br>let r = f()<br>switch r {<br>    case .First: /* do something */<br>    case .Last: /* do something */<br>}<br></p><p>Do you also recommend always having a default case when working with enums throughout your code? This is just as fragile. <br></p><p>Also, if the counter-argument is that ErrorType is sufficient for all error handling, then Swift should just make it a struct and let’s be done with it.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6308b466/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>Huge +1 to David&#39;s comments.  The language should not restrict the choices available to library authors when designing the contract for error results.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 8, 2015, at 12:12 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 9:29 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a library author all this does is promote wrapping errors with useless wrappers. If I touch the filesystem, I am subject to any number of filesystem errors. If I touch the network I am subject to any number of network errors. What is gained by wrapping those? If the OS is updated and the system API throws a new type of error does that mean my library is broken? If not, then the supposed contract is a lie. If my library calls another library, I’ve multiplied the boilerplate to handle that error (now the user needs to catch OtherLibraryErrorType and MyLibraryErrorType where e.innerError is OtherLibraryErrorType). Even if you solved the fragile interface problem there’s still pressure to perform the wrapping (and pressure on library authors not to introduce new error types) because I upgraded the library and now all my catch clauses are incomplete, potentially causing massive breakage due to a minor change in some core library function that ripples outward.<br>&gt;&gt; <br>&gt; <br>&gt; Ok, let’s take an example of what you’re describing; I’ll argue that I believe that what you are doing is leaking implementation details that should not be shared. I believe this to be the general case when you simply wrap errors to propagate them up the call stack. <br>&gt; <br>&gt; func nameOfTheDayOfTheWeek() -&gt; String { /* … */ }<br>&gt; <br>&gt; Now, let’s say you need to touch the filesystem to implement this because you have a list of days in a text file.<br>&gt; <br>&gt; There are several options here:<br>&gt; <br>&gt; Mark the func as throws so the IO errors can propagate out.<br>&gt; Mark the func as throws so you can “wrap” the error.<br>&gt; Mark the func as throws so you can return specific errors for your library.<br>&gt; Return an optional value to signify the error.<br>&gt; Assume the function always works because an invariant you state and convert the error to a “universal error” (as described in this doc: https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst)<br>&gt; <br>&gt; The fact that the function is using IO is an implementation detail, and because of that, it’s my opinion that #1 and #2 are wrong as you’re just propagating the inner implementation details that are subject to change. Option #3 here really seems like overkill for the function as there are only two results: get the name or don’t get the name.<br>&gt; <br>&gt; So, this leaves us with #4 and #5.<br>&gt; <br>&gt; Of all of the options I listed above, I think all of them have value except #2. However, I would limit the contexts of each of the types of errors because they all have something explicit to say about the contract they are creating. <br>&gt; <br>&gt; If you intend for your users of your library to simply be catching you error, logging it, and moving on, what’s the point of using the throws construct in the first place? It would seem that you would be much better of simplifying your API and simply use the optional construct (this is the “Simple Domain Errors” construct).<br>&gt; <br>&gt; The question really comes down to the “specificity” section; the primary concern here is #2 from the list above - simply wrapping the errors. I think the danger of throwing this out citing Java as the example, is problematic. Java made many mistakes with how it handled exceptions, and Swift takes a different approach to what errors mean.<br>&gt; <br>&gt; What I’m asking for in the proposal is the ability for library authors to chose to make a strong contract or a weak contract about the type of errors it can throw. Also, the other vital thing to note here is this: if I’m returning an enum that implements ErrorType, I’ve explicitly stated that these are the sum of the errors that I want to handle. Further, it only impacts the places in my code where I’ve explicitly chosen to handle the different cases of the error differently. If I were to instead specify a protocol or another type, the thing I’m getting out of that is the ability to use the APIs for those types without casting (that is also the exhaustive case, but suffers from none of the breaking change concerns you had above).<br>&gt; <br>&gt; It’s up to the library author to determine if their error types are a set of potential issues or a type that simply holds some information so that new error types can be added later. <br>&gt; <br>&gt;&gt;  If the OS is updated and the system API throws a new type of error does that mean my library is broken?<br>&gt; <br>&gt; Yes (if that error was defined as an enum), just like your libraries are broken if a library you use adds a new enum case; that’s a breaking change. You have the same problem today with this code:<br>&gt; <br>&gt; func f() -&gt; MyEnum { /* … */ }<br>&gt; let r = f()<br>&gt; switch r {<br>&gt;     case .First: /* do something */<br>&gt;     case .Last: /* do something */<br>&gt; }<br>&gt; <br>&gt; Do you also recommend always having a default case when working with enums throughout your code? This is just as fragile. <br>&gt; <br>&gt; Also, if the counter-argument is that ErrorType is sufficient for all error handling, then Swift should just make it a struct and let’s be done with it.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/3e8c9c90/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:12 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 7, 2015, at 9:29 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a library author all this does is promote wrapping errors with useless wrappers. If I touch the filesystem, I am subject to any number of filesystem errors. If I touch the network I am subject to any number of network errors. What is gained by wrapping those? If the OS is updated and the system API throws a new type of error does that mean my library is broken? If not, then the supposed contract is a lie. If my library calls another library, I’ve multiplied the boilerplate to handle that error (now the user needs to catch OtherLibraryErrorType and MyLibraryErrorType where e.innerError is OtherLibraryErrorType). Even if you solved the fragile interface problem there’s still pressure to perform the wrapping (and pressure on library authors not to introduce new error types) because I upgraded the library and now all my catch clauses are incomplete, potentially causing massive breakage due to a minor change in some core library function that ripples outward.<br>&gt;&gt; <br>&gt; <br>&gt; Ok, let’s take an example of what you’re describing; I’ll argue that I believe that what you are doing is leaking implementation details that should not be shared. I believe this to be the general case when you simply wrap errors to propagate them up the call stack. <br>&gt; <br>&gt; func nameOfTheDayOfTheWeek() -&gt; String { /* … */ }<br>&gt; <br>&gt; Now, let’s say you need to touch the filesystem to implement this because you have a list of days in a text file.<br>&gt; <br>&gt; There are several options here:<br>&gt; <br>&gt; Mark the func as throws so the IO errors can propagate out.<br>&gt; Mark the func as throws so you can “wrap” the error.<br>&gt; Mark the func as throws so you can return specific errors for your library.<br>&gt; Return an optional value to signify the error.<br>&gt; Assume the function always works because an invariant you state and convert the error to a “universal error” (as described in this doc: https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;)<br>&gt; <br>&gt; The fact that the function is using IO is an implementation detail, and because of that, it’s my opinion that #1 and #2 are wrong as you’re just propagating the inner implementation details that are subject to change. Option #3 here really seems like overkill for the function as there are only two results: get the name or don’t get the name.<br>&gt; <br>&gt; So, this leaves us with #4 and #5.<br></p><p>For this example, #5 seems like the clearly correct answer.  Of course, this is mostly just evidence that artificial examples aren’t terribly helpful for this kind of discussion.<br></p><p>But in some ways, this is pretty key in the design.  As I covered in the rationale, failure modes — like most other kinds of complexity — explode very quickly in a way that’s pretty predictable by 0,1,∞: either there’s some intrinsic, mathematically-definable reason why the operation can only fail (recoverably) in one or two ways, or you’re inevitably going to slide into the maddening complexity of the world.  My concern is that any design that tries to address the former doesn’t encourage well-meaning programmers to waste their time trying to tame the second.<br></p><p>&gt; Of all of the options I listed above, I think all of them have value except #2. However, I would limit the contexts of each of the types of errors because they all have something explicit to say about the contract they are creating. <br>&gt; <br>&gt; If you intend for your users of your library to simply be catching you error, logging it, and moving on, what’s the point of using the throws construct in the first place? It would seem that you would be much better of simplifying your API and simply use the optional construct (this is the “Simple Domain Errors” construct).<br>&gt; <br>&gt; The question really comes down to the “specificity” section; the primary concern here is #2 from the list above - simply wrapping the errors. I think the danger of throwing this out citing Java as the example, is problematic. Java made many mistakes with how it handled exceptions, and Swift takes a different approach to what errors mean.<br></p><p>I agree that it’s important not to conflate all the mistakes that Java made here.  This is specifically about the wisdom of writing “throws X, Y”, which I think has been a clearly failed design approach in Java independent of all of those other mistakes.<br></p><p>&gt; What I’m asking for in the proposal is the ability for library authors to chose to make a strong contract or a weak contract about the type of errors it can throw. Also, the other vital thing to note here is this: if I’m returning an enum that implements ErrorType, I’ve explicitly stated that these are the sum of the errors that I want to handle. Further, it only impacts the places in my code where I’ve explicitly chosen to handle the different cases of the error differently. If I were to instead specify a protocol or another type, the thing I’m getting out of that is the ability to use the APIs for those types without casting (that is also the exhaustive case, but suffers from none of the breaking change concerns you had above).<br>&gt; <br>&gt; It’s up to the library author to determine if their error types are a set of potential issues or a type that simply holds some information so that new error types can be added later. <br>&gt; <br>&gt;&gt;  If the OS is updated and the system API throws a new type of error does that mean my library is broken?<br>&gt; <br>&gt; Yes (if that error was defined as an enum), just like your libraries are broken if a library you use adds a new enum case; that’s a breaking change. You have the same problem today with this code:<br>&gt; <br>&gt; func f() -&gt; MyEnum { /* … */ }<br>&gt; let r = f()<br>&gt; switch r {<br>&gt;     case .First: /* do something */<br>&gt;     case .Last: /* do something */<br>&gt; }<br>&gt; <br>&gt; Do you also recommend always having a default case when working with enums throughout your code? This is just as fragile. <br>&gt; <br>&gt; Also, if the counter-argument is that ErrorType is sufficient for all error handling, then Swift should just make it a struct and let’s be done with it.<br></p><p>This doesn’t follow; there’s still clear value in being able to define new library-specific errors.  The ErrorType design is essentially an open enumeration, akin to the SML exn type, with a considerable bit more structure due to the grouping into types (which can then implement more specific and reflectively-discoverable protocols).<br></p><p>Again, I’m not opposed to allowing more specificity here eventually.  I just think it’s not really a good use of design and engineering resources right now, because I think simple “throws” is going to be the right design for libraries far more often than some more specific type, especially given that in practice most error types will almost always be resilient enums and therefore will not allow exhaustive pattern-matching outside of their defining module anyway.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/9481c558/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>My $0.02:<br></p><p>When the errors thrown by a protocol are constrained to just MyError, what are your options for reporting other types of errors that your implementation can generate (such as a database error, IO error, and so on). <br></p><p>Is wrapping one of those in a MyError really that useful? Does that mean a MyError enumeration is going to contain an .Other(ErrorType) case to deal with them? Why not (in that case) just have the calling code catch said other exceptions and deal with them generically?<br></p><p>- Documenting the specific errors that a method may throw is useful.<br>- Indicating for some functions that *only* those specific types can be thrown is useful, and may warrant compiler support (enforcement of said declaration, allowing exhaustive catches)<br>- Documenting that you may also get exceptions dependent on objects or closures that you have supplied is also useful. Rethrows implicitly does a little of this today.<br></p><p>I however point to Java as an example that exhaustive checked exceptions are a bad idea (and in Java, they aren’t even exhaustive - RuntimeException and Error types and subtypes are unchecked). The use of Errors as a signaling mechanism for alternate flows should be kept to a minimum.<br></p><p>-DW<br></p><p>&gt; On Dec 7, 2015, at 5:06 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn&#39;t it better to have the choice of type safety, and perhaps have a compiler option or linter to enforce it (if you choose).<br>&gt; <br>&gt; Default syntax:<br>&gt; func foo() throws; // defaults to ErrorType<br>&gt; <br>&gt; Optional type safety:<br>&gt; func foo() throws(MyError); // note, only one type.<br>&gt; <br>&gt; When it comes down to it, for me, the problem is that you can catch anything you like, and the check for exhaustivity does not check what may actually be thrown, resulting in excess code and compile-time errors.<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:24 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; IMHO be careful what you wish for. If the compiler enforces this then we&#39;re just repeating the mistakes of Java&#39;s checked exceptions. All roads would eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br>&gt; <br>&gt; russ<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/b7158d85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>My personal use case for typed throws would have been as a replacement<br>(within the context of an interpreter for a different language) for:<br></p><p>func doSomething() -&gt; Result&lt;T, MyInterpreterRuntimeError&gt; {<br>  guard someCondition() else {<br>    return .Failure(MyInterpreterRuntimeError(...))<br>  }<br>  guard anotherCondition() else {<br>    return .Failure(MyInterpreterRuntimeError(...))<br>  }<br>  // ...<br>  return .Success(T(...))<br>}<br></p><p>becomes...<br></p><p>func doSomething() (throws MyInterpreterRuntimeError) -&gt; T {<br>  guard someCondition() else {<br>    throw MyInterpreterRuntimeError(...)<br>  }<br>  guard anotherCondition() else {<br>    throw MyInterpreterRuntimeError(...)<br>  }<br>  // ...<br>  return T(...<br>}<br></p><p>The more I think about this use case, though, the more I feel like I&#39;m<br>misusing the mechanism for syntax sugar, as John alluded to earlier. If<br>this isn&#39;t a compelling argument for some sort of typed throws support,<br>though, I would at least like to see better support for a stdlib Result<br>type, although there are pitfalls there as well and that&#39;s a topic better<br>elaborated upon within a different thread.<br></p><p>Austin<br></p><p>On Mon, Dec 7, 2015 at 4:51 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My $0.02:<br>&gt;<br>&gt; When the errors thrown by a protocol are constrained to just MyError, what<br>&gt; are your options for reporting other types of errors that your<br>&gt; implementation can generate (such as a database error, IO error, and so<br>&gt; on).<br>&gt;<br>&gt; Is wrapping one of those in a MyError really that useful? Does that mean a<br>&gt; MyError enumeration is going to contain an .Other(ErrorType) case to deal<br>&gt; with them? Why not (in that case) just have the calling code catch said<br>&gt; other exceptions and deal with them generically?<br>&gt;<br>&gt; - Documenting the specific errors that a method may throw is useful.<br>&gt; - Indicating for some functions that *only* those specific types can be<br>&gt; thrown is useful, and may warrant compiler support (enforcement of said<br>&gt; declaration, allowing exhaustive catches)<br>&gt; - Documenting that you may also get exceptions dependent on objects or<br>&gt; closures that you have supplied is also useful. Rethrows implicitly does a<br>&gt; little of this today.<br>&gt;<br>&gt; I however point to Java as an example that exhaustive checked exceptions<br>&gt; are a bad idea (and in Java, they aren’t even exhaustive - RuntimeException<br>&gt; and Error types and subtypes are unchecked). The use of Errors as a<br>&gt; signaling mechanism for alternate flows should be kept to a minimum.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 7, 2015, at 5:06 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Isn&#39;t it better to have the choice of type safety, and perhaps have a<br>&gt; compiler option or linter to enforce it (if you choose).<br>&gt;<br>&gt; Default syntax:<br>&gt; func foo() throws; // defaults to ErrorType<br>&gt;<br>&gt; Optional type safety:<br>&gt; func foo() throws(MyError); // note, only one type.<br>&gt;<br>&gt; When it comes down to it, for me, the problem is that you can catch<br>&gt; anything you like, and the check for exhaustivity does not check what may<br>&gt; actually be thrown, resulting in excess code and compile-time errors.<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 9:24 AM, Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; IMHO be careful what you wish for. If the compiler enforces this then<br>&gt;&gt; we&#39;re just repeating the mistakes of Java&#39;s checked exceptions. All roads<br>&gt;&gt; would eventually lead to &quot;throws ErrorType&quot;, defeating the supposed purpose.<br>&gt;&gt;<br>&gt;&gt; russ<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/407d40ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
