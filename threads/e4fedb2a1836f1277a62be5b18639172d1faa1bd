<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>## Introduction<br></p><p>Tail call optimization can be a powerful tool when implementing certain<br>types of algorithms. Unfortunately, ARC&#39;s semantics interfere with our<br>ability to handle all possible cases of tail call recursion. An attribute,<br>similar to Scala&#39;s `tailrec`, along with LLVM warnings, could allow a clear<br>indicator of when such optimizations are not guaranteed to work.<br></p><p>## Motivation<br></p><p>LLVM will, currently, perform tail call optimization when possible cannot<br>guarantee such optimizations. ARC can interfere with tail call recursion by<br>inserting a method call after the intended &#39;last&#39; recursive call. The<br>ability to insert this call is fundamental to ARC and, because of this,<br>swift developers currently have no insight into when TCO can/will occur.<br></p><p>``` swift<br>func fact(input: Int) -&gt; Int {<br>    func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>        if n &lt;= 0 {<br>            return (0, value)<br>        } else {<br>            return _fact(n - 1, value: n * value)<br>        }<br>    }<br></p><p>    return _fact(input, value: 1).value<br>}<br>```<br>In the provided example, the developer can be sure that tail call<br>optimization is possible but, without either a universal guarantee or<br>something like the proposed attribute, there is no wait to be sure that<br>such an optimization will occur.<br></p><p>## Proposed solution<br></p><p>Providing an attribute would provide developers with concrete klnowledge of<br>when TCO can and will be performed by LLVM in compiling their swift code.<br></p><p>``` swift<br>func fact(input: Int) -&gt; Int {<br>@tailrec<br>    func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>        ...<br>```<br>With this attribute, the developer can express the desire for TCO and<br>warnings can be emitted if TCO cannot be guaranteed. If there are currently<br>only a few such cases, developers are made aware of what those cases are<br>and can design implementations with this information at hand. As LLVM&#39;s<br>ability to provide TCO increases, the allowed cases simply grow with no<br>effect for the initial narrow cases.<br></p><p><br>## Detailed design<br>In an ideal situation, implementation of this feature can consist solely of<br>the attribute and output from LLVM indicating whether or not the requested<br>ptimization can be guaranteed. This proposal does not call for an expansion<br>of accepted cases.<br></p><p>## Impact on existing code<br></p><p>This should not have any breaking impact as it is strictly additive and<br>diagnostic.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e4fea1bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 08:00:00am</p></header><div class="content"><p>I like this proposal and I like the general approach even more.  Allow the programmer to make an assertion about performance and receive a warning or error when the compiler cannot guarantee the assertion will be met.  This will make it easier to reason about the performance of code in a language where performance is extremely reliant on optimizations.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 5, 2015, at 7:55 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Tail call optimization can be a powerful tool when implementing certain types of algorithms. Unfortunately, ARC&#39;s semantics interfere with our ability to handle all possible cases of tail call recursion. An attribute, similar to Scala&#39;s `tailrec`, along with LLVM warnings, could allow a clear indicator of when such optimizations are not guaranteed to work.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; LLVM will, currently, perform tail call optimization when possible cannot guarantee such optimizations. ARC can interfere with tail call recursion by inserting a method call after the intended &#39;last&#39; recursive call. The ability to insert this call is fundamental to ARC and, because of this, swift developers currently have no insight into when TCO can/will occur.<br>&gt; <br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         if n &lt;= 0 {<br>&gt;             return (0, value)<br>&gt;         } else {<br>&gt;             return _fact(n - 1, value: n * value)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     return _fact(input, value: 1).value<br>&gt; }<br>&gt; ```<br>&gt; In the provided example, the developer can be sure that tail call optimization is possible but, without either a universal guarantee or something like the proposed attribute, there is no wait to be sure that such an optimization will occur.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Providing an attribute would provide developers with concrete klnowledge of when TCO can and will be performed by LLVM in compiling their swift code. <br>&gt; <br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt; 	@tailrec<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         ...<br>&gt; ```<br>&gt; With this attribute, the developer can express the desire for TCO and warnings can be emitted if TCO cannot be guaranteed. If there are currently only a few such cases, developers are made aware of what those cases are and can design implementations with this information at hand. As LLVM&#39;s ability to provide TCO increases, the allowed cases simply grow with no effect for the initial narrow cases.<br>&gt; <br>&gt; <br>&gt; ## Detailed design<br>&gt; In an ideal situation, implementation of this feature can consist solely of the attribute and output from LLVM indicating whether or not the requested ptimization can be guaranteed. This proposal does not call for an expansion of accepted cases.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This should not have any breaking impact as it is strictly additive and diagnostic.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/5fff9bdf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/900e19fd7259c4962c14f7fee2cc9789?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Per Melin</string> &lt;p at greendale.se&gt;<p>December  5, 2015 at 04:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015 at 2:55 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; Tail call optimization can be a powerful tool when implementing certain<br>&gt; types of algorithms. Unfortunately, ARC&#39;s semantics interfere with our<br>&gt; ability to handle all possible cases of tail call recursion. An attribute,<br>&gt; similar to Scala&#39;s `tailrec`, along with LLVM warnings, could allow a clear<br>&gt; indicator of when such optimizations are not guaranteed to work.<br>&gt;<br></p><p>I have primarily worked in functional languages with guaranteed tail call<br>elimination for many years. Turning to Swift, I (grudgingly) try to avoid<br>recursion altogether simply because of the risk of blowing the stack.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b17900f6/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 07:00:00am</p></header><div class="content"><p>Requiring an explicit &#39;tail&#39; annotation for tail calls is definitely the right way to approach this. However, ARC is not the only (or even the primary) reason tail recursion is problematic for Swift. ARC operations are not strictly ordered, unlike C++ destructors; the compiler is free to release values at any point after their last use. As long as a tail-callable function uses a convention where the callee takes ownership of all of its refcounted parameters, then ARC can avoid interfering with tail calls. However, there are other low-level resources that need to be managed in the case of an arbitrary tail call, such as space on the callstack and memory for indirectly-passed parameters. Being able to manage these would require a special machine-level calling convention that would have overhead we don&#39;t want to spend pervasively to make arbitrary functions tail-callable. Because of this, we&#39;d have to put further restrictions on what can be tail-called. Some options, in rough order of complexity, include:<br></p><p>- only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>- only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>- only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br></p><p>-Joe<br></p><p>&gt; On Dec 5, 2015, at 5:55 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Tail call optimization can be a powerful tool when implementing certain types of algorithms. Unfortunately, ARC&#39;s semantics interfere with our ability to handle all possible cases of tail call recursion. An attribute, similar to Scala&#39;s `tailrec`, along with LLVM warnings, could allow a clear indicator of when such optimizations are not guaranteed to work.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; LLVM will, currently, perform tail call optimization when possible cannot guarantee such optimizations. ARC can interfere with tail call recursion by inserting a method call after the intended &#39;last&#39; recursive call. The ability to insert this call is fundamental to ARC and, because of this, swift developers currently have no insight into when TCO can/will occur.<br>&gt; <br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         if n &lt;= 0 {<br>&gt;             return (0, value)<br>&gt;         } else {<br>&gt;             return _fact(n - 1, value: n * value)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     return _fact(input, value: 1).value<br>&gt; }<br>&gt; ```<br>&gt; In the provided example, the developer can be sure that tail call optimization is possible but, without either a universal guarantee or something like the proposed attribute, there is no wait to be sure that such an optimization will occur.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Providing an attribute would provide developers with concrete klnowledge of when TCO can and will be performed by LLVM in compiling their swift code. <br>&gt; <br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt; 	@tailrec<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         ...<br>&gt; ```<br>&gt; With this attribute, the developer can express the desire for TCO and warnings can be emitted if TCO cannot be guaranteed. If there are currently only a few such cases, developers are made aware of what those cases are and can design implementations with this information at hand. As LLVM&#39;s ability to provide TCO increases, the allowed cases simply grow with no effect for the initial narrow cases.<br>&gt; <br>&gt; <br>&gt; ## Detailed design<br>&gt; In an ideal situation, implementation of this feature can consist solely of the attribute and output from LLVM indicating whether or not the requested ptimization can be guaranteed. This proposal does not call for an expansion of accepted cases.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This should not have any breaking impact as it is strictly additive and diagnostic.<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1f5fc2da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December  6, 2015 at 12:00:00am</p></header><div class="content"><p>I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there<br>are other complications and it is interesting to note that ARC isn&#39;t the<br>the primary reason.<br></p><p>On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; - only allowing self-recursive tail calls, which avoid some of the stack<br>&gt; and memory management problems with arbitrary tail calls,<br>&gt; - only allowing tail calls between functions in the same module, so that<br>&gt; the compiler has enough information to use the tail-callable convention<br>&gt; only where needed,<br>&gt; - only allowing tail calls between functions in the same module or<br>&gt; external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;<br>&gt;<br>Even if none of these can be supported immediately, there is a case for<br>adding the attribute with the note that there are almost no supported<br>cases. Guaranteed support for self recursive tail calls, even if that is<br>all we added, would be a huge addition, in my opinion.<br></p><p>I don&#39;t know how useful the third option would be but the second case is<br>compelling. I am thinking of parser combinators in particular being a case<br>where the second option could help.<br></p><p>On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; Requiring an explicit &#39;tail&#39; annotation for tail calls is definitely the<br>&gt; right way to approach this. However, ARC is not the only (or even the<br>&gt; primary) reason tail recursion is problematic for Swift. ARC operations are<br>&gt; not strictly ordered, unlike C++ destructors; the compiler is free to<br>&gt; release values at any point after their last use. As long as a<br>&gt; tail-callable function uses a convention where the callee takes ownership<br>&gt; of all of its refcounted parameters, then ARC can avoid interfering with<br>&gt; tail calls. However, there are other low-level resources that need to be<br>&gt; managed in the case of an arbitrary tail call, such as space on the<br>&gt; callstack and memory for indirectly-passed parameters. Being able to manage<br>&gt; these would require a special machine-level calling convention that would<br>&gt; have overhead we don&#39;t want to spend pervasively to make arbitrary<br>&gt; functions tail-callable. Because of this, we&#39;d have to put further<br>&gt; restrictions on what can be tail-called. Some options, in rough order of<br>&gt; complexity, include:<br>&gt;<br>&gt; - only allowing self-recursive tail calls, which avoid some of the stack<br>&gt; and memory management problems with arbitrary tail calls,<br>&gt; - only allowing tail calls between functions in the same module, so that<br>&gt; the compiler has enough information to use the tail-callable convention<br>&gt; only where needed,<br>&gt; - only allowing tail calls between functions in the same module or<br>&gt; external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Dec 5, 2015, at 5:55 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Tail call optimization can be a powerful tool when implementing certain<br>&gt; types of algorithms. Unfortunately, ARC&#39;s semantics interfere with our<br>&gt; ability to handle all possible cases of tail call recursion. An attribute,<br>&gt; similar to Scala&#39;s `tailrec`, along with LLVM warnings, could allow a clear<br>&gt; indicator of when such optimizations are not guaranteed to work.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; LLVM will, currently, perform tail call optimization when possible cannot<br>&gt; guarantee such optimizations. ARC can interfere with tail call recursion by<br>&gt; inserting a method call after the intended &#39;last&#39; recursive call. The<br>&gt; ability to insert this call is fundamental to ARC and, because of this,<br>&gt; swift developers currently have no insight into when TCO can/will occur.<br>&gt;<br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         if n &lt;= 0 {<br>&gt;             return (0, value)<br>&gt;         } else {<br>&gt;             return _fact(n - 1, value: n * value)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     return _fact(input, value: 1).value<br>&gt; }<br>&gt; ```<br>&gt; In the provided example, the developer can be sure that tail call<br>&gt; optimization is possible but, without either a universal guarantee or<br>&gt; something like the proposed attribute, there is no wait to be sure that<br>&gt; such an optimization will occur.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Providing an attribute would provide developers with concrete klnowledge<br>&gt; of when TCO can and will be performed by LLVM in compiling their swift<br>&gt; code.<br>&gt;<br>&gt; ``` swift<br>&gt; func fact(input: Int) -&gt; Int {<br>&gt; @tailrec<br>&gt;     func _fact(n: Int, value: Int) -&gt; (n: Int, value:Int) {<br>&gt;         ...<br>&gt; ```<br>&gt; With this attribute, the developer can express the desire for TCO and<br>&gt; warnings can be emitted if TCO cannot be guaranteed. If there are currently<br>&gt; only a few such cases, developers are made aware of what those cases are<br>&gt; and can design implementations with this information at hand. As LLVM&#39;s<br>&gt; ability to provide TCO increases, the allowed cases simply grow with no<br>&gt; effect for the initial narrow cases.<br>&gt;<br>&gt;<br>&gt; ## Detailed design<br>&gt; In an ideal situation, implementation of this feature can consist solely<br>&gt; of the attribute and output from LLVM indicating whether or not the<br>&gt; requested ptimization can be guaranteed. This proposal does not call for an<br>&gt; expansion of accepted cases.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; This should not have any breaking impact as it is strictly additive and<br>&gt; diagnostic.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/65b8a10c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there are other complications and it is interesting to note that ARC isn&#39;t the the primary reason.<br>&gt; <br>&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt; <br>&gt; <br>&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt; <br>&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br></p><p>This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/3bc5dfb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 10:52 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there are other complications and it is interesting to note that ARC isn&#39;t the the primary reason.<br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt; <br>&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt; <br>&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br></p><p>One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. Either we accept this (which seems reasonable to me), or allow deferred blocks to be executed before the expression in a `tail return`, if there&#39;s a motivating reason.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/06b30c35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:58 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 5, 2015, at 10:52 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there are other complications and it is interesting to note that ARC isn&#39;t the the primary reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt; <br>&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt; <br>&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. Either we accept this (which seems reasonable to me), or allow deferred blocks to be executed before the expression in a `tail return`, if there&#39;s a motivating reason.<br></p><p>Wouldn&#39;t the latter potentially break code?<br></p><p>func f() -&gt; String {<br>  let fd = open(...)<br>  defer { close(fd) }<br>  return read(fd)<br>}<br></p><p>In other languages with TCO, defer-like constructs inhibit the optimization, and I see no reason to deviate from that here.<br></p><p>Slava<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/10b4d2bf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:58 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 5, 2015, at 10:52 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there are other complications and it is interesting to note that ARC isn&#39;t the the primary reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt; <br>&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt; <br>&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated.<br></p><p>It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br></p><p>We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br></p><p>Mark<br></p><p>&gt; Either we accept this (which seems reasonable to me), or allow deferred blocks to be executed before the expression in a `tail return`, if there&#39;s a motivating reason.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/84237a51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:58 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 10:52 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there are other complications and it is interesting to note that ARC isn&#39;t the the primary reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt; <br>&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated.<br>&gt; <br>&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br></p><p>Yeah, that&#39;s an interesting idea. It&#39;s possibly useful to have defers run after the tail call converges (though arguably you&#39;re probably better off just writing the loop version at this point).<br></p><p>&gt; <br>&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br></p><p>For ARC stuff it seems to me we can ensure all parameters are callee-consumed @owned or @in, and move any non-argument cleanups before the tail call, which eliminates the need for any continuation to be passed.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f3ab5287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December  8, 2015 at 04:00:00am</p></header><div class="content"><p>Since this clearly seems to have legs, I have started a gist with the<br>suggested additions here<br>https://gist.github.com/griotspeak/093ad8ec61d07dfcb8a2<br></p><p>Please feel free to continue discussion here or there.<br>TJ<br></p><p>On Tue, Dec 8, 2015 at 2:04 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 10:58 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 5, 2015, at 10:52 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 5, 2015, at 10:45 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; I did paint ARC as the sole culprit, didn&#39;t I? It makes sense that there<br>&gt; are other complications and it is interesting to note that ARC isn&#39;t the<br>&gt; the primary reason.<br>&gt;<br>&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack<br>&gt;&gt; and memory management problems with arbitrary tail calls,<br>&gt;&gt; - only allowing tail calls between functions in the same module, so that<br>&gt;&gt; the compiler has enough information to use the tail-callable convention<br>&gt;&gt; only where needed,<br>&gt;&gt; - only allowing tail calls between functions in the same module or<br>&gt;&gt; external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Even if none of these can be supported immediately, there is a case for<br>&gt; adding the attribute with the note that there are almost no supported<br>&gt; cases. Guaranteed support for self recursive tail calls, even if that is<br>&gt; all we added, would be a huge addition, in my opinion.<br>&gt;<br>&gt; I don&#39;t know how useful the third option would be but the second case is<br>&gt; compelling. I am thinking of parser combinators in particular being a case<br>&gt; where the second option could help.<br>&gt;<br>&gt;<br>&gt; This seems like a reasonable evolution path. Getting only self-tail-calls<br>&gt; working is indeed much simpler, and can likely be implemented mostly in<br>&gt; SILGen by jumping to the entry block, without any supporting backend work.<br>&gt; Arbitrary tail calls can be supported in the fullness of time.<br>&gt;<br>&gt;<br>&gt; One small thing: for completeness, any tail call proposal would have to<br>&gt; describe how it interacts with `defer`. As currently specified, `defer`<br>&gt; would have to block tail calling, since the deferred blocks occur after the<br>&gt; return expression is evaluated.<br>&gt;<br>&gt;<br>&gt; It seems like this could also be handled by passing continuations that<br>&gt; should be run on the return paths of callees. The continuation a function<br>&gt; passes to its callee would wrap the continuation passed to it by its<br>&gt; caller, so they would get executed in the original order. That’s an ABI<br>&gt; change though, and a potentially expensive one.<br>&gt;<br>&gt;<br>&gt; Yeah, that&#39;s an interesting idea. It&#39;s possibly useful to have defers run<br>&gt; after the tail call converges (though arguably you&#39;re probably better off<br>&gt; just writing the loop version at this point).<br>&gt;<br>&gt;<br>&gt; We’ve considered doing something like this as an optimization to enable<br>&gt; more proper tail calls in other cases (e.g. for the ARC case where you<br>&gt; release after return). This would be done by cloning callees, and adding a<br>&gt; new parameter. It’s not clear how worthwhile it would be to pursue this,<br>&gt; and how expensive it would be in terms of code bloat.<br>&gt;<br>&gt;<br>&gt; For ARC stuff it seems to me we can ensure all parameters are<br>&gt; callee-consumed @owned or @in, and move any non-argument cleanups before<br>&gt; the tail call, which eliminates the need for any continuation to be passed.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c5b45f3c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt; <br>&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. <br>&gt; <br>&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt; <br>&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br></p><p>Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br></p><p>Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/941ce3ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 3:03 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. <br>&gt;&gt; <br>&gt;&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt;&gt; <br>&gt;&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br>&gt; <br>&gt; Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br>&gt; <br>&gt; Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br></p><p>Right, I think we want both a modifier on calls and an attribute on functions that allows them to be used with the call modifier.  Joe is right that we can’t reliably do interprocedural tail calls without CC support, which is why the attribute is necessary; and I completely agree that the modifier which specifically requests a tail call is a must.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/66f77e3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 3:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 3:03 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br>&gt;&gt; <br>&gt;&gt; Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br>&gt;&gt; <br>&gt;&gt; Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br>&gt; <br>&gt; Right, I think we want both a modifier on calls and an attribute on functions that allows them to be used with the call modifier.  Joe is right that we can’t reliably do interprocedural tail calls without CC support, which is why the attribute is necessary; and I completely agree that the modifier which specifically requests a tail call is a must.<br></p><p>The function attribute is at least theoretically inferrable if for self-tail calls or calls between functions in the same module. It&#39;s only strictly necessary for public API that wants to be externally tail-callable.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/d5a70b91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 3:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Dec 7, 2015, at 3:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 3:03 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br>&gt;&gt; <br>&gt;&gt; Right, I think we want both a modifier on calls and an attribute on functions that allows them to be used with the call modifier.  Joe is right that we can’t reliably do interprocedural tail calls without CC support, which is why the attribute is necessary; and I completely agree that the modifier which specifically requests a tail call is a must.<br>&gt; <br>&gt; The function attribute is at least theoretically inferrable if for self-tail calls or calls between functions in the same module. It&#39;s only strictly necessary for public API that wants to be externally tail-callable.<br></p><p>Good point.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/6071eca0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 3:03 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:30 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,<br>&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,<br>&gt;&gt;&gt;&gt;&gt; - only allowing tail calls between functions in the same module or external functions marked with a &#39;@tail_callable&#39; attribute.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One small thing: for completeness, any tail call proposal would have to describe how it interacts with `defer`. As currently specified, `defer` would have to block tail calling, since the deferred blocks occur after the return expression is evaluated. <br>&gt;&gt; <br>&gt;&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt;&gt; <br>&gt;&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br>&gt; <br>&gt; Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br>&gt; <br>&gt; Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br></p><p>If you really don’t want to support defer in functions that have tail calls, I think what you&#39;re suggesting is the right approach. As Joe pointed out the optimization I had in mind wouldn’t be necessary if we had support for just transferring ownership at the point of these tail calls (as opposed to the retain/release we emit around the call for these arguments today).<br></p><p>Mark<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/8ce10cce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 7, 2015, at 3:18 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;&gt; It seems like this could also be handled by passing continuations that should be run on the return paths of callees. The continuation a function passes to its callee would wrap the continuation passed to it by its caller, so they would get executed in the original order. That’s an ABI change though, and a potentially expensive one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’ve considered doing something like this as an optimization to enable more proper tail calls in other cases (e.g. for the ARC case where you release after return). This would be done by cloning callees, and adding a new parameter. It’s not clear how worthwhile it would be to pursue this, and how expensive it would be in terms of code bloat.<br>&gt;&gt; <br>&gt;&gt; Why not just make “tail” a modifier on return that guarantees you’ll either get a tail call, or a compile time error?<br>&gt;&gt; <br>&gt;&gt; Use of “tail return foo()” in a context with a defer in flight could/should just produce that compile time error then.  This would provide the predictable programming model that people are seeking, and can provide good QoI so people know how to solve the problem if they really want the tail call (remove or change the defer).<br>&gt; <br>&gt; If you really don’t want to support defer in functions that have tail calls, I think what you&#39;re suggesting is the right approach. As Joe pointed out the optimization I had in mind wouldn’t be necessary if we had support for just transferring ownership at the point of these tail calls (as opposed to the retain/release we emit around the call for these arguments today).<br></p><p>I would really prefer that a “tail return” not change the semantics of the function, it merely is an assertion that the tail call is guaranteed.  This means that defer cannot be used, but we can exploit the “early destroy’s are ok” aspect of ARC to solve its issues.<br></p><p>I agree that this isn’t enough to solve the calling convention issue, an attribute or magic for self recursion seems fine to me.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/6a3be1c2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Tail Call Optimization keyword/attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 30, 2016 at 03:00:00am</p></header><div class="content"><p>Hello,<br></p><p>I&#39;ve updated the proposal and created a pull request. Please let me know if<br>it needs further updates<br>https://github.com/apple/swift-evolution/pull/103<br></p><p>TJ<br></p><p><br></p><p>On Tue, Dec 8, 2015 at 1:08 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 7, 2015, at 3:18 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt; It seems like this could also be handled by passing continuations that<br>&gt; should be run on the return paths of callees. The continuation a function<br>&gt; passes to its callee would wrap the continuation passed to it by its<br>&gt; caller, so they would get executed in the original order. That’s an ABI<br>&gt; change though, and a potentially expensive one.<br>&gt;<br>&gt; We’ve considered doing something like this as an optimization to enable<br>&gt; more proper tail calls in other cases (e.g. for the ARC case where you<br>&gt; release after return). This would be done by cloning callees, and adding a<br>&gt; new parameter. It’s not clear how worthwhile it would be to pursue this,<br>&gt; and how expensive it would be in terms of code bloat.<br>&gt;<br>&gt;<br>&gt; Why not just make “tail” a modifier on return that guarantees you’ll<br>&gt; either get a tail call, or a compile time error?<br>&gt;<br>&gt; Use of “tail return foo()” in a context with a defer in flight<br>&gt; could/should just produce that compile time error then.  This would provide<br>&gt; the predictable programming model that people are seeking, and can provide<br>&gt; good QoI so people know how to solve the problem if they really want the<br>&gt; tail call (remove or change the defer).<br>&gt;<br>&gt;<br>&gt; If you really don’t want to support defer in functions that have tail<br>&gt; calls, I think what you&#39;re suggesting is the right approach. As Joe pointed<br>&gt; out the optimization I had in mind wouldn’t be necessary if we had support<br>&gt; for just transferring ownership at the point of these tail calls (as<br>&gt; opposed to the retain/release we emit around the call for these arguments<br>&gt; today).<br>&gt;<br>&gt;<br>&gt; I would really prefer that a “tail return” not change the semantics of the<br>&gt; function, it merely is an assertion that the tail call is guaranteed.  This<br>&gt; means that defer cannot be used, but we can exploit the “early destroy’s<br>&gt; are ok” aspect of ARC to solve its issues.<br>&gt;<br>&gt; I agree that this isn’t enough to solve the calling convention issue, an<br>&gt; attribute or magic for self recursion seems fine to me.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/3dce4c2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
