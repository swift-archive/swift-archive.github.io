<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Conditional casting and conditional binding: Wierd edge case or flawed design</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Normally in guard and if condition lists, you look up a value in a dictionary and conditionally cast:<br></p><p>    if let value = dict[key] as? T, ...<br></p><p>The &quot;as?&quot; operator passes the Any? type through, and the lhs result is T, not T?.<br></p><p>* dict[key] returns Any?<br>* Any? as T returns T?, not T??<br>* the conditional binding binds T? to T<br>* PROFIT!<br></p><p>However, this (somewhat illogical) &quot;sugar&quot; doesn&#39;t happen when you conditionally cast T? to U, for example, when a dictionary is [AnyHashable: String]:<br></p><p>guard let value = dict[&quot;Key&quot;] as? NSString<br>    else { fatalError() }<br></p><p>(see http://i.imgur.com/SkXkk6o.jpg &lt;http://i.imgur.com/SkXkk6o.jpg&gt;)<br></p><p>* dict[key] returns String?<br>* String? as T is guaranteed to fail<br></p><p>In this case, the compiler asserts that a cast from String? to an unrelated type NSString always fails. You can mitigate this by sticking an &quot;Any&quot; cast in the middle:<br></p><p>guard let value = dict[&quot;Key&quot;] as Any as? NSString<br>    else { fatalError() }<br></p><p>If that&#39;s not &quot;magic&quot;, I don&#39;t know what is.  (You can also cast the dictionary to [AnyHashable: NSString], etc.)<br></p><p>Jack L&#39;s initial response: &quot;oh, that&#39;s a weird bridging edge case ðŸ˜• it seems like we should just make that work...&quot;  http://twitter.com/_jackhl/status/784998768898744320 &lt;http://twitter.com/_jackhl/status/784998768898744320&gt;) but he asked me to follow up here on SwiftEv. It seems to me that in conditional binding with conditional casting, you&#39;re asking the compiler to do not one but *two* magical things:<br></p><p>1. Apply what *looks* like assignment (I have a similar issue with if case/guard case) but is actually something else<br>2. Apply what *looks* like conditional casting but which magically passes Any? through to T?, not T??<br></p><p>I handwave this (but just the moment) and say &quot;it&#39;s not really an assignment, so it&#39;s not really a conditional cast&quot;. Jack asked me to bring this discussion over to Swift Evolution and ask the greater community whether Swift is doing these things right, and if not, how it should fix them. <br></p><p>Where I stand:<br></p><p>* If there&#39;s going to be magic, it should be documented (and it is not) in the Swift Programming Language<br>* If there&#39;s going to be magic, it should work for T?, not just Any?<br>* I&#39;d rather there not be magic here<br></p><p>-- E<br>p.s. I&#39;d also rather that if-case/guard-case would use &quot;:&quot; like in switch statements not &quot;=&quot;, but no one seems to be responding to that thread, dagnabit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/7c5d4a73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Conditional casting and conditional binding: Wierd edge case or flawed design</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 10, 2016 at 03:00:00am</p></header><div class="content"><p>A quick fix:<br></p><p>guard let value = dict[&quot;Key&quot;].map({ $0 as NSString }) {<br>    use(value)<br>}<br></p><p>Current behavior is quite logical: main purpose of as? is to perform casts,<br>which are not guaranteed to succeed. But Iâ€™d say that as? should also<br>support what you want.<br>â€‹<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/2d2f37a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Conditional casting and conditional binding: Wierd edge case or flawed design</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October  9, 2016 at 07:00:00pm</p></header><div class="content"><p>If you&#39;d like more context to the conversation:<br>How do I: Cast an optional string to NSString &lt;http://ericasadun.com/2016/10/08/how-do-i-cast-an-optional-string-to-nsstring/&gt;<br></p><p>-- E<br></p><p><br>&gt; On Oct 9, 2016, at 6:59 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; A quick fix:<br>&gt; <br>&gt; guard let value = dict[&quot;Key&quot;].map({ $0 as NSString }) {<br>&gt;     use(value)<br>&gt; }<br>&gt; Current behavior is quite logical: main purpose of as? is to perform casts, which are not guaranteed to succeed. But Iâ€™d say that as? should also support what you want.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/e83baec3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Conditional casting and conditional binding: Wierd edge case or flawed design</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 9, 2016, at 1:10 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Normally in guard and if condition lists, you look up a value in a dictionary and conditionally cast:<br>&gt; <br>&gt;     if let value = dict[key] as? T, ...<br>&gt; <br>&gt; The &quot;as?&quot; operator passes the Any? type through, and the lhs result is T, not T?.<br>&gt; <br>&gt; * dict[key] returns Any?<br>&gt; * Any? as T returns T?, not T??<br>&gt; * the conditional binding binds T? to T<br>&gt; * PROFIT!<br>&gt; <br>&gt; However, this (somewhat illogical) &quot;sugar&quot; doesn&#39;t happen when you conditionally cast T? to U, for example, when a dictionary is [AnyHashable: String]:<br>&gt; <br>&gt; guard let value = dict[&quot;Key&quot;] as? NSString<br>&gt;     else { fatalError() }<br>&gt; <br>&gt; (see http://i.imgur.com/SkXkk6o.jpg &lt;http://i.imgur.com/SkXkk6o.jpg&gt;)<br>&gt; <br>&gt; * dict[key] returns String?<br>&gt; * String? as T is guaranteed to fail<br>&gt; <br>&gt; In this case, the compiler asserts that a cast from String? to an unrelated type NSString always fails. You can mitigate this by sticking an &quot;Any&quot; cast in the middle:<br>&gt; <br>&gt; guard let value = dict[&quot;Key&quot;] as Any as? NSString<br>&gt;     else { fatalError() }<br>&gt; <br>&gt; If that&#39;s not &quot;magic&quot;, I don&#39;t know what is.  (You can also cast the dictionary to [AnyHashable: NSString], etc.)<br></p><p>This is a bug. &#39;String as NSString&#39; works, and you can cast through Optionals &#39;T? as? U&#39;, so transitively this also works, despite the misleading warning. Please file a bug report if you haven&#39;t yet.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/342aa911/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
