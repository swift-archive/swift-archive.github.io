<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br></p><p><br>The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br></p><p><br>Parameter Lists<br></p><p>‘var’ in a parameter list is problematic for a number of reasons:<br></p><p>- Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br></p><p>- Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br></p><p>- “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br></p><p><br>Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br></p><p>“var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br></p><p><br>Patterns<br></p><p>&quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br></p><p>- We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br></p><p>- Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br></p><p>- There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br></p><p><br>Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br></p><p><br>Case Patterns<br></p><p>We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>	case .Foo(var x):<br></p><p>- The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br></p><p>- That said, making a special case for this would make Swift less regular.<br></p><p><br>Conclusions: <br>- The core team decided to KEEP “var” here.<br>- We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br></p><p>Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br></p><p>-Swift Core Team<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a2b03c06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>Excellent news. Thanks to the relearn for the special case treatment of the issue and for the comprehensive breakdown.<br></p><p>Sent from my iPhone, please excuse brevity and errors<br></p><p>&gt; On Jan 28, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt; <br>&gt; <br>&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt; <br>&gt; <br>&gt; Parameter Lists<br>&gt; <br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt; <br>&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt; <br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt; <br>&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt; <br>&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt; <br>&gt; <br>&gt; Patterns<br>&gt; <br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt; <br>&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt; <br>&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt; <br>&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt; <br>&gt; <br>&gt; Case Patterns<br>&gt; <br>&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt; 	case .Foo(var x):<br>&gt; <br>&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt; <br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt; <br>&gt; <br>&gt; Conclusions: <br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt; <br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt; <br>&gt; -Swift Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/53ac60a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 29, 2016 at 07:00:00am</p></header><div class="content"><p>Huge +1 from me. Thanks!<br></p><p>-Thorsten<br></p><p>&gt; Am 29.01.2016 um 06:57 schrieb Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Excellent news. Thanks to the relearn for the special case treatment of the issue and for the comprehensive breakdown.<br>&gt; <br>&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameter Lists<br>&gt;&gt; <br>&gt;&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;&gt; <br>&gt;&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt;&gt; <br>&gt;&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt;&gt; <br>&gt;&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt;&gt; <br>&gt;&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Patterns<br>&gt;&gt; <br>&gt;&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt;&gt; <br>&gt;&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt;&gt; <br>&gt;&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt;&gt; <br>&gt;&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Case Patterns<br>&gt;&gt; <br>&gt;&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt;&gt; 	case .Foo(var x):<br>&gt;&gt; <br>&gt;&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt;&gt; <br>&gt;&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusions: <br>&gt;&gt; - The core team decided to KEEP “var” here.<br>&gt;&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt;&gt; <br>&gt;&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt;&gt; <br>&gt;&gt; -Swift Core Team<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/52b5caac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 28, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 This is great!<br></p><p>&gt; On Jan 28, 2016, at 10:05 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Huge +1 from me. Thanks!<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 29.01.2016 um 06:57 schrieb Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Excellent news. Thanks to the relearn for the special case treatment of the issue and for the comprehensive breakdown.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parameter Lists<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patterns<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Case Patterns<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt;&gt;&gt; 	case .Foo(var x):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conclusions: <br>&gt;&gt;&gt; - The core team decided to KEEP “var” here.<br>&gt;&gt;&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Swift Core Team<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/f7ac89d1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>+3 from me — one for each of the conclusions. This sounds exactly right.<br></p><p>If I understand correctly, we now alllmost have a nice language-wide uniformity:<br></p><p>• Anywhere the syntax allows “let” it also allows “var,” and vice versa.<br>• Where they’re allowed, exactly one of them _must_ appear.<br></p><p>The exception I can think of is for loops, where the iterator variable’s “let” is still implied. (Are there others?) It would be more uniform, I suppose, to require this:<br></p><p>	for let i in 0..&lt;256<br></p><p>…but that just looks intolerably awkward to my eyes.<br></p><p>Cheers, P<br></p><p><br>&gt; On Jan 28, 2016, at 11:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt; <br>&gt; <br>&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt; <br>&gt; <br>&gt; Parameter Lists<br>&gt; <br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt; <br>&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt; <br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt; <br>&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt; <br>&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt; <br>&gt; <br>&gt; Patterns<br>&gt; <br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt; <br>&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt; <br>&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt; <br>&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt; <br>&gt; <br>&gt; Case Patterns<br>&gt; <br>&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt; 	case .Foo(var x):<br>&gt; <br>&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt; <br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt; <br>&gt; <br>&gt; Conclusions: <br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt; <br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt; <br>&gt; -Swift Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/aa3c33db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 29, 2016 at 08:00:00am</p></header><div class="content"><p>A very reasonable decision! It is also good to know that accepted proposals are not “absolute” but will be reviewed again if  necessary. <br></p><p>— Taras<br></p><p>&gt; On 29 Jan 2016, at 07:20, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +3 from me — one for each of the conclusions. This sounds exactly right.<br>&gt; <br>&gt; If I understand correctly, we now alllmost have a nice language-wide uniformity:<br>&gt; <br>&gt; • Anywhere the syntax allows “let” it also allows “var,” and vice versa.<br>&gt; • Where they’re allowed, exactly one of them _must_ appear.<br>&gt; <br>&gt; The exception I can think of is for loops, where the iterator variable’s “let” is still implied. (Are there others?) It would be more uniform, I suppose, to require this:<br>&gt; <br>&gt; 	for let i in 0..&lt;256<br>&gt; <br>&gt; …but that just looks intolerably awkward to my eyes.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 11:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameter Lists<br>&gt;&gt; <br>&gt;&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;&gt; <br>&gt;&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt;&gt; <br>&gt;&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt;&gt; <br>&gt;&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt;&gt; <br>&gt;&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Patterns<br>&gt;&gt; <br>&gt;&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt;&gt; <br>&gt;&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt;&gt; <br>&gt;&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt;&gt; <br>&gt;&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Case Patterns<br>&gt;&gt; <br>&gt;&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt;&gt; 	case .Foo(var x):<br>&gt;&gt; <br>&gt;&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt;&gt; <br>&gt;&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conclusions: <br>&gt;&gt; - The core team decided to KEEP “var” here.<br>&gt;&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt;&gt; <br>&gt;&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt;&gt; <br>&gt;&gt; -Swift Core Team<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f41b6105/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br>Ondrej<br></p><p>On Fri, Jan 29, 2016 at 8:14 AM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A very reasonable decision! It is also good to know that accepted<br>&gt; proposals are not “absolute” but will be reviewed again if  necessary.<br>&gt;<br>&gt; — Taras<br>&gt;<br>&gt; On 29 Jan 2016, at 07:20, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +3 from me — one for each of the conclusions. This sounds exactly right.<br>&gt;<br>&gt; If I understand correctly, we now alllmost have a nice language-wide<br>&gt; uniformity:<br>&gt;<br>&gt; • Anywhere the syntax allows “let” it also allows “var,” and vice versa.<br>&gt; • Where they’re allowed, exactly one of them _must_ appear.<br>&gt;<br>&gt; The exception I can think of is for loops, where the iterator variable’s<br>&gt; “let” is still implied. (Are there others?) It would be more uniform, I<br>&gt; suppose, to require this:<br>&gt;<br>&gt; for let i in 0..&lt;256<br>&gt;<br>&gt; …but that just looks intolerably awkward to my eyes.<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;<br>&gt; On Jan 28, 2016, at 11:41 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The core team met to discuss SE-0003, and we have a new conclusion,<br>&gt; described below.  As was mentioned on the other thread, this proposal is a<br>&gt; bit unusual because it predates Swift open source, and thus didn’t go<br>&gt; through the full evolution process, nor did it get the normal public review<br>&gt; that would come with it.<br>&gt;<br>&gt;<br>&gt; The core team broke this proposal down into a few different cases, each of<br>&gt; which came to a different conclusion.  To be clear up front, this is not a<br>&gt; clear-cut topic, and there are opinions on all sides.  Here are the<br>&gt; decisions the core team came to, along with some rationale:<br>&gt;<br>&gt;<br>&gt; *Parameter Lists*<br>&gt;<br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;<br>&gt; - Parameter lists currently allow both “inout” and “var”, and real<br>&gt; confusion occurs for some people learning swift that expect “var” to<br>&gt; provide reference semantics.<br>&gt;<br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor<br>&gt; “var” really make sense there.  Parameters were patterns in a much older<br>&gt; swift design, but that was eliminated a long time ago and this aspect never<br>&gt; got reconsidered.<br>&gt;<br>&gt; - “var” in a parameter list is odd because it is an implementation detail<br>&gt; being foisted on the interface to the function.  To be fair, we already<br>&gt; have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger<br>&gt; semantic implementation detail.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let”<br>&gt; from parameter lists.<br>&gt;<br>&gt; “var” in a parameter list is convenient sugar that defines away some minor<br>&gt; boilerplate (the shadowing copy), however, the cost benefit tradeoff<br>&gt; doesn’t pay enough to keep it.<br>&gt;<br>&gt;<br>&gt; *Patterns*<br>&gt;<br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka<br>&gt; &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We<br>&gt; discussed whether to eliminate var from this, with much more mixed results:<br>&gt;<br>&gt; - We currently have a duality across the language between var and let<br>&gt; which is common, unifying, and works really well in practice.  Eliminating<br>&gt; var from pattern matching would make the language less uniform, because<br>&gt; patterns wouldn’t align with var/let declarations.<br>&gt;<br>&gt; - Working in Swift *demands* that you get an early grasp on what value<br>&gt; semantics means, and “var x = y” is always a copy of the value.  As such,<br>&gt; based on the strong duality mentioned above, it is reasonable to expect<br>&gt; people to learn that “if var x = y” produces a copy and not a reference<br>&gt; binding.<br>&gt;<br>&gt; - There certainly is confusion from people who expect “if var” to do a<br>&gt; reference binding, despite the comment directly above.  However, we feel<br>&gt; that this is more of a point-in-time confusion than the parameter case,<br>&gt; given that the parameter case exposes the ‘var’ as part of the function<br>&gt; signature.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in<br>&gt; patterns.<br>&gt;<br>&gt;<br>&gt; *Case Patterns*<br>&gt;<br>&gt; We had an additional discussion focused specifically on whether it would<br>&gt; make sense to ban var in case patterns, e.g.:<br>&gt; case .Foo(var x):<br>&gt;<br>&gt; - The core team agrees that this specific case is a common point of<br>&gt; confusion, particularly because Swift doesn’t provide a way to get a<br>&gt; mutable binding to the associated value in an enum.<br>&gt;<br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;<br>&gt;<br>&gt; Conclusions:<br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change<br>&gt; &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for<br>&gt; patterns.<br>&gt;<br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to<br>&gt; keep using it, but people who just mash the “fixit” button to silence the<br>&gt; compiler won’t get surprising behavior.<br>&gt;<br>&gt; -Swift Core Team<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/affa8962/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 on all accounts<br></p><p>On Fri, Jan 29, 2016 at 3:21 AM Ondrej Barina via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt; Ondrej<br>&gt;<br>&gt; On Fri, Jan 29, 2016 at 8:14 AM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; A very reasonable decision! It is also good to know that accepted<br>&gt;&gt; proposals are not “absolute” but will be reviewed again if  necessary.<br>&gt;&gt;<br>&gt;&gt; — Taras<br>&gt;&gt;<br>&gt;&gt; On 29 Jan 2016, at 07:20, Paul Cantrell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +3 from me — one for each of the conclusions. This sounds exactly right.<br>&gt;&gt;<br>&gt;&gt; If I understand correctly, we now alllmost have a nice language-wide<br>&gt;&gt; uniformity:<br>&gt;&gt;<br>&gt;&gt; • Anywhere the syntax allows “let” it also allows “var,” and vice versa.<br>&gt;&gt; • Where they’re allowed, exactly one of them _must_ appear.<br>&gt;&gt;<br>&gt;&gt; The exception I can think of is for loops, where the iterator variable’s<br>&gt;&gt; “let” is still implied. (Are there others?) It would be more uniform, I<br>&gt;&gt; suppose, to require this:<br>&gt;&gt;<br>&gt;&gt; for let i in 0..&lt;256<br>&gt;&gt;<br>&gt;&gt; …but that just looks intolerably awkward to my eyes.<br>&gt;&gt;<br>&gt;&gt; Cheers, P<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 28, 2016, at 11:41 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The core team met to discuss SE-0003, and we have a new conclusion,<br>&gt;&gt; described below.  As was mentioned on the other thread, this proposal is a<br>&gt;&gt; bit unusual because it predates Swift open source, and thus didn’t go<br>&gt;&gt; through the full evolution process, nor did it get the normal public review<br>&gt;&gt; that would come with it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The core team broke this proposal down into a few different cases, each<br>&gt;&gt; of which came to a different conclusion.  To be clear up front, this is not<br>&gt;&gt; a clear-cut topic, and there are opinions on all sides.  Here are the<br>&gt;&gt; decisions the core team came to, along with some rationale:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Parameter Lists*<br>&gt;&gt;<br>&gt;&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;&gt;<br>&gt;&gt; - Parameter lists currently allow both “inout” and “var”, and real<br>&gt;&gt; confusion occurs for some people learning swift that expect “var” to<br>&gt;&gt; provide reference semantics.<br>&gt;&gt;<br>&gt;&gt; - Parameter lists are not “patterns” in the language, so neither “let”<br>&gt;&gt; nor “var” really make sense there.  Parameters were patterns in a much<br>&gt;&gt; older swift design, but that was eliminated a long time ago and this aspect<br>&gt;&gt; never got reconsidered.<br>&gt;&gt;<br>&gt;&gt; - “var” in a parameter list is odd because it is an implementation detail<br>&gt;&gt; being foisted on the interface to the function.  To be fair, we already<br>&gt;&gt; have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger<br>&gt;&gt; semantic implementation detail.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Conclusion: The core team decided that we should REMOVE “var” and “let”<br>&gt;&gt; from parameter lists.<br>&gt;&gt;<br>&gt;&gt; “var” in a parameter list is convenient sugar that defines away some<br>&gt;&gt; minor boilerplate (the shadowing copy), however, the cost benefit tradeoff<br>&gt;&gt; doesn’t pay enough to keep it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Patterns*<br>&gt;&gt;<br>&gt;&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka<br>&gt;&gt; &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We<br>&gt;&gt; discussed whether to eliminate var from this, with much more mixed results:<br>&gt;&gt;<br>&gt;&gt; - We currently have a duality across the language between var and let<br>&gt;&gt; which is common, unifying, and works really well in practice.  Eliminating<br>&gt;&gt; var from pattern matching would make the language less uniform, because<br>&gt;&gt; patterns wouldn’t align with var/let declarations.<br>&gt;&gt;<br>&gt;&gt; - Working in Swift *demands* that you get an early grasp on what value<br>&gt;&gt; semantics means, and “var x = y” is always a copy of the value.  As such,<br>&gt;&gt; based on the strong duality mentioned above, it is reasonable to expect<br>&gt;&gt; people to learn that “if var x = y” produces a copy and not a reference<br>&gt;&gt; binding.<br>&gt;&gt;<br>&gt;&gt; - There certainly is confusion from people who expect “if var” to do a<br>&gt;&gt; reference binding, despite the comment directly above.  However, we feel<br>&gt;&gt; that this is more of a point-in-time confusion than the parameter case,<br>&gt;&gt; given that the parameter case exposes the ‘var’ as part of the function<br>&gt;&gt; signature.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in<br>&gt;&gt; patterns.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Case Patterns*<br>&gt;&gt;<br>&gt;&gt; We had an additional discussion focused specifically on whether it would<br>&gt;&gt; make sense to ban var in case patterns, e.g.:<br>&gt;&gt; case .Foo(var x):<br>&gt;&gt;<br>&gt;&gt; - The core team agrees that this specific case is a common point of<br>&gt;&gt; confusion, particularly because Swift doesn’t provide a way to get a<br>&gt;&gt; mutable binding to the associated value in an enum.<br>&gt;&gt;<br>&gt;&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Conclusions:<br>&gt;&gt; - The core team decided to KEEP “var” here.<br>&gt;&gt; - We will stop leading people into it by eliminating the &quot;note: change<br>&gt;&gt; &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for<br>&gt;&gt; patterns.<br>&gt;&gt;<br>&gt;&gt; Eliminating the note allows users sufficiently knowledgable about Swift<br>&gt;&gt; to keep using it, but people who just mash the “fixit” button to silence<br>&gt;&gt; the compiler won’t get surprising behavior.<br>&gt;&gt;<br>&gt;&gt; -Swift Core Team<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f682ced2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>+1, glad to see this revisited.  Agree with the new decisions.<br></p><p>&gt; On Jan 28, 2016, at 11:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt; <br>&gt; <br>&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt; <br>&gt; <br>&gt; Parameter Lists<br>&gt; <br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt; <br>&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt; <br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt; <br>&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt; <br>&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt; <br>&gt; <br>&gt; Patterns<br>&gt; <br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt; <br>&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt; <br>&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt; <br>&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt; <br>&gt; <br>&gt; Case Patterns<br>&gt; <br>&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt; 	case .Foo(var x):<br>&gt; <br>&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt; <br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt; <br>&gt; <br>&gt; Conclusions: <br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt; <br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt; <br>&gt; -Swift Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/a9218bb6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 :-) Thank the team for the decision and guidance.<br></p><p>On Friday, January 29, 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The core team met to discuss SE-0003, and we have a new conclusion,<br>&gt; described below.  As was mentioned on the other thread, this proposal is a<br>&gt; bit unusual because it predates Swift open source, and thus didn’t go<br>&gt; through the full evolution process, nor did it get the normal public review<br>&gt; that would come with it.<br>&gt;<br>&gt;<br>&gt; The core team broke this proposal down into a few different cases, each of<br>&gt; which came to a different conclusion.  To be clear up front, this is not a<br>&gt; clear-cut topic, and there are opinions on all sides.  Here are the<br>&gt; decisions the core team came to, along with some rationale:<br>&gt;<br>&gt;<br>&gt; *Parameter Lists*<br>&gt;<br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;<br>&gt; - Parameter lists currently allow both “inout” and “var”, and real<br>&gt; confusion occurs for some people learning swift that expect “var” to<br>&gt; provide reference semantics.<br>&gt;<br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor<br>&gt; “var” really make sense there.  Parameters were patterns in a much older<br>&gt; swift design, but that was eliminated a long time ago and this aspect never<br>&gt; got reconsidered.<br>&gt;<br>&gt; - “var” in a parameter list is odd because it is an implementation detail<br>&gt; being foisted on the interface to the function.  To be fair, we already<br>&gt; have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger<br>&gt; semantic implementation detail.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let”<br>&gt; from parameter lists.<br>&gt;<br>&gt; “var” in a parameter list is convenient sugar that defines away some minor<br>&gt; boilerplate (the shadowing copy), however, the cost benefit tradeoff<br>&gt; doesn’t pay enough to keep it.<br>&gt;<br>&gt;<br>&gt; *Patterns*<br>&gt;<br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka<br>&gt; &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We<br>&gt; discussed whether to eliminate var from this, with much more mixed results:<br>&gt;<br>&gt; - We currently have a duality across the language between var and let<br>&gt; which is common, unifying, and works really well in practice.  Eliminating<br>&gt; var from pattern matching would make the language less uniform, because<br>&gt; patterns wouldn’t align with var/let declarations.<br>&gt;<br>&gt; - Working in Swift *demands* that you get an early grasp on what value<br>&gt; semantics means, and “var x = y” is always a copy of the value.  As such,<br>&gt; based on the strong duality mentioned above, it is reasonable to expect<br>&gt; people to learn that “if var x = y” produces a copy and not a reference<br>&gt; binding.<br>&gt;<br>&gt; - There certainly is confusion from people who expect “if var” to do a<br>&gt; reference binding, despite the comment directly above.  However, we feel<br>&gt; that this is more of a point-in-time confusion than the parameter case,<br>&gt; given that the parameter case exposes the ‘var’ as part of the function<br>&gt; signature.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in<br>&gt; patterns.<br>&gt;<br>&gt;<br>&gt; *Case Patterns*<br>&gt;<br>&gt; We had an additional discussion focused specifically on whether it would<br>&gt; make sense to ban var in case patterns, e.g.:<br>&gt; case .Foo(var x):<br>&gt;<br>&gt; - The core team agrees that this specific case is a common point of<br>&gt; confusion, particularly because Swift doesn’t provide a way to get a<br>&gt; mutable binding to the associated value in an enum.<br>&gt;<br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt;<br>&gt;<br>&gt; Conclusions:<br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change<br>&gt; &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for<br>&gt; patterns.<br>&gt;<br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to<br>&gt; keep using it, but people who just mash the “fixit” button to silence the<br>&gt; compiler won’t get surprising behavior.<br>&gt;<br>&gt; -Swift Core Team<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/b0df1f10/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;ll miss parameter vars a little bit, but the reasoning for removing them is solid. Really glad to see vars remain in patterns. Thanks to the Swift core team for being open to reconsidering this!<br></p><p>Jarod<br></p><p>&gt; On Jan 28, 2016, at 21:41, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt; <br>&gt; <br>&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt; <br>&gt; <br>&gt; Parameter Lists<br>&gt; <br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt; <br>&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt; <br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt; <br>&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt; <br>&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt; <br>&gt; <br>&gt; Patterns<br>&gt; <br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt; <br>&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt; <br>&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt; <br>&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt; <br>&gt; <br>&gt; Case Patterns<br>&gt; <br>&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt; 	case .Foo(var x):<br>&gt; <br>&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt; <br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt; <br>&gt; <br>&gt; Conclusions: <br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt; <br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt; <br>&gt; -Swift Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/35c9895b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>This is great news! Thank you for being willing to reconsider this<br>proposal. And the explanation given in this email is really great. Even<br>though I stated earlier that ditching `var` in parameter lists is mildly<br>annoying, the rationale given here is very compelling. And the reasons<br>for keeping &quot;var&quot; everywhere else are spot-on too.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Jan 28, 2016, at 09:41 PM, Chris Lattner via swift-evolution wrote:<br>&gt; The core team met to discuss SE-0003, and we have a new conclusion,<br>&gt; described below.  As was mentioned on the other thread, this proposal<br>&gt; is a bit unusual because it predates Swift open source, and thus<br>&gt; didn’t go through the full evolution process, nor did it get the<br>&gt; normal public review that would come with it.<br>&gt;<br>&gt;<br>&gt; The core team broke this proposal down into a few different cases,<br>&gt; each of which came to a different conclusion.  To be clear up front,<br>&gt; this is not a clear-cut topic, and there are opinions on all sides.<br>&gt; Here are the decisions the core team came to, along with some<br>&gt; rationale:<br>&gt;<br>&gt;<br>&gt; *Parameter Lists*<br>&gt;<br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt;<br>&gt; - Parameter lists currently allow both “inout” and “var”, and real<br>&gt;   confusion occurs for some people learning swift that expect “var” to<br>&gt;   provide reference semantics.<br>&gt;<br>&gt; - Parameter lists are not “patterns” in the language, so neither “let”<br>&gt;   nor “var” really make sense there.  Parameters were patterns in a<br>&gt;   much older swift design, but that was eliminated a long time ago and<br>&gt;   this aspect never got reconsidered.<br>&gt;<br>&gt; - “var” in a parameter list is odd because it is an implementation<br>&gt;   detail being foisted on the interface to the function.  To be fair,<br>&gt;   we already have this with &quot;API names&quot; vs &quot;internal names”, but this<br>&gt;   is a bigger semantic implementation detail.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should REMOVE “var” and<br>&gt; “let” from parameter lists.<br>&gt;<br>&gt; “var” in a parameter list is convenient sugar that defines away some<br>&gt; minor boilerplate (the shadowing copy), however, the cost benefit<br>&gt; tradeoff doesn’t pay enough to keep it.<br>&gt;<br>&gt;<br>&gt; *Patterns*<br>&gt;<br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar<br>&gt; (aka &quot;pattern matching&quot; and “destructuring” features described in<br>&gt; TSPL).  We discussed whether to eliminate var from this, with much<br>&gt; more mixed results:<br>&gt;<br>&gt; - We currently have a duality across the language between var and let<br>&gt;   which is common, unifying, and works really well in practice.<br>&gt;   Eliminating var from pattern matching would make the language less<br>&gt;   uniform, because patterns wouldn’t align with var/let declarations.<br>&gt;<br>&gt; - Working in Swift *demands* that you get an early grasp on what value<br>&gt;   semantics means, and “var x = y” is always a copy of the value.  As<br>&gt;   such, based on the strong duality mentioned above, it is reasonable<br>&gt;   to expect people to learn that “if var x = y” produces a copy and<br>&gt;   not a reference binding.<br>&gt;<br>&gt; - There certainly is confusion from people who expect “if var” to do a<br>&gt;   reference binding, despite the comment directly above.  However, we<br>&gt;   feel that this is more of a point-in-time confusion than the<br>&gt;   parameter case, given that the parameter case exposes the ‘var’ as<br>&gt;   part of the function signature.<br>&gt;<br>&gt;<br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let”<br>&gt; in patterns.<br>&gt;<br>&gt;<br>&gt; *Case Patterns*<br>&gt;<br>&gt; We had an additional discussion focused specifically on whether it<br>&gt; would make sense to ban var in case patterns, e.g.: case .Foo(var x):<br>&gt;<br>&gt; - The core team agrees that this specific case is a common point of<br>&gt;   confusion, particularly because Swift doesn’t provide a way to get a<br>&gt;   mutable binding to the associated value in an enum.<br>&gt;<br>&gt; - That said, making a special case for this would make Swift less<br>&gt;   regular.<br>&gt;<br>&gt;<br>&gt; Conclusions:<br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change<br>&gt;   &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces<br>&gt;   for patterns.<br>&gt;<br>&gt; Eliminating the note allows users sufficiently knowledgable about<br>&gt; Swift to keep using it, but people who just mash the “fixit” button to<br>&gt; silence the compiler won’t get surprising behavior.<br>&gt;<br>&gt; -Swift Core Team<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/8e0fdc50/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>A.M.A.Z.I.N.G.<br></p><p>Thanks for letting us know!<br></p><p>R+<br></p><p>&gt; On 29 Jan 2016, at 06:41, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The core team met to discuss SE-0003, and we have a new conclusion, described below.  As was mentioned on the other thread, this proposal is a bit unusual because it predates Swift open source, and thus didn’t go through the full evolution process, nor did it get the normal public review that would come with it.<br>&gt; <br>&gt; <br>&gt; The core team broke this proposal down into a few different cases, each of which came to a different conclusion.  To be clear up front, this is not a clear-cut topic, and there are opinions on all sides.  Here are the decisions the core team came to, along with some rationale:<br>&gt; <br>&gt; <br>&gt; Parameter Lists<br>&gt; <br>&gt; ‘var’ in a parameter list is problematic for a number of reasons:<br>&gt; <br>&gt; - Parameter lists currently allow both “inout” and “var”, and real confusion occurs for some people learning swift that expect “var” to provide reference semantics.<br>&gt; <br>&gt; - Parameter lists are not “patterns” in the language, so neither “let” nor “var” really make sense there.  Parameters were patterns in a much older swift design, but that was eliminated a long time ago and this aspect never got reconsidered.<br>&gt; <br>&gt; - “var” in a parameter list is odd because it is an implementation detail being foisted on the interface to the function.  To be fair, we already have this with &quot;API names&quot; vs &quot;internal names”, but this is a bigger semantic implementation detail.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should REMOVE “var” and “let” from parameter lists.<br>&gt; <br>&gt; “var” in a parameter list is convenient sugar that defines away some minor boilerplate (the shadowing copy), however, the cost benefit tradeoff doesn’t pay enough to keep it.<br>&gt; <br>&gt; <br>&gt; Patterns<br>&gt; <br>&gt; &quot;if var”, “for var”, &quot;if case var&quot; etc all use the pattern grammar (aka &quot;pattern matching&quot; and “destructuring” features described in TSPL).  We discussed whether to eliminate var from this, with much more mixed results:<br>&gt; <br>&gt; - We currently have a duality across the language between var and let which is common, unifying, and works really well in practice.  Eliminating var from pattern matching would make the language less uniform, because patterns wouldn’t align with var/let declarations.<br>&gt; <br>&gt; - Working in Swift *demands* that you get an early grasp on what value semantics means, and “var x = y” is always a copy of the value.  As such, based on the strong duality mentioned above, it is reasonable to expect people to learn that “if var x = y” produces a copy and not a reference binding.<br>&gt; <br>&gt; - There certainly is confusion from people who expect “if var” to do a reference binding, despite the comment directly above.  However, we feel that this is more of a point-in-time confusion than the parameter case, given that the parameter case exposes the ‘var’ as part of the function signature.<br>&gt; <br>&gt; <br>&gt; Conclusion: The core team decided that we should KEEP “var” and “let” in patterns.<br>&gt; <br>&gt; <br>&gt; Case Patterns<br>&gt; <br>&gt; We had an additional discussion focused specifically on whether it would make sense to ban var in case patterns, e.g.:<br>&gt; 	case .Foo(var x):<br>&gt; <br>&gt; - The core team agrees that this specific case is a common point of confusion, particularly because Swift doesn’t provide a way to get a mutable binding to the associated value in an enum.<br>&gt; <br>&gt; - That said, making a special case for this would make Swift less regular.<br>&gt; <br>&gt; <br>&gt; Conclusions: <br>&gt; - The core team decided to KEEP “var” here.<br>&gt; - We will stop leading people into it by eliminating the &quot;note: change &#39;let&#39; to &#39;var&#39; to make it mutable” note that the compiler produces for patterns.<br>&gt; <br>&gt; Eliminating the note allows users sufficiently knowledgable about Swift to keep using it, but people who just mash the “fixit” button to silence the compiler won’t get surprising behavior.<br>&gt; <br>&gt; -Swift Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/4d712cdf/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
