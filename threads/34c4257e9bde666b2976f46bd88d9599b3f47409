<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 26, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br></p><p>	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br></p><p>the proposal follows, and is available here as well:<br></p><p>	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br></p><p>Comments appreciated!<br></p><p>Generalized Naming for Any Function<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: Awaiting Review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br></p><p>Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br></p><p>Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br></p><p>It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br></p><p>extension UIView {<br>  func insertSubview(view: UIView, at index: Int)<br>  func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>  func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>}<br>When calling these methods, the argument labels distinguish the different methods, e.g.,<br></p><p>someView.insertSubview(view, at: 3)<br>someView.insertSubview(view, aboveSubview: otherView)<br>someView.insertSubview(view, belowSubview: otherView)<br>However, when referencing the function to create a function value, one cannot provide the labels:<br></p><p>let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>In some cases, it is possible to use type annotations to disambiguate:<br></p><p>let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>To resolve the latter case, one must fall back to creating a closure:<br></p><p>let fn: (UIView, UIView) = { view, otherView in<br>  button.insertSubview(view, otherView)<br>}<br>which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br></p><p>extension UIButton {<br>  var currentTitle: String? { ... }<br>}<br></p><p>var fn: () -&gt; String? = { () in<br>  return button.currentTitle<br>}<br>One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br></p><p>Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br></p><p>func `try`() -&gt; Bool { ... }<br>declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br></p><p>Compound names can be written entirely within the back-ticks, e.g.,<br></p><p>let fn = someView.`insertSubview(_:at:)`<br>let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>The same syntax can also refer to initializers, e.g.,<br></p><p>let buttonFactory = UIButton.`init(type:)`<br>Getters and setters can be written using dotted syntax within the back-ticks:<br></p><p>let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br></p><p>extension Matrix {<br>  subscript (row row: Int) -&gt; [Double] {<br>    get { ... }<br>    set { ... }<br>  }<br>}<br></p><p>let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br></p><p>self.`myProperty.lazy`.clear()<br>Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br></p><p>extension Font {<br>  func `subscript`() -&gt; Font {<br>    // return the subscript version of the given font<br>  }<br>}<br></p><p>let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br></p><p>let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br> &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br></p><p>Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br></p><p>let specificTitle = button.currentTitle#get<br>The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br></p><p>let fn = someView.insertSubview#(_:at:)<br>which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br></p><p>Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br></p><p>Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br></p><p>let fn = someView.insertSubview(_:at:)<br>can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br></p><p>extension Optional {<br>  func get() -&gt; T { return self! }<br>}<br></p><p>let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>let fn2 = set.removeAllElements()   // call or reference?<br></p><p><br>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/34c47409/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 26, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br></p><p>This link doesn&#39;t work; in fact, you don&#39;t seem to have *any* public repositories.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 26, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 11:43 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt; <br>&gt; This link doesn&#39;t work; in fact, you don&#39;t seem to have *any* public repositories.<br></p><p>Ah, thanks. I’ve made the repository public.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December 27, 2015 at 03:00:00am</p></header><div class="content"><p>Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br></p><p>In reference to the issues noted with this approach:<br></p><p>IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br></p><p>I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br></p><p>Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br></p><p>FKL<br></p><p>On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt; <br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt; <br>&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt; <br>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; Comments appreciated!<br>&gt; <br>&gt; Generalized Naming for Any Function<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt; <br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; <br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt; <br>&gt; func `try`() -&gt; Bool { ... }<br>&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt; <br>&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt; <br>&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt; <br>&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt; <br>&gt; extension Matrix {<br>&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;     get { ... }<br>&gt;     set { ... }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt; <br>&gt; self.`myProperty.lazy`.clear()<br>&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt; <br>&gt; extension Font {<br>&gt;   func `subscript`() -&gt; Font {<br>&gt;     // return the subscript version of the given font<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt; <br>&gt; let specificTitle = button.currentTitle#get<br>&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt; <br>&gt; let fn = someView.insertSubview#(_:at:)<br>&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt; <br>&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt; <br>&gt; extension Optional {<br>&gt;   func get() -&gt; T { return self! }<br>&gt; }<br>&gt; <br>&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/76c22374/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/265868676ac8f12472cc3cc0fc59d827?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Nicky Gerritsen</string> &lt;nickygerritsen at me.com&gt;<p>December 27, 2015 at 10:00:00am</p></header><div class="content"><p>I have to agree with Frederick that the two-backticks example looks horrible ;-). I guess the # way worjs better in that case.<br></p><p>I’m not entirely sure about his second remark: if we require that references to functions without arguments are written without parenthesis, don’t we then have some inconsistency? i.e. functions without arguments are obj.func while functions with arguments are obj.func(_:y:). I’m not really in favor of this inconsistency. But I’m not really sure currently how we can easily solve this without creating more strange inconsistencies...<br></p><p>Regards,<br></p><p>Nicky<br></p><p>&gt; On 27 dec. 2015, at 09:27, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br>&gt; <br>&gt; In reference to the issues noted with this approach:<br>&gt; <br>&gt; IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br>&gt; <br>&gt; I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br>&gt; <br>&gt; Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br>&gt; <br>&gt; FKL<br>&gt; <br>&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension UIButton {<br>&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;   return button.currentTitle<br>&gt;&gt; }<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt; <br>&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt; <br>&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt; <br>&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt; <br>&gt;&gt; extension Font {<br>&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt; <br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/fce41530/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 27, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 12:27 AM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br>&gt; <br>&gt; In reference to the issues noted with this approach:<br>&gt; <br>&gt; IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br>&gt; <br>&gt; I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br>&gt; <br>&gt; Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br></p><p>Not having the back-ticks means that you will need to use contextual type information to disambiguate the zero-parameter case from other cases. For example:<br></p><p>	class Foo {<br>		func doSomething() { }<br>		func doSomething(value: Int) { }<br>	}<br></p><p>	let fn = Foo.doSomething // ambiguous<br>	let fn2 = Foo.doSomething(_:) // okay<br>	let fn3: (Foo) -&gt; () -&gt; Void = Foo.doSomething // okay<br>	let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething // okay<br></p><p>My general complaint with the “drop the backticks” approach is that it doesn’t solve the whole problem. Sure, it solves 95% of the problem with a little less syntax, but now you need to invent yet another mechanism to handle the other cases (#set, contextual type disambiguation, etc)… which seems inconsistent to me.<br></p><p>	- Doug<br></p><p><br>&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension UIButton {<br>&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;   return button.currentTitle<br>&gt;&gt; }<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt; <br>&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt; <br>&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt; <br>&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt; <br>&gt;&gt; extension Font {<br>&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt; <br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/490907df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>Commentary inline below.<br></p><p>FKL<br></p><p>&gt; On Dec 27, 2015, at 8:40 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 12:27 AM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br>&gt;&gt; <br>&gt;&gt; In reference to the issues noted with this approach:<br>&gt;&gt; <br>&gt;&gt; IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br>&gt;&gt; <br>&gt;&gt; I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br>&gt;&gt; <br>&gt;&gt; Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br>&gt; <br>&gt; Not having the back-ticks means that you will need to use contextual type information to disambiguate the zero-parameter case from other cases. For example:<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		func doSomething() { }<br>&gt; 		func doSomething(value: Int) { }<br>&gt; 	}<br>&gt; <br>&gt; 	let fn = Foo.doSomething // ambiguous<br>&gt; 	let fn2 = Foo.doSomething(_:) // okay<br>&gt; 	let fn3: (Foo) -&gt; () -&gt; Void = Foo.doSomething // okay<br>&gt; 	let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething // okay<br></p><p>Why does Foo.doSomething have to be ambiguous? I would say that if this system is implemented (especially if without backticks), Foo.doSomething should only be able to refer to the no-argument overload of doSomething (i.e. &quot;let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething&quot; would be an error). This would break existing code that relies on the type disambiguation, but we would be able to offer a replacement for it.<br></p><p>&gt; My general complaint with the “drop the backticks” approach is that it doesn’t solve the whole problem. Sure, it solves 95% of the problem with a little less syntax, but now you need to invent yet another mechanism to handle the other cases (#set, contextual type disambiguation, etc)… which seems inconsistent to me.<br></p><p>I feel as though backticks are the inconsistent approach in this case, especially because they already have one meaning in Swift that is used in the same context (as Chris notes). The &#39;natural&#39; solution to me would be to refer to method references by writing them like a call without arguments, just like the name of a selector in Objective C.<br></p><p>Backticks also have the unfortunate properties of being relatively unknown characters to those who may not have a lot of programming experience, and at first glance are hard to differentiate from single quotes. In the context of using keywords as identifiers, I don&#39;t see those to be as big of issues, because except in very specific cases the easier solution is simply &quot;come up with a different name for your identifier&quot;. To have to use backticks whenever a method reference is desired is, IMO, confusing and cluttered syntax.<br></p><p>I think that the best solution is to extend the current syntax as naturally as possible, and only introduce the backticks (or other syntax) as needed in cases such as obj.`property.get` (or obj.property#get). Obviously my notion of &#39;natural&#39; is going to differ from others&#39;, but I think that most would agree that being able to write &quot;Foo.doSomething(_:bar:)&quot; is a more intuitive extension of the syntax than &quot;Foo.`doSomething(_:bar:)`.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here, continued here. See the Alternatives considered section for commentary on that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael Henson proposed naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/d69d1422/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 28, 2015 at 09:00:00am</p></header><div class="content"><p>Do things get any better if we combine the proposed changes and remove the<br>bare case? Begin function reference with some symbol (# here but it doesn&#39;t<br>matter), only use back tics to disambiguate keywords (which lines up with<br>their current use) and remove the unadorned case to avoid ambiguity.<br></p><p>```swift<br>class Foo {<br>func doSomething() { }<br>func doSomething(value: Int) { }<br>func sub<br>}<br></p><p>let fn = Foo#doSomething // no longer allowed<br>let fn = Foo#doSomething() // okay<br>let fn2 = Foo#doSomething(_:) // okay<br></p><p>// and<br></p><p>let getRow = someMatrix#`subscript`(row:).get<br></p><p>```<br></p><p><br></p><p>On Sun, Dec 27, 2015 at 10:40 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 27, 2015, at 12:27 AM, Frederick Kellison-Linn via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would<br>&gt; strongly lean towards the no-backtick alternative mentioned at the end. I<br>&gt; feel as though the backticks end up looking very cluttered (particularly<br>&gt; when you get into the double-nested backticks), and it seems cleaner to be<br>&gt; able to reference a method as it was declared rather than having to add<br>&gt; extra syntax.<br>&gt;<br>&gt; In reference to the issues noted with this approach:<br>&gt;<br>&gt; IMO, there is already enough syntactic difference between getters/setters<br>&gt; and normal methods to justify requiring a different syntax to reference<br>&gt; them. For instance, the # syntax could be used so that,<br>&gt; button.currentTitle.get would reference Optional&lt;String&gt;.get, and<br>&gt; button.currentTitle#get would reference the getter. Or,<br>&gt; button.`currentTitle.get` could reference the getter (i.e. backticks are<br>&gt; only required in cases that are ambiguous).<br>&gt;<br>&gt; I also think it is reasonable to require that in the case of a method with<br>&gt; no arguments such as set.removeAllElements, the programmer be expected to<br>&gt; know the difference between the expression with and without the trailing<br>&gt; parenthesis. After all, that distinction already exists in the language,<br>&gt; and would not disappear with this proposed addition. If a parallel syntax<br>&gt; for referencing methods with no arguments is strongly desired, perhaps<br>&gt; something such as set.removeAllElements(:), set#removeAllElements(), or<br>&gt; similar could be used, though I think that the present system for<br>&gt; referencing these methods is sufficient.<br>&gt;<br>&gt; Are there other obvious reasons why this alternative wouldn’t work? I<br>&gt; think it is the cleanest of the alternatives and avoids littering the code<br>&gt; with backticks.<br>&gt;<br>&gt;<br>&gt; Not having the back-ticks means that you will need to use contextual type<br>&gt; information to disambiguate the zero-parameter case from other cases. For<br>&gt; example:<br>&gt;<br>&gt; class Foo {<br>&gt; func doSomething() { }<br>&gt; func doSomething(value: Int) { }<br>&gt; }<br>&gt;<br>&gt; let fn = Foo.doSomething // ambiguous<br>&gt; let fn2 = Foo.doSomething(_:) // okay<br>&gt; let fn3: (Foo) -&gt; () -&gt; Void = Foo.doSomething // okay<br>&gt; let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething // okay<br>&gt;<br>&gt; My general complaint with the “drop the backticks” approach is that it<br>&gt; doesn’t solve the whole problem. Sure, it solves 95% of the problem with a<br>&gt; little less syntax, but now you need to invent yet another mechanism to<br>&gt; handle the other cases (#set, contextual type disambiguation, etc)… which<br>&gt; seems inconsistent to me.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In<br>&gt; effect, it’s continuing the discussion of retrieving getters and setters as<br>&gt; functions started by Michael Henson here:<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;<br>&gt; the proposal follows, and is available here as well:<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;<br>&gt; Comments appreciated!<br>&gt;<br>&gt; Generalized Naming for Any Function<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting Review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift includes support for first-class functions, such that any function<br>&gt; (or method) can be placed into a value of function type. However, it is not<br>&gt; possible to specifically name every function that is part of a Swift<br>&gt; program---one cannot provide the argument labels when naming a function,<br>&gt; nor are property and subscript getters and setters referenceable. This<br>&gt; proposal introduces a general syntax that allows one to name anything that<br>&gt; is a function within Swift in an extensible manner.<br>&gt;<br>&gt; Swift-evolution thread: Michael Henson started a thread about the<br>&gt; getter/setter issue here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;,<br>&gt; continued here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;.<br>&gt; See the Alternatives considered<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section<br>&gt; for commentary on that discussion.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the<br>&gt; same &quot;base name&quot;, but be distinguished by parameter labels. For example,<br>&gt; UIView has three methods with the same base name insertSubview:<br>&gt;<br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt;<br>&gt; When calling these methods, the argument labels distinguish the different<br>&gt; methods, e.g.,<br>&gt;<br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;<br>&gt; However, when referencing the function to create a function value, one<br>&gt; cannot provide the labels:<br>&gt;<br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;<br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;<br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt;<br>&gt; which is painfully tedious. A similar workaround is required to produce a<br>&gt; function value for a getter of a property, e.g.,<br>&gt;<br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt;<br>&gt; One additional bit of motivation: Swift should probably get some way to<br>&gt; ask for the Objective-C selector for a given method (rather than writing a<br>&gt; string literal). The argument to such an operation would likely be a<br>&gt; reference to a method, which would benefit from being able to name any<br>&gt; method, including getters and setters.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords<br>&gt; for names, which would otherwise fail to parse. For example,<br>&gt;<br>&gt; func `try`() -&gt; Bool { ... }<br>&gt;<br>&gt; declares a function named try, even though try is a keyword. I propose to<br>&gt; extend the back-tick syntax to allow compound Swift names (e.g.,<br>&gt; insertSubview(_:aboveSubview:)) and references to the accessors of<br>&gt; properties (e.g., the getter for currentTitle). Specifically,<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;<br>&gt;    let fn = someView.`insertSubview(_:at:)`let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;<br>&gt;    The same syntax can also refer to initializers, e.g.,<br>&gt;<br>&gt;    let buttonFactory = UIButton.`init(type:)`<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Getters and setters can be written using dotted syntax within the<br>&gt;    back-ticks:<br>&gt;<br>&gt;    let specificTitle = button.`currentTitle.get` // has type () -&gt; String?let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;<br>&gt;    The same syntax works with subscript getters and setters as well,<br>&gt;    using the full name of the subscript:<br>&gt;<br>&gt;    extension Matrix {<br>&gt;      subscript (row row: Int) -&gt; [Double] {<br>&gt;        get { ... }<br>&gt;        set { ... }<br>&gt;      }<br>&gt;    }<br>&gt;    let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;<br>&gt;    If we introduce property behaviors into Swift, the back-tick syntax<br>&gt;    could also be used to refer to behaviors, e.g., accessing the lazy behavior<br>&gt;    of a property:<br>&gt;<br>&gt;    self.`myProperty.lazy`.clear()<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Base names that are meaningful keywords (init and subscript) can be<br>&gt;    escaped with a nested pair of back-ticks:<br>&gt;<br>&gt;    extension Font {<br>&gt;      func `subscript`() -&gt; Font {<br>&gt;        // return the subscript version of the given font<br>&gt;      }<br>&gt;    }<br>&gt;    let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;<br>&gt;<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will<br>&gt; be the subject of a separate proposal. However, here is one possibility<br>&gt; that illustrations how it uses the proposed syntax here:<br>&gt;<br>&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This is a purely additive feature that has no impact on existing code. The<br>&gt; syntactic space it uses is already present, and it merely extends the use<br>&gt; of back-ticks from storing a single identifier to more complex names.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Michael Henson proposed<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming<br>&gt;    getters and setters using # syntax followed by get or set, e.g.,<br>&gt;<br>&gt;    let specificTitle = button.currentTitle#get<br>&gt;<br>&gt;    The use of postfix # is a reasonable alternative here, and more<br>&gt;    lightweight than two back-ticks for the simple getter/setter case. The<br>&gt;    notion could be extended to allow argument labels for functions, discussed<br>&gt;    here<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;.<br>&gt;    The proposals in that discussion actually included type annotations as<br>&gt;    well, but the syntax seems cleaner---and more directly focused on<br>&gt;    *names*---without them, e.g.,:<br>&gt;<br>&gt;    let fn = someView.insertSubview#(_:at:)<br>&gt;<br>&gt;    which works. I didn&#39;t go with this syntax because (1) it breaks up<br>&gt;    Swift method names such as insertSubview(_:at:)with an # in the<br>&gt;    middle, and (2) while useful, this feature doesn&#39;t seem important enough to<br>&gt;    justify overloading #further.<br>&gt;    -<br>&gt;<br>&gt;    Joe Groff notes<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt;<br>&gt;     that *lenses* are a better solution than manually retrieving<br>&gt;    getter/setter functions when the intent is to actually operate on the<br>&gt;    properties. That weakens the case this proposal makes for making<br>&gt;    getters/setters available as functions. However, it doesn&#39;t address the<br>&gt;    general naming issue or the desire to retrieve the Objective-C selector for<br>&gt;    a getter/setter.<br>&gt;    -<br>&gt;<br>&gt;    Can we drop the back-ticks? It&#39;s very tempting to want to drop the<br>&gt;    back-ticks entirely, because something like<br>&gt;<br>&gt;    let fn = someView.insertSubview(_:at:)<br>&gt;<br>&gt;    can be correctly parsed as a reference to insertSubview(_:at:).<br>&gt;    However, it breaks down at the margins, e.g., with getter/setter references<br>&gt;    or no-argument functions:<br>&gt;<br>&gt;    extension Optional {<br>&gt;      func get() -&gt; T { return self! }<br>&gt;    }<br>&gt;    let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?let fn2 = set.removeAllElements()   // call or reference?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/9ec2e94d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 28, 2015 at 05:00:00pm</p></header><div class="content"><p>Looks good so far.<br></p><p>Top-level functions:<br></p><p>#doSomething()<br>ModuleName#doSomething() // is it a problem to distinguish modules and classes here?<br></p><p>What about static/class functions? Any idea how to fit them into that scheme?<br></p><p>-Thorsten<br></p><p>&gt; Am 28.12.2015 um 16:05 schrieb T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Do things get any better if we combine the proposed changes and remove the bare case? Begin function reference with some symbol (# here but it doesn&#39;t matter), only use back tics to disambiguate keywords (which lines up with their current use) and remove the unadorned case to avoid ambiguity.<br>&gt; <br>&gt; ```swift <br>&gt; class Foo {<br>&gt; 	func doSomething() { }<br>&gt; 	func doSomething(value: Int) { }<br>&gt; 	func sub<br>&gt; }<br>&gt; <br>&gt; let fn = Foo#doSomething // no longer allowed<br>&gt; let fn = Foo#doSomething() // okay<br>&gt; let fn2 = Foo#doSomething(_:) // okay<br>&gt; <br>&gt; // and<br>&gt; <br>&gt; let getRow = someMatrix#`subscript`(row:).get<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Dec 27, 2015 at 10:40 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 12:27 AM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In reference to the issues noted with this approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br>&gt;&gt; <br>&gt;&gt; Not having the back-ticks means that you will need to use contextual type information to disambiguate the zero-parameter case from other cases. For example:<br>&gt;&gt; <br>&gt;&gt; 	class Foo {<br>&gt;&gt; 		func doSomething() { }<br>&gt;&gt; 		func doSomething(value: Int) { }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	let fn = Foo.doSomething // ambiguous<br>&gt;&gt; 	let fn2 = Foo.doSomething(_:) // okay<br>&gt;&gt; 	let fn3: (Foo) -&gt; () -&gt; Void = Foo.doSomething // okay<br>&gt;&gt; 	let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething // okay<br>&gt;&gt; <br>&gt;&gt; My general complaint with the “drop the backticks” approach is that it doesn’t solve the whole problem. Sure, it solves 95% of the problem with a little less syntax, but now you need to invent yet another mechanism to handle the other cases (#set, contextual type disambiguation, etc)… which seems inconsistent to me.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here, continued here. See the Alternatives considered section for commentary on that discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Michael Henson proposed naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/72ceeb26/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>Does this bridge over to referencing properties, such as using:<br></p><p>struct Bar {<br>   var counter:Int = 0<br>}<br></p><p>let fn3 = Bar#counter.get<br></p><p>-DW<br></p><p><br>&gt; On Dec 28, 2015, at 8:05 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do things get any better if we combine the proposed changes and remove the bare case? Begin function reference with some symbol (# here but it doesn&#39;t matter), only use back tics to disambiguate keywords (which lines up with their current use) and remove the unadorned case to avoid ambiguity.<br>&gt; <br>&gt; ```swift <br>&gt; class Foo {<br>&gt; 	func doSomething() { }<br>&gt; 	func doSomething(value: Int) { }<br>&gt; 	func sub<br>&gt; }<br>&gt; <br>&gt; let fn = Foo#doSomething // no longer allowed<br>&gt; let fn = Foo#doSomething() // okay<br>&gt; let fn2 = Foo#doSomething(_:) // okay<br>&gt; <br>&gt; // and<br>&gt; <br>&gt; let getRow = someMatrix#`subscript`(row:).get<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Dec 27, 2015 at 10:40 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 12:27 AM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given that someView.insertSubview(_:at:) can be correctly parsed, I would strongly lean towards the no-backtick alternative mentioned at the end. I feel as though the backticks end up looking very cluttered (particularly when you get into the double-nested backticks), and it seems cleaner to be able to reference a method as it was declared rather than having to add extra syntax.<br>&gt;&gt; <br>&gt;&gt; In reference to the issues noted with this approach:<br>&gt;&gt; <br>&gt;&gt; IMO, there is already enough syntactic difference between getters/setters and normal methods to justify requiring a different syntax to reference them. For instance, the # syntax could be used so that, button.currentTitle.get would reference Optional&lt;String&gt;.get, and button.currentTitle#get would reference the getter. Or, button.`currentTitle.get` could reference the getter (i.e. backticks are only required in cases that are ambiguous).<br>&gt;&gt; <br>&gt;&gt; I also think it is reasonable to require that in the case of a method with no arguments such as set.removeAllElements, the programmer be expected to know the difference between the expression with and without the trailing parenthesis. After all, that distinction already exists in the language, and would not disappear with this proposed addition. If a parallel syntax for referencing methods with no arguments is strongly desired, perhaps something such as set.removeAllElements(:), set#removeAllElements(), or similar could be used, though I think that the present system for referencing these methods is sufficient.<br>&gt;&gt; <br>&gt;&gt; Are there other obvious reasons why this alternative wouldn’t work? I think it is the cleanest of the alternatives and avoids littering the code with backticks.<br>&gt; <br>&gt; Not having the back-ticks means that you will need to use contextual type information to disambiguate the zero-parameter case from other cases. For example:<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		func doSomething() { }<br>&gt; 		func doSomething(value: Int) { }<br>&gt; 	}<br>&gt; <br>&gt; 	let fn = Foo.doSomething // ambiguous<br>&gt; 	let fn2 = Foo.doSomething(_:) // okay<br>&gt; 	let fn3: (Foo) -&gt; () -&gt; Void = Foo.doSomething // okay<br>&gt; 	let fn3: (Foo) -&gt; (Int) -&gt; Void = Foo.doSomething // okay<br>&gt; <br>&gt; My general complaint with the “drop the backticks” approach is that it doesn’t solve the whole problem. Sure, it solves 95% of the problem with a little less syntax, but now you need to invent yet another mechanism to handle the other cases (#set, contextual type disambiguation, etc)… which seems inconsistent to me.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/a989cd12/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 27, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt; <br>&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt; <br>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; Comments appreciated!<br>&gt; <br>&gt; Generalized Naming for Any Function<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt; <br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; <br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt; <br>&gt; func `try`() -&gt; Bool { ... }<br>&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt; <br>&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt; <br>&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.`init(type:)`<br>This part seems reasonable to me.<br>&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt; <br>&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt; <br>&gt; extension Matrix {<br>&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;     get { ... }<br>&gt;     set { ... }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br></p><p>I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors, and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br>&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt; <br>&gt; extension Optional {<br>&gt;   func get() -&gt; T { return self! }<br>&gt; }<br>&gt; <br>&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt; let fn2 = set.removeAllElements()   // call or reference?<br>From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/2807c077/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 27, 2015 at 12:00:00pm</p></header><div class="content"><p>Some more things to consider:<br></p><p>- Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br></p><p>- How do labeled references interact with default and variadic arguments? If you have a func foo(x: Int = 0, y: String = 0), can you refer to foo(x:) and foo(y:) to apply some of the defaulted arguments, or only foo(x:y:)? Would foo(y:x:) also work?<br></p><p>-Joe<br></p><p>&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension UIButton {<br>&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;   return button.currentTitle<br>&gt;&gt; }<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt; <br>&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt; <br>&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt; This part seems reasonable to me.<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br>&gt; <br>&gt; I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors, and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/3489deb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 28, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 3:32 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some more things to consider:<br>&gt; <br>&gt; - Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br></p><p>Any reason not to put in a proposal to change this everywhere, e.g., diagnostics?<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/288639b8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>December 28, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 1:32 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some more things to consider:<br>&gt; <br>&gt; - Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br></p><p>At first glance it seems like we can remove the parens altogether if we went with this approach. Could instance.`foo:bar:` work (instance.`foo` in the no-arg case)? I’m not sure how removing parens would work for inits and subscripts though.<br></p><p>&gt; - How do labeled references interact with default and variadic arguments? If you have a func foo(x: Int = 0, y: String = 0), can you refer to foo(x:) and foo(y:) to apply some of the defaulted arguments, or only foo(x:y:)? Would foo(y:x:) also work?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt; This part seems reasonable to me.<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br>&gt;&gt; <br>&gt;&gt; I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors, and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br>&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/eb5e1875/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 11:47 AM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 27, 2015, at 1:32 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some more things to consider:<br>&gt;&gt; <br>&gt;&gt; - Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br>&gt; <br>&gt; At first glance it seems like we can remove the parens altogether if we went with this approach. Could instance.`foo:bar:` work (instance.`foo` in the no-arg case)? I’m not sure how removing parens would work for inits and subscripts though.<br></p><p>While the conventions encourage the first parameter to be unlabeled, it doesn&#39;t enforce it (and there are exceptions in the standard library, like `removeAll(keepCapacity:)`, as well as `stride(to:…)` and `stride(through:…)`.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/592418d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 10:24 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 28, 2015, at 11:47 AM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Dec 27, 2015, at 1:32 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some more things to consider:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br>&gt;&gt; <br>&gt;&gt; At first glance it seems like we can remove the parens altogether if we went with this approach. Could instance.`foo:bar:` work (instance.`foo` in the no-arg case)? I’m not sure how removing parens would work for inits and subscripts though.<br>&gt; <br>&gt; While the conventions encourage the first parameter to be unlabeled, it doesn&#39;t enforce it (and there are exceptions in the standard library, like `removeAll(keepCapacity:)`, as well as `stride(to:…)` and `stride(through:…)`.<br>&gt; <br>&gt; Stephen<br></p><p>Ah right, great point :-)<br></p><p>- Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/55128aec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 28, 2015 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 28, 2015, at 9:26 AM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 10:24 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 11:47 AM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 27, 2015, at 1:32 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some more things to consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Our naming conventions encourage the first parameter to most methods to be unlabeled, so unlabeled parameters come up a lot. I don&#39;t think there&#39;s a grammatical requirement for an identifier before each colon; maybe we can leave out the underscore and use `foo(:bar:)` instead of `foo(_:bar:)` to refer to unlabeled arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At first glance it seems like we can remove the parens altogether if we went with this approach. Could instance.`foo:bar:` work (instance.`foo` in the no-arg case)? I’m not sure how removing parens would work for inits and subscripts though.<br>&gt;&gt; <br>&gt;&gt; While the conventions encourage the first parameter to be unlabeled, it doesn&#39;t enforce it (and there are exceptions in the standard library, like `removeAll(keepCapacity:)`, as well as `stride(to:…)` and `stride(through:…)`.<br>&gt;&gt; <br>&gt;&gt; Stephen<br>&gt; <br>&gt; Ah right, great point :-)<br></p><p>... And initializers, which often have a labeled first argument, also need to fit the syntax. <br></p><p>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/fbe268cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 27, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br>&gt; <br>&gt; I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors, and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br></p><p>I know this might be too early, but: what syntax are we thinking of for lenses?  We might want to design this with future consistency in mind.<br></p><p>John.<br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/0834531f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 2:47 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br>&gt;&gt; <br>&gt;&gt; I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors, and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br>&gt; <br>&gt; I know this might be too early, but: what syntax are we thinking of for lenses?  We might want to design this with future consistency in mind.<br></p><p>Vaguely, I think it could look something like this. You could define a lens function by having it return `inout`. Calling the function produces an lvalue whose access nests within the accesses of its input `inout` parameters, if any, allowing for things like:<br></p><p>var localVar = 1<br>let localRef: () -&gt; inout Int = { &amp;localVar }<br></p><p>func second(inout array: [Int]) -&gt; inout Int {<br>  return &amp;array[1]<br>}<br></p><p>// Maybe you can define an inout function with accessors too<br>func fahrenheit(inout celsius: Double) -&gt; inout Double {<br>  get {<br>    return celsius * 9/5 + 32<br>  }<br>  set {<br>    celsius = (newValue - 32) * 5/9<br>  }<br>}<br></p><p>and you could access the unapplied lens for an instance property using `Type.property` syntax, analogous to how `Type.method` works. I feel like if we did that, then it would obviate the need for explicit `property.get` or `property.set` for most native Swift uses, though maybe not ObjC interop uses.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/64511b37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 28, 2015 at 07:00:00pm</p></header><div class="content"><p>And if we only make the actual type inference more powerful?<br></p><p>Using the examples on proposal:<br></p><p>extension UIView {<br>  func insertSubview(view: UIView, at index: Int)<br>  func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>  func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>}<br></p><p><br></p><p>let fn1: (UIView, Int) = someView.insertSubview    // ok: uses<br>insertSubview(_:at:)let fn2: (UIView, aboveSubview: UIView) =<br>someView.insertSubview // Ok: no more ambiguous!let fn3: (UIView,<br>belowSubview: UIView) = someView.insertSubview // Ok: no more<br>ambiguous!<br></p><p><br>And for properties:<br></p><p>let specificTitle:() -&gt; String? = button.currentTitle // will pick the<br>getterlet otherTitle: (UIButton) -&gt; () -&gt; String? =<br>UIButton.currentTitle  // will pick the getterlet setTintColor:<br>(UIColor!) -&gt; () = button.tintColor     // will pick the setter<br></p><p><br>This can be an opportunity to do something like that:<br></p><p>func processColor(data: Any, delegate : (UIColor!) -&gt; ())<br></p><p>processColor(someData, button.tintColor) // will pass tintColor setter<br></p><p><br>And for subscript:<br></p><p>extension Matrix {<br>  subscript (row row: Int) -&gt; [Double] {<br>    get { ... }<br>    set { ... }<br>  }<br>}<br>let getRow: (Int) -&gt; () -&gt; [Double] = someMatrix // will pick the<br>subscript getterlet setRow: (Int) -&gt; ([Double]) -&gt; () = someMatrix //<br>will pick the subscript setter<br></p><p><br></p><p>Of course is more hard, but there&#39;s no new notation, just a expansion of<br>the current type inference.<br></p><p>Maybe some syntax sugar can be provided in another proposal, but this one<br>can be the kickoff.<br></p><p><br>Em seg, 28 de dez de 2015 às 16:10, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; On Dec 27, 2015, at 2:47 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Getters and setters can be written using dotted syntax within the<br>&gt;    back-ticks:<br>&gt;<br>&gt;    let specificTitle = button.`currentTitle.get` // has type () -&gt; String?let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;<br>&gt;    The same syntax works with subscript getters and setters as well,<br>&gt;    using the full name of the subscript:<br>&gt;<br>&gt;    extension Matrix {<br>&gt;      subscript (row row: Int) -&gt; [Double] {<br>&gt;        get { ... }<br>&gt;        set { ... }<br>&gt;      }<br>&gt;    }<br>&gt;    let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;<br>&gt;<br>&gt; At least as far as pure Swift is concerned, for unapplied access, like<br>&gt; `UIButton.currentTitle`, I think it would be more consistent with the way<br>&gt; method references works for that to give you the getter (or lens) without<br>&gt; decoration. instance.instanceMethod has type Args -&gt; Ret, and<br>&gt; Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since<br>&gt; instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to<br>&gt; expect Type.instanceProperty to have type Self -&gt; [inout] Ret. Forming a<br>&gt; getter or setter partially applied to an instance feels unmotivated to me—{<br>&gt; button.currentTitle } or { button.currentTitle = $0 } already work, and are<br>&gt; arguably clearer than this syntax.<br>&gt;<br>&gt; I acknowledge that this leaves forming selectors from setters out to dry,<br>&gt; but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot;<br>&gt; design along with typed selectors. As a rough sketch, we could say that the<br>&gt; representation of @convention(selector) T -&gt; inout U is a pair of<br>&gt; getter/setter selectors, and provide API on Selector to grab the individual<br>&gt; selectors from that, maybe Selector(getterFor:<br>&gt; UIView.currentTitle)/(setterFor: UIView.currentTitle). I don&#39;t think<br>&gt; get/set is a good interface for working with Swift properties, so I don&#39;t<br>&gt; like the idea of building in language support to codify it beyond what&#39;s<br>&gt; needed for ObjC interaction.<br>&gt;<br>&gt;<br>&gt; I know this might be too early, but: what syntax are we thinking of for<br>&gt; lenses?  We might want to design this with future consistency in mind.<br>&gt;<br>&gt;<br>&gt; Vaguely, I think it could look something like this. You could define a<br>&gt; lens function by having it return `inout`. Calling the function produces an<br>&gt; lvalue whose access nests within the accesses of its input `inout`<br>&gt; parameters, if any, allowing for things like:<br>&gt;<br>&gt; var localVar = 1<br>&gt; let localRef: () -&gt; inout Int = { &amp;localVar }<br>&gt;<br>&gt; func second(inout array: [Int]) -&gt; inout Int {<br>&gt;   return &amp;array[1]<br>&gt; }<br>&gt;<br>&gt; // Maybe you can define an inout function with accessors too<br>&gt; func fahrenheit(inout celsius: Double) -&gt; inout Double {<br>&gt;   get {<br>&gt;     return celsius * 9/5 + 32<br>&gt;   }<br>&gt;   set {<br>&gt;     celsius = (newValue - 32) * 5/9<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; and you could access the unapplied lens for an instance property using<br>&gt; `Type.property` syntax, analogous to how `Type.method` works. I feel like<br>&gt; if we did that, then it would obviate the need for explicit `property.get`<br>&gt; or `property.set` for most native Swift uses, though maybe not ObjC interop<br>&gt; uses.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/fb97e695/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; and you could access the unapplied lens for an instance property using `Type.property` syntax, analogous to how `Type.method` works. I feel like if we did that, then it would obviate the need for explicit `property.get` or `property.set` for most native Swift uses, though maybe not ObjC interop uses.<br></p><p>I feel like if you don&#39;t have a way to fetch an unbound getter, you&#39;re missing the 90% case, which is constructs like:<br></p><p>	let textValues = textViews.map(.#text.get)<br></p><p>I do agree with you that the setter is usually far less useful—although the ReactiveCocoa people might not agree with us on that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 1:09 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; and you could access the unapplied lens for an instance property using `Type.property` syntax, analogous to how `Type.method` works. I feel like if we did that, then it would obviate the need for explicit `property.get` or `property.set` for most native Swift uses, though maybe not ObjC interop uses.<br>&gt; <br>&gt; I feel like if you don&#39;t have a way to fetch an unbound getter, you&#39;re missing the 90% case, which is constructs like:<br>&gt; <br>&gt; 	let textValues = textViews.map(.#text.get)<br></p><p>Agreed. I think there are a couple ways to approach that. We could resolve unbound property references contextually, so that Type.property gives you the getter in normal function context, or the lens in inout function context, and/or either allow implicit upconversion from lens to getter function or provide an explicit getter((inout T) -&gt; inout U) -&gt; T -&gt; U adapter function.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 29, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 1:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Dec 28, 2015, at 1:09 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; and you could access the unapplied lens for an instance property using `Type.property` syntax, analogous to how `Type.method` works. I feel like if we did that, then it would obviate the need for explicit `property.get` or `property.set` for most native Swift uses, though maybe not ObjC interop uses.<br>&gt;&gt; <br>&gt;&gt; I feel like if you don&#39;t have a way to fetch an unbound getter, you&#39;re missing the 90% case, which is constructs like:<br>&gt;&gt; <br>&gt;&gt; 	let textValues = textViews.map(.#text.get)<br>&gt; <br>&gt; Agreed. I think there are a couple ways to approach that. We could resolve unbound property references contextually, so that Type.property gives you the getter in normal function context, or the lens in inout function context, and/or either allow implicit upconversion from lens to getter function or provide an explicit getter((inout T) -&gt; inout U) -&gt; T -&gt; U adapter function.<br></p><p>So the contextual lookup rule would be:<br></p><p>If the expression<br>  .foo<br>or<br>  .foo(E…)<br>is known from context to yield a value of type T, then:<br>  if T is a nominal type, the expression is equivalent to T.foo(E…);<br>  if T is a function type (inout? U -&gt; V), then the expression is equivalent to { (x: inout? U) in x.foo(E…) };<br>  if T is a lens function type (inout? U -&gt; inout V), then the argument expression (E…) shall not be present and the expression shall be equivalent to { (x: inout? U) in &amp;x.foo }, or whatever the “applied” lens syntax is;<br>otherwise the expression is ill-formed.<br></p><p>This would be an obstacle to allowing extension methods on a hypothetical Swift.Function&lt;X,Y&gt; type, but I think that’s an acceptable sacrifice.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 27, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br></p><p>I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br></p><p>1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br></p><p>Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/793fd854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 27, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 4:02 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br>&gt; <br>&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt; <br>&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt; <br>&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br></p><p>The concern, I think, is that a messed-up normal call might look like a curried reference.<br></p><p>My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/56a20269/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 27, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt;&gt; <br>&gt;&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt;&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt;&gt; <br>&gt;&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br>&gt; <br>&gt; The concern, I think, is that a messed-up normal call might look like a curried reference.<br>&gt; <br>&gt; My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br></p><p>If you were to go that far, I’d suggest looking at this as a different version of the “.&quot; operator.  If you resyntax curried to something else like (just a strawman, intentionally ugly syntax):<br></p><p>	foo.#bar<br></p><p>Then you’d get a nice property that the plain old dot operator always has to be fully applied.  This certainly would be a win for error recovery.  Also, if you did this, you wouldn’t need the backticks from doug’s proposal either for things like:<br></p><p>	foo.#bar(param1:param2:)<br></p><p>either.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 27, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt;&gt;&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br>&gt;&gt; <br>&gt;&gt; The concern, I think, is that a messed-up normal call might look like a curried reference.<br>&gt;&gt; <br>&gt;&gt; My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br>&gt; <br>&gt; If you were to go that far, I’d suggest looking at this as a different version of the “.&quot; operator.  If you resyntax curried to something else like (just a strawman, intentionally ugly syntax):<br>&gt; <br>&gt; 	foo.#bar<br>&gt; <br>&gt; Then you’d get a nice property that the plain old dot operator always has to be fully applied.  This certainly would be a win for error recovery.  Also, if you did this, you wouldn’t need the backticks from doug’s proposal either for things like:<br>&gt; <br>&gt; 	foo.#bar(param1:param2:)<br>&gt; <br>&gt; either.<br></p><p>Right.  I really like this effect.<br></p><p>I’m not that bothered by requiring the backticks, especially because it generalizes well to non-member function references, which I’m not sure any sort of different-member-access syntax does.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 28, 2015 at 12:00:00am</p></header><div class="content"><p>How to differentiate these functions?<br></p><p>class A{<br>    func someFunc(a: Int) -&gt; Int{<br>        return 0;<br>    }<br>    func someFunc(a: Int) -&gt; Double{<br>        return 0;<br>    }<br>    func someFunc(a: Double) -&gt; Int{<br>        return 0;<br>    }<br>    func someFunc(a: Double) -&gt; Double{<br>        return 0;<br>    }<br>   func someFunc(a: Int, b: Int) -&gt; Int{<br>        return 0;<br>    }<br>}<br></p><p>Even with backticks would not be possible.<br></p><p>You may need to reference the method signature altogether.<br></p><p>var someA = A()<br></p><p>*let fn1 = someA.#someFunc(a: Int) -&gt; Int*<br></p><p><br>*let fn2 = someA.#someFunc(a: Int) -&gt; Double let fn3 = someA.#someFunc(a:<br>Double) -&gt; Int let fn4 = someA.#someFunc(a: Double) -&gt; Double*<br></p><p>An operator at the beginning perhaps?<br></p><p>let fn1 = #someA.someFunc(a: Int) -&gt; Int<br>let fn2 = #someA.someFunc(a: Int) -&gt; Double<br>let fn3 = #someA.someFunc(a: Double) -&gt; Int<br>let fn4 = #someA.someFunc(a: Double) -&gt; Double<br></p><p><br>You may not need the full signature all the time, only necessary to<br>differentiate.<br></p><p>extension A {<br>    func someOtherFunc(a: Int, b: Int) -&gt; Int{<br>        return 0;<br>    }<br>    func someOtherFunc(){<br>    }<br>    func someOther(){<br>    }<br>}<br></p><p>*let fn5 = someA.#someOtherFunc(a:, b:)*<br>*let fn6 = someA.#someOtherFunc()*<br>*let fn6 = someA.someOther*<br></p><p>Another possibility:<br></p><p>*let fn5 = #(someA.someOtherFunc(a:, b:))*<br>*let fn5 = @(someA.someOtherFunc(a:, b:))*<br></p><p>Thus the parser can try to just focus on what&#39;s inside the *#(*...*) or *<br>*@(*...*)*<br></p><p>Em dom, 27 de dez de 2015 às 22:27, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; &gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major<br>&gt; concern here for two reasons:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 1) The most common case in a method will lack a label, and<br>&gt; &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried<br>&gt; reference.<br>&gt; &gt;&gt;&gt; 2) A common case of accidentally completing a nullary call<br>&gt; (thing.foo() vs thing.foo) will produce a type error.  We already produce<br>&gt; good QoI for an unapplied function - adding the inverse would be simple.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried reference,<br>&gt; so error recovery doesn’t have to be perfect in all the edge cases.  As<br>&gt; with other commenters, if it is at all possible to avoid the extra<br>&gt; backticks, I’d really prefer that.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The concern, I think, is that a messed-up normal call might look like a<br>&gt; curried reference.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My inclination would be to go the other way: if we get a syntax for<br>&gt; this that we like, I think we should use it for *all* curried member<br>&gt; references, and reject things like foo.bar in favor of foo.`bar`.  The<br>&gt; ability to write foo.bar for a method has always struck me as more clever<br>&gt; than wise, to be honest.<br>&gt; &gt;<br>&gt; &gt; If you were to go that far, I’d suggest looking at this as a different<br>&gt; version of the “.&quot; operator.  If you resyntax curried to something else<br>&gt; like (just a strawman, intentionally ugly syntax):<br>&gt; &gt;<br>&gt; &gt;       foo.#bar<br>&gt; &gt;<br>&gt; &gt; Then you’d get a nice property that the plain old dot operator always<br>&gt; has to be fully applied.  This certainly would be a win for error<br>&gt; recovery.  Also, if you did this, you wouldn’t need the backticks from<br>&gt; doug’s proposal either for things like:<br>&gt; &gt;<br>&gt; &gt;       foo.#bar(param1:param2:)<br>&gt; &gt;<br>&gt; &gt; either.<br>&gt;<br>&gt; Right.  I really like this effect.<br>&gt;<br>&gt; I’m not that bothered by requiring the backticks, especially because it<br>&gt; generalizes well to non-member function references, which I’m not sure any<br>&gt; sort of different-member-access syntax does.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/3e31071f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 27, 2015 at 08:00:00pm</p></header><div class="content"><p>Le 27 déc. 2015 à 19:54, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; Even with backticks would not be possible.<br>&gt; <br>&gt; You may need to reference the method signature altogether.<br>&gt; <br>&gt; var someA = A()<br>&gt; let fn1 = someA.#someFunc(a: Int) -&gt; Int<br>&gt; let fn2 = someA.#someFunc(a: Int) -&gt; Double <br>&gt; let fn3 = someA.#someFunc(a: Double) -&gt; Int <br>&gt; let fn4 = someA.#someFunc(a: Double) -&gt; Double<br>&gt; <br>&gt; An operator at the beginning perhaps?<br>&gt; <br>&gt; let fn1 = #someA.someFunc(a: Int) -&gt; Int<br>&gt; let fn2 = #someA.someFunc(a: Int) -&gt; Double<br>&gt; let fn3 = #someA.someFunc(a: Double) -&gt; Int<br>&gt; let fn4 = #someA.someFunc(a: Double) -&gt; Double<br></p><p>Well, this works today:<br></p><p>let fn1: Int -&gt; Int = someA.someFunc<br>let fn2: Int -&gt; Double = someA.someFunc<br>let fn3: Double -&gt; Int = someA.someFunc<br>let fn4: Double -&gt; Double = someA.someFunc<br></p><p>In fact, this too works:<br></p><p>let fn1: (a: Int) -&gt; Int = someA.someFunc<br>let fn2: (a: Int) -&gt; Double = someA.someFunc<br>let fn3: (a: Double) -&gt; Int = someA.someFunc<br>let fn4: (a: Double) -&gt; Double = someA.someFunc<br></p><p>See the parameter name in the type? It could be used to disambiguate, but currently it is not taken into account: if you add a `someFunc` overload taking a different parameter name but the same types the above code becomes ambiguous.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 28, 2015 at 01:00:00am</p></header><div class="content"><p>*&quot;if you add a `someFunc` overload taking a different parameter name but<br>the same types the above code becomes ambiguous.&quot;*<br></p><p>Yes, I know, I forgot this example. Ironically that was the intent, but I<br>do not choose good examples.<br></p><p>I was just exploring the idea of having to display the full signature at<br>some point.<br></p><p>Em dom, 27 de dez de 2015 às 23:11, Michel Fortin &lt;michel.fortin at michelf.ca&gt;<br>escreveu:<br></p><p>&gt; Le 27 déc. 2015 à 19:54, Wallacy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt; Even with backticks would not be possible.<br>&gt; &gt;<br>&gt; &gt; You may need to reference the method signature altogether.<br>&gt; &gt;<br>&gt; &gt; var someA = A()<br>&gt; &gt; let fn1 = someA.#someFunc(a: Int) -&gt; Int<br>&gt; &gt; let fn2 = someA.#someFunc(a: Int) -&gt; Double<br>&gt; &gt; let fn3 = someA.#someFunc(a: Double) -&gt; Int<br>&gt; &gt; let fn4 = someA.#someFunc(a: Double) -&gt; Double<br>&gt; &gt;<br>&gt; &gt; An operator at the beginning perhaps?<br>&gt; &gt;<br>&gt; &gt; let fn1 = #someA.someFunc(a: Int) -&gt; Int<br>&gt; &gt; let fn2 = #someA.someFunc(a: Int) -&gt; Double<br>&gt; &gt; let fn3 = #someA.someFunc(a: Double) -&gt; Int<br>&gt; &gt; let fn4 = #someA.someFunc(a: Double) -&gt; Double<br>&gt;<br>&gt; Well, this works today:<br>&gt;<br>&gt; let fn1: Int -&gt; Int = someA.someFunc<br>&gt; let fn2: Int -&gt; Double = someA.someFunc<br>&gt; let fn3: Double -&gt; Int = someA.someFunc<br>&gt; let fn4: Double -&gt; Double = someA.someFunc<br>&gt;<br>&gt; In fact, this too works:<br>&gt;<br>&gt; let fn1: (a: Int) -&gt; Int = someA.someFunc<br>&gt; let fn2: (a: Int) -&gt; Double = someA.someFunc<br>&gt; let fn3: (a: Double) -&gt; Int = someA.someFunc<br>&gt; let fn4: (a: Double) -&gt; Double = someA.someFunc<br>&gt;<br>&gt; See the parameter name in the type? It could be used to disambiguate, but<br>&gt; currently it is not taken into account: if you add a `someFunc` overload<br>&gt; taking a different parameter name but the same types the above code becomes<br>&gt; ambiguous.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/7bcc2c7e/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 27, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 4:54 PM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; How to differentiate these functions?<br></p><p>Doug talked about this some in his proposal.<br></p><p>John.<br></p><p>&gt; <br>&gt; class A{<br>&gt;     func someFunc(a: Int) -&gt; Int{<br>&gt;         return 0;<br>&gt;     }<br>&gt;     func someFunc(a: Int) -&gt; Double{<br>&gt;         return 0;<br>&gt;     }<br>&gt;     func someFunc(a: Double) -&gt; Int{<br>&gt;         return 0;<br>&gt;     }<br>&gt;     func someFunc(a: Double) -&gt; Double{<br>&gt;         return 0;<br>&gt;     }<br>&gt;    func someFunc(a: Int, b: Int) -&gt; Int{<br>&gt;         return 0;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Even with backticks would not be possible.<br>&gt; <br>&gt; You may need to reference the method signature altogether.<br>&gt; <br>&gt; var someA = A()<br>&gt; let fn1 = someA.#someFunc(a: Int) -&gt; Int<br>&gt; let fn2 = someA.#someFunc(a: Int) -&gt; Double <br>&gt; let fn3 = someA.#someFunc(a: Double) -&gt; Int <br>&gt; let fn4 = someA.#someFunc(a: Double) -&gt; Double<br>&gt; <br>&gt; An operator at the beginning perhaps?<br>&gt; <br>&gt; let fn1 = #someA.someFunc(a: Int) -&gt; Int<br>&gt; let fn2 = #someA.someFunc(a: Int) -&gt; Double<br>&gt; let fn3 = #someA.someFunc(a: Double) -&gt; Int<br>&gt; let fn4 = #someA.someFunc(a: Double) -&gt; Double<br>&gt; <br>&gt; <br>&gt; You may not need the full signature all the time, only necessary to differentiate.<br>&gt; <br>&gt; extension A {<br>&gt;     func someOtherFunc(a: Int, b: Int) -&gt; Int{<br>&gt;         return 0;<br>&gt;     }<br>&gt;     func someOtherFunc(){<br>&gt;     }<br>&gt;     func someOther(){<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let fn5 = someA.#someOtherFunc(a:, b:)<br>&gt; let fn6 = someA.#someOtherFunc()<br>&gt; let fn6 = someA.someOther<br>&gt; <br>&gt; Another possibility:<br>&gt; <br>&gt; let fn5 = #(someA.someOtherFunc(a:, b:))<br>&gt; let fn5 = @(someA.someOtherFunc(a:, b:))<br>&gt; <br>&gt; Thus the parser can try to just focus on what&#39;s inside the #(...) or @(...)<br>&gt; <br>&gt; Em dom, 27 de dez de 2015 às 22:27, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt; &gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt; &gt;&gt;&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The concern, I think, is that a messed-up normal call might look like a curried reference.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br>&gt; &gt;<br>&gt; &gt; If you were to go that far, I’d suggest looking at this as a different version of the “.&quot; operator.  If you resyntax curried to something else like (just a strawman, intentionally ugly syntax):<br>&gt; &gt;<br>&gt; &gt;       foo.#bar<br>&gt; &gt;<br>&gt; &gt; Then you’d get a nice property that the plain old dot operator always has to be fully applied.  This certainly would be a win for error recovery.  Also, if you did this, you wouldn’t need the backticks from doug’s proposal either for things like:<br>&gt; &gt;<br>&gt; &gt;       foo.#bar(param1:param2:)<br>&gt; &gt;<br>&gt; &gt; either.<br>&gt; <br>&gt; Right.  I really like this effect.<br>&gt; <br>&gt; I’m not that bothered by requiring the backticks, especially because it generalizes well to non-member function references, which I’m not sure any sort of different-member-access syntax does.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/9a3c80ae/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 27, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 4:27 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt;&gt;&gt;&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The concern, I think, is that a messed-up normal call might look like a curried reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br>&gt;&gt; <br>&gt;&gt; If you were to go that far, I’d suggest looking at this as a different version of the “.&quot; operator.  If you resyntax curried to something else like (just a strawman, intentionally ugly syntax):<br>&gt;&gt; <br>&gt;&gt; 	foo.#bar<br>&gt;&gt; <br>&gt;&gt; Then you’d get a nice property that the plain old dot operator always has to be fully applied.  This certainly would be a win for error recovery.  Also, if you did this, you wouldn’t need the backticks from doug’s proposal either for things like:<br>&gt;&gt; <br>&gt;&gt; 	foo.#bar(param1:param2:)<br>&gt;&gt; <br>&gt;&gt; either.<br>&gt; <br>&gt; Right.  I really like this effect.<br>&gt; <br>&gt; I’m not that bothered by requiring the backticks, especially because it generalizes well to non-member function references, which I’m not sure any sort of different-member-access syntax does.<br></p><p>I’m bothered by it because it overloads backtick to mean two things: keywords-as-names, and annoying-sequences-of-tokens-as-names.  Either use would be acceptable to me, but the fact that we have to support one nested inside the other makes it pretty nasty.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 28, 2015 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 27, 2015, at 8:34 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 4:27 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major concern here for two reasons:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) The most common case in a method will lack a label, and &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried reference.<br>&gt;&gt;&gt;&gt;&gt; 2) A common case of accidentally completing a nullary call (thing.foo() vs thing.foo) will produce a type error.  We already produce good QoI for an unapplied function - adding the inverse would be simple.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried reference, so error recovery doesn’t have to be perfect in all the edge cases.  As with other commenters, if it is at all possible to avoid the extra backticks, I’d really prefer that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The concern, I think, is that a messed-up normal call might look like a curried reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My inclination would be to go the other way: if we get a syntax for this that we like, I think we should use it for *all* curried member references, and reject things like foo.bar in favor of foo.`bar`.  The ability to write foo.bar for a method has always struck me as more clever than wise, to be honest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you were to go that far, I’d suggest looking at this as a different version of the “.&quot; operator.  If you resyntax curried to something else like (just a strawman, intentionally ugly syntax):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    foo.#bar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then you’d get a nice property that the plain old dot operator always has to be fully applied.  This certainly would be a win for error recovery.  Also, if you did this, you wouldn’t need the backticks from doug’s proposal either for things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    foo.#bar(param1:param2:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; either.<br>&gt;&gt; <br>&gt;&gt; Right.  I really like this effect.<br>&gt;&gt; <br>&gt;&gt; I’m not that bothered by requiring the backticks, especially because it generalizes well to non-member function references, which I’m not sure any sort of different-member-access syntax does.<br>&gt; <br>&gt; I’m bothered by it because it overloads backtick to mean two things: keywords-as-names, and annoying-sequences-of-tokens-as-names.  Either use would be acceptable to me, but the fact that we have to support one nested inside the other makes it pretty nasty.<br></p><p>In the context of this proposal, I think of backticks as delimiters around a generalized name. It&#39;s a generalization of today&#39;s notion that it&#39;s an escaped identifier; more like an escaped name. <br></p><p>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 28, 2015 at 08:00:00pm</p></header><div class="content"><p>&quot;In the context of this proposal, I think of backticks as delimiters around<br>a generalized name. It&#39;s a generalization of today&#39;s notion that it&#39;s an<br>escaped identifier; more like an escaped name.&quot;<br></p><p>backticks are just a &quot;hack&quot;, with the proposal 0001 (Allow (most) keywords<br>as argument labels),  your proposal, we just will not see this feature<br>being used.<br></p><p>It&#39;s not just a matter of style, just does not seem natural.<br></p><p>Expand type annotation to &quot;pick&quot; the correct function, as I said before,<br>seems to me more natural. Or choose another symbol of course.<br></p><p>Em seg, 28 de dez de 2015 às 17:49, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On Dec 27, 2015, at 8:34 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Dec 27, 2015, at 4:27 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 27, 2015, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 27, 2015, at 4:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; I’m a fan of good error recovery, but I don’t think it is a major<br>&gt; concern here for two reasons:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1) The most common case in a method will lack a label, and<br>&gt; &quot;thing.foo(_: “ and “thing.foo(:” are both unambiguously a curried<br>&gt; reference.<br>&gt; &gt;&gt;&gt;&gt;&gt; 2) A common case of accidentally completing a nullary call<br>&gt; (thing.foo() vs thing.foo) will produce a type error.  We already produce<br>&gt; good QoI for an unapplied function - adding the inverse would be simple.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Further, it will be uncommon *in general* to form a curried<br>&gt; reference, so error recovery doesn’t have to be perfect in all the edge<br>&gt; cases.  As with other commenters, if it is at all possible to avoid the<br>&gt; extra backticks, I’d really prefer that.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The concern, I think, is that a messed-up normal call might look like<br>&gt; a curried reference.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; My inclination would be to go the other way: if we get a syntax for<br>&gt; this that we like, I think we should use it for *all* curried member<br>&gt; references, and reject things like foo.bar in favor of foo.`bar`.  The<br>&gt; ability to write foo.bar for a method has always struck me as more clever<br>&gt; than wise, to be honest.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If you were to go that far, I’d suggest looking at this as a different<br>&gt; version of the “.&quot; operator.  If you resyntax curried to something else<br>&gt; like (just a strawman, intentionally ugly syntax):<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    foo.#bar<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Then you’d get a nice property that the plain old dot operator always<br>&gt; has to be fully applied.  This certainly would be a win for error<br>&gt; recovery.  Also, if you did this, you wouldn’t need the backticks from<br>&gt; doug’s proposal either for things like:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    foo.#bar(param1:param2:)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; either.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Right.  I really like this effect.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not that bothered by requiring the backticks, especially because it<br>&gt; generalizes well to non-member function references, which I’m not sure any<br>&gt; sort of different-member-access syntax does.<br>&gt; &gt;<br>&gt; &gt; I’m bothered by it because it overloads backtick to mean two things:<br>&gt; keywords-as-names, and annoying-sequences-of-tokens-as-names.  Either use<br>&gt; would be acceptable to me, but the fact that we have to support one nested<br>&gt; inside the other makes it pretty nasty.<br>&gt;<br>&gt; In the context of this proposal, I think of backticks as delimiters around<br>&gt; a generalized name. It&#39;s a generalization of today&#39;s notion that it&#39;s an<br>&gt; escaped identifier; more like an escaped name.<br>&gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/6d5069be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 28, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; Am 28.12.2015 um 01:15 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; (just a strawman, intentionally ugly syntax):<br>&gt; <br>&gt;    foo.#bar<br></p><p>Much prettier than backticks IMHO.<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 29, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; On Dec 27, 2015, at 10:37 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; <br>[snip]<br>&gt; <br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; At least as far as pure Swift is concerned, for unapplied access, like `UIButton.currentTitle`, I think it would be more consistent with the way method references works for that to give you the getter (or lens) without decoration. instance.instanceMethod has type Args -&gt; Ret, and Type.instanceMethod has type Self -&gt; Args -&gt; Ret; by analogy, since instance.instanceProperty has type Ret or inout Ret, it&#39;s reasonable to expect Type.instanceProperty to have type Self -&gt; [inout] Ret.<br></p><p>Yes, that seems reasonable.<br></p><p>&gt; Forming a getter or setter partially applied to an instance feels unmotivated to me—{ button.currentTitle } or { button.currentTitle = $0 } already work, and are arguably clearer than this syntax.<br></p><p>I’m not strongly motivated by it in and of itself; rather, I like the idea of being able to get at all of the functions (for completeness/consistency), partly because of the Objective-C selector issue.<br></p><p>&gt; I acknowledge that this leaves forming selectors from setters out to dry, but I feel like that&#39;s something that could be incorporated into a &quot;lens&quot; design along with typed selectors. As a rough sketch, we could say that the representation of @convention(selector) T -&gt; inout U is a pair of getter/setter selectors,<br></p><p>I should weigh in over on a typed-selectors thread, but my personal view is that typed selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with Objective-C. To make that work, we&#39;d need a Clang feature as well (to express the types), then all of the relevant Objective-C APIs would need to adopt it for us to see the benefits. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred. <br></p><p>&gt; and provide API on Selector to grab the individual selectors from that, maybe Selector(getterFor: UIView.currentTitle)/(setterFor: UIView.currentTitle)<br></p><p>Sure. I suspect that retrieving the selector of a getter/setter will be fairly rare, so I&#39;m fine with that operation being ugly. <br></p><p>&gt; . I don&#39;t think get/set is a good interface for working with Swift properties, so I don&#39;t like the idea of building in language support to codify it beyond what&#39;s needed for ObjC interaction.<br></p><p>That is an excellent point. I think you&#39;ve convinced me to drop the getter/setter part of this: lenses are the right abstraction for working with properties, and we can handle ObjC getter/setter in some other way. <br></p><p>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; From what I remember, the bigger concern with allowing foo(bar:bas:) without backticks is parser error recovery. The unambiguity with call syntax depends on having the `:)` token pair at the end. The edit distance between foo(bar:bas:) and a call foo(bar: bas) or work-in-progress call foo(bar: x, bas: ) is pretty slight, and would be tricky to give good diagnostics for. If we felt confident we could give good diagnostics, I&#39;d support removing the backticks.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/f472381f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3de170f1f925338b091170b400cc30e4?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Bartlomiej Cichosz</string> &lt;barrrt at gmail.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I am sorry if this was already considered (jumping in a bit late), but what about using the following syntax:<br></p><p>let fn = aGameView.insertSubview(_, aboveSubview: _)<br></p><p>This is similar to a function calling syntax (rather than function definition syntax), but with _ instead of specific arguments.<br></p><p>The reason I think this may be useful is because it could be generalized to a syntax for partial application (assuming such functionality is desired in Swift):<br></p><p>let insertCardViewAtTheBottomOfTheDeck = aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br></p><p>then:<br></p><p>insertCardViewAtTheBottomOfTheDeck(anotherCard)<br></p><p><br>Or:<br></p><p>let insertMyCard = aGameView.insertSubview(myCard, aboveSubview: _)<br></p><p>then:<br></p><p>insertMyCard(aboveSubview:otherCard)<br></p><p><br>In the above examples, the definitions of insertCardViewAtTheBottomOfTheDeck and insertMyCard would return partially applied functions. Whereas the first example, the definition of fn, where all arguments are specified as _ is a special case that refers to the original function.<br></p><p>Some of the issues mentioned in the proposal remain, for example, how to disambiguate same function names with different parameter types, such as:<br></p><p>let fn1 = aGameView.insertSubview(_, aboveSubview: _:CardView)<br></p><p>or <br></p><p>let fn2 = aGameView.insertSubview(_, aboveSubview: _ as CardView)<br></p><p><br></p><p>Or different return values:<br></p><p>let fn3 = aGameView.insertSubview(_, aboveSubview: playingSurfaceView) -&gt; Bool<br></p><p><br>Getters and setters, using the example from the proposal:<br></p><p>let getRow = someMatrix.subscript(row: _).get<br></p><p><br>All of the above assumes, of course, that presence of one or more _ is sufficient to parse these not as function calls, but partial application expressions (with the special case of all _s being just reference to the original function). If that’s the case, it would eliminate the need for back-ticks.<br></p><p>Regards,<br></p><p>Bart<br></p><p><br></p><p>&gt; On Dec 27, 2015, at 02:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt; <br>&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt; <br>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; Comments appreciated!<br>&gt; <br>&gt; Generalized Naming for Any Function<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt; <br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; <br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt; <br>&gt; func `try`() -&gt; Bool { ... }<br>&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt; <br>&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt; <br>&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt; <br>&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt; <br>&gt; extension Matrix {<br>&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;     get { ... }<br>&gt;     set { ... }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt; <br>&gt; self.`myProperty.lazy`.clear()<br>&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt; <br>&gt; extension Font {<br>&gt;   func `subscript`() -&gt; Font {<br>&gt;     // return the subscript version of the given font<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt; <br>&gt; let specificTitle = button.currentTitle#get<br>&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt; <br>&gt; let fn = someView.insertSubview#(_:at:)<br>&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt; <br>&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt; <br>&gt; extension Optional {<br>&gt;   func get() -&gt; T { return self! }<br>&gt; }<br>&gt; <br>&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/4ae8f798/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br></p><p>extension ProtocolA { func foo() }<br>extension ProtocolB { func foo() }<br></p><p>public struct Foo: ProtocolA, ProtocolB {<br>  func callBothFoos() {<br>    self.`ProtocolA.foo`()<br>    self.`ProtocolB.foo`()<br>  }<br>}<br></p><p>import A // extends Bar with bar()<br>import B // also extends Bar with bar()<br></p><p>extension Bar {<br>  func callBothBars() {<br>    self.`A.bar`()<br>    self.`B.bar`()<br>  }<br>}<br></p><p>-Joe<br></p><p>&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt; <br>&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt; <br>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; Comments appreciated!<br>&gt; <br>&gt; Generalized Naming for Any Function<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt; <br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; <br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt; <br>&gt; func `try`() -&gt; Bool { ... }<br>&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt; <br>&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt; <br>&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt; <br>&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt; <br>&gt; extension Matrix {<br>&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;     get { ... }<br>&gt;     set { ... }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt; <br>&gt; self.`myProperty.lazy`.clear()<br>&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt; <br>&gt; extension Font {<br>&gt;   func `subscript`() -&gt; Font {<br>&gt;     // return the subscript version of the given font<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt; <br>&gt; let specificTitle = button.currentTitle#get<br>&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt; <br>&gt; let fn = someView.insertSubview#(_:at:)<br>&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt; <br>&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt; <br>&gt; extension Optional {<br>&gt;   func get() -&gt; T { return self! }<br>&gt; }<br>&gt; <br>&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/57357af3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 12:17 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt; <br>&gt; extension ProtocolA { func foo() }<br>&gt; extension ProtocolB { func foo() }<br>&gt; <br>&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;   func callBothFoos() {<br>&gt;     self.`ProtocolA.foo`()<br>&gt;     self.`ProtocolB.foo`()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; import A // extends Bar with bar()<br>&gt; import B // also extends Bar with bar()<br>&gt; <br>&gt; extension Bar {<br>&gt;   func callBothBars() {<br>&gt;     self.`A.bar`()<br>&gt;     self.`B.bar`()<br>&gt;   }<br>&gt; }<br>&gt; <br></p><p>Like many others I am not a fan of the backticks being required in common use cases, but I don’t mind them in edge cases at all.  In those cases they are far better than no solution.  So +1 to using backticks to allow disambiguation!<br></p><p>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension UIButton {<br>&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;   return button.currentTitle<br>&gt;&gt; }<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt; <br>&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt; <br>&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt; <br>&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt; <br>&gt;&gt; extension Font {<br>&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt; <br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/79ef93d4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 29, 2015 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br></p><p>That&#39;s a fantastic idea!<br></p><p>&gt; <br>&gt; extension ProtocolA { func foo() }<br>&gt; extension ProtocolB { func foo() }<br>&gt; <br>&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;   func callBothFoos() {<br>&gt;     self.`ProtocolA.foo`()<br>&gt;     self.`ProtocolB.foo`()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; import A // extends Bar with bar()<br>&gt; import B // also extends Bar with bar()<br>&gt; <br>&gt; extension Bar {<br>&gt;   func callBothBars() {<br>&gt;     self.`A.bar`()<br>&gt;     self.`B.bar`()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt; <br>&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt; <br>&gt;&gt; Comments appreciated!<br>&gt;&gt; <br>&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here, continued here. See the Alternatives considered section for commentary on that discussion.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension UIButton {<br>&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;   return button.currentTitle<br>&gt;&gt; }<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt; <br>&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt; <br>&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt; <br>&gt;&gt; extension Matrix {<br>&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;     get { ... }<br>&gt;&gt;     set { ... }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt; <br>&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt; <br>&gt;&gt; extension Font {<br>&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Michael Henson proposed naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt; <br>&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt; <br>&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/75a0d688/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>Talk about things you didn&#39;t know you needed until you see them. This is a really nice way of disambiguating!<br></p><p>-- E<br></p><p>&gt; On Dec 29, 2015, at 12:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt; <br>&gt; That&#39;s a fantastic idea!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt; <br>&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;   func callBothFoos() {<br>&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt; <br>&gt;&gt; extension Bar {<br>&gt;&gt;   func callBothBars() {<br>&gt;&gt;     self.`A.bar`()<br>&gt;&gt;     self.`B.bar`()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/41d90a7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>Currently, they can be disambiguated using (self as ProtocolA).bar(), no?<br></p><p>Félix<br></p><p>&gt; Le 29 déc. 2015 à 14:10:51, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Talk about things you didn&#39;t know you needed until you see them. This is a really nice way of disambiguating!<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 12:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fantastic idea!<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;&gt;   func callBothFoos() {<br>&gt;&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bar {<br>&gt;&gt;&gt;   func callBothBars() {<br>&gt;&gt;&gt;     self.`A.bar`()<br>&gt;&gt;&gt;     self.`B.bar`()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/6a85857d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 29, 2015, at 11:48 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Currently, they can be disambiguated using (self as ProtocolA).bar(), no?<br></p><p>Not if ProtocolA has self requirements or associated types. <br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 29 déc. 2015 à 14:10:51, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Talk about things you didn&#39;t know you needed until you see them. This is a really nice way of disambiguating!<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 12:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a fantastic idea!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt;&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;&gt;&gt;   func callBothFoos() {<br>&gt;&gt;&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt;&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Bar {<br>&gt;&gt;&gt;&gt;   func callBothBars() {<br>&gt;&gt;&gt;&gt;     self.`A.bar`()<br>&gt;&gt;&gt;&gt;     self.`B.bar`()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt;&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here, continued here. See the Alternatives considered section for commentary on that discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Michael Henson proposed naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/67150a4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>Right.<br></p><p>Félix<br></p><p>&gt; Le 29 déc. 2015 à 15:04:11, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 29, 2015, at 11:48 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Currently, they can be disambiguated using (self as ProtocolA).bar(), no?<br>&gt; <br>&gt; Not if ProtocolA has self requirements or associated types. <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 29 déc. 2015 à 14:10:51, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Talk about things you didn&#39;t know you needed until you see them. This is a really nice way of disambiguating!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 12:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a fantastic idea!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt;&gt;&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;&gt;&gt;&gt;   func callBothFoos() {<br>&gt;&gt;&gt;&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;&gt;&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt;&gt;&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Bar {<br>&gt;&gt;&gt;&gt;&gt;   func callBothBars() {<br>&gt;&gt;&gt;&gt;&gt;     self.`A.bar`()<br>&gt;&gt;&gt;&gt;&gt;     self.`B.bar`()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt;&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt;&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt;&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt;&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt;&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt;&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt;&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt;&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt;&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt;&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt;&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt;&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt;&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt;&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt;&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt;&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt;&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/d40175a6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Currently, they can be disambiguated using (self as ProtocolA).bar(), no?<br></p><p>I think this method is more about, for instance:<br></p><p>	extension NSString {<br>		func drawAtPoint(point: CGPoint, withAttributes attributes: [String: AnyObject]?) {<br>			doSomeOtherThing()<br>			myString.`UIKit.drawAtPoint`(point, withAttributes: attrs)<br>		}<br>	}<br></p><p>You use it to access a method by the module it comes from, not the protocol it comes from.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 29, 2015, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt; <br>&gt; That&#39;s a fantastic idea!<br></p><p>It does introduce some ambiguities at the margins. Given<br></p><p>  foo.`bar.get`()<br></p><p>Do we look for bar in the lexical scope or in the member scope of foo? Or both with yet another disambiguation mechanism?<br></p><p>I&#39;m still traumatized by implementing the related C++ rules for<br></p><p>  foo.bar::get <br></p><p>:)<br></p><p>This is the other thing that nudges me toward dropping getters/setters from the generalized naming proposal, because it leaves the use of &#39;.&#39; within backticks for your newly-proposed meaning. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt; <br>&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;   func callBothFoos() {<br>&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt; <br>&gt;&gt; extension Bar {<br>&gt;&gt;   func callBothBars() {<br>&gt;&gt;     self.`A.bar`()<br>&gt;&gt;     self.`B.bar`()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here, continued here. See the Alternatives considered section for commentary on that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael Henson proposed naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/971453fd/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 12:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 29, 2015, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:17 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We also have a problem with disambiguating same-named members that come from different extensions, whether via protocol extensions or independent concrete extensions from different modules. Could we extend this scheme to allow for disambiguating extension methods by protocol/module name?<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fantastic idea!<br>&gt; <br>&gt; It does introduce some ambiguities at the margins. Given<br>&gt; <br>&gt;   foo.`bar.get`()<br>&gt; <br>&gt; Do we look for bar in the lexical scope or in the member scope of foo? Or both with yet another disambiguation mechanism?<br>&gt; <br>&gt; I&#39;m still traumatized by implementing the related C++ rules for<br>&gt; <br>&gt;   foo.bar::get <br>&gt; <br>&gt; :)<br></p><p>Clearly we should just adopt Koenig lookup rules.<br></p><p>&gt; This is the other thing that nudges me toward dropping getters/setters from the generalized naming proposal, because it leaves the use of &#39;.&#39; within backticks for your newly-proposed meaning. <br></p><p>Well, even if we drop `.get`/`.set` from the proposal, there&#39;s still the potential ambiguity between module names and type or protocol names. As an example from the wild, there&#39;s an Either module which defines an Either type, and we have bugs on file saying you can&#39;t pick one or the other. It seems like we&#39;ll ultimately want some sort of absolute qualification scheme.<br></p><p>-Joe<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ProtocolA { func foo() }<br>&gt;&gt;&gt; extension ProtocolB { func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo: ProtocolA, ProtocolB {<br>&gt;&gt;&gt;   func callBothFoos() {<br>&gt;&gt;&gt;     self.`ProtocolA.foo`()<br>&gt;&gt;&gt;     self.`ProtocolB.foo`()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import A // extends Bar with bar()<br>&gt;&gt;&gt; import B // also extends Bar with bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bar {<br>&gt;&gt;&gt;   func callBothBars() {<br>&gt;&gt;&gt;     self.`A.bar`()<br>&gt;&gt;&gt;     self.`B.bar`()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 26, 2015, at 11:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the proposal follows, and is available here as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments appreciated!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalized Naming for Any Function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;&gt;   button.insertSubview(view, otherView)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension UIButton {<br>&gt;&gt;&gt;&gt;   var currentTitle: String? { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var fn: () -&gt; String? = { () in<br>&gt;&gt;&gt;&gt;   return button.currentTitle<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func `try`() -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt;&gt;&gt;&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt;&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt;&gt;&gt;&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt;&gt;&gt;&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt;&gt;&gt;&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt;&gt;&gt;&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Matrix {<br>&gt;&gt;&gt;&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;&gt;&gt;&gt;     get { ... }<br>&gt;&gt;&gt;&gt;     set { ... }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt;&gt;&gt;&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt;&gt;&gt;&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; self.`myProperty.lazy`.clear()<br>&gt;&gt;&gt;&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Font {<br>&gt;&gt;&gt;&gt;   func `subscript`() -&gt; Font {<br>&gt;&gt;&gt;&gt;     // return the subscript version of the given font<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt;&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt;&gt;&gt;&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let specificTitle = button.currentTitle#get<br>&gt;&gt;&gt;&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview#(_:at:)<br>&gt;&gt;&gt;&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt;&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional {<br>&gt;&gt;&gt;&gt;   func get() -&gt; T { return self! }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt;&gt;&gt;&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/4d66d724/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Generalized Naming for Any Function</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>I like this proposal overall and the proposed syntax in particular; I think it addresses a real issue in a straightforward, predictable way.<br></p><p>As an aside — and FWIW — one thing I was at some point going to propose was a shorthand syntax for specifying trivial “argument-ordering-adjustment” closures.<br></p><p>EG: in the context of the proposal, a shorthand like this:<br></p><p>	let indicesForViews: [(Int,UIView)] = …<br>	indicesForViews.forEach(self.`insertSubview($1,at:$0)`)<br></p><p>…although using something other than back-ticks may be necessary to avoid ambiguity.<br></p><p>In the example above, it’s a bit contrived; in general, it’s never actually-shorter than the current option:<br></p><p>	let indicesForViews: [(Int,UIView)] = …<br>	indicesForViews.forEach({ self.insertSubview($1, at: $0) })<br></p><p>…but it would still make things more symmetric between the “function name” case and the inline-short-closure case.<br></p><p>More importantly, it’d allow a streamlined way to express things like this:<br></p><p>	// shorthand:<br>	let flippedArguments = self.`insertSubview($1, at: $0)` <br></p><p>	// current syntax:<br>	let flippedArguments = { (Int,UIView) -&gt; Void in self.insertSubview($1, at: $0) }<br></p><p>…which will be a lot more useful once we have a reliable way to pull such functions into local variables.<br></p><p>I’m not requesting this be included in the below proposal, just hoping the final syntax selected here not somehow inadvertently prevent such a construct from ever being created.<br></p><p>Apologies if this has already come up in the discussion.<br></p><p>&gt; On Dec 27, 2015, at 1:22 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Here’s a proposal draft to allow one to name any function in Swift. In effect, it’s continuing the discussion of retrieving getters and setters as functions started by Michael Henson here:<br>&gt; <br>&gt; 	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;<br>&gt; <br>&gt; the proposal follows, and is available here as well:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; Comments appreciated!<br>&gt; <br>&gt; Generalized Naming for Any Function<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: Michael Henson started a thread about the getter/setter issue here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;. See the Alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt; section for commentary on that discussion.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, otherView)<br>&gt; }<br>&gt; which is painfully tedious. A similar workaround is required to produce a function value for a getter of a property, e.g.,<br>&gt; <br>&gt; extension UIButton {<br>&gt;   var currentTitle: String? { ... }<br>&gt; }<br>&gt; <br>&gt; var fn: () -&gt; String? = { () in<br>&gt;   return button.currentTitle<br>&gt; }<br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift currently has a back-tick escaping syntax that lets one use keywords for names, which would otherwise fail to parse. For example,<br>&gt; <br>&gt; func `try`() -&gt; Bool { ... }<br>&gt; declares a function named try, even though try is a keyword. I propose to extend the back-tick syntax to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) and references to the accessors of properties (e.g., the getter for currentTitle). Specifically,<br>&gt; <br>&gt; Compound names can be written entirely within the back-ticks, e.g.,<br>&gt; <br>&gt; let fn = someView.`insertSubview(_:at:)`<br>&gt; let fn1 = someView.`insertSubview(_:aboveSubview:)`<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.`init(type:)`<br>&gt; Getters and setters can be written using dotted syntax within the back-ticks:<br>&gt; <br>&gt; let specificTitle = button.`currentTitle.get` // has type () -&gt; String?<br>&gt; let otherTitle = UIButton.`currentTitle.get`  // has type (UIButton) -&gt; () -&gt; String?<br>&gt; let setTintColor = button.`tintColor.set`     // has type (UIColor!) -&gt; ()<br>&gt; The same syntax works with subscript getters and setters as well, using the full name of the subscript:<br>&gt; <br>&gt; extension Matrix {<br>&gt;   subscript (row row: Int) -&gt; [Double] {<br>&gt;     get { ... }<br>&gt;     set { ... }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getRow = someMatrix.`subscript(row:).get` // has type (Int) -&gt; () -&gt; [Double]<br>&gt; let setRow = someMatrix.`subscript(row:).set` // has type (Int) -&gt; ([Double]) -&gt; ()<br>&gt; If we introduce property behaviors into Swift, the back-tick syntax could also be used to refer to behaviors, e.g., accessing the lazy behavior of a property:<br>&gt; <br>&gt; self.`myProperty.lazy`.clear()<br>&gt; Base names that are meaningful keywords (init and subscript) can be escaped with a nested pair of back-ticks:<br>&gt; <br>&gt; extension Font {<br>&gt;   func `subscript`() -&gt; Font {<br>&gt;     // return the subscript version of the given font<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let getSubscript = font.``subscript`()` // has type () -&gt; Font<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter: Selector = objc_selector(NSDictionary.`subscript(_:).get`) // produces objectForKeyedSubscript:<br>&gt; let setter: Selector = objc_selector(NSDictionary.`subscript(_:).set`) // produces setObject:forKeyedSubscript:<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code. The syntactic space it uses is already present, and it merely extends the use of back-ticks from storing a single identifier to more complex names.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Michael Henson proposed &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt; naming getters and setters using # syntax followed by get or set, e.g.,<br>&gt; <br>&gt; let specificTitle = button.currentTitle#get<br>&gt; The use of postfix # is a reasonable alternative here, and more lightweight than two back-ticks for the simple getter/setter case. The notion could be extended to allow argument labels for functions, discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002210.html&gt;. The proposals in that discussion actually included type annotations as well, but the syntax seems cleaner---and more directly focused on names---without them, e.g.,:<br>&gt; <br>&gt; let fn = someView.insertSubview#(_:at:)<br>&gt; which works. I didn&#39;t go with this syntax because (1) it breaks up Swift method names such as insertSubview(_:at:)with an # in the middle, and (2) while useful, this feature doesn&#39;t seem important enough to justify overloading #further.<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. That weakens the case this proposal makes for making getters/setters available as functions. However, it doesn&#39;t address the general naming issue or the desire to retrieve the Objective-C selector for a getter/setter.<br>&gt; <br>&gt; Can we drop the back-ticks? It&#39;s very tempting to want to drop the back-ticks entirely, because something like<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; can be correctly parsed as a reference to insertSubview(_:at:). However, it breaks down at the margins, e.g., with getter/setter references or no-argument functions:<br>&gt; <br>&gt; extension Optional {<br>&gt;   func get() -&gt; T { return self! }<br>&gt; }<br>&gt; <br>&gt; let fn1 = button.currentTitle.get   // getter or Optional&lt;String&gt;.get?<br>&gt; let fn2 = set.removeAllElements()   // call or reference?<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/7f4e16cd/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
