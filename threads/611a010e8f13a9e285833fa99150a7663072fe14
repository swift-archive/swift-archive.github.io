<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Motivation:<br></p><p>The Cocoa frameworks have a long-standing issue regarding methods that are intended as primitives for subclasses to override or for protocol implementers to provide, but which aren’t meant for client code to call directly. Often, the only way to determine that a method shouldn’t be called is to look at the documentation, but that isn’t much of a help when auto-complete suggests such methods, which sometimes look perfectly usable, even tempting, to the naked eye. NSView has a number of them that have come up many a time on mailing lists and support forums in the past, to the extent that Apple has actually created a chart intended to indicate which should be called directly and which shouldn’t:<br></p><p>https://developer.apple.com/library/mac/releasenotes/UserExperience/RNAutomaticLayout/#//apple_ref/doc/uid/TP40010631-CH1-SW14 &lt;https://developer.apple.com/library/mac/releasenotes/UserExperience/RNAutomaticLayout/#//apple_ref/doc/uid/TP40010631-CH1-SW14&gt;<br></p><p>Clearly advertising things that are not supposed to be actually called is non-ideal in terms of interface.<br></p><p>Proposed Solution:<br></p><p>Following the example of private(set), I propose a new access modifier for methods and properties called private(call). A method declared private(call) would behave exactly the same as a private method in almost all circumstances, the one exception being when a subclass attempts to override it (for a class) or a class, struct, or enum implements it (for a protocol). These methods would not be callable by any code outside of the source file that declared the property, and would not show up in code completion.<br></p><p>A similar access modifier, internal(call), would allow the method to be called only by code in the same module, but publicly would be override/implement only.<br></p><p>Wait, isn’t this the same as protected?<br></p><p>No. The difference between this and protected is that while protected allows subclasses to access the method and/or property as if it were public, private(call) does *not*. Subclass code is forbidden from accessing the member, exactly as any code from any other class would be. This makes implementation simpler than it would be for protected; private(call) can be treated exactly the same as private for all use cases other than:<br></p><p>1. Displaying the generated “headers” to show the class or protocol’s interface.<br></p><p>2. A method or property declaration in a source code file that either begins with “override” or implements a required member of a protocol.<br></p><p>In all other cases, the compiler can treat private(call) and internal(call) exactly as it would private and internal respectively. It is also more secure than protected, since it cannot be worked around simply by making a subclass of the class in question, and since it reduces the ways a subclass can do something unexpected with the property or method.<br></p><p>Alternatives Considered:<br></p><p>In some cases, an exception could be made for Objective-C methods marked OBJC_REQUIRES_SUPER; in such cases, the subclass could be allowed to call super’s implementation, but only from within the override. This could be extended to pure-Swift classes once Swift acquires an equivalent to OBJC_REQUIRES_SUPER. Other than this one exception, even subclasses would not be able to call a method marked private(call). This would, however, complicate the implementation somewhat, and may not be necessary, since any work that the superclass needs to do could be done in a separate method, before calling the private(call) method. There may be some cases where the subclass wants to begin with the return value from the superclass method and modify it slightly, however, in which case this variant may be helpful. It could also possibly be useful in cases where there is a chain of subclasses going several layers down, where each subclass wants to do the work of its own superclass’s implementation before continuing.<br></p><p>Summary:<br></p><p>All in all, I think this would be a positive contribution to the language. What do you think?<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/611afe14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>This is the reply that I wrote to someone else who wanted a private(extension) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005450.html&gt; modifier. Swift&#39;s access modifiers align with linker access modifiers and visibility styles: `private` is not exported beyond the translation unit (and can be very aggressively optimized), `internal` is hidden (not exported to the dynamic symbol table) and `public` is exported to the symbol table of the resulting executable. `Private(set)` just means that the setter method is not exported but the getter is. <br></p><p>So as I said in the other thread, I wouldn&#39;t consider that these new modifiers follow the example that private(set) set.<br></p><p>The great thing about using the linker to implement access control is that it can be enforced. The reason internal or private can&#39;t be called from outside an executable is that no data about it exists in the final executable As a matter of fact, the symbol itself might not even exist in the fully optimized executable.<br></p><p>I also think that it&#39;s fundamentally the same as protected, because nothing prevents you from sharing the logic outside. You can forward the protected call to a public call, which is exactly the same as a public call forwarding to a protected call in terms of encapsulation.<br></p><p>If I can toot my horn, you should consider as an alternative better cooperation between the language and the autocomplete/linters &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005807.html&gt;. I haven&#39;t got around to a new proposal with documentation comments yet but the idea&#39;s there.<br></p><p>Félix<br></p><p>&gt; Le 11 janv. 2016 à 19:53:57, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; The Cocoa frameworks have a long-standing issue regarding methods that are intended as primitives for subclasses to override or for protocol implementers to provide, but which aren’t meant for client code to call directly. Often, the only way to determine that a method shouldn’t be called is to look at the documentation, but that isn’t much of a help when auto-complete suggests such methods, which sometimes look perfectly usable, even tempting, to the naked eye. NSView has a number of them that have come up many a time on mailing lists and support forums in the past, to the extent that Apple has actually created a chart intended to indicate which should be called directly and which shouldn’t:<br>&gt; <br>&gt; https://developer.apple.com/library/mac/releasenotes/UserExperience/RNAutomaticLayout/#//apple_ref/doc/uid/TP40010631-CH1-SW14 &lt;https://developer.apple.com/library/mac/releasenotes/UserExperience/RNAutomaticLayout/#//apple_ref/doc/uid/TP40010631-CH1-SW14&gt;<br>&gt; <br>&gt; Clearly advertising things that are not supposed to be actually called is non-ideal in terms of interface.<br>&gt; <br>&gt; Proposed Solution:<br>&gt; <br>&gt; Following the example of private(set), I propose a new access modifier for methods and properties called private(call). A method declared private(call) would behave exactly the same as a private method in almost all circumstances, the one exception being when a subclass attempts to override it (for a class) or a class, struct, or enum implements it (for a protocol). These methods would not be callable by any code outside of the source file that declared the property, and would not show up in code completion.<br>&gt; <br>&gt; A similar access modifier, internal(call), would allow the method to be called only by code in the same module, but publicly would be override/implement only.<br>&gt; <br>&gt; Wait, isn’t this the same as protected?<br>&gt; <br>&gt; No. The difference between this and protected is that while protected allows subclasses to access the method and/or property as if it were public, private(call) does *not*. Subclass code is forbidden from accessing the member, exactly as any code from any other class would be. This makes implementation simpler than it would be for protected; private(call) can be treated exactly the same as private for all use cases other than:<br>&gt; <br>&gt; 1. Displaying the generated “headers” to show the class or protocol’s interface.<br>&gt; <br>&gt; 2. A method or property declaration in a source code file that either begins with “override” or implements a required member of a protocol.<br>&gt; <br>&gt; In all other cases, the compiler can treat private(call) and internal(call) exactly as it would private and internal respectively. It is also more secure than protected, since it cannot be worked around simply by making a subclass of the class in question, and since it reduces the ways a subclass can do something unexpected with the property or method.<br>&gt; <br>&gt; Alternatives Considered:<br>&gt; <br>&gt; In some cases, an exception could be made for Objective-C methods marked OBJC_REQUIRES_SUPER; in such cases, the subclass could be allowed to call super’s implementation, but only from within the override. This could be extended to pure-Swift classes once Swift acquires an equivalent to OBJC_REQUIRES_SUPER. Other than this one exception, even subclasses would not be able to call a method marked private(call). This would, however, complicate the implementation somewhat, and may not be necessary, since any work that the superclass needs to do could be done in a separate method, before calling the private(call) method. There may be some cases where the subclass wants to begin with the return value from the superclass method and modify it slightly, however, in which case this variant may be helpful. It could also possibly be useful in cases where there is a chain of subclasses going several layers down, where each subclass wants to do the work of its own superclass’s implementation before continuing.<br>&gt; <br>&gt; Summary:<br>&gt; <br>&gt; All in all, I think this would be a positive contribution to the language. What do you think?<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/7c1393eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 12:00:00am</p></header><div class="content"><p>On 2016-01-11 23:33, Félix Cloutier wrote:<br>&gt; This is the reply that I wrote to someone else who wanted a<br>&gt; private(extension) [2] modifier. Swift&#39;s access modifiers align with<br>&gt; linker access modifiers and visibility styles: `private` is not<br>&gt; exported beyond the translation unit (and can be very aggressively<br>&gt; optimized), `internal` is hidden (not exported to the dynamic symbol<br>&gt; table) and `public` is exported to the symbol table of the resulting<br>&gt; executable. `Private(set)` just means that the setter method is not<br>&gt; exported but the getter is.<br>&gt; <br>&gt; So as I said in the other thread, I wouldn&#39;t consider that these new<br>&gt; modifiers follow the example that private(set) set.<br></p><p>Okay, amend that statement to say that it follows the _syntactic_ <br>example of private(set). How it is implemented under the hood is just <br>that: implementation details.<br></p><p>&gt; The great thing about using the linker to implement access control is<br>&gt; that it can be enforced. The reason internal or private can&#39;t be<br>&gt; called from outside an executable is that no data about it exists in<br>&gt; the final executable As a matter of fact, the symbol itself might not<br>&gt; even exist in the fully optimized executable.<br></p><p>Access modifiers aren&#39;t just across linker boundaries. Private, <br>private(set), and, if implemented, private(call) would help enforce <br>boundaries between classes within a single module as well.<br></p><p>&gt; I also think that it&#39;s fundamentally the same as protected, because<br>&gt; nothing prevents you from sharing the logic outside. You can forward<br>&gt; the protected call to a public call, which is exactly the same as a<br>&gt; public call forwarding to a protected call in terms of encapsulation.<br></p><p>Um, if that&#39;s your metric, then private is fundamentally the same as <br>internal is the same as public, and there&#39;s no such thing as access <br>modifiers at all. *Anything* can be forwarded to a public call, whether <br>it&#39;s private, public, internal, my proposed private(call), or protected, <br>if it&#39;s done within the class that owns it. However, code from outside <br>the class (or struct, or enum, or whatever) wouldn&#39;t be able to access <br>something defined as private(call), even if it&#39;s a class and they&#39;re a <br>subclass of it, whereas with protected, if you&#39;re a subclass it&#39;s <br>basically open season.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 12, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;&gt; The reason internal or private can&#39;t be called from outside an executable is that no data about it exists in the final executable<br>&gt; <br>&gt; Actually, I believe internal symbols *are* in the final executable. (If they aren&#39;t now, they certainly were for a while.)<br></p><p><br>The LLVM bitcode for internal symbols has the &quot;hidden&quot; visibility style &lt;http://llvm.org/docs/LangRef.html#visibilitystyles&gt; (you can test with swift -emit-ir). It&#39;s possible that the symbol will show up in debug executables, but the intent is to get rid of it at release.<br></p><p>&gt; Le 12 janv. 2016 à 00:28:55, cocoadev at charlessoft.com a écrit :<br>&gt;&gt; The great thing about using the linker to implement access control is<br>&gt;&gt; that it can be enforced. The reason internal or private can&#39;t be<br>&gt;&gt; called from outside an executable is that no data about it exists in<br>&gt;&gt; the final executable As a matter of fact, the symbol itself might not<br>&gt;&gt; even exist in the fully optimized executable.<br>&gt; <br>&gt; Access modifiers aren&#39;t just across linker boundaries. Private, private(set), and, if implemented, private(call) would help enforce boundaries between classes within a single module as well.<br></p><p>Currently, access modifiers *are* just across linker boundaries. The translation unit (single file) level is a linker boundary. Private is very close to C&#39;s static.<br></p><p>&gt;&gt; I also think that it&#39;s fundamentally the same as protected, because<br>&gt;&gt; nothing prevents you from sharing the logic outside. You can forward<br>&gt;&gt; the protected call to a public call, which is exactly the same as a<br>&gt;&gt; public call forwarding to a protected call in terms of encapsulation.<br>&gt; <br>&gt; Um, if that&#39;s your metric, then private is fundamentally the same as internal is the same as public, and there&#39;s no such thing as access modifiers at all. *Anything* can be forwarded to a public call, whether it&#39;s private, public, internal, my proposed private(call), or protected, if it&#39;s done within the class that owns it. However, code from outside the class (or struct, or enum, or whatever) wouldn&#39;t be able to access something defined as private(call), even if it&#39;s a class and they&#39;re a subclass of it, whereas with protected, if you&#39;re a subclass it&#39;s basically open season.<br></p><p>They&#39;re not, because as the writer of the Swift library, *you* are in control of internal and private members. I believe that the worry has never been what you could do with your own code, but rather what others can do with your own code, and in the case of a `private(call)` member, if the person really wants that logic to be callable, they have means to do it (whereas they don&#39;t have the means to call an internal or private symbol).<br></p><p>The only un-abusable justification for the feature is to document that a symbol shouldn&#39;t be used directly, hence the suggestion to use documentation features to achieve that goal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/305205c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 02:00:00am</p></header><div class="content"><p>On 2016-01-12 01:36, Félix Cloutier wrote:<br></p><p>&gt; They&#39;re not, because as the writer of the Swift library, *you* are in<br>&gt; control of internal and private members. I believe that the worry has<br>&gt; never been what you could do with your own code, but rather what<br>&gt; others can do with your own code, and in the case of a `private(call)`<br>&gt; member, if the person really wants that logic to be callable, they<br>&gt; have means to do it (whereas they don&#39;t have the means to call an<br>&gt; internal or private symbol).<br></p><p>Unless we are talking about someone hacking their way in via C or <br>assembler or something, no, they don&#39;t have the means to do so. And if <br>we *are* talking about hacking, then that&#39;s impossible to prevent, <br>anyway, if someone is *really* determined. I mean, even if the stupid <br>thing is inlined, you could still disassemble the thing and <br>copy-and-paste out the relevant part. Making things 100% bulletproof is <br>not the goal, and if it were, we would have been publishing every single <br>API, private and public, in Objective-C, since in that language it was <br>staggeringly easy, even for a relative neophyte, to find and call <br>private methods on pretty much anything. Despite that, we still found it <br>useful to hide things in private headers and implementation files, which <br>suggests that access control does have a use beyond the linker level <br>after all.<br></p><p>&gt; The only un-abusable justification for the feature is to document that<br>&gt; a symbol shouldn&#39;t be used directly, hence the suggestion to use<br>&gt; documentation features to achieve that goal.<br></p><p>It has multiple goals:<br></p><p>1) To document that it shouldn&#39;t be called directly<br></p><p>2) To keep it from being called accidentally via code completion<br></p><p>3) To make it enough of a PITA to call that people will be more likely <br>to just do things the right way.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 12 janv. 2016 à 02:11:07, cocoadev at charlessoft.com a écrit :<br>&gt; <br>&gt; Unless we are talking about someone hacking their way in via C or assembler or something, no, they don&#39;t have the means to do so. And if we *are* talking about hacking, then that&#39;s impossible to prevent, anyway, if someone is *really* determined. I mean, even if the stupid thing is inlined, you could still disassemble the thing and copy-and-paste out the relevant part. Making things 100% bulletproof is not the goal, and if it were, we would have been publishing every single API, private and public, in Objective-C, since in that language it was staggeringly easy, even for a relative neophyte, to find and call private methods on pretty much anything. Despite that, we still found it useful to hide things in private headers and implementation files, which suggests that access control does have a use beyond the linker level after all.<br></p><p>class A {<br>	private(call) func logicYouShouldImplementButNotCall() {<br>	}<br>}<br></p><p>/* other module */ class B {<br>	private(call) override func logicYouShouldImplementButNotCall() {<br>		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>	}<br>	<br>	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>		/* snip */<br>	}<br>}<br></p><p>&gt;&gt; The only un-abusable justification for the feature is to document that<br>&gt;&gt; a symbol shouldn&#39;t be used directly, hence the suggestion to use<br>&gt;&gt; documentation features to achieve that goal.<br>&gt; <br>&gt; It has multiple goals:<br>&gt; <br>&gt; 1) To document that it shouldn&#39;t be called directly<br>&gt; <br>&gt; 2) To keep it from being called accidentally via code completion<br>&gt; <br>&gt; 3) To make it enough of a PITA to call that people will be more likely to just do things the right way.<br></p><p>I&#39;m not in favor of complexifying access control for the sake of documentation. The first two goals can be implemented with just a little more collaboration between tools and documentation and you can get 90% of the way there for the third one as well.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Are you allowed to call `super.functionMarkedPrivateCall()`?<br></p><p>Félix<br></p><p>&gt; Le 12 janv. 2016 à 11:58:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; Le 12 janv. 2016 à 02:11:07, cocoadev at charlessoft.com a écrit :<br>&gt;&gt; <br>&gt;&gt; Unless we are talking about someone hacking their way in via C or assembler or something, no, they don&#39;t have the means to do so. And if we *are* talking about hacking, then that&#39;s impossible to prevent, anyway, if someone is *really* determined. I mean, even if the stupid thing is inlined, you could still disassemble the thing and copy-and-paste out the relevant part. Making things 100% bulletproof is not the goal, and if it were, we would have been publishing every single API, private and public, in Objective-C, since in that language it was staggeringly easy, even for a relative neophyte, to find and call private methods on pretty much anything. Despite that, we still found it useful to hide things in private headers and implementation files, which suggests that access control does have a use beyond the linker level after all.<br>&gt; <br>&gt; class A {<br>&gt; 	private(call) func logicYouShouldImplementButNotCall() {<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; /* other module */ class B {<br>&gt; 	private(call) override func logicYouShouldImplementButNotCall() {<br>&gt; 		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>&gt; 	}<br>&gt; 	<br>&gt; 	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>&gt; 		/* snip */<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt;&gt;&gt; The only un-abusable justification for the feature is to document that<br>&gt;&gt;&gt; a symbol shouldn&#39;t be used directly, hence the suggestion to use<br>&gt;&gt;&gt; documentation features to achieve that goal.<br>&gt;&gt; <br>&gt;&gt; It has multiple goals:<br>&gt;&gt; <br>&gt;&gt; 1) To document that it shouldn&#39;t be called directly<br>&gt;&gt; <br>&gt;&gt; 2) To keep it from being called accidentally via code completion<br>&gt;&gt; <br>&gt;&gt; 3) To make it enough of a PITA to call that people will be more likely to just do things the right way.<br>&gt; <br>&gt; I&#39;m not in favor of complexifying access control for the sake of documentation. The first two goals can be implemented with just a little more collaboration between tools and documentation and you can get 90% of the way there for the third one as well.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/ed85f4bb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On 2016-01-12 11:58, Félix Cloutier wrote:<br>&gt;&gt; Le 12 janv. 2016 à 02:11:07, cocoadev at charlessoft.com a écrit :<br>&gt;&gt; <br>&gt;&gt; Unless we are talking about someone hacking their way in via C or <br>&gt;&gt; assembler or something, no, they don&#39;t have the means to do so. And if <br>&gt;&gt; we *are* talking about hacking, then that&#39;s impossible to prevent, <br>&gt;&gt; anyway, if someone is *really* determined. I mean, even if the stupid <br>&gt;&gt; thing is inlined, you could still disassemble the thing and <br>&gt;&gt; copy-and-paste out the relevant part. Making things 100% bulletproof <br>&gt;&gt; is not the goal, and if it were, we would have been publishing every <br>&gt;&gt; single API, private and public, in Objective-C, since in that language <br>&gt;&gt; it was staggeringly easy, even for a relative neophyte, to find and <br>&gt;&gt; call private methods on pretty much anything. Despite that, we still <br>&gt;&gt; found it useful to hide things in private headers and implementation <br>&gt;&gt; files, which suggests that access control does have a use beyond the <br>&gt;&gt; linker level after all.<br>&gt; <br>&gt; class A {<br>&gt; 	private(call) func logicYouShouldImplementButNotCall() {<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; /* other module */ class B {<br>&gt; 	private(call) override func logicYouShouldImplementButNotCall() {<br>&gt; 		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>&gt; 	}<br>&gt; <br>&gt; 	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>&gt; 		/* snip */<br>&gt; 	}<br>&gt; }<br></p><p>B can also expose any private method or property that it has via a <br>separate method.<br></p><p>class B {<br>     private func mineAllMine() {<br>         ohNoes()<br>     }<br></p><p>     func ohNoes() {}<br>}<br></p><p>How is that new?<br></p><p>Anyway, if the author of the class did that, I&#39;d assume they had some <br>reason for it. And if there *were* some reason to expose the logic <br>backing the primitive method, I&#39;d say it&#39;s better to create a new public <br>method anyway to make your intentions clear, rather than asking users to <br>call the method that according to your superclass&#39;s API contract isn&#39;t <br>supposed to be called.<br></p><p>Class B cannot call Class *A*&#39;s implementation of it, nor will a user of <br>both these classes mistake logicYouShouldImplementButNotCall() as <br>something they should use as an access point.<br></p><p>&gt; I&#39;m not in favor of complexifying access control for the sake of<br>&gt; documentation. The first two goals can be implemented with just a<br>&gt; little more collaboration between tools and documentation and you can<br>&gt; get 90% of the way there for the third one as well.<br></p><p>Again, things like -[NSView display] have long been a stumbling block <br>for newbies who often don&#39;t realize that they should be calling <br>-setNeedsDisplay: instead until someone tells them. We can make our APIs <br>more intuitive, and we should.<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The reason internal or private can&#39;t be called from outside an executable is that no data about it exists in the final executable<br></p><p>Actually, I believe internal symbols *are* in the final executable. (If they aren&#39;t now, they certainly were for a while.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 20:33 , Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; This is the reply that I wrote to someone else who wanted a private(extension) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005450.html&gt; modifier. Swift&#39;s access modifiers align with linker access modifiers and visibility styles: `private` is not exported beyond the translation unit (and can be very aggressively optimized), `internal` is hidden (not exported to the dynamic symbol table) and `public` is exported to the symbol table of the resulting executable. `Private(set)` just means that the setter method is not exported but the getter is. <br>&gt; <br>&gt; So as I said in the other thread, I wouldn&#39;t consider that these new modifiers follow the example that private(set) set.<br>&gt; <br>&gt; The great thing about using the linker to implement access control is that it can be enforced. The reason internal or private can&#39;t be called from outside an executable is that no data about it exists in the final executable As a matter of fact, the symbol itself might not even exist in the fully optimized executable.<br></p><p>This is not the recommended way to think about Swift access control, and it is not guaranteed. For example, an overridable internal method in a publicly-subclassable class currently needs to appear in a subclass&#39;s vtable, even if the subclass is in another module and cannot possibly override this method. That&#39;s an implementation detail, sure, and it isn&#39;t a long-term constraint (because we want you to always be allowed to add new methods), but it&#39;s an example of a case where symbol linkage doesn&#39;t match up with access control.<br></p><p>Access-control-related features should be evaluated on their own merits, not on the implementation details of exported and non-exported symbols.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/3dd85965/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 12, 2016 at 01:00:00pm</p></header><div class="content"><p>Le 11 janv. 2016 à 19:53, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; What do you think?<br></p><p>The idea looks good to me on the surface. But the details are awkward.<br></p><p>First, if you can&#39;t call the super implementation from an override, there is no need to require that the overriding function be private(call) because all it will contain is client code that can&#39;t call the library&#39;s implementation. So the derived class can make the function more visible by reimplementing it.<br></p><p>But that&#39;s not the common case. In general you want to allow the overriding function to call the super implementation. So...<br></p><p>Second, if you allow a call to the super implementation from an override, then you need to make that overriding function uncallable by anyone. Only the base class can call it using virtual dispatch. You can&#39;t call it even from the same file, so it&#39;s *less visible than private*.<br></p><p>That&#39;s a bit weird.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On 2016-01-12 13:50, Michel Fortin wrote:<br>&gt; Le 11 janv. 2016 à 19:53, Charles Srstka via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; The idea looks good to me on the surface. But the details are awkward.<br>&gt; <br>&gt; First, if you can&#39;t call the super implementation from an override,<br>&gt; there is no need to require that the overriding function be<br>&gt; private(call) because all it will contain is client code that can&#39;t<br>&gt; call the library&#39;s implementation. So the derived class can make the<br>&gt; function more visible by reimplementing it.<br></p><p>My thinking is that if the subclass wants to make the functionality <br>behind the method more visible, it&#39;s better to just spin it off into a <br>separate method rather than ask callers to get used to calling a method <br>that, according to the API contract of the superclass, is more an <br>implementation detail than a part of the external interface.<br></p><p>&gt; But that&#39;s not the common case. In general you want to allow the<br>&gt; overriding function to call the super implementation. So...<br>&gt; <br>&gt; Second, if you allow a call to the super implementation from an<br>&gt; override, then you need to make that overriding function uncallable by<br>&gt; anyone. Only the base class can call it using virtual dispatch. You<br>&gt; can&#39;t call it even from the same file, so it&#39;s *less visible than<br>&gt; private*.<br>&gt; <br>&gt; That&#39;s a bit weird.<br></p><p>It may be a bit weird, but it is what the API contract is already asking <br>the class to do. It&#39;s just that currently, it&#39;s not enforced other than <br>in documentation.<br></p><p>I should point out that we, essentially, already have methods like this; <br>Swift initializers, unlike init methods in Objective-C, are similarly <br>invisible; they cannot be called by any other code, even in the same <br>file, unless that code is marked as a convenience initializer. Deinit, <br>likewise, can&#39;t be called by anything except for the Swift runtime <br>itself.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>To be clear, I agree that there is a problem. I just perceive it as a documentation problem more than as an access control problem.<br></p><p>There are at least 2 other proposals that suggest(ed?) a more complex access control model (`private(extension)`, `private(objc)`), and I don&#39;t like adding exceptions to `private`.<br></p><p>Félix<br></p><p>&gt; Le 12 janv. 2016 à 16:43:39, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On 2016-01-12 13:50, Michel Fortin wrote:<br>&gt;&gt; Le 11 janv. 2016 à 19:53, Charles Srstka via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt; The idea looks good to me on the surface. But the details are awkward.<br>&gt;&gt; First, if you can&#39;t call the super implementation from an override,<br>&gt;&gt; there is no need to require that the overriding function be<br>&gt;&gt; private(call) because all it will contain is client code that can&#39;t<br>&gt;&gt; call the library&#39;s implementation. So the derived class can make the<br>&gt;&gt; function more visible by reimplementing it.<br>&gt; <br>&gt; My thinking is that if the subclass wants to make the functionality behind the method more visible, it&#39;s better to just spin it off into a separate method rather than ask callers to get used to calling a method that, according to the API contract of the superclass, is more an implementation detail than a part of the external interface.<br>&gt; <br>&gt;&gt; But that&#39;s not the common case. In general you want to allow the<br>&gt;&gt; overriding function to call the super implementation. So...<br>&gt;&gt; Second, if you allow a call to the super implementation from an<br>&gt;&gt; override, then you need to make that overriding function uncallable by<br>&gt;&gt; anyone. Only the base class can call it using virtual dispatch. You<br>&gt;&gt; can&#39;t call it even from the same file, so it&#39;s *less visible than<br>&gt;&gt; private*.<br>&gt;&gt; That&#39;s a bit weird.<br>&gt; <br>&gt; It may be a bit weird, but it is what the API contract is already asking the class to do. It&#39;s just that currently, it&#39;s not enforced other than in documentation.<br>&gt; <br>&gt; I should point out that we, essentially, already have methods like this; Swift initializers, unlike init methods in Objective-C, are similarly invisible; they cannot be called by any other code, even in the same file, unless that code is marked as a convenience initializer. Deinit, likewise, can&#39;t be called by anything except for the Swift runtime itself.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/ff10bdc6/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Le 12 janv. 2016 à 16:43, cocoadev at charlessoft.com a écrit :<br>&gt; <br>&gt; On 2016-01-12 13:50, Michel Fortin wrote:<br>&gt;&gt; Le 11 janv. 2016 à 19:53, Charles Srstka via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt; The idea looks good to me on the surface. But the details are awkward.<br>&gt;&gt; First, if you can&#39;t call the super implementation from an override,<br>&gt;&gt; there is no need to require that the overriding function be<br>&gt;&gt; private(call) because all it will contain is client code that can&#39;t<br>&gt;&gt; call the library&#39;s implementation. So the derived class can make the<br>&gt;&gt; function more visible by reimplementing it.<br>&gt; <br>&gt; My thinking is that if the subclass wants to make the functionality behind the method more visible, it&#39;s better to just spin it off into a separate method rather than ask callers to get used to calling a method that, according to the API contract of the superclass, is more an implementation detail than a part of the external interface.<br></p><p>True. In any case, this case isn&#39;t the problematic one.<br></p><p>&gt;&gt; But that&#39;s not the common case. In general you want to allow the<br>&gt;&gt; overriding function to call the super implementation. So...<br>&gt;&gt; Second, if you allow a call to the super implementation from an<br>&gt;&gt; override, then you need to make that overriding function uncallable by<br>&gt;&gt; anyone. Only the base class can call it using virtual dispatch. You<br>&gt;&gt; can&#39;t call it even from the same file, so it&#39;s *less visible than<br>&gt;&gt; private*.<br>&gt;&gt; That&#39;s a bit weird.<br>&gt; <br>&gt; It may be a bit weird, but it is what the API contract is already asking the class to do. It&#39;s just that currently, it&#39;s not enforced other than in documentation.<br></p><p>What I meant here is that you can&#39;t even mandate `private` at the override point because it&#39;s *less visible than private*. So writing `private` or `private(call)` at the override point is a lie. You can&#39;t define `private(call)` to mean &quot;private access for calling this but if there is a override keyword next to it then it means less visible than private and you can&#39;t call it&quot;, that&#39;s too awkward.<br></p><p>I understand what the API contract is, but all I&#39;m saying is that I wonder if there is a syntax that can express all this sanely.<br></p><p><br>&gt; I should point out that we, essentially, already have methods like this; Swift initializers, unlike init methods in Objective-C, are similarly invisible; they cannot be called by any other code, even in the same file, unless that code is marked as a convenience initializer. Deinit, likewise, can&#39;t be called by anything except for the Swift runtime itself.<br></p><p>Sure, but `init` and `deinit` in Swift are function-like constructs that aren&#39;t quite functions in order to accommodate all this. Surely you don&#39;t want to go that far here.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 09:00:00pm</p></header><div class="content"><p>On 2016-01-12 17:34, Michel Fortin wrote:<br></p><p>&gt;&gt; It may be a bit weird, but it is what the API contract is already <br>&gt;&gt; asking the class to do. It&#39;s just that currently, it&#39;s not enforced <br>&gt;&gt; other than in documentation.<br>&gt; <br>&gt; What I meant here is that you can&#39;t even mandate `private` at the<br>&gt; override point because it&#39;s *less visible than private*. So writing<br>&gt; `private` or `private(call)` at the override point is a lie. You can&#39;t<br>&gt; define `private(call)` to mean &quot;private access for calling this but if<br>&gt; there is a override keyword next to it then it means less visible than<br>&gt; private and you can&#39;t call it&quot;, that&#39;s too awkward.<br>&gt; <br>&gt; I understand what the API contract is, but all I&#39;m saying is that I<br>&gt; wonder if there is a syntax that can express all this sanely.<br></p><p>I&#39;ve read this paragraph a large number of times, and I still don&#39;t <br>understand what the objection is here.<br></p><p>1. It&#39;s not less visible than private, it&#39;s more visible by definition, <br>because it appears in the interface and you can interact with it (by <br>subclassing a class or implementing a protocol). If it were just plain <br>private, it would be completely invisible and there would be no way to <br>interact with it or even see that it exists outside of hacky things.<br></p><p>2. How this means that you can&#39;t mandate private(call), or that it would <br>be &quot;a lie&quot;, simply confuses me.<br></p><p>3. &quot;You can override this but you can&#39;t call it&quot; isn&#39;t too complicated <br>to wrap one&#39;s head around, and to my mind sums up this feature pretty <br>succinctly.<br></p><p>&gt;&gt; I should point out that we, essentially, already have methods like <br>&gt;&gt; this; Swift initializers, unlike init methods in Objective-C, are <br>&gt;&gt; similarly invisible; they cannot be called by any other code, even in <br>&gt;&gt; the same file, unless that code is marked as a convenience <br>&gt;&gt; initializer. Deinit, likewise, can&#39;t be called by anything except for <br>&gt;&gt; the Swift runtime itself.<br>&gt; <br>&gt; Sure, but `init` and `deinit` in Swift are function-like constructs<br>&gt; that aren&#39;t quite functions in order to accommodate all this. Surely<br>&gt; you don&#39;t want to go that far here.<br></p><p>Under the hood, they&#39;re just methods; if your class derives from <br>NSObject, you can even inspect it with the Objective-C runtime <br>functions. It&#39;s just that they have special semantics for calling them.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 12 janv. 2016 à 21:46, cocoadev at charlessoft.com a écrit :<br>&gt; <br>&gt; On 2016-01-12 17:34, Michel Fortin wrote:<br>&gt; <br>&gt;&gt;&gt; It may be a bit weird, but it is what the API contract is already asking the class to do. It&#39;s just that currently, it&#39;s not enforced other than in documentation.<br>&gt;&gt; What I meant here is that you can&#39;t even mandate `private` at the<br>&gt;&gt; override point because it&#39;s *less visible than private*. So writing<br>&gt;&gt; `private` or `private(call)` at the override point is a lie. You can&#39;t<br>&gt;&gt; define `private(call)` to mean &quot;private access for calling this but if<br>&gt;&gt; there is a override keyword next to it then it means less visible than<br>&gt;&gt; private and you can&#39;t call it&quot;, that&#39;s too awkward.<br>&gt;&gt; I understand what the API contract is, but all I&#39;m saying is that I<br>&gt;&gt; wonder if there is a syntax that can express all this sanely.<br>&gt; <br>&gt; I&#39;ve read this paragraph a large number of times, and I still don&#39;t understand what the objection is here.<br>&gt; <br>&gt; 1. It&#39;s not less visible than private, it&#39;s more visible by definition, because it appears in the interface and you can interact with it (by subclassing a class or implementing a protocol). If it were just plain private, it would be completely invisible and there would be no way to interact with it or even see that it exists outside of hacky things.<br></p><p>I realize I was probably mistaken by an example that was not written by you but by Félix Cloutier. If you were the one that wrote this example in the thread then my criticisms would apply:<br></p><p>class A {<br>	private(call) func logicYouShouldImplementButNotCall() {<br>	}<br>}<br></p><p>/* other module */ class B {<br>	private(call) override func logicYouShouldImplementButNotCall() {<br>		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>	}<br>	<br>	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>		/* snip */<br>	}<br>}<br></p><p>In this example, class B is qualified `private(call)`, but it can&#39;t be made private here (nor internal or public), because it has to be less visible than any of those. (Actually, to confuse things further it could because it does not call the super implementation, but let&#39;s ignore that for now.)<br></p><p><br>&gt; 2. How this means that you can&#39;t mandate private(call), or that it would be &quot;a lie&quot;, simply confuses me.<br>&gt; <br>&gt; 3. &quot;You can override this but you can&#39;t call it&quot; isn&#39;t too complicated to wrap one&#39;s head around, and to my mind sums up this feature pretty succinctly.<br></p><p>The question is: what is the syntax at the override point? I mistakenly thought it&#39;d require `private(call)` because I saw this example, but there&#39;s actually nothing about that in the initial proposal.<br></p><p>Sorry for the confusion.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>I do wonder if this is something that can have a clean technical solution. It *feels* to me like something better served by cleaner architecture and API design - where logic that is essentially part of a delegate helper is clearly identified in a seperate protocol.<br></p><p>-Simon<br></p><p><br>&gt; On 13 Jan 2016, at 2:18 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 12 janv. 2016 à 21:46, cocoadev at charlessoft.com a écrit :<br>&gt;&gt; <br>&gt;&gt; On 2016-01-12 17:34, Michel Fortin wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It may be a bit weird, but it is what the API contract is already asking the class to do. It&#39;s just that currently, it&#39;s not enforced other than in documentation.<br>&gt;&gt;&gt; What I meant here is that you can&#39;t even mandate `private` at the<br>&gt;&gt;&gt; override point because it&#39;s *less visible than private*. So writing<br>&gt;&gt;&gt; `private` or `private(call)` at the override point is a lie. You can&#39;t<br>&gt;&gt;&gt; define `private(call)` to mean &quot;private access for calling this but if<br>&gt;&gt;&gt; there is a override keyword next to it then it means less visible than<br>&gt;&gt;&gt; private and you can&#39;t call it&quot;, that&#39;s too awkward.<br>&gt;&gt;&gt; I understand what the API contract is, but all I&#39;m saying is that I<br>&gt;&gt;&gt; wonder if there is a syntax that can express all this sanely.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve read this paragraph a large number of times, and I still don&#39;t understand what the objection is here.<br>&gt;&gt; <br>&gt;&gt; 1. It&#39;s not less visible than private, it&#39;s more visible by definition, because it appears in the interface and you can interact with it (by subclassing a class or implementing a protocol). If it were just plain private, it would be completely invisible and there would be no way to interact with it or even see that it exists outside of hacky things.<br>&gt; <br>&gt; I realize I was probably mistaken by an example that was not written by you but by Félix Cloutier. If you were the one that wrote this example in the thread then my criticisms would apply:<br>&gt; <br>&gt; class A {<br>&gt; 	private(call) func logicYouShouldImplementButNotCall() {<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; /* other module */ class B {<br>&gt; 	private(call) override func logicYouShouldImplementButNotCall() {<br>&gt; 		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>&gt; 	}<br>&gt; 	<br>&gt; 	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>&gt; 		/* snip */<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; In this example, class B is qualified `private(call)`, but it can&#39;t be made private here (nor internal or public), because it has to be less visible than any of those. (Actually, to confuse things further it could because it does not call the super implementation, but let&#39;s ignore that for now.)<br>&gt; <br>&gt; <br>&gt;&gt; 2. How this means that you can&#39;t mandate private(call), or that it would be &quot;a lie&quot;, simply confuses me.<br>&gt;&gt; <br>&gt;&gt; 3. &quot;You can override this but you can&#39;t call it&quot; isn&#39;t too complicated to wrap one&#39;s head around, and to my mind sums up this feature pretty succinctly.<br>&gt; <br>&gt; The question is: what is the syntax at the override point? I mistakenly thought it&#39;d require `private(call)` because I saw this example, but there&#39;s actually nothing about that in the initial proposal.<br>&gt; <br>&gt; Sorry for the confusion.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca &lt;https://michelf.ca/&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/a5a4e07f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>On 2016-01-12 22:18, Michel Fortin wrote:<br></p><p>&gt; I realize I was probably mistaken by an example that was not written<br>&gt; by you but by Félix Cloutier. If you were the one that wrote this<br>&gt; example in the thread then my criticisms would apply:<br>&gt; <br>&gt; class A {<br>&gt; 	private(call) func logicYouShouldImplementButNotCall() {<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; /* other module */ class B {<br>&gt; 	private(call) override func logicYouShouldImplementButNotCall() {<br>&gt; 		iActuallyWantToCallItWhyWontYouLetMeDoIt()<br>&gt; 	}<br>&gt; <br>&gt; 	func iActuallyWantToCallItWhyWontYouLetMeDoIt() {<br>&gt; 		/* snip */<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; In this example, class B is qualified `private(call)`, but it can&#39;t be<br>&gt; made private here (nor internal or public), because it has to be less<br>&gt; visible than any of those. (Actually, to confuse things further it<br>&gt; could because it does not call the super implementation, but let&#39;s<br>&gt; ignore that for now.)<br></p><p>The class B isn&#39;t qualified &#39;private(call)&#39;, but rather just the method <br>it&#39;s overriding. The method itself would probably need to be <br>private(call) as well, because Swift requires methods to be at least as <br>visible as the original methods from a superclass or protocol. This bugs <br>me, actually, since it causes your class interface to be cluttered up by <br>stuff required for protocol conformance that could have been happily <br>left out of the header file in Objective-C, with callers still knowing <br>that those methods were supported due to their being present in a <br>protocol that the class implements, or in a superclass. But that&#39;s a <br>separate issue.<br></p><p>I&#39;m still confused by how something you can override but not call could <br>be considered less visible than something you can&#39;t override, call, or <br>even see.<br></p><p>&gt; <br>&gt;&gt; 2. How this means that you can&#39;t mandate private(call), or that it <br>&gt;&gt; would be &quot;a lie&quot;, simply confuses me.<br>&gt;&gt; <br>&gt;&gt; 3. &quot;You can override this but you can&#39;t call it&quot; isn&#39;t too complicated <br>&gt;&gt; to wrap one&#39;s head around, and to my mind sums up this feature pretty <br>&gt;&gt; succinctly.<br>&gt; <br>&gt; The question is: what is the syntax at the override point? I<br>&gt; mistakenly thought it&#39;d require `private(call)` because I saw this<br>&gt; example, but there&#39;s actually nothing about that in the initial<br>&gt; proposal.<br>&gt; <br>&gt; Sorry for the confusion.<br></p><p>Well, Swift&#39;s existing rules state that the overriding method needs to <br>be at least as visible as in the superclass, so private is already out. <br>Whether you can change it to internal or public depends on whether you <br>feel that it should be possible to make a primitive method more visible <br>and have people calling it. Personally, my thought on the matter is that <br>if you want to expose that functionality, it&#39;s better to spin it off <br>into a separate method as Félix did, but you could argue either way on <br>that, I suppose.<br></p><p>In any case, the most common use case, and the one that IMO makes the <br>most sense, would be to define the overriding method as private(call) as <br>well.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 12, 2016 at 11:00:00pm</p></header><div class="content"><p>Le 12 janv. 2016 à 22:52, cocoadev at charlessoft.com a écrit :<br></p><p>&gt; In any case, the most common use case, and the one that IMO makes the most sense, would be to define the overriding method as private(call) as well.<br></p><p>Ok then, that&#39;s the lie. (Not that you&#39;re lying, but the syntax you propose is a lie.)<br></p><p>When I read `private(call)`, I read it &quot;private visibility for calling the method&quot;, just like `private(set)` means &quot;private visibility for the setter&quot;. A private visibility limits the usage to the current file. And the usage being limited to the current file is the ability to call the method.<br></p><p>When you apply `private(call)` in the base class context, the method is callable only from the current file (thus the call ability is private). That&#39;s exactly what&#39;s needed. All is good.<br></p><p>But when you apply `private(call)` at the override point, you want the method to not be callable from the current file. The syntax is saying the call ability is private (limited to the current file), but that&#39;s simply not true. What you really want to say here is `unavailable(call)`, but that does not exist.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>January 12, 2016 at 11:00:00pm</p></header><div class="content"><p>I am not an expert, but if we were to do anything along these lines at all,<br>wouldn’t it make more sense to have something like @warn_on_call with which<br>to annotate functions/methods that should never be called from client code<br>but may need to be overridden? IDE’s could hide those items from<br>autocomplete too.<br></p><p>Nevin<br></p><p>On Tue, Jan 12, 2016 at 11:16 PM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Le 12 janv. 2016 à 22:52, cocoadev at charlessoft.com a écrit :<br>&gt;<br>&gt; &gt; In any case, the most common use case, and the one that IMO makes the<br>&gt; most sense, would be to define the overriding method as private(call) as<br>&gt; well.<br>&gt;<br>&gt; Ok then, that&#39;s the lie. (Not that you&#39;re lying, but the syntax you<br>&gt; propose is a lie.)<br>&gt;<br>&gt; When I read `private(call)`, I read it &quot;private visibility for calling the<br>&gt; method&quot;, just like `private(set)` means &quot;private visibility for the<br>&gt; setter&quot;. A private visibility limits the usage to the current file. And the<br>&gt; usage being limited to the current file is the ability to call the method.<br>&gt;<br>&gt; When you apply `private(call)` in the base class context, the method is<br>&gt; callable only from the current file (thus the call ability is private).<br>&gt; That&#39;s exactly what&#39;s needed. All is good.<br>&gt;<br>&gt; But when you apply `private(call)` at the override point, you want the<br>&gt; method to not be callable from the current file. The syntax is saying the<br>&gt; call ability is private (limited to the current file), but that&#39;s simply<br>&gt; not true. What you really want to say here is `unavailable(call)`, but that<br>&gt; does not exist.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/d8205ea6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private(call) and internal(call)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 13, 2016 at 01:00:00am</p></header><div class="content"><p>On 2016-01-12 23:16, Michel Fortin wrote:<br>&gt; Le 12 janv. 2016 à 22:52, cocoadev at charlessoft.com a écrit :<br>&gt; <br>&gt;&gt; In any case, the most common use case, and the one that IMO makes the <br>&gt;&gt; most sense, would be to define the overriding method as private(call) <br>&gt;&gt; as well.<br>&gt; <br>&gt; Ok then, that&#39;s the lie. (Not that you&#39;re lying, but the syntax you<br>&gt; propose is a lie.)<br>&gt; <br>&gt; When I read `private(call)`, I read it &quot;private visibility for calling<br>&gt; the method&quot;, just like `private(set)` means &quot;private visibility for<br>&gt; the setter&quot;. A private visibility limits the usage to the current<br>&gt; file. And the usage being limited to the current file is the ability<br>&gt; to call the method.<br>&gt; <br>&gt; When you apply `private(call)` in the base class context, the method<br>&gt; is callable only from the current file (thus the call ability is<br>&gt; private). That&#39;s exactly what&#39;s needed. All is good.<br>&gt; <br>&gt; But when you apply `private(call)` at the override point, you want the<br>&gt; method to not be callable from the current file. The syntax is saying<br>&gt; the call ability is private (limited to the current file), but that&#39;s<br>&gt; simply not true. What you really want to say here is<br>&gt; `unavailable(call)`, but that does not exist.<br></p><p>Ah, I see what you&#39;re saying, that the private(call) in B implies that B <br>can call it. It&#39;s a semantic issue. Well, if you want to have the <br>subclass&#39;s implementation declared as unavailable(call), that works.<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
