<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Changing how nominal type descriptors store type names</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Nominal type descriptors currently store the mangled name of the type they represent, but I don&#39;t think this is necessary or optimal. I don&#39;t believe the string is directly used for uniquing, and it&#39;s mostly used for reflective purposes. Since we&#39;ve decided we want to use a human-parsable syntax for runtime type lookup, a more structured representation would likely be easier to match. Furthermore, since every mangled name includes the containing module name, there&#39;s a lot of redundancy in the mangled strings for every type. If we instead store only the unqualified type name, and a reference to the module name as a separate string, that&#39;s likely to be more space-efficient, since all types can share the same module name string, and most module names are shorter than the four bytes necessary for a relative reference. So instead of:<br></p><p>@&quot;nominal type descriptor for Foo.Bar&quot; = {<br>  .name = relative reference to &quot;C3Foo3Bar&quot;,<br>}<br></p><p>we&#39;d have:<br></p><p>@&quot;nominal type descriptor for Foo.Bar&quot; = {<br>  .name = relative reference to &quot;Bar&quot;,<br>  .moduleName = relative reference to &quot;Foo&quot;<br>}<br></p><p><br>The one exception is the standard library, which gets a special one-character mangling; we could maybe pack an &quot;is in standard library&quot; bit somewhere so we avoid storing an extra reference in that case. Any objections or concerns?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Changing how nominal type descriptors store type names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 06:00:00pm</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 6:21 PM, Joe Groff via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;   .name = relative reference to &quot;Bar&quot;,<br>&gt;   .moduleName = relative reference to &quot;Foo&quot;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The one exception is the standard library, which gets a special one-character mangling; we could maybe pack an &quot;is in standard library&quot; bit somewhere so we avoid storing an extra reference in that case. Any objections or concerns?<br></p><p>Since `moduleName` can&#39;t be 0, you can define 0 to mean &quot;Swift<br>module&quot;.  You can also reserve a few low integers, say 0..&lt;1024, for<br>other special names -- like __C.  Maybe others will come up in future.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Changing how nominal type descriptors store type names</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 6:21 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Nominal type descriptors currently store the mangled name of the type they represent, but I don&#39;t think this is necessary or optimal. I don&#39;t believe the string is directly used for uniquing, and it&#39;s mostly used for reflective purposes. Since we&#39;ve decided we want to use a human-parsable syntax for runtime type lookup, a more structured representation would likely be easier to match. Furthermore, since every mangled name includes the containing module name, there&#39;s a lot of redundancy in the mangled strings for every type. If we instead store only the unqualified type name, and a reference to the module name as a separate string, that&#39;s likely to be more space-efficient, since all types can share the same module name string, and most module names are shorter than the four bytes necessary for a relative reference. So instead of:<br>&gt; <br>&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;  .name = relative reference to &quot;C3Foo3Bar&quot;,<br>&gt; }<br>&gt; <br>&gt; we&#39;d have:<br>&gt; <br>&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;  .name = relative reference to &quot;Bar&quot;,<br>&gt;  .moduleName = relative reference to &quot;Foo&quot;<br>&gt; }<br>&gt; <br>&gt; <br>&gt; The one exception is the standard library, which gets a special one-character mangling; we could maybe pack an &quot;is in standard library&quot; bit somewhere so we avoid storing an extra reference in that case. Any objections or concerns?<br></p><p>Maybe we should just make a module descriptor and make this a relative reference to that.  There are a lot of things that naturally make sense to have in a module descriptor, e.g. a list of the public types; even if we don’t want to record that explicitly, it makes sense to have a unique structure representing it.<br></p><p>For now, I guess the easiest thing would be to emit it with shared linkage.  In the long run, it’s reasonable to ask the build system to declare some file to be the primary file of the module; for a dylib, the choice would be arbitrary.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Changing how nominal type descriptors store type names</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 12:06 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 6:21 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Nominal type descriptors currently store the mangled name of the type they represent, but I don&#39;t think this is necessary or optimal. I don&#39;t believe the string is directly used for uniquing, and it&#39;s mostly used for reflective purposes. Since we&#39;ve decided we want to use a human-parsable syntax for runtime type lookup, a more structured representation would likely be easier to match. Furthermore, since every mangled name includes the containing module name, there&#39;s a lot of redundancy in the mangled strings for every type. If we instead store only the unqualified type name, and a reference to the module name as a separate string, that&#39;s likely to be more space-efficient, since all types can share the same module name string, and most module names are shorter than the four bytes necessary for a relative reference. So instead of:<br>&gt;&gt; <br>&gt;&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;&gt; .name = relative reference to &quot;C3Foo3Bar&quot;,<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; we&#39;d have:<br>&gt;&gt; <br>&gt;&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;&gt; .name = relative reference to &quot;Bar&quot;,<br>&gt;&gt; .moduleName = relative reference to &quot;Foo&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The one exception is the standard library, which gets a special one-character mangling; we could maybe pack an &quot;is in standard library&quot; bit somewhere so we avoid storing an extra reference in that case. Any objections or concerns?<br>&gt; <br>&gt; Maybe we should just make a module descriptor and make this a relative reference to that.  There are a lot of things that naturally make sense to have in a module descriptor, e.g. a list of the public types; even if we don’t want to record that explicitly, it makes sense to have a unique structure representing it.<br>&gt; <br>&gt; For now, I guess the easiest thing would be to emit it with shared linkage.  In the long run, it’s reasonable to ask the build system to declare some file to be the primary file of the module; for a dylib, the choice would be arbitrary.<br></p><p>ld64 also doesn&#39;t seem to like relative references to undefined symbols, so we&#39;d need to fix that too before getting away from emitting a module descriptor as shared.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Changing how nominal type descriptors store type names</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 12:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 25, 2016, at 12:06 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 6:21 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nominal type descriptors currently store the mangled name of the type they represent, but I don&#39;t think this is necessary or optimal. I don&#39;t believe the string is directly used for uniquing, and it&#39;s mostly used for reflective purposes. Since we&#39;ve decided we want to use a human-parsable syntax for runtime type lookup, a more structured representation would likely be easier to match. Furthermore, since every mangled name includes the containing module name, there&#39;s a lot of redundancy in the mangled strings for every type. If we instead store only the unqualified type name, and a reference to the module name as a separate string, that&#39;s likely to be more space-efficient, since all types can share the same module name string, and most module names are shorter than the four bytes necessary for a relative reference. So instead of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;&gt;&gt; .name = relative reference to &quot;C3Foo3Bar&quot;,<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; we&#39;d have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @&quot;nominal type descriptor for Foo.Bar&quot; = {<br>&gt;&gt;&gt; .name = relative reference to &quot;Bar&quot;,<br>&gt;&gt;&gt; .moduleName = relative reference to &quot;Foo&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one exception is the standard library, which gets a special one-character mangling; we could maybe pack an &quot;is in standard library&quot; bit somewhere so we avoid storing an extra reference in that case. Any objections or concerns?<br>&gt;&gt; <br>&gt;&gt; Maybe we should just make a module descriptor and make this a relative reference to that.  There are a lot of things that naturally make sense to have in a module descriptor, e.g. a list of the public types; even if we don’t want to record that explicitly, it makes sense to have a unique structure representing it.<br>&gt;&gt; <br>&gt;&gt; For now, I guess the easiest thing would be to emit it with shared linkage.  In the long run, it’s reasonable to ask the build system to declare some file to be the primary file of the module; for a dylib, the choice would be arbitrary.<br>&gt; <br>&gt; ld64 also doesn&#39;t seem to like relative references to undefined symbols, so we&#39;d need to fix that too before getting away from emitting a module descriptor as shared.<br></p><p>Ah, okay.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
