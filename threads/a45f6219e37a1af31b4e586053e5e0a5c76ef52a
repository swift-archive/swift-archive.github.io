<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Submitted] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 24, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>This is just an informational note to say that the widely-discussed proposal below has now been submitted as a pull request:<br></p><p>https://github.com/apple/swift-evolution/pull/171 &lt;https://github.com/apple/swift-evolution/pull/171&gt;<br></p><p>Evan<br></p><p>---<br></p><p>Allow using optional binding to upgrade self from a weak to strong reference<br></p><p>Proposal: SE-NNNN<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Awaiting Review<br>Review manager: TBD<br> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#introduction&gt;Introduction<br></p><p>When working with escaping Swift closures, it is a common pattern to have the closure capture self weakly to avoid creating an object reference cycle.<br></p><p>For example, let’s say you have a view controller that displays the result of a network operation. When the view controller is placed onscreen, it starts the operation and provides a closure to be executed upon completion.<br></p><p>The fact that a network operation may be in-flight should not prevent user from navigating away from that view controller. Similarly, we don’t want a pending network operation to prevent our view controller from being deallocated after it goes offscreen. In other words, we only care about the network operation while the view controller is alive; once the view controller has been deallocated, we can safely ignore the result of any network request it initiated.<br></p><p>To achieve this, the networking code might look something like:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let strongSelf = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        strongSelf.processData(data)<br></p><p>    case .Failed(let err):<br>        strongSelf.handleError(err)<br>    }<br>}<br>When it comes time to execute this closure, the guard statement effectively asks the question, “Is the view controller represented by self still alive?” If the answer is no, the guard forces a return and the rest of the closure does not execute.<br></p><p>If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure’s execution.<br></p><p>When the closure finishes, strongSelf goes away, once again making the view controller represented by self eligible for deallocation if no other references are held.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#the-problem&gt;The Problem<br></p><p>The only available mechanism for upgrading a weak self to a strong reference requires the creation of a self-like variable with an arbitrary name—in the example above, strongSelf.<br></p><p>Because there is no compiler-level mechanism for enforcing a consistent name across an entire codebase, in some instances strongSelf may be ss or it may be s or it may be a random sequence of characters that captures the developer’s mood of the moment.<br></p><p>This lack of consistency adds noise to the codebase, and makes code harder to reason about, especially in cases where the strong reference is held by a variable with a name more cryptic than strongSelf.<br></p><p>Being able to upgrade self from a weak reference to a strong reference while retaining the name self would be ideal, and it would be consistent with the existing Swift convention of optional binding that reuses the name of the optional variable, eg.:<br></p><p>// foo is an optional here<br>if let foo = foo {<br>    // foo is non-optional here;<br>    // the optional foo is masked within this scope<br>}<br>// foo is once again an optional here<br> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution entails allowing self to be upgraded from a weak reference to a strong reference using optional binding.<br></p><p>In any scope where self is a weak reference, the compiler will accept an if or guard statement containing an optional binding that upgrades self to a strong reference.<br></p><p>This would allow self to keep its meaningful name instead of being renamed to something arbitrary.<br></p><p>With this feature, the code above could be rewritten as:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let self = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br>The following would also be legal:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    if let self = self {<br>        switch result {<br>        case .Succeeded(let data):<br>            self.processData(data)<br></p><p>        case .Failed(let err):<br>            self.handleError(err)<br>        }<br>    }<br>}<br> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#behavior&gt;Behavior<br></p><p>Regardless of which notation is used for this feature, the behavior is the same:<br></p><p>The strong self can only be assigned from the optional self resulting from a weak capture in a closure.<br></p><p>Once bound, the strong self follows the same scoping rules as any other optionally-bound variable.<br></p><p>While the strong self is in scope, it masks the weak self variable. If the strong reference to self goes out of scope before the weak self reference does, the weak self will once again be visible to code.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#restrictions&gt;Restrictions<br></p><p>To ensure safety, the compiler will enforce certain restrictions on the use of this feature:<br></p><p>Attempting to use this feature in a context where self is not a weak reference will cause a compiler error. <br></p><p>Binding of self may only be used with let; attempting to bind self to a var is an error. (Because this feature only works with object references and not value types, this restriction does not affect the mutability of self.)<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#status-quo&gt;Status quo<br></p><p>The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br></p><p>As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects.<br></p><p>Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code’s original intent, making it harder to reason about.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#relying-on-a-compiler-bug&gt;Relying on a compiler bug<br></p><p>There is a bug in current versions of the Swift compiler that allow self to be assigned when the word is surrounded by backticks.<br></p><p>This bug causes the following code to compile and work:<br></p><p>guard let `self` = self else {<br>    return<br>}<br>Apple’s Chris Lattner has stated that “this is a compiler bug &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007425.html&gt;”.<br></p><p>Therefore, we should not rely on this “feature” to work in the future, because the bug will (presumably) be fixed eventually.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#adding-a-new-guard-capture-type&gt;Adding a new guard capture type<br></p><p>An alternate to this proposal involves adding a new capture type, called guard &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, which would automatically handle upgrading self (and other references) from weak to strong.<br></p><p>Although the alternate proposal received a favorable response from the Swift Evolution mailing list, the community seemed split between the approach outlined in that proposal, and the one outlined here.<br></p><p> &lt;https://github.com/emaloney/swift-evolution/blob/upgrade-self-from-weak-to-strong/proposals/NNNN-upgrade-self-from-weak-to-strong.md#citations&gt;Citations<br></p><p>Variations on this proposal were discussed earlier in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; threads:<br></p><p>Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;<br>[Proposal] Allow upgrading weak self to strong self by assignment &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010691.html&gt;<br>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010759.html&gt;<br>[Last Call] Allow using optional binding to upgrade self from a weak to strong reference &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010904.html&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/a45ff52a/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
