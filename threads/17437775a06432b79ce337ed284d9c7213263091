<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December  3, 2015 at 12:00:00pm</p></header><div class="content"><p>There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br></p><p>- Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>- Double Block (one for success, one for failure)<br>- Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ &lt;http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/&gt;)<br></p><p>Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br></p><p>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/17433091/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; <br>&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt; <br>&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt; - Double Block (one for success, one for failure)<br>&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ &lt;http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/&gt;)<br>&gt; <br>&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br></p><p>This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/bcce16d6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>A couple of points to think about:<br></p><p>- Seems to me like Swift&#39;s error handling should be discussed at the same time because asynchronous callbacks is the only case where we need to revert back to using NSError instead of using Swift?s error handling. What can the language do for us?<br></p><p>- This is slightly off-topic, but do we profit from Swift as a new language to move to a completely different paradigm like Promises?<br></p><p>David<br></p><p>&gt; On 03 Dec 2015, at 23:15, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com &lt;mailto:daniel.j.stenmark at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt; <br>&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ &lt;http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/&gt;)<br>&gt;&gt; <br>&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt; <br>&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/31cdcf07/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>December  4, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com &lt;mailto:daniel.j.stenmark at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt; <br>&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ &lt;http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/&gt;)<br>&gt;&gt; <br>&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt; <br>&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br></p><p>Hi Dan!<br></p><p>I think guidelines in this area would be great.<br></p><p>Here are the tradeoffs I think we have for each approach:<br></p><p>1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.<br></p><p>2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code. <br></p><p>Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.<br></p><p>Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.<br></p><p>     /*<br>          Single block.<br>          Trailing closure syntax works well.<br>     */<br>     request.fetch { result, error in<br>          // More indented code since we need to use guard or if let.<br>          guard let result = result else {<br>               // Need to force unwrap `error`.<br>               handleFetchError(error!) <br>               return <br>          }<br></p><p>          use(result)<br>     }<br></p><p>     /*<br>          Double block.<br>          Trailing closure syntax is awkward here.<br>     */<br>     request.fetch(withCompletionHandler: { result in<br>          use(result)          <br>     }, errorHandler: { error in<br>          // Don?t need to force unwrap `error`.<br>          handleFetchError(error) <br>     })<br></p><p>3) Enums with associated values are conceptually nice, but unless we have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.<br></p><p>Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?<br></p><p>Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.<br></p><p>- Alex<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e429cbf6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>What if there was a possibility for a deferred throw?<br></p><p>For example, imagine the fetch function was something like this:<br></p><p>func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {}<br></p><p>And to call it, you?d wrap it in a try with a new kind of catch:<br></p><p>do {<br>  try request.fetch() { result in ? }<br>} defer catch (? pattern) {<br>}<br></p><p>So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.<br></p><p>The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:<br></p><p>func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {<br>  var context = FetchContext()<br>  context.completionHandler = withCompletionHandler<br>  context.errorHandler = { reason in throw RequestError(reason) }<br>  self.pending.append(context)<br>  context.start()<br>}<br></p><p>Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 4, 2015, at 10:57 AM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt;&gt; <br>&gt;&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br>&gt; <br>&gt; Hi Dan!<br>&gt; <br>&gt; I think guidelines in this area would be great.<br>&gt; <br>&gt; Here are the tradeoffs I think we have for each approach:<br>&gt; <br>&gt; 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.<br>&gt; <br>&gt; 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code. <br>&gt; <br>&gt; Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.<br>&gt; <br>&gt; Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.<br>&gt; <br>&gt;      /*<br>&gt;           Single block.<br>&gt;           Trailing closure syntax works well.<br>&gt;      */<br>&gt;      request.fetch { result, error in<br>&gt;           // More indented code since we need to use guard or if let.<br>&gt;           guard let result = result else {<br>&gt;                // Need to force unwrap `error`.<br>&gt;                handleFetchError(error!) <br>&gt;                return <br>&gt;           }<br>&gt; <br>&gt;           use(result)<br>&gt;      }<br>&gt; <br>&gt;      /*<br>&gt;           Double block.<br>&gt;           Trailing closure syntax is awkward here.<br>&gt;      */<br>&gt;      request.fetch(withCompletionHandler: { result in<br>&gt;           use(result)          <br>&gt;      }, errorHandler: { error in<br>&gt;           // Don?t need to force unwrap `error`.<br>&gt;           handleFetchError(error) <br>&gt;      })<br>&gt; <br>&gt; 3) Enums with associated values are conceptually nice, but unless we have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.<br>&gt; <br>&gt; Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?<br>&gt; <br>&gt; Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>December  4, 2015 at 01:00:00pm</p></header><div class="content"><p>I really like the idea of using try/catches, it seems like a more swifty approach. However, I&#39;d prefer to do it in a way that doesn&#39;t add a new syntax.<br></p><p>Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)<br></p><p>&gt; On Dec 4, 2015, at 12:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; What if there was a possibility for a deferred throw?<br>&gt; <br>&gt; For example, imagine the fetch function was something like this:<br>&gt; <br>&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {}<br>&gt; <br>&gt; And to call it, you?d wrap it in a try with a new kind of catch:<br>&gt; <br>&gt; do {<br>&gt;  try request.fetch() { result in ? }<br>&gt; } defer catch (? pattern) {<br>&gt; }<br>&gt; <br>&gt; So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.<br>&gt; <br>&gt; The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:<br>&gt; <br>&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {<br>&gt;  var context = FetchContext()<br>&gt;  context.completionHandler = withCompletionHandler<br>&gt;  context.errorHandler = { reason in throw RequestError(reason) }<br>&gt;  self.pending.append(context)<br>&gt;  context.start()<br>&gt; }<br>&gt; <br>&gt; Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 10:57 AM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt;&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt;&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br>&gt;&gt; <br>&gt;&gt; Hi Dan!<br>&gt;&gt; <br>&gt;&gt; I think guidelines in this area would be great.<br>&gt;&gt; <br>&gt;&gt; Here are the tradeoffs I think we have for each approach:<br>&gt;&gt; <br>&gt;&gt; 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.<br>&gt;&gt; <br>&gt;&gt; 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code. <br>&gt;&gt; <br>&gt;&gt; Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.<br>&gt;&gt; <br>&gt;&gt; Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.<br>&gt;&gt; <br>&gt;&gt;     /*<br>&gt;&gt;          Single block.<br>&gt;&gt;          Trailing closure syntax works well.<br>&gt;&gt;     */<br>&gt;&gt;     request.fetch { result, error in<br>&gt;&gt;          // More indented code since we need to use guard or if let.<br>&gt;&gt;          guard let result = result else {<br>&gt;&gt;               // Need to force unwrap `error`.<br>&gt;&gt;               handleFetchError(error!) <br>&gt;&gt;               return <br>&gt;&gt;          }<br>&gt;&gt; <br>&gt;&gt;          use(result)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /*<br>&gt;&gt;          Double block.<br>&gt;&gt;          Trailing closure syntax is awkward here.<br>&gt;&gt;     */<br>&gt;&gt;     request.fetch(withCompletionHandler: { result in<br>&gt;&gt;          use(result)          <br>&gt;&gt;     }, errorHandler: { error in<br>&gt;&gt;          // Don?t need to force unwrap `error`.<br>&gt;&gt;          handleFetchError(error) <br>&gt;&gt;     })<br>&gt;&gt; <br>&gt;&gt; 3) Enums with associated values are conceptually nice, but unless we have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.<br>&gt;&gt; <br>&gt;&gt; Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?<br>&gt;&gt; <br>&gt;&gt; Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>Hey Alex!<br></p><p>I completely agree that the double-block approach is advantageous for its reduced unwrapping, but the only issue I have is that, when applied in production, it typically leads to duplicate code.<br></p><p>request.fetch(withCompletionHandler: { result in<br>          activityIndicator.stopAnimating()<br>          button.enabled = true<br>          tableView.hidden = false<br></p><p>          use(result)          <br></p><p>          print( ?Foo!? )<br></p><p>     }, errorHandler: { error in<br>          activityIndicator.stopAnimating()<br>          button.enabled = true<br>          tableView.hidden = false<br></p><p>          // Don?t need to force unwrap `error`.<br>          handleFetchError(error)<br></p><p>          print( ?Foo!? )<br></p><p>     })<br></p><p>The same issue is present in the aforementioned deferred throw concept.  There?re certainly ways to mitigate the problem, but no practical way of eliminating it altogether.  I?m personally leaning towards an evolution of the Enum-based approach for this very reason, but if a solution can be figured out to remove such code duplication, I?d happily adopt double-blocks.<br></p><p>Dan<br></p><p>&gt; On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini &lt;vinivendra at gmail.com&gt; wrote:<br>&gt; <br>&gt; I really like the idea of using try/catches, it seems like a more swifty approach. However, I&#39;d prefer to do it in a way that doesn&#39;t add a new syntax.<br>&gt; <br>&gt; Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 12:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What if there was a possibility for a deferred throw?<br>&gt;&gt; <br>&gt;&gt; For example, imagine the fetch function was something like this:<br>&gt;&gt; <br>&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {}<br>&gt;&gt; <br>&gt;&gt; And to call it, you?d wrap it in a try with a new kind of catch:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; try request.fetch() { result in ? }<br>&gt;&gt; } defer catch (? pattern) {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.<br>&gt;&gt; <br>&gt;&gt; The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:<br>&gt;&gt; <br>&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {<br>&gt;&gt; var context = FetchContext()<br>&gt;&gt; context.completionHandler = withCompletionHandler<br>&gt;&gt; context.errorHandler = { reason in throw RequestError(reason) }<br>&gt;&gt; self.pending.append(context)<br>&gt;&gt; context.start()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 10:57 AM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt;&gt;&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt;&gt;&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dan!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think guidelines in this area would be great.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are the tradeoffs I think we have for each approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    /*<br>&gt;&gt;&gt;         Single block.<br>&gt;&gt;&gt;         Trailing closure syntax works well.<br>&gt;&gt;&gt;    */<br>&gt;&gt;&gt;    request.fetch { result, error in<br>&gt;&gt;&gt;         // More indented code since we need to use guard or if let.<br>&gt;&gt;&gt;         guard let result = result else {<br>&gt;&gt;&gt;              // Need to force unwrap `error`.<br>&gt;&gt;&gt;              handleFetchError(error!) <br>&gt;&gt;&gt;              return <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         use(result)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    /*<br>&gt;&gt;&gt;         Double block.<br>&gt;&gt;&gt;         Trailing closure syntax is awkward here.<br>&gt;&gt;&gt;    */<br>&gt;&gt;&gt;    request.fetch(withCompletionHandler: { result in<br>&gt;&gt;&gt;         use(result)          <br>&gt;&gt;&gt;    }, errorHandler: { error in<br>&gt;&gt;&gt;         // Don?t need to force unwrap `error`.<br>&gt;&gt;&gt;         handleFetchError(error) <br>&gt;&gt;&gt;    })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) Enums with associated values are conceptually nice, but unless we have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Alex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/82fb6e65/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  4, 2015 at 01:00:00pm</p></header><div class="content"><p>I think that the code duplication issue is more of an API design side effect. If the API was designed with a 3rd block for when it is ?done? regardless of error, then you could put that shared code there - but I would imagine that?d be out of the scope of Swift itself. What I often do in these situations is just make a local function that does the shared stuff and then call it from both blocks:<br></p><p>func finished() {<br>          activityIndicator.stopAnimating()<br>          button.enabled = true<br>          tableView.hidden = false<br>}<br></p><p>request.fetch(withCompletionHandler: { result in<br>          finished()<br>          use(result)<br>     }, errorHandler: { error in<br>          finished()<br>          handleFetchError(error)<br>     })<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 4, 2015, at 1:13 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey Alex!<br>&gt; <br>&gt; I completely agree that the double-block approach is advantageous for its reduced unwrapping, but the only issue I have is that, when applied in production, it typically leads to duplicate code.<br>&gt; <br>&gt; request.fetch(withCompletionHandler: { result in<br>&gt;           activityIndicator.stopAnimating()<br>&gt;           button.enabled = true<br>&gt;           tableView.hidden = false<br>&gt; <br>&gt;           use(result)          <br>&gt; <br>&gt;           print( ?Foo!? )<br>&gt; <br>&gt;      }, errorHandler: { error in<br>&gt;           activityIndicator.stopAnimating()<br>&gt;           button.enabled = true<br>&gt;           tableView.hidden = false<br>&gt; <br>&gt;           // Don?t need to force unwrap `error`.<br>&gt;           handleFetchError(error)<br>&gt; <br>&gt;           print( ?Foo!? )<br>&gt; <br>&gt;      })<br>&gt; <br>&gt; The same issue is present in the aforementioned deferred throw concept.  There?re certainly ways to mitigate the problem, but no practical way of eliminating it altogether.  I?m personally leaning towards an evolution of the Enum-based approach for this very reason, but if a solution can be figured out to remove such code duplication, I?d happily adopt double-blocks.<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini &lt;vinivendra at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like the idea of using try/catches, it seems like a more swifty approach. However, I&#39;d prefer to do it in a way that doesn&#39;t add a new syntax.<br>&gt;&gt; <br>&gt;&gt; Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 12:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if there was a possibility for a deferred throw?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, imagine the fetch function was something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And to call it, you?d wrap it in a try with a new kind of catch:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; try request.fetch() { result in ? }<br>&gt;&gt;&gt; } defer catch (? pattern) {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {<br>&gt;&gt;&gt; var context = FetchContext()<br>&gt;&gt;&gt; context.completionHandler = withCompletionHandler<br>&gt;&gt;&gt; context.errorHandler = { reason in throw RequestError(reason) }<br>&gt;&gt;&gt; self.pending.append(context)<br>&gt;&gt;&gt; context.start()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 10:57 AM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)<br>&gt;&gt;&gt;&gt;&gt;&gt; - Double Block (one for success, one for failure)<br>&gt;&gt;&gt;&gt;&gt;&gt; - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I&#39;ve seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dan!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think guidelines in this area would be great.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are the tradeoffs I think we have for each approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    /*<br>&gt;&gt;&gt;&gt;         Single block.<br>&gt;&gt;&gt;&gt;         Trailing closure syntax works well.<br>&gt;&gt;&gt;&gt;    */<br>&gt;&gt;&gt;&gt;    request.fetch { result, error in<br>&gt;&gt;&gt;&gt;         // More indented code since we need to use guard or if let.<br>&gt;&gt;&gt;&gt;         guard let result = result else {<br>&gt;&gt;&gt;&gt;              // Need to force unwrap `error`.<br>&gt;&gt;&gt;&gt;              handleFetchError(error!) <br>&gt;&gt;&gt;&gt;              return <br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         use(result)<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    /*<br>&gt;&gt;&gt;&gt;         Double block.<br>&gt;&gt;&gt;&gt;         Trailing closure syntax is awkward here.<br>&gt;&gt;&gt;&gt;    */<br>&gt;&gt;&gt;&gt;    request.fetch(withCompletionHandler: { result in<br>&gt;&gt;&gt;&gt;         use(result)          <br>&gt;&gt;&gt;&gt;    }, errorHandler: { error in<br>&gt;&gt;&gt;&gt;         // Don?t need to force unwrap `error`.<br>&gt;&gt;&gt;&gt;         handleFetchError(error) <br>&gt;&gt;&gt;&gt;    })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3) Enums with associated values are conceptually nice, but unless we have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Alex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>API Guidelines for Asynchronous Completion Handlers?</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>There&#39;s a concurrency proposal that discusses various options here:<br>https://github.com/apple/swift/blob/master/docs/proposals/Concurrency.rst<br></p><p>I like the idea of using try-catch for asynchronous error handling, but<br>don&#39;t think that defers needs to annotate throws. With a language-level<br>async/await model we&#39;d get deferred catching for free:<br></p><p>    class Request {<br>        async func fetch() throws -&gt; Response {}<br>    }<br></p><p>    try {<br>        let response = try await request.fetch()<br>    } catch {<br>        // handle error<br>    }<br></p><p>The &quot;try await ?&quot; is a bit wordy, though.<br></p><p>On Fri, Dec 4, 2015 at 2:19 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; I think that the code duplication issue is more of an API design side<br>&gt; effect. If the API was designed with a 3rd block for when it is ?done?<br>&gt; regardless of error, then you could put that shared code there - but I<br>&gt; would imagine that?d be out of the scope of Swift itself. What I often do<br>&gt; in these situations is just make a local function that does the shared<br>&gt; stuff and then call it from both blocks:<br>&gt;<br>&gt; func finished() {<br>&gt;           activityIndicator.stopAnimating()<br>&gt;           button.enabled = true<br>&gt;           tableView.hidden = false<br>&gt; }<br>&gt;<br>&gt; request.fetch(withCompletionHandler: { result in<br>&gt;           finished()<br>&gt;           use(result)<br>&gt;      }, errorHandler: { error in<br>&gt;           finished()<br>&gt;           handleFetchError(error)<br>&gt;      })<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Dec 4, 2015, at 1:13 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hey Alex!<br>&gt; &gt;<br>&gt; &gt; I completely agree that the double-block approach is advantageous for<br>&gt; its reduced unwrapping, but the only issue I have is that, when applied in<br>&gt; production, it typically leads to duplicate code.<br>&gt; &gt;<br>&gt; &gt; request.fetch(withCompletionHandler: { result in<br>&gt; &gt;           activityIndicator.stopAnimating()<br>&gt; &gt;           button.enabled = true<br>&gt; &gt;           tableView.hidden = false<br>&gt; &gt;<br>&gt; &gt;           use(result)<br>&gt; &gt;<br>&gt; &gt;           print( ?Foo!? )<br>&gt; &gt;<br>&gt; &gt;      }, errorHandler: { error in<br>&gt; &gt;           activityIndicator.stopAnimating()<br>&gt; &gt;           button.enabled = true<br>&gt; &gt;           tableView.hidden = false<br>&gt; &gt;<br>&gt; &gt;           // Don?t need to force unwrap `error`.<br>&gt; &gt;           handleFetchError(error)<br>&gt; &gt;<br>&gt; &gt;           print( ?Foo!? )<br>&gt; &gt;<br>&gt; &gt;      })<br>&gt; &gt;<br>&gt; &gt; The same issue is present in the aforementioned deferred throw concept.<br>&gt; There?re certainly ways to mitigate the problem, but no practical way of<br>&gt; eliminating it altogether.  I?m personally leaning towards an evolution of<br>&gt; the Enum-based approach for this very reason, but if a solution can be<br>&gt; figured out to remove such code duplication, I?d happily adopt<br>&gt; double-blocks.<br>&gt; &gt;<br>&gt; &gt; Dan<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini &lt;vinivendra at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I really like the idea of using try/catches, it seems like a more<br>&gt; swifty approach. However, I&#39;d prefer to do it in a way that doesn&#39;t add a<br>&gt; new syntax.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Also, I agree with Alex, the second options seems the best of those<br>&gt; alternatives (if it were done without trailing closures.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 4, 2015, at 12:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What if there was a possibility for a deferred throw?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; For example, imagine the fetch function was something like this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; And to call it, you?d wrap it in a try with a new kind of catch:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; do {<br>&gt; &gt;&gt;&gt; try request.fetch() { result in ? }<br>&gt; &gt;&gt;&gt; } defer catch (? pattern) {<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; So what the language would do then is treat all of the ?defer catch?<br>&gt; blocks as closures and pass them along with calls to ?defer throws?<br>&gt; functions in the same context. When they throw, they would then run those<br>&gt; blocks as if you had passed them along manually in the double block style.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The context to throw back to would need to be capture-able by the<br>&gt; function body for fetch() so that if it encounters an error some time later<br>&gt; it would know where to throw it to. Perhaps the easiest way would be to<br>&gt; create a closure that throws like so:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func fetch(withCompletionHandler: (Result) -&gt; ()) defer throws {<br>&gt; &gt;&gt;&gt; var context = FetchContext()<br>&gt; &gt;&gt;&gt; context.completionHandler = withCompletionHandler<br>&gt; &gt;&gt;&gt; context.errorHandler = { reason in throw RequestError(reason) }<br>&gt; &gt;&gt;&gt; self.pending.append(context)<br>&gt; &gt;&gt;&gt; context.start()<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Under the hood the ?throw? captured in the closure would also be<br>&gt; carrying along the context needed to route that error back to the expected<br>&gt; defer catch block.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; l8r<br>&gt; &gt;&gt;&gt; Sean<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 10:57 AM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 2:15 PM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 12:32 PM, Dan Stenmark &lt;<br>&gt; daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; There?s a some of debate in the community regarding best practice<br>&gt; for asynchronous completion callbacks.  These practices include:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - Single Block w/ Mutually Exclusive Result and Error Objects (the<br>&gt; current standard convention in Cocoa, though originally designed with<br>&gt; Objective-C in mind)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - Double Block (one for success, one for failure)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - Swift Enum w/ Associated Objects (as described here:<br>&gt; http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/<br>&gt; )<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Even prior to Swift, Apple?s code guidelines never explicitly<br>&gt; addressed this topic.  Going forward into the brave new world of Swift, are<br>&gt; there going to be new preferred API design guidelines for this?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; This is a great point, and there are a number of other issues<br>&gt; related to callbacks/closure arguments that would benefit from guidelines.<br>&gt; For example, I&#39;ve seen the ?Double Block? case where the second block ends<br>&gt; up being a trailing closure, which makes for non-intuitive uses.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Hi Dan!<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I think guidelines in this area would be great.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Here are the tradeoffs I think we have for each approach:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 1) The single block approach means you?d code against an optional<br>&gt; result and an optional error, making it easy to write invalid code (see<br>&gt; example in #2). With the single block you can use trailing closure syntax<br>&gt; coherently. I think most ObjC APIs use this approach since it works well in<br>&gt; ObjC.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 2) As Doug mentioned, the double block can be inconvenient / awkward<br>&gt; but it does produce more correct code.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Doug: maybe we can limit using trailing closures from being used if<br>&gt; the 2nd to last parameter is also a closure? That would eliminate some<br>&gt; confusion at the call site.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Some ObjC APIs use this approach. One positive aspect of the<br>&gt; double-block approach is that it always produces code that?s less indented<br>&gt; than the single block approach. e.g.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;    /*<br>&gt; &gt;&gt;&gt;&gt;         Single block.<br>&gt; &gt;&gt;&gt;&gt;         Trailing closure syntax works well.<br>&gt; &gt;&gt;&gt;&gt;    */<br>&gt; &gt;&gt;&gt;&gt;    request.fetch { result, error in<br>&gt; &gt;&gt;&gt;&gt;         // More indented code since we need to use guard or if let.<br>&gt; &gt;&gt;&gt;&gt;         guard let result = result else {<br>&gt; &gt;&gt;&gt;&gt;              // Need to force unwrap `error`.<br>&gt; &gt;&gt;&gt;&gt;              handleFetchError(error!)<br>&gt; &gt;&gt;&gt;&gt;              return<br>&gt; &gt;&gt;&gt;&gt;         }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;         use(result)<br>&gt; &gt;&gt;&gt;&gt;    }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;    /*<br>&gt; &gt;&gt;&gt;&gt;         Double block.<br>&gt; &gt;&gt;&gt;&gt;         Trailing closure syntax is awkward here.<br>&gt; &gt;&gt;&gt;&gt;    */<br>&gt; &gt;&gt;&gt;&gt;    request.fetch(withCompletionHandler: { result in<br>&gt; &gt;&gt;&gt;&gt;         use(result)<br>&gt; &gt;&gt;&gt;&gt;    }, errorHandler: { error in<br>&gt; &gt;&gt;&gt;&gt;         // Don?t need to force unwrap `error`.<br>&gt; &gt;&gt;&gt;&gt;         handleFetchError(error)<br>&gt; &gt;&gt;&gt;&gt;    })<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 3) Enums with associated values are conceptually nice, but unless we<br>&gt; have a Result&lt;&gt; or an Either&lt;&gt; in the Standard Library I think most people<br>&gt; will write one-off enums for each set of methods that return a specific<br>&gt; kind of result + error. That adds an unnecessary conceptual burden since<br>&gt; you need to know the type of of the value that?s passed to each callback.<br>&gt; Also, we don?t have any primarily ObjC APIs that use this approach yet. It<br>&gt; would also suffer from the same indentation problem as #1 but without the<br>&gt; ?invalid code? problem. If we go this route I think we?d want to map the<br>&gt; async error ObjC APIs to use this approach similar to what we do with<br>&gt; non-async error handling.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Looking at the tradeoffs I think I prefer #2 if we could limit the<br>&gt; ability to use a trailing closure for the last parameter. I?d want to look<br>&gt; at more code with the change though. We should also consider whether we<br>&gt; should map the single block APIs in ObjC into double block APIs. What do<br>&gt; you think?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Also, with any of these approaches there?s also the question of<br>&gt; whether we pass ErrorType, NSError, or the specific error type.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; - Alex<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e589cb4e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
