<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>on Sun Jun 05 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sent from my iPhone<br>&gt;<br>&gt;&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal,<br>&gt;&gt;&gt;&gt; taking into account as much of Matthew&#39;s feedback as I could. You<br>&gt;&gt;&gt;&gt; can find it below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime<br>&gt;&gt;&gt;&gt; soon, I expect to make significant revisions to it over the next<br>&gt;&gt;&gt;&gt; month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The actual feature description is spread out through this very long<br>&gt;&gt;&gt; document, with user-facing ideas (e.g., using “anonymous associated<br>&gt;&gt;&gt; types”) intermixed with deeper technical details (existential type<br>&gt;&gt;&gt; equivalence), so it’s very daunting to read. Please bring the<br>&gt;&gt;&gt; user-facing features to the front (“Proposed Solution”) with<br>&gt;&gt;&gt; examples, and save the deeper technical details for “Detailed<br>&gt;&gt;&gt; Design”. You want more readers to make it through the part that<br>&gt;&gt;&gt; affects them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with<br>&gt;&gt;&gt; associated types specified in the requirements, and there are no<br>&gt;&gt;&gt; nested Any&lt;...&gt; requirements with where clauses of their own, that<br>&gt;&gt;&gt; protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Okay<br>&gt;&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In<br>&gt;&gt;&gt; generic signatures, if you have two different protocols with<br>&gt;&gt;&gt; same-named associated types, and a given type parameter (or<br>&gt;&gt;&gt; associated type) conforms to both protocols, the associated types<br>&gt;&gt;&gt; are (implicitly) made equivalent via an inferred same-type<br>&gt;&gt;&gt; constraint. So there’s no reason to introduce the<br>&gt;&gt;&gt; “Collection.Element == Int” syntax, because the “Collection” part<br>&gt;&gt;&gt; is basically irrelevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once existentials have been suitably enhanced, there is a strong<br>&gt;&gt;&gt; analogy between an existential and a generic signature with a<br>&gt;&gt;&gt; single type parameter that you can’t name. An existential<br>&gt;&gt;&gt; Any&lt;Collection where .Element : Equatable&gt; has most of the same<br>&gt;&gt;&gt; characteristics as a generic something with the signature &lt;T :<br>&gt;&gt;&gt; Collection where T.Element : Equatable&gt;. Specifically, the sections<br>&gt;&gt;&gt; on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt;&gt;&gt; anonymous associated types”, “Anonymous associated types to real<br>&gt;&gt;&gt; types”. could be reduced to a few small, simple examples and a<br>&gt;&gt;&gt; mention of the analogous behavior of generics. It will be far<br>&gt;&gt;&gt; easier to explain this way, and readers don’t need to get immersed<br>&gt;&gt;&gt; in the details. Where there are differences vs. generics, that’s<br>&gt;&gt;&gt; important to point out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Associated types and member exposure”: you don’t make the point<br>&gt;&gt;&gt; that it only makes sense to refer to the associated types of a let<br>&gt;&gt;&gt; constant; a var could change its type dynamically, which would<br>&gt;&gt;&gt; invalidate the typing rules. Did you consider just using<br>&gt;&gt;&gt; “x.dynamicType” in the type grammar for this? It’s more general, in<br>&gt;&gt;&gt; that you can refer to associated types but also talk about the<br>&gt;&gt;&gt; dynamic type of “x” itself, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x: Equatable = …<br>&gt;&gt;&gt; 	let y: Equatable = …<br>&gt;&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not a fan of the “anonymous associated types” terminology:<br>&gt;&gt;&gt; these are associated types of a type of some runtime-defined<br>&gt;&gt;&gt; value. The only thing “anonymous” about them is that it’s harder to<br>&gt;&gt;&gt; spell the base type; otherwise, they’re just like associated types<br>&gt;&gt;&gt; of a generic type parameter. Again, the generics analogy is strong<br>&gt;&gt;&gt; here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with<br>&gt;&gt;&gt; what you’ve described here. Also, remember that a method of a<br>&gt;&gt;&gt; protocol extension essentially opens “Self”, so we already have one<br>&gt;&gt;&gt; way to open an existential (and that’s probably enough).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the latter of which is fairly important, because it gives nice<br>&gt;&gt;&gt; syntactic sure to one of the most highly-requested features<br>&gt;&gt;&gt; [*]. I’d suggest having that example very, very early.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt; <br>&gt;&gt; Great feedback here Doug.<br>&gt;&gt; <br>&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;<br>&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt; one would need parameterize a protocols.<br></p><p>That does, however, speak for the idea that a concise and obvious syntax<br>should be supported for that use-case.<br></p><p>Personally, it doesn&#39;t seem ridiculous to me that some associated types<br>might usefully be written as type parameters on a protocol.  As<br>Collection shows, not all associated types are equally important.<br>Approximately nobody wants the existential “Collection where Index ==<br>Int.”<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>I think the generic typealiases Doug mentioned are a pretty good approximation of a type parameter on a protocol. After all, you should be able to do this:<br></p><p>typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br></p><p>Speaking of which, I went ahead and rewrote the proposal based on Doug&#39;s feedback. I look forward to discussing it in depth later this year/early next year. (Suggestions for a better example than the ridiculous pet hotel example at the beginning especially welcome...)<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;<br></p><p>Austin<br></p><p>&gt; On Jun 8, 2016, at 11:57 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;&gt; <br>&gt;&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt;&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt;&gt; one would need parameterize a protocols.<br>&gt; <br>&gt; That does, however, speak for the idea that a concise and obvious syntax<br>&gt; should be supported for that use-case.<br>&gt; <br>&gt; Personally, it doesn&#39;t seem ridiculous to me that some associated types<br>&gt; might usefully be written as type parameters on a protocol.  As<br>&gt; Collection shows, not all associated types are equally important.<br>&gt; Approximately nobody wants the existential “Collection where Index ==<br>&gt; Int.”<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/e4fcb1e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 11:57 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Jun 05 2016, Douglas Gregor &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal,<br>&gt;&gt;&gt;&gt;&gt; taking into account as much of Matthew&#39;s feedback as I could. You<br>&gt;&gt;&gt;&gt;&gt; can find it below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime<br>&gt;&gt;&gt;&gt;&gt; soon, I expect to make significant revisions to it over the next<br>&gt;&gt;&gt;&gt;&gt; month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The actual feature description is spread out through this very long<br>&gt;&gt;&gt;&gt; document, with user-facing ideas (e.g., using “anonymous associated<br>&gt;&gt;&gt;&gt; types”) intermixed with deeper technical details (existential type<br>&gt;&gt;&gt;&gt; equivalence), so it’s very daunting to read. Please bring the<br>&gt;&gt;&gt;&gt; user-facing features to the front (“Proposed Solution”) with<br>&gt;&gt;&gt;&gt; examples, and save the deeper technical details for “Detailed<br>&gt;&gt;&gt;&gt; Design”. You want more readers to make it through the part that<br>&gt;&gt;&gt;&gt; affects them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with<br>&gt;&gt;&gt;&gt; associated types specified in the requirements, and there are no<br>&gt;&gt;&gt;&gt; nested Any&lt;...&gt; requirements with where clauses of their own, that<br>&gt;&gt;&gt;&gt; protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Okay<br>&gt;&gt;&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt;&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt;&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt;&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In<br>&gt;&gt;&gt;&gt; generic signatures, if you have two different protocols with<br>&gt;&gt;&gt;&gt; same-named associated types, and a given type parameter (or<br>&gt;&gt;&gt;&gt; associated type) conforms to both protocols, the associated types<br>&gt;&gt;&gt;&gt; are (implicitly) made equivalent via an inferred same-type<br>&gt;&gt;&gt;&gt; constraint. So there’s no reason to introduce the<br>&gt;&gt;&gt;&gt; “Collection.Element == Int” syntax, because the “Collection” part<br>&gt;&gt;&gt;&gt; is basically irrelevant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Once existentials have been suitably enhanced, there is a strong<br>&gt;&gt;&gt;&gt; analogy between an existential and a generic signature with a<br>&gt;&gt;&gt;&gt; single type parameter that you can’t name. An existential<br>&gt;&gt;&gt;&gt; Any&lt;Collection where .Element : Equatable&gt; has most of the same<br>&gt;&gt;&gt;&gt; characteristics as a generic something with the signature &lt;T :<br>&gt;&gt;&gt;&gt; Collection where T.Element : Equatable&gt;. Specifically, the sections<br>&gt;&gt;&gt;&gt; on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt;&gt;&gt;&gt; anonymous associated types”, “Anonymous associated types to real<br>&gt;&gt;&gt;&gt; types”. could be reduced to a few small, simple examples and a<br>&gt;&gt;&gt;&gt; mention of the analogous behavior of generics. It will be far<br>&gt;&gt;&gt;&gt; easier to explain this way, and readers don’t need to get immersed<br>&gt;&gt;&gt;&gt; in the details. Where there are differences vs. generics, that’s<br>&gt;&gt;&gt;&gt; important to point out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Associated types and member exposure”: you don’t make the point<br>&gt;&gt;&gt;&gt; that it only makes sense to refer to the associated types of a let<br>&gt;&gt;&gt;&gt; constant; a var could change its type dynamically, which would<br>&gt;&gt;&gt;&gt; invalidate the typing rules. Did you consider just using<br>&gt;&gt;&gt;&gt; “x.dynamicType” in the type grammar for this? It’s more general, in<br>&gt;&gt;&gt;&gt; that you can refer to associated types but also talk about the<br>&gt;&gt;&gt;&gt; dynamic type of “x” itself, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let x: Equatable = …<br>&gt;&gt;&gt;&gt; 	let y: Equatable = …<br>&gt;&gt;&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not a fan of the “anonymous associated types” terminology:<br>&gt;&gt;&gt;&gt; these are associated types of a type of some runtime-defined<br>&gt;&gt;&gt;&gt; value. The only thing “anonymous” about them is that it’s harder to<br>&gt;&gt;&gt;&gt; spell the base type; otherwise, they’re just like associated types<br>&gt;&gt;&gt;&gt; of a generic type parameter. Again, the generics analogy is strong<br>&gt;&gt;&gt;&gt; here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with<br>&gt;&gt;&gt;&gt; what you’ve described here. Also, remember that a method of a<br>&gt;&gt;&gt;&gt; protocol extension essentially opens “Self”, so we already have one<br>&gt;&gt;&gt;&gt; way to open an existential (and that’s probably enough).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the latter of which is fairly important, because it gives nice<br>&gt;&gt;&gt;&gt; syntactic sure to one of the most highly-requested features<br>&gt;&gt;&gt;&gt; [*]. I’d suggest having that example very, very early.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great feedback here Doug.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;&gt; <br>&gt;&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt;&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt;&gt; one would need parameterize a protocols.<br>&gt; <br>&gt; That does, however, speak for the idea that a concise and obvious syntax<br>&gt; should be supported for that use-case.<br>&gt; <br>&gt; Personally, it doesn&#39;t seem ridiculous to me that some associated types<br>&gt; might usefully be written as type parameters on a protocol.  As<br>&gt; Collection shows, not all associated types are equally important.<br>&gt; Approximately nobody wants the existential “Collection where Index ==<br>&gt; Int.”<br></p><p><br>I’ve toyed with some form of this idea before, and IIRC it was discussed on this list at one point, where some or all associate types move up to the “type parameter” position in the grammar, e.g.,<br></p><p>protocol Collection&lt;Element&gt; : Sequence&lt;Element&gt; {<br>  associatedtype Index<br>  associatedtype SubSequence<br>}<br></p><p>However, unless that is semantically a type parameter in the sense that one can have a single concrete type conform to Collection&lt;A&gt; and Collection&lt;B&gt; separately, I think it’s misleading to go this route, even if it does give us the clean “Collection&lt;Int&gt;” syntax.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/3844a62d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Jun 09 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 11:57 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Jun 05 2016, Douglas Gregor &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal,<br>&gt;&gt;&gt;&gt;&gt;&gt; taking into account as much of Matthew&#39;s feedback as I could. You<br>&gt;&gt;&gt;&gt;&gt;&gt; can find it below:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime<br>&gt;&gt;&gt;&gt;&gt;&gt; soon, I expect to make significant revisions to it over the next<br>&gt;&gt;&gt;&gt;&gt;&gt; month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The actual feature description is spread out through this very long<br>&gt;&gt;&gt;&gt;&gt; document, with user-facing ideas (e.g., using “anonymous associated<br>&gt;&gt;&gt;&gt;&gt; types”) intermixed with deeper technical details (existential type<br>&gt;&gt;&gt;&gt;&gt; equivalence), so it’s very daunting to read. Please bring the<br>&gt;&gt;&gt;&gt;&gt; user-facing features to the front (“Proposed Solution”) with<br>&gt;&gt;&gt;&gt;&gt; examples, and save the deeper technical details for “Detailed<br>&gt;&gt;&gt;&gt;&gt; Design”. You want more readers to make it through the part that<br>&gt;&gt;&gt;&gt;&gt; affects them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with<br>&gt;&gt;&gt;&gt;&gt; associated types specified in the requirements, and there are no<br>&gt;&gt;&gt;&gt;&gt; nested Any&lt;...&gt; requirements with where clauses of their own, that<br>&gt;&gt;&gt;&gt;&gt; protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Okay<br>&gt;&gt;&gt;&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt;&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt;&gt;&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In<br>&gt;&gt;&gt;&gt;&gt; generic signatures, if you have two different protocols with<br>&gt;&gt;&gt;&gt;&gt; same-named associated types, and a given type parameter (or<br>&gt;&gt;&gt;&gt;&gt; associated type) conforms to both protocols, the associated types<br>&gt;&gt;&gt;&gt;&gt; are (implicitly) made equivalent via an inferred same-type<br>&gt;&gt;&gt;&gt;&gt; constraint. So there’s no reason to introduce the<br>&gt;&gt;&gt;&gt;&gt; “Collection.Element == Int” syntax, because the “Collection” part<br>&gt;&gt;&gt;&gt;&gt; is basically irrelevant.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Once existentials have been suitably enhanced, there is a strong<br>&gt;&gt;&gt;&gt;&gt; analogy between an existential and a generic signature with a<br>&gt;&gt;&gt;&gt;&gt; single type parameter that you can’t name. An existential<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Collection where .Element : Equatable&gt; has most of the same<br>&gt;&gt;&gt;&gt;&gt; characteristics as a generic something with the signature &lt;T :<br>&gt;&gt;&gt;&gt;&gt; Collection where T.Element : Equatable&gt;. Specifically, the sections<br>&gt;&gt;&gt;&gt;&gt; on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt;&gt;&gt;&gt;&gt; anonymous associated types”, “Anonymous associated types to real<br>&gt;&gt;&gt;&gt;&gt; types”. could be reduced to a few small, simple examples and a<br>&gt;&gt;&gt;&gt;&gt; mention of the analogous behavior of generics. It will be far<br>&gt;&gt;&gt;&gt;&gt; easier to explain this way, and readers don’t need to get immersed<br>&gt;&gt;&gt;&gt;&gt; in the details. Where there are differences vs. generics, that’s<br>&gt;&gt;&gt;&gt;&gt; important to point out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Associated types and member exposure”: you don’t make the point<br>&gt;&gt;&gt;&gt;&gt; that it only makes sense to refer to the associated types of a let<br>&gt;&gt;&gt;&gt;&gt; constant; a var could change its type dynamically, which would<br>&gt;&gt;&gt;&gt;&gt; invalidate the typing rules. Did you consider just using<br>&gt;&gt;&gt;&gt;&gt; “x.dynamicType” in the type grammar for this? It’s more general, in<br>&gt;&gt;&gt;&gt;&gt; that you can refer to associated types but also talk about the<br>&gt;&gt;&gt;&gt;&gt; dynamic type of “x” itself, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let x: Equatable = …<br>&gt;&gt;&gt;&gt;&gt; 	let y: Equatable = …<br>&gt;&gt;&gt;&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not a fan of the “anonymous associated types” terminology:<br>&gt;&gt;&gt;&gt;&gt; these are associated types of a type of some runtime-defined<br>&gt;&gt;&gt;&gt;&gt; value. The only thing “anonymous” about them is that it’s harder to<br>&gt;&gt;&gt;&gt;&gt; spell the base type; otherwise, they’re just like associated types<br>&gt;&gt;&gt;&gt;&gt; of a generic type parameter. Again, the generics analogy is strong<br>&gt;&gt;&gt;&gt;&gt; here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with<br>&gt;&gt;&gt;&gt;&gt; what you’ve described here. Also, remember that a method of a<br>&gt;&gt;&gt;&gt;&gt; protocol extension essentially opens “Self”, so we already have one<br>&gt;&gt;&gt;&gt;&gt; way to open an existential (and that’s probably enough).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; the latter of which is fairly important, because it gives nice<br>&gt;&gt;&gt;&gt;&gt; syntactic sure to one of the most highly-requested features<br>&gt;&gt;&gt;&gt;&gt; [*]. I’d suggest having that example very, very early.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great feedback here Doug.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt;&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt;&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt;&gt;&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt;&gt;&gt; one would need parameterize a protocols.<br>&gt;&gt; <br>&gt;&gt; That does, however, speak for the idea that a concise and obvious<br>&gt; syntax<br>&gt;&gt; should be supported for that use-case.<br>&gt;&gt; <br>&gt;&gt; Personally, it doesn&#39;t seem ridiculous to me that some associated<br>&gt; types<br>&gt;&gt; might usefully be written as type parameters on a protocol.  As<br>&gt;&gt; Collection shows, not all associated types are equally important.<br>&gt;&gt; Approximately nobody wants the existential “Collection where Index<br>&gt; ==<br>&gt;&gt; Int.”<br>&gt;<br>&gt; I’ve toyed with some form of this idea before, and IIRC it was<br>&gt; discussed on this list at one point, where some or all associate types<br>&gt; move up to the “type parameter” position in the grammar, e.g.,<br>&gt;<br>&gt; protocol Collection&lt;Element&gt; : Sequence&lt;Element&gt; {<br>&gt;   associatedtype Index<br>&gt;   associatedtype SubSequence<br>&gt; }<br>&gt;<br>&gt; However, unless that is semantically a type parameter in the sense<br>&gt; that one can have a single concrete type conform to Collection&lt;A&gt; and<br>&gt; Collection&lt;B&gt; separately, I think it’s misleading to go this route,<br>&gt; even if it does give us the clean “Collection&lt;Int&gt;” syntax.<br></p><p>Excellent point!  I hadn&#39;t considered it.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 08:00:00pm</p></header><div class="content"><p>decided to play with a different syntax<br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p><br>still have to formalize it, but it does work for many situations, and is consistent with  var  a: P1 &amp; P2<br></p><p><br></p><p>&gt; On Jun 9, 2016, at 6:44 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 11:57 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Jun 05 2016, Douglas Gregor &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; taking into account as much of Matthew&#39;s feedback as I could. You<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can find it below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; soon, I expect to make significant revisions to it over the next<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The actual feature description is spread out through this very long<br>&gt;&gt;&gt;&gt;&gt;&gt; document, with user-facing ideas (e.g., using “anonymous associated<br>&gt;&gt;&gt;&gt;&gt;&gt; types”) intermixed with deeper technical details (existential type<br>&gt;&gt;&gt;&gt;&gt;&gt; equivalence), so it’s very daunting to read. Please bring the<br>&gt;&gt;&gt;&gt;&gt;&gt; user-facing features to the front (“Proposed Solution”) with<br>&gt;&gt;&gt;&gt;&gt;&gt; examples, and save the deeper technical details for “Detailed<br>&gt;&gt;&gt;&gt;&gt;&gt; Design”. You want more readers to make it through the part that<br>&gt;&gt;&gt;&gt;&gt;&gt; affects them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt; associated types specified in the requirements, and there are no<br>&gt;&gt;&gt;&gt;&gt;&gt; nested Any&lt;...&gt; requirements with where clauses of their own, that<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Okay<br>&gt;&gt;&gt;&gt;&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt;&gt;&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In<br>&gt;&gt;&gt;&gt;&gt;&gt; generic signatures, if you have two different protocols with<br>&gt;&gt;&gt;&gt;&gt;&gt; same-named associated types, and a given type parameter (or<br>&gt;&gt;&gt;&gt;&gt;&gt; associated type) conforms to both protocols, the associated types<br>&gt;&gt;&gt;&gt;&gt;&gt; are (implicitly) made equivalent via an inferred same-type<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint. So there’s no reason to introduce the<br>&gt;&gt;&gt;&gt;&gt;&gt; “Collection.Element == Int” syntax, because the “Collection” part<br>&gt;&gt;&gt;&gt;&gt;&gt; is basically irrelevant.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Once existentials have been suitably enhanced, there is a strong<br>&gt;&gt;&gt;&gt;&gt;&gt; analogy between an existential and a generic signature with a<br>&gt;&gt;&gt;&gt;&gt;&gt; single type parameter that you can’t name. An existential<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection where .Element : Equatable&gt; has most of the same<br>&gt;&gt;&gt;&gt;&gt;&gt; characteristics as a generic something with the signature &lt;T :<br>&gt;&gt;&gt;&gt;&gt;&gt; Collection where T.Element : Equatable&gt;. Specifically, the sections<br>&gt;&gt;&gt;&gt;&gt;&gt; on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt;&gt;&gt;&gt;&gt;&gt; anonymous associated types”, “Anonymous associated types to real<br>&gt;&gt;&gt;&gt;&gt;&gt; types”. could be reduced to a few small, simple examples and a<br>&gt;&gt;&gt;&gt;&gt;&gt; mention of the analogous behavior of generics. It will be far<br>&gt;&gt;&gt;&gt;&gt;&gt; easier to explain this way, and readers don’t need to get immersed<br>&gt;&gt;&gt;&gt;&gt;&gt; in the details. Where there are differences vs. generics, that’s<br>&gt;&gt;&gt;&gt;&gt;&gt; important to point out.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Associated types and member exposure”: you don’t make the point<br>&gt;&gt;&gt;&gt;&gt;&gt; that it only makes sense to refer to the associated types of a let<br>&gt;&gt;&gt;&gt;&gt;&gt; constant; a var could change its type dynamically, which would<br>&gt;&gt;&gt;&gt;&gt;&gt; invalidate the typing rules. Did you consider just using<br>&gt;&gt;&gt;&gt;&gt;&gt; “x.dynamicType” in the type grammar for this? It’s more general, in<br>&gt;&gt;&gt;&gt;&gt;&gt; that you can refer to associated types but also talk about the<br>&gt;&gt;&gt;&gt;&gt;&gt; dynamic type of “x” itself, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let x: Equatable = …<br>&gt;&gt;&gt;&gt;&gt;&gt; 	let y: Equatable = …<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the “anonymous associated types” terminology:<br>&gt;&gt;&gt;&gt;&gt;&gt; these are associated types of a type of some runtime-defined<br>&gt;&gt;&gt;&gt;&gt;&gt; value. The only thing “anonymous” about them is that it’s harder to<br>&gt;&gt;&gt;&gt;&gt;&gt; spell the base type; otherwise, they’re just like associated types<br>&gt;&gt;&gt;&gt;&gt;&gt; of a generic type parameter. Again, the generics analogy is strong<br>&gt;&gt;&gt;&gt;&gt;&gt; here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with<br>&gt;&gt;&gt;&gt;&gt;&gt; what you’ve described here. Also, remember that a method of a<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol extension essentially opens “Self”, so we already have one<br>&gt;&gt;&gt;&gt;&gt;&gt; way to open an existential (and that’s probably enough).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; the latter of which is fairly important, because it gives nice<br>&gt;&gt;&gt;&gt;&gt;&gt; syntactic sure to one of the most highly-requested features<br>&gt;&gt;&gt;&gt;&gt;&gt; [*]. I’d suggest having that example very, very early.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Great feedback here Doug.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt;&gt;&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt;&gt;&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt;&gt;&gt;&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt;&gt;&gt;&gt; one would need parameterize a protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That does, however, speak for the idea that a concise and obvious<br>&gt;&gt; syntax<br>&gt;&gt;&gt; should be supported for that use-case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, it doesn&#39;t seem ridiculous to me that some associated<br>&gt;&gt; types<br>&gt;&gt;&gt; might usefully be written as type parameters on a protocol.  As<br>&gt;&gt;&gt; Collection shows, not all associated types are equally important.<br>&gt;&gt;&gt; Approximately nobody wants the existential “Collection where Index<br>&gt;&gt; ==<br>&gt;&gt;&gt; Int.”<br>&gt;&gt; <br>&gt;&gt; I’ve toyed with some form of this idea before, and IIRC it was<br>&gt;&gt; discussed on this list at one point, where some or all associate types<br>&gt;&gt; move up to the “type parameter” position in the grammar, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Collection&lt;Element&gt; : Sequence&lt;Element&gt; {<br>&gt;&gt;  associatedtype Index<br>&gt;&gt;  associatedtype SubSequence<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, unless that is semantically a type parameter in the sense<br>&gt;&gt; that one can have a single concrete type conform to Collection&lt;A&gt; and<br>&gt;&gt; Collection&lt;B&gt; separately, I think it’s misleading to go this route,<br>&gt;&gt; even if it does give us the clean “Collection&lt;Int&gt;” syntax.<br>&gt; <br>&gt; Excellent point!  I hadn&#39;t considered it.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/f9371ed5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Enhanced existential types proposal discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 6:44 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 11:57 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Jun 05 2016, Douglas Gregor &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve put together a considerably more detailed draft proposal,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; taking into account as much of Matthew&#39;s feedback as I could. You<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can find it below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since there is no chance this will come up for review anytime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; soon, I expect to make significant revisions to it over the next<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; month or so. Any feedback would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is very much Swift 4 territory, but I can’t help myself… so…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The actual feature description is spread out through this very long<br>&gt;&gt;&gt;&gt;&gt;&gt; document, with user-facing ideas (e.g., using “anonymous associated<br>&gt;&gt;&gt;&gt;&gt;&gt; types”) intermixed with deeper technical details (existential type<br>&gt;&gt;&gt;&gt;&gt;&gt; equivalence), so it’s very daunting to read. Please bring the<br>&gt;&gt;&gt;&gt;&gt;&gt; user-facing features to the front (“Proposed Solution”) with<br>&gt;&gt;&gt;&gt;&gt;&gt; examples, and save the deeper technical details for “Detailed<br>&gt;&gt;&gt;&gt;&gt;&gt; Design”. You want more readers to make it through the part that<br>&gt;&gt;&gt;&gt;&gt;&gt; affects them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Shortcut &#39;dot&#39; notation: If there is only one protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt; associated types specified in the requirements, and there are no<br>&gt;&gt;&gt;&gt;&gt;&gt; nested Any&lt;...&gt; requirements with where clauses of their own, that<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&#39;s name can be omitted from the whereclause constraints:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Okay<br>&gt;&gt;&gt;&gt;&gt;&gt; // Would otherwise be Any&lt; ~ where Collection.Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;class, Collection, Any&lt;Streamable, CustomStringConvertible&gt; where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // NOT ALLOWED<br>&gt;&gt;&gt;&gt;&gt;&gt; // Both Collection and OptionSetType have associated types.<br>&gt;&gt;&gt;&gt;&gt;&gt; let b : Any&lt;Collection, OptionSetType where .Element == Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I think “.Element == Int” should be the only syntax. In<br>&gt;&gt;&gt;&gt;&gt;&gt; generic signatures, if you have two different protocols with<br>&gt;&gt;&gt;&gt;&gt;&gt; same-named associated types, and a given type parameter (or<br>&gt;&gt;&gt;&gt;&gt;&gt; associated type) conforms to both protocols, the associated types<br>&gt;&gt;&gt;&gt;&gt;&gt; are (implicitly) made equivalent via an inferred same-type<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint. So there’s no reason to introduce the<br>&gt;&gt;&gt;&gt;&gt;&gt; “Collection.Element == Int” syntax, because the “Collection” part<br>&gt;&gt;&gt;&gt;&gt;&gt; is basically irrelevant.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Once existentials have been suitably enhanced, there is a strong<br>&gt;&gt;&gt;&gt;&gt;&gt; analogy between an existential and a generic signature with a<br>&gt;&gt;&gt;&gt;&gt;&gt; single type parameter that you can’t name. An existential<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection where .Element : Equatable&gt; has most of the same<br>&gt;&gt;&gt;&gt;&gt;&gt; characteristics as a generic something with the signature &lt;T :<br>&gt;&gt;&gt;&gt;&gt;&gt; Collection where T.Element : Equatable&gt;. Specifically, the sections<br>&gt;&gt;&gt;&gt;&gt;&gt; on “Existential type equivalence”, “Ordering”, “Real types to<br>&gt;&gt;&gt;&gt;&gt;&gt; anonymous associated types”, “Anonymous associated types to real<br>&gt;&gt;&gt;&gt;&gt;&gt; types”. could be reduced to a few small, simple examples and a<br>&gt;&gt;&gt;&gt;&gt;&gt; mention of the analogous behavior of generics. It will be far<br>&gt;&gt;&gt;&gt;&gt;&gt; easier to explain this way, and readers don’t need to get immersed<br>&gt;&gt;&gt;&gt;&gt;&gt; in the details. Where there are differences vs. generics, that’s<br>&gt;&gt;&gt;&gt;&gt;&gt; important to point out.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Associated typealias rewriting”: this also falls out of the equivalence with generics + SE-0092.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Associated types and member exposure”: you don’t make the point<br>&gt;&gt;&gt;&gt;&gt;&gt; that it only makes sense to refer to the associated types of a let<br>&gt;&gt;&gt;&gt;&gt;&gt; constant; a var could change its type dynamically, which would<br>&gt;&gt;&gt;&gt;&gt;&gt; invalidate the typing rules. Did you consider just using<br>&gt;&gt;&gt;&gt;&gt;&gt; “x.dynamicType” in the type grammar for this? It’s more general, in<br>&gt;&gt;&gt;&gt;&gt;&gt; that you can refer to associated types but also talk about the<br>&gt;&gt;&gt;&gt;&gt;&gt; dynamic type of “x” itself, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let x: Equatable = …<br>&gt;&gt;&gt;&gt;&gt;&gt; 	let y: Equatable = …<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let yAsX = y as? x.dynamicType { … x == yAsX … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; which is (almost?) as powerful as a general “open” expression.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not a fan of the “anonymous associated types” terminology:<br>&gt;&gt;&gt;&gt;&gt;&gt; these are associated types of a type of some runtime-defined<br>&gt;&gt;&gt;&gt;&gt;&gt; value. The only thing “anonymous” about them is that it’s harder to<br>&gt;&gt;&gt;&gt;&gt;&gt; spell the base type; otherwise, they’re just like associated types<br>&gt;&gt;&gt;&gt;&gt;&gt; of a generic type parameter. Again, the generics analogy is strong<br>&gt;&gt;&gt;&gt;&gt;&gt; here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I don’t think we’ll ever need “opening existentials” with<br>&gt;&gt;&gt;&gt;&gt;&gt; what you’ve described here. Also, remember that a method of a<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol extension essentially opens “Self”, so we already have one<br>&gt;&gt;&gt;&gt;&gt;&gt; way to open an existential (and that’s probably enough).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was a little surprised you didn’t point out that AnyObject could become<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	typealias AnyObject = Any&lt;class&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or give the nice “AnyCollection” syntax:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; the latter of which is fairly important, because it gives nice<br>&gt;&gt;&gt;&gt;&gt;&gt; syntactic sure to one of the most highly-requested features<br>&gt;&gt;&gt;&gt;&gt;&gt; [*]. I’d suggest having that example very, very early.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [*] That generally comes in as “Swift should have parameterized protocols…”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Great feedback here Doug.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, we also occasionally get &quot;Swift should have parameterized<br>&gt;&gt;&gt;&gt;&gt; protocols&quot; in the context of multiple conformances by the same<br>&gt;&gt;&gt;&gt;&gt; concrete type (as in things like ConvertibleTo&lt;T&gt; protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know. From the bugs I&#39;ve seen it&#39;s at least 10x as many requests for<br>&gt;&gt;&gt;&gt; &quot;any collection of some element type&quot; as for any actually reason why<br>&gt;&gt;&gt;&gt; one would need parameterize a protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That does, however, speak for the idea that a concise and obvious<br>&gt;&gt; syntax<br>&gt;&gt;&gt; should be supported for that use-case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, it doesn&#39;t seem ridiculous to me that some associated<br>&gt;&gt; types<br>&gt;&gt;&gt; might usefully be written as type parameters on a protocol.  As<br>&gt;&gt;&gt; Collection shows, not all associated types are equally important.<br>&gt;&gt;&gt; Approximately nobody wants the existential “Collection where Index<br>&gt;&gt; ==<br>&gt;&gt;&gt; Int.”<br>&gt;&gt; <br>&gt;&gt; I’ve toyed with some form of this idea before, and IIRC it was<br>&gt;&gt; discussed on this list at one point, where some or all associate types<br>&gt;&gt; move up to the “type parameter” position in the grammar, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Collection&lt;Element&gt; : Sequence&lt;Element&gt; {<br>&gt;&gt;  associatedtype Index<br>&gt;&gt;  associatedtype SubSequence<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, unless that is semantically a type parameter in the sense<br>&gt;&gt; that one can have a single concrete type conform to Collection&lt;A&gt; and<br>&gt;&gt; Collection&lt;B&gt; separately, I think it’s misleading to go this route,<br>&gt;&gt; even if it does give us the clean “Collection&lt;Int&gt;” syntax.<br>&gt; <br>&gt; Excellent point!  I hadn&#39;t considered it.<br></p><p>this is an attempt as getting near the:  Collection&lt;Int&gt;<br></p><p>I included a tentative grammar but I am still trying to chk the details<br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p><br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/dd2ba27d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
