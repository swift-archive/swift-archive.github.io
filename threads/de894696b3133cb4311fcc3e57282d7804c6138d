<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 15, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Feb 15 2016, Zach Waldowski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; See responses inline.<br>&gt;<br>&gt; Aside: omgomgomg I got Dave Abrahams to respond to a proposal of mine<br></p><p>Don&#39;t worry; it&#39;ll wear off soon enough...<br></p><p>&gt; Excitedly,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt;<br>&gt; On Mon, Feb 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution<br>&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Thu Feb 11 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins<br>&gt;&gt; &gt; now and runs through February 16, 2016. The proposal is available<br>&gt;&gt; &gt; here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; &gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt; &gt; the top of the message:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposal link:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; &gt; Reply text<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Other replies<br>&gt;&gt; &gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; &gt; through constructive criticism and, eventually, determine the<br>&gt;&gt; &gt; direction of Swift. When writing your review, here are some questions<br>&gt;&gt; &gt; you might want to answer in your review:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I support the intent of the proposal but am -1 on the specific proposal<br>&gt;&gt; as offered.<br>&gt;&gt; <br>&gt;&gt; First, in the presentation, there are several things that make it hard<br>&gt;&gt; to evaluate:<br>&gt;&gt; <br>&gt;&gt; 1. The &quot;decode&quot; function signature is so wide that it can&#39;t be read<br>&gt;&gt;    without scrolling at<br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; <br>&gt;&gt; 2. The proposal doesn&#39;t show any usage of the proposed APIs, so it<br>&gt;&gt;    is hard to understand what effect these APIs would have on real<br>&gt;&gt;    code.  There are some examples of uses in<br>&gt;&gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt;&gt;    but I have to dig for them.<br>&gt;&gt; <br>&gt;&gt; 3. The description of the “Detailed Design” doesn&#39;t show any examples<br>&gt;&gt;    either, so I have to imagine what “backporting the Swift 3.0 versions<br>&gt;&gt;    of the CString constructors, then making them generic over their<br>&gt;&gt;    input and codec” means.<br>&gt;<br>&gt; The notes are appreciated. I&#39;ll take care to add examples and fix<br>&gt; formatting. The proposal was always intended to be paired with the PR to<br>&gt; the stdlib, and that lack of clarity did not come up during the proposal<br>&gt; vetting stage.<br>&gt;<br>&gt;&gt; Next, when I look at *uses* that I can find (in the tests), I don&#39;t find<br>&gt;&gt; them to be clear.<br>&gt;&gt; <br>&gt;&gt;   String(validatingCodeUnits: result, as: UTF8.self)<br>&gt;&gt; <br>&gt;&gt; What does “validatingCodeUnits” mean?  Clearly we&#39;re going to do some<br>&gt;&gt; checking.  Is there a repair?  Is the initializer failable?  <br>&gt;<br>&gt; I&#39;m open to suggestions. The names as they are were lifted from the<br>&gt; changes to the CString APIs made on swift-3-api-guidelines.<br></p><p>I suspected that they might be so I went and checked on GitHub... but<br>now I see that only searches the default branch :-P<br></p><p>    https://help.github.com/articles/searching-code/<br></p><p>But if the naming error was on our side, my apologies.  We should do<br>better, regardless.<br></p><p>&gt; &quot;repairingCodeUnits&quot; implies to me that there is something already wrong<br>&gt; with them. <br></p><p>That doesn&#39;t bother me.  If you are requesting the repair, you are<br>effectively assuming that there is something already wrong with them.<br></p><p>&gt; I&#39;m also not sure as to the point of the initializer being failable;<br>&gt; many domain initializers in the stdlib don&#39;t indicate that they can<br>&gt; fail directly in the name.<br></p><p>The point I&#39;m trying to make is that the implications of “validating”<br>aren&#39;t clear, not that I can&#39;t tell whether it&#39;s failable.<br></p><p>&gt;&gt; <br>&gt;&gt; In this change, for example:<br>&gt;&gt; https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units#diff-d39ec2c4819c950aeef95f899f53b104R79<br>&gt;&gt; I find the old code much clearer than the new code (I&#39;m not sure why<br>&gt;&gt; _decode starts with an underscore here; isn&#39;t it part of your proposed<br>&gt;&gt; public API?)<br>&gt;<br>&gt; The PR is ahead of the proposal here. It was pointed out in the review<br>&gt; thread up to this point that that that &quot;primitive&quot; isn&#39;t truly needed;<br>&gt; the initializers on String should be the API used by all.<br></p><p>Okay, well, proposals (including any diffs they reference) should remain<br>stable under review so we know what we&#39;re reviewing.  I really don&#39;t<br>know what&#39;s being proposed here.<br></p><p>&gt; static func decode&lt;<br>&gt;   Encoding: UnicodeCodecType, <br>&gt;   Input: CollectionType where Input.Generator.Element == Encoding.CodeUnit<br>&gt; &gt;(<br>&gt;    _: Input, as: Encoding.Type, repairingInvalidCodeUnits: Bool = default<br>&gt; ) -&gt; (result: String, repairsMade: Bool)?<br></p><p>It seems like you are withdrawing decode from the proposal?<br></p><p>&gt; For convenience, the Bool flag here is also separated out to a more<br>&gt; common-case pair of String initializers:<br></p><p>I don&#39;t understand what it means for a “bool flag to be separated out to<br>a... pair of ... initializers.”<br></p><p>&gt; init&lt;...&gt;(codeUnits: Input, as: Encoding.Type)<br>&gt; init?&lt;...&gt;(validatingCodeUnits: Input, as: Encoding.Type)<br></p><p>Are you saying that the first initializer corresponds to<br>`repairingInvalidCodeUnits: true` and the second to<br>`repairingInvalidCodeUnits: false`?<br></p><p>What about the user who wants repairs if necessary and wants to know<br>about it when repairs were made?<br></p><p>&gt; Finally, for more direct compatibility with String.Type.fromCString(_:)<br>&gt; and String.Type.fromCStringRepairingIllFormedUTF8(_:), these<br>&gt; constructors are overloaded for pointer-based strings of unknown length:<br>&gt; <br>&gt; init(cString: UnsafePointer&lt;CChar&gt;)<br>&gt; init?(validatingCString: UnsafePointer&lt;CChar&gt;)<br></p><p>Why are we trying to “be compatible” with those static methods?  <br></p><p>&gt; The ugliness in this instance is transitional; <br></p><p>What ugliness?<br></p><p>&gt; it stems from bridging the old-style constructor to the new-style<br>&gt; one. <br></p><p>I don&#39;t know what that means either.<br></p><p>&gt; The old signature&#39;s return type is awkward in that it returns the<br>&gt; extra hadError flag regardless of whether decoding failed, which is<br>&gt; discarded almost universally by clients in the stdlib.<br>&gt;<br>&gt; I intend to revert the change to `fromCStringRepairingIllFormedUTF8`, or<br>&gt; elide `_decode` into it instead.<br></p><p>I don&#39;t know what that means either.<br></p><p>&gt;&gt; Lastly, I am very concerned about the “Alternatives Considered” section,<br>&gt;&gt; where, of one alternative, it says:<br>&gt;&gt; <br>&gt;&gt;       This might be the better long-term solution from the perspective<br>&gt;&gt;       of API maintenance, but in the meantime this proposal has a fairly<br>&gt;&gt;       low impact.<br>&gt;&gt; <br>&gt;&gt; We can&#39;t accept changes into the standard library “in the meantime,”<br>&gt;&gt; with the expectation that something more comprehensive will make them<br>&gt;&gt; obsolete.  Even though we&#39;ve had migration tools, we never operated that<br>&gt;&gt; way in the past, and as we head toward API and ABI stability it is even<br>&gt;&gt; more true today.<br>&gt;<br>&gt; I understand the sentiment here, but I don&#39;t think &quot;wait for the next<br>&gt; rewrite of String&quot; is a good solution to a problem that the stdlib<br>&gt; already resolves. <br></p><p>I&#39;m really confused.  If the stdlib already resolves the problem, why is<br>there a proposal?<br></p><p>&gt; See below.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; &gt; Is the problem being addressed significant enough to warrant a change<br>&gt;&gt; &gt; to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt; &gt; Does this proposal fit well with the feel and direction of Swift?  <br>&gt;&gt; <br>&gt;&gt; W.r.t. direction, the fact that we have a major String overhaul planned<br>&gt;&gt; means that tackling this one corner of the API is probably not entirely<br>&gt;&gt; appropriate.<br>&gt;<br>&gt; &quot;Corner&quot; is an unfair characterization; <br></p><p>Not at all; this addresses an important use-case, but accounts for a<br>very small part of the API.<br></p><p>&gt; users of Swift want to implement things to the level of safety and<br>&gt; performance bar set by the stdlib, but we are currently at a<br>&gt; disadvantage. No better example can be found but in<br>&gt; corelibs-foundation:<br>&gt; https://github.com/apple/swift-corelibs-foundation/blob/546dc8e16c3c34ca50f5752c6d0f39c3524f5f0a/Foundation/NSString.swift#L305.<br></p><p>Heh, well, that&#39;s ironic.  Before Swift was released we had all of this<br>functionality for unicode transcoding available in the String API, and<br>it was decided that to avoid treading into Foundation&#39;s territory, any<br>functionality already exposed by NSString should not be public API on<br>String without Foundation loaded.<br></p><p>I have ambitions that Swift strings will be first-class standalone types<br>without the need to rely on Foundation some day soon, but under the<br>circumstances we may need a more comprehensive change than merely adding<br>fast unicode transcoding to justify treading into this area.<br></p><p>&gt; Is it not a deficiency of the stdlib when code has to resort to<br>&gt; non-public methods? <br></p><p>Yes.  There are lots of deficiencies in the stdlib.  I&#39;m not saying this<br>shouldn&#39;t be addressed, but I&#39;m concerned about addressing this in a<br>temporary way that we think may be sub-optimal.<br></p><p>&gt; The stdlib (i.e., the parts touched by the PR) and corelibs-foundation<br>&gt; would have to move in lockstep to adopt a replacement, so the existing<br>&gt; underscored versions are as good as public API.<br>&gt;<br>&gt; I understand, and 100% encourage, the reticence around new API. However,<br>&gt; we&#39;ve created a worse problem by encouraging slow, buggy, custom<br>&gt; versions of behavior that already exists in the stdlib, or implying that<br>&gt; the underscored API should be used because we haven&#39;t managed something<br>&gt; better yet. :/<br></p><p>I am not reticent to have new API.  I am reticent to accept partial or<br>known-suboptimal temporary solutions when we are developing a<br>comprehensive plan that ought to address the same problems (among many<br>others).<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>February 15, 2016 at 07:00:00pm</p></header><div class="content"><p>Responses are inline.<br></p><p>Best,<br>Zachary Waldowski<br>zach at waldowski.me<br></p><p>On Mon, Feb 15, 2016, at 02:10 PM, Dave Abrahams via swift-evolution<br>wrote:<br>&gt; <br>&gt; on Mon Feb 15 2016, Zach Waldowski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; See responses inline.<br>&gt; &gt;<br>&gt; &gt; Aside: omgomgomg I got Dave Abrahams to respond to a proposal of mine<br>&gt; <br>&gt; Don&#39;t worry; it&#39;ll wear off soon enough...<br>&gt; <br>&gt; &gt; Excitedly,<br>&gt; &gt;   Zachary Waldowski<br>&gt; &gt;   zach at waldowski.me<br>&gt; &gt;<br>&gt; &gt; On Mon, Feb 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution<br>&gt; &gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; on Thu Feb 11 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; &gt; Hello Swift community,<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins<br>&gt; &gt;&gt; &gt; now and runs through February 16, 2016. The proposal is available<br>&gt; &gt;&gt; &gt; here:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt; &gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; &gt;&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; &gt;&gt; &gt; review manager. When replying, please try to keep the proposal link at<br>&gt; &gt;&gt; &gt; the top of the message:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Proposal link:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt; &gt;&gt; &gt; Reply text<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Other replies<br>&gt; &gt;&gt; &gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; &gt;&gt; &gt; through constructive criticism and, eventually, determine the<br>&gt; &gt;&gt; &gt; direction of Swift. When writing your review, here are some questions<br>&gt; &gt;&gt; &gt; you might want to answer in your review:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; What is your evaluation of the proposal?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I support the intent of the proposal but am -1 on the specific proposal<br>&gt; &gt;&gt; as offered.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; First, in the presentation, there are several things that make it hard<br>&gt; &gt;&gt; to evaluate:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 1. The &quot;decode&quot; function signature is so wide that it can&#39;t be read<br>&gt; &gt;&gt;    without scrolling at<br>&gt; &gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 2. The proposal doesn&#39;t show any usage of the proposed APIs, so it<br>&gt; &gt;&gt;    is hard to understand what effect these APIs would have on real<br>&gt; &gt;&gt;    code.  There are some examples of uses in<br>&gt; &gt;&gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; &gt;&gt;    but I have to dig for them.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 3. The description of the “Detailed Design” doesn&#39;t show any examples<br>&gt; &gt;&gt;    either, so I have to imagine what “backporting the Swift 3.0 versions<br>&gt; &gt;&gt;    of the CString constructors, then making them generic over their<br>&gt; &gt;&gt;    input and codec” means.<br>&gt; &gt;<br>&gt; &gt; The notes are appreciated. I&#39;ll take care to add examples and fix<br>&gt; &gt; formatting. The proposal was always intended to be paired with the PR to<br>&gt; &gt; the stdlib, and that lack of clarity did not come up during the proposal<br>&gt; &gt; vetting stage.<br>&gt; &gt;<br>&gt; &gt;&gt; Next, when I look at *uses* that I can find (in the tests), I don&#39;t find<br>&gt; &gt;&gt; them to be clear.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   String(validatingCodeUnits: result, as: UTF8.self)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; What does “validatingCodeUnits” mean?  Clearly we&#39;re going to do some<br>&gt; &gt;&gt; checking.  Is there a repair?  Is the initializer failable?  <br>&gt; &gt;<br>&gt; &gt; I&#39;m open to suggestions. The names as they are were lifted from the<br>&gt; &gt; changes to the CString APIs made on swift-3-api-guidelines.<br>&gt; <br>&gt; I suspected that they might be so I went and checked on GitHub... but<br>&gt; now I see that only searches the default branch :-P<br>&gt; <br>&gt;     https://help.github.com/articles/searching-code/<br>&gt; <br>&gt; But if the naming error was on our side, my apologies.  We should do<br>&gt; better, regardless.<br>&gt; <br>&gt; &gt; &quot;repairingCodeUnits&quot; implies to me that there is something already wrong<br>&gt; &gt; with them. <br>&gt; <br>&gt; That doesn&#39;t bother me.  If you are requesting the repair, you are<br>&gt; effectively assuming that there is something already wrong with them.<br>&gt; <br>&gt; &gt; I&#39;m also not sure as to the point of the initializer being failable;<br>&gt; &gt; many domain initializers in the stdlib don&#39;t indicate that they can<br>&gt; &gt; fail directly in the name.<br>&gt; <br>&gt; The point I&#39;m trying to make is that the implications of “validating”<br>&gt; aren&#39;t clear, not that I can&#39;t tell whether it&#39;s failable.<br></p><p>Okay, point taken. Is your recommendation behind &quot;repairingCodeUnits&quot;?<br>Or something else?<br></p><p>&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; In this change, for example:<br>&gt; &gt;&gt; https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units#diff-d39ec2c4819c950aeef95f899f53b104R79<br>&gt; &gt;&gt; I find the old code much clearer than the new code (I&#39;m not sure why<br>&gt; &gt;&gt; _decode starts with an underscore here; isn&#39;t it part of your proposed<br>&gt; &gt;&gt; public API?)<br>&gt; &gt;<br>&gt; &gt; The PR is ahead of the proposal here. It was pointed out in the review<br>&gt; &gt; thread up to this point that that that &quot;primitive&quot; isn&#39;t truly needed;<br>&gt; &gt; the initializers on String should be the API used by all.<br>&gt; <br>&gt; Okay, well, proposals (including any diffs they reference) should remain<br>&gt; stable under review so we know what we&#39;re reviewing.  I really don&#39;t<br>&gt; know what&#39;s being proposed here.<br></p><p>Noted. I was following the example set by many other reviews, and I<br>apologize for not knowing what the right was here.<br></p><p>I intend to continue to push changes to the PR (or make a new branch,<br>more likely), but will strive to make the proposal not dependent on the<br>branch anyway. <br></p><p>&gt; <br>&gt; &gt; static func decode&lt;<br>&gt; &gt;   Encoding: UnicodeCodecType, <br>&gt; &gt;   Input: CollectionType where Input.Generator.Element == Encoding.CodeUnit<br>&gt; &gt; &gt;(<br>&gt; &gt;    _: Input, as: Encoding.Type, repairingInvalidCodeUnits: Bool = default<br>&gt; &gt; ) -&gt; (result: String, repairsMade: Bool)?<br>&gt; <br>&gt; It seems like you are withdrawing decode from the proposal?<br>&gt; <br>&gt; &gt; For convenience, the Bool flag here is also separated out to a more<br>&gt; &gt; common-case pair of String initializers:<br>&gt; <br>&gt; I don&#39;t understand what it means for a “bool flag to be separated out to<br>&gt; a... pair of ... initializers.”<br>&gt; <br>&gt; &gt; init&lt;...&gt;(codeUnits: Input, as: Encoding.Type)<br>&gt; &gt; init?&lt;...&gt;(validatingCodeUnits: Input, as: Encoding.Type)<br>&gt; <br>&gt; Are you saying that the first initializer corresponds to<br>&gt; `repairingInvalidCodeUnits: true` and the second to<br>&gt; `repairingInvalidCodeUnits: false`?<br></p><p>Yes.<br></p><p>&gt; <br>&gt; What about the user who wants repairs if necessary and wants to know<br>&gt; about it when repairs were made?<br></p><p>That&#39;s valid enough reason to keep the full version of decode around,<br>though I will again note that the flag is typically ignored. I&#39;ve yet to<br>find someone actually using it.<br></p><p>&gt; <br>&gt; &gt; Finally, for more direct compatibility with String.Type.fromCString(_:)<br>&gt; &gt; and String.Type.fromCStringRepairingIllFormedUTF8(_:), these<br>&gt; &gt; constructors are overloaded for pointer-based strings of unknown length:<br>&gt; &gt; <br>&gt; &gt; init(cString: UnsafePointer&lt;CChar&gt;)<br>&gt; &gt; init?(validatingCString: UnsafePointer&lt;CChar&gt;)<br>&gt; <br>&gt; Why are we trying to “be compatible” with those static methods?  <br></p><p>They are existing public API and they are being deprecated and replaced<br>by this proposal. It was noted during the proposal shopping period that<br>requiring strlen and creating an UnsafeBufferPointer would be, in as<br>many words, too much migration effort.<br></p><p>&gt; <br>&gt; &gt; The ugliness in this instance is transitional; <br>&gt; <br>&gt; What ugliness?<br></p><p>&quot;I find the old code much clearer than the new code&quot;, being the<br>forwarding implementation of<br>String.Type.fromCStringRepairingIllFormedUTF8(_:).<br></p><p>&gt; <br>&gt; &gt; it stems from bridging the old-style constructor to the new-style<br>&gt; &gt; one. <br>&gt; <br>&gt; I don&#39;t know what that means either.<br></p><p>String.Type.fromCString(_:) and<br>String.Type.fromCStringRepairingIllFormedUTF8(_:) are replaced by<br>String(validatingCString:) and String(cString:), respectively, as<br>described under &quot;Impact on existing code&quot;.<br></p><p>&gt; <br>&gt; &gt; The old signature&#39;s return type is awkward in that it returns the<br>&gt; &gt; extra hadError flag regardless of whether decoding failed, which is<br>&gt; &gt; discarded almost universally by clients in the stdlib.<br>&gt; &gt;<br>&gt; &gt; I intend to revert the change to `fromCStringRepairingIllFormedUTF8`, or<br>&gt; &gt; elide `_decode` into it instead.<br>&gt; <br>&gt; I don&#39;t know what that means either.<br></p><p>You found the changes fromCStringRepairingIllFormedUTF8 unclear, I<br>intend to return it to the previous version.<br></p><p>&gt; <br>&gt; &gt;&gt; Lastly, I am very concerned about the “Alternatives Considered” section,<br>&gt; &gt;&gt; where, of one alternative, it says:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;       This might be the better long-term solution from the perspective<br>&gt; &gt;&gt;       of API maintenance, but in the meantime this proposal has a fairly<br>&gt; &gt;&gt;       low impact.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; We can&#39;t accept changes into the standard library “in the meantime,”<br>&gt; &gt;&gt; with the expectation that something more comprehensive will make them<br>&gt; &gt;&gt; obsolete.  Even though we&#39;ve had migration tools, we never operated that<br>&gt; &gt;&gt; way in the past, and as we head toward API and ABI stability it is even<br>&gt; &gt;&gt; more true today.<br>&gt; &gt;<br>&gt; &gt; I understand the sentiment here, but I don&#39;t think &quot;wait for the next<br>&gt; &gt; rewrite of String&quot; is a good solution to a problem that the stdlib<br>&gt; &gt; already resolves. <br>&gt; <br>&gt; I&#39;m really confused.  If the stdlib already resolves the problem, why is<br>&gt; there a proposal?<br></p><p>It has implementations in underscored form, which I can&#39;t use.<br></p><p>&gt; <br>&gt; &gt; See below.<br>&gt; &gt;<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; &gt; Is the problem being addressed significant enough to warrant a change<br>&gt; &gt;&gt; &gt; to Swift?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Yes.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; &gt; Does this proposal fit well with the feel and direction of Swift?  <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; W.r.t. direction, the fact that we have a major String overhaul planned<br>&gt; &gt;&gt; means that tackling this one corner of the API is probably not entirely<br>&gt; &gt;&gt; appropriate.<br>&gt; &gt;<br>&gt; &gt; &quot;Corner&quot; is an unfair characterization; <br>&gt; <br>&gt; Not at all; this addresses an important use-case, but accounts for a<br>&gt; very small part of the API.<br>&gt; <br>&gt; &gt; users of Swift want to implement things to the level of safety and<br>&gt; &gt; performance bar set by the stdlib, but we are currently at a<br>&gt; &gt; disadvantage. No better example can be found but in<br>&gt; &gt; corelibs-foundation:<br>&gt; &gt; https://github.com/apple/swift-corelibs-foundation/blob/546dc8e16c3c34ca50f5752c6d0f39c3524f5f0a/Foundation/NSString.swift#L305.<br>&gt; <br>&gt; Heh, well, that&#39;s ironic.  Before Swift was released we had all of this<br>&gt; functionality for unicode transcoding available in the String API, and<br>&gt; it was decided that to avoid treading into Foundation&#39;s territory, any<br>&gt; functionality already exposed by NSString should not be public API on<br>&gt; String without Foundation loaded.<br>&gt; <br></p><p>That&#39;s unfortunate.<br></p><p>&gt; I have ambitions that Swift strings will be first-class standalone types<br>&gt; without the need to rely on Foundation some day soon, but under the<br>&gt; circumstances we may need a more comprehensive change than merely adding<br>&gt; fast unicode transcoding to justify treading into this area.<br>&gt; <br>&gt; &gt; Is it not a deficiency of the stdlib when code has to resort to<br>&gt; &gt; non-public methods? <br>&gt; <br>&gt; Yes.  There are lots of deficiencies in the stdlib.  I&#39;m not saying this<br>&gt; shouldn&#39;t be addressed, but I&#39;m concerned about addressing this in a<br>&gt; temporary way that we think may be sub-optimal.<br>&gt; <br>&gt; &gt; The stdlib (i.e., the parts touched by the PR) and corelibs-foundation<br>&gt; &gt; would have to move in lockstep to adopt a replacement, so the existing<br>&gt; &gt; underscored versions are as good as public API.<br>&gt; &gt;<br>&gt; &gt; I understand, and 100% encourage, the reticence around new API. However,<br>&gt; &gt; we&#39;ve created a worse problem by encouraging slow, buggy, custom<br>&gt; &gt; versions of behavior that already exists in the stdlib, or implying that<br>&gt; &gt; the underscored API should be used because we haven&#39;t managed something<br>&gt; &gt; better yet. :/<br>&gt; <br>&gt; I am not reticent to have new API.  I am reticent to accept partial or<br>&gt; known-suboptimal temporary solutions when we are developing a<br>&gt; comprehensive plan that ought to address the same problems (among many<br>&gt; others).<br></p><p>Not it&#39;s my turn to be confused. I don&#39;t think of this proposal as a<br>temporary solution, and would like more color on that if you would. Even<br>if a &quot;more complete&quot; variant found its way to the String views, the<br>number of clients in the stdlib and Foundation make it clear that this<br>group of constructors are necessary. Unless the entire UnicodeCodec<br>concept is going away, I don&#39;t see this proposal causing a drastic<br>migration problem; if they are, then the proposed constructors would be<br>just a small component of another heroic migration anyway.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Dave, a few questions below:<br></p><p>&gt; On Feb 15, 2016, at 11:10 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>…<br></p><p>&gt; Heh, well, that&#39;s ironic.  Before Swift was released we had all of this<br>&gt; functionality for unicode transcoding available in the String API, and<br>&gt; it was decided that to avoid treading into Foundation&#39;s territory, any<br>&gt; functionality already exposed by NSString should not be public API on<br>&gt; String without Foundation loaded.<br></p><p>Could you explain what went into the decisions about what overlapping functionality was allowed and what was not? There seems to be significant overlapping functionality: fromCString, uppercaseString, and hasPrefix just to name a few redundant methods.<br></p><p>Also, the new functions in the proposal operate on parameters that are Swift types with no equivalent in Obj-C. Is that really treading into Foundation territory?<br></p><p>&gt; I have ambitions that Swift strings will be first-class standalone types<br>&gt; without the need to rely on Foundation some day soon, but under the<br>&gt; circumstances we may need a more comprehensive change than merely adding<br>&gt; fast unicode transcoding to justify treading into this area.<br></p><p>Are all of the Swift stdlib types that bridge to Foundation types (Array, Dictionary, etc.) under similar restrictions about treading on Foundation? I’m surprised by that approach.<br></p><p>&gt; <br>&gt;&gt; Is it not a deficiency of the stdlib when code has to resort to<br>&gt;&gt; non-public methods? <br>&gt; <br>&gt; Yes.  There are lots of deficiencies in the stdlib.  I&#39;m not saying this<br>&gt; shouldn&#39;t be addressed, but I&#39;m concerned about addressing this in a<br>&gt; temporary way that we think may be sub-optimal.<br></p><p>Is it the interface or the implementation that you think might be suboptimal? As long as we can settle on a good API, we don’t have to worry about the implementation changing underneath it, do we?<br></p><p>&gt; <br>&gt;&gt; The stdlib (i.e., the parts touched by the PR) and corelibs-foundation<br>&gt;&gt; would have to move in lockstep to adopt a replacement, so the existing<br>&gt;&gt; underscored versions are as good as public API.<br>&gt;&gt; <br>&gt;&gt; I understand, and 100% encourage, the reticence around new API. However,<br>&gt;&gt; we&#39;ve created a worse problem by encouraging slow, buggy, custom<br>&gt;&gt; versions of behavior that already exists in the stdlib, or implying that<br>&gt;&gt; the underscored API should be used because we haven&#39;t managed something<br>&gt;&gt; better yet. :/<br>&gt; <br>&gt; I am not reticent to have new API.  I am reticent to accept partial or<br>&gt; known-suboptimal temporary solutions when we are developing a<br>&gt; comprehensive plan that ought to address the same problems (among many<br>&gt; others).<br></p><p>Is the comprehensive String redesign happening in public? I haven’t found anything, but I probably just don’t know where to look.<br></p><p>—CK<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
