<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Fwd: [Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 05:00:00am</p></header><div class="content"><p>Begin forwarded message:<br></p><p>&gt; From: &quot;L. Mihalkovic&quot; &lt;laurent.mihalkovic at gmail.com&gt;<br>&gt; Date: May 25, 2016 at 10:08:35 PM GMT+2<br>&gt; To: Tony Allevato &lt;allevato at google.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Automatically deriving Equatable and Hashable for certain value types<br></p><p>There are precedents that show that something like this needs to provide the ability for users to influence the heuristic. Something like this comes to mind (not limited to let/var fields but allowing to mark value returning method/properties)<br></p><p>Struct xxxxxx {<br>    @strawman_id Var f1<br>    @strawman_id func getabc() -&gt; Int<br>    Var nonIdField<br>}<br></p><p>@strawman_all_id Struct xxxxxx {<br>    Var f1<br>    Var f2<br>    Var f3<br>}<br></p><p>whereby the compiler can be told what is id versus not. That should eliminate many manual override situations. There is at least 10 years of precedent showing the usefulness and/or pitfall or such schemes.<br></p><p><br>Problem is I think this is something that can probably be equally done using the upcoming behaviors, or via the further down the roard macros. Either way, I&#39;m not sure it belongs anywhere in the form described.<br></p><p><br>&gt; On May 25, 2016, at 8:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; <br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt; <br>&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; Proposal: SE-0000<br>&gt;&gt; Author(s): Tony Allevato<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;   return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;          lhs.property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;          lhs.property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;          ...<br>&gt;&gt; }<br>&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; <br>&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt; <br>&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool {<br>&gt;&gt;   switch (lhs, rhs) {<br>&gt;&gt;   case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let rSuit)):<br>&gt;&gt;     return lRank == rRank &amp;&amp; lSuit == rSuit<br>&gt;&gt;   case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let rFour)):<br>&gt;&gt;     return lFour == rFour<br>&gt;&gt;   case (.fullHouse(three: let lThree), .fullHouse(three: let rThree)):<br>&gt;&gt;     return lThree == rThree<br>&gt;&gt;   case (.flush(let lRank, let lSuit), .flush(let rRank, let rSuit)):<br>&gt;&gt;     return lSuit == rSuit &amp;&amp; lRank == rRank<br>&gt;&gt;   case (.straight(high: let lRank), .straight(high: let rRank)):<br>&gt;&gt;     return lRank == rRank<br>&gt;&gt;   case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let rRank)):<br>&gt;&gt;     return lRank == rRank<br>&gt;&gt;   case (.twoPair(high: let lHigh, low: let lLow, highCard: let lCard),<br>&gt;&gt;         .twoPair(high: let rHigh, low: let rLow, highCard: let rCard)):<br>&gt;&gt;     return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard == rCard<br>&gt;&gt;   case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let lCard3),<br>&gt;&gt;         .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let rCard3)):<br>&gt;&gt;     return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 == rCard3<br>&gt;&gt;   case (.highCard(let lCard), .highCard(let rCard)):<br>&gt;&gt;     return lCard == rCard<br>&gt;&gt;   default:<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt; <br>&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt; <br>&gt;&gt; enum Foo: Int {<br>&gt;&gt;   case one = 1<br>&gt;&gt;   case two = 2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt; <br>&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; <br>&gt;&gt; A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt; <br>&gt;&gt; An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt; <br>&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; <br>&gt;&gt; A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; <br>&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt; <br>&gt;&gt; An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt; <br>&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; <br>&gt;&gt; Overriding defaults<br>&gt;&gt; <br>&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt; <br>&gt;&gt; Open questions<br>&gt;&gt; <br>&gt;&gt; Omission of fields from generated computations<br>&gt;&gt; <br>&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; <br>&gt;&gt; Explicit or implicit derivation<br>&gt;&gt; <br>&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt; <br>&gt;&gt; Acknowledgments<br>&gt;&gt; <br>&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/f3cbce87/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
