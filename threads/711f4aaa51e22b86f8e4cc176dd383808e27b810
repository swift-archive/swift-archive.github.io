<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160226/711fb810/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 26, 2016 at 11:00:00pm</p></header><div class="content"><p>On Feb 26, 2016, at 7:05 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br></p><p>-0.1<br>There is nothing wrong with this proposal but I just don&#39;t see the value over private (plus a little doc comment if absolutely necessary).<br></p><p>Downside is more language to learn / encounter and complexity to maintain. <br></p><p>I&#39;ve read the proposal but not the preceding discussion.<br></p><p>Joseph<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/e2ae16e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 01:00:00am</p></header><div class="content"><p>By the same logic, the comment alone is enough, the private keyword isn&#39;t<br>necessary. The benefit of scoped is that the intent would be enforceable by<br>the compiler.<br>On Fri, Feb 26, 2016 at 6:48 PM Joseph Lord via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Feb 26, 2016, at 7:05 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through<br>&gt; March 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt;<br>&gt; -0.1<br>&gt; There is nothing wrong with this proposal but I just don&#39;t see the value<br>&gt; over private (plus a little doc comment if absolutely necessary).<br>&gt;<br>&gt; Downside is more language to learn / encounter and complexity to maintain.<br>&gt;<br>&gt; I&#39;ve read the proposal but not the preceding discussion.<br>&gt;<br>&gt; Joseph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/b0d6ba56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 27, 2016 at 01:00:00am</p></header><div class="content"><p>The key differences are:<br></p><p>1) You are already the file implementing on that area of code if you are in the same file. <br>2) The file shouldn&#39;t be that big whereas the module is likely to have hundreds of files and several people on it.<br>3) There are performance benefits to be had with private (at least when Whole Module Optimisation is off).<br></p><p>I&#39;m not too worried if it does get included it just seems the gains will be quite small. Can you point me to some code that would really benefit or where the lack of it has caused mistakes or problems in the past?<br></p><p>Joseph<br></p><p>&gt; On Feb 27, 2016, at 1:24 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; By the same logic, the comment alone is enough, the private keyword isn&#39;t necessary. The benefit of scoped is that the intent would be enforceable by the compiler. <br>&gt;&gt; On Fri, Feb 26, 2016 at 6:48 PM Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Feb 26, 2016, at 7:05 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;&gt; <br>&gt;&gt; -0.1<br>&gt;&gt; There is nothing wrong with this proposal but I just don&#39;t see the value over private (plus a little doc comment if absolutely necessary).<br>&gt;&gt; <br>&gt;&gt; Downside is more language to learn / encounter and complexity to maintain. <br>&gt;&gt; <br>&gt;&gt; I&#39;ve read the proposal but not the preceding discussion.<br>&gt;&gt; <br>&gt;&gt; Joseph<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/b7fdbbb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 02:00:00am</p></header><div class="content"><p>The question is not whether it&#39;s in the same file but whether it should<br>have access to internal state (and potentially mutate it). If it shouldn&#39;t,<br>the compiler should enforce it no matter which file you are in. This is not<br>possible right now. A similar argument could be made about var and let. If<br>you are careful, then you can just have var (and put a comment that the<br>value is not supposed to change). Everybody likes let because it&#39;s enforced<br>by the compiler. The same applies to scoped. If you don&#39;t have any<br>implementation details that you want to hide, you will not benefit from<br>scoped. But if you do, the compiler will enforce it much better than any<br>convention or comments.<br>On Fri, Feb 26, 2016 at 8:53 PM Joseph Lord &lt;joseph at human-friendly.com&gt;<br>wrote:<br></p><p>&gt; The key differences are:<br>&gt;<br>&gt; 1) You are already the file implementing on that area of code if you are<br>&gt; in the same file.<br>&gt; 2) The file shouldn&#39;t be that big whereas the module is likely to have<br>&gt; hundreds of files and several people on it.<br>&gt; 3) There are performance benefits to be had with private (at least when<br>&gt; Whole Module Optimisation is off).<br>&gt;<br>&gt; I&#39;m not too worried if it does get included it just seems the gains will<br>&gt; be quite small. Can you point me to some code that would really benefit or<br>&gt; where the lack of it has caused mistakes or problems in the past?<br>&gt;<br>&gt; Joseph<br>&gt;<br>&gt; On Feb 27, 2016, at 1:24 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; By the same logic, the comment alone is enough, the private keyword isn&#39;t<br>&gt; necessary. The benefit of scoped is that the intent would be enforceable by<br>&gt; the compiler.<br>&gt; On Fri, Feb 26, 2016 at 6:48 PM Joseph Lord via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 26, 2016, at 7:05 PM, Douglas Gregor via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through<br>&gt;&gt; March 3, 2016. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -0.1<br>&gt;&gt; There is nothing wrong with this proposal but I just don&#39;t see the value<br>&gt;&gt; over private (plus a little doc comment if absolutely necessary).<br>&gt;&gt;<br>&gt;&gt; Downside is more language to learn / encounter and complexity to<br>&gt;&gt; maintain.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve read the proposal but not the preceding discussion.<br>&gt;&gt;<br>&gt;&gt; Joseph<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/ded6aacc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 26, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>I don&#39;t think it makes its case well. The alternatives it lists are sufficient and, if anything, mentioning them makes their case equally well (or better).<br></p><p>The suggestion that the current behavior &quot;forces a one class per file structure&quot; is misleading. While it may require a careful API designer to use one file to scope truly private behavior, they are free to implement other parts of this class/structure/enumeration (and others) elsewhere.<br></p><p>The one limitation of splitting logic over many files (a limitation the proposal does not mention) is that stored properties can only be defined in the initial definition of a class/structure. I can see a separate case (and proposal) to be made for allowing stored properties to be defined in extensions as long as the class/structure definition exists in the same module. I also remember reading a lukewarm discussion here around removing this limitation.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No. The problems it attempts to address can already be solved with the existing levels of access control. It also feels incongruous alongside them and would make Swift&#39;s design more confusing and complex.<br></p><p>I believe that for those that want it, this kind of scoping could be enforced using a linter.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. Swift has lately been removing, not adding, complexity. The bar for new language features is being set rather high, and this proposal in its current state is not convincing enough.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don&#39;t know of any other languages that have 4 levels of access control. I have used languages that have more traditional &quot;protected&quot; and &quot;private&quot; inheritance-based access control (the latter of which is similar to that suggested in this proposal). I believe the Swift team carefully considered prior art and thoughtfully designed the current setup (as described in https://github.com/apple/swift/blob/master/docs/AccessControl.rst).<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read through the proposal and have thought extensively about the existing design.<br></p><p>--<br>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 03:00:00pm</p></header><div class="content"><p>This is a good example of the arguments against the proposal. Let me try to<br>summarize and address them:<br></p><p>1) using a convention is sufficient to declare intent<br>2) the programmer changing the file should know what he is doing, so a<br>comment should be enough<br>3) since the programmer has access to the code, he can just change the<br>access level, so there is no need to go beyond the file scope<br>4) given the previous arguments, this small addition is not worth<br>increasing the language complexity<br></p><p>Now, let&#39;s pretend that &quot;let&quot; is not in the language and run it through the<br>list to see if it&#39;s worth adding:<br></p><p>1) there is a common convention of using ALL_CAPS for constants (used in<br>C). Another common convention is to use &quot;k&quot; in front of the name. Cocoa<br>APIs use it in many places. &quot;let&quot; not need. Check.<br>2) if the programmer is expected to have the proper knowledge about the<br>file he is in, this is a must for variables / constants in the *local*<br>scope. &quot;let&quot; not needed. Check.<br>3) since the programmer has access to the code, he can always just change<br>let to var. The compiler cannot help with that. &quot;Let&quot; doesn&#39;t protect then,<br>so it&#39;s not needed. Check.<br>4) This definitely increases the language and implementation complexity,<br>and especially given (3), it would be an addition that can be easily worked<br>around, so why bother? Check.<br></p><p>And yet, it is in the language because it backs a very important concept<br>(immutability) and lets the compiler enforce it. Moreover, Xcode keeps<br>track of this, and if you declare something as var and use it as a<br>constant, it will actively suggest that you change it to &quot;let&quot;.<br></p><p>We should have &quot;scoped&quot; (or &quot;local&quot;) for exactly the same reasons. Most<br>likely, any argument against it would apply to &quot;let&quot; in much the same way<br>(and the arguments for it are also similar to arguments for having &quot;let&quot;).<br>And it would be great if Xcode noticed that you use something only<br>internally and actively suggested to make it scoped. The important concepts<br>that &quot;scoped&quot; would back are encapsulation and information hiding. Just as<br>immutability, encapsulation is a fundamental (and related!) concept, so I<br>don&#39;t think that the proposal needs to sell itself through compelling<br>examples. We all know what it&#39;s about.<br></p><p>On Fri, Feb 26, 2016 at 8:39 PM Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; What is your evaluation of the proposal?<br>&gt;<br>&gt; I don&#39;t think it makes its case well. The alternatives it lists are<br>&gt; sufficient and, if anything, mentioning them makes their case equally well<br>&gt; (or better).<br>&gt;<br>&gt; The suggestion that the current behavior &quot;forces a one class per file<br>&gt; structure&quot; is misleading. While it may require a careful API designer to<br>&gt; use one file to scope truly private behavior, they are free to implement<br>&gt; other parts of this class/structure/enumeration (and others) elsewhere.<br>&gt;<br>&gt; The one limitation of splitting logic over many files (a limitation the<br>&gt; proposal does not mention) is that stored properties can only be defined in<br>&gt; the initial definition of a class/structure. I can see a separate case (and<br>&gt; proposal) to be made for allowing stored properties to be defined in<br>&gt; extensions as long as the class/structure definition exists in the same<br>&gt; module. I also remember reading a lukewarm discussion here around removing<br>&gt; this limitation.<br>&gt;<br>&gt; &gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt; No. The problems it attempts to address can already be solved with the<br>&gt; existing levels of access control. It also feels incongruous alongside them<br>&gt; and would make Swift&#39;s design more confusing and complex.<br>&gt;<br>&gt; I believe that for those that want it, this kind of scoping could be<br>&gt; enforced using a linter.<br>&gt;<br>&gt; &gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; No. Swift has lately been removing, not adding, complexity. The bar for<br>&gt; new language features is being set rather high, and this proposal in its<br>&gt; current state is not convincing enough.<br>&gt;<br>&gt; &gt; If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I don&#39;t know of any other languages that have 4 levels of access control.<br>&gt; I have used languages that have more traditional &quot;protected&quot; and &quot;private&quot;<br>&gt; inheritance-based access control (the latter of which is similar to that<br>&gt; suggested in this proposal). I believe the Swift team carefully considered<br>&gt; prior art and thoughtfully designed the current setup (as described in<br>&gt; https://github.com/apple/swift/blob/master/docs/AccessControl.rst).<br>&gt;<br>&gt; &gt; How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; I read through the proposal and have thought extensively about the<br>&gt; existing design.<br>&gt;<br>&gt; --<br>&gt; Stephen<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/9238c3a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 8:57 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a good example of the arguments against the proposal. Let me try to summarize and address them:<br>&gt; <br>&gt; 1) using a convention is sufficient to declare intent<br>&gt; 2) the programmer changing the file should know what he is doing, so a comment should be enough<br>&gt; 3) since the programmer has access to the code, he can just change the access level, so there is no need to go beyond the file scope<br>&gt; 4) given the previous arguments, this small addition is not worth increasing the language complexity<br>&gt; <br>&gt; Now, let&#39;s pretend that &quot;let&quot; is not in the language and run it through the list to see if it&#39;s worth adding:<br>&gt; <br>&gt; 1) there is a common convention of using ALL_CAPS for constants (used in C). Another common convention is to use &quot;k&quot; in front of the name. Cocoa APIs use it in many places. &quot;let&quot; not need. Check.<br></p><p>&gt; 2) if the programmer is expected to have the proper knowledge about the file he is in, this is a must for variables / constants in the *local* scope. &quot;let&quot; not needed. Check.<br>&gt; 3) since the programmer has access to the code, he can always just change let to var. The compiler cannot help with that. &quot;Let&quot; doesn&#39;t protect then, so it&#39;s not needed. Check.<br>&gt; 4) This definitely increases the language and implementation complexity, and especially given (3), it would be an addition that can be easily worked around, so why bother? Check.<br></p><p>let/var does actually enforce intent. I have to actually change let to var before I can modify a value.<br></p><p>This proposal does not enforce intent. I do not have to change from “scoped”/“local” to “private” in order to break encapsulation - I just add another method to the class.<br></p><p>That is my primary complaint against scoped/local access - it is an arbitrary limitation that does not improve my ability to express what is invariant in a class beyond private. I still have to assume any change within a file may have abused scoped access permissions until I evaluate said change.<br></p><p>Some of my personal opinion on this may be the volume of changes I try to evaluate as line-by-line diffs. A change from let to var or from non-optional to IUO shows up as part of such a change. Where code was lexically inserted within a file does not. Unlike var/let and optionals, I don’t believe scoped allows a reviewer to know that invariants were abused without an analysis of the file which was modified.<br></p><p>More so, I can request and expect a certain evaluation about a developer changing a variable from being constant to non-constant, or from non-optional to optional. “Scoped”/“Local” does not require the developer to change a line of code to get different behavior - they simply change the location where their code is inserted. This is because access control only affects behavior at the call site, not the actual functionality of a variable or method.<br></p><p>If a developer thinks their method requires access to scoped/local properties or methods, they will just add that to the body of the class. The *only* thing that makes such a change safe is understanding of the invariants of the class - and scoped/local do not affect the behavior of these invariants or a developer’s ability/need to understand them whatsoever.<br></p><p>My understanding of your argument is that let/var are justified because they improve safety and more strongly indicate intent, and that scoped/local are justified for the same reason.<br></p><p>My argument, however, is that scoped/local do not meaningfully improve safety or indicate intent over a mix of private and partitioning code into files. Scoped/local allows the access control model to scale to having more code be included in a single file. <br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; let/var does actually enforce intent. I have to actually change let to<br>var before I can modify a value.<br></p><p>&quot;scoped&quot; also enforces intent. You have to actually mark something as at<br>least &quot;private&quot; to be able to use it outside its scope.<br></p><p>&gt; This proposal does not enforce intent. I do not have to change from<br>“scoped”/“local” to “private” in &gt; order to break encapsulation - I just<br>add another method to the class.<br></p><p>Exactly the same is true about &quot;private&quot;. You don&#39;t have to change from<br>&quot;private&quot; to &quot;internal&quot; in order to make something accessible from another<br>file -- you just add another method to the class.<br></p><p>&gt; That is my primary complaint against scoped/local access - it is an<br>arbitrary limitation that does not &gt; improve my ability to express what is<br>invariant in a class beyond private. I still have to assume any &gt; change<br>within a file may have abused scoped access permissions until I evaluate<br>said change.<br></p><p>Exactly the same is true about &quot;private&quot; vs. &quot;internal&quot;. In general, as<br>long as you have access to the source code, you could move code around or<br>introduce wrappers to work around the original definition without modifying<br>it. By this logic, only &quot;internal&quot;  and &quot;public&quot; make sense. And yet,<br>&quot;private&quot; is in the language because it provides a way to express an intent<br>related to encapsulation, and that intent is enforced by the compiler.<br>&quot;scoped&quot; should be there for the same reason.<br></p><p>&gt; My argument, however, is that scoped/local do not meaningfully improve<br>safety or indicate intent &gt; over a mix of private and partitioning code<br>into files.<br></p><p>It does. It expresses the intent that a method or a property is private to<br>the scope in which it is defined. This allows to provide the proper<br>interface outside of the scope independently of where the scope is in the<br>source code. This is important because interfaces are defined at the scope<br>level, not file level. In the most concrete example, this allows hiding<br>state (data encapsulation), but the same is true for methods in extensions.<br></p><p><br>On Sat, Feb 27, 2016 at 11:45 AM David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 27, 2016, at 8:57 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; This is a good example of the arguments against the proposal. Let me try<br>&gt; to summarize and address them:<br>&gt; &gt;<br>&gt; &gt; 1) using a convention is sufficient to declare intent<br>&gt; &gt; 2) the programmer changing the file should know what he is doing, so a<br>&gt; comment should be enough<br>&gt; &gt; 3) since the programmer has access to the code, he can just change the<br>&gt; access level, so there is no need to go beyond the file scope<br>&gt; &gt; 4) given the previous arguments, this small addition is not worth<br>&gt; increasing the language complexity<br>&gt; &gt;<br>&gt; &gt; Now, let&#39;s pretend that &quot;let&quot; is not in the language and run it through<br>&gt; the list to see if it&#39;s worth adding:<br>&gt; &gt;<br>&gt; &gt; 1) there is a common convention of using ALL_CAPS for constants (used in<br>&gt; C). Another common convention is to use &quot;k&quot; in front of the name. Cocoa<br>&gt; APIs use it in many places. &quot;let&quot; not need. Check.<br>&gt;<br>&gt; &gt; 2) if the programmer is expected to have the proper knowledge about the<br>&gt; file he is in, this is a must for variables / constants in the *local*<br>&gt; scope. &quot;let&quot; not needed. Check.<br>&gt; &gt; 3) since the programmer has access to the code, he can always just<br>&gt; change let to var. The compiler cannot help with that. &quot;Let&quot; doesn&#39;t<br>&gt; protect then, so it&#39;s not needed. Check.<br>&gt; &gt; 4) This definitely increases the language and implementation complexity,<br>&gt; and especially given (3), it would be an addition that can be easily worked<br>&gt; around, so why bother? Check.<br>&gt;<br>&gt; let/var does actually enforce intent. I have to actually change let to var<br>&gt; before I can modify a value.<br>&gt;<br>&gt; This proposal does not enforce intent. I do not have to change from<br>&gt; “scoped”/“local” to “private” in order to break encapsulation - I just add<br>&gt; another method to the class.<br>&gt;<br>&gt; That is my primary complaint against scoped/local access - it is an<br>&gt; arbitrary limitation that does not improve my ability to express what is<br>&gt; invariant in a class beyond private. I still have to assume any change<br>&gt; within a file may have abused scoped access permissions until I evaluate<br>&gt; said change.<br>&gt;<br>&gt; Some of my personal opinion on this may be the volume of changes I try to<br>&gt; evaluate as line-by-line diffs. A change from let to var or from<br>&gt; non-optional to IUO shows up as part of such a change. Where code was<br>&gt; lexically inserted within a file does not. Unlike var/let and optionals, I<br>&gt; don’t believe scoped allows a reviewer to know that invariants were abused<br>&gt; without an analysis of the file which was modified.<br>&gt;<br>&gt; More so, I can request and expect a certain evaluation about a developer<br>&gt; changing a variable from being constant to non-constant, or from<br>&gt; non-optional to optional. “Scoped”/“Local” does not require the developer<br>&gt; to change a line of code to get different behavior - they simply change the<br>&gt; location where their code is inserted. This is because access control only<br>&gt; affects behavior at the call site, not the actual functionality of a<br>&gt; variable or method.<br>&gt;<br>&gt; If a developer thinks their method requires access to scoped/local<br>&gt; properties or methods, they will just add that to the body of the class.<br>&gt; The *only* thing that makes such a change safe is understanding of the<br>&gt; invariants of the class - and scoped/local do not affect the behavior of<br>&gt; these invariants or a developer’s ability/need to understand them<br>&gt; whatsoever.<br>&gt;<br>&gt; My understanding of your argument is that let/var are justified because<br>&gt; they improve safety and more strongly indicate intent, and that<br>&gt; scoped/local are justified for the same reason.<br>&gt;<br>&gt; My argument, however, is that scoped/local do not meaningfully improve<br>&gt; safety or indicate intent over a mix of private and partitioning code into<br>&gt; files. Scoped/local allows the access control model to scale to having more<br>&gt; code be included in a single file.<br>&gt;<br>&gt; -DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/e99461ca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 26, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 26 févr. 2016 à 14:05, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>One good thing which is not fully highlighted in the proposal is when using nested classes, one can protect the guts of the inner class from the containing class. For completeness the local keyword would have to be useable to create local setter as well.<br></p><p>class outer {<br>    class counter {<br>        local(set) var count: Int = 0 // Cannot set from outer<br>        func incr() { count += 1 }<br>    }<br>    var data = counter()<br>    func somework() { data.incr() }<br>}<br></p><p><br>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/9d8875a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 for the local scope.<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 10:44 PM, Dany St-Amant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Le 26 févr. 2016 à 14:05, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through<br>&gt; March 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt;<br>&gt; One good thing which is not fully highlighted in the proposal is when<br>&gt; using nested classes, one can protect the guts of the inner class from the<br>&gt; containing class. For completeness the local keyword would have to be<br>&gt; useable to create local setter as well.<br>&gt;<br>&gt; class outer {<br>&gt;     class counter {<br>&gt;         local(set) var count: Int = 0 // Cannot set from outer<br>&gt;         func incr() { count += 1 }<br>&gt;     }<br>&gt;     var data = counter()<br>&gt;     func somework() { data.incr() }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/13e44f87/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>February 26, 2016 at 09:00:00pm</p></header><div class="content"><p>https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>I support the proposed change to add a locally scoped access level. After following the original discussion and re-reading the proposal, I&#39;m confident that this additional scope level would support the design decisions already present in Swift and help us write safer, simpler code.<br></p><p>Adding the local access level would essentially let extensions act as local scope blocks for a type&#39;s or protocol&#39;s methods. Many methods are made simpler by extracting an encapsulated chunk into a separate function, but these extracted bits have preconditions and requirements that would be excessive to check again.<br></p><p>For example, one algorithm for rotating a collection uses an &quot;unguarded&quot; rotate as one of its steps, which is optimized to rotate a portion of the collection without bothering to check the inputs. It makes sense to extract this bit of the full rotation algorithm into a separate function, but it&#39;s unsafe to call unless very specific requirements are met that are unlikely outside the expected context. Being able to specify a local access level for the unguarded rotation would make this safer.<br></p><p>While an additional access level would certainly make the system more complicated, the proposed &quot;local&quot; access level fits into the same framework as the three existing tiers. Unlike adding an inheritance-based level like &quot;protected&quot;, this continues the practice of access level as defined by proximity. Types and methods are available at the global, module, or file level; this proposal would extend that down to the scope level for even finer control over the same axis of specificity.<br></p><p>In sum, this proposal gets my vote and I&#39;m certain I would use the feature if added to Swift.<br></p><p>Nate<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/d1495109/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 26, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 10:21 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For example, one algorithm for rotating a collection uses an &quot;unguarded&quot; rotate as one of its steps, which is optimized to rotate a portion of the collection without bothering to check the inputs. It makes sense to extract this bit of the full rotation algorithm into a separate function, but it&#39;s unsafe to call unless very specific requirements are met that are unlikely outside the expected context. Being able to specify a local access level for the unguarded rotation would make this safer.<br></p><p>I&#39;m curious if you could make the example more concrete and provide actual code that would benefit? One of the tough things about evaluating both SE-0025 and SE-0026 is that the proposals themselves contain very basic examples that don&#39;t sell the concepts.<br></p><p>--<br>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>February 28, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 9:42 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 10:21 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For example, one algorithm for rotating a collection uses an &quot;unguarded&quot; rotate as one of its steps, which is optimized to rotate a portion of the collection without bothering to check the inputs. It makes sense to extract this bit of the full rotation algorithm into a separate function, but it&#39;s unsafe to call unless very specific requirements are met that are unlikely outside the expected context. Being able to specify a local access level for the unguarded rotation would make this safer.<br>&gt; <br>&gt; I&#39;m curious if you could make the example more concrete and provide actual code that would benefit? One of the tough things about evaluating both SE-0025 and SE-0026 is that the proposals themselves contain very basic examples that don&#39;t sell the concepts.<br></p><p>Sure. you can see the rotate code here:<br>	https://gist.github.com/natecook1000/df70dd6a1e1aa1228d42<br></p><p>`unguardedRotate` is the method that would benefit from being locally scoped. It was even more fragile before the last refactor, but in its current form descends into an infinite loop if the parameter is either the startIndex or endIndex of the collection.<br></p><p>Nate<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>+1<br></p><p>I think that what we have is completely workable but `local` could give an<br>added degree of control and expression while preserving/augmenting the<br>model that we already have for access modifiers.<br></p><p>On Sun, Feb 28, 2016 at 2:18 AM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Feb 26, 2016, at 9:42 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Feb 26, 2016, at 10:21 PM, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For example, one algorithm for rotating a collection uses an<br>&gt; &quot;unguarded&quot; rotate as one of its steps, which is optimized to rotate a<br>&gt; portion of the collection without bothering to check the inputs. It makes<br>&gt; sense to extract this bit of the full rotation algorithm into a separate<br>&gt; function, but it&#39;s unsafe to call unless very specific requirements are met<br>&gt; that are unlikely outside the expected context. Being able to specify a<br>&gt; local access level for the unguarded rotation would make this safer.<br>&gt; &gt;<br>&gt; &gt; I&#39;m curious if you could make the example more concrete and provide<br>&gt; actual code that would benefit? One of the tough things about evaluating<br>&gt; both SE-0025 and SE-0026 is that the proposals themselves contain very<br>&gt; basic examples that don&#39;t sell the concepts.<br>&gt;<br>&gt; Sure. you can see the rotate code here:<br>&gt;         https://gist.github.com/natecook1000/df70dd6a1e1aa1228d42<br>&gt;<br>&gt; `unguardedRotate` is the method that would benefit from being locally<br>&gt; scoped. It was even more fragile before the last refactor, but in its<br>&gt; current form descends into an infinite loop if the parameter is either the<br>&gt; startIndex or endIndex of the collection.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/82387e48/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>February 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 28, 2016, at 1:18 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 9:42 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 10:21 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, one algorithm for rotating a collection uses an &quot;unguarded&quot; rotate as one of its steps, which is optimized to rotate a portion of the collection without bothering to check the inputs. It makes sense to extract this bit of the full rotation algorithm into a separate function, but it&#39;s unsafe to call unless very specific requirements are met that are unlikely outside the expected context. Being able to specify a local access level for the unguarded rotation would make this safer.<br>&gt;&gt; <br>&gt;&gt; I&#39;m curious if you could make the example more concrete and provide actual code that would benefit? One of the tough things about evaluating both SE-0025 and SE-0026 is that the proposals themselves contain very basic examples that don&#39;t sell the concepts.<br>&gt; <br>&gt; Sure. you can see the rotate code here:<br>&gt; 	https://gist.github.com/natecook1000/df70dd6a1e1aa1228d42<br>&gt; <br>&gt; `unguardedRotate` is the method that would benefit from being locally scoped. It was even more fragile before the last refactor, but in its current form descends into an infinite loop if the parameter is either the startIndex or endIndex of the collection.<br></p><p>For another example, see this comment in the standard library, which says not to use the _variantStorage property, then scroll down about twenty lines to see it used:<br>	https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb#L432<br></p><p>As a reader of this file, what should be my interpretation here? (a) The init that uses _variantStorage just got put in the wrong place, (b) the init should&#39;ve been written without using _variantStorage, or (c) the comment is outdated? Marking _variantStorage as scoped and closing the initial declaration block of the type would both communicate and enforce the actual intent.<br></p><p>Nate<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 28, 2016, at 2:18 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sure. you can see the rotate code here:<br>&gt; 	https://gist.github.com/natecook1000/df70dd6a1e1aa1228d42<br>&gt; <br>&gt; `unguardedRotate` is the method that would benefit from being locally scoped. It was even more fragile before the last refactor, but in its current form descends into an infinite loop if the parameter is either the startIndex or endIndex of the collection.<br></p><p>Thanks for sharing! Is there a reason to prefer `local` here over `private` or a slight refactor that embeds the unguarded logic in a nested function?<br></p><p>&gt; For another example, see this comment in the standard library, which says not to use the _variantStorage property, then scroll down about twenty lines to see it used:<br>&gt; 	https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb#L432<br>&gt; <br>&gt; As a reader of this file, what should be my interpretation here? (a) The init that uses _variantStorage just got put in the wrong place, (b) the init should&#39;ve been written without using _variantStorage, or (c) the comment is outdated? Marking _variantStorage as scoped and closing the initial declaration block of the type would both communicate and enforce the actual intent.<br></p><p><br>It also appears that `_variantStorage` is `internal` when it could be marked `private`, right?<br></p><p>A lot of this discussion brings me back to a point I brought up in my evaluation: if class/structure extensions could define storage from the same module in which they&#39;re defined, is there anything that `local` would provide that the existing model can&#39;t?<br></p><p>I do see `local` solving current problems and providing a more expressive/flexible ability to scope without having to reorganize things into multiple files and extensions, I just wonder if there are better solutions to the problems that don&#39;t require another level of access control.<br></p><p>Stephen<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>+0.9<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.  Let me defend that a little, since that seems to be the angle of criticism for this proposal.<br></p><p>Some propose that convention is good enough.  But the difference in safety between &quot;convention&quot; and &quot;compile error&quot; is stark.<br></p><p>Threading is one especially pernicious case.  If I have an ivar that is only safe for access from one thread, I *need* compiler enforcement.  I *need* a guarantee that this ivar is only accessed through public interface methods that can be audited to be threadsafe.  Simply a doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br></p><p>This is not even a matter of &quot;artistic choice&quot; of whether or not I want to follow &quot;one file per class&quot;.  I can achieve thread safety with &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is UITableViewCellContentView (which is an implementation detail that should be hidden even to most of UIKit) I am now forced to expose that implementation detail to my entire team.<br></p><p>This places me in the unconscionable situation of choosing between whether I have thread safety or encapsulation, between whether my coworker will accidentally create a threading bug or accidentally use a class they ought not to use and I am unable to appropriately hide.<br></p><p>ObjC has a solution to this problem: the &quot;Foo-private.h&quot;.  Obviously I think that is not the right solution for Swift.  But to say it is not a significant problem is to be unfamiliar with the complexities of large ObjC codebases.  <br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Personally, the solution I would prefer is Rust&#39;s &quot;use&quot; / &quot;pub use&quot; system.  (For an explanation on this accessible to Swift programmers, see here &lt;http://faq.sealedabstract.com/rust/#visibility&gt;.)  The key difference is that while Swift has a flat namespace for each module, in Rust, modules are recursively composeable.  So Rust&#39;s UIKit framework would consist of multiple &quot;components&quot;, such as a UITableView component (with e.g. UITableView, UITableViewController, UITableViewCell, UITableViewCellContentView, etc.), UIText component (UITextField/UITextArea), UINotification component (UILocalNotification, UIUserNotificationAction, UIUserMutableNotificationAction), etc., where each component has identifiers that are private to the class, identifiers that are shared with only the component, identifiers that are internal to all of UIKit, and identifiers that are public to the application developer.<br></p><p>The advantage of the Rust system is that it can achieve in two access keywords what Swift achieves in four.  However, a change like that would be more controversial than the present proposal.  I support some progress on improving access modifiers, even if this is not my ideal solution.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my position somewhat in response to the growing uncertainty about dropping the NS prefix, which I think exposes some very real problems with visibility in Swift.<br></p><p>As that situation has developed, I no longer believe this proposal goes far enough.  But it does go somewhere, and we should not stay where we are.<br></p><p>&gt; On Feb 26, 2016, at 1:05 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/a38b8277/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Threading is one especially pernicious case.  If I have an ivar that is only safe for access from one thread, I *need* compiler enforcement.  I *need* a guarantee that this ivar is only accessed through public interface methods that can be audited to be threadsafe.  Simply a doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br></p><p>I’m unsure what you are imagining here - compiler protection of class details from within a closure completion handler that is also part of your class definition? I believe you would only get this with this local scope proposal if you structured your code such that callback blocks were functions outside your type definition.<br></p><p>If you are talking about access or modification of the inner state of a class and a manual audit of safety, that audit is of the file and not of the type or extension. I’m unsure if your concern is of having to split code into multiple files for safety, or that there is not a way to split code into multiple files to achieve safety in some particular scenario.<br></p><p>&gt; <br>&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I want to follow &quot;one file per class&quot;.  I can achieve thread safety with &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is UITableViewCellContentView (which is an implementation detail that should be hidden even to most of UIKit) I am now forced to expose that implementation detail to my entire team.<br></p><p>&gt; This places me in the unconscionable situation of choosing between whether I have thread safety or encapsulation, between whether my coworker will accidentally create a threading bug or accidentally use a class they ought not to use and I am unable to appropriately hide.<br></p><p>I’m not quite sure what you mean here - exposing that your class is a subclass of UITableViewCellContentView? Or that the rest of your team needs to code in different files from your class in order to maintain encapsulation?<br></p><p>It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br></p><p>&lt;snip&gt;<br></p><p>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my position somewhat in response to the growing uncertainty about dropping the NS prefix, which I think exposes some very real problems with visibility in Swift.<br>&gt; <br>&gt; As that situation has developed, I no longer believe this proposal goes far enough.  But it does go somewhere, and we should not stay where we are.<br></p><p>I don’t understand how an access control proposal pertains to changes in the Foundation public API. What is the ideal end state in your mind, and in what way is this a step toward that?<br></p><p>-DW<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/16b12296/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 26, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; I’m unsure what you are imagining here - compiler protection of class details from within a closure completion handler that is also part of your class definition?<br></p><p>What i mean here is simply<br></p><p>class Foo {<br>	///it is undefined behavior to access this variable except from specialQueue<br>       private var _specialQueueOnly = 0<br></p><p>	public var specialQueueOnly: Int {<br>		var i: I! = nil<br>		dispatch_sync(specialQueue) {<br>			i = _specialQueueOnly<br>		}<br>		return i<br>	}<br>}<br></p><p>The lynchpin of this defensive programming technique is that only these 12 lines of code have any risk of a threading bug, and we can trivially inspect the 12 lines.  So our safety hangs on two tentpegs:<br></p><p>1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler enforcement against other files trying to access this ivar<br>2.  That the file itself is 12 (or other minimal number of) lines and trivially inspectable.<br></p><p>Should we violate any of these constraints, we lose our safety.<br></p><p>&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br></p><p><br>Well, that is kind of the point: Objective-C&#39;s access control worked, and prevented you from knowing about this class.  <br></p><p>But to provide a more accessible illustration, consider the case where we have some motivation to hide Foo from the rest of our framework[/module/target/application/executable/library].  This is more likely to happen in a UIKit-sized project, where there are hundreds of public classes, and probably thousands of &quot;internal&quot; ones, and a typical class has motivation to touch 5 or 6 other classes, of the thousands that may be available.<br></p><p>In Swift, each internal class is visible to every other class.  But that is not especially workable at UIKit scale; if every class can potentially reach every other class we are in for an adventure when one of the hundred developers on your team decides that some UITableView implementation detail you&#39;ve never heard of should be accessing some UILocalNotification detail you&#39;ve also never heard of.  So we need some kind of &quot;fencing&quot; within a large framework to make good neighbors.<br></p><p>This is solved very easily: we can group several related classes into one file, and some of the classes are private.  Many ordinary people today group related classes into a file as a fencing mechanism even not at UIKit-scale.  So a file can access all of its own classes, but not all the classes of other files.  That creates the &quot;fence&quot;, and now your coworker cannot draw a line between some UITableView secret class and some UILocalNotification secret class, and your desk will not be dented from the impact of your forehead.<br></p><p>The problem now is that while fixing this situation we have broken one of our safety tentpegs.  We earlier required that Foo.swift be only 12 lines for thread safety, but now Foo is contained in a larger file so as to create a fence.  So we can solve one of these problems or the other one, but never both at the same time.<br></p><p>&quot;local&quot; effectively resolves this dilemma, because if our _specialQueueOnly variable is local, then it is not the /file/ which must be kept to 12 lines, but the /scope/.  So we could group an unlimited number of classes in Foo.swift, with no loss of confidence for our thread safety.<br></p><p>A better approach might be to realize that if global scope, target scope, and file scope do not solve the visibility problem, perhaps yet another scope will not totally solve the problem either.  I fully expect Apple will need a &quot;vendor&quot; scope for example (so that UIKit and CoreAnimation, two public frameworks, can still have private APIs between them), and I bet there are many more kinds of scopes that have not yet occurred to me.<br></p><p>Behind that realization lies the Rust system, which divorces visibility from these arbitrary scopes that we seem to be struggling to fit into.  But that proposal isn&#39;t before us, and this one is.  I prefer going somewhere to staying here.<br></p><p>Drew<br> <br></p><p>&gt; On Feb 26, 2016, at 10:34 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that is only safe for access from one thread, I *need* compiler enforcement.  I *need* a guarantee that this ivar is only accessed through public interface methods that can be audited to be threadsafe.  Simply a doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt; <br>&gt; I’m unsure what you are imagining here - compiler protection of class details from within a closure completion handler that is also part of your class definition? I believe you would only get this with this local scope proposal if you structured your code such that callback blocks were functions outside your type definition.<br>&gt; <br>&gt; If you are talking about access or modification of the inner state of a class and a manual audit of safety, that audit is of the file and not of the type or extension. I’m unsure if your concern is of having to split code into multiple files for safety, or that there is not a way to split code into multiple files to achieve safety in some particular scenario.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I want to follow &quot;one file per class&quot;.  I can achieve thread safety with &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is UITableViewCellContentView (which is an implementation detail that should be hidden even to most of UIKit) I am now forced to expose that implementation detail to my entire team.<br>&gt; <br>&gt;&gt; This places me in the unconscionable situation of choosing between whether I have thread safety or encapsulation, between whether my coworker will accidentally create a threading bug or accidentally use a class they ought not to use and I am unable to appropriately hide.<br>&gt; <br>&gt; I’m not quite sure what you mean here - exposing that your class is a subclass of UITableViewCellContentView? Or that the rest of your team needs to code in different files from your class in order to maintain encapsulation?<br>&gt; <br>&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br>&gt; <br>&gt; &lt;snip&gt;<br>&gt; <br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my position somewhat in response to the growing uncertainty about dropping the NS prefix, which I think exposes some very real problems with visibility in Swift.<br>&gt;&gt; <br>&gt;&gt; As that situation has developed, I no longer believe this proposal goes far enough.  But it does go somewhere, and we should not stay where we are.<br>&gt; <br>&gt; I don’t understand how an access control proposal pertains to changes in the Foundation public API. What is the ideal end state in your mind, and in what way is this a step toward that?<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/0a685af6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Joseph Lord</string> &lt;Joseph at human-friendly.com&gt;<p>February 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks Drew,<br></p><p>This and your previous email have provided a good use case and shifted my view towards the positive. +0.5 now as I&#39;m still not sure it a definite win worthy of the addition to the language but I think it might be. I&#39;ll continue thinking about it. <br></p><p>Joseph<br></p><p>&gt; On 27 Feb 2016, at 05:46, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m unsure what you are imagining here - compiler protection of class details from within a closure completion handler that is also part of your class definition?<br>&gt; <br>&gt; What i mean here is simply<br>&gt; <br>&gt; class Foo {<br>&gt; 	///it is undefined behavior to access this variable except from specialQueue<br>&gt;        private var _specialQueueOnly = 0<br>&gt; <br>&gt; 	public var specialQueueOnly: Int {<br>&gt; 		var i: I! = nil<br>&gt; 		dispatch_sync(specialQueue) {<br>&gt; 			i = _specialQueueOnly<br>&gt; 		}<br>&gt; 		return i<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; The lynchpin of this defensive programming technique is that only these 12 lines of code have any risk of a threading bug, and we can trivially inspect the 12 lines.  So our safety hangs on two tentpegs:<br>&gt; <br>&gt; 1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler enforcement against other files trying to access this ivar<br>&gt; 2.  That the file itself is 12 (or other minimal number of) lines and trivially inspectable.<br>&gt; <br>&gt; Should we violate any of these constraints, we lose our safety.<br>&gt; <br>&gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br>&gt; <br>&gt; <br>&gt; Well, that is kind of the point: Objective-C&#39;s access control worked, and prevented you from knowing about this class.  <br>&gt; <br>&gt; But to provide a more accessible illustration, consider the case where we have some motivation to hide Foo from the rest of our framework[/module/target/application/executable/library].  This is more likely to happen in a UIKit-sized project, where there are hundreds of public classes, and probably thousands of &quot;internal&quot; ones, and a typical class has motivation to touch 5 or 6 other classes, of the thousands that may be available.<br>&gt; <br>&gt; In Swift, each internal class is visible to every other class.  But that is not especially workable at UIKit scale; if every class can potentially reach every other class we are in for an adventure when one of the hundred developers on your team decides that some UITableView implementation detail you&#39;ve never heard of should be accessing some UILocalNotification detail you&#39;ve also never heard of.  So we need some kind of &quot;fencing&quot; within a large framework to make good neighbors.<br>&gt; <br>&gt; This is solved very easily: we can group several related classes into one file, and some of the classes are private.  Many ordinary people today group related classes into a file as a fencing mechanism even not at UIKit-scale.  So a file can access all of its own classes, but not all the classes of other files.  That creates the &quot;fence&quot;, and now your coworker cannot draw a line between some UITableView secret class and some UILocalNotification secret class, and your desk will not be dented from the impact of your forehead.<br>&gt; <br>&gt; The problem now is that while fixing this situation we have broken one of our safety tentpegs.  We earlier required that Foo.swift be only 12 lines for thread safety, but now Foo is contained in a larger file so as to create a fence.  So we can solve one of these problems or the other one, but never both at the same time.<br>&gt; <br>&gt; &quot;local&quot; effectively resolves this dilemma, because if our _specialQueueOnly variable is local, then it is not the /file/ which must be kept to 12 lines, but the /scope/.  So we could group an unlimited number of classes in Foo.swift, with no loss of confidence for our thread safety.<br>&gt; <br>&gt; A better approach might be to realize that if global scope, target scope, and file scope do not solve the visibility problem, perhaps yet another scope will not totally solve the problem either.  I fully expect Apple will need a &quot;vendor&quot; scope for example (so that UIKit and CoreAnimation, two public frameworks, can still have private APIs between them), and I bet there are many more kinds of scopes that have not yet occurred to me.<br>&gt; <br>&gt; Behind that realization lies the Rust system, which divorces visibility from these arbitrary scopes that we seem to be struggling to fit into.  But that proposal isn&#39;t before us, and this one is.  I prefer going somewhere to staying here.<br>&gt; <br>&gt; Drew<br>&gt;  <br>&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 10:34 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that is only safe for access from one thread, I *need* compiler enforcement.  I *need* a guarantee that this ivar is only accessed through public interface methods that can be audited to be threadsafe.  Simply a doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt;&gt; <br>&gt;&gt; I’m unsure what you are imagining here - compiler protection of class details from within a closure completion handler that is also part of your class definition? I believe you would only get this with this local scope proposal if you structured your code such that callback blocks were functions outside your type definition.<br>&gt;&gt; <br>&gt;&gt; If you are talking about access or modification of the inner state of a class and a manual audit of safety, that audit is of the file and not of the type or extension. I’m unsure if your concern is of having to split code into multiple files for safety, or that there is not a way to split code into multiple files to achieve safety in some particular scenario.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I want to follow &quot;one file per class&quot;.  I can achieve thread safety with &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is UITableViewCellContentView (which is an implementation detail that should be hidden even to most of UIKit) I am now forced to expose that implementation detail to my entire team.<br>&gt;&gt; <br>&gt;&gt;&gt; This places me in the unconscionable situation of choosing between whether I have thread safety or encapsulation, between whether my coworker will accidentally create a threading bug or accidentally use a class they ought not to use and I am unable to appropriately hide.<br>&gt;&gt; <br>&gt;&gt; I’m not quite sure what you mean here - exposing that your class is a subclass of UITableViewCellContentView? Or that the rest of your team needs to code in different files from your class in order to maintain encapsulation?<br>&gt;&gt; <br>&gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br>&gt;&gt; <br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my position somewhat in response to the growing uncertainty about dropping the NS prefix, which I think exposes some very real problems with visibility in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As that situation has developed, I no longer believe this proposal goes far enough.  But it does go somewhere, and we should not stay where we are.<br>&gt;&gt; <br>&gt;&gt; I don’t understand how an access control proposal pertains to changes in the Foundation public API. What is the ideal end state in your mind, and in what way is this a step toward that?<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/8eea734b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 27, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 12:46 AM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What i mean here is simply [...]<br></p><p>Thanks Drew! This example is much more compelling than the one in the proposal, and I hope there are more that come to light in this thread. I do, however, think that property behaviors would be a better solution to that particular problem:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md#synchronized-property-access<br></p><p>--<br>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 27, 2016 at 08:00:00am</p></header><div class="content"><p>I agree that property behaviors would be more compelling due to the specific way that I motivated the example, but if you instead imagine the analogous case for a function (that can only be called from specialQueue), we are back here again.<br></p><p>I actually believe we need–and I would prefer–&quot;function behaviors&quot; (!) as a solution to this problem, and property behaviors as a solution to my example.  I mentioned this in my review of the (rejected) SE-0030.<br></p><p>However, property behaviors was tabled/rejected, and &quot;function behaviors&quot; have not been proposed, as far as I know, except in a passing remark in my review.  So regarding solutions along that line, while you and I can agree they&#39;re superior, we seem to be in the minority.<br></p><p>This is one of those cases where in my view it is better go somewhere than stay here.  The community seems to have decided for the present not to go the &quot;behavioral&quot; direction, I would be in favor of reconsidering that decision, but unfortunately that question is not the one presently before us.  This proposal is not the best solution to my problems, but it is preferable to no solution.<br></p><p>Apple folk may want to check out rdar://21435592 &lt;rdar://21435592&gt; for a spookily similar feature request to this proposal that I logged way back in June 2015, and here I am saying most of the same things now that I said then.  So from my POV it is time to do something.  The additional time I&#39;ve let this bake has caused me to reflect on this exact solution as being less excellent than I originally thought, but the problem itself still feels as fresh as it was 6 months ago.<br></p><p><br>&gt; On Feb 27, 2016, at 7:52 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 12:46 AM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What i mean here is simply [...]<br>&gt; <br>&gt; Thanks Drew! This example is much more compelling than the one in the proposal, and I hope there are more that come to light in this thread. I do, however, think that property behaviors would be a better solution to that particular problem:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md#synchronized-property-access<br>&gt; <br>&gt; --<br>&gt; Stephen<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/6ad33cbd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 26, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; What is your evaluation of the proposal?<br>-1<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>After what seemed like endless discussion, I remain unconvinced that its actual stated motivation justifies its inclusion.<br></p><p>The justification appears to be that there needs to be some way to protect portions of a single source file from one another. A better approach here from my personal experience is just to require developers to have responsibility for understanding the functioning of all the code in a file before making changes, and to structure your code so that you use multiple files to represent different concepts.<br></p><p>The example in the detailed design shows an extension in the same file where counter and advanceCount are not visible to an extension. However, there is nothing to prevent a developer who wishes to use advanceCount to implement a private incrementTwice from putting their code within the class itself, rather than in an extension - literally a difference in insertion point of the same code, and providing the same external behavior.<br></p><p>One use I can partially agree with is that a local scope would allow playground users to more easily experiment with scopes. However, it does not make sense to teach access control with playgrounds unless one is able to show the usage of other scopes - and adding another access control level which students need to keep in their head seems a counterintuitive approach to teaching.<br></p><p>I believe this proposal is mostly motivated by the impedance mismatch between ‘private’ in other languages meaning that access is restricted to a type implementation body or similar, while ‘private’ in swift limits access to the current file. While I can understand someone preferring the system they are more familiar with (especially in the face of private requiring a particular code structure), I don’t believe the additional access model complexity is justified in supporting both.<br></p><p>I expect developers would gravitate toward using one or the other. Other aspects of Swift currently push for file-level access control semantics, such as implementing Equatable for a type based on its internal state. As such, I don’t know if “local” would be used even in contexts where it might be a slightly better fit - developers will already be required to use file-level access control to implement other things.<br></p><p>I will second Joseph Lord’s inquiry for anyone code which has had negative impacts to its safety by the lack of this feature - specifically interested in cases where the file based access control was insufficient, rather than cases where file based access control was not attempted to be used.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>I don’t know of any v3 goals this aligns with.<br></p><p>My understanding is that this comes about from a simple idea - someone wants to have objects which have some protection of their API from the outside world, and to limit the interface between those objects from exposing internal implementation details in order to maintain invariance. Today, this is done by making the interface between objects internal, and putting the objects in separate files so that they can have private implementation details. Where this can fall down is when you want the API between objects to not be exposed to other members of a module.<br></p><p>Therefore, I wonder if an alternate direction for Swift evolution would be to promote the creation of many smaller modules vs a few large frameworks. Approaches which come to mind for this would be to have submodules as part of a single framework, or otherwise optimize the language, packaging, and/or runtime platform to promote the idea that ‘micro frameworks’ containing less than a half dozen types and as little as 100 lines of code are appropriate and will not have a deployment or runtime impact.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Most of my experience implementing frameworks has been on top of Java, C#, C++, and Ruby.<br></p><p>The existing public/internal/private system I believe compares favorably with these languages. I don’t believe any of these languages have a file-level limit of object accessibility, instead having ‘private’ be similar to the local lexical scope defined here. Rules about exposure of private methods when you have inner/outer types vary, as do accessibility of private methods through type introspection. As stated above, I suspect some motivation behind this proposal are the difference in ‘private’ as defined in other languages vs in Swift - but I don’t believe both are justified in being present in the language.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Significant participation in discussion before proposal.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/44878f29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; My understanding is that this comes about from a simple idea - someone wants to have objects which have some protection of their API from the outside world, and to limit the interface between those objects from exposing internal implementation details in order to maintain invariance.<br></p><p>No, this comes from the desire to document the specific members that are accessed by other scopes in the file.<br></p><p>I think it makes a significant difference when reading code.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/151f37bc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>Short form: the problem addressed is very real and IMHO very significant; the proposed solution is *useful* but on reflection seems to illustrate this isn’t a problem that can be *entirely* addressed just by adding another scope (or scope(s)). I think I agree with what I think Drew has been saying that the visibility model itself may be not quite ideal (it isn’t broken or anything). <br></p><p>I’m also a little unsure how useful `local` will be in the context of the rest of the language at this time; it seems like to really come into its own we’d also want e.g. to be able to split up the definition of a type across multiple extensions within the same module.<br></p><p>Longer form: within Swift’s existing access-control approach, if you want to keep things private—as opposed to merely internal—it’s easy to wind up with numerous closely-related types, all living in the same file. The only sensible visibility for most of the aspects of most of the types is `private`, but because these are all living in the same file we don’t actually get any effective &quot;cross-type” access-protection within that file.<br></p><p>So e.g. for a custom type implementing `CollectionType`, you can have the type itself, an associated index type, and perhaps also an associated generator type; if instead of “is-a `CollectionType`” you instead opt for “has-multiple `CollectionType` views”, then you can wind up with the base type + 2-3 closely-related types per such view (the collection type, its index, and perhaps also the generator).<br></p><p>The standard-library `String` is an example, where it’s not itself a collection but has 4 “views”, each of which defines an index, and one of which also adds a custom generator.<br></p><p>I don’t have a short example I can share, but I can describe one: at one point I wrote an “accelerated 2D point array”, which was effectively an array of `CGPoint`, but in struct-of-arrays style (e.g. separate arrays of `x` and `y` coordinates). The tricky part is it had a delicate internal state, since the actual storage looked like this (many details elided here) :<br></p><p>@implementation PointArray {<br>  float *_bufferA;<br>  float *_bufferB;<br>  float *_bufferC;<br>}<br></p><p>@property(nonatomic, assign) PointArrayState state;<br></p><p>@end<br></p><p>…wherein *which* buffer was for `x` or `y` varied over time (and was tracked via that `state` field). The reason for this design is many of the array-level operations were implemented using functions from Accelerate, which in turn often benefit from being done “out-of-place” (and thus e.g. to translate each point by dx,dy, if you started out with `bufferA` having the x-coordinates and `bufferB` having the y-coordinates, you might wind up with `bufferC` holding the updated x-coordinates and `bufferA` holding the updated y-coordinates, along with `state` updated to reflect that updated arrangement).<br></p><p>This is code that would arguably benefit from being migrated to Swift at some point. As it is in Objective-C, it’s implemented as part of a larger family of classes, and it’s easy to tightly control visibility: there’s public headers, there’s private headers imported by subclasses, and there’s methods defined in .m files that are difficult to call accidentally from anywhere else. <br></p><p>In Swift the design would change a bit — a lot of methods that in Objective-C are effectively “sort if necessary, then call this block on each point” would get migrated to “view structs” that implement `CollectionType` — but I get nervous thinking through the implementation because it seems at least a little awkward to structure the internal API in a robust way, while also having so many types all defined in the same file.<br></p><p>I’m not entirely sold that `local` is the ideal solution, but it’s definitely addressing an IMHO significant problem.<br></p><p>What does concern me about `local` is that, at present, it would seemingly force an unnatural code organization at times; the norm is typically to put each adopted protocol into its own extension, but this means that any stored fields must either be `private` — and thus not protected by `local` — or you have to implement a lot of things from within the main definition (not idiomatic).<br></p><p>Even then, consider a simple case like this:<br></p><p>public struct SomeCustomIndex&lt;T&gt; {<br>  local let position: Position<br>}<br></p><p>public func ==&lt;T&gt;(lhs: SomeViewIndex&lt;T&gt;, rhs: SomeViewIndex&lt;T&gt;) -&gt; Bool {<br>  return lhs.position == rhs.position // oops!<br>}<br></p><p>…(in this case it’s hard to see what harm you could do with `private let position`, but it illustrates a general limit to the utility of `local` declarations).<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, VERY MUCH SO.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>I’m not sure. I feel like there should be some better approach to visibility that solves this problem and is overall more “Swift”, but I don’t know what it is.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I think the closest analogy here is that &quot;private + local&quot; are trying to get Swift to the same place that, say, “protected + friend” would get it, but along a different route.<br></p><p>The general problem being solved is that Swift’s somewhat-unique approach to `private` is unsatisfactory for some cases—IMHO in particular for the “family of related types” scenario—and `local` adds another tool to solve it.<br></p><p>Although I’m well aware of the arguments against “protected (+ friend)”, I’d point out that those constructs are IMHO the *usual* approach to solving these same issues.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal, participated in original discussion, read the current discussion.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/80fd6c81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Code organization of having most methods in extensions would not work for<br>extensions that need access to internal state marked with &quot;scoped&quot;. For<br>this specific use case, one class per file + &quot;private&quot; works perfectly.<br>This code organization makes sense for very large classes but not for<br>smaller and related classes.<br></p><p>That said, I think that even in this case, &quot;scoped&quot; would help with hiding<br>helper methods that are necessary to implement protocols but are useless in<br>other places in the same file.<br></p><p>I do think that the name &quot;private&quot; is an unfortunate choice because it<br>means something else in other mainstream languages, but the access level<br>that it provides is very useful and a much better alternative than &quot;friend&quot;<br>in C++. However, we still need &quot;scoped&quot; (private in C++) to declare and<br>enforce encapsulation at the scope (class or extension) level.<br></p><p>On Sat, Feb 27, 2016 at 10:27 AM plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; Short form: the problem addressed is very real and IMHO very significant;<br>&gt; the proposed solution is *useful* but on reflection seems to illustrate<br>&gt; this isn’t a problem that can be *entirely* addressed just by adding<br>&gt; another scope (or scope(s)). I think I agree with what I think Drew has<br>&gt; been saying that the visibility model itself may be not quite ideal (it<br>&gt; isn’t broken or anything).<br>&gt;<br>&gt; I’m also a little unsure how useful `local` will be in the context of the<br>&gt; rest of the language at this time; it seems like to really come into its<br>&gt; own we’d also want e.g. to be able to split up the definition of a type<br>&gt; across multiple extensions within the same module.<br>&gt;<br>&gt; Longer form: within Swift’s existing access-control approach, if you want<br>&gt; to keep things private—as opposed to merely internal—it’s easy to wind up<br>&gt; with numerous closely-related types, all living in the same file. The only<br>&gt; sensible visibility for most of the aspects of most of the types is<br>&gt; `private`, but because these are all living in the same file we don’t<br>&gt; actually get any effective &quot;cross-type” access-protection within that file.<br>&gt;<br>&gt; So e.g. for a custom type implementing `CollectionType`, you can have the<br>&gt; type itself, an associated index type, and perhaps also an associated<br>&gt; generator type; if instead of “is-a `CollectionType`” you instead opt for<br>&gt; “has-multiple `CollectionType` views”, then you can wind up with the base<br>&gt; type + 2-3 closely-related types per such view (the collection type, its<br>&gt; index, and perhaps also the generator).<br>&gt;<br>&gt; The standard-library `String` is an example, where it’s not itself a<br>&gt; collection but has 4 “views”, each of which defines an index, and one of<br>&gt; which also adds a custom generator.<br>&gt;<br>&gt; I don’t have a short example I can share, but I can describe one: at one<br>&gt; point I wrote an “accelerated 2D point array”, which was effectively an<br>&gt; array of `CGPoint`, but in struct-of-arrays style (e.g. separate arrays of<br>&gt; `x` and `y` coordinates). The tricky part is it had a delicate internal<br>&gt; state, since the actual storage looked like this (many details elided here)<br>&gt; :<br>&gt;<br>&gt; @implementation PointArray {<br>&gt;   float *_bufferA;<br>&gt;   float *_bufferB;<br>&gt;   float *_bufferC;<br>&gt; }<br>&gt;<br>&gt; @property(nonatomic, assign) PointArrayState state;<br>&gt;<br>&gt; @end<br>&gt;<br>&gt; …wherein *which* buffer was for `x` or `y` varied over time (and was<br>&gt; tracked via that `state` field). The reason for this design is many of the<br>&gt; array-level operations were implemented using functions from Accelerate,<br>&gt; which in turn often benefit from being done “out-of-place” (and thus e.g.<br>&gt; to translate each point by dx,dy, if you started out with `bufferA` having<br>&gt; the x-coordinates and `bufferB` having the y-coordinates, you might wind up<br>&gt; with `bufferC` holding the updated x-coordinates and `bufferA` holding the<br>&gt; updated y-coordinates, along with `state` updated to reflect that updated<br>&gt; arrangement).<br>&gt;<br>&gt; This is code that would arguably benefit from being migrated to Swift at<br>&gt; some point. As it is in Objective-C, it’s implemented as part of a larger<br>&gt; family of classes, and it’s easy to tightly control visibility: there’s<br>&gt; public headers, there’s private headers imported by subclasses, and there’s<br>&gt; methods defined in .m files that are difficult to call accidentally from<br>&gt; anywhere else.<br>&gt;<br>&gt; In Swift the design would change a bit — a lot of methods that in<br>&gt; Objective-C are effectively “sort if necessary, then call this block on<br>&gt; each point” would get migrated to “view structs” that implement<br>&gt; `CollectionType` — but I get nervous thinking through the implementation<br>&gt; because it seems at least a little awkward to structure the internal API in<br>&gt; a robust way, while also having so many types all defined in the same file.<br>&gt;<br>&gt; I’m not entirely sold that `local` is the ideal solution, but it’s<br>&gt; definitely addressing an IMHO significant problem.<br>&gt;<br>&gt; What does concern me about `local` is that, at present, it would seemingly<br>&gt; force an unnatural code organization at times; the norm is typically to put<br>&gt; each adopted protocol into its own extension, but this means that any<br>&gt; stored fields must either be `private` — and thus not protected by `local`<br>&gt; — or you have to implement a lot of things from within the main definition<br>&gt; (not idiomatic).<br>&gt;<br>&gt; Even then, consider a simple case like this:<br>&gt;<br>&gt; public struct SomeCustomIndex&lt;T&gt; {<br>&gt;   local let position: Position<br>&gt; }<br>&gt;<br>&gt; public func ==&lt;T&gt;(lhs: SomeViewIndex&lt;T&gt;, rhs: SomeViewIndex&lt;T&gt;) -&gt; Bool {<br>&gt;   return lhs.position == rhs.position // oops!<br>&gt; }<br>&gt;<br>&gt; …(in this case it’s hard to see what harm you could do with `private let<br>&gt; position`, but it illustrates a general limit to the utility of `local`<br>&gt; declarations).<br>&gt;<br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yes, VERY MUCH SO.<br>&gt;<br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I’m not sure. I feel like there should be some better approach to<br>&gt; visibility that solves this problem and is overall more “Swift”, but I<br>&gt; don’t know what it is.<br>&gt;<br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I think the closest analogy here is that &quot;private + local&quot; are trying to<br>&gt; get Swift to the same place that, say, “protected + friend” would get it,<br>&gt; but along a different route.<br>&gt;<br>&gt; The general problem being solved is that Swift’s somewhat-unique approach<br>&gt; to `private` is unsatisfactory for some cases—IMHO in particular for the<br>&gt; “family of related types” scenario—and `local` adds another tool to solve<br>&gt; it.<br>&gt;<br>&gt; Although I’m well aware of the arguments against “protected (+ friend)”,<br>&gt; I’d point out that those constructs are IMHO the *usual* approach to<br>&gt; solving these same issues.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; Read the proposal, participated in original discussion, read the current<br>&gt; discussion.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/fe7e350f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>-1<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think its not necessary.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>Not sure.<br></p><p>How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>I have been following the whole discussion ago this proposal.<br></p><p>Ondrej Barina<br></p><p><br></p><p><br>On Fri, Feb 26, 2016 at 8:05 PM, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through<br>&gt; March 3, 2016. The proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt; manager. When replying, please try to keep the proposal link at the top of<br>&gt; the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do<br>&gt; you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or<br>&gt; an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 27, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>I am agains it. My rationale below.<br></p><p>One of Ilya’s main points is that encapsulation is a core principle of OOP and that Swift lacks tools to implement this properly. I think the terminology is somehow unlucky here. Encapsulation more universally refers to bundling of data and code that operates of that data, and this is indeed one of the things that defines OOP as a programming style. However, it seems that Ilya refers to data hiding, which often accompanies encapsulation. I believe it is important to distinguish these two concepts. Encapsulation as I use here is a particular problem-solving style while data hiding (what Ilya stresses) is a technique for enforcing program correctness. It is also not true that data hiding is a fundamental component of OOP languages, some of the popular ones don’t have any data hiding (e.g. Python).<br></p><p>Data hiding obviously has an important core function, which is, as I mentioned above — making sure that the program is correct, by only exposing the interface other components should have safe access to. Swift has data hiding, only the philosophy of that data hiding is a bit different from the mainstream implementations. The scope of the most restricted access is the file. If I understand the background of this design decision correctly, goal here is to allow the programmer to be as flexible as possible about what can access what but also to ‘force&#39; them to think about their code design and code layout (by organising interrelated stuff by files). Is this an ideal decision to the problem? Certainly not — it imposes some inconveniences on the programmer and can also compromise code safety (as Illya points out). Is this a good, elegant decision? In my opinion, yes. <br></p><p>I can also understand Illya’s point that a local scope access might improve code safety in certain cases. What I disagree with is that these cases are prominent or problematic enough to deserve such attention. Adding new access modifiers makes the rules of the language more complicated, but I seriously doubt that a ‘local’ specifier will make programmers significantly more productive or prevent any number of serious bugs. So far, arguments presented were more of the ideological nature and while they are formally correct, I do not think that the actual end effect is as dramatic as described. In addition, I would like to point out that ‘local’ is also only an approximation — it does not solve the safety problem entirely. It merely functions as an additional safeguard agains programmer error. The actual problem can be only solved by specifying full rules what is accessible from where and under which conditions. A system like that probably won’t be practical enough for everyday programming at this point.<br></p><p>I also think that the comparison with ‘let/var’ as brough try Ilya is flawed — variable mutability concerns the basic design of the data structure/algorithm itself, while data hiding concerns the fragility of a data structure. I understand that the boundary between these two is very fluent, as one can portray fragility as design by encapsulating/hiding parts of the implementation. However, we are talking about actual implementations (e.g. variables, code etc. that the implementation use) rather then the abstract structure of implementations. <br></p><p>To sum it up: Swift already supports an elegant data hiding mechanism which IMO solves the biggest issue: components are already shielded agains incorrect EXTERNAL use. It remains prone to incorrect use in the same file. As far as I am concerned, the practical consequences of this are negligible. I have some experience with languages that do not have any data hiding whatsoever and I can’t say that I ever had any issues with messing up the private and public interfaces — neither in my own code nor in code written in collaboration with other people. In this regards  do not believe that ‘local’ will add anything of value to the language, however it will make the rules more complicated. <br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>I do not know. The problem of code safety is a fundamental one, but I am not sure that Swift has ever had the ambition to solve all of them. For me, the offered solution is good enough. <br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I have read the proposal, and participated in the original discussion. I can’t claim to have performed an in-depth study though. <br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/f74c6a09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 27, 2016 at 09:00:00pm</p></header><div class="content"><p>If the primary goal is to keep the language small, this would be a good<br>argument for removing &quot;private&quot;. But if the goal is clarity and<br>correctness, then &quot;scoped&quot; will help with both. There are many constructs<br>in the language already that are not strictly necessary and can be<br>expressed via other means. For example, anything that you can do with<br>&quot;guard&quot;, you can do with &quot;if&quot;. But they are there because they help clarity<br>and correctness. &quot;scoped&quot; is like that.<br></p><p>On Sat, Feb 27, 2016 at 3:00 PM Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; I am agains it. My rationale below.<br>&gt;<br>&gt; One of Ilya’s main points is that encapsulation is a core principle of OOP<br>&gt; and that Swift lacks tools to implement this properly. I think the<br>&gt; terminology is somehow unlucky here. Encapsulation more universally refers<br>&gt; to bundling of data and code that operates of that data, and this is indeed<br>&gt; one of the things that defines OOP as a programming style. However, it<br>&gt; seems that Ilya refers to data hiding, which often accompanies<br>&gt; encapsulation. I believe it is important to distinguish these two concepts.<br>&gt; Encapsulation as I use here is a particular problem-solving style while<br>&gt; data hiding (what Ilya stresses) is a technique for enforcing program<br>&gt; correctness. It is also not true that data hiding is a fundamental<br>&gt; component of OOP languages, some of the popular ones don’t have any data<br>&gt; hiding (e.g. Python).<br>&gt;<br>&gt; Data hiding obviously has an important core function, which is, as I<br>&gt; mentioned above — making sure that the program is correct, by only exposing<br>&gt; the interface other components should have safe access to. Swift has data<br>&gt; hiding, only the philosophy of that data hiding is a bit different from the<br>&gt; mainstream implementations. The scope of the most restricted access is the<br>&gt; file. If I understand the background of this design decision correctly,<br>&gt; goal here is to allow the programmer to be as flexible as possible about<br>&gt; what can access what but also to ‘force&#39; them to think about their code<br>&gt; design and code layout (by organising interrelated stuff by files). Is this<br>&gt; an ideal decision to the problem? Certainly not — it imposes some<br>&gt; inconveniences on the programmer and can also compromise code safety (as<br>&gt; Illya points out). Is this a good, elegant decision? In my opinion, yes.<br>&gt;<br>&gt; I can also understand Illya’s point that a local scope access might<br>&gt; improve code safety in certain cases. What I disagree with is that these<br>&gt; cases are prominent or problematic enough to deserve such attention. Adding<br>&gt; new access modifiers makes the rules of the language more complicated, but<br>&gt; I seriously doubt that a ‘local’ specifier will make programmers<br>&gt; significantly more productive or prevent any number of serious bugs. So<br>&gt; far, arguments presented were more of the ideological nature and while they<br>&gt; are formally correct, I do not think that the actual end effect is as<br>&gt; dramatic as described. In addition, I would like to point out that ‘local’<br>&gt; is also only an approximation — it does not solve the safety problem<br>&gt; entirely. It merely functions as an additional safeguard agains programmer<br>&gt; error. The actual problem can be only solved by specifying full rules what<br>&gt; is accessible from where and under which conditions. A system like that<br>&gt; probably won’t be practical enough for everyday programming at this point.<br>&gt;<br>&gt; I also think that the comparison with ‘let/var’ as brough try Ilya is<br>&gt; flawed — variable mutability concerns the basic design of the data<br>&gt; structure/algorithm itself, while data hiding concerns the fragility of a<br>&gt; data structure. I understand that the boundary between these two is very<br>&gt; fluent, as one can portray fragility as design by encapsulating/hiding<br>&gt; parts of the implementation. However, we are talking about actual<br>&gt; implementations (e.g. variables, code etc. that the implementation use)<br>&gt; rather then the abstract structure of implementations.<br>&gt;<br>&gt; To sum it up: Swift already supports an elegant data hiding mechanism<br>&gt; which IMO solves the biggest issue: components are already shielded agains<br>&gt; incorrect EXTERNAL use. It remains prone to incorrect use in the same file.<br>&gt; As far as I am concerned, the practical consequences of this are<br>&gt; negligible. I have some experience with languages that do not have any data<br>&gt; hiding whatsoever and I can’t say that I ever had any issues with messing<br>&gt; up the private and public interfaces — neither in my own code nor in code<br>&gt; written in collaboration with other people. In this regards  do not believe<br>&gt; that ‘local’ will add anything of value to the language, however it will<br>&gt; make the rules more complicated.<br>&gt;<br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I do not know. The problem of code safety is a fundamental one, but I am<br>&gt; not sure that Swift has ever had the ambition to solve all of them. For me,<br>&gt; the offered solution is good enough.<br>&gt;<br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; I have read the proposal, and participated in the original discussion. I<br>&gt; can’t claim to have performed an in-depth study though.<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/9bf06b56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 9:37 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If the primary goal is to keep the language small, this would be a good argument for removing &quot;private&quot;. But if the goal is clarity and correctness, then &quot;scoped&quot; will help with both.<br>&gt; <br>&gt; There are many constructs in the language already that are not strictly necessary and can be expressed via other means. For example, anything that you can do with &quot;guard&quot;, you can do with &quot;if&quot;. But they are there because they help clarity and correctness. &quot;scoped&quot; is like that.<br></p><p>I&#39;ve drifted to mild support for this proposal but I want to pick up the point of language size.<br></p><p> While not the &quot;primary goal&quot; a small language is still an important goal. The bigger the language the more there is for beginners to learn and the more things that you need to understand while reading code. There is also the chance if the language gets too big that people start using different subsets.  C++ is to me the canonical example of the language that is too big and complicated for its own good.<br></p><p>This doesn&#39;t mean that nothing should be added to Swift just that everything needs to pull its weight, whether by making things possible that aren&#39;t otherwise or by sufficiently improving clarity and correctness or some other real improvement especially in common use cases. I appreciate that the bar for inclusion is kept high and that some things are even being removed through the evolution process.<br></p><p>Joseph<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 28, 2016 at 12:00:00am</p></header><div class="content"><p>That&#39;s a good point. To me, &quot;scoped&quot; is like &quot;guard&quot; in this sense.<br></p><p>On Sat, Feb 27, 2016 at 6:28 PM Joseph Lord &lt;joseph at human-friendly.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Feb 27, 2016, at 9:37 PM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; If the primary goal is to keep the language small, this would be a good<br>&gt; argument for removing &quot;private&quot;. But if the goal is clarity and<br>&gt; correctness, then &quot;scoped&quot; will help with both.<br>&gt; &gt;<br>&gt; &gt; There are many constructs in the language already that are not strictly<br>&gt; necessary and can be expressed via other means. For example, anything that<br>&gt; you can do with &quot;guard&quot;, you can do with &quot;if&quot;. But they are there because<br>&gt; they help clarity and correctness. &quot;scoped&quot; is like that.<br>&gt;<br>&gt; I&#39;ve drifted to mild support for this proposal but I want to pick up the<br>&gt; point of language size.<br>&gt;<br>&gt;  While not the &quot;primary goal&quot; a small language is still an important goal.<br>&gt; The bigger the language the more there is for beginners to learn and the<br>&gt; more things that you need to understand while reading code. There is also<br>&gt; the chance if the language gets too big that people start using different<br>&gt; subsets.  C++ is to me the canonical example of the language that is too<br>&gt; big and complicated for its own good.<br>&gt;<br>&gt; This doesn&#39;t mean that nothing should be added to Swift just that<br>&gt; everything needs to pull its weight, whether by making things possible that<br>&gt; aren&#39;t otherwise or by sufficiently improving clarity and correctness or<br>&gt; some other real improvement especially in common use cases. I appreciate<br>&gt; that the bar for inclusion is kept high and that some things are even being<br>&gt; removed through the evolution process.<br>&gt;<br>&gt; Joseph<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/a993c6a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February 27, 2016 at 09:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>-1<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>In my experience, it is not.<br></p><p>How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>I&#39;ve read the proposal and been following the surrounding discussions.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 26 Feb 2016, at 20:05, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/8d127835/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>This proposal definitely fills a gap in the access control scheme currently supported by Swift. It seems somewhat unfortunate that &quot;private&quot; refers to the the level of access control limiting the scope to the source file, as it seems this keyword would be better associated with the scope of access described in this proposal. I&#39;d personally like to see &quot;private&quot; reassigned to the lexical scope and come up with a new keyword to describe the source file scope (e.g., maybe &quot;file&quot;). However, this would increase impact of the change.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>For framework developers, the problem is significant. I&#39;m sure application developers may have a difficult time considering this a problem.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes, I think this is fits well with the direction of Swift. I have seen some people raise the question of the proposal adding undue complexity to the language. However, I disagree with this, as the proposal adds a single keyword associated with a new scope of access control.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Many object-oriented languages support access control to members of entities. Apple went further by adding a scope of access for Swift&#39;s notion of a &quot;module&quot;, which I have never seen any language provide. In doing so, I think they overlooked the need for the a level of access control typically described by &quot;private&quot;. Or, Apple envisioned the one entity to a source file, like Java.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>In-depth study.<br></p><p>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/22d6b824/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt; What is your evaluation of the proposal?<br>+1.  I believe I was the first person to suggest this as a direction for refining the access control feature.  It fits naturally with the existing access control features, allows more refined expression of intent, and adds minimal incremental complexity to the language.<br></p><p>Differentiating between the intention of ‘local’ and ‘private’ access control is IMO a big win.  When reading code that declares a member ‘local’, I immediately know I only need to consider how other code in the containing scope uses that member.  I do not need to consider whether the member is used by other code in the same file.  The increase in clarity and readability is significant.<br></p><p>During the discussion I looked through the code for the (at that time) current release of Alamofire to see how ‘private’ members are actually used.  As it turns out, every use of `private` in that library could actually use `local` instead if it existed, with a corresponding increase in clarity and readability for anyone new to the code.<br></p><p>In some cases ‘private’ and ‘local’ would be equivalent because there is only one type / scope in the file anyway.  However, in most cases for Alamofire they actually do communicate something different.  There are a few ways this is possible:<br></p><p>In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br></p><p>In other cases, there are extensions of other types.  These extensions add methods that are closely related to the primary type / extension involved in the file.  The private members of the primary type should not be visible to the related extensions.<br></p><p>One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br></p><p>None of these cases would be covered by various alternatives (related to concurrency, etc) that have been discussed in the review thread.  Scoped access control stands on its on as a small but valuable addition to the language in addition to providing better short-term options for some of the cases discussed in the review until more complete and direct solutions are added to the language.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes.  The approach is a very natural extension of the existing access control mechanism.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>This is closer to the notion of ‘private’ than Swift’s existing ‘private’ access level.  Swift’s ‘private’ solves the ‘friend’ problem much more elegantly than ‘friend’ but it leaves an expressivity gap where members are sometimes much more broadly visible within a file than is necessary.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I participated heavily in the discussion leading up to this proposal, including analysis of existing code for places where this feature would be valuable.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/d425a3f5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 28, 2016 at 07:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>-1<br></p><p>I admit I was surprised by the semantics of private in Swift when I first discovered it, because I was used to private in other languages corresponding to Scoped Access Level. But I’ve not been overly bothered by it, and I’ve always kept a fairly strict one class per file anyway. I also don’t like that the proposal adds another keyword/layer of scoping. If people really wanted Scoped Access Level, I would have suggested modifying the meaning of private to correspond to Scoped Access Level and not add another keyword like this proposal.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I’d say no.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don’t find it worthwhile enough to warrant adding another scoping level and confusing newcomers.<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, all the other languages I have used have had Scoped Access Level, but I don’t mind Swift’s current file access level.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A thorough read.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/6a233516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I admit I was surprised by the semantics of private in Swift when I first<br>discovered it,<br></p><p>And so will be most of newcomers.<br></p><p>&gt; But I’ve not been overly bothered by it, and I’ve always kept a fairly<br>strict one class per file &gt; anyway.<br></p><p>It is still useful to have &quot;scoped&quot; in one class per file structure. If the<br>code is organized in a way where internal state is hidden in one scope and<br>other functions that don&#39;t require access to the internal state are added<br>via extensions, &quot;scoped&quot; can hide the internal state from extensions and<br>also hide implementation details of each extension from other extensions in<br>the same file.<br></p><p>&gt; I also don’t like that the proposal adds another keyword/layer of scoping.<br></p><p>Today, there is no other way to express what &quot;scoped&quot; does except<br>by putting each scope into a separate file. This is very restricting and<br>makes it more difficult to put related code in the same file (you lose any<br>the help that the compiler could give you with protecting against using<br>private APIs).<br></p><p>&gt; If people really wanted Scoped Access Level, I would have suggested<br>modifying the meaning &gt; of private to correspond to Scoped Access Level and<br>not add another keyword like this &gt; proposal.<br></p><p>&quot;private&quot; as it is today serves an important purpose of allowing access to<br>internal state of related classes. It solves the same problem as &quot;friend&quot;<br>in C++. &quot;scoped&quot; is necessary to hide implementation details completely,<br>regardless of where the code is.<br></p><p>&gt; I don’t find it worthwhile enough to warrant adding another scoping level<br>and confusing &gt; newcomers.<br></p><p>You acknowledge that the meaning of &quot;private&quot; is already confusing to<br>newcomers from other languages. Having &quot;scoped&quot; would only reduce the<br>confusion by providing what newcomers are likely already used to. If we<br>could rename &quot;private&quot; to something else that clearly means &quot;file level<br>access&quot;, there would be no confusion at all. Newcomers would just map<br>&quot;private&quot; that they are used to in other languages to &quot;scoped&quot; in Swift.<br></p><p>&gt; Yes, all the other languages I have used have had Scoped Access Level,<br>but I don’t mind &gt; Swift’s current file access level.<br></p><p>Neither do I. I think it&#39;s great to have a file based access level. It<br>might be better than &quot;friend&quot; in C++. &quot;scoped&quot; provides the functionality<br>similar to &quot;private&quot; in C++ and is valuable because it would provide<br>clarity of intent that can be enforced by the compiler and help ensure code<br>correctness.<br></p><p><br>On Sun, Feb 28, 2016 at 2:08 PM David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *What is your evaluation of the proposal?*<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; I admit I was surprised by the semantics of private in Swift when I first<br>&gt; discovered it, because I was used to private in other languages<br>&gt; corresponding to Scoped Access Level. But I’ve not been overly bothered by<br>&gt; it, and I’ve always kept a fairly strict one class per file anyway. I also<br>&gt; don’t like that the proposal adds another keyword/layer of scoping. If<br>&gt; people really wanted Scoped Access Level, I would have suggested modifying<br>&gt; the meaning of private to correspond to Scoped Access Level and not add<br>&gt; another keyword like this proposal.<br>&gt;<br>&gt; *Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?*<br>&gt;<br>&gt; I’d say no.<br>&gt;<br>&gt; *Does this proposal fit well with the feel and direction of Swift?*<br>&gt;<br>&gt; I don’t find it worthwhile enough to warrant adding another scoping level<br>&gt; and confusing newcomers.<br>&gt;<br>&gt; *If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?*<br>&gt;<br>&gt; Yes, all the other languages I have used have had Scoped Access Level, but<br>&gt; I don’t mind Swift’s current file access level.<br>&gt;<br>&gt; *How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?*<br>&gt;<br>&gt; A thorough read.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/f6558dae/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>February 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; I am very in favor of an access control modifier with the effect described<br>in the proposal. The proposal addresses a shortcoming of the Swift language<br>which I have felt acutely many times. I am not particularly attached to the<br>specific word “local” as the modifier.<br></p><p><br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yes.<br></p><p><br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes. It conveys an important intent to the compiler for enforcement with<br>minimal impact to the style and structure of the language.<br></p><p>There are other features that I hope to someday see in Swift that would<br>sometimes replace the need for this (e.g. nested modules). Even so, I think<br>there will always be cases where this level of access control conveys<br>useful information.<br></p><p><br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Of the languages I&#39;ve used heavily, C++, Java, and Scala have a similar<br>level of access control. Scala has the finest granularity of access control<br>amongst the languages I&#39;ve used. Scala has more access control granularity<br>than I&#39;ve ever needed, but Swift has less than I&#39;ve wanted. This proposal<br>improves Swift without going overboard.<br></p><p><br>&gt;<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; I read the proposal carefully. I also followed the original discussion<br>closely and participated in it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/f2b55036/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br></p><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>I don&#39;t think it&#39;s a good idea.<br></p><p>I think the source of our disagreement is expressed in this paragraph from the proposal:<br></p><p>&gt; It forces a one class per file structure, which is very limiting. Putting related APIs and/or related implementations in the same file helps ensure consistency and reduces the time to find a particular API or implementation. This does not mean that the classes in the same file need to share otherwise hidden APIs, but there is no way to express it with the current access levels.<br></p><p>This reflects a view that grouping APIs into files is a purely stylistic choice. You can move APIs around freely and organize them however you like. If Swift gets in the way of your preferred arrangement, Swift should be changed to allow it. The most important thing is that you be free to express yourself artistically through the medium of the file system.<br></p><p>I believe that view is mistaken. Swift has a very opinionated view of how code should be organized into files; they are as semantically meaningful as declaration blocks.<br></p><p>The purpose of a file is to implement one concern—essentially, one logical piece of the module&#39;s functionality with its own self-contained implementation details. A concern is not necessarily fully represented by a single type; a type may include several concerns, and several types may implement one concern. (It&#39;s not a coincidence that a file can contain several types and a type can be split across several files.) The precise boundaries of a concern are a little nebulous, especially when you build convenience APIs which don&#39;t depend on anything private, but it&#39;s usually roughly clear what they are.<br></p><p>When you want to use `local`, that usually means you&#39;re not organizing your code the way Swift thinks you should. It&#39;s no wonder Swift seems to not be expressive enough: You&#39;re fighting the language.<br></p><p>Now, there are two exceptions to this general rule, but I think they&#39;re both best handled in other ways.<br></p><p>The first: Sometimes Swift will not allow you to move certain things to separate files; for instance, only one file can declare stored properties on a type, and so stored properties must either be made more visible than they should be, or several concerns must be mixed into a single file. I think this is best handled by allowing extensions to declare stored properties and other such one-file-only constructs, rather than by complicating access control.<br></p><p>The second: Sometimes a particular concern has an especially complicated, self-contained &quot;sub-concern&quot; which has implementation details of its own. You would like to keep the sub-concerns implementation details private from the containing concern, but the sub-concern is *itself* an implementation detail of the containing concern, so you *also* want to keep the sub-concern private from other, unrelated concerns. In these cases, some sort of more nuanced access control would be better—but even then, I don&#39;t think `local` is actually a very good way to do it.<br></p><p>There&#39;s nothing about a declaration block that makes it a natural choice for scoping declarations. `local` hides the declaration from containing and sibling declaration blocks and exposes it to nested declaration blocks. But if concerns often transcend type boundaries, surely sub-concerns do as well, so `local` will often be either too limiting or not limiting enough.<br></p><p>To properly handle this problem, we would be better off coming up with some way to limit the scope of `internal` to only particular files which need to interface with that file&#39;s concern. `internal` would expose the API to your file&#39;s &quot;clients&quot;—by default all files in the module, but potentially narrowed down to a particular subset—while `private` would remain as something truly limited to a single file.<br></p><p>However, that approach is rather complicated, bordering on the horror of C++ `friend` declarations. Ultimately, I just don&#39;t think it&#39;s too large of a burden to say, &quot;You have a three-level namespace, and anything that crosses files goes into `internal`; if something in `internal` is only meant to be used in a particular file, show some discipline.&quot;<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>As I often say, the problem is arguably significant enough, but I don&#39;t think the solution is the right one.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don&#39;t think so. Swift has strong, opinionated ideas about how code should be organized; this proposal doesn&#39;t follow that pattern.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve used languages with file-based scoping, and languages with arbitrary lexical scoping, but not languages with both.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In addition to reading the present proposal, I also participated fairly extensively in discussions about it and read previously-posted reviews.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>February 29, 2016 at 11:00:00pm</p></header><div class="content"><p>+1<br></p><p>*Fortifies extension-based approach*<br>The change fits well with Swift&#39;s style of splitting types&#39; subsystems and<br>protocol conformances into their own extensions. This modularity is an<br>important tool in managing complexity and assuring quality/safety (key<br>Swift values), and the language should encourage this pattern. It&#39;ll become<br>only more relevant if extensions within the same module will in the future<br>be allowed to add stored properties, a change which would fit very well<br>with this one.<br></p><p>*Why not file split &amp; use private*<br>Splitting each extension into a separate file is impractical because if<br>properly done, the size of the individual extensions is usually quite small.<br></p><p>*Self-documents extension API*<br>It makes API per extension more self-documenting – it immediately tells you<br>what the extension exposes to the rest of the file and what is an<br>implementation detail.<br></p><p>On Mon, Feb 29, 2016 at 9:45 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; &gt;       • What is your evaluation of the proposal?<br>&gt;<br>&gt; I don&#39;t think it&#39;s a good idea.<br>&gt;<br>&gt; I think the source of our disagreement is expressed in this paragraph from<br>&gt; the proposal:<br>&gt;<br>&gt; &gt; It forces a one class per file structure, which is very limiting.<br>&gt; Putting related APIs and/or related implementations in the same file helps<br>&gt; ensure consistency and reduces the time to find a particular API or<br>&gt; implementation. This does not mean that the classes in the same file need<br>&gt; to share otherwise hidden APIs, but there is no way to express it with the<br>&gt; current access levels.<br>&gt;<br>&gt; This reflects a view that grouping APIs into files is a purely stylistic<br>&gt; choice. You can move APIs around freely and organize them however you like.<br>&gt; If Swift gets in the way of your preferred arrangement, Swift should be<br>&gt; changed to allow it. The most important thing is that you be free to<br>&gt; express yourself artistically through the medium of the file system.<br>&gt;<br>&gt; I believe that view is mistaken. Swift has a very opinionated view of how<br>&gt; code should be organized into files; they are as semantically meaningful as<br>&gt; declaration blocks.<br>&gt;<br>&gt; The purpose of a file is to implement one concern—essentially, one logical<br>&gt; piece of the module&#39;s functionality with its own self-contained<br>&gt; implementation details. A concern is not necessarily fully represented by a<br>&gt; single type; a type may include several concerns, and several types may<br>&gt; implement one concern. (It&#39;s not a coincidence that a file can contain<br>&gt; several types and a type can be split across several files.) The precise<br>&gt; boundaries of a concern are a little nebulous, especially when you build<br>&gt; convenience APIs which don&#39;t depend on anything private, but it&#39;s usually<br>&gt; roughly clear what they are.<br>&gt;<br>&gt; When you want to use `local`, that usually means you&#39;re not organizing<br>&gt; your code the way Swift thinks you should. It&#39;s no wonder Swift seems to<br>&gt; not be expressive enough: You&#39;re fighting the language.<br>&gt;<br>&gt; Now, there are two exceptions to this general rule, but I think they&#39;re<br>&gt; both best handled in other ways.<br>&gt;<br>&gt; The first: Sometimes Swift will not allow you to move certain things to<br>&gt; separate files; for instance, only one file can declare stored properties<br>&gt; on a type, and so stored properties must either be made more visible than<br>&gt; they should be, or several concerns must be mixed into a single file. I<br>&gt; think this is best handled by allowing extensions to declare stored<br>&gt; properties and other such one-file-only constructs, rather than by<br>&gt; complicating access control.<br>&gt;<br>&gt; The second: Sometimes a particular concern has an especially complicated,<br>&gt; self-contained &quot;sub-concern&quot; which has implementation details of its own.<br>&gt; You would like to keep the sub-concerns implementation details private from<br>&gt; the containing concern, but the sub-concern is *itself* an implementation<br>&gt; detail of the containing concern, so you *also* want to keep the<br>&gt; sub-concern private from other, unrelated concerns. In these cases, some<br>&gt; sort of more nuanced access control would be better—but even then, I don&#39;t<br>&gt; think `local` is actually a very good way to do it.<br>&gt;<br>&gt; There&#39;s nothing about a declaration block that makes it a natural choice<br>&gt; for scoping declarations. `local` hides the declaration from containing and<br>&gt; sibling declaration blocks and exposes it to nested declaration blocks. But<br>&gt; if concerns often transcend type boundaries, surely sub-concerns do as<br>&gt; well, so `local` will often be either too limiting or not limiting enough.<br>&gt;<br>&gt; To properly handle this problem, we would be better off coming up with<br>&gt; some way to limit the scope of `internal` to only particular files which<br>&gt; need to interface with that file&#39;s concern. `internal` would expose the API<br>&gt; to your file&#39;s &quot;clients&quot;—by default all files in the module, but<br>&gt; potentially narrowed down to a particular subset—while `private` would<br>&gt; remain as something truly limited to a single file.<br>&gt;<br>&gt; However, that approach is rather complicated, bordering on the horror of<br>&gt; C++ `friend` declarations. Ultimately, I just don&#39;t think it&#39;s too large of<br>&gt; a burden to say, &quot;You have a three-level namespace, and anything that<br>&gt; crosses files goes into `internal`; if something in `internal` is only<br>&gt; meant to be used in a particular file, show some discipline.&quot;<br>&gt;<br>&gt; &gt;       • Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; As I often say, the problem is arguably significant enough, but I don&#39;t<br>&gt; think the solution is the right one.<br>&gt;<br>&gt; &gt;       • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I don&#39;t think so. Swift has strong, opinionated ideas about how code<br>&gt; should be organized; this proposal doesn&#39;t follow that pattern.<br>&gt;<br>&gt; &gt;       • If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I&#39;ve used languages with file-based scoping, and languages with arbitrary<br>&gt; lexical scoping, but not languages with both.<br>&gt;<br>&gt; &gt;       • How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; In addition to reading the present proposal, I also participated fairly<br>&gt; extensively in discussions about it and read previously-posted reviews.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/c12a390b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  1, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I believe that view is mistaken. Swift has a very opinionated view of how<br>code should be organized into files;<br></p><p>If that is true, Swift should enforce it. Right now it doesn&#39;t, so this is<br>open to interpretation.<br></p><p>&gt; they are as semantically meaningful as declaration blocks.<br></p><p>Agreed. Which is why some people may want to group related code into the<br>same file but still want to hide implementation details at the scope level.<br></p><p>&gt; The purpose of a file is to implement one concern—essentially, one<br>logical piece of the module&#39;s functionality with its own self-contained<br>implementation details. A concern is not necessarily fully represented by a<br>single type; a type may include several concerns, and several types may<br>implement one concern. (It&#39;s not a coincidence that a file can contain<br>several types and a type can be split across several files.) The precise<br>boundaries of a concern are a little nebulous, especially when you build<br>convenience APIs which don&#39;t depend on anything private, but it&#39;s usually<br>roughly clear what they are.<br></p><p>&quot;concern&quot; is a very vague term. Implementation details of a type and hiding<br>of its internal state and internal helper functions is much more concrete.<br>The model that you describe is very good about sharing implementation<br>details of several classes and hiding them as a whole. It&#39;s a good<br>alternative to C++ &quot;friend&quot;. However, this model doesn&#39;t work well for<br>hiding implementation details and protecting invariants of a single type.<br>Most types and their extensions are small, and creating files for every<br>single one of them only to hide implementation details is very impractical.<br>For example, most people just put all extensions of one type in one file<br>for convenience. Carefully separating every scope and protecting its<br>implementation details in a separate file is very tedious. It&#39;s like<br>putting every paragraph of a chapter in a separate file. I haven&#39;t seen<br>anyone do it. Instead, people just forgo access control altogether or, at<br>best, provide much more access than they really mean to.<br></p><p>&gt; When you want to use `local`, that usually means you&#39;re not organizing<br>your code the way Swift thinks you should. It&#39;s no wonder Swift seems to<br>not be expressive enough: You&#39;re fighting the language.<br></p><p>Or maybe the language is fighting me :–) If this was C, and the issue was<br>to protect internal global variables, this reasoning would be true. But<br>with types, most of the time, invariants and internal state exist at the<br>type level, and right now there is no direct way of protecting them. Using<br>files for this purpose is very indirect, and the meaning is open to<br>interpretation. For example, another review compares access levels with<br>exports. Semantically they are not the same, even if the end result is<br>hidden APIs. Scoped level access is very clear, direct, and natural for<br>anyone new to the language and expresses a very important concept.<br></p><p>&gt; The first: Sometimes Swift will not allow you to move certain things to<br>separate files; for instance, only one file can declare stored properties<br>on a type, and so stored properties must either be made more visible than<br>they should be, or several concerns must be mixed into a single file. I<br>think this is best handled by allowing extensions to declare stored<br>properties and other such one-file-only constructs, rather than by<br>complicating access control.<br></p><p>I think that stored properties in extensions would be a great addition to<br>the language, but it has nothing to do with access level. If / when Swift<br>gains this feature, hiding these stored properties in the scope of the<br>extension would be just as important as it is now for stored properties.<br>Exactly the same logic applies to extensions.<br></p><p>&gt; The second: Sometimes a particular concern has an especially complicated,<br>self-contained &quot;sub-concern&quot; which has implementation details of its own.<br>You would like to keep the sub-concerns implementation details private from<br>the containing concern, but the sub-concern is *itself* an implementation<br>detail of the containing concern, so you *also* want to keep the<br>sub-concern private from other, unrelated concerns. In these cases, some<br>sort of more nuanced access control would be better—but even then, I don&#39;t<br>think `local` is actually a very good way to do it.<br></p><p>I am surprised by this -- it&#39;s exactly the kind of problem that &quot;scoped&quot;<br>solves, and very directly. Why wouldn&#39;t it be a good way to do it?<br></p><p>&gt; There&#39;s nothing about a declaration block that makes it a natural choice<br>for scoping declarations. `local` hides the declaration from containing and<br>sibling declaration blocks and exposes it to nested declaration blocks. But<br>if concerns often transcend type boundaries, surely sub-concerns do as<br>well, so `local` will often be either too limiting or not limiting enough.<br></p><p>&quot;concern&quot; is a very vague term, but I think that most of the time,<br>&quot;concern&quot; spans one type -- it protects internal state and internal APIs<br>that may manipulate that state in an unsafe way or make some assumptions<br>that are generally not true. &quot;scoped&quot; provides a very clear expression of<br>intent for this very common case. Most of the time, &quot;friend&quot; in C++ is not<br>needed. Similarly, most of the time, &quot;private&quot; could be replaced by<br>&quot;scoped&quot;. Internal APIs that span several types are exceptions, not the<br>rule.<br></p><p>&gt;       • Does this proposal fit well with the feel and direction of Swift?<br></p><p>&gt; I don&#39;t think so. Swift has strong, opinionated ideas about how code<br>should be organized; this proposal doesn&#39;t follow that pattern.<br></p><p>It actually does:<br>public -- visible outside of module<br>internal -- visible in all files<br>private -- visible in one file<br>scoped -- visible in part of a file<br>for the sake of the argument, we could add<br>micro -- visible on one line<br></p><p>On Mon, Feb 29, 2016 at 5:45 AM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; &gt;       • What is your evaluation of the proposal?<br>&gt;<br>&gt; I don&#39;t think it&#39;s a good idea.<br>&gt;<br>&gt; I think the source of our disagreement is expressed in this paragraph from<br>&gt; the proposal:<br>&gt;<br>&gt; &gt; It forces a one class per file structure, which is very limiting.<br>&gt; Putting related APIs and/or related implementations in the same file helps<br>&gt; ensure consistency and reduces the time to find a particular API or<br>&gt; implementation. This does not mean that the classes in the same file need<br>&gt; to share otherwise hidden APIs, but there is no way to express it with the<br>&gt; current access levels.<br>&gt;<br>&gt; This reflects a view that grouping APIs into files is a purely stylistic<br>&gt; choice. You can move APIs around freely and organize them however you like.<br>&gt; If Swift gets in the way of your preferred arrangement, Swift should be<br>&gt; changed to allow it. The most important thing is that you be free to<br>&gt; express yourself artistically through the medium of the file system.<br>&gt;<br>&gt; I believe that view is mistaken. Swift has a very opinionated view of how<br>&gt; code should be organized into files; they are as semantically meaningful as<br>&gt; declaration blocks.<br>&gt;<br>&gt; The purpose of a file is to implement one concern—essentially, one logical<br>&gt; piece of the module&#39;s functionality with its own self-contained<br>&gt; implementation details. A concern is not necessarily fully represented by a<br>&gt; single type; a type may include several concerns, and several types may<br>&gt; implement one concern. (It&#39;s not a coincidence that a file can contain<br>&gt; several types and a type can be split across several files.) The precise<br>&gt; boundaries of a concern are a little nebulous, especially when you build<br>&gt; convenience APIs which don&#39;t depend on anything private, but it&#39;s usually<br>&gt; roughly clear what they are.<br>&gt;<br>&gt; When you want to use `local`, that usually means you&#39;re not organizing<br>&gt; your code the way Swift thinks you should. It&#39;s no wonder Swift seems to<br>&gt; not be expressive enough: You&#39;re fighting the language.<br>&gt;<br>&gt; Now, there are two exceptions to this general rule, but I think they&#39;re<br>&gt; both best handled in other ways.<br>&gt;<br>&gt; The first: Sometimes Swift will not allow you to move certain things to<br>&gt; separate files; for instance, only one file can declare stored properties<br>&gt; on a type, and so stored properties must either be made more visible than<br>&gt; they should be, or several concerns must be mixed into a single file. I<br>&gt; think this is best handled by allowing extensions to declare stored<br>&gt; properties and other such one-file-only constructs, rather than by<br>&gt; complicating access control.<br>&gt;<br>&gt; The second: Sometimes a particular concern has an especially complicated,<br>&gt; self-contained &quot;sub-concern&quot; which has implementation details of its own.<br>&gt; You would like to keep the sub-concerns implementation details private from<br>&gt; the containing concern, but the sub-concern is *itself* an implementation<br>&gt; detail of the containing concern, so you *also* want to keep the<br>&gt; sub-concern private from other, unrelated concerns. In these cases, some<br>&gt; sort of more nuanced access control would be better—but even then, I don&#39;t<br>&gt; think `local` is actually a very good way to do it.<br>&gt;<br>&gt; There&#39;s nothing about a declaration block that makes it a natural choice<br>&gt; for scoping declarations. `local` hides the declaration from containing and<br>&gt; sibling declaration blocks and exposes it to nested declaration blocks. But<br>&gt; if concerns often transcend type boundaries, surely sub-concerns do as<br>&gt; well, so `local` will often be either too limiting or not limiting enough.<br>&gt;<br>&gt; To properly handle this problem, we would be better off coming up with<br>&gt; some way to limit the scope of `internal` to only particular files which<br>&gt; need to interface with that file&#39;s concern. `internal` would expose the API<br>&gt; to your file&#39;s &quot;clients&quot;—by default all files in the module, but<br>&gt; potentially narrowed down to a particular subset—while `private` would<br>&gt; remain as something truly limited to a single file.<br>&gt;<br>&gt; However, that approach is rather complicated, bordering on the horror of<br>&gt; C++ `friend` declarations. Ultimately, I just don&#39;t think it&#39;s too large of<br>&gt; a burden to say, &quot;You have a three-level namespace, and anything that<br>&gt; crosses files goes into `internal`; if something in `internal` is only<br>&gt; meant to be used in a particular file, show some discipline.&quot;<br>&gt;<br>&gt; &gt;       • Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; As I often say, the problem is arguably significant enough, but I don&#39;t<br>&gt; think the solution is the right one.<br>&gt;<br>&gt; &gt;       • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I don&#39;t think so. Swift has strong, opinionated ideas about how code<br>&gt; should be organized; this proposal doesn&#39;t follow that pattern.<br>&gt;<br>&gt; &gt;       • If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I&#39;ve used languages with file-based scoping, and languages with arbitrary<br>&gt; lexical scoping, but not languages with both.<br>&gt;<br>&gt; &gt;       • How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; In addition to reading the present proposal, I also participated fairly<br>&gt; extensively in discussions about it and read previously-posted reviews.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/ef39fa35/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 29, 2016 at 09:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>-1. I disagree with the starting motivation points, so it&#39;s hard to really see the value in the rest of the arguments.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. Swift&#39;s access modifier control is about code unit access levels. This proposal breaks this conceptual model. Now instead of thinking of publicly exposed APIs, APIs using only within the context of the module, and APIs local to the file, I now need to parse semantic scopes to understand where a piece of code can be used.<br></p><p>Basically Swift&#39;s model is:<br>  - public exports<br>  - internal exports<br>  - no exports<br></p><p>This proposal doesn&#39;t fit anywhere in that model.<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, this basically what private is other languages. However, traditionally &quot;private scope&quot; implementations have severe weaknesses in the ability to expose the implementation details only to helper code within the same file. Creating local re-invents part of that. <br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve read the review and followed much of the conversation, including participating in the previous thread on this topic.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/e97f0008/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  1, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; Swift&#39;s access modifier control is about code unit access levels. This<br>proposal breaks this conceptual model. Now instead of thinking of publicly<br>exposed APIs, APIs using only within the context of the module, and APIs<br>local to the file, I now need to parse semantic scopes to understand where<br>a piece of code can be used.<br></p><p>&gt; Basically Swift&#39;s model is:<br>  - public exports<br>  - internal exports<br>  - no exports<br></p><p>&gt; This proposal doesn&#39;t fit anywhere in that model.<br></p><p>This is one interoperation. Here is another that makes it fit perfectly<br>well:<br></p><p>- public: exports symbol to all files<br>- internal: exports symbol to module files<br>- private: exports symbol to one file containing the scope<br>- scoped: no export<br></p><p>&gt; Yes, this basically what private is other languages. However,<br>traditionally &quot;private scope&quot; implementations have severe weaknesses in the<br>ability to expose the implementation details only to helper code within the<br>same file. Creating local re-invents part of that.<br></p><p>Yes, and &quot;private&quot; is great for that. We can have both. They serve<br>different purposes.<br></p><p>On Mon, Feb 29, 2016 at 12:31 PM David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; *What is your evaluation of the proposal?*<br>&gt;<br>&gt; -1. I disagree with the starting motivation points, so it&#39;s hard to really<br>&gt; see the value in the rest of the arguments.<br>&gt;<br>&gt;<br>&gt; *Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?*<br>&gt;<br>&gt; No.<br>&gt;<br>&gt;<br>&gt; *Does this proposal fit well with the feel and direction of Swift?*<br>&gt;<br>&gt; No. Swift&#39;s access modifier control is about code unit access levels. This<br>&gt; proposal breaks this conceptual model. Now instead of thinking of publicly<br>&gt; exposed APIs, APIs using only within the context of the module, and APIs<br>&gt; local to the file, I now need to parse semantic scopes to understand where<br>&gt; a piece of code can be used.<br>&gt;<br>&gt; Basically Swift&#39;s model is:<br>&gt;   - public exports<br>&gt;   - internal exports<br>&gt;   - no exports<br>&gt;<br>&gt; This proposal doesn&#39;t fit anywhere in that model.<br>&gt;<br>&gt;<br>&gt; *If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?*<br>&gt;<br>&gt; Yes, this basically what private is other languages. However,<br>&gt; traditionally &quot;private scope&quot; implementations have severe weaknesses in the<br>&gt; ability to expose the implementation details only to helper code within the<br>&gt; same file. Creating local re-invents part of that.<br>&gt;<br>&gt; *How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?*<br>&gt;<br>&gt; I&#39;ve read the review and followed much of the conversation, including<br>&gt; participating in the previous thread on this topic.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/321dc08c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 8:08 PM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This is one interoperation. Here is another that makes it fit perfectly well:<br>&gt; <br>&gt; - public: exports symbol to all files<br>&gt; - internal: exports symbol to module files<br>&gt; - private: exports symbol to one file containing the scope<br>&gt; - scoped: no export<br></p><p>I disagree. The conceptual model is file scoping.<br></p><p>`public` - available in any source file within the module and in external source files that link the module<br>`internal` - available in any source file within the module<br>`private` - available in its own source file<br></p><p>The addition of `local` adds a new conceptual model around access control: lexical scoping. This type of scoping also actively works against various Swift patterns that are fairly common: using extensions to implement protocol conformance.<br></p><p>struct TypeA {<br>    var a: String<br>}<br></p><p>extension TypeA : StringLiteralConvertible {<br>    init(stringLiteral value: String) {<br>        self.a = value<br>    }<br>    <br>    init(extendedGraphemeClusterLiteral value: String) {<br>        self.a = value<br>    }<br>    <br>    init(unicodeScalarLiteral value: String) {<br>        self.a = value<br>    }<br>}<br></p><p>When `a` on type `TypeA` is declared as `local`, this pattern is no longer possible. Thus I find the use cases for `local`, as presented in the proposal, extremely limited in real use cases. <br></p><p>Now, if the proposal was to have `local` be scoped to the type that defines it, thus allowing extensions access to it, then it becomes more interesting, and has many more applicable use cases while still allowing the use case defined in the proposal.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/2e8d0e7e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>Neutral. While I agree that scoped access levels can be useful in some cases, I don&#39;t see much long-term profits, especially when using a &quot;protocol conformance in an extension&quot; style:<br></p><p>struct Foo {<br>	private func doSomethingInternal()<br>}<br></p><p>extension Foo: Barable {<br>	func bar() {<br>		doSomethingInternal()<br>	}<br>}<br></p><p>The above would not be possible to achieve with scoped access levels.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I don&#39;t think so. File access level does the job well for me.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes and no. Yes, because it a<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, Ruby, PHP, C++. In those languages, there are no file access levels and so the scoped access levels are the only ones which allow to hide the implementation details from the outside world. In Swift, however, file access level allows us to do the same with additional bonus – we can use those `private` members in extensions.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 26.02.2016, o godz. 20:05:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/8521bfcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes and no. Yes, because it a<br></p><p>Sorry, I forgot to finish the sentence. 🙈<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p><br>Yes and no. Yes, because it could in some small percent increase the safety of our programs. No, because it would strip away the &quot;composability&quot; of our code. <br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Adrian Kashivskyy via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 04.03.2016, o godz. 10:09:<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; Neutral. While I agree that scoped access levels can be useful in some cases, I don&#39;t see much long-term profits, especially when using a &quot;protocol conformance in an extension&quot; style:<br>&gt; <br>&gt; struct Foo {<br>&gt; 	private func doSomethingInternal()<br>&gt; }<br>&gt; <br>&gt; extension Foo: Barable {<br>&gt; 	func bar() {<br>&gt; 		doSomethingInternal()<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; The above would not be possible to achieve with scoped access levels.<br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I don&#39;t think so. File access level does the job well for me.<br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes and no. Yes, because it a<br>&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Yes, Ruby, PHP, C++. In those languages, there are no file access levels and so the scoped access levels are the only ones which allow to hide the implementation details from the outside world. In Swift, however, file access level allows us to do the same with additional bonus – we can use those `private` members in extensions.<br>&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; <br>&gt; <br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomość napisana przez Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 26.02.2016, o godz. 20:05:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through March 3, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/b317e49a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  4, 2016 at 11:00:00am</p></header><div class="content"><p>The main argument against seems to be that using “scoped” doesn’t allow<br>putting more code in extensions inside the same file. And the reason to put<br>code into extensions is to group it in some meaningful way, the most common<br>being implementation of a protocol. I completely agree that this is a nice<br>feature, and I wouldn’t want to lose it myself. At the same time, I think<br>that the most important grouping is one that is based on whether something<br>needs access to internal state and can potentially break it. My reasoning:<br></p><p>- the compiler can help ensure correctness because it won’t let you use<br>unsafe APIs that could break invariants / internal state.<br></p><p>- changing the implementation is much easier because implementation details<br>are not scattered throughout the file and are isolated in one place (the<br>scope).<br></p><p>- the tools can (and should) hide the “scoped” elements from the outside<br>and make code completion for the rest of the code much more convenient<br></p><p>But the more general question is this: are you willing to give up on<br>compiler&#39;s help with code correctness for a little more code grouping<br>convenience? This same argument could be made about “private”. Let’s say<br>you have a very large file that you want to break into smaller files, and<br>the code uses “private” throughout the file. If you break it up, you have<br>to remove “private” and make it “internal” and lose the compiler’s’ help<br>with access control. If we go that route, only “public” vs “internal” makes<br>sense. And yet, “private” is there. As it is today, it’s a good alternative<br>to “friend” in C++, but it doesn’t address the problem that “scoped” solves.<br></p><p>On Fri, Mar 4, 2016 at 4:12 AM Adrian Kashivskyy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Yes and no. Yes, because it a<br>&gt;<br>&gt;<br>&gt; Sorry, I forgot to finish the sentence. 🙈<br>&gt;<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Yes and no. Yes, because it could in some small percent increase the<br>&gt; safety of our programs. No, because it would strip away the &quot;composability&quot;<br>&gt; of our code.<br>&gt;<br>&gt;<br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt;<br>&gt; Wiadomość napisana przez Adrian Kashivskyy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; w dniu 04.03.2016, o godz. 10:09:<br>&gt;<br>&gt;<br>&gt; What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt; Neutral. While I agree that scoped access levels can be useful in some<br>&gt; cases, I don&#39;t see much long-term profits, especially when using a<br>&gt; &quot;protocol conformance in an extension&quot; style:<br>&gt;<br>&gt; struct Foo {<br>&gt; private func doSomethingInternal()<br>&gt; }<br>&gt;<br>&gt; extension Foo: Barable {<br>&gt; func bar() {<br>&gt; doSomethingInternal()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; The above would not be possible to achieve with scoped access levels.<br>&gt;<br>&gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; I don&#39;t think so. File access level does the job well for me.<br>&gt;<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Yes and no. Yes, because it a<br>&gt;<br>&gt; If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt; Yes, Ruby, PHP, C++. In those languages, there are no file access levels<br>&gt; and so the scoped access levels are the only ones which allow to hide the<br>&gt; implementation details from the outside world. In Swift, however, file<br>&gt; access level allows us to do the same with additional bonus – we can use<br>&gt; those `private` members in extensions.<br>&gt;<br>&gt; How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt;<br>&gt; Wiadomość napisana przez Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; w dniu 26.02.2016, o godz. 20:05:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0025 “Scoped Access Level&quot; begins now and runs through<br>&gt; March 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/9442685d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a7105d5001b7547920b134e67d3bcd17?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Jim Kubicek</string> &lt;jkubicek at gmail.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>+1<br></p><p>This proposal addresses a pain point I encounter daily. Currently there is no (good) way to limit extension methods to use only within the containing extension. I think the added clarity of a compiler-enforced access to “local” extension methods will be a solid win. In addition, it’s possible for code completion to no longer suggest the inaccessible methods.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, especially because this change can largely be ignored by developers new to Swift and only brought into play when needed.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Certainly. “Local” feels like a natural extension of the existing access level keywords.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read the proposal and the commentary in this thread.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/b48fa5cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Currently there is no (good) way to limit extension methods to use only within the containing extension. I think the added clarity of a compiler-enforced access to “local” extension methods will be a solid win.<br></p><p>I&#39;m seeing a lot of people say &quot;I want to keep things private to a particular extension within a file&quot;. I&#39;m still not convinced if that&#39;s a worthy goal, but if it&#39;s what people want, I&#39;d like to suggest an alternate semantic: `scoped` limits visibility to a particular top-level declaration block and all of the blocks nested inside it. That is, `local` declarations in a nested block are visible to the blocks it&#39;s inside, up to but not including the file scope.<br></p><p>	class Foo {<br>		struct Bar {<br>			var parentFoo: Foo<br>		}<br>		var myBar: Bar<br>		<br>		// Here, neither of the implementationDetails is visible.<br>	}<br>	<br>	extension Foo {<br>		func doSomething() {<br>			myBar.implementationDetail1()<br>		}<br>		<br>		extension Bar {<br>			scoped func implementationDetail1() {<br>				parentFoo.implementationDetail2()<br>			}<br>		}<br>		<br>		scoped func implementationDetail2() {<br>			print(&quot;All this compiles!&quot;)<br>		}<br>	}<br>	<br>	extension Foo {<br>		// Here, neither of the implementationDetails is visible.<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; That is, `local` declarations in a nested block<br></p><p>Sorry, that should be `scoped`.<br></p><p>I also want to make clear that, although I like this definition of `scoped` better than the proposed one, I still don&#39;t think we should add either one to Swift. I think `private` is private enough.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  4, 2016 at 10:00:00pm</p></header><div class="content"><p>A very important property of the proposal is that anything declared<br>&quot;scoped&quot; is completely sealed inside its scope and cannot be accessed from<br>the outside. This means that the scope can be moved anywhere in the file<br>without the danger of introducing access to implementation details.<br></p><p>Allowing a containing scope to see &quot;scoped&quot; in its inner scope would mean<br>that someone could just wrap a scope in another scope to gain access to<br>implementation details without changing anything in the scope itself. The<br>whole point of the proposal is to protect against something like this and<br>make sure that implementation details remain hidden from anything outside<br>the scope.<br></p><p>On Fri, Mar 4, 2016 at 4:37 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Currently there is no (good) way to limit extension methods to use only<br>&gt; within the containing extension. I think the added clarity of a<br>&gt; compiler-enforced access to “local” extension methods will be a solid win.<br>&gt;<br>&gt; I&#39;m seeing a lot of people say &quot;I want to keep things private to a<br>&gt; particular extension within a file&quot;. I&#39;m still not convinced if that&#39;s a<br>&gt; worthy goal, but if it&#39;s what people want, I&#39;d like to suggest an alternate<br>&gt; semantic: `scoped` limits visibility to a particular top-level declaration<br>&gt; block and all of the blocks nested inside it. That is, `local` declarations<br>&gt; in a nested block are visible to the blocks it&#39;s inside, up to but not<br>&gt; including the file scope.<br>&gt;<br>&gt;         class Foo {<br>&gt;                 struct Bar {<br>&gt;                         var parentFoo: Foo<br>&gt;                 }<br>&gt;                 var myBar: Bar<br>&gt;<br>&gt;                 // Here, neither of the implementationDetails is visible.<br>&gt;         }<br>&gt;<br>&gt;         extension Foo {<br>&gt;                 func doSomething() {<br>&gt;                         myBar.implementationDetail1()<br>&gt;                 }<br>&gt;<br>&gt;                 extension Bar {<br>&gt;                         scoped func implementationDetail1() {<br>&gt;                                 parentFoo.implementationDetail2()<br>&gt;                         }<br>&gt;                 }<br>&gt;<br>&gt;                 scoped func implementationDetail2() {<br>&gt;                         print(&quot;All this compiles!&quot;)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         extension Foo {<br>&gt;                 // Here, neither of the implementationDetails is visible.<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/e2e1c793/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; A very important property of the proposal is that anything declared &quot;scoped&quot; is completely sealed inside its scope and cannot be accessed from the outside. This means that the scope can be moved anywhere in the file without the danger of introducing access to implementation details. <br>&gt; <br>&gt; Allowing a containing scope to see &quot;scoped&quot; in its inner scope would mean that someone could just wrap a scope in another scope to gain access to implementation details without changing anything in the scope itself. The whole point of the proposal is to protect against something like this and make sure that implementation details remain hidden from anything outside the scope.<br></p><p>Wrap it how? You can&#39;t introduce arbitrary scopes inside file scope; that is, this is already illegal*:<br></p><p>	do {<br>		extension SomeType {<br>			scoped func secret() { ... }<br>		}<br></p><p>		func intruder(some: SomeType) {<br>			some.secret()<br>		}<br>	}<br></p><p>Introducing a scope would require you to declare or extend a type. Thus, moving something into a containing scope in order to allow you to &quot;see&quot; into it would also, by necessity, move the type itself, forcing you to change any code that uses the type. It would be far easier for someone trying to get access to internal details to simply change `scoped` to `private`.<br></p><p>When considering the `scoped` proposal, you must remember that `scoped`&#39;s protections are paper-thin. You are already in the very file which declares the member `scoped`; if you want to deliberately violate that protection, all you must do is change that to `private`.<br></p><p>To the extent there is value in `scoped`, it is because it prevents *mistakes*, not *malice*. So when we&#39;re thinking about what `scoped` should do, we should ask, &quot;What is likely to be a mistake?&quot;<br></p><p>I submit that, if you nest one declaration inside another, and the outer declaration accesses implementation details of the inner declaration, that is not likely to be a mistake. If it would be, you can always put the inner declaration into its own extension; then any code which accesses its implementation details will have to be deliberately put in that particular extension.<br></p><p>This does not permanently wall off those implementation details from anything outside the type, but there is *nothing* we can do that will do that, because you are already in the file and can always change the the `scoped` to `private`. <br></p><p><br></p><p>* The REPL won&#39;t show this behavior because it allows arbitrary statements at the top scope; you&#39;ll have to try it in a .swift file.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Wrap it how? You can&#39;t introduce arbitrary scopes inside file scope; that<br>is, this is already illegal*:<br></p><p>&gt; Introducing a scope would require you to declare or extend a type. Thus,<br>moving something into a containing scope in order to allow you to &quot;see&quot;<br>into it would also, by necessity, move the type itself, forcing you to<br>change any code that uses the type.<br></p><p><br>Yes, that&#39;s what I meant: making a class nested.<br></p><p><br>&gt;  It would be far easier for someone trying to get access to internal<br>details to simply change `scoped` to `private`.<br></p><p><br>That may be, but it&#39;s still important to preserve the semantic meaning of<br>&quot;scoped&quot; -- it should make anything marked with &quot;scoped&quot; be completely<br>hidden from outside of the scope. It&#39;s a guarantee that nothing outside the<br>scope can break what the scope aims to hide. As long as the code inside the<br>scope hasn&#39;t changed, any code changes outside of it will not break it.<br>It&#39;s the same kind of guarantee that we get with &quot;private&quot; (as long as the<br>file hasn&#39;t changed, changes in other files  will not break the code inside<br>the file).<br></p><p><br>&gt; When considering the `scoped` proposal, you must remember that `scoped`&#39;s<br>protections are paper-thin. You are already in the very file which declares<br>the member `scoped`; if you want to deliberately violate that protection,<br>all you must do is change that to `private`.<br></p><p><br>Exactly the same argument is true about &quot;private&quot;. If you want to<br>deliberately violate protection by &quot;private&quot;, all you must do is change<br>that to &quot;internal&quot;. As long as you haver access to source code, you can<br>break anything like that. The &quot;paper-thin protection&quot; argument applies to<br>anything in the source code. For example, you could change any variable&#39;s<br>type from T to T! and bypass any compiler&#39;s checks for optionals. The whole<br>point of having types and access control is that you know what operations<br>are allowed and that as long as *something else* changes, the compiler<br>still protects your type. The protection comes in the form of a compilation<br>error saying that something is not allowed, given the contract that you<br>specified. If you have access to source code, you can change the contract,<br>but in this case the compilation error is the most you can hope for, and<br>it&#39;s not &quot;paper-thin&quot;.<br></p><p><br></p><p>On Fri, Mar 4, 2016 at 10:14 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; A very important property of the proposal is that anything declared<br>&gt; &quot;scoped&quot; is completely sealed inside its scope and cannot be accessed from<br>&gt; the outside. This means that the scope can be moved anywhere in the file<br>&gt; without the danger of introducing access to implementation details.<br>&gt; &gt;<br>&gt; &gt; Allowing a containing scope to see &quot;scoped&quot; in its inner scope would<br>&gt; mean that someone could just wrap a scope in another scope to gain access<br>&gt; to implementation details without changing anything in the scope itself.<br>&gt; The whole point of the proposal is to protect against something like this<br>&gt; and make sure that implementation details remain hidden from anything<br>&gt; outside the scope.<br>&gt;<br>&gt; Wrap it how? You can&#39;t introduce arbitrary scopes inside file scope; that<br>&gt; is, this is already illegal*:<br>&gt;<br>&gt;         do {<br>&gt;                 extension SomeType {<br>&gt;                         scoped func secret() { ... }<br>&gt;                 }<br>&gt;<br>&gt;                 func intruder(some: SomeType) {<br>&gt;                         some.secret()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; Introducing a scope would require you to declare or extend a type. Thus,<br>&gt; moving something into a containing scope in order to allow you to &quot;see&quot;<br>&gt; into it would also, by necessity, move the type itself, forcing you to<br>&gt; change any code that uses the type. It would be far easier for someone<br>&gt; trying to get access to internal details to simply change `scoped` to<br>&gt; `private`.<br>&gt;<br>&gt; When considering the `scoped` proposal, you must remember that `scoped`&#39;s<br>&gt; protections are paper-thin. You are already in the very file which declares<br>&gt; the member `scoped`; if you want to deliberately violate that protection,<br>&gt; all you must do is change that to `private`.<br>&gt;<br>&gt; To the extent there is value in `scoped`, it is because it prevents<br>&gt; *mistakes*, not *malice*. So when we&#39;re thinking about what `scoped` should<br>&gt; do, we should ask, &quot;What is likely to be a mistake?&quot;<br>&gt;<br>&gt; I submit that, if you nest one declaration inside another, and the outer<br>&gt; declaration accesses implementation details of the inner declaration, that<br>&gt; is not likely to be a mistake. If it would be, you can always put the inner<br>&gt; declaration into its own extension; then any code which accesses its<br>&gt; implementation details will have to be deliberately put in that particular<br>&gt; extension.<br>&gt;<br>&gt; This does not permanently wall off those implementation details from<br>&gt; anything outside the type, but there is *nothing* we can do that will do<br>&gt; that, because you are already in the file and can always change the the<br>&gt; `scoped` to `private`.<br>&gt;<br>&gt;<br>&gt;<br>&gt; * The REPL won&#39;t show this behavior because it allows arbitrary statements<br>&gt; at the top scope; you&#39;ll have to try it in a .swift file.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/63e736af/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
