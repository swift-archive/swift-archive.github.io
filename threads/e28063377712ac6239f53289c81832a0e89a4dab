<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Id like to revive the discussion around OS &quot;variants&quot;.  I&#39;ve been doing<br>some work to bring up Windows without any emulation layer (MSVCRT based) as<br>a viable host environment.  This work is bringing to light the need for<br>more finer grained OS checks.<br></p><p>Currently, we have the `os` compilation condition.  However, this doesn&#39;t<br>provide sufficiently detailed information for Windows.  On Windows, we have<br>at least 4 different &quot;variants&quot;:<br></p><p>- &quot;msvc&quot; (Microsoft&#39;s environment)<br>- &quot;itanium&quot; (MS ABI for C, Itanium ABI for C++)<br>- &quot;gnu&quot; (MinGW)<br>- &quot;cygnus&quot; (cygwin)<br></p><p>Each one of these is slightly different and requires particular handling in<br>the runtime.  However, the OS for each one of these is windows, and so<br>`os(Windows)` yields true on all of them.<br></p><p>This is not a problem strictly limited to Windows.  It also appears in<br>other OSes.  As a concrete example, Linux has traditionally had the &quot;gnu&quot;<br>environment (libc).  However, there is also &quot;uclibc&quot; which is pretty<br>common, and these days, &quot;musl&quot; as different targets.  Swift also supports<br>android, which is a Linux environment variant.<br></p><p>As deeper system integration occurs with swift, the need for finer grained<br>os detection logic is probably going to be needed.<br></p><p>To keep things simple, I would like to propose the &quot;environment&quot;<br>conditional compilation directive.  It would yield true for the appropriate<br>environment with one of the previously mentioned values for windows and<br>true for &quot;android&quot; on Android.  It would sit as a peer to `os` and allow<br>for finer grained querying of the host environment.<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160707/e2804dab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks for sending this out, Saleem!<br></p><p>I’m not convinced that gnu/uclibc/musl are environment variants worth testing for, nor do I think we actually want to model Android as a kind of Linux. It’s unclear whether “environment” is another set of mutually-exclusive options (enum-like) or a way to check several things that might all be true (option-set-like). For example, is “itanium” really distinct from all the others, or can you have itanium-gnu?<br></p><p>I imagine some people might like to distinguish Linux distros as well, but since those follow the “like Gecko &lt;https://www.nczonline.net/blog/2010/01/12/history-of-the-user-agent-string/&gt;” policy, I’m not sure we’d actually want to encourage people to use such a thing. On the other hand, we could easily have ‘environment(simulator)’ for the Apple device OSs.<br></p><p>It’s also not clear whether we always want ‘environment&#39; to be a subset of ‘os&#39;, i.e. it’s a mistake to test for “simulator” before checking for an OS because it might mean different things on different platforms. (iOS simulator or Android simulator?)<br></p><p>I’ll defer to all of you as to whether “gnu” and “cygnus” are the right names for MinGW and Cygwin. I kind of thought Cygnus was named as such because it was also a GNU environment.<br></p><p>A related use is something that’s above `os(…)`, so that we can have all the Apple platforms grouped together. That could be “environment”, or it could be something different.<br></p><p>Finally, in the spirit of “question everything”, is “environment” the right name for this setting? :-)<br></p><p>The goal of this thread should be for you/us to converge on a design, and then for someone to write it up and take to swift-evolution.<br></p><p>Jordan<br></p><p><br>&gt; On Jul 7, 2016, at 18:17, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Id like to revive the discussion around OS &quot;variants&quot;.  I&#39;ve been doing some work to bring up Windows without any emulation layer (MSVCRT based) as a viable host environment.  This work is bringing to light the need for more finer grained OS checks.<br>&gt; <br>&gt; Currently, we have the `os` compilation condition.  However, this doesn&#39;t provide sufficiently detailed information for Windows.  On Windows, we have at least 4 different &quot;variants&quot;:<br>&gt; <br>&gt; - &quot;msvc&quot; (Microsoft&#39;s environment)<br>&gt; - &quot;itanium&quot; (MS ABI for C, Itanium ABI for C++)<br>&gt; - &quot;gnu&quot; (MinGW)<br>&gt; - &quot;cygnus&quot; (cygwin)<br>&gt; <br>&gt; Each one of these is slightly different and requires particular handling in the runtime.  However, the OS for each one of these is windows, and so `os(Windows)` yields true on all of them.<br>&gt; <br>&gt; This is not a problem strictly limited to Windows.  It also appears in other OSes.  As a concrete example, Linux has traditionally had the &quot;gnu&quot; environment (libc).  However, there is also &quot;uclibc&quot; which is pretty common, and these days, &quot;musl&quot; as different targets.  Swift also supports android, which is a Linux environment variant.<br>&gt; <br>&gt; As deeper system integration occurs with swift, the need for finer grained os detection logic is probably going to be needed.<br>&gt; <br>&gt; To keep things simple, I would like to propose the &quot;environment&quot; conditional compilation directive.  It would yield true for the appropriate environment with one of the previously mentioned values for windows and true for &quot;android&quot; on Android.  It would sit as a peer to `os` and allow for finer grained querying of the host environment.<br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160707/3ffb16ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  7, 2016 at 08:00:00pm</p></header><div class="content"><p>Just want to throw this into the discussion: <br></p><p>* https://github.com/apple/swift-evolution/pull/369<br></p><p>Also discussions on -evolution, which do touch on &quot;Apple-like&quot;, etc.<br></p><p>* http://thread.gmane.org/gmane.comp.lang.swift.evolution/7516<br>* http://thread.gmane.org/gmane.comp.lang.swift.evolution/12065<br></p><p>-- E<br></p><p>&gt; On Jul 7, 2016, at 8:19 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for sending this out, Saleem!<br>&gt; <br>&gt; I’m not convinced that gnu/uclibc/musl are environment variants worth testing for, nor do I think we actually want to model Android as a kind of Linux. It’s unclear whether “environment” is another set of mutually-exclusive options (enum-like) or a way to check several things that might all be true (option-set-like). For example, is “itanium” really distinct from all the others, or can you have itanium-gnu?<br>&gt; <br>&gt; I imagine some people might like to distinguish Linux distros as well, but since those follow the “like Gecko &lt;https://www.nczonline.net/blog/2010/01/12/history-of-the-user-agent-string/&gt;” policy, I’m not sure we’d actually want to encourage people to use such a thing. On the other hand, we could easily have ‘environment(simulator)’ for the Apple device OSs.<br>&gt; <br>&gt; It’s also not clear whether we always want ‘environment&#39; to be a subset of ‘os&#39;, i.e. it’s a mistake to test for “simulator” before checking for an OS because it might mean different things on different platforms. (iOS simulator or Android simulator?)<br>&gt; <br>&gt; I’ll defer to all of you as to whether “gnu” and “cygnus” are the right names for MinGW and Cygwin. I kind of thought Cygnus was named as such because it was also a GNU environment.<br>&gt; <br>&gt; A related use is something that’s above `os(…)`, so that we can have all the Apple platforms grouped together. That could be “environment”, or it could be something different.<br>&gt; <br>&gt; Finally, in the spirit of “question everything”, is “environment” the right name for this setting? :-)<br>&gt; <br>&gt; The goal of this thread should be for you/us to converge on a design, and then for someone to write it up and take to swift-evolution.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 7, 2016, at 18:17, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Id like to revive the discussion around OS &quot;variants&quot;.  I&#39;ve been doing some work to bring up Windows without any emulation layer (MSVCRT based) as a viable host environment.  This work is bringing to light the need for more finer grained OS checks.<br>&gt;&gt; <br>&gt;&gt; Currently, we have the `os` compilation condition.  However, this doesn&#39;t provide sufficiently detailed information for Windows.  On Windows, we have at least 4 different &quot;variants&quot;:<br>&gt;&gt; <br>&gt;&gt; - &quot;msvc&quot; (Microsoft&#39;s environment)<br>&gt;&gt; - &quot;itanium&quot; (MS ABI for C, Itanium ABI for C++)<br>&gt;&gt; - &quot;gnu&quot; (MinGW)<br>&gt;&gt; - &quot;cygnus&quot; (cygwin)<br>&gt;&gt; <br>&gt;&gt; Each one of these is slightly different and requires particular handling in the runtime.  However, the OS for each one of these is windows, and so `os(Windows)` yields true on all of them.<br>&gt;&gt; <br>&gt;&gt; This is not a problem strictly limited to Windows.  It also appears in other OSes.  As a concrete example, Linux has traditionally had the &quot;gnu&quot; environment (libc).  However, there is also &quot;uclibc&quot; which is pretty common, and these days, &quot;musl&quot; as different targets.  Swift also supports android, which is a Linux environment variant.<br>&gt;&gt; <br>&gt;&gt; As deeper system integration occurs with swift, the need for finer grained os detection logic is probably going to be needed.<br>&gt;&gt; <br>&gt;&gt; To keep things simple, I would like to propose the &quot;environment&quot; conditional compilation directive.  It would yield true for the appropriate environment with one of the previously mentioned values for windows and true for &quot;android&quot; on Android.  It would sit as a peer to `os` and allow for finer grained querying of the host environment.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Saleem Abdulrasool<br>&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160707/12da26ee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I Agree with Saleem that this is a worthwhile discussion, and I think I agree with Jordan that word environment seems a little bit wrong to me.<br></p><p>Following the discussion, it feels to me like what we&#39;re really concerned about is libc and ABI.  Most of the examples that Saleem gave seems to have that in common.  Jordan&#39;s example about environment(simulator) feels like a more natural fit (i.e. using it as a way to talk about the physical/virtual environment).  I think that libc(gnu), etc., would be perhaps workable, but doesn&#39;t express the differences in ABI for the Itanium example.<br></p><p>I do like Erica&#39;s contribution of the Evolution proposal from a bit ago. Adding libc to it with a combined check for arch should get is substantially there.<br></p><p>I know that I&#39;m rambling bit; my thoughts on the subject are not fully formed.  I haven&#39;t been bitten by this particular issue yet, so it&#39;s of academic interest so far.<br></p><p>Thanks to all for their work,<br>- Will<br></p><p>&gt; On Jul 7, 2016, at 7:19 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Thanks for sending this out, Saleem!<br>&gt; <br>&gt; I’m not convinced that gnu/uclibc/musl are environment variants worth testing for, nor do I think we actually want to model Android as a kind of Linux. It’s unclear whether “environment” is another set of mutually-exclusive options (enum-like) or a way to check several things that might all be true (option-set-like). For example, is “itanium” really distinct from all the others, or can you have itanium-gnu?<br>&gt; <br>&gt; I imagine some people might like to distinguish Linux distros as well, but since those follow the “like Gecko &lt;https://www.nczonline.net/blog/2010/01/12/history-of-the-user-agent-string/&gt;” policy, I’m not sure we’d actually want to encourage people to use such a thing. On the other hand, we could easily have ‘environment(simulator)’ for the Apple device OSs.<br>&gt; <br>&gt; It’s also not clear whether we always want ‘environment&#39; to be a subset of ‘os&#39;, i.e. it’s a mistake to test for “simulator” before checking for an OS because it might mean different things on different platforms. (iOS simulator or Android simulator?)<br>&gt; <br>&gt; I’ll defer to all of you as to whether “gnu” and “cygnus” are the right names for MinGW and Cygwin. I kind of thought Cygnus was named as such because it was also a GNU environment.<br>&gt; <br>&gt; A related use is something that’s above `os(…)`, so that we can have all the Apple platforms grouped together. That could be “environment”, or it could be something different.<br>&gt; <br>&gt; Finally, in the spirit of “question everything”, is “environment” the right name for this setting? :-)<br>&gt; <br>&gt; The goal of this thread should be for you/us to converge on a design, and then for someone to write it up and take to swift-evolution.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 7, 2016, at 18:17, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Id like to revive the discussion around OS &quot;variants&quot;.  I&#39;ve been doing some work to bring up Windows without any emulation layer (MSVCRT based) as a viable host environment.  This work is bringing to light the need for more finer grained OS checks.<br>&gt;&gt; <br>&gt;&gt; Currently, we have the `os` compilation condition.  However, this doesn&#39;t provide sufficiently detailed information for Windows.  On Windows, we have at least 4 different &quot;variants&quot;:<br>&gt;&gt; <br>&gt;&gt; - &quot;msvc&quot; (Microsoft&#39;s environment)<br>&gt;&gt; - &quot;itanium&quot; (MS ABI for C, Itanium ABI for C++)<br>&gt;&gt; - &quot;gnu&quot; (MinGW)<br>&gt;&gt; - &quot;cygnus&quot; (cygwin)<br>&gt;&gt; <br>&gt;&gt; Each one of these is slightly different and requires particular handling in the runtime.  However, the OS for each one of these is windows, and so `os(Windows)` yields true on all of them.<br>&gt;&gt; <br>&gt;&gt; This is not a problem strictly limited to Windows.  It also appears in other OSes.  As a concrete example, Linux has traditionally had the &quot;gnu&quot; environment (libc).  However, there is also &quot;uclibc&quot; which is pretty common, and these days, &quot;musl&quot; as different targets.  Swift also supports android, which is a Linux environment variant.<br>&gt;&gt; <br>&gt;&gt; As deeper system integration occurs with swift, the need for finer grained os detection logic is probably going to be needed.<br>&gt;&gt; <br>&gt;&gt; To keep things simple, I would like to propose the &quot;environment&quot; conditional compilation directive.  It would yield true for the appropriate environment with one of the previously mentioned values for windows and true for &quot;android&quot; on Android.  It would sit as a peer to `os` and allow for finer grained querying of the host environment.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Saleem Abdulrasool<br>&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160707/9f2826b3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 7:19 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Finally, in the spirit of “question everything”, is “environment” the right name for this setting? :-)<br></p><p>Also, is &quot;environment&quot; a name we want to take for this particular feature? &quot;Environment&quot; is a broad and general word, and this proposal uses it in a fairly narrow and esoteric context.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>My thoughts:<br>I don&#39;t like the idea of additional qualifiers after OS. Perhaps we could rename it something more generic like &quot;SDK&quot; or split the non-common stuff in to a seprarate module?<br>As for the proposal (I know it&#39;s too late for Swift 3, but I read it so I might as well say what i thought about it):- I don&#39;t like &quot;vendor&quot;; it&#39;s too vague to give useful guarantees. Even the Apple platforms can be wildly different. I would prefer a group SDK target instead, like &quot;mobileDarwin&quot;, or even something better than that (the &quot;canImport&quot; idea is even better - so you can test for the presence of frameworks such as UIKit directly, and the compiler will/should use @availability attributes to ensure it is safe for all of your deployment targets)- Also don&#39;t like the simulator condition variable. The iOS simulator is literally x86 iOS. If there was an x86 iPhone, theoretically your binaries would be compatible. The fact that it runs on a simulator instead of a real device is not such a vital distinction (or shouldn&#39;t be) that we need integrate it in the language. What would we do in the future if there ever was a real x86 iOS target?<br>Sorry to give a list of stuff I don&#39;t like, but it&#39;s easier that way because the rest of it is good. Endianness, word-size and Interop availability are useful things to know and really are compile-time options, and as I said canImport is also a very good idea.<br>Karl<br></p><p><br></p><p>On Fri, Jul 8, 2016 at 3:17 AM +0200, &quot;Saleem Abdulrasool via swift-dev&quot; &lt;swift-dev at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>Hi,<br>Id like to revive the discussion around OS &quot;variants&quot;.  I&#39;ve been doing some work to bring up Windows without any emulation layer (MSVCRT based) as a viable host environment.  This work is bringing to light the need for more finer grained OS checks.<br>Currently, we have the `os` compilation condition.  However, this doesn&#39;t provide sufficiently detailed information for Windows.  On Windows, we have at least 4 different &quot;variants&quot;:<br>- &quot;msvc&quot; (Microsoft&#39;s environment)- &quot;itanium&quot; (MS ABI for C, Itanium ABI for C++)- &quot;gnu&quot; (MinGW)- &quot;cygnus&quot; (cygwin)<br>Each one of these is slightly different and requires particular handling in the runtime.  However, the OS for each one of these is windows, and so `os(Windows)` yields true on all of them.<br>This is not a problem strictly limited to Windows.  It also appears in other OSes.  As a concrete example, Linux has traditionally had the &quot;gnu&quot; environment (libc).  However, there is also &quot;uclibc&quot; which is pretty common, and these days, &quot;musl&quot; as different targets.  Swift also supports android, which is a Linux environment variant.<br></p><p>As deeper system integration occurs with swift, the need for finer grained os detection logic is probably going to be needed.<br>To keep things simple, I would like to propose the &quot;environment&quot; conditional compilation directive.  It would yield true for the appropriate environment with one of the previously mentioned values for windows and true for &quot;android&quot; on Android.  It would sit as a peer to `os` and allow for finer grained querying of the host environment.<br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160711/8596770c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 10:50 AM, Karl Wagner via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; My thoughts:<br>&gt; <br>&gt; I don&#39;t like the idea of additional qualifiers after OS. Perhaps we could rename it something more generic like &quot;SDK&quot; or split the non-common stuff in to a seprarate module?<br>&gt; <br>&gt; As for the proposal (I know it&#39;s too late for Swift 3, but I read it so I might as well say what i thought about it):<br>&gt; - I don&#39;t like &quot;vendor&quot;; it&#39;s too vague to give useful guarantees. Even the Apple platforms can be wildly different. I would prefer a group SDK target instead, like &quot;mobileDarwin&quot;, or even something better than that (the &quot;canImport&quot; idea is even better - so you can test for the presence of frameworks such as UIKit directly, and the compiler will/should use @availability attributes to ensure it is safe for all of your deployment targets)<br>&gt; - Also don&#39;t like the simulator condition variable. The iOS simulator is literally x86 iOS. If there was an x86 iPhone, theoretically your binaries would be compatible. The fact that it runs on a simulator instead of a real device is not such a vital distinction (or shouldn&#39;t be) that we need integrate it in the language. What would we do in the future if there ever was a real x86 iOS target?<br>&gt; <br>&gt; Sorry to give a list of stuff I don&#39;t like, but it&#39;s easier that way because the rest of it is good. Endianness, word-size and Interop availability are useful things to know and really are compile-time options, and as I said canImport is also a very good idea.<br>&gt; <br>&gt; Karl<br>&gt; <br></p><p>`canImport` is already adopted. Feel free to implement:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>July 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 9:50 AM, Karl Wagner via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; - Also don&#39;t like the simulator condition variable. The iOS simulator is literally x86 iOS. If there was an x86 iPhone, theoretically your binaries would be compatible. The fact that it runs on a simulator instead of a real device is not such a vital distinction (or shouldn&#39;t be) that we need integrate it in the language. What would we do in the future if there ever was a real x86 iOS target?<br></p><p>The iOS simulator is not literally x86 iOS. It has changed ABI in incompatible ways in the past and reserves the right to do so in the future. Any real x86 iOS would have a real ABI which would likely differ from today&#39;s simulator.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160711/12dd7662/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I remember somebody telling me it was, but it was years ago and I&#39;m probably remembering it wrong.  Fair enough though; I got told on that one 😶<br>  <br></p><p>  <br>I&#39;m standing by the principle - it shouldn&#39;t matter if you&#39;re running in a simulator or not. Use a compile flag if you must know, but in general I disagree with a compiler flag for determining the runtime platform for two platforms with the same API and triple.<br>  <br>  <br>  <br>      <br>  <br>Karl<br>  <br></p><p>  <br>&gt;   <br>&gt; On Jul 11, 2016 at 11:26 PM,  &lt;Greg Parker (mailto:gparker at apple.com)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt; &gt;   <br>&gt; &gt; On Jul 11, 2016, at 9:50 AM, Karl Wagner via swift-dev  &lt;swift-dev at swift.org (mailto:swift-dev at swift.org)&gt;  wrote:<br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt; - Also don&#39;t like the simulator condition variable. The iOS simulator is literally x86 iOS. If there was an x86 iPhone, theoretically your binaries would be compatible. The fact that it runs on a simulator instead of a real device is not such a vital distinction (or shouldn&#39;t be) that we need integrate it in the language. What would we do in the future if there ever was a real x86 iOS target?<br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt;   <br>&gt;   <br>&gt; The iOS simulator is not literally x86 iOS. It has changed ABI in incompatible ways in the past and reserves the right to do so in the future. Any real x86 iOS would have a real ABI which would likely differ from today&#39;s simulator.<br>&gt;   <br>&gt;<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; --   <br>&gt;   <br>&gt; Greg Parker          gparker at apple.com (mailto:gparker at apple.com)           Runtime Wrangler<br>&gt;   <br>&gt;   <br>  <br>  <br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160711/c2c5989c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>[RFC] Finer grained OS checks</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>July 12, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 2:33 PM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; I remember somebody telling me it was, but it was years ago and I&#39;m<br>&gt; probably remembering it wrong. Fair enough though; I got told on that one<br>&gt; 😶<br>&gt;<br>&gt; I&#39;m standing by the principle - it shouldn&#39;t matter if you&#39;re running in a<br>&gt; simulator or not. Use a compile flag if you must know, but in general I<br>&gt; disagree with a compiler flag for determining the runtime platform for two<br>&gt; platforms with the same API and triple.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; On Jul 11, 2016 at 11:26 PM, &lt;Greg Parker &lt;gparker at apple.com&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 9:50 AM, Karl Wagner via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; - Also don&#39;t like the simulator condition variable. The iOS simulator is<br>&gt; literally x86 iOS. If there was an x86 iPhone, theoretically your binaries<br>&gt; would be compatible. The fact that it runs on a simulator instead of a real<br>&gt; device is not such a vital distinction (or shouldn&#39;t be) that we need<br>&gt; integrate it in the language. What would we do in the future if there ever<br>&gt; was a real x86 iOS target?<br>&gt;<br>&gt;<br>&gt; The iOS simulator is not literally x86 iOS. It has changed ABI in<br>&gt; incompatible ways in the past and reserves the right to do so in the<br>&gt; future. Any real x86 iOS would have a real ABI which would likely differ<br>&gt; from today&#39;s simulator.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>Well, the name that I went with was environment was derived from the fact<br>that it was based on the &quot;environment&quot; component of the &quot;triple&quot;.  That<br>said, an alternative idea is to make a more invasive change:<br></p><p>`host(...)`: where we can actually do a more target specific component<br>matching.  Something like:<br></p><p>#if host(Windows, msvc)<br>#elseif host(Linux, musl)<br>#elseif host(iOS, ARM)<br>#endif<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160712/0644cbb0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
