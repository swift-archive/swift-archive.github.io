<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>December  6, 2015 at 07:00:00pm</p></header><div class="content"><p>I have a struct and this code:<br></p><p>func test() {<br>    precondition(sizeof(Foo) == 128)<br></p><p>    let s = Foo()<br>    for _ in 0..&lt;100_000_000 {<br>        doSomething(s)<br>    }<br>}<br></p><p>The asm (on LInux, with -O) is showing me that s is being re-initialized on<br>every iteration of the loop.  I was hoping that thanks to swift&#39;s strict<br>constness rules on structs, it wouldn&#39;t have to do this - and just pass the<br>same pointer to doSomething() each time.<br></p><p>When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize<br>each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be<br>as fast.<br></p><p>- Karl<br></p><p>asm from perf:<br></p><p>  2.71 │50:┌─→xorps  %xmm0,%xmm0<br>                                               ▒<br>  8.06 │   │  movaps %xmm0,-0x20(%rbp)<br>                                               ▒<br>  2.71 │   │  movaps %xmm0,-0x30(%rbp)<br>                                               ▒<br>  7.41 │   │  movaps %xmm0,-0x40(%rbp)<br>                                               ▒<br> 10.59 │   │  movaps %xmm0,-0x50(%rbp)<br>                                               ▒<br> 10.00 │   │  movaps %xmm0,-0x60(%rbp)<br>                                               ▒<br>  9.53 │   │  movaps %xmm0,-0x70(%rbp)<br>                                               ▒<br> 10.65 │   │  movaps %xmm0,-0x80(%rbp)<br>                                               ▒<br> 11.24 │   │  movaps %xmm0,-0x90(%rbp)<br>                                               ▒<br> 12.06 │   │  mov    %r14,%rdi<br>                                               ▒<br>  3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_<br>                                               ▒<br>  2.82 │   │  dec    %rbx<br>                                              ▒<br>  8.82 │   └──jne    50<br></p><p>main.swift:<br></p><p>struct Vec4 {<br>    var a: Int64 = 0<br>    var b: Int64 = 0<br>    var c: Int64 = 0<br>    var d: Int64 = 0<br>}<br></p><p>struct Foo {<br>    var x: Vec4 = Vec4()<br>    var y: Vec4 = Vec4()<br>    var z: Vec4 = Vec4()<br>    var u: Vec4 = Vec4()<br>}<br></p><p>func test() {<br>    precondition(sizeof(Foo) == 128)<br></p><p>    let s = Foo()<br>    for _ in 0..&lt;100_000_000 {<br>        doSomething(s)<br>    }<br>}<br></p><p>test()<br></p><p><br>lib.swift:<br></p><p>func doSomething(s: Foo) {<br>    precondition(s.x.a != 1)<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151206/23c5c3ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be as fast.<br></p><p>Huh. That’s especially weird since the semantics of inout actually call for two copies (after the called function returns, the copy of the struct that was passed to it gets copied back into the original variable.) The compiler is often able to optimize that down to the more-expected pass-by-pointer, as in your example. So why then isn’t it able to optimize the non-inout case the same way?<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/a1444181/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a struct and this code:<br>&gt; <br>&gt; func test() {<br>&gt;     precondition(sizeof(Foo) == 128)<br>&gt; <br>&gt;     let s = Foo()<br>&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;         doSomething(s)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The asm (on LInux, with -O) is showing me that s is being re-initialized on every iteration of the loop.  I was hoping that thanks to swift&#39;s strict constness rules on structs, it wouldn&#39;t have to do this - and just pass the same pointer to doSomething() each time.<br>&gt; <br>&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be as fast.<br></p><p>This definitely seems like a place where we ought to be able to peephole the extra copies away. Mind filing a bug?<br></p><p>-Joe<br></p><p>&gt; <br>&gt; - Karl<br>&gt; <br>&gt; asm from perf:<br>&gt; <br>&gt;   2.71 │50:┌─→xorps  %xmm0,%xmm0                                                                                          ▒<br>&gt;   8.06 │   │  movaps %xmm0,-0x20(%rbp)                                                                                    ▒<br>&gt;   2.71 │   │  movaps %xmm0,-0x30(%rbp)                                                                                    ▒<br>&gt;   7.41 │   │  movaps %xmm0,-0x40(%rbp)                                                                                    ▒<br>&gt;  10.59 │   │  movaps %xmm0,-0x50(%rbp)                                                                                    ▒<br>&gt;  10.00 │   │  movaps %xmm0,-0x60(%rbp)                                                                                    ▒<br>&gt;   9.53 │   │  movaps %xmm0,-0x70(%rbp)                                                                                    ▒<br>&gt;  10.65 │   │  movaps %xmm0,-0x80(%rbp)                                                                                    ▒<br>&gt;  11.24 │   │  movaps %xmm0,-0x90(%rbp)                                                                                    ▒<br>&gt;  12.06 │   │  mov    %r14,%rdi                                                                                            ▒<br>&gt;   3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_                                                                      ▒<br>&gt;   2.82 │   │  dec    %rbx                                                                                                 ▒<br>&gt;   8.82 │   └──jne    50             <br>&gt; <br>&gt; main.swift:<br>&gt; <br>&gt; struct Vec4 {<br>&gt;     var a: Int64 = 0<br>&gt;     var b: Int64 = 0<br>&gt;     var c: Int64 = 0<br>&gt;     var d: Int64 = 0<br>&gt; }<br>&gt; <br>&gt; struct Foo {<br>&gt;     var x: Vec4 = Vec4()<br>&gt;     var y: Vec4 = Vec4()<br>&gt;     var z: Vec4 = Vec4()<br>&gt;     var u: Vec4 = Vec4()<br>&gt; }<br>&gt; <br>&gt; func test() {<br>&gt;     precondition(sizeof(Foo) == 128)<br>&gt; <br>&gt;     let s = Foo()<br>&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;         doSomething(s)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; test()<br>&gt; <br>&gt; <br>&gt; lib.swift:<br>&gt; <br>&gt; func doSomething(s: Foo) {<br>&gt;     precondition(s.x.a != 1)<br>&gt; }<br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/65c23ba7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>I created https://bugs.swift.org/browse/SR-110 for the compiler.  However,<br>I also think that the documentation needs an issue filed.  (Where to do<br>that at?)<br></p><p>The current docs say structs are always copied (the only exception being<br>inout to memory variable optimization).  That would make programmers<br>worried about speed and stack usage run away screaming, and not give swift<br>a try.<br></p><p>On Mon, Dec 7, 2015 at 11:53 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I have a struct and this code:<br>&gt;<br>&gt; func test() {<br>&gt;     precondition(sizeof(Foo) == 128)<br>&gt;<br>&gt;     let s = Foo()<br>&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;         doSomething(s)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The asm (on LInux, with -O) is showing me that s is being re-initialized<br>&gt; on every iteration of the loop.  I was hoping that thanks to swift&#39;s strict<br>&gt; constness rules on structs, it wouldn&#39;t have to do this - and just pass the<br>&gt; same pointer to doSomething() each time.<br>&gt;<br>&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize<br>&gt; each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be<br>&gt; as fast.<br>&gt;<br>&gt;<br>&gt; This definitely seems like a place where we ought to be able to peephole<br>&gt; the extra copies away. Mind filing a bug?<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; asm from perf:<br>&gt;<br>&gt;   2.71 │50:┌─→xorps  %xmm0,%xmm0<br>&gt;                                                ▒<br>&gt;   8.06 │   │  movaps %xmm0,-0x20(%rbp)<br>&gt;                                                ▒<br>&gt;   2.71 │   │  movaps %xmm0,-0x30(%rbp)<br>&gt;                                                ▒<br>&gt;   7.41 │   │  movaps %xmm0,-0x40(%rbp)<br>&gt;                                                ▒<br>&gt;  10.59 │   │  movaps %xmm0,-0x50(%rbp)<br>&gt;                                                ▒<br>&gt;  10.00 │   │  movaps %xmm0,-0x60(%rbp)<br>&gt;                                                ▒<br>&gt;   9.53 │   │  movaps %xmm0,-0x70(%rbp)<br>&gt;                                                ▒<br>&gt;  10.65 │   │  movaps %xmm0,-0x80(%rbp)<br>&gt;                                                ▒<br>&gt;  11.24 │   │  movaps %xmm0,-0x90(%rbp)<br>&gt;                                                ▒<br>&gt;  12.06 │   │  mov    %r14,%rdi<br>&gt;                                                ▒<br>&gt;   3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_<br>&gt;                                                ▒<br>&gt;   2.82 │   │  dec    %rbx<br>&gt;                                                 ▒<br>&gt;   8.82 │   └──jne    50<br>&gt;<br>&gt; main.swift:<br>&gt;<br>&gt; struct Vec4 {<br>&gt;     var a: Int64 = 0<br>&gt;     var b: Int64 = 0<br>&gt;     var c: Int64 = 0<br>&gt;     var d: Int64 = 0<br>&gt; }<br>&gt;<br>&gt; struct Foo {<br>&gt;     var x: Vec4 = Vec4()<br>&gt;     var y: Vec4 = Vec4()<br>&gt;     var z: Vec4 = Vec4()<br>&gt;     var u: Vec4 = Vec4()<br>&gt; }<br>&gt;<br>&gt; func test() {<br>&gt;     precondition(sizeof(Foo) == 128)<br>&gt;<br>&gt;     let s = Foo()<br>&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;         doSomething(s)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; test()<br>&gt;<br>&gt;<br>&gt; lib.swift:<br>&gt;<br>&gt; func doSomething(s: Foo) {<br>&gt;     precondition(s.x.a != 1)<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/63c320b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:27 AM, Karl Pickett &lt;karl.pickett at gmail.com&gt; wrote:<br>&gt; <br>&gt; I created https://bugs.swift.org/browse/SR-110 &lt;https://bugs.swift.org/browse/SR-110&gt; for the compiler.  However, I also think that the documentation needs an issue filed.  (Where to do that at?) <br></p><p>Thanks!<br></p><p>&gt; The current docs say structs are always copied (the only exception being inout to memory variable optimization).  That would make programmers worried about speed and stack usage run away screaming, and not give swift a try.<br></p><p>If weren&#39;t already been chased away by &#39;vars are always allocated on the heap&#39;. The docs generally discuss high-level semantic behavior rather than the real code emitted; in general, users can count on structs being copied whenever necessary to preserve value semantics between different names. How would you suggest rewording the documentation?<br></p><p>-Joe<br></p><p>&gt; On Mon, Dec 7, 2015 at 11:53 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a struct and this code:<br>&gt;&gt; <br>&gt;&gt; func test() {<br>&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt; <br>&gt;&gt;     let s = Foo()<br>&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;         doSomething(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The asm (on LInux, with -O) is showing me that s is being re-initialized on every iteration of the loop.  I was hoping that thanks to swift&#39;s strict constness rules on structs, it wouldn&#39;t have to do this - and just pass the same pointer to doSomething() each time.<br>&gt;&gt; <br>&gt;&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be as fast.<br>&gt; <br>&gt; This definitely seems like a place where we ought to be able to peephole the extra copies away. Mind filing a bug?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Karl<br>&gt;&gt; <br>&gt;&gt; asm from perf:<br>&gt;&gt; <br>&gt;&gt;   2.71 │50:┌─→xorps  %xmm0,%xmm0                                                                                          ▒<br>&gt;&gt;   8.06 │   │  movaps %xmm0,-0x20(%rbp)                                                                                    ▒<br>&gt;&gt;   2.71 │   │  movaps %xmm0,-0x30(%rbp)                                                                                    ▒<br>&gt;&gt;   7.41 │   │  movaps %xmm0,-0x40(%rbp)                                                                                    ▒<br>&gt;&gt;  10.59 │   │  movaps %xmm0,-0x50(%rbp)                                                                                    ▒<br>&gt;&gt;  10.00 │   │  movaps %xmm0,-0x60(%rbp)                                                                                    ▒<br>&gt;&gt;   9.53 │   │  movaps %xmm0,-0x70(%rbp)                                                                                    ▒<br>&gt;&gt;  10.65 │   │  movaps %xmm0,-0x80(%rbp)                                                                                    ▒<br>&gt;&gt;  11.24 │   │  movaps %xmm0,-0x90(%rbp)                                                                                    ▒<br>&gt;&gt;  12.06 │   │  mov    %r14,%rdi                                                                                            ▒<br>&gt;&gt;   3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_                                                                      ▒<br>&gt;&gt;   2.82 │   │  dec    %rbx                                                                                                 ▒<br>&gt;&gt;   8.82 │   └──jne    50             <br>&gt;&gt; <br>&gt;&gt; main.swift:<br>&gt;&gt; <br>&gt;&gt; struct Vec4 {<br>&gt;&gt;     var a: Int64 = 0<br>&gt;&gt;     var b: Int64 = 0<br>&gt;&gt;     var c: Int64 = 0<br>&gt;&gt;     var d: Int64 = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;     var x: Vec4 = Vec4()<br>&gt;&gt;     var y: Vec4 = Vec4()<br>&gt;&gt;     var z: Vec4 = Vec4()<br>&gt;&gt;     var u: Vec4 = Vec4()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func test() {<br>&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt; <br>&gt;&gt;     let s = Foo()<br>&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;         doSomething(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; test()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; lib.swift:<br>&gt;&gt; <br>&gt;&gt; func doSomething(s: Foo) {<br>&gt;&gt;     precondition(s.x.a != 1)<br>&gt;&gt; }<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/d85a755a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:36 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:27 AM, Karl Pickett &lt;karl.pickett at gmail.com &lt;mailto:karl.pickett at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I created https://bugs.swift.org/browse/SR-110 &lt;https://bugs.swift.org/browse/SR-110&gt; for the compiler.  However, I also think that the documentation needs an issue filed.  (Where to do that at?) <br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt;&gt; The current docs say structs are always copied (the only exception being inout to memory variable optimization).  That would make programmers worried about speed and stack usage run away screaming, and not give swift a try.<br>&gt; <br>&gt; If weren&#39;t already been chased away by &#39;vars are always allocated on the heap&#39;. The docs generally discuss high-level semantic behavior rather than the real code emitted; in general, users can count on structs being copied whenever necessary to preserve value semantics between different names. How would you suggest rewording the documentation?<br>&gt; <br>&gt; -Joe<br></p><p>Perhaps the docs should instead talk about how the lifetime of the var&#39;s value might extend beyond the return from its scope, without explicitly saying anything about stack or heap allocation, which as you note is entirely implementation detail.<br></p><p>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 11:53 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a struct and this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test() {<br>&gt;&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let s = Foo()<br>&gt;&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;&gt;         doSomething(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The asm (on LInux, with -O) is showing me that s is being re-initialized on every iteration of the loop.  I was hoping that thanks to swift&#39;s strict constness rules on structs, it wouldn&#39;t have to do this - and just pass the same pointer to doSomething() each time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be as fast.<br>&gt;&gt; <br>&gt;&gt; This definitely seems like a place where we ought to be able to peephole the extra copies away. Mind filing a bug?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; asm from perf:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   2.71 │50:┌─→xorps  %xmm0,%xmm0                                                                                          ▒<br>&gt;&gt;&gt;   8.06 │   │  movaps %xmm0,-0x20(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;   2.71 │   │  movaps %xmm0,-0x30(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;   7.41 │   │  movaps %xmm0,-0x40(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;  10.59 │   │  movaps %xmm0,-0x50(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;  10.00 │   │  movaps %xmm0,-0x60(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;   9.53 │   │  movaps %xmm0,-0x70(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;  10.65 │   │  movaps %xmm0,-0x80(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;  11.24 │   │  movaps %xmm0,-0x90(%rbp)                                                                                    ▒<br>&gt;&gt;&gt;  12.06 │   │  mov    %r14,%rdi                                                                                            ▒<br>&gt;&gt;&gt;   3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_                                                                      ▒<br>&gt;&gt;&gt;   2.82 │   │  dec    %rbx                                                                                                 ▒<br>&gt;&gt;&gt;   8.82 │   └──jne    50             <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; main.swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vec4 {<br>&gt;&gt;&gt;     var a: Int64 = 0<br>&gt;&gt;&gt;     var b: Int64 = 0<br>&gt;&gt;&gt;     var c: Int64 = 0<br>&gt;&gt;&gt;     var d: Int64 = 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     var x: Vec4 = Vec4()<br>&gt;&gt;&gt;     var y: Vec4 = Vec4()<br>&gt;&gt;&gt;     var z: Vec4 = Vec4()<br>&gt;&gt;&gt;     var u: Vec4 = Vec4()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test() {<br>&gt;&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let s = Foo()<br>&gt;&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;&gt;         doSomething(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; test()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; lib.swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(s: Foo) {<br>&gt;&gt;&gt;     precondition(s.x.a != 1)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/2695cc73/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:36 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; If weren&#39;t already been chased away by &#39;vars are always allocated on the heap&#39;. The docs generally discuss high-level semantic behavior rather than the real code emitted; in general, users can count on structs being copied whenever necessary to preserve value semantics between different names. How would you suggest rewording the documentation?<br></p><p>Perhaps take a look at the Go language documentation for ideas, since it has similar semantics. Here’s an explanation I found in their FAQ:<br></p><p>&gt;&gt; How do I know whether a variable is allocated on the heap or the stack?<br>&gt;&gt; <br>&gt;&gt; From a correctness standpoint, you don&#39;t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.<br>&gt;&gt; <br>&gt;&gt; The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&#39;s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.<br>&gt;&gt; <br>&gt;&gt; In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.<br></p><p>https://golang.org/doc/faq#stack_or_heap<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/878fcf54/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>Are structs really always pessimistically copied when calling funcs?</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 12:36 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 7, 2015, at 10:27 AM, Karl Pickett &lt;karl.pickett at gmail.com&gt; wrote:<br>&gt;<br>&gt; I created https://bugs.swift.org/browse/SR-110 for the compiler.<br>&gt; However, I also think that the documentation needs an issue filed.  (Where<br>&gt; to do that at?)<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; The current docs say structs are always copied (the only exception being<br>&gt; inout to memory variable optimization).  That would make programmers<br>&gt; worried about speed and stack usage run away screaming, and not give swift<br>&gt; a try.<br>&gt;<br>&gt;<br>&gt; If weren&#39;t already been chased away by &#39;vars are always allocated on the<br>&gt; heap&#39;. The docs generally discuss high-level semantic behavior rather than<br>&gt; the real code emitted; in general, users can count on structs being copied<br>&gt; whenever necessary to preserve value semantics between different names. How<br>&gt; would you suggest rewording the documentation?<br>&gt;<br></p><p>I&#39;m find with the docs being broad and semantic but a &#39;NOTE: Copying might<br>be elided; see &quot;Swift Optimizations&quot; for details&#39; would be helpful.<br>Clearly the semantics are being carefully designed to enable certain<br>optimizations, but if we&#39;re only seeing the semantics, we&#39;re not seeing the<br>whole picture.<br></p><p>I did a search for &quot;heap&quot; and found nothing in the 2.2 ebook.  I recall<br>seeing heap-&gt;stack optimizations for closures in some video and didn&#39;t go<br>digging further because it seemed like the language designer(s) had a<br>solution.  I think that&#39;s a separate issue but yes having details would be<br>great.<br></p><p>Consider a user who wants to write some C-style swift (using stack and<br>heap) and wants to know &quot;what am I being forced to pay for in Swift, that C<br>doesn&#39;t have&quot;.  The docs often contrast with C and I think that&#39;s great.<br></p><p>So the &quot;Swift Optimizations&quot; would cover heap/stack, struct copying for<br>func calls (pure structs, and cases where they have embedded classes), and<br>inouts to function or global vars.  And returning a struct (does caller or<br>callee allocate, and/or copy).   And ARC.  Even if an optimization isn&#39;t<br>currently implemented, it could say &quot;the language was designed for X<br>optimization to be possible so don&#39;t assume Y&quot;.<br></p><p>I&#39;m also unsure how inlining works across modules/libraries.  whole-module<br>is great but I assume we can&#39;t rely on that in the general case, unless we<br>have c++ like &quot;header only&quot; libraries with full source.<br></p><p>Swift seems really great (the Linux build worked with no problems for me);<br>there&#39;s just a lack of &quot;deep dive&quot; material at the moment, so I&#39;m left<br>hanging wondering what the gotchas are with using it for a systems project.<br>At the moment it&#39;s a few clues and hints to go off of.<br></p><p>- Karl<br></p><p><br></p><p><br></p><p><br></p><p><br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 11:53 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 5:16 PM, Karl Pickett via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have a struct and this code:<br>&gt;&gt;<br>&gt;&gt; func test() {<br>&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt;<br>&gt;&gt;     let s = Foo()<br>&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;         doSomething(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The asm (on LInux, with -O) is showing me that s is being re-initialized<br>&gt;&gt; on every iteration of the loop.  I was hoping that thanks to swift&#39;s strict<br>&gt;&gt; constness rules on structs, it wouldn&#39;t have to do this - and just pass the<br>&gt;&gt; same pointer to doSomething() each time.<br>&gt;&gt;<br>&gt;&gt; When I use an inout param, that is 2x as fast and doesn&#39;t re-initialize<br>&gt;&gt; each time.  However I don&#39;t see why passing something immutably wouldn&#39;t be<br>&gt;&gt; as fast.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This definitely seems like a place where we ought to be able to peephole<br>&gt;&gt; the extra copies away. Mind filing a bug?<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Karl<br>&gt;&gt;<br>&gt;&gt; asm from perf:<br>&gt;&gt;<br>&gt;&gt;   2.71 │50:┌─→xorps  %xmm0,%xmm0<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   8.06 │   │  movaps %xmm0,-0x20(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   2.71 │   │  movaps %xmm0,-0x30(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   7.41 │   │  movaps %xmm0,-0x40(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;  10.59 │   │  movaps %xmm0,-0x50(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;  10.00 │   │  movaps %xmm0,-0x60(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   9.53 │   │  movaps %xmm0,-0x70(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;  10.65 │   │  movaps %xmm0,-0x80(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;  11.24 │   │  movaps %xmm0,-0x90(%rbp)<br>&gt;&gt;                                                  ▒<br>&gt;&gt;  12.06 │   │  mov    %r14,%rdi<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   3.41 │   │→ callq  _TF4main11doSomethingFVS_3FooT_<br>&gt;&gt;                                                  ▒<br>&gt;&gt;   2.82 │   │  dec    %rbx<br>&gt;&gt;                                                   ▒<br>&gt;&gt;   8.82 │   └──jne    50<br>&gt;&gt;<br>&gt;&gt; main.swift:<br>&gt;&gt;<br>&gt;&gt; struct Vec4 {<br>&gt;&gt;     var a: Int64 = 0<br>&gt;&gt;     var b: Int64 = 0<br>&gt;&gt;     var c: Int64 = 0<br>&gt;&gt;     var d: Int64 = 0<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Foo {<br>&gt;&gt;     var x: Vec4 = Vec4()<br>&gt;&gt;     var y: Vec4 = Vec4()<br>&gt;&gt;     var z: Vec4 = Vec4()<br>&gt;&gt;     var u: Vec4 = Vec4()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func test() {<br>&gt;&gt;     precondition(sizeof(Foo) == 128)<br>&gt;&gt;<br>&gt;&gt;     let s = Foo()<br>&gt;&gt;     for _ in 0..&lt;100_000_000 {<br>&gt;&gt;         doSomething(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; test()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; lib.swift:<br>&gt;&gt;<br>&gt;&gt; func doSomething(s: Foo) {<br>&gt;&gt;     precondition(s.x.a != 1)<br>&gt;&gt; }<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/8e948a25/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
