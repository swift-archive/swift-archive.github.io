<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br></p><p>Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br></p><p>public var receivers: [GameControllerReceiverType] {<br>    // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>    return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>}<br></p><p>This workaround works, but is undesirable for a number of reasons. Most notably:<br></p><p>• NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>• It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>• It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br></p><p>I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br></p><p>Thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/04d4f137/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December 11, 2015 at 12:00:00am</p></header><div class="content"><p>Hi Riley,<br></p><p>Have you tried using an array of structs that in turn hold weak references to your objects? Something like this should work:<br></p><p>public class Weak&lt;T: AnyObject&gt;: NSObject {<br>	public private(set) weak var value: T?<br></p><p>	public init(_ value: T?) {<br>		self.value = value<br>	}<br>}<br></p><p>let weakFoo: [Weak&lt;Foo&gt;] = [Weak&lt;Foo&gt;(foo), ...]<br></p><p>Comes with the overhead of one extra object instantiated per element, but perhaps this is acceptable for your use case.<br></p><p>/T<br></p><p>&gt; Op 10 dec. 2015, om 23:55 heeft Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; het volgende geschreven:<br>&gt; <br>&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt; <br>&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt; <br>&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;     // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;     return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt; }<br>&gt; <br>&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt; <br>&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt; <br>&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8005ebeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>Using box types solves the portability problems, but it still means O(n) access for clients who want to access the non-boxed values directly. Additionally, these objects aren’t automatically removed from the collection when their values are nil-ed out, which is unfortunate.<br></p><p>Side note: this is the route I originally tried to take, but unfortunately the Swift doesn’t work well with weak references to protocol types…<br></p><p>&gt; On Dec 10, 2015, at 3:01 PM, Tommy van der Vorst &lt;tommy at pixelspark.nl&gt; wrote:<br>&gt; <br>&gt; Hi Riley,<br>&gt; <br>&gt; Have you tried using an array of structs that in turn hold weak references to your objects? Something like this should work:<br>&gt; <br>&gt; public class Weak&lt;T: AnyObject&gt;: NSObject {<br>&gt; 	public private(set) weak var value: T?<br>&gt; <br>&gt; 	public init(_ value: T?) {<br>&gt; 		self.value = value<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let weakFoo: [Weak&lt;Foo&gt;] = [Weak&lt;Foo&gt;(foo), ...]<br>&gt; <br>&gt; Comes with the overhead of one extra object instantiated per element, but perhaps this is acceptable for your use case.<br>&gt; <br>&gt; /T<br>&gt; <br>&gt;&gt; Op 10 dec. 2015, om 23:55 heeft Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt;&gt; <br>&gt;&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt;&gt; <br>&gt;&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt;&gt; <br>&gt;&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;&gt;     // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;&gt;     return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt;&gt; <br>&gt;&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt;&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt;&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt;&gt; <br>&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/970e8373/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 3:31 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Using box types solves the portability problems, but it still means O(n) access for clients who want to access the non-boxed values directly. Additionally, these objects aren’t automatically removed from the collection when their values are nil-ed out, which is unfortunate.<br>&gt; <br>&gt; Side note: this is the route I originally tried to take, but unfortunately the Swift doesn’t work well with weak references to protocol types…<br></p><p>Really?  Please file a bug about this; I’ve been working in this area recently.<br></p><p>(Or just point out the radar number if you filed one there already.)<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; On Dec 10, 2015, at 3:01 PM, Tommy van der Vorst &lt;tommy at pixelspark.nl &lt;mailto:tommy at pixelspark.nl&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Riley,<br>&gt;&gt; <br>&gt;&gt; Have you tried using an array of structs that in turn hold weak references to your objects? Something like this should work:<br>&gt;&gt; <br>&gt;&gt; public class Weak&lt;T: AnyObject&gt;: NSObject {<br>&gt;&gt; 	public private(set) weak var value: T?<br>&gt;&gt; <br>&gt;&gt; 	public init(_ value: T?) {<br>&gt;&gt; 		self.value = value<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let weakFoo: [Weak&lt;Foo&gt;] = [Weak&lt;Foo&gt;(foo), ...]<br>&gt;&gt; <br>&gt;&gt; Comes with the overhead of one extra object instantiated per element, but perhaps this is acceptable for your use case.<br>&gt;&gt; <br>&gt;&gt; /T<br>&gt;&gt; <br>&gt;&gt;&gt; Op 10 dec. 2015, om 23:55 heeft Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;&gt;&gt;     // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;&gt;&gt;     return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt;&gt;&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt;&gt;&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/af7add43/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 4:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 3:31 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Using box types solves the portability problems, but it still means O(n) access for clients who want to access the non-boxed values directly. Additionally, these objects aren’t automatically removed from the collection when their values are nil-ed out, which is unfortunate.<br>&gt;&gt; <br>&gt;&gt; Side note: this is the route I originally tried to take, but unfortunately the Swift doesn’t work well with weak references to protocol types…<br>&gt; <br>&gt; Really?  Please file a bug about this; I’ve been working in this area recently.<br></p><p>It should work with protocols, but they must be class bound.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b38bddce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>FWIW, I don’t think it was directly tied to being unable to support weak references to protocol types, but rather was a side-effect (I know I had to change it from “protocol TestProtocol: class” to “protocol TestProtocol: AnyObject” to satisfy some of the compiler errors, but doing that still preventing me from using the protocol directly in certain situations). However, I can no longer reproduce the issue, so it’s possible it was a bug in Swift that has been subsequently fixed.<br></p><p>&gt; On Dec 10, 2015, at 5:27 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 4:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 3:31 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Using box types solves the portability problems, but it still means O(n) access for clients who want to access the non-boxed values directly. Additionally, these objects aren’t automatically removed from the collection when their values are nil-ed out, which is unfortunate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Side note: this is the route I originally tried to take, but unfortunately the Swift doesn’t work well with weak references to protocol types…<br>&gt;&gt; <br>&gt;&gt; Really?  Please file a bug about this; I’ve been working in this area recently.<br>&gt; <br>&gt; It should work with protocols, but they must be class bound.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/ce706ae4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 2:55 PM, Riley Testut via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think native swift collections with support for weak references for<br>&gt; their contents would be very useful, and in more places than just listed<br>&gt; above. I don’t think Array could be easily extended to support it (what<br>&gt; happens if a value is released? does everything shift down? do they keep<br>&gt; their indices?), but Set and Dictionary (where the keys and/or values could<br>&gt; be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;<br></p><p>Seems like an interesting direction to me, using value types as keys and<br>weak references in a dictionary-like data structure seems like a fequent<br>use case.  A proposal in this area should include not just the API, but<br>also a discussion of the implementation strategy.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/2cf60072/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 2:55 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br></p><p>Containers of weak references are valuable, but I suspect they will need to be completely distinct from Array and Set and Dictionary. The problem is that a weak reference can become nil at any time. This subverts the value semantics of Swift&#39;s current containers and defeats assumptions that typical container algorithms make. (For example, a typical sorting algorithm assumes that comparison results between two elements are consistent over time, but that isn&#39;t true if a weak reference disappears while a sort is in progress.)<br></p><p>Note that Foundation does not support weak references in NSDictionary or NSSet.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Weak Native Swift Containers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not sure how NSHashTable and NSMapTable are implemented under the hood, but assumedly the native Swift implementation would be somewhat similar. I&#39;m not opposed to figuring out the best way to accomplish this, but if it&#39;s already been implemented and works well, no use going through all that work again :-)<br></p><p>I agree they should be distinct types, but I&#39;m debating how explicit that should be to the user. On one hand, there could be a &quot;WeakSet&quot; or &quot;WeakDictionary&quot; type, that is completely separate, explicit, and public, or we could go a more &quot;magical&quot; route and have a private implementation of Set/Dictionary that conforms to all the same protocols as Set/Dictionary (similar to the different implementations of Array depending on what the backing store is), and is used when a weak set is needed.<br></p><p>Or, it could be in the middle, and we could convert a Set/Dictionary into a weak variant, such as by accessing a &quot;.weak&quot; property (akin to the &quot;.lazy&quot; property implemented by CollectionType). I think all these solutions have their pros and cons, and it would be worth discussing the best way to approach this problem.<br></p><p>&gt; On Dec 10, 2015, at 4:53 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 2:55 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt; <br>&gt; Containers of weak references are valuable, but I suspect they will need to be completely distinct from Array and Set and Dictionary. The problem is that a weak reference can become nil at any time. This subverts the value semantics of Swift&#39;s current containers and defeats assumptions that typical container algorithms make. (For example, a typical sorting algorithm assumes that comparison results between two elements are consistent over time, but that isn&#39;t true if a weak reference disappears while a sort is in progress.)<br>&gt; <br>&gt; Note that Foundation does not support weak references in NSDictionary or NSSet.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
