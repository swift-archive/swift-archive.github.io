<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0101: Rename sizeof and related functions to comply with API Guidelines&quot; begins now and runs through June 27. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0101-standardizing-sizeof-naming.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>On 21 June 2016 at 14:03, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0101: Rename sizeof and related functions to comply with API Guidelines&quot; begins now and runs through June 27. The proposal is available here:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0101-standardizing-sizeof-naming.md<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br></p><p>After a carefull review of the proposal, I will be obligated to<br>decline it. After studying the proposal I ended up thinking I was<br>writing more code to get the data and in comparison with dynamicType<br>-&gt; type(of:) it lead me to think at first the proposal would suggest<br>renaming size* functions to size(of*:) and so forth, which would seem<br>to go more towards the compared proposal (SE-0096). This idea doesn&#39;t<br>even made into the alternatives considered and I think it would making<br>reading and understanding the code much clearer than the proposed<br>nested function calls.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I&#39;m not sure. Given the reasoning I&#39;d say yes but given proposal<br>SE-0096 I&#39;d say yes only if the new function names were to be<br>size(of*:), stride(of*:) and align(of*:) and thus not depending of the<br>nested result of type(of*:).<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don&#39;t think so. As I said, when I finished reading the proposal, I<br>ended up thinking I was writing more code in the new version and it<br>didn&#39;t seem very clear to me what was the size I was getting.<br>Moreover, it seems I&#39;ll always have to invoke these functions to the<br>result of type(of*:) which would be unnecessary redundant code.<br></p><p>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Many languages (like C/C++, C#, D) have both sizeof and typeof and in<br>most these two functions have similar names and syntaxes. In this case<br>I believe making them different makes it hard to discover those<br>functions exist and relate their purpose.<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick study was enough for me.<br></p><p>L<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 21, 2016 at 11:00:00am</p></header><div class="content"><p>Regarding the issue of existential metatypes with sizeof:<br></p><p>Pyry Jahkola points out one instance where the memorySize(type(of: …)) workaround won&#39;t work. When the value is an existential, it&#39;s illegal to ask for the size of its dynamic type: the result can&#39;t be retrieved at compile time:<br></p><p>// Swift 2.2, 64-bit<br>let i = 123<br>print(sizeofValue(i)) //=&gt; 8<br>let c: CustomStringConvertible = i<br>print(sizeofValue(c)) //=&gt; 40<br>print(sizeof(c.dynamicType)) // error: cannot invoke &#39;sizeof&#39; with an argument list of type &#39;(CustomStringCo<br>This could be enabled by having sizeof and friends formally take an Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of the underlying builtins to be able to open existential metatypes, but it seems implementable.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/006e8da4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 12:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Regarding the issue of existential metatypes with sizeof:<br>&gt; <br>&gt; Pyry Jahkola points out one instance where the memorySize(type(of: …)) workaround won&#39;t work. When the value is an existential, it&#39;s illegal to ask for the size of its dynamic type: the result can&#39;t be retrieved at compile time:<br>&gt; <br>&gt; let i = 123<br>&gt; let c: CustomStringConvertible = i<br>&gt; print(sizeof(c.dynamicType)) // error: cannot invoke &#39;sizeof&#39; with an argument list of type &#39;(CustomStringCo<br>&gt; This could be enabled by having sizeof and friends formally take an Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of the underlying builtins to be able to open existential metatypes, but it seems implementable.)<br></p><p>While I&#39;m not a huge fan of Dave A&#39;s generic struct approach (for reasons detailed in the proposal), this could resolve one major issue I currently have with his alternative.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/7d30d040/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 21, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Jun 21 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 21, 2016, at 12:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Regarding the issue of existential metatypes with sizeof:<br>&gt;&gt; <br>&gt;&gt; Pyry Jahkola points out one instance where the memorySize(type(of:<br>&gt;<br>&gt;&gt; …)) workaround won&#39;t work. When the value is an existential, it&#39;s<br>&gt;&gt; illegal to ask for the size of its dynamic type: the result can&#39;t be<br>&gt;&gt; retrieved at compile time:<br>&gt;&gt; <br>&gt;&gt; let i = 123<br>&gt;&gt; let c: CustomStringConvertible = i<br>&gt;&gt; print(sizeof(c.dynamicType)) // error: cannot invoke &#39;sizeof&#39; with an argument list of type &#39;(CustomStringCo<br>&gt;&gt; This could be enabled by having sizeof and friends formally take an<br>&gt;&gt; Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of<br>&gt;&gt; the underlying builtins to be able to open existential metatypes,<br>&gt;&gt; but it seems implementable.)<br>&gt;<br>&gt; While I&#39;m not a huge fan of Dave A&#39;s generic struct approach (for<br>&gt; reasons detailed in the proposal), <br></p><p>Some of the examples used to justify avoiding that approach look<br>wrong or overly complicated to me.  Am I missing something?<br></p><p>    let errnoSize = MemoryLayout.init(t: errno).size<br></p><p>    _class_getInstancePositiveExtentSize(bufferClass) ==<br>    MemoryLayout&lt;_HeapObject.self&gt;.size<br></p><p>wouldn&#39;t that be:<br></p><p>    let errnoSize = MemoryLayout(errno).size<br></p><p>    _class_getInstancePositiveExtentSize(bufferClass) == <br>    MemoryLayout&lt;_HeapObject&gt;.size<br></p><p>? <br></p><p>Once you fix those issues, I don&#39;t find my proposal to hurt<br>readability at all.  One has to put those examples into their actual<br>contexts rather than packing them all next to one another, to evaluate<br>it fairly.<br></p><p>Finally, I still object to doubling the API surface area just so you can<br>pass values instead of types to these functions.  Having three global<br>functions is acceptable, but six is too many, and arguably, having a<br>single type would be better.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 2:36 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jun 21 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 12:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; This could be enabled by having sizeof and friends formally take an<br>&gt;&gt;&gt; Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of<br>&gt;&gt;&gt; the underlying builtins to be able to open existential metatypes,<br>&gt;&gt;&gt; but it seems implementable.)<br>&gt;&gt; <br>&gt;&gt; While I&#39;m not a huge fan of Dave A&#39;s generic struct approach (for<br>&gt;&gt; reasons detailed in the proposal), <br>&gt; <br>&gt; Some of the examples used to justify avoiding that approach look<br>&gt; wrong or overly complicated to me.  Am I missing something?<br>&gt; <br>&gt;    let errnoSize = MemoryLayout.init(t: errno).size<br>&gt; <br>&gt;    _class_getInstancePositiveExtentSize(bufferClass) ==<br>&gt;    MemoryLayout&lt;_HeapObject.self&gt;.size<br>&gt; <br>&gt; wouldn&#39;t that be:<br>&gt; <br>&gt;    let errnoSize = MemoryLayout(errno).size<br>&gt; <br>&gt;    _class_getInstancePositiveExtentSize(bufferClass) == <br>&gt;    MemoryLayout&lt;_HeapObject&gt;.size<br>&gt; <br>&gt; ? <br>&gt; <br>&gt; Once you fix those issues, I don&#39;t find my proposal to hurt<br>&gt; readability at all.  One has to put those examples into their actual<br>&gt; contexts rather than packing them all next to one another, to evaluate<br>&gt; it fairly.<br>&gt; <br>&gt; Finally, I still object to doubling the API surface area just so you can<br>&gt; pass values instead of types to these functions.  Having three global<br>&gt; functions is acceptable, but six is too many, and arguably, having a<br>&gt; single type would be better.<br></p><p>* I sourced my examples from the stdlib. That one&#39;s from ManagedBuffer.swift.<br>Only qualification was that I was looking for examples of sizeof.<br></p><p>* In regard to offering both of and ofValue, I agree: I&#39;d rather offer half the surface area,<br>especially since Joe says the main issue is technically avoidable.<br></p><p>* I don&#39;t like having to scan past the MemoryLayout and the type in question to<br>get to the member name that defines what property is requested. You have to read it back<br>to front. I find that to be a human factors limitation that makes it less desirable to use.<br></p><p>* At the same time, what I do like about the struct is that it&#39;s extensible without introducing<br>standalone functions (and shrinks the number of functions that exist in the stdlib), and that <br>the properties express intrinsic characteristics of the memory layout of a given type. The<br>functions are measure-y. The properties are characteristic-y.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/c89c5d9e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 21, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Jun 21 2016, Joe Groff &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt; Regarding the issue of existential metatypes with sizeof:<br>&gt;<br>&gt; Pyry Jahkola points out one instance where the memorySize(type(of: …))<br>&gt; workaround won&#39;t work. When the value is an existential, it&#39;s illegal<br>&gt; to ask for the size of its dynamic type: the result can&#39;t be retrieved<br>&gt; at compile time:<br>&gt;<br>&gt; // Swift 2.2, 64-bit<br>&gt; let i = 123<br>&gt; print(sizeofValue(i)) //=&gt; 8<br>&gt; let c: CustomStringConvertible = i<br>&gt; print(sizeofValue(c)) //=&gt; 40<br>&gt; print(sizeof(c.dynamicType)) // error: cannot invoke &#39;sizeof&#39; with an argument list of type &#39;(CustomStringCo<br>&gt; This could be enabled by having sizeof and friends formally take an<br>&gt; Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of the<br>&gt; underlying builtins to be able to open existential metatypes, but it<br>&gt; seems implementable.)<br></p><p>Would it be as fully specializable down to a compile-time constant?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 1:23 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; on Tue Jun 21 2016, Joe Groff &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt; <br>&gt;&gt; Regarding the issue of existential metatypes with sizeof:<br>&gt;&gt; <br>&gt;&gt; Pyry Jahkola points out one instance where the memorySize(type(of: …))<br>&gt;&gt; workaround won&#39;t work. When the value is an existential, it&#39;s illegal<br>&gt;&gt; to ask for the size of its dynamic type: the result can&#39;t be retrieved<br>&gt;&gt; at compile time:<br>&gt;&gt; <br>&gt;&gt; // Swift 2.2, 64-bit<br>&gt;&gt; let i = 123<br>&gt;&gt; print(sizeofValue(i)) //=&gt; 8<br>&gt;&gt; let c: CustomStringConvertible = i<br>&gt;&gt; print(sizeofValue(c)) //=&gt; 40<br>&gt;&gt; print(sizeof(c.dynamicType)) // error: cannot invoke &#39;sizeof&#39; with an argument list of type &#39;(CustomStringCo<br>&gt;&gt; This could be enabled by having sizeof and friends formally take an<br>&gt;&gt; Any.Type instead of &lt;T&gt; T.Type. (This might need some tweaking of the<br>&gt;&gt; underlying builtins to be able to open existential metatypes, but it<br>&gt;&gt; seems implementable.)<br>&gt; <br>&gt; Would it be as fully specializable down to a compile-time constant?<br></p><p>Seems like it ought to be. sizeof() is just a transparent wrapper around Builtin.sizeof IIRC, and we can control the codegen of the builtin.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 21, 2016 at 12:00:00pm</p></header><div class="content"><p>I’ve given this a pretty thorough couple of readings, and experimented with the different options in my own code.<br></p><p>Global functions in Swift are a rare thing, in general the language prefers not to have them, so where we do have them I feel it’s important to get them right. Addressing them is, to me, an significant improvement to Swift and the proposal makes good steps towards that.<br></p><p>I do have some comments.<br></p><p>It is clear to me that the purpose of functions that return details about the size in memory of a type, the alignment in memory of a type, and the distance between memory of two values of a given type, are consistently within the realm of dealing with types. For example, the “what is distance between memory of a value” makes no sense as a question, the only way to make that question make sense is to instead say “what is the distance between memory of two values of the type of a value.” Likewise “what is the size in memory of the type of a value,” and “what is the alignment in memory of the type of a value.”<br></p><p>Allowing these functions to operate on values is really just a shortcut, these functions should naturally operate on types.<br></p><p>To that end, I would prefer that the “ofValue” variations be removed, and SE-0096 to be preserve as-is.<br></p><p>The proposal brings up the issue that you cannot ask for the size of an existential type, but is that actually an issue? The purpose of these functions is to permit memory allocation, low-level memory manipulation, etc. Is there ever a situation where it is valid to do this on an existential type? Isn’t the very error here a sign that the type you’re attempting to manipulate isn’t one that you should be performing low-level memory manipulation for?<br></p><p>Scott<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 21, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Generally in support, with two small exceptions:<br></p><p>1. I think the type variants should have the parameter label `of`. `memorySize(of: Int.self)` reads grammatically (other than the hopefully soon-to-be-vestigial `self`); `memorySize(Int.self)` does not.<br></p><p>2. I am not convinced that the `ofValue` variants are valuable enough to keep, although they do help support the (I think necessary, though I could probably be convinced otherwise now that these three all have a `memory` prefix) change to `type(ofValue:)`.<br></p><p>(Actually, I&#39;m now considering the idea that these should be `valueSize(of: T.Type)`, etc., since they measure only the size of the immediate value, not any objects that value might reference. But that thought is underdeveloped, so I&#39;m not ready to stand behind it.)<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes; these are inconsistent with the API guidelines.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I like that it&#39;s a little clearer what sort of &quot;size&quot; is meant; people are unlikely to imagine this will tell them an array&#39;s length, for instance.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0101: Rename sizeof and related functions to comply with API Guidelines</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1.  I prefer the MemoryLayout struct approach that Dave Abrahams has suggested.  The proposed names retain the  the disadvantage of several top level names and introduce a new disadvantage that they are not directly related to familiar terms of art (sizeof from C, etc).<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I don’t think it is a critical change given the current names are related to terms of art.  If we are going to make a change I think it is better to reduce the number of top level names and make the relationship of them clear by making them members of a type.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It fits the Swift 3 directive to do any breaking change bike shedding now.  However, the overall direction of Swift is away from top level functions without a compelling reason that a top level function is necessary.  I don’t think these cases are compelling.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>They break the tie to familiar naming from other languages.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Participated quite a bit in the initial discussion and read the final proposal.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
