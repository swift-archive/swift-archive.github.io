<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  5, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello dear Swift community,<br></p><p>this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br></p><p>Lets assume we have some sort of network type, which can throw a ton of different errors:<br></p><p>struct TCPListener {<br>		<br>	init(address: String) throws { /* implement */ }<br></p><p>	func accept() throws -&gt; TCPConn { /* implement */ }<br></p><p>	/* ... */<br>}<br></p><p>A way of implimentation might look like this:<br></p><p>let listener: TCPListener<br>do {<br>	listener = try TCPListener(&quot;some valid address&quot;)<br></p><p>	// we could do more work here, but if we need to catch more<br>	// errors we will result in a new PYRAMIDE OF DOOM<br>} catch {<br>	fatalError()<br>}<br></p><p>At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br></p><p>let clientConn: TCPConn<br>do {<br>	clientConn = try listener.accept() // save to call accept method<br>} catch {<br>	fatalError()<br>} <br></p><p>As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br></p><p>I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br></p><p>Introducing the &#39;guard try catch&#39; mechanism:<br></p><p>guard try throwingFunc() catch { <br>	/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch _ { <br>	/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern { <br>	/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern where condition { <br>	/* handle error */ <br>}<br></p><p>guard let newInstance = try throwingFuncReturns() catch ... { <br>	/* handle error */ <br>}<br></p><p>Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br></p><p>We also might want the return type to be mutable.<br></p><p>guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>	/* handle error */ <br>}<br></p><p>This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br></p><p>Lets rebuild the example from above with the new mechanism:<br></p><p>guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>	fatalError()<br>}<br></p><p>guard let clientConn = try listener.accept() catch {<br>	fatalError()<br>} <br></p><p>One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br></p><p>Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br></p><p>I&#39;m really curious about your opinions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/a6eaec2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br></p><p>Félix<br></p><p>&gt; Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello dear Swift community,<br>&gt; <br>&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt; <br>&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt; <br>&gt; struct TCPListener {<br>&gt; 	<br>&gt; 	init(address: String) throws { /* implement */ }<br>&gt; <br>&gt; 	func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt; <br>&gt; 	/* ... */<br>&gt; }<br>&gt; <br>&gt; A way of implimentation might look like this:<br>&gt; <br>&gt; let listener: TCPListener<br>&gt; do {<br>&gt; 	listener = try TCPListener(&quot;some valid address&quot;)<br>&gt; <br>&gt; 	// we could do more work here, but if we need to catch more<br>&gt; 	// errors we will result in a new PYRAMIDE OF DOOM<br>&gt; } catch {<br>&gt; 	fatalError()<br>&gt; }<br>&gt; <br>&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt; <br>&gt; let clientConn: TCPConn<br>&gt; do {<br>&gt; 	clientConn = try listener.accept() // save to call accept method<br>&gt; } catch {<br>&gt; 	fatalError()<br>&gt; } <br>&gt; <br>&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt; <br>&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt; <br>&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt; <br>&gt; guard try throwingFunc() catch { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch _ { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch pattern { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch pattern where condition { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt; <br>&gt; We also might want the return type to be mutable.<br>&gt; <br>&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt; <br>&gt; Lets rebuild the example from above with the new mechanism:<br>&gt; <br>&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt; 	fatalError()<br>&gt; }<br>&gt; <br>&gt; guard let clientConn = try listener.accept() catch {<br>&gt; 	fatalError()<br>&gt; } <br>&gt; <br>&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt; <br>&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt; <br>&gt; I&#39;m really curious about your opinions.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/40079107/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br></p><p>enum Error: ErrorType {<br>	case SomeError<br>}<br></p><p>func throwingFunc() throws {<br>	throw Error.SomeError<br>}<br></p><p>func throwingFuncReturns() throws -&gt; Int {<br>	return 0<br>}<br></p><p>do { try throwingFunc() } catch {<br>	/* do nothing */<br>}<br></p><p>var num: Int<br>do { num = try throwingFuncReturns() } catch {<br>	/* do nothing */<br>}<br></p><p>print(&quot;both fell through&quot;)<br></p><p>To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br></p><p>I think it is fine to rename the proposed mechanism.<br></p><p>do try throwingFunc() catch { <br>	/* handle error */ <br>}<br></p><p>do try throwingFunc() catch _ { <br>	/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>	/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>	/* handle error */ <br>}<br></p><p>do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>	/* handle error */ <br>}<br></p><p>do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>	/* handle error */ <br>}<br></p><p>&#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca) schrieb:<br></p><p>We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br></p><p>Félix<br></p><p>Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>Hello dear Swift community,<br></p><p>this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br></p><p>Lets assume we have some sort of network type, which can throw a ton of different errors:<br></p><p>struct TCPListener {<br>init(address: String) throws { /* implement */ }<br></p><p>func accept() throws -&gt; TCPConn { /* implement */ }<br></p><p>/* ... */<br>}<br></p><p>A way of implimentation might look like this:<br></p><p>let listener: TCPListener<br>do {<br>listener = try TCPListener(&quot;some valid address&quot;)<br></p><p>// we could do more work here, but if we need to catch more<br>// errors we will result in a new PYRAMIDE OF DOOM<br>} catch {<br>fatalError()<br>}<br></p><p>At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br></p><p>let clientConn: TCPConn<br>do {<br>clientConn = try listener.accept() // save to call accept method<br>} catch {<br>fatalError()<br>} <br></p><p>As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br></p><p>I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br></p><p>Introducing the &#39;guard try catch&#39; mechanism:<br></p><p>guard try throwingFunc() catch { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch _ { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>guard let newInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br></p><p>We also might want the return type to be mutable.<br></p><p>guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br></p><p>Lets rebuild the example from above with the new mechanism:<br></p><p>guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>fatalError()<br>}<br></p><p>guard let clientConn = try listener.accept() catch {<br>fatalError()<br>} <br></p><p>One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br></p><p>Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br></p><p>I&#39;m really curious about your opinions.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/241d8a4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Unless you&#39;re declaring a variable with a single-statement try, there&#39;s no reason to disallow fallthrough.<br></p><p>Félix<br></p><p>&gt; Le 5 févr. 2016 à 13:28:58, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br>&gt; <br>&gt; enum Error: ErrorType {<br>&gt; 	case SomeError<br>&gt; }<br>&gt; <br>&gt; func throwingFunc() throws {<br>&gt; 	throw Error.SomeError<br>&gt; }<br>&gt; <br>&gt; func throwingFuncReturns() throws -&gt; Int {<br>&gt; 	return 0<br>&gt; }<br>&gt; <br>&gt; do { try throwingFunc() } catch {<br>&gt; 	/* do nothing */<br>&gt; }<br>&gt; <br>&gt; var num: Int<br>&gt; do { num = try throwingFuncReturns() } catch {<br>&gt; 	/* do nothing */<br>&gt; }<br>&gt; <br>&gt; print(&quot;both fell through&quot;)<br>&gt; <br>&gt; To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br>&gt; <br>&gt; I think it is fine to rename the proposed mechanism.<br>&gt; <br>&gt; do try throwingFunc() catch { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; do try throwingFunc() catch _ { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; do try throwingFunc() catch pattern { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; do try throwingFunc() catch pattern { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; &#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;) schrieb:<br>&gt; <br>&gt;&gt; We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct TCPListener {<br>&gt;&gt;&gt; init(address: String) throws { /* implement */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /* ... */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A way of implimentation might look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let listener: TCPListener<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; listener = try TCPListener(&quot;some valid address&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // we could do more work here, but if we need to catch more<br>&gt;&gt;&gt; // errors we will result in a new PYRAMIDE OF DOOM<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let clientConn: TCPConn<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; clientConn = try listener.accept() // save to call accept method<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard try throwingFunc() catch { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard try throwingFunc() catch _ { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard try throwingFunc() catch pattern { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard try throwingFunc() catch pattern where condition { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We also might want the return type to be mutable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets rebuild the example from above with the new mechanism:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let clientConn = try listener.accept() catch {<br>&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m really curious about your opinions.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/0847d533/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 You are right Félix, it was only my own project that tempted me to return from each catch scope. <br></p><p>But wouldn’t this confuse everyone?<br></p><p>Here is an example:<br></p><p>do let/var newInstance = try throwingFuncReturns() catch {<br>	// can not fall through at all<br>}<br></p><p>There is no chance the compile can guarantee that `newInstance` was assigned with a value, except if `newInstance` is an optional type, so this code may not fall through like the &#39;guard‘ mechanism.<br></p><p>let newInstance: Type<br>do newInstance = try throwingFuncReturns() catch {<br>	// if not returned from here or the newInstance is not set here the compiler should raise an error<br>}<br></p><p>`newInstance` is only safe when throwing function returns without any errors or the instance was set inside the catch scope. This mimics the `if else` behavior. This can already be done with the existing `do try catch` mechanism.<br></p><p>let x: SomeThing<br>if condition {<br>	x = foo()<br>} else {<br>	x = bar()<br>}<br>use(x)<br></p><p>do try throwingFunc() catch {<br>	// can fall through if needed (this means I can ignore the error or return/break)<br>}<br></p><p>Another way do this right now would look like this:<br></p><p>do {<br>	try throwingFunc() <br>} catch _ { } // will ignore the error<br></p><p>As you can see only the first example can not fall though after catching the error, so wouldn’t it be better to support both syntax variants?<br></p><p>guard let/var newInstance = try throwingFuncReturns() catch {<br>	// can not fall through<br>}<br></p><p>let newInstance: Type<br>do newInstance = try throwingFuncReturns() catch {<br>	// if not returned from here or the newInstance is not set here the compiler should raise an error<br>}<br></p><p>do try throwingFunc() catch {<br>	// can fall through if needed (this means I can ignore the error)<br>}<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 19:40:46, Félix Cloutier (felixcca at yahoo.ca) schrieb:<br></p><p>Unless you&#39;re declaring a variable with a single-statement try, there&#39;s no reason to disallow fallthrough.<br></p><p>Félix<br></p><p>Le 5 févr. 2016 à 13:28:58, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br></p><p>enum Error: ErrorType {<br>case SomeError<br>}<br></p><p>func throwingFunc() throws {<br>throw Error.SomeError<br>}<br></p><p>func throwingFuncReturns() throws -&gt; Int {<br>return 0<br>}<br></p><p>do { try throwingFunc() } catch {<br>/* do nothing */<br>}<br></p><p>var num: Int<br>do { num = try throwingFuncReturns() } catch {<br>/* do nothing */<br>}<br></p><p>print(&quot;both fell through&quot;)<br></p><p>To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br></p><p>I think it is fine to rename the proposed mechanism.<br></p><p>do try throwingFunc() catch { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch _ { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>&#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca) schrieb:<br></p><p>We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br></p><p>Félix<br></p><p>Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>Hello dear Swift community,<br></p><p>this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br></p><p>Lets assume we have some sort of network type, which can throw a ton of different errors:<br></p><p>struct TCPListener {<br>init(address: String) throws { /* implement */ }<br></p><p>func accept() throws -&gt; TCPConn { /* implement */ }<br></p><p>/* ... */<br>}<br></p><p>A way of implimentation might look like this:<br></p><p>let listener: TCPListener<br>do {<br>listener = try TCPListener(&quot;some valid address&quot;)<br></p><p>// we could do more work here, but if we need to catch more<br>// errors we will result in a new PYRAMIDE OF DOOM<br>} catch {<br>fatalError()<br>}<br></p><p>At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br></p><p>let clientConn: TCPConn<br>do {<br>clientConn = try listener.accept() // save to call accept method<br>} catch {<br>fatalError()<br>} <br></p><p>As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br></p><p>I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br></p><p>Introducing the &#39;guard try catch&#39; mechanism:<br></p><p>guard try throwingFunc() catch { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch _ { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>guard let newInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br></p><p>We also might want the return type to be mutable.<br></p><p>guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br></p><p>Lets rebuild the example from above with the new mechanism:<br></p><p>guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>fatalError()<br>}<br></p><p>guard let clientConn = try listener.accept() catch {<br>fatalError()<br>} <br></p><p>One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br></p><p>Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br></p><p>I&#39;m really curious about your opinions.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/c9db6f6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>@Erica I wrote this example before:<br></p><p>do {<br>	let listener = try TCPListener(&quot;some address&quot;)<br></p><p>	do {<br>		let conn = try listener.accept()<br></p><p>		// do some work and catch more errors<br></p><p>		do {<br>			try conn.close()<br>		} catch {<br>			do {<br>				try listener.close()<br>			} catch {<br>				fatallError(&quot;cannot close listener&quot;)<br>			}<br>			fatallError(&quot;cannot close connection&quot;)<br>		}<br>	} catch {<br>		fatallError(&quot;cannot accept&quot;)<br>	}<br>} catch {<br>	fatallError(&quot;cannot create listener&quot;)<br>}<br></p><p>Than I realized I could avoid this pyramide of doom by doing it differently:<br></p><p>let listener: TCPListener<br>do {<br>	listener = try TCPListener(&quot;some address&quot;)<br>} catch {<br>	fatallError(&quot;cannot create listener&quot;)<br>}<br></p><p>let conn: TCPConn<br>do {<br>	conn = try listener.accept()<br>} catch {<br>	fatallError(&quot;cannot accept&quot;)<br>}<br></p><p>// do some work and catch more errors<br></p><p>do {<br>	try conn.close()<br>} catch {<br>	do {<br>		try listener.close()<br>	} catch {<br>		fatallError(&quot;cannot close listener&quot;)<br>	}<br>	fatallError(&quot;cannot close connection&quot;)<br>}<br></p><p>As you can see there is no need for the do block here. A single try-statement would do enough.<br></p><p>I could rewrite this example like this:<br></p><p>guard let listener = try TCPListener(&quot;some address&quot;) catch {<br>	fatallError(&quot;cannot create listener&quot;) // or return and try again later<br>}<br></p><p>guard let conn = try listener.accept() catch {<br>	fatallError(&quot;cannot accept&quot;)<br>}<br></p><p>// do some work and catch more errors<br></p><p>do try conn.close() catch {<br>	do try listener.close() catch {<br>		fatallError(&quot;cannot close listener&quot;)<br>	}<br>	fatallError(&quot;cannot close connection&quot;)<br>}<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 20:18:26, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>+1 You are right Félix, it was only my own project that tempted me to return from each catch scope. <br></p><p>But wouldn’t this confuse everyone?<br></p><p>Here is an example:<br></p><p>do let/var newInstance = try throwingFuncReturns() catch {<br>// can not fall through at all<br>}<br></p><p>There is no chance the compile can guarantee that `newInstance` was assigned with a value, except if `newInstance` is an optional type, so this code may not fall through like the &#39;guard‘ mechanism.<br></p><p>let newInstance: Type<br>do newInstance = try throwingFuncReturns() catch {<br>// if not returned from here or the newInstance is not set here the compiler should raise an error<br>}<br></p><p>`newInstance` is only safe when throwing function returns without any errors or the instance was set inside the catch scope. This mimics the `if else` behavior. This can already be done with the existing `do try catch` mechanism.<br></p><p>let x: SomeThing<br>if condition {<br>x = foo()<br>} else {<br>x = bar()<br>}<br>use(x)<br></p><p>do try throwingFunc() catch {<br>// can fall through if needed (this means I can ignore the error or return/break)<br>}<br></p><p>Another way do this right now would look like this:<br></p><p>do {<br>try throwingFunc() <br>} catch _ { } // will ignore the error<br></p><p>As you can see only the first example can not fall though after catching the error, so wouldn’t it be better to support both syntax variants?<br></p><p>guard let/var newInstance = try throwingFuncReturns() catch {<br>// can not fall through<br>}<br></p><p>let newInstance: Type<br>do newInstance = try throwingFuncReturns() catch {<br>// if not returned from here or the newInstance is not set here the compiler should raise an error<br>}<br></p><p>do try throwingFunc() catch {<br>// can fall through if needed (this means I can ignore the error)<br>}<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 19:40:46, Félix Cloutier (felixcca at yahoo.ca) schrieb:<br></p><p>Unless you&#39;re declaring a variable with a single-statement try, there&#39;s no reason to disallow fallthrough.<br></p><p>Félix<br></p><p>Le 5 févr. 2016 à 13:28:58, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br></p><p>enum Error: ErrorType {<br>case SomeError<br>}<br></p><p>func throwingFunc() throws {<br>throw Error.SomeError<br>}<br></p><p>func throwingFuncReturns() throws -&gt; Int {<br>return 0<br>}<br></p><p>do { try throwingFunc() } catch {<br>/* do nothing */<br>}<br></p><p>var num: Int<br>do { num = try throwingFuncReturns() } catch {<br>/* do nothing */<br>}<br></p><p>print(&quot;both fell through&quot;)<br></p><p>To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br></p><p>I think it is fine to rename the proposed mechanism.<br></p><p>do try throwingFunc() catch { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch _ { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>do try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>&#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca) schrieb:<br></p><p>We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br></p><p>Félix<br></p><p>Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>Hello dear Swift community,<br></p><p>this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br></p><p>Lets assume we have some sort of network type, which can throw a ton of different errors:<br></p><p>struct TCPListener {<br>init(address: String) throws { /* implement */ }<br></p><p>func accept() throws -&gt; TCPConn { /* implement */ }<br></p><p>/* ... */<br>}<br></p><p>A way of implimentation might look like this:<br></p><p>let listener: TCPListener<br>do {<br>listener = try TCPListener(&quot;some valid address&quot;)<br></p><p>// we could do more work here, but if we need to catch more<br>// errors we will result in a new PYRAMIDE OF DOOM<br>} catch {<br>fatalError()<br>}<br></p><p>At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br></p><p>let clientConn: TCPConn<br>do {<br>clientConn = try listener.accept() // save to call accept method<br>} catch {<br>fatalError()<br>} <br></p><p>As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br></p><p>I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br></p><p>Introducing the &#39;guard try catch&#39; mechanism:<br></p><p>guard try throwingFunc() catch { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch _ { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern { <br>/* handle error */ <br>}<br></p><p>guard try throwingFunc() catch pattern where condition { <br>/* handle error */ <br>}<br></p><p>guard let newInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br></p><p>We also might want the return type to be mutable.<br></p><p>guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>/* handle error */ <br>}<br></p><p>This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br></p><p>Lets rebuild the example from above with the new mechanism:<br></p><p>guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>fatalError()<br>}<br></p><p>guard let clientConn = try listener.accept() catch {<br>fatalError()<br>} <br></p><p>One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br></p><p>Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br></p><p>I&#39;m really curious about your opinions.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/0276fa8b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 5 févr. 2016 à 14:33, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; @Erica I wrote this example before:<br>&gt; <br>&gt; do {<br>&gt; 	let listener = try TCPListener(&quot;some address&quot;)<br>&gt; <br>&gt; 	do {<br>&gt; 		let conn = try listener.accept()<br>&gt; <br>&gt; 		// do some work and catch more errors<br>&gt; <br>&gt; 		do {<br>&gt; 			try conn.close()<br>&gt; 		} catch {<br>&gt; 			do {<br>&gt; 				try listener.close()<br>&gt; 			} catch {<br>&gt; 				fatallError(&quot;cannot close listener&quot;)<br>&gt; 			}<br>&gt; 			fatallError(&quot;cannot close connection&quot;)<br>&gt; 		}<br>&gt; 	} catch {<br>&gt; 		fatallError(&quot;cannot accept&quot;)<br>&gt; 	}<br>&gt; } catch {<br>&gt; 	fatallError(&quot;cannot create listener&quot;)<br>&gt; }<br>&gt; <br></p><p>I am no expert (and have always be scared of throws) but from what I understand the errors thrown by each method can be specific, so you can do multiple try in a single do (even though I could not find example on the web); flattening your pyramid a little bit.<br></p><p>do {<br>    let listener = try TCPListener(&quot;some address&quot;)<br>    let conn = try listener.accept()<br>    // Some more code<br>} catch SomeError.CannotCreate {<br>    fatallError(&quot;cannot create listener&quot;)<br>} catch SomeError.Rejection {<br>    fatallError(&quot;cannot accept&quot;)<br>} catch {<br>    fatallError(&quot;Unknown&quot;)<br>}<br></p><p>So once restructured, is the pyramid still that bad?<br></p><p>Dany<br></p><p>&gt; Than I realized I could avoid this pyramide of doom by doing it differently:<br>&gt; <br>&gt; let listener: TCPListener<br>&gt; do {<br>&gt; 	listener = try TCPListener(&quot;some address&quot;)<br>&gt; } catch {<br>&gt; 	fatallError(&quot;cannot create listener&quot;)<br>&gt; }<br>&gt; <br>&gt; let conn: TCPConn<br>&gt; do {<br>&gt; 	conn = try listener.accept()<br>&gt; } catch {<br>&gt; 	fatallError(&quot;cannot accept&quot;)<br>&gt; }<br>&gt; <br>&gt; // do some work and catch more errors<br>&gt; <br>&gt; do {<br>&gt; 	try conn.close()<br>&gt; } catch {<br>&gt; 	do {<br>&gt; 		try listener.close()<br>&gt; 	} catch {<br>&gt; 		fatallError(&quot;cannot close listener&quot;)<br>&gt; 	}<br>&gt; 	fatallError(&quot;cannot close connection&quot;)<br>&gt; }<br>&gt; <br>&gt; As you can see there is no need for the do block here. A single try-statement would do enough.<br>&gt; <br>&gt; I could rewrite this example like this:<br>&gt; <br>&gt; guard let listener = try TCPListener(&quot;some address&quot;) catch {<br>&gt; 	fatallError(&quot;cannot create listener&quot;) // or return and try again later<br>&gt; }<br>&gt; <br>&gt; guard let conn = try listener.accept() catch {<br>&gt; 	fatallError(&quot;cannot accept&quot;)<br>&gt; }<br>&gt; <br>&gt; // do some work and catch more errors<br>&gt; <br>&gt; do try conn.close() catch {<br>&gt; 	do try listener.close() catch {<br>&gt; 		fatallError(&quot;cannot close listener&quot;)<br>&gt; 	}<br>&gt; 	fatallError(&quot;cannot close connection&quot;)<br>&gt; }<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 5. Februar 2016 bei 20:18:26, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; +1 You are right Félix, it was only my own project that tempted me to return from each catch scope. <br>&gt;&gt; <br>&gt;&gt; But wouldn’t this confuse everyone?<br>&gt;&gt; <br>&gt;&gt; Here is an example:<br>&gt;&gt; <br>&gt;&gt; do let/var newInstance = try throwingFuncReturns() catch {<br>&gt;&gt; // can not fall through at all<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There is no chance the compile can guarantee that `newInstance` was assigned with a value, except if `newInstance` is an optional type, so this code may not fall through like the &#39;guard‘ mechanism.<br>&gt;&gt; <br>&gt;&gt; let newInstance: Type<br>&gt;&gt; do newInstance = try throwingFuncReturns() catch {<br>&gt;&gt; // if not returned from here or the newInstance is not set here the compiler should raise an error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; `newInstance` is only safe when throwing function returns without any errors or the instance was set inside the catch scope. This mimics the `if else` behavior. This can already be done with the existing `do try catch` mechanism.<br>&gt;&gt; <br>&gt;&gt; let x: SomeThing<br>&gt;&gt; if condition {<br>&gt;&gt; x = foo()<br>&gt;&gt; } else {<br>&gt;&gt; x = bar()<br>&gt;&gt; }<br>&gt;&gt; use(x)<br>&gt;&gt; <br>&gt;&gt; do try throwingFunc() catch {<br>&gt;&gt; // can fall through if needed (this means I can ignore the error or return/break)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Another way do this right now would look like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; try throwingFunc() <br>&gt;&gt; } catch _ { } // will ignore the error<br>&gt;&gt; <br>&gt;&gt; As you can see only the first example can not fall though after catching the error, so wouldn’t it be better to support both syntax variants?<br>&gt;&gt; <br>&gt;&gt; guard let/var newInstance = try throwingFuncReturns() catch {<br>&gt;&gt; // can not fall through<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let newInstance: Type<br>&gt;&gt; do newInstance = try throwingFuncReturns() catch {<br>&gt;&gt; // if not returned from here or the newInstance is not set here the compiler should raise an error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; do try throwingFunc() catch {<br>&gt;&gt; // can fall through if needed (this means I can ignore the error)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 5. Februar 2016 bei 19:40:46, Félix Cloutier (felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Unless you&#39;re declaring a variable with a single-statement try, there&#39;s no reason to disallow fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 5 févr. 2016 à 13:28:58, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Error: ErrorType {<br>&gt;&gt;&gt;&gt; case SomeError<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func throwingFunc() throws {<br>&gt;&gt;&gt;&gt; throw Error.SomeError<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func throwingFuncReturns() throws -&gt; Int {<br>&gt;&gt;&gt;&gt; return 0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do { try throwingFunc() } catch {<br>&gt;&gt;&gt;&gt; /* do nothing */<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var num: Int<br>&gt;&gt;&gt;&gt; do { num = try throwingFuncReturns() } catch {<br>&gt;&gt;&gt;&gt; /* do nothing */<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(&quot;both fell through&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it is fine to rename the proposed mechanism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do try throwingFunc() catch { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do try throwingFunc() catch _ { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do try throwingFunc() catch pattern { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do try throwingFunc() catch pattern { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct TCPListener {<br>&gt;&gt;&gt;&gt;&gt;&gt; init(address: String) throws { /* implement */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /* ... */<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A way of implimentation might look like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let listener: TCPListener<br>&gt;&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;&gt; listener = try TCPListener(&quot;some valid address&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // we could do more work here, but if we need to catch more<br>&gt;&gt;&gt;&gt;&gt;&gt; // errors we will result in a new PYRAMIDE OF DOOM<br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let clientConn: TCPConn<br>&gt;&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;&gt; clientConn = try listener.accept() // save to call accept method<br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch _ { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch pattern { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch pattern where condition { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We also might want the return type to be mutable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Lets rebuild the example from above with the new mechanism:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let clientConn = try listener.accept() catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m really curious about your opinions.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/c0986d6e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  6, 2016 at 08:00:00am</p></header><div class="content"><p>It is possible in a lighter project, but its no fun to build an ErrorType for this: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/errno.h<br></p><p>Here is a snippet from my current project I’m working on:<br></p><p>public enum TCPBug: ErrorType {<br>		<br>	case NetworkError(code: Int32, message: String)<br>	case FileError(code: Int32, message: String)<br>		<br>	@noreturn private static func raise(type: TCPBugType) throws {<br>			<br>		let errorCode = errno<br>		let errorMessage = String.fromCString(strerror(errorCode))!<br>			<br>		switch type {<br>				<br>		case .Network:<br>			throw TCPBug.NetworkError(code: errorCode, message: errorMessage)<br>		case .File:<br>			throw TCPBug.FileError(code: errorCode, message: errorMessage)<br>		}<br>	}<br>}<br></p><p>As you might guess from errno.h there are a lot a different errors that could be thrown. And as I described in my previous post I could handle errors where they occur, so there won’t be any new pyramid. <br></p><p>Anyways, from my perspective Swift does need a single &#39;do try catch‘ mechanism which escapes the &#39;do { }‘ scope. The only one problem we found is that declaring a new constant/variable inside a single ‘do try catch’ statement can not fall through from the catch body (like the &#39;guard&#39; mechanism).<br></p><p>Best regards, <br>Adrian Zubarev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/6fe888ce/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  5, 2016 at 05:00:00pm</p></header><div class="content"><p>The privileged `guard` syntax is convenient because optionals can propagate to variables and the most convenient way to safely unwrap an Optional is to use pattern matching. However, AFAIK, you can&#39;t save the wrapped result of a throwing function into a variable: you need to unwrap it as the call is made. This means that you can always write:<br></p><p>let foo: Int<br>do foo = try funcThatThrows() catch { /* snip */ }<br></p><p>You can fall through, but if you do, `foo` will be in a quantum superposition state of &quot;initialized&quot; and &quot;not initialized&quot;, meaning that you won&#39;t be able to access it or initialize it, so if fallthrough wasn&#39;t intentional, you should find out pretty quickly.<br></p><p>I do agree that it would be a little prettier if the declaration was on the same line as the assignment.<br></p><p>Félix<br></p><p>&gt; Le 5 févr. 2016 à 14:18:25, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1 You are right Félix, it was only my own project that tempted me to return from each catch scope. <br>&gt; <br>&gt; But wouldn’t this confuse everyone?<br>&gt; <br>&gt; Here is an example:<br>&gt; <br>&gt; do let/var newInstance = try throwingFuncReturns() catch {<br>&gt; 	// can not fall through at all<br>&gt; }<br>&gt; <br>&gt; There is no chance the compile can guarantee that `newInstance` was assigned with a value, except if `newInstance` is an optional type, so this code may not fall through like the &#39;guard‘ mechanism.<br>&gt; <br>&gt; let newInstance: Type<br>&gt; do newInstance = try throwingFuncReturns() catch {<br>&gt; 	// if not returned from here or the newInstance is not set here the compiler should raise an error<br>&gt; }<br>&gt; <br>&gt; `newInstance` is only safe when throwing function returns without any errors or the instance was set inside the catch scope. This mimics the `if else` behavior. This can already be done with the existing `do try catch` mechanism.<br>&gt; <br>&gt; let x: SomeThing<br>&gt; if condition {<br>&gt; 	x = foo()<br>&gt; } else {<br>&gt; 	x = bar()<br>&gt; }<br>&gt; use(x)<br>&gt; <br>&gt; do try throwingFunc() catch {<br>&gt; 	// can fall through if needed (this means I can ignore the error or return/break)<br>&gt; }<br>&gt; <br>&gt; Another way do this right now would look like this:<br>&gt; <br>&gt; do {<br>&gt; 	try throwingFunc() <br>&gt; } catch _ { } // will ignore the error<br>&gt; <br>&gt; As you can see only the first example can not fall though after catching the error, so wouldn’t it be better to support both syntax variants?<br>&gt; <br>&gt; guard let/var newInstance = try throwingFuncReturns() catch {<br>&gt; 	// can not fall through<br>&gt; }<br>&gt; <br>&gt; let newInstance: Type<br>&gt; do newInstance = try throwingFuncReturns() catch {<br>&gt; 	// if not returned from here or the newInstance is not set here the compiler should raise an error<br>&gt; }<br>&gt; <br>&gt; do try throwingFunc() catch {<br>&gt; 	// can fall through if needed (this means I can ignore the error)<br>&gt; }<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 5. Februar 2016 bei 19:40:46, Félix Cloutier (felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;) schrieb:<br>&gt; <br>&gt;&gt; Unless you&#39;re declaring a variable with a single-statement try, there&#39;s no reason to disallow fallthrough.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 5 févr. 2016 à 13:28:58, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now the error handling mechanism will fall through even if the error was handled inside the catch scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Error: ErrorType {<br>&gt;&gt;&gt; case SomeError<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func throwingFunc() throws {<br>&gt;&gt;&gt; throw Error.SomeError<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func throwingFuncReturns() throws -&gt; Int {<br>&gt;&gt;&gt; return 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do { try throwingFunc() } catch {<br>&gt;&gt;&gt; /* do nothing */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var num: Int<br>&gt;&gt;&gt; do { num = try throwingFuncReturns() } catch {<br>&gt;&gt;&gt; /* do nothing */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(&quot;both fell through&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To guarantee the safety of the execution from my point of view the catch body may not fall through (for single try statements), at least not by default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it is fine to rename the proposed mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do try throwingFunc() catch { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do try throwingFunc() catch _ { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do try throwingFunc() catch pattern { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do try throwingFunc() catch pattern { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do let newInstance = try throwingFuncReturns() catch catch pattern where condition { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do var newMutableInstance = try throwingFuncReturns() catch pattern where condition { <br>&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;Where&#39; clause is significant for catching wider range of errors that might occur.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 5. Februar 2016 bei 19:05:12, Félix Cloutier (felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello dear Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct TCPListener {<br>&gt;&gt;&gt;&gt;&gt; init(address: String) throws { /* implement */ }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /* ... */<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A way of implimentation might look like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let listener: TCPListener<br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt; listener = try TCPListener(&quot;some valid address&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // we could do more work here, but if we need to catch more<br>&gt;&gt;&gt;&gt;&gt; // errors we will result in a new PYRAMIDE OF DOOM<br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let clientConn: TCPConn<br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt; clientConn = try listener.accept() // save to call accept method<br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch _ { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch pattern { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard try throwingFunc() catch pattern where condition { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We also might want the return type to be mutable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt;&gt;&gt;&gt; /* handle error */ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Lets rebuild the example from above with the new mechanism:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let clientConn = try listener.accept() catch {<br>&gt;&gt;&gt;&gt;&gt; fatalError()<br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m really curious about your opinions.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/2961a5ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>February  7, 2016 at 11:00:00am</p></header><div class="content"><p>@Félix as far as I know you won’t be able to fall through be accident:<br></p><p>func throwingFuncReturns() throws -&gt; Int? {<br>	return 42<br>}<br></p><p>func use(foo: Int) {<br>	print(foo)<br>}<br></p><p>func scope() {<br>		<br>	let foo: Int? // saving will work as long as the type is an optional too<br></p><p>	do { foo = try throwingFuncReturns() } catch { <br></p><p>		// INITIALIZE foo OR RETURN &lt;-- copiler will be happy<br>	}<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br></p><p>scope() // to be able to return<br></p><p>This was added in Swift 1.2 for `if else` as far as I know.<br></p><p>let x: SomeThing<br>if condition {<br>	x = foo()<br>} else {<br>	x = bar()<br>}<br>use(x)<br></p><p>So porting this behavior to a single `do try catch` will work as it did before:<br></p><p>func scope() {<br>		<br>	let foo: Int? // saving will work as long as the type is an optional too<br></p><p>	do foo = try throwingFuncReturns() catch { <br>		// INITIALIZE foo OR RETURN &lt;-- copiler will be happy<br>	}<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br></p><p>Simplifying everything with the `guard` syntax might help us with optionals, but it automatically will close the door for `fallthrough`, because the original mechanism does not work this way. This will just confuse everyone.<br></p><p>It might sound absurd, but what if we remove the `do` keyword from the single `do try catch` and leave it as `try catch` with the some new behavior:<br></p><p>func scope() {<br>		<br>	let foo: Int? = try throwingFuncReturns() catch { <br>		// foo IS AVAILABLE INSIDE THE CATCH BODY<br>		// INITIALIZE foo OR RETURN<br>	}<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br></p><p>The `do` body is needed if we want to execute more than one operation from its body, but it isn’t needed for a single `try catch` mechanism at all. So why would we want to keep the keyword here? We can omit the type from the throwing function that returns a value if no errors occurred. Plus we could apply an extra rule and assign the value from the catch body then fall through or return/break.<br></p><p>This also won’t have any impact on existing codebase.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/3a6ca71e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Having foo available within the catch would be very strange as it is not yet in scope.<br></p><p>-Thorsten <br></p><p>&gt; Am 07.02.2016 um 11:00 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; @Félix as far as I know you won’t be able to fall through be accident:<br>&gt; <br>&gt; func throwingFuncReturns() throws -&gt; Int? {<br>&gt; 	return 42<br>&gt; }<br>&gt; <br>&gt; func use(foo: Int) {<br>&gt; 	print(foo)<br>&gt; }<br>&gt; <br>&gt; func scope() {<br>&gt; 	<br>&gt; 	let foo: Int? // saving will work as long as the type is an optional too<br>&gt; <br>&gt; 	do { foo = try throwingFuncReturns() } catch { <br>&gt; <br>&gt; 		// INITIALIZE foo OR RETURN &lt;-- copiler will be happy<br>&gt; 	}<br>&gt; 	guard let unwrappedFoo = foo else { <br>&gt; 		return<br>&gt; 	}<br>&gt; 	use(unwrappedFoo)<br>&gt; }<br>&gt; <br>&gt; scope() // to be able to return<br>&gt; <br>&gt; This was added in Swift 1.2 for `if else` as far as I know.<br>&gt; <br>&gt; let x: SomeThing<br>&gt; if condition {<br>&gt; 	x = foo()<br>&gt; } else {<br>&gt; 	x = bar()<br>&gt; }<br>&gt; use(x)<br>&gt; <br>&gt; So porting this behavior to a single `do try catch` will work as it did before:<br>&gt; <br>&gt; func scope() {<br>&gt; 	<br>&gt; 	let foo: Int? // saving will work as long as the type is an optional too<br>&gt; <br>&gt; 	do foo = try throwingFuncReturns() catch { <br>&gt; 		// INITIALIZE foo OR RETURN &lt;-- copiler will be happy<br>&gt; 	}<br>&gt; 	guard let unwrappedFoo = foo else { <br>&gt; 		return<br>&gt; 	}<br>&gt; 	use(unwrappedFoo)<br>&gt; }<br>&gt; <br>&gt; Simplifying everything with the `guard` syntax might help us with optionals, but it automatically will close the door for `fallthrough`, because the original mechanism does not work this way. This will just confuse everyone.<br>&gt; <br>&gt; It might sound absurd, but what if we remove the `do` keyword from the single `do try catch` and leave it as `try catch` with the some new behavior:<br>&gt; <br>&gt; func scope() {<br>&gt; 	<br>&gt; 	let foo: Int? = try throwingFuncReturns() catch { <br>&gt; 		// foo IS AVAILABLE INSIDE THE CATCH BODY<br>&gt; 		// INITIALIZE foo OR RETURN<br>&gt; 	}<br>&gt; 	guard let unwrappedFoo = foo else { <br>&gt; 		return<br>&gt; 	}<br>&gt; 	use(unwrappedFoo)<br>&gt; }<br>&gt; <br>&gt; The `do` body is needed if we want to execute more than one operation from its body, but it isn’t needed for a single `try catch` mechanism at all. So why would we want to keep the keyword here? We can omit the type from the throwing function that returns a value if no errors occurred. Plus we could apply an extra rule and assign the value from the catch body then fall through or return/break.<br>&gt; <br>&gt; This also won’t have any impact on existing codebase.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/06483574/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  5, 2016 at 07:00:00pm</p></header><div class="content"><p>The only reason to favour guard is to have the compiler force you to exit the containing scope.<br></p><p>&gt; On 05 Feb 2016, at 19:05, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We could do it without a new guard syntax if `do` didn&#39;t need a block statement.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 5 févr. 2016 à 12:54:47, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hello dear Swift community,<br>&gt;&gt; <br>&gt;&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt;&gt; <br>&gt;&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt;&gt; <br>&gt;&gt; struct TCPListener {<br>&gt;&gt; 	<br>&gt;&gt; 	init(address: String) throws { /* implement */ }<br>&gt;&gt; <br>&gt;&gt; 	func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt;&gt; <br>&gt;&gt; 	/* ... */<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A way of implimentation might look like this:<br>&gt;&gt; <br>&gt;&gt; let listener: TCPListener<br>&gt;&gt; do {<br>&gt;&gt; 	listener = try TCPListener(&quot;some valid address&quot;)<br>&gt;&gt; <br>&gt;&gt; 	// we could do more work here, but if we need to catch more<br>&gt;&gt; 	// errors we will result in a new PYRAMIDE OF DOOM<br>&gt;&gt; } catch {<br>&gt;&gt; 	fatalError()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt;&gt; <br>&gt;&gt; let clientConn: TCPConn<br>&gt;&gt; do {<br>&gt;&gt; 	clientConn = try listener.accept() // save to call accept method<br>&gt;&gt; } catch {<br>&gt;&gt; 	fatalError()<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt;&gt; <br>&gt;&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt;&gt; <br>&gt;&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt;&gt; <br>&gt;&gt; guard try throwingFunc() catch { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard try throwingFunc() catch _ { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard try throwingFunc() catch pattern { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard try throwingFunc() catch pattern where condition { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt;&gt; <br>&gt;&gt; We also might want the return type to be mutable.<br>&gt;&gt; <br>&gt;&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt;&gt; 	/* handle error */ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt;&gt; <br>&gt;&gt; Lets rebuild the example from above with the new mechanism:<br>&gt;&gt; <br>&gt;&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt;&gt; 	fatalError()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard let clientConn = try listener.accept() catch {<br>&gt;&gt; 	fatalError()<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt;&gt; <br>&gt;&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt;&gt; <br>&gt;&gt; I&#39;m really curious about your opinions.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/cf95faff/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal]: Escaping another (unused) scope pyramide with &#39;guard try catch&#39;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  5, 2016 at 11:00:00am</p></header><div class="content"><p>I am having problems trying to understand why you&#39;d want to circumvent the throwing chain and perform error handling and recovery late in the call tree rather than at the root point that initiated the request.  <br></p><p>-- Erica<br></p><p><br>&gt; On Feb 5, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello dear Swift community,<br>&gt; <br>&gt; this proposal might seem like some new syntax sugar, but it also aims to escape the &#39;do { }&#39; scope from the &#39;do try catch‘ mechanism while making the existing error handling more powerful.<br>&gt; <br>&gt; Lets assume we have some sort of network type, which can throw a ton of different errors:<br>&gt; <br>&gt; struct TCPListener {<br>&gt; 	<br>&gt; 	init(address: String) throws { /* implement */ }<br>&gt; <br>&gt; 	func accept() throws -&gt; TCPConn { /* implement */ }<br>&gt; <br>&gt; 	/* ... */<br>&gt; }<br>&gt; <br>&gt; A way of implimentation might look like this:<br>&gt; <br>&gt; let listener: TCPListener<br>&gt; do {<br>&gt; 	listener = try TCPListener(&quot;some valid address&quot;)<br>&gt; <br>&gt; 	// we could do more work here, but if we need to catch more<br>&gt; 	// errors we will result in a new PYRAMIDE OF DOOM<br>&gt; } catch {<br>&gt; 	fatalError()<br>&gt; }<br>&gt; <br>&gt; At this point think about the comment inside the &#39;do { }&#39; scope. Such an application might result in a new pyramide of doom as we know from optional unwrapping before &#39;guard else&#39; mechanism was introduced.<br>&gt; <br>&gt; let clientConn: TCPConn<br>&gt; do {<br>&gt; 	clientConn = try listener.accept() // save to call accept method<br>&gt; } catch {<br>&gt; 	fatalError()<br>&gt; } <br>&gt; <br>&gt; As you can see this application might not need the extra &#39;do&#39; scope at all, and if it does, the &#39;do try catch&#39; is still there.<br>&gt; <br>&gt; I propose a new error handling mechanism that mimics the solution for optional pyramide of doom, which adds a slightly better syntax and removes the unneeded/unused &#39;do { }&#39; scope (as for the example from above). Not only can this mechanism guarantee the execution of a throwing function without any errors (like a true guard condition) it also can assign returned values to a new constant/variable.<br>&gt; <br>&gt; Introducing the &#39;guard try catch&#39; mechanism:<br>&gt; <br>&gt; guard try throwingFunc() catch { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch _ { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch pattern { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard try throwingFunc() catch pattern where condition { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; guard let newInstance = try throwingFuncReturns() catch ... { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; Where &#39;...&#39; represents the different combinations of possible patterns already showed in the first 4 examples.<br>&gt; <br>&gt; We also might want the return type to be mutable.<br>&gt; <br>&gt; guard var newMutableInstance = try throwingFuncReturns() catch ... { <br>&gt; 	/* handle error */ <br>&gt; }<br>&gt; <br>&gt; This mechanism also makes the error handling more powerful, since it can catch more specific errors defined with &#39;where condition&#39;.<br>&gt; <br>&gt; Lets rebuild the example from above with the new mechanism:<br>&gt; <br>&gt; guard let listener = try TCPListener(&quot;some valid address&quot;) catch {<br>&gt; 	fatalError()<br>&gt; }<br>&gt; <br>&gt; guard let clientConn = try listener.accept() catch {<br>&gt; 	fatalError()<br>&gt; } <br>&gt; <br>&gt; One think that should be mentioned here is that the method call from the second &#39;guard&#39; is safe, because a &#39;guard&#39; body may not fall through.<br>&gt; <br>&gt; Impact on existing codebase: None, because the mechanism is new and does not break any existing code.<br>&gt; <br>&gt; I&#39;m really curious about your opinions.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/d3a0b813/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
