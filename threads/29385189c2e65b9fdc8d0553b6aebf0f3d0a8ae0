<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 10:00:00am</p></header><div class="content"><p>on Sun Jan 24 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Good/important examples.<br>&gt;<br>&gt; The problem here seems to be that &quot;sin&quot;, &quot;mean&quot;, &quot;remainder&quot;, etc. read<br>&gt; nicely as noun phrases, but the guidelines would recommend -ed/-ing verb<br>&gt; forms in this case (methods with both mutating and nonmutating variants),<br>&gt; not noun phrases:<br>&gt;<br>&gt;     &quot;*When a mutating method is described by a verb, name its nonmutating<br>&gt; counterpart according to the &#39;ed/ing&#39; rule*.&quot;<br>&gt;<br>&gt; ...but we don&#39;t have a verb to which to apply -ed or -ing. (&quot;sined&quot;?<br>&gt; &quot;meaned&quot;? &quot;remaindered&quot;?)<br>&gt;<br>&gt; I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot; seem to<br>&gt; work pretty well, but I&#39;m aware that I&#39;m drawing on experience with the old<br>&gt; names of sortInPlace(), subtractInPlace(), etc., and in fact this case is<br>&gt; worse because the first words aren&#39;t really verbs (you can&#39;t sine something *in<br>&gt; place* any more than you can sine it). &quot;takeSine()&quot; doesn&#39;t sound great<br>&gt; either.<br></p><p>Nope, InPlace becomes a term-of-art in these cases.<br>x.replaceWithTheResultOfApplyingSin() is linguistically correct, but too<br>unwieldly to be a serious contender.<br></p><p>We&#39;d be very happy to have a better alternative than InPlace for these<br>cases, but so far, we haven&#39;t found any.<br></p><p>&gt; One option is to simply not offer mutating versions of these methods; then<br>&gt; users can write &quot;y=y.remainder()&quot; with only two extra characters (four with<br>&gt; spaces). IMO this is awkward; it also kinda necessitates an<br>&gt; isUniquelyReferenced check to avoid unnecessary copying.<br></p><p>Unfortunately, an isUniquelyReferenced check can&#39;t actually solve the<br>problem.  The language semantics force an additional reference going<br>into the union method when you write<br></p><p>     x = x.union(y)<br></p><p>It&#39;s also useless for scenarios like<br></p><p>     a[x] = a[x].union(y)<br></p><p>&gt; Jacob &quot;no useful suggestions to see here&quot; Bandes-Storch<br>&gt;<br>&gt; On Sat, Jan 23, 2016 at 11:36 PM, Tyler Fleming Cloutier via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is a very real problem. It has come up a nontrivial number of times<br>&gt;&gt; during my attempt to conform Surge &lt;https://github.com/mattt/Surge&gt; to<br>&gt;&gt; the API Guideline. My work in progress version is here<br>&gt;&gt; &lt;https://github.com/TheArtOfEngineering/Jolt&gt;.<br>&gt;&gt;<br>&gt;&gt; Surge is in essence Swift a wrapper around the Accelerate framework.<br>&gt;&gt; Originally the Surge API was constructed as a collection of global<br>&gt;&gt; functions that mirrored the Accelerate framework exactly. I’m currently<br>&gt;&gt; attempting to bring the API in line with the API Guideline and to extend<br>&gt;&gt; CollectionType to have methods with these operations.<br>&gt;&gt;<br>&gt;&gt; Thus I have three different types of API end points.<br>&gt;&gt;<br>&gt;&gt; - Global functions<br>&gt;&gt; - Non-mutating methods<br>&gt;&gt; - Mutating methods<br>&gt;&gt;<br>&gt;&gt; These distinctions could potentially be important given that these are all<br>&gt;&gt; performance critical vector operations. Also given that this is extending<br>&gt;&gt; the Accelerate framework many functions are named in mathematical terms,<br>&gt;&gt; which makes them more difficult to name according to the current<br>&gt;&gt; guidelines. Consider the following functions.<br>&gt;&gt;<br>&gt;&gt; First let’s consider a function like `add` which operates on vectors and<br>&gt;&gt; whose output is also a vector. This function is straightforward to conform<br>&gt;&gt; to the API Guidelines, the result of which is quite satisfying.<br>&gt;&gt;<br>&gt;&gt; The global function is called `add`, the mutating method is called `add`,<br>&gt;&gt; and the non-mutating method is called `adding`.<br>&gt;&gt; add(x, y) vs x.add(y) vs x.adding(y)<br>&gt;&gt;<br>&gt;&gt; Excellent.<br>&gt;&gt;<br>&gt;&gt; Next, however, consider the vector function `sum`. In this case the global<br>&gt;&gt; function is named `sum`. There is no corresponding mutating method for<br>&gt;&gt; `sum` since it does not output a vector. Should the non-mutating method<br>&gt;&gt; therefore be called `sum` or `summed`? The Guideline is not so explicit<br>&gt;&gt; about this. You could conceivably make an argument for either, although I<br>&gt;&gt; think `sum` would win out because there is no non-mutating version. If<br>&gt;&gt; there is no current mutating version for an API, but there could<br>&gt;&gt; conceivably be one in the future, I assume that it should use the ‘ed/ing&#39;<br>&gt;&gt; rule.<br>&gt;&gt;<br>&gt;&gt; sum(myVec) vs myVec.sum() // &lt;- this is non-mutating<br>&gt;&gt;<br>&gt;&gt; So far, acceptable.<br>&gt;&gt;<br>&gt;&gt; What about the function `sin`?<br>&gt;&gt;<br>&gt;&gt; Again, the global function is just `sin`. How, though, do you distinguish<br>&gt;&gt; the mutating and non-mutating methods?<br>&gt;&gt;<br>&gt;&gt; sin(x) vs x.sin() vs x.sined()?<br>&gt;&gt;<br>&gt;&gt; Fortunately, the API Guideline does have a comment on this. In the case of<br>&gt;&gt; `sin`, it is reasonable to only provide the global function in accordance<br>&gt;&gt; with mathematical convention. The problem is that memory constricted<br>&gt;&gt; environments may require that the calculation be done in place. What that<br>&gt;&gt; should look like is not clear.<br>&gt;&gt;<br>&gt;&gt; What about functions that are almost always abbreviated by convention like<br>&gt;&gt; `ceil`?<br>&gt;&gt;<br>&gt;&gt; ceil(x) vs x.ceil() vs x.ceiled()<br>&gt;&gt;<br>&gt;&gt; In this case the InPlace prefix can save us. x.ceilInPlace() would work.<br>&gt;&gt;<br>&gt;&gt; Another good one is `remainder`.<br>&gt;&gt;<br>&gt;&gt; remainder(x) vs x.remainder() vs x.remaindered() ?<br>&gt;&gt;<br>&gt;&gt; These are just a few examples, but there are many many others in this API<br>&gt;&gt; alone that the Guidelines struggle to address. Most are problematic for the<br>&gt;&gt; same reasons outlined above. If it weren’t necessarily critical to reduce<br>&gt;&gt; memory use it would suffice to just include the global function for many of<br>&gt;&gt; them.<br>&gt;&gt;<br>&gt;&gt; e.g.<br>&gt;&gt; reciprocal<br>&gt;&gt; threshold<br>&gt;&gt; floor<br>&gt;&gt; abs -&gt; ???<br>&gt;&gt; exp -&gt; x.exponentiated()?<br>&gt;&gt; exp2 or expSquared<br>&gt;&gt; logb<br>&gt;&gt; mean<br>&gt;&gt; dot<br>&gt;&gt; cross<br>&gt;&gt;<br>&gt;&gt; For some functions like `dot` we could conceivably rely on the fact that<br>&gt;&gt; familiar users would know that the return type is not the same as the<br>&gt;&gt; arguments. I would argue however, that, if we were going to rely on the<br>&gt;&gt; type information of the returned value then perhaps that’s what should be<br>&gt;&gt; relied on exclusively to determine whether a method is mutating or not.<br>&gt;&gt;<br>&gt;&gt; All mutating methods should return Void and all non mutating methods<br>&gt;&gt; should have @warn_unused_result. Thus the context would distinguish it’s<br>&gt;&gt; mutability. Not a huge fan of this, but with the unused warning result it’s<br>&gt;&gt; not too bad.<br>&gt;&gt;<br>&gt;&gt; For example.<br>&gt;&gt;<br>&gt;&gt; let y = [...]<br>&gt;&gt; let x = y.remainder()<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; var y = […]<br>&gt;&gt; y.remainder()<br>&gt;&gt;<br>&gt;&gt; I hope this helps to give a little bit of color on a real world example<br>&gt;&gt; outside of the standard library.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 23, 2016, at 11:00 AM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jan 22 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; How do you handle naming non-mutating versions of these operations?<br>&gt;&gt; Conjugating other irregular verbs also imposes a barrier on<br>&gt;&gt; developers whose first language is not English.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Swift could use “after” as a prefix, or something similar.<br>&gt;&gt;<br>&gt;&gt; array.sort()<br>&gt;&gt; array.afterSort()<br>&gt;&gt;<br>&gt;&gt; I was tempted to say “afterSorting()” but that has the same problems<br>&gt;&gt; mentioned above.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s reminiscent of the way the classic Cocoa naming guidelines<br>&gt;&gt; cleverly avoided these issues by using the &#39;did-&#39; prefix consistently<br>&gt;&gt; instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a<br>&gt;&gt; bit awkward, though, as are any other equivalent prefixes i can think<br>&gt;&gt; of that have the same effect on the past participle (havingSplit?<br>&gt;&gt; bySplitting?)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;splitting&quot; works perfectly well on its own, IMO.  If there&#39;s an<br>&gt;&gt; argument to the method, you&#39;ll want some kind of preposition like &quot;At&quot;<br>&gt;&gt; or &quot;On&quot; afterwards.<br>&gt;&gt;<br>&gt;&gt; I think the real problem cases for this guideline as written are the<br>&gt;&gt; ones where there&#39;s no underlying verb, like &quot;union&quot;, or where the verb<br>&gt;&gt; already has a strong non-mutating connotation, like &quot;exclusiveOr.&quot;<br>&gt;&gt; Those are the ones that really cry out for a different convention, like<br>&gt;&gt; &quot;InPlace.&quot;<br>&gt;&gt;<br>&gt;&gt; In developing the guidelines, we had some internal arguments about<br>&gt;&gt; whether it was worth adding complexity to accomodate those cases, or<br>&gt;&gt; whether we should simply not mention them and let them get sorted out on<br>&gt;&gt; a case-by-case basis when they come up in code review.  We didn&#39;t reach<br>&gt;&gt; consensus, so this would be a useful area in which to get community<br>&gt;&gt; input.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
