<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268e1090c88890a4ed2387a4d22c661c?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>J.E. Schotsman</string> &lt;jeschot at xs4all.nl&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>The only reason I can think of writing a function with a force-unwrapped parameter is overriding an API function with such a signature, as Chris mentioned.<br></p><p>If the function actually doesn’t accept nil you might feel obliged to start the function with something like<br></p><p>precondition( IUO argument != nil, “this method cannot handle nil”)<br></p><p>in order to at least provide a message rather than just crashing.<br></p><p>As for consistency and symmetry I don’t think the current practice meets these criteria.<br>In your own code an IUO means “only use if you are sure it’s non-nil” whereas in imported APIs it means “enter nil at your own risk”.<br>If the unwrap shorthand `if let x!` would be accepted it would mean “if unwrap succeeds use as if it’s an IUO instead of an ordinary optional”. <br>That would make three shades of weirdness. I like it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  1, 2016 at 06:00:00am</p></header><div class="content"><p>I find it useful when dealing with (NS)URLs. I have a project that deals with URLs an awful lot and it would be incredible pain to deal to check if each URL is nonnil at call site.<br></p><p>What I do instead is use IUO arguments in methods where I pass the URLs to. The IUO nicely indicates &quot;This argument should not be nil on most occasions, but may be under some circumstances.&quot; The only thing I need to do at the top of the method is guard url != nil else  { return }.<br></p><p>Sure, I could do this with optional + shadowing original argument var with guard let url = url else { return }, but I find it easier this way.<br></p><p>&gt; On Jun 30, 2016, at 5:55 PM, J.E. Schotsman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The only reason I can think of writing a function with a force-unwrapped parameter is overriding an API function with such a signature, as Chris mentioned.<br>&gt; <br>&gt; If the function actually doesn’t accept nil you might feel obliged to start the function with something like<br>&gt; <br>&gt; precondition( IUO argument != nil, “this method cannot handle nil”)<br>&gt; <br>&gt; in order to at least provide a message rather than just crashing.<br>&gt; <br>&gt; As for consistency and symmetry I don’t think the current practice meets these criteria.<br>&gt; In your own code an IUO means “only use if you are sure it’s non-nil” whereas in imported APIs it means “enter nil at your own risk”.<br>&gt; If the unwrap shorthand `if let x!` would be accepted it would mean “if unwrap succeeds use as if it’s an IUO instead of an ordinary optional”. <br>&gt; That would make three shades of weirdness. I like it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Sorry, but I’m going to use your use case as an example…hope you don’t take<br>it personally :)<br></p><p>Basically, your use of IUOs is exactly what I’m trying to avoid. IUOs may<br>have their uses, but in my mind, they don’t (in my mind) indicate “This<br>argument should not be nil on most occasions, but may be under some<br>circumstances.” I think of it as “this can occasionally be nil, but if you<br>shouldn’t have to check for it since I guarantee it will have a value<br>whenever you try to use it”. If you can’t make this guarantee, then you<br>should be using a plain Optional instead to make it explicit that the value<br>you’re trying to use can be nil.<br></p><p>Interpretation of IUO aside, your approach has other issues, for both the<br>author and the user. As an author, putting an IUO in the function signature<br>makes it possible to passing in nil, but does not *require* a check to<br>compile. Basically, what I’m saying is that with an Optional the compiler<br>*forces* you to check for nil before you try to use a variable shadowing<br>with a guard (which I don’t really see as easier than explicitly checking<br>for nil; they’re basically the same number of characters, and this one<br>looks more Swifty™ to me anyways):<br></p><p>guard let url = url else {<br>    return<br>}<br></p><p>whereas with IUOs you can easily forget the check and the compiler won’t<br>warn you. This way, it makes it both explicit as well as safe.<br></p><p>Your function also appears unsafe for users, as well. Let’s assume I was<br>using your code for my project as a framework, and I came across your<br>function. Everything’s perfect, it does what I want, until I come across a<br>URL! parameter. As a user, I cannot trust that you have implemented a check<br>for nil (maybe you forgot) and a runtime crash would be unacceptable<br>behavior. Thus, I’m obliged to add my own check for nil before passing in<br>my URL?, which completely negates the benefits of the IUO you have.<br></p><p><br>On Thu, Jun 30, 2016 at 9:15 PM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I find it useful when dealing with (NS)URLs. I have a project that deals<br>&gt; with URLs an awful lot and it would be incredible pain to deal to check if<br>&gt; each URL is nonnil at call site.<br>&gt;<br>&gt; What I do instead is use IUO arguments in methods where I pass the URLs<br>&gt; to. The IUO nicely indicates &quot;This argument should not be nil on most<br>&gt; occasions, but may be under some circumstances.&quot; The only thing I need to<br>&gt; do at the top of the method is guard url != nil else  { return }.<br>&gt;<br>&gt; Sure, I could do this with optional + shadowing original argument var with<br>&gt; guard let url = url else { return }, but I find it easier this way.<br>&gt;<br>&gt; &gt; On Jun 30, 2016, at 5:55 PM, J.E. Schotsman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The only reason I can think of writing a function with a force-unwrapped<br>&gt; parameter is overriding an API function with such a signature, as Chris<br>&gt; mentioned.<br>&gt; &gt;<br>&gt; &gt; If the function actually doesn’t accept nil you might feel obliged to<br>&gt; start the function with something like<br>&gt; &gt;<br>&gt; &gt; precondition( IUO argument != nil, “this method cannot handle nil”)<br>&gt; &gt;<br>&gt; &gt; in order to at least provide a message rather than just crashing.<br>&gt; &gt;<br>&gt; &gt; As for consistency and symmetry I don’t think the current practice meets<br>&gt; these criteria.<br>&gt; &gt; In your own code an IUO means “only use if you are sure it’s non-nil”<br>&gt; whereas in imported APIs it means “enter nil at your own risk”.<br>&gt; &gt; If the unwrap shorthand `if let x!` would be accepted it would mean “if<br>&gt; unwrap succeeds use as if it’s an IUO instead of an ordinary optional”.<br>&gt; &gt; That would make three shades of weirdness. I like it.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/4e072902/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
