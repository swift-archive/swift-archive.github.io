<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 02:00:00am</p></header><div class="content"><p>This is less a proposal and more a vague notion, but here goes.<br></p><p>Occasionally, Optional&lt;Void&gt; comes up in Swift. This particularly happens with optional chaining (and its socially awkward twin `Optional.flatMap(_:)`), but I occasionally see it come up in other places, particularly where you’re using a Result-ish type. Wherever it does come up, it seems to have the same semantic meaning as Bool, with `nil` meaning `false` and `()` meaning `true`.<br></p><p>Does it make sense to somehow unify them? Perhaps turn Bool into a typealias for Optional&lt;Void&gt; and move all of its conformances into (not yet supported) conditional conformances on Optional?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>Interesting proposal, I think there&#39;s value in exploring this, it certainly<br>seems logical. I&#39;d like to see the impact on an existing codebase and if<br>there&#39;s any savings/conveniences/issues.<br></p><p>My main concerns, mostly that Swift is not yet ready for it:<br> * How does this compare semantically when used in an if/guard statement?<br> * If higher kinded types are introduced should &quot;Optional&lt;Int&gt;&quot; be of a<br>kind with &quot;Bool&quot; ?<br> * Optional casting rules need some work still, in my opinion.<br> * How does this relate to &quot;ImplicitlyUnwrappedOptional&lt;Void&gt;&quot; ? they seem<br>sometimes interchangeable with &quot;Optional&lt;Void&gt;&quot;.<br> * As you mentioned, but in more detail:<br>     + Making it conform to &quot;BooleanType&quot;, &quot;BooleanLiteralConvertible&quot; is<br>not yet possible:<br></p><p>*error: same-type requirement makes generic parameter &#39;Wrapped&#39; non-generic*<br></p><p>extension Optional where Wrapped == Void { /*...*/ }<br></p><p>     + Can we, or even should we specialise debugDescription for<br>CustomDebugStringConvertible ?<br> * Assuming the generic is equivalent to this:<br></p><p>enum Bool: BooleanType, BooleanLiteralConvertible {<br></p><p>    case Some()<br></p><p>    case None<br></p><p>}<br></p><p>     + Will that be optimised to the same extent as Bool?<br>     + Will it be packed as efficiently as Bool (Int1)?<br>     + Is &quot;let myBoolean = .None&quot; confusing? should it be allowed?<br></p><p><br>On Thu, Dec 17, 2015 at 9:25 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is less a proposal and more a vague notion, but here goes.<br>&gt;<br>&gt; Occasionally, Optional&lt;Void&gt; comes up in Swift. This particularly happens<br>&gt; with optional chaining (and its socially awkward twin<br>&gt; `Optional.flatMap(_:)`), but I occasionally see it come up in other places,<br>&gt; particularly where you’re using a Result-ish type. Wherever it does come<br>&gt; up, it seems to have the same semantic meaning as Bool, with `nil` meaning<br>&gt; `false` and `()` meaning `true`.<br>&gt;<br>&gt; Does it make sense to somehow unify them? Perhaps turn Bool into a<br>&gt; typealias for Optional&lt;Void&gt; and move all of its conformances into (not yet<br>&gt; supported) conditional conformances on Optional?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ba353fac/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December 17, 2015 at 12:00:00pm</p></header><div class="content"><p>Does it make sense to somehow unify them? Perhaps turn Bool into a typealias for Optional&lt;Void&gt; and move all of its conformances into (not yet supported) conditional conformances on Optional?<br>I’m against unifying those concepts, for two main reasons:<br></p><p>1) These are two separate constructs. When Bool is turned into Optional&lt;Void&gt;, it’s logical to be able to map it to Optional&lt;T&gt;, to flatMap it, to forEach it etc. I can’t see a situation where mapping Bool to, let’s say, Optional&lt;Array&lt;String&gt;&gt; is a readable statement.<br></p><p>2) Bool is a very basic type, one of the first to use when learning programming. Making it an alias for a widely more complicated construct will introduce special cases that will be misleading for those learning to code.<br></p><p><br></p><p>I believe the situation where Optional&lt;Void&gt; is used to indicate the existence or absence of particular condition could be better resolved. Two alternatives that come to mind:<br></p><p>a) „isDefined” method on Optional, converting any Optional to Bool<br></p><p>b) just writing optionalVoid.map { return true } ?? false at the end of your pipe to transform otherwise ambiguous Void? to Bool clearly expressing your thoughts.<br></p><p><br></p><p>Krzysztof<br></p><p><br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/3aca7b8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>I&#39;m also against unification. I think that Krzysztof makes a good point showing what you can do on an Optional but shouldn&#39;t do on booleans.<br></p><p>In my opinion, going forward, code that uses Void? to signal failure should move to either Bool or to exceptions anyway. If this encourages the idiom to stay, it might not be in the best interest of the language.<br></p><p>Félix<br></p><p>&gt; Le 17 déc. 2015 à 06:36:50, Krzysztof Siejkowski via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; Does it make sense to somehow unify them? Perhaps turn Bool into a typealias for Optional&lt;Void&gt; and move all of its conformances into (not yet supported) conditional conformances on Optional?<br>&gt; <br>&gt; I’m against unifying those concepts, for two main reasons:<br>&gt; <br>&gt; 1) These are two separate constructs. When Bool is turned into Optional&lt;Void&gt;, it’s logical to be able to map it to Optional&lt;T&gt;, to flatMap it, to forEach it etc. I can’t see a situation where mapping Bool to, let’s say, Optional&lt;Array&lt;String&gt;&gt; is a readable statement.<br>&gt; <br>&gt; 2) Bool is a very basic type, one of the first to use when learning programming. Making it an alias for a widely more complicated construct will introduce special cases that will be misleading for those learning to code.<br>&gt; <br>&gt; <br>&gt; <br>&gt; I believe the situation where Optional&lt;Void&gt; is used to indicate the existence or absence of particular condition could be better resolved. Two alternatives that come to mind:<br>&gt; <br>&gt; a) „isDefined” method on Optional, converting any Optional to Bool<br>&gt; <br>&gt; b) just writing optionalVoid.map { return true } ?? false at the end of your pipe to transform otherwise ambiguous Void? to Bool clearly expressing your thoughts.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Krzysztof<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/2b0cf880/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 17 Dec 2015, at 12:25, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Occasionally, Optional&lt;Void&gt; comes up in Swift. This particularly happens with optional chaining (and its socially awkward twin `Optional.flatMap(_:)`), but I occasionally see it come up in other places, particularly where you’re using a Result-ish type. Wherever it does come up, it seems to have the same semantic meaning as Bool, with `nil` meaning `false` and `()` meaning `true`.<br></p><p>It&#39;s true that Optional&lt;Void&gt; corresponds to Bool, but those aren&#39;t the only isomorphic types to each other. There&#39;s also Bit, and I could list a lot of other more domain-specific enums that just happen to have two cases with no associated data.<br></p><p>I think it would be very confusing to people when Optional&lt;Void&gt;.Some() were suddenly a common thing. (Possibly related to this is that Bool is a struct and not an enum in Swift.)<br></p><p>&gt; Does it make sense to somehow unify them? Perhaps turn Bool into a typealias for Optional&lt;Void&gt; and move all of its conformances into (not yet supported) conditional conformances on Optional?<br></p><p>The one thing I&#39;d suggest instead is if Void were made Equatable. In that case, you&#39;d convert from Optional&lt;Void&gt; to Bool by simply comparing against ():<br></p><p>let optional: ()? = ...<br>let bool = optional == ()<br></p><p>And before someone says it&#39;s impossible because tuples aren&#39;t nominal types in Swift (yet), this all could be emulated (for now) by overloading == and !=:<br></p><p>@warn_unused_result<br>func ==(_: (), _: ()) -&gt; Bool { return true }<br></p><p>@warn_unused_result<br>func !=(_: (), _: ()) -&gt; Bool { return false }<br></p><p>@warn_unused_result<br>func ==(a: ()?, b: ()?) -&gt; Bool {<br>    switch (a, b) {<br>    case (()?, ()?), (nil, nil): return true<br>    default: return false<br>    }<br>}<br></p><p>@warn_unused_result<br>func !=(a: ()?, b: ()?) -&gt; Bool {<br>    return !(a == b)<br>}<br></p><p>Another question though is whether not defining () == () also servers as a sanity check against making something stupid like comparing the result of a side-effectful function against nil by mistake. But it turns out the compiler is actually pretty clever against unintended Void or Void?:<br></p><p>class Missile {<br>    // Maybe it once returned `()?` or something.<br>    //func launch() -&gt; ()? { return nil }<br>    func launch() {}<br>}<br></p><p>let result = Missile().launch()<br>//  ^<br>// warning: constant &#39;result&#39; inferred to have type &#39;()&#39;, which may be unexpected<br>// note: add an explicit type annotation to silence this warning<br></p><p>let explicit: ()? = result // no warning<br></p><p>let bool = result != nil<br>//         ~~~~~~ ^<br>// error: value of type &#39;()&#39; can never be nil, comparison isn&#39;t allowed<br></p><p>let optional = Optional(result)<br>//  ^<br>// warning: constant &#39;optional&#39; inferred to have type &#39;Optional&lt;()&gt;&#39;, which may be unexpected<br></p><p>if optional == () { // No warning.<br>    print(&quot;Missile launched, I&#39;m afraid!&quot;)<br>}<br></p><p>— Pyry Jahkola<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/44ffd76a/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/44ffd76a/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:01 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; (Possibly related to this is that Bool is a struct and not an enum in Swift.)<br></p><p>This is an artifact of the current implementation more than anything. IIRC there are missed optimization opportunities with an enum implementation, but the goal is to move to that.<br></p><p>Slava<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/77e1a3cf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Bool vs. Optional&lt;Void&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>This idea has actually come up before, but ultimately we came to the same conclusion as most people here: just because they&#39;re isomorphic and fairly similar doesn&#39;t mean they&#39;re really the same type. (For example, we have some auto-corrections if you try to use an Optional as a Bool. But if your Optional is coincidentally Optional&lt;Void&gt;, suddenly your code is valid! This can happen with optional chaining.)<br></p><p>&gt; On Dec 17, 2015, at 11:01 , Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Possibly related to this is that Bool is a struct and not an enum in Swift.)<br></p><p>We&#39;ve tossed around the idea of going to an enum now that we actually have efficient enum-handling instructions in SIL. I think there&#39;s still a bit of work to be done there, though.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/522daf45/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
