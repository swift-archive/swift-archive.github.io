<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9e453dc290485e158dcd01698e8c60ae?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Alexey Demedetskiy</string> &lt;demedeckie at gmail.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>From my point of view, ability to limit behavior in subclasses will do more harm than profit.<br>But several attributes can be applied.<br></p><p>1) default - override is enabled in any form. Current default behavior.<br>2) final - override is disabled in any form. Currently implemented.<br>3) stub - only override(instead) is allowed. This keyword should mark default bodies.<br></p><p>stub func renderShape(shape: Shape) { }<br></p><p>4) require - override(instead) is disabled. Call to parent is important to the object lifecycle.<br></p><p>This will introduce new keywords, and can be implemented separately from override(…) behavior.<br>Also instead of ‘stub’ ‘abstract’ can be used.<br></p><p>&gt; Cc:swift-evolution at swift.org<br>&gt; Subject:[swift-evolution] Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall<br>&gt; Date:February 16, 2016 at 12:28:55 AM GMT+2<br>&gt; <br>&gt; <br>&gt; +1 for what you outlined Alexey. I think maintaining the use of override as the keyword is the most understandable in the context and also is terminology usually used in various object languages. I like adding the optional qualifiers to allow (1) better diagnostics by the compiler, (2) clearer code, and (3) the opportunity for compiler generating the need coded (in a few of the situations).<br>&gt; <br>&gt; Can something like this be used in the super classes interface definition to clarify expectations of a subclass?<br>&gt; On Mon, Feb 15, 2016 at 2:07 PM Alexey Demedetskiy via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; Hi<br>&gt; &gt; <br>&gt; &gt; I would like to suggest you to extend your proposal.<br>&gt; &gt; <br>&gt; &gt; In my practice, overriding super functions can have several semantics.<br>&gt; &gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; &gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; &gt; 3) Before super - opposite to 2.<br>&gt; &gt; 4) Override - no rules about order, but super call must be done.<br>&gt; &gt; <br>&gt; &gt; So code can look like:<br>&gt; &gt; <br>&gt; &gt; override(after) func viewDidLoad() {<br>&gt; &gt; // super.viewDidLoad()&lt;— no need to call super at first line.<br>&gt; &gt; // child code<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; override(before) func tearDown() {<br>&gt; &gt; // clean code<br>&gt; &gt; // super… inserted by compiler<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; override(instead) func loadView() {<br>&gt; &gt; // super.loadView()&lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; override func refillHealthBar() {<br>&gt; &gt; // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt; &gt; <br>&gt; &gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt;Hi!<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt; &gt;The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;class View {<br>&gt; &gt; &gt;func viewDidLoad() {<br>&gt; &gt; &gt;// does something<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;class Button: View {<br>&gt; &gt; &gt;override func viewDidLoad() {<br>&gt; &gt; &gt;super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt; &gt;// do something other<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;// Example for extending a function<br>&gt; &gt; &gt;class Button: View {<br>&gt; &gt; &gt;extend func viewDidLoad() {<br>&gt; &gt; &gt;super.viewDidLoad()<br>&gt; &gt; &gt;// do something<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;extend func viewDidAppear() {<br>&gt; &gt; &gt;// do something<br>&gt; &gt; &gt;} //&lt;— the compiler should throw an error here.<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;// Example for replacing a function<br>&gt; &gt; &gt;class Geometry {<br>&gt; &gt; &gt;func volume() -&gt;Double {<br>&gt; &gt; &gt;return 0;<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;class Cube: Geometry {<br>&gt; &gt; &gt;var length: Double = 0.0<br>&gt; &gt; &gt;replace func volume() -&gt;Double {<br>&gt; &gt; &gt;let v = length * length * length<br>&gt; &gt; &gt;return v<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Cheers,<br>&gt; &gt; &gt;Florian<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
