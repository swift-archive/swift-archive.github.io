<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[summary] Protocol extension method dispatch - was [Static Dispatch Pitfalls]</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; protocol A {<br>&gt;   func f()<br>&gt;   func x()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;   func x() {print(&quot;a-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; class B: A { // already strange. B depends on A extension. did not implement all required methods from A<br>&gt;   func f() {}<br>&gt; }<br></p><p>In order to understand the various perspectives on what constitutes expected versus strange, it might be useful to have a sense of which programing language the viewpoint would be expressed from. <br></p><p>For eg in this case, coming from objc it might indeed be surprising that one of the methods of Protocol A does not have to be implemented (this was well explained in last year&#39;s wwdc, or was it even 2 years ago). Coming from a java viewpoint however, this would present no surprise, except for having to write the default implementation in an extension rather than directly in the protocol itself. Scala, c#... and more? again different kinds of surprises, but overall the pleasant feeling that swift is actually a modern language.<br></p><p><br>I took the liberty to rewrite the examples with different variable name to avoid mixing expectations with behavior:<br></p><p>// —————————————— <br>protocol P {<br>  func x()<br>}<br></p><p>extension P {<br>  func x() {<br>    helper()<br>    print(&quot;ext-x&quot;)<br>  }<br>  func helper() {<br>    print(&quot;ext-helper&quot;)<br>  }<br>}<br></p><p>class A:P {<br>  func x() {		// Note that ‘override’ is not required, even though in effect <br>    print(&quot;a-x”)	// the local x() implementation is an override of the default<br>  }			// supplied by the protocol extension. However at the same time,<br>}			// by virtue of being defined inside an extension of the protocol<br>			// it is reasonable to consider that the default implementation<br>			// is NOT intrinsically a part of the protocol, defining an<br>			// implementation of x() inside a conforming class is NOT <br>			// considered overriding the definition existing in the extension<br></p><p>class B:P {		// B is made to reliant on the extension for its A conformance<br>  func helper() {<br>    print(&quot;b-helper&quot;)<br>  }<br>}<br></p><p>class C:B {<br>  func x() {		// Note that ‘override’ is not required because B does not provide<br>    print (&quot;c-x”)	// its own implementation of x() (wasn’t there a proposal from <br>  }			// E.Sadun regarding ‘override’ at this location?!)<br>  override func helper() { 	// Here ‘override’ is mandated by the presence of a similar<br>    print(&quot;c-helper”)		// helper inside B<br>  }<br>}<br></p><p><br>// —————————————— <br>// invocation via the object type<br></p><p>var x1 = A()<br>x1.x()        // a-x			no surprise<br>x1.helper()   // ext-helper		no surprise<br></p><p>var x2 = B()<br>x2.x()        // ext-helper + ext-x	!!! no surprise even if &#39;b-helper + ext-x’ might seem more ‘intuitive&#39;<br>x2.helper()   // b-helper		no surprise<br></p><p>var x3 = C()<br>x3.x()        // c-x			no surprise<br>x3.helper()   // c-helper		no surprise<br></p><p>The direct invocation case is mostly without surprises, and in all cases, logically explainable. The only contentious point might be why the definition of helper() present in B is not used when helper() is invoked from the default method implementation supplied in the protocol extension.<br></p><p><br>// —————————————— <br>// invocation via the protocol type<br></p><p>var v1:P = A()<br>v1.x()        // a-x			no surprise (type has precedence over default when directly equivalent)<br>v1.helper()   // ext-helper		no surprise<br></p><p>var v2:P = B()<br>v2.x()        // ext-helper + ext-x	coherent with x2.yyy() calls<br>v2.helper()   // ext-helper		entirely coherent, even if possibly surprising<br></p><p>var v3:P = C()<br>v3.x()        // ext-helper + ext-x	!!! again this is surprising on the surface, but it stems from the lack<br>v3.helper()   // ext-helper		of direct link to P. So when it comes to dealing with C as a<br>					reference to a P, there is no alternative but to refer to B to <br>					find out what to do<br></p><p><br>So we have identified some cases where depending on which programming language we might come from, there might be a mismatch between expectations and current Swift behavior, leading to possible bugs and or frustrations. Considering that nothing says that one line of intuition is more right than any other or even than the existing behavior, it may still be useful to manage expectations differently than they are today.<br></p><p>If the desire is to align the current code with the one line of expectations/intuition mentioned above, then it seems that the alternatives are the following:<br></p><p>1) Allow ‘override’ at the point of definition of x() inside C() (despite the absence of a x() definition inside B). The same could be said of the definition of helper() inside B. <br></p><p>One issue with this scenario is that technically speaking, the definition of helper() inside B or x() inside C are NOT overrides, because the methods they define are NOT a part of the protocol. This stems directly from the fact that default protocol methods in extensions are an extension of the internal resolution mechanism that is NOT a part of the formal definition of the protocol they supplement (see #5 for a solution that would make them FORMALLY a part of the protocol itself). IMO this semantic gap should eliminate this solution entirely<br></p><p><br>2) Support the following calling convention<br></p><p>straw_man_dynamic_dispatch v2.x()	// ext-helper + ext-x  (NOTE: does leave an expectation mismatch regarding &#39;b-helper’)<br>straw_man_dynamic_dispatch v2.helper()	// b-helper<br></p><p>straw_man_dynamic_dispatch v3.x()	// c-x<br>straw_man_dynamic_dispatch v3.helper()	// c-helper<br></p><p>In this scenario, the user of P would express the desire to include any object type level redefinitions take precedence over any possible default behavior she might have provided in a protocol extension. Note that it does leave a possible expectations mismatch regarding the call to helper() from within the context of a dynamically resolved parent call. This could also be resolved by deciding that once-dynamic, always dynamic which would create more cognitive overload by having to trace every call-tree...<br></p><p><br>3) Extend 2) to all call sites of x() by making the annotation on the method inside protocol extension<br></p><p>extension P {<br>  straw_man_dynamic_dispatch func x() {<br>    helper()<br>    print(“ext-x”)<br>  }<br>  fun helper() {<br>    print(“ext-helper”)<br>  }<br>}<br></p><p>v1.x()        // a-x<br>v1.helper()   // ext-helper<br></p><p>v2.x()        // ext-helper + ext-x	might surprise some, but once again logical as helper() is NOT straw_man_dynamic_dispatch<br>v2.helper()   // ext-helper<br></p><p>v3.x()        // c-x			<br>v3.helper()   // ext-helper		again complete logical as helper() in P is NOT straw_man_dynamic_dispatch and C has no formal relationship to P<br></p><p><br>4) change the default behavior for dispatching calls to default methods in protocol extensions, and provide an annotation that indicates to opposite behavior per call-site and/or for all call-sites<br></p><p>extension P {<br>  straw_man_static_dispatch func x() {<br>    print(“ext-x”)	STATICALLY dispatched<br>  }<br>  fun helper() {<br>    print(“ext-helper”)	dynamic dispatch<br>  }  <br>}<br></p><p>v1.x()        // a-x<br>v1.helper()   // ext-helper<br></p><p>v2.x()        // b-helper + b-x<br>v2.helper()   // b-helper<br></p><p>v3.x()        // ext-x			<br>v3.helper()   // c-helper<br></p><p><br>5) leave things the way there are today, and support dynamically dispatched protocol defaults via a new default methods mechanism on protocol directly<br></p><p>protocol P {<br>  straw_man_default_attribute func x() {<br>    print(“proto-x”)<br>  }<br>}<br></p><p>v1.x()		// a-x<br>v1.helper()	// ext-helper<br></p><p>v2.x()		// proto-x<br>v2.helper()	// ext-helper<br></p><p>v3.x()		// c-x		- note that ‘override’ would then be REQUIRED inside the implementation of C().<br>v3.helper()	// ext-helper	again local due to he absence of direct relationship between C and P (it is all via B-ness)<br></p><p><br></p><p>Regardless of the path chosen, there seems to be room today from more information from the compiler. <br></p><p><br>@michael<br></p><p>Can we agree that two methods with the same name sometimes have the same contract and sometimes not? And that this is not a programmer error? And that it would be good to distinguish between these two cases?<br></p><p>yes on all accounts.<br></p><p>NOTES: <br>a reasonable candidate for the straw_man_dynamic_dispatch attribute may very well be the existing dynamic<br>a reasonable candidate for the straw_man_default_attribute attribute might be default<br>a reasonable candidate for the straw_man_static_dispatch attribute might be: nondynamic <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/603cd0ed/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
