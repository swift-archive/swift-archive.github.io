<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Bug?] Reference types and mutating methods</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 30, 2016 at 12:00:00pm</p></header><div class="content"><p>I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br></p><p>--My Situation--<br>I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br></p><p>I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br></p><p>let array: ObservedArray&lt;String&gt; = []<br>array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br></p><p>I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br></p><p>--The Problem--<br>Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br></p><p>However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br></p><p>Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Bug?] Reference types and mutating methods</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>The problem here seems to be with using the default implementation<br>provided. If you override `append` in ObservedArray, the compiler allows<br>it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement<br>every mutating method, but that is the current solution. I haven&#39;t puzzled<br>out the reasoning behind this myself.<br></p><p><br>``` swift<br>class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>    var value: [T]<br>    init(value: [T]) {<br>        self.value = value<br>    }<br>    required init() {<br>        self.value = []<br>    }<br></p><p>    required convenience init(arrayLiteral elements: T...) {<br>        self.init(elements)<br>    }<br></p><p>}<br></p><p>extension ObservedArray {<br>    typealias Index = Int<br></p><p>    var startIndex: Index {<br>        return value.startIndex<br>    }<br></p><p>    var endIndex: Index {<br>        return value.endIndex<br>    }<br></p><p>    subscript(position: Index) -&gt; T {<br>        return value[position]<br>    }<br></p><p>}<br></p><p>extension ObservedArray : RangeReplaceableCollectionType {<br>    typealias Generator = IndexingGenerator&lt;[T]&gt;<br></p><p>    func generate() -&gt; Generator {<br>        return value.generate()<br>    }<br>}<br></p><p>extension ObservedArray {<br>    func replaceRange&lt;C : CollectionType where C.Generator.Element ==<br>Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>        value.replaceRange(subRange, with: newElements)<br>    }<br></p><p>    func append(newElement: T) { // &lt;- adding this makes it work<br>        value.append(newElement)<br>    }<br>}<br></p><p>let array: ObservedArray&lt;String&gt; = []<br>array.append(&quot;1&quot;)<br></p><p><br>```<br></p><p><br></p><p><br>On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;<br>&gt; --My Situation--<br>&gt; I&#39;ve recently been working on an observable collection type. Because each<br>&gt; stores ‘subscriptions’ to changes that occur, it made sense to me that this<br>&gt; should be a reference type, so subscriptions can&#39;t be copied with the<br>&gt; values themselves.<br>&gt;<br>&gt; I have made this class conform to RangeReplaceableCollectionType,<br>&gt; providing it with all the standard collection functions. I do the following:<br>&gt;<br>&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value:<br>&gt; ‘array’ is a ‘let’ constant<br>&gt;<br>&gt; I have to make the reference immutable just to use my new collection type?<br>&gt; This is a bit of a deal-breaker.<br>&gt;<br>&gt; --The Problem--<br>&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way<br>&gt; to mutate a value type. However, reassigning ‘self’ has a special meaning<br>&gt; to reference types, which is presumably the reason they are disallowed in<br>&gt; classes.<br>&gt;<br>&gt; However, classes can conform to protocols with mutating methods, leading<br>&gt; to the compiler disallowing calls to mutating methods for ‘let’ values of<br>&gt; type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in<br>&gt; generic code. In addition, classes can inherit mutating methods from<br>&gt; protocol extensions, leading to the behaviour I describe above.<br>&gt;<br>&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or<br>&gt; is this really an omission in the language?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/7766324a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br></p><p>To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br></p><p>To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>Is there any support for making this change? Or are there any simpler solutions?<br></p><p>I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br></p><p><br>PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br></p><p>From James F<br></p><p>&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt; <br>&gt; <br>&gt; ``` swift<br>&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;     var value: [T]<br>&gt;     init(value: [T]) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt;     required init() {<br>&gt;         self.value = []<br>&gt;     }<br>&gt; <br>&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;         self.init(elements)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; extension ObservedArray {<br>&gt;     typealias Index = Int<br>&gt; <br>&gt;     var startIndex: Index {<br>&gt;         return value.startIndex<br>&gt;     }<br>&gt; <br>&gt;     var endIndex: Index {<br>&gt;         return value.endIndex<br>&gt;     }<br>&gt; <br>&gt;     subscript(position: Index) -&gt; T {<br>&gt;         return value[position]<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt; <br>&gt;     func generate() -&gt; Generator {<br>&gt;         return value.generate()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension ObservedArray {<br>&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;     }<br>&gt; <br>&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;         value.append(newElement)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt; array.append(&quot;1&quot;)<br>&gt; <br>&gt; <br>&gt; ```<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt; <br>&gt;&gt; --My Situation--<br>&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt; <br>&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt; <br>&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt; <br>&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt; <br>&gt;&gt; --The Problem--<br>&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt; <br>&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt; <br>&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/ee0c5a96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May  3, 2016 at 08:00:00pm</p></header><div class="content"><p>Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br></p><p>func removing(_ element: Element) -&gt; Self {<br>  var result = self // not necessarily a copy…<br>  result.remove(element)<br>  return result // not necessarily an independent value<br>}<br></p><p>func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>  // requires inout on ‘nums’  even when it’s a class<br>  for i in nums.indices {<br>    if nums[i] &lt; 0 {<br>      nums.removeAtIndex(i)<br>    }<br>  }<br>  // …because of this.<br>  if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>    nums = C()<br>  }<br>}<br></p><p>var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>// either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>zapBadElements(&amp;refCollection)<br></p><p>There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br></p><p>We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br></p><p>---<br></p><p>In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br></p><p>Jordan<br></p><p><br>&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt; <br>&gt; To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt; <br>&gt; To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt; <br>&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt; <br>&gt; <br>&gt; PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br>&gt; <br>&gt; From James F<br>&gt; <br>&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ``` swift<br>&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;     var value: [T]<br>&gt;&gt;     init(value: [T]) {<br>&gt;&gt;         self.value = value<br>&gt;&gt;     }<br>&gt;&gt;     required init() {<br>&gt;&gt;         self.value = []<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;         self.init(elements)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ObservedArray {<br>&gt;&gt;     typealias Index = Int<br>&gt;&gt; <br>&gt;&gt;     var startIndex: Index {<br>&gt;&gt;         return value.startIndex<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     var endIndex: Index {<br>&gt;&gt;         return value.endIndex<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;         return value[position]<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt; <br>&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;         return value.generate()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ObservedArray {<br>&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;         value.append(newElement)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt; <br>&gt;&gt; --My Situation--<br>&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt; <br>&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt; <br>&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt; <br>&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt; <br>&gt;&gt; --The Problem--<br>&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt; <br>&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt; <br>&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/b69a9a45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>May  4, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks. It&#39;s a shame this isn&#39;t being addressed. I find myself always considering whether things are value-type or reference-type when writing generic code, avoiding assignments to self for this reason, and feel bad adding mutating methods to protocols knowing that it will make the protocol almost unusable for classes. Maybe I&#39;m the exception?<br></p><p>I think that if we had an AnyValue protocol, a Copyable protocol could provide value-types a default implementation which returns self, and this could be used when copying is needed. It would at least be better than restricting protocols to AnyValue. It seems it would work for your ‘removing’ example, even if it doesn&#39;t solve the underlying problem.<br></p><p>From James F<br></p><p>&gt; On 4 May 2016, at 04:02, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt; <br>&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;   var result = self // not necessarily a copy…<br>&gt;   result.remove(element)<br>&gt;   return result // not necessarily an independent value<br>&gt; }<br>&gt; <br>&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;   for i in nums.indices {<br>&gt;     if nums[i] &lt; 0 {<br>&gt;       nums.removeAtIndex(i)<br>&gt;     }<br>&gt;   }<br>&gt;   // …because of this.<br>&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;     nums = C()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt; zapBadElements(&amp;refCollection)<br>&gt; <br>&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt; <br>&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt; <br>&gt;&gt; To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt; <br>&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt; <br>&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;     var value: [T]<br>&gt;&gt;&gt;     init(value: [T]) {<br>&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     required init() {<br>&gt;&gt;&gt;         self.value = []<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;         self.init(elements)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var startIndex: Index {<br>&gt;&gt;&gt;         return value.startIndex<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var endIndex: Index {<br>&gt;&gt;&gt;         return value.endIndex<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;         return value[position]<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;&gt;         return value.generate()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;         value.append(newElement)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/b5568c1b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May  4, 2016 at 08:00:00am</p></header><div class="content"><p>Something about your first paragraph reminded me of a question I&#39;ve had for<br>a while. Is there a reasoning behind not being able to restrict a protocol<br>to value types? One way that this might be workable is if we could overload<br>protocols for Value vs for reference.<br></p><p>TJ<br></p><p>On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Dave and I have pondered this before, and considered that one possible<br>&gt; (drastic) solution is to ban classes from implementing protocols with<br>&gt; mutating members, on the grounds that it’s very hard to write an algorithm<br>&gt; that’s correct for both.<br>&gt;<br>&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;   var result = self* // not necessarily a copy…*<br>&gt;   result.remove(element)<br>&gt;   return result* // not necessarily an independent value*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; func zapBadElements&lt;C: RangeReplaceableCollection where<br>&gt; C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;   *// requires inout on ‘nums’  even when it’s a class*<br>&gt;   for i in nums.indices {<br>&gt;     if nums[i] &lt; 0 {<br>&gt;       nums.removeAtIndex(i)<br>&gt;     }<br>&gt;   }<br>&gt;   *// …because of this.*<br>&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;     nums = C()<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt; *// either the variable ‘refCollection’ or the instance<br>&gt; of ‘SharedArrayOfSomeKind’ might be mutated…or both!*<br>&gt; zapBadElements(&amp;refCollection)<br>&gt;<br>&gt;<br>&gt; There are of course ways to safely use a protocol with mutating<br>&gt; requirements with classes, namely if you *only* use them for mutation<br>&gt; (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters)<br>&gt; and never rely on value copying (no assignment, no returning). Most simple<br>&gt; wrappers around mutating members would fall into this category.<br>&gt;<br>&gt; We didn’t really develop the idea very far yet because there’s been more<br>&gt; pressing things to worry about. I’m bringing it up here because it’s an<br>&gt; important idea that shouldn’t get lost.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of<br>&gt; reassigning ‘self’ in a protocol extension when the model type is a class,<br>&gt; and got shot down. I don’t have those discussions on hand at the moment,<br>&gt; but I remember we deliberately decided to leave protocol extensions the way<br>&gt; they were, allowing them to reassign class references. I think it’s because<br>&gt; it means things like zapBadElements are more likely to work correctly^W as<br>&gt; expected―if you don’t have any other references at the time you do the<br>&gt; mutation, it can work. But yeah, I’m uncomfortable with the situation we’re<br>&gt; in right now.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Thanks for the response, I agree this is currently the best solution.<br>&gt; Unfortunately, it&#39;s not just as simple as just implementing each method,<br>&gt; since without being able to call super, I have to fully reimplement the<br>&gt; original behaviour, which at best seems like bad practice, and would break<br>&gt; in future versions of Swift, and at worst could lead to hard-to-detect bugs<br>&gt; right now.<br>&gt;<br>&gt; To recap for anyone reading, protocol extensions currently apply mutating<br>&gt; methods unmodified to reference types, as I found trying to make a<br>&gt; reference-type collection. This results in the compiler disallowing ‘let’<br>&gt; when calling these functions, and allows methods to reassign the reference<br>&gt; ‘self’ to a new object. The best solution is to manually implement each<br>&gt; method, removing the mutating modifier, yet this workaround doesn&#39;t<br>&gt; extend to generic code.<br>&gt;<br>&gt; To fix this behaviour, we would need to distinguish between ‘true’<br>&gt; mutating functions, which reassign self, and ‘partially’ mutating<br>&gt; functions, for use in generics and protocol extensions, which can reassign<br>&gt; properties only.<br>&gt; Is there any support for making this change? Or are there any simpler<br>&gt; solutions?<br>&gt;<br>&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt; possible without some evolution of the language regarding the mutating<br>&gt; keyword, so I&#39;m trying to bring this up here in hope of us getting an<br>&gt; actual solution. I&#39;ve changed the title to what I hope is something that<br>&gt; better reflects the problem; this thread was originally titled ‘[swift-evolution]<br>&gt; [Bug?] Reference types and mutating methods’.<br>&gt;<br>&gt;<br>&gt; PS: I have noticed another side-effect of calling mutating functions on my<br>&gt; reference-type collection: it seems to trigger didChange on properties,<br>&gt; even when, upon comparing the new and old objects, the reference isn&#39;t<br>&gt; being changed. I haven&#39;t done much experimentation with this behaviour;<br>&gt; this may be an unexpected side-effect of an extension method assigning to<br>&gt; self, but it feels like it could be undefined behaviour.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; The problem here seems to be with using the default implementation<br>&gt; provided. If you override `append` in ObservedArray, the compiler allows<br>&gt; it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement<br>&gt; every mutating method, but that is the current solution. I haven&#39;t puzzled<br>&gt; out the reasoning behind this myself.<br>&gt;<br>&gt;<br>&gt; ``` swift<br>&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;     var value: [T]<br>&gt;     init(value: [T]) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt;     required init() {<br>&gt;         self.value = []<br>&gt;     }<br>&gt;<br>&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;         self.init(elements)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension ObservedArray {<br>&gt;     typealias Index = Int<br>&gt;<br>&gt;     var startIndex: Index {<br>&gt;         return value.startIndex<br>&gt;     }<br>&gt;<br>&gt;     var endIndex: Index {<br>&gt;         return value.endIndex<br>&gt;     }<br>&gt;<br>&gt;     subscript(position: Index) -&gt; T {<br>&gt;         return value[position]<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;<br>&gt;     func generate() -&gt; Generator {<br>&gt;         return value.generate()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension ObservedArray {<br>&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element ==<br>&gt; Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;     }<br>&gt;<br>&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;         value.append(newElement)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt; array.append(&quot;1&quot;)<br>&gt;<br>&gt;<br>&gt; ```<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;<br>&gt;&gt; --My Situation--<br>&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each<br>&gt;&gt; stores ‘subscriptions’ to changes that occur, it made sense to me that this<br>&gt;&gt; should be a reference type, so subscriptions can&#39;t be copied with the<br>&gt;&gt; values themselves.<br>&gt;&gt;<br>&gt;&gt; I have made this class conform to RangeReplaceableCollectionType,<br>&gt;&gt; providing it with all the standard collection functions. I do the following:<br>&gt;&gt;<br>&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value:<br>&gt;&gt; ‘array’ is a ‘let’ constant<br>&gt;&gt;<br>&gt;&gt; I have to make the reference immutable just to use my new collection<br>&gt;&gt; type? This is a bit of a deal-breaker.<br>&gt;&gt;<br>&gt;&gt; --The Problem--<br>&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way<br>&gt;&gt; to mutate a value type. However, reassigning ‘self’ has a special meaning<br>&gt;&gt; to reference types, which is presumably the reason they are disallowed in<br>&gt;&gt; classes.<br>&gt;&gt;<br>&gt;&gt; However, classes can conform to protocols with mutating methods, leading<br>&gt;&gt; to the compiler disallowing calls to mutating methods for ‘let’ values of<br>&gt;&gt; type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in<br>&gt;&gt; generic code. In addition, classes can inherit mutating methods from<br>&gt;&gt; protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;<br>&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or<br>&gt;&gt; is this really an omission in the language?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/b351df47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 4, 2016, at 7:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something about your first paragraph reminded me of a question I&#39;ve had for a while. Is there a reasoning behind not being able to restrict a protocol to value types? One way that this might be workable is if we could overload protocols for Value vs for reference.<br>&gt; <br></p><p>There is a thread going right now discussing adding an intrinsic AnyValue protocol (and a few other intrinsic protocols).  I think it is a good idea but I don&#39;t believe anyone from the core team has commented in that thread yet.<br></p><p>&gt; TJ<br>&gt; <br>&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt; <br>&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;   var result = self // not necessarily a copy…<br>&gt;&gt;   result.remove(element)<br>&gt;&gt;   return result // not necessarily an independent value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;   for i in nums.indices {<br>&gt;&gt;     if nums[i] &lt; 0 {<br>&gt;&gt;       nums.removeAtIndex(i)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   // …because of this.<br>&gt;&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;     nums = C()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt; <br>&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt; <br>&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;     var value: [T]<br>&gt;&gt;&gt;&gt;     init(value: [T]) {<br>&gt;&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     required init() {<br>&gt;&gt;&gt;&gt;         self.value = []<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;         self.init(elements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var startIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.startIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var endIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.endIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;         return value[position]<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;         return value.generate()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;         value.append(newElement)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/7c8ed75f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>May  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Your comment on overloads for reference types gave me an idea. I&#39;ve just tried in a playground, and overloading is currently possible for protocol extensions. Providing an implementation, then separate ones in an extension where Self: AnyObject, will cause the compiler to choose the more specific implementation, which is allowed to omit the mutating keyword. This does work using a generic variable of type protocol&lt;P, AnyObject&gt;.<br></p><p>However, whether the value conforms to AnyObject has to be known at compile time, otherwise the more general implementation will (invisibly to the programmer) be called instead, so generic code needs to explicitly attempt a cast to protocol&lt;P, AnyObject&gt;. Additionally, using this as a general fix would require large amounts of copy &amp; pasting implementations to duplicate every function within a ‘where Self: AnyObject’ extension.<br></p><p>So by itself, not a great solution either. If I understand what you&#39;re suggesting, overloading protocols (one for AnyValue, one for AnyObject) would require the method duplication and casts, and remove confusion for users, preventing truly generic code. I&#39;m divided as to whether it&#39;s worth the headaches, though.<br></p><p>From James F<br></p><p>&gt; On 4 May 2016, at 13:28, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; Something about your first paragraph reminded me of a question I&#39;ve had for a while. Is there a reasoning behind not being able to restrict a protocol to value types? One way that this might be workable is if we could overload protocols for Value vs for reference.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt; <br>&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;   var result = self // not necessarily a copy…<br>&gt;&gt;   result.remove(element)<br>&gt;&gt;   return result // not necessarily an independent value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;   for i in nums.indices {<br>&gt;&gt;     if nums[i] &lt; 0 {<br>&gt;&gt;       nums.removeAtIndex(i)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   // …because of this.<br>&gt;&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;     nums = C()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt; <br>&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt; <br>&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;     var value: [T]<br>&gt;&gt;&gt;&gt;     init(value: [T]) {<br>&gt;&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     required init() {<br>&gt;&gt;&gt;&gt;         self.value = []<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;         self.init(elements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var startIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.startIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var endIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.endIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;         return value[position]<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;         return value.generate()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;         value.append(newElement)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/46110ec9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something about your first paragraph reminded me of a question I&#39;ve had for a while. Is there a reasoning behind not being able to restrict a protocol to value types? One way that this might be workable is if we could overload protocols for Value vs for reference.<br></p><p>I&#39;m not totally comfortable with this, because references are a kind of value. I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br></p><p>-Joe<br></p><p>&gt; TJ<br>&gt; <br>&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt; <br>&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;   var result = self // not necessarily a copy…<br>&gt;   result.remove(element)<br>&gt;   return result // not necessarily an independent value<br>&gt; }<br>&gt; <br>&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;   for i in nums.indices {<br>&gt;     if nums[i] &lt; 0 {<br>&gt;       nums.removeAtIndex(i)<br>&gt;     }<br>&gt;   }<br>&gt;   // …because of this.<br>&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;     nums = C()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt; zapBadElements(&amp;refCollection)<br>&gt; <br>&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt; <br>&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the response, I agree this is currently the best solution. Unfortunately, it&#39;s not just as simple as just implementing each method, since without being able to call super, I have to fully reimplement the original behaviour, which at best seems like bad practice, and would break in future versions of Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt; <br>&gt;&gt; To recap for anyone reading, protocol extensions currently apply mutating methods unmodified to reference types, as I found trying to make a reference-type collection. This results in the compiler disallowing ‘let’ when calling these functions, and allows methods to reassign the reference ‘self’ to a new object. The best solution is to manually implement each method, removing the mutating modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt; <br>&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’ mutating functions, which reassign self, and ‘partially’ mutating functions, for use in generics and protocol extensions, which can reassign properties only.<br>&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt; <br>&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not possible without some evolution of the language regarding the mutating keyword, so I&#39;m trying to bring this up here in hope of us getting an actual solution. I&#39;ve changed the title to what I hope is something that better reflects the problem; this thread was originally titled ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; PS: I have noticed another side-effect of calling mutating functions on my reference-type collection: it seems to trigger didChange on properties, even when, upon comparing the new and old objects, the reference isn&#39;t being changed. I haven&#39;t done much experimentation with this behaviour; this may be an unexpected side-effect of an extension method assigning to self, but it feels like it could be undefined behaviour.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;     var value: [T]<br>&gt;&gt;&gt;     init(value: [T]) {<br>&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     required init() {<br>&gt;&gt;&gt;         self.value = []<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;         self.init(elements)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var startIndex: Index {<br>&gt;&gt;&gt;         return value.startIndex<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var endIndex: Index {<br>&gt;&gt;&gt;         return value.endIndex<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;         return value[position]<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;&gt;         return value.generate()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;         value.append(newElement)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt; <br>&gt; -Joe<br></p><p>+1<br></p><p>I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br></p><p>I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br></p><p>I was thinking of something pretty similar to your PureReference idea, but slightly different.  Pure / immutable references have value semantics.  With that in mind I was thinking of an ImmutableObject protocol which would inherit from both AnyObject and PureValue.<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Having given it some more thought... Does &quot;PureReference&quot; make sense? What would it mean? At some point a reference has to, you know, actually refer to a concrete value. Otherwise it&#39;s just turtles all the way down.<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br>&gt; <br>&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt; <br>&gt; I was thinking of something pretty similar to your PureReference idea, but slightly different.  Pure / immutable references have value semantics.  With that in mind I was thinking of an ImmutableObject protocol which would inherit from both AnyObject and PureValue.<br>&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>... And 30 seconds later I realized that &quot;PureReference&quot; could be fulfilled by something with only static or computed properties. <br></p><p>Sent from my iPhone<br></p><p>&gt; On May 4, 2016, at 16:16, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Having given it some more thought... Does &quot;PureReference&quot; make sense? What would it mean? At some point a reference has to, you know, actually refer to a concrete value. Otherwise it&#39;s just turtles all the way down.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br>&gt;&gt; <br>&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt; <br>&gt;&gt; I was thinking of something pretty similar to your PureReference idea, but slightly different.  Pure / immutable references have value semantics.  With that in mind I was thinking of an ImmutableObject protocol which would inherit from both AnyObject and PureValue.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 4:20 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; ... And 30 seconds later I realized that &quot;PureReference&quot; could be fulfilled by something with only static or computed properties.<br></p><p>Any class that only had immutable value semantic members would fulfill PureReference.  They would not need to be static or computed.<br></p><p>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 4, 2016, at 16:16, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make sense? What would it mean? At some point a reference has to, you know, actually refer to a concrete value. Otherwise it&#39;s just turtles all the way down.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking of something pretty similar to your PureReference idea, but slightly different.  Pure / immutable references have value semantics.  With that in mind I was thinking of an ImmutableObject protocol which would inherit from both AnyObject and PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; Having given it some more thought... Does &quot;PureReference&quot; make sense? What would it mean? At some point a reference has to, you know, actually refer to a concrete value. Otherwise it&#39;s just turtles all the way down.<br></p><p>In my thinking PureReference (or ImmutableObject) has semantics indicating that the type is a value-semantic reference type.  I think this could be quite useful in some cases.  <br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for types that represent fully self-contained values, but conforming to that protocol requires a bit more thought than just being a struct or enum, since there are structs that have reference semantics (such as UnsafePointer), and there are hybrid value types that contain references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be useful. Isn&#39;t it the mixed types that make for tricky mutation rules &amp; serialization?<br>&gt;&gt; <br>&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt; <br>&gt;&gt; I was thinking of something pretty similar to your PureReference idea, but slightly different.  Pure / immutable references have value semantics.  With that in mind I was thinking of an ImmutableObject protocol which would inherit from both AnyObject and PureValue.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 08:00:00am</p></header><div class="content"><p>on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make<br>&gt;&gt; sense? What would it mean? At some point a reference has to, you<br>&gt;&gt; know, actually refer to a concrete value. Otherwise it&#39;s just<br>&gt;&gt; turtles all the way down.<br>&gt;<br>&gt; In my thinking PureReference (or ImmutableObject) has semantics<br>&gt; indicating that the type is a value-semantic reference type.  I think<br>&gt; this could be quite useful in some cases.<br></p><p>Like what? To a first approximation, the only thing I can see this being<br>useful for is Objective-C interop.  Aside from being an element of an<br>NSArray, there&#39;s nothing a an immutable class can do that a struct<br>can&#39;t.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol,<br>&gt;&gt;&gt;&gt;&gt; for types that represent fully self-contained values, but<br>&gt;&gt;&gt;&gt;&gt; conforming to that protocol requires a bit more thought than just<br>&gt;&gt;&gt;&gt;&gt; being a struct or enum, since there are structs that have<br>&gt;&gt;&gt;&gt;&gt; reference semantics (such as UnsafePointer), and there are hybrid<br>&gt;&gt;&gt;&gt;&gt; value types that contain references to data that isn&#39;t part of<br>&gt;&gt;&gt;&gt;&gt; the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be<br>&gt;&gt;&gt;&gt; useful. Isn&#39;t it the mixed types that make for tricky mutation<br>&gt;&gt;&gt;&gt; rules &amp; serialization?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking of something pretty similar to your PureReference<br>&gt;&gt;&gt; idea, but slightly different.  Pure / immutable references have<br>&gt;&gt;&gt; value semantics.  With that in mind I was thinking of an<br>&gt;&gt;&gt; ImmutableObject protocol which would inherit from both AnyObject<br>&gt;&gt;&gt; and PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 5, 2016, at 10:59 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make<br>&gt;&gt;&gt; sense? What would it mean? At some point a reference has to, you<br>&gt;&gt;&gt; know, actually refer to a concrete value. Otherwise it&#39;s just<br>&gt;&gt;&gt; turtles all the way down.<br>&gt;&gt; <br>&gt;&gt; In my thinking PureReference (or ImmutableObject) has semantics<br>&gt;&gt; indicating that the type is a value-semantic reference type.  I think<br>&gt;&gt; this could be quite useful in some cases.<br>&gt; <br>&gt; Like what? To a first approximation, the only thing I can see this being<br>&gt; useful for is Objective-C interop.  Aside from being an element of an<br>&gt; NSArray, there&#39;s nothing a an immutable class can do that a struct<br>&gt; can&#39;t.<br></p><p>Objective-C / cocoa interop is important enough to matter IMO.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol,<br>&gt;&gt;&gt;&gt;&gt;&gt; for types that represent fully self-contained values, but<br>&gt;&gt;&gt;&gt;&gt;&gt; conforming to that protocol requires a bit more thought than just<br>&gt;&gt;&gt;&gt;&gt;&gt; being a struct or enum, since there are structs that have<br>&gt;&gt;&gt;&gt;&gt;&gt; reference semantics (such as UnsafePointer), and there are hybrid<br>&gt;&gt;&gt;&gt;&gt;&gt; value types that contain references to data that isn&#39;t part of<br>&gt;&gt;&gt;&gt;&gt;&gt; the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be<br>&gt;&gt;&gt;&gt;&gt; useful. Isn&#39;t it the mixed types that make for tricky mutation<br>&gt;&gt;&gt;&gt;&gt; rules &amp; serialization?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was thinking of something pretty similar to your PureReference<br>&gt;&gt;&gt;&gt; idea, but slightly different.  Pure / immutable references have<br>&gt;&gt;&gt;&gt; value semantics.  With that in mind I was thinking of an<br>&gt;&gt;&gt;&gt; ImmutableObject protocol which would inherit from both AnyObject<br>&gt;&gt;&gt;&gt; and PureValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 12:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On May 5, 2016, at 10:59 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make<br>&gt;&gt;&gt;&gt; sense? What would it mean? At some point a reference has to, you<br>&gt;&gt;&gt;&gt; know, actually refer to a concrete value. Otherwise it&#39;s just<br>&gt;&gt;&gt;&gt; turtles all the way down.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my thinking PureReference (or ImmutableObject) has semantics<br>&gt;&gt;&gt; indicating that the type is a value-semantic reference type.  I think<br>&gt;&gt;&gt; this could be quite useful in some cases.<br>&gt;&gt; <br>&gt;&gt; Like what? To a first approximation, the only thing I can see this being<br>&gt;&gt; useful for is Objective-C interop.  Aside from being an element of an<br>&gt;&gt; NSArray, there&#39;s nothing a an immutable class can do that a struct<br>&gt;&gt; can&#39;t.<br>&gt;<br>&gt; Objective-C / cocoa interop is important enough to matter IMO.<br></p><p>Sure.  I don&#39;t see why we should have an ImmutableObject protocol when<br>we can just compose “Immutable” with “AnyObject.”<br></p><p>&gt;<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for types that represent fully self-contained values, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conforming to that protocol requires a bit more thought than just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; being a struct or enum, since there are structs that have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference semantics (such as UnsafePointer), and there are hybrid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; value types that contain references to data that isn&#39;t part of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be<br>&gt;&gt;&gt;&gt;&gt;&gt; useful. Isn&#39;t it the mixed types that make for tricky mutation<br>&gt;&gt;&gt;&gt;&gt;&gt; rules &amp; serialization?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was thinking of something pretty similar to your PureReference<br>&gt;&gt;&gt;&gt;&gt; idea, but slightly different.  Pure / immutable references have<br>&gt;&gt;&gt;&gt;&gt; value semantics.  With that in mind I was thinking of an<br>&gt;&gt;&gt;&gt;&gt; ImmutableObject protocol which would inherit from both AnyObject<br>&gt;&gt;&gt;&gt;&gt; and PureValue.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 2:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 5, 2016, at 10:59 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make<br>&gt;&gt;&gt;&gt;&gt; sense? What would it mean? At some point a reference has to, you<br>&gt;&gt;&gt;&gt;&gt; know, actually refer to a concrete value. Otherwise it&#39;s just<br>&gt;&gt;&gt;&gt;&gt; turtles all the way down.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my thinking PureReference (or ImmutableObject) has semantics<br>&gt;&gt;&gt;&gt; indicating that the type is a value-semantic reference type.  I think<br>&gt;&gt;&gt;&gt; this could be quite useful in some cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like what? To a first approximation, the only thing I can see this being<br>&gt;&gt;&gt; useful for is Objective-C interop.  Aside from being an element of an<br>&gt;&gt;&gt; NSArray, there&#39;s nothing a an immutable class can do that a struct<br>&gt;&gt;&gt; can&#39;t.<br>&gt;&gt; <br>&gt;&gt; Objective-C / cocoa interop is important enough to matter IMO.<br>&gt; <br>&gt; Sure.  I don&#39;t see why we should have an ImmutableObject protocol when<br>&gt; we can just compose “Immutable” with “AnyObject.”<br></p><p>Yes, fair enough.  A typealias is easy enough to add if it is used frequently.  <br></p><p>I wouldn’t call it “Immutable” though as “PureValue&quot; indicates what we care about (value semantics).  “ImmutableObject” is just a good name for a value semantic reference type as immutability is the only way to achieve value semantics with a reference type.<br></p><p>It would be great to see “PureValue” added to the standard library and applied to its types.  This would allow us to start drawing the distinction you make in your third category which is very important for many reasons, but is only latent today.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 13:32, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 1:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 11:12, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for types that represent fully self-contained values, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conforming to that protocol requires a bit more thought than just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; being a struct or enum, since there are structs that have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference semantics (such as UnsafePointer), and there are hybrid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; value types that contain references to data that isn&#39;t part of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the value (an Array&lt;Class&gt;, for instance).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d think that both &quot;PureValue&quot; and &quot;PureReference&quot; would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; useful. Isn&#39;t it the mixed types that make for tricky mutation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rules &amp; serialization?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I also like Joe’s idea.  It fits with the direction in Swift of attaching semantics, not just syntax, to protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was thinking of something pretty similar to your PureReference<br>&gt;&gt;&gt;&gt;&gt;&gt; idea, but slightly different.  Pure / immutable references have<br>&gt;&gt;&gt;&gt;&gt;&gt; value semantics.  With that in mind I was thinking of an<br>&gt;&gt;&gt;&gt;&gt;&gt; ImmutableObject protocol which would inherit from both AnyObject<br>&gt;&gt;&gt;&gt;&gt;&gt; and PureValue.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/92a611db/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 10:59 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 4:16 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having given it some more thought... Does &quot;PureReference&quot; make<br>&gt;&gt;&gt; sense? What would it mean? At some point a reference has to, you<br>&gt;&gt;&gt; know, actually refer to a concrete value. Otherwise it&#39;s just<br>&gt;&gt;&gt; turtles all the way down.<br>&gt;&gt; <br>&gt;&gt; In my thinking PureReference (or ImmutableObject) has semantics<br>&gt;&gt; indicating that the type is a value-semantic reference type.  I think<br>&gt;&gt; this could be quite useful in some cases.<br>&gt; <br>&gt; Like what? To a first approximation, the only thing I can see this being<br>&gt; useful for is Objective-C interop.  Aside from being an element of an<br>&gt; NSArray, there&#39;s nothing a an immutable class can do that a struct<br>&gt; can’t.<br>Generic “manager” singletons? Like maybe if you wanted to use something other than NSFileManager? I’m hazy enough on exactly what the singleton pattern means that I’m not sure it matters.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 08:00:00am</p></header><div class="content"><p>on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt; reference.<br>&gt;<br>&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt; of value. <br></p><p>We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>them out, this is going to become impossible to resolve.  So let me<br>propose some terms:<br></p><p>1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>   value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>   In this sense, a variable of any type T “has a value.”  Even though<br>   it&#39;s not strictly correct (since the term really applies to<br>   expressions), I propose “rvalue” for this one.  <br></p><p>2. The “value types vs reference types” sense, where every type falls<br>   into one of two crisp buckets based on how it&#39;s declared.  I propose<br>   we always say “reference type” or “value type” for this one.<br></p><p>3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>   category depends on how it is implemented,  and it&#39;s possible (though<br>   inadvisable) to fall outside either bucket.  This is the only<br>   interesting category when you&#39;re discussing protocols and<br>   constraints, and doesn&#39;t have any intrinsic relationship to sense<br>   #2.  I propose we always say “value semantics” or “reference<br>   semantics” for this one.<br></p><p>&gt; I can see value in there being some kind of PureValue protocol, for<br>&gt; types that represent fully self-contained values, but conforming to<br>&gt; that protocol requires a bit more thought than just being a struct or<br>&gt; enum, since there are structs that have reference semantics (such as<br>&gt; UnsafePointer), and there are hybrid value types that contain<br>&gt; references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for<br>&gt; instance).<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt; <br>&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;   var result = self // not necessarily a copy…<br>&gt;&gt;   result.remove(element)<br>&gt;&gt;   return result // not necessarily an independent value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;   for i in nums.indices {<br>&gt;&gt;     if nums[i] &lt; 0 {<br>&gt;&gt;       nums.removeAtIndex(i)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   // …because of this.<br>&gt;&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;     nums = C()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt; <br>&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt; <br>&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the response, I agree this is currently the best<br>&gt;&gt;&gt; solution. Unfortunately, it&#39;s not just as simple as just<br>&gt;&gt;&gt; implementing each method, since without being able to call super, I<br>&gt;&gt;&gt; have to fully reimplement the original behaviour, which at best<br>&gt;&gt;&gt; seems like bad practice, and would break in future versions of<br>&gt;&gt;&gt; Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply<br>&gt;&gt;&gt; mutating methods unmodified to reference types, as I found trying<br>&gt;&gt;&gt; to make a reference-type collection. This results in the compiler<br>&gt;&gt;&gt; disallowing ‘let’ when calling these functions, and allows methods<br>&gt;&gt;&gt; to reassign the reference ‘self’ to a new object. The best solution<br>&gt;&gt;&gt; is to manually implement each method, removing the mutating<br>&gt;&gt;&gt; modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’<br>&gt;&gt;&gt; mutating functions, which reassign self, and ‘partially’ mutating<br>&gt;&gt;&gt; functions, for use in generics and protocol extensions, which can<br>&gt;&gt;&gt; reassign properties only.<br>&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt;&gt;&gt; possible without some evolution of the language regarding the<br>&gt;&gt;&gt; mutating keyword, so I&#39;m trying to bring this up here in hope of us<br>&gt;&gt;&gt; getting an actual solution. I&#39;ve changed the title to what I hope<br>&gt;&gt;&gt; is something that better reflects the problem; this thread was<br>&gt;&gt;&gt; originally titled ‘[swift-evolution] [Bug?] Reference types and<br>&gt;&gt;&gt; mutating methods’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating<br>&gt;&gt;&gt; functions on my reference-type collection: it seems to trigger<br>&gt;&gt;&gt; didChange on properties, even when, upon comparing the new and old<br>&gt;&gt;&gt; objects, the reference isn&#39;t being changed. I haven&#39;t done much<br>&gt;&gt;&gt; experimentation with this behaviour; this may be an unexpected<br>&gt;&gt;&gt; side-effect of an extension method assigning to self, but it feels<br>&gt;&gt;&gt; like it could be undefined behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;     var value: [T]<br>&gt;&gt;&gt;&gt;     init(value: [T]) {<br>&gt;&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     required init() {<br>&gt;&gt;&gt;&gt;         self.value = []<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;         self.init(elements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var startIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.startIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var endIndex: Index {<br>&gt;&gt;&gt;&gt;         return value.endIndex<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;         return value[position]<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;     typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;         return value.generate()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;     func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;         value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;         value.append(newElement)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 8:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt;&gt; reference.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt;&gt; of value. <br>&gt; <br>&gt; We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>&gt; them out, this is going to become impossible to resolve.  So let me<br>&gt; propose some terms:<br>&gt; <br>&gt; 1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>&gt;   value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>&gt;   In this sense, a variable of any type T “has a value.”  Even though<br>&gt;   it&#39;s not strictly correct (since the term really applies to<br>&gt;   expressions), I propose “rvalue” for this one.  <br>&gt; <br>&gt; 2. The “value types vs reference types” sense, where every type falls<br>&gt;   into one of two crisp buckets based on how it&#39;s declared.  I propose<br>&gt;   we always say “reference type” or “value type” for this one.<br>&gt; <br>&gt; 3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>&gt;   category depends on how it is implemented,  and it&#39;s possible (though<br>&gt;   inadvisable) to fall outside either bucket.  This is the only<br>&gt;   interesting category when you&#39;re discussing protocols and<br>&gt;   constraints, and doesn&#39;t have any intrinsic relationship to sense<br>&gt;   #2.  I propose we always say “value semantics” or “reference<br>&gt;   semantics” for this one.<br></p><p>I claim that my sense is the same as #2. A reference has all the properties of a value-type value; it has the additional ability to be used as a handle to access independent program state. Int isn&#39;t any less of a value because it can be used to reference values in an array. Rather than try to break the world down according to categories of types, I think it&#39;s more effective to look at the semantics of *operations*. So called &quot;reference types&quot; have value semantics operations too; reassigning a class reference, &#39;+=&#39;-ing a pointer, and adding or removing elements from an Array of references are all operations that mutate only the value being operated on, even though none of these types are strictly &quot;value types&quot;.<br></p><p>-Joe<br></p><p>&gt;&gt; I can see value in there being some kind of PureValue protocol, for<br>&gt;&gt; types that represent fully self-contained values, but conforming to<br>&gt;&gt; that protocol requires a bit more thought than just being a struct or<br>&gt;&gt; enum, since there are structs that have reference semantics (such as<br>&gt;&gt; UnsafePointer), and there are hybrid value types that contain<br>&gt;&gt; references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for<br>&gt;&gt; instance).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;&gt;  var result = self // not necessarily a copy…<br>&gt;&gt;&gt;  result.remove(element)<br>&gt;&gt;&gt;  return result // not necessarily an independent value<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;&gt;  // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;&gt;  for i in nums.indices {<br>&gt;&gt;&gt;    if nums[i] &lt; 0 {<br>&gt;&gt;&gt;      nums.removeAtIndex(i)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  // …because of this.<br>&gt;&gt;&gt;  if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;&gt;    nums = C()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for the response, I agree this is currently the best<br>&gt;&gt;&gt;&gt; solution. Unfortunately, it&#39;s not just as simple as just<br>&gt;&gt;&gt;&gt; implementing each method, since without being able to call super, I<br>&gt;&gt;&gt;&gt; have to fully reimplement the original behaviour, which at best<br>&gt;&gt;&gt;&gt; seems like bad practice, and would break in future versions of<br>&gt;&gt;&gt;&gt; Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply<br>&gt;&gt;&gt;&gt; mutating methods unmodified to reference types, as I found trying<br>&gt;&gt;&gt;&gt; to make a reference-type collection. This results in the compiler<br>&gt;&gt;&gt;&gt; disallowing ‘let’ when calling these functions, and allows methods<br>&gt;&gt;&gt;&gt; to reassign the reference ‘self’ to a new object. The best solution<br>&gt;&gt;&gt;&gt; is to manually implement each method, removing the mutating<br>&gt;&gt;&gt;&gt; modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’<br>&gt;&gt;&gt;&gt; mutating functions, which reassign self, and ‘partially’ mutating<br>&gt;&gt;&gt;&gt; functions, for use in generics and protocol extensions, which can<br>&gt;&gt;&gt;&gt; reassign properties only.<br>&gt;&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt;&gt;&gt;&gt; possible without some evolution of the language regarding the<br>&gt;&gt;&gt;&gt; mutating keyword, so I&#39;m trying to bring this up here in hope of us<br>&gt;&gt;&gt;&gt; getting an actual solution. I&#39;ve changed the title to what I hope<br>&gt;&gt;&gt;&gt; is something that better reflects the problem; this thread was<br>&gt;&gt;&gt;&gt; originally titled ‘[swift-evolution] [Bug?] Reference types and<br>&gt;&gt;&gt;&gt; mutating methods’.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating<br>&gt;&gt;&gt;&gt; functions on my reference-type collection: it seems to trigger<br>&gt;&gt;&gt;&gt; didChange on properties, even when, upon comparing the new and old<br>&gt;&gt;&gt;&gt; objects, the reference isn&#39;t being changed. I haven&#39;t done much<br>&gt;&gt;&gt;&gt; experimentation with this behaviour; this may be an unexpected<br>&gt;&gt;&gt;&gt; side-effect of an extension method assigning to self, but it feels<br>&gt;&gt;&gt;&gt; like it could be undefined behaviour.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;    var value: [T]<br>&gt;&gt;&gt;&gt;&gt;    init(value: [T]) {<br>&gt;&gt;&gt;&gt;&gt;        self.value = value<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;    required init() {<br>&gt;&gt;&gt;&gt;&gt;        self.value = []<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;&gt;        self.init(elements)<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;    typealias Index = Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    var startIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;        return value.startIndex<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    var endIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;        return value.endIndex<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;        return value[position]<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;&gt;    typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;&gt;        return value.generate()<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;    func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;&gt;        value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;&gt;        value.append(newElement)<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 11:06 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 5, 2016, at 8:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt;&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt;&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt;&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt;&gt;&gt; reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt;&gt;&gt; of value. <br>&gt;&gt; <br>&gt;&gt; We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>&gt;&gt; them out, this is going to become impossible to resolve.  So let me<br>&gt;&gt; propose some terms:<br>&gt;&gt; <br>&gt;&gt; 1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>&gt;&gt;  value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>&gt;&gt;  In this sense, a variable of any type T “has a value.”  Even though<br>&gt;&gt;  it&#39;s not strictly correct (since the term really applies to<br>&gt;&gt;  expressions), I propose “rvalue” for this one.  <br>&gt;&gt; <br>&gt;&gt; 2. The “value types vs reference types” sense, where every type falls<br>&gt;&gt;  into one of two crisp buckets based on how it&#39;s declared.  I propose<br>&gt;&gt;  we always say “reference type” or “value type” for this one.<br>&gt;&gt; <br>&gt;&gt; 3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>&gt;&gt;  category depends on how it is implemented,  and it&#39;s possible (though<br>&gt;&gt;  inadvisable) to fall outside either bucket.  This is the only<br>&gt;&gt;  interesting category when you&#39;re discussing protocols and<br>&gt;&gt;  constraints, and doesn&#39;t have any intrinsic relationship to sense<br>&gt;&gt;  #2.  I propose we always say “value semantics” or “reference<br>&gt;&gt;  semantics” for this one.<br>&gt; <br>&gt; I claim that my sense is the same as #2. A reference has all the properties of a value-type value; it has the additional ability to be used as a handle to access independent program state. Int isn&#39;t any less of a value because it can be used to reference values in an array. Rather than try to break the world down according to categories of types, I think it&#39;s more effective to look at the semantics of *operations*. So called &quot;reference types&quot; have value semantics operations too; reassigning a class reference, &#39;+=&#39;-ing a pointer, and adding or removing elements from an Array of references are all operations that mutate only the value being operated on, even though none of these types are strictly &quot;value types”.<br></p><p>The distinction between “reference as a value” and “value the reference points to” is a pretty important one.  All of the operations you discuss are really operations on the “reference as a value”. <br></p><p>I think the reason we talk about *types* rather than *operations* having value semantics is because that tells us that *all* operations on any instance are going to have value semantics.  This means that *nobody else* is going to mutate the variable in question behind our back.  If the type has “reference semantic operations” we don’t have that guarantee today.  The fact that the type may also have some &quot;value semantic operations&quot; seems relatively unimportant.<br></p><p>One possible avenue for improvement in the language where this distinction could be useful is by allowing us to specify which operations have &quot;value semantics&quot; on reference types and allow us to designate specific *references* as being value semantic.  `let` wouldn’t work as that only means that the reference itself is immutable, not the value it refers to.  We would need some additional syntax to specify that the value the reference points to cannot be mutated.  Such a reference could only be assigned to when the compiler can prove it will refer to a value that has *no* existing mutable references.  This would allow us to capture the benefits of value semantics for specific *instances* of a reference type.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for<br>&gt;&gt;&gt; types that represent fully self-contained values, but conforming to<br>&gt;&gt;&gt; that protocol requires a bit more thought than just being a struct or<br>&gt;&gt;&gt; enum, since there are structs that have reference semantics (such as<br>&gt;&gt;&gt; UnsafePointer), and there are hybrid value types that contain<br>&gt;&gt;&gt; references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for<br>&gt;&gt;&gt; instance).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TJ<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;&gt;&gt; var result = self // not necessarily a copy…<br>&gt;&gt;&gt;&gt; result.remove(element)<br>&gt;&gt;&gt;&gt; return result // not necessarily an independent value<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;&gt;&gt; // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;&gt;&gt; for i in nums.indices {<br>&gt;&gt;&gt;&gt;   if nums[i] &lt; 0 {<br>&gt;&gt;&gt;&gt;     nums.removeAtIndex(i)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // …because of this.<br>&gt;&gt;&gt;&gt; if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;&gt;&gt;   nums = C()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt;&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt;&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for the response, I agree this is currently the best<br>&gt;&gt;&gt;&gt;&gt; solution. Unfortunately, it&#39;s not just as simple as just<br>&gt;&gt;&gt;&gt;&gt; implementing each method, since without being able to call super, I<br>&gt;&gt;&gt;&gt;&gt; have to fully reimplement the original behaviour, which at best<br>&gt;&gt;&gt;&gt;&gt; seems like bad practice, and would break in future versions of<br>&gt;&gt;&gt;&gt;&gt; Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply<br>&gt;&gt;&gt;&gt;&gt; mutating methods unmodified to reference types, as I found trying<br>&gt;&gt;&gt;&gt;&gt; to make a reference-type collection. This results in the compiler<br>&gt;&gt;&gt;&gt;&gt; disallowing ‘let’ when calling these functions, and allows methods<br>&gt;&gt;&gt;&gt;&gt; to reassign the reference ‘self’ to a new object. The best solution<br>&gt;&gt;&gt;&gt;&gt; is to manually implement each method, removing the mutating<br>&gt;&gt;&gt;&gt;&gt; modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’<br>&gt;&gt;&gt;&gt;&gt; mutating functions, which reassign self, and ‘partially’ mutating<br>&gt;&gt;&gt;&gt;&gt; functions, for use in generics and protocol extensions, which can<br>&gt;&gt;&gt;&gt;&gt; reassign properties only.<br>&gt;&gt;&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt;&gt;&gt;&gt;&gt; possible without some evolution of the language regarding the<br>&gt;&gt;&gt;&gt;&gt; mutating keyword, so I&#39;m trying to bring this up here in hope of us<br>&gt;&gt;&gt;&gt;&gt; getting an actual solution. I&#39;ve changed the title to what I hope<br>&gt;&gt;&gt;&gt;&gt; is something that better reflects the problem; this thread was<br>&gt;&gt;&gt;&gt;&gt; originally titled ‘[swift-evolution] [Bug?] Reference types and<br>&gt;&gt;&gt;&gt;&gt; mutating methods’.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating<br>&gt;&gt;&gt;&gt;&gt; functions on my reference-type collection: it seems to trigger<br>&gt;&gt;&gt;&gt;&gt; didChange on properties, even when, upon comparing the new and old<br>&gt;&gt;&gt;&gt;&gt; objects, the reference isn&#39;t being changed. I haven&#39;t done much<br>&gt;&gt;&gt;&gt;&gt; experimentation with this behaviour; this may be an unexpected<br>&gt;&gt;&gt;&gt;&gt; side-effect of an extension method assigning to self, but it feels<br>&gt;&gt;&gt;&gt;&gt; like it could be undefined behaviour.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var value: [T]<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(value: [T]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;       self.value = value<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   required init() {<br>&gt;&gt;&gt;&gt;&gt;&gt;       self.value = []<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;       self.init(elements)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;&gt;   typealias Index = Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   var startIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return value.startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   var endIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return value.endIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return value[position]<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;&gt;&gt;   typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return value.generate()<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;&gt;   func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;&gt;&gt;       value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;&gt;&gt;       value.append(newElement)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/8e2b923b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu May 05 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On May 5, 2016, at 8:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt;&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt;&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt;&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt;&gt;&gt; reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt;&gt;&gt; of value. <br>&gt;&gt; <br>&gt;&gt; We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>&gt;&gt; them out, this is going to become impossible to resolve.  So let me<br>&gt;&gt; propose some terms:<br>&gt;&gt; <br>&gt;&gt; 1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>&gt;&gt;   value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>&gt;&gt;   In this sense, a variable of any type T “has a value.”  Even though<br>&gt;&gt;   it&#39;s not strictly correct (since the term really applies to<br>&gt;&gt;   expressions), I propose “rvalue” for this one.  <br>&gt;&gt; <br>&gt;&gt; 2. The “value types vs reference types” sense, where every type falls<br>&gt;&gt;   into one of two crisp buckets based on how it&#39;s declared.  I propose<br>&gt;&gt;   we always say “reference type” or “value type” for this one.<br>&gt;&gt; <br>&gt;&gt; 3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>&gt;&gt;   category depends on how it is implemented,  and it&#39;s possible (though<br>&gt;&gt;   inadvisable) to fall outside either bucket.  This is the only<br>&gt;&gt;   interesting category when you&#39;re discussing protocols and<br>&gt;&gt;   constraints, and doesn&#39;t have any intrinsic relationship to sense<br>&gt;&gt;   #2.  I propose we always say “value semantics” or “reference<br>&gt;&gt;   semantics” for this one.<br>&gt;<br>&gt; I claim that my sense is the same as #2. A reference has all the<br>&gt; properties of a value-type value; it has the additional ability to be<br>&gt; used as a handle to access independent program state. Int isn&#39;t any<br>&gt; less of a value because it can be used to reference values in an<br>&gt; array. <br></p><p>It&#39;s less of a value in sense #2 because <br></p><p>  x as Any as? AnyObject<br></p><p>is always nil for a value in sense #2.<br></p><p>&gt; Rather than try to break the world down according to categories of<br>&gt; types, I think it&#39;s more effective to look at the semantics of<br>&gt; *operations*. So called &quot;reference types&quot; have value semantics<br>&gt; operations too; <br></p><p>Please define the term “value semantics operation.”  I wager there is no<br>such thing.<br></p><p>&gt; reassigning a class reference, &#39;+=&#39;-ing a pointer,<br></p><p>A pointer is a value type in every sense of the word.<br></p><p>&gt; and adding or removing elements from an Array of references are all<br>&gt; operations that mutate only the value being operated on, even though<br>&gt; none of these types are strictly &quot;value types&quot;.<br></p><p>Now you&#39;re really blending meanings, or at least being very fuzzy.  Your<br>Array of references has a sense #1 value that might not even be altered<br>when you change the elements in the array.  It is a sense #2 value by<br>language rules.  It almost has sense #3 value semantics but for our<br>inability to compare it with &quot;==&quot;, because we don&#39;t implicitly get &quot;==&quot;<br>defined in terms of &quot;===&quot; for all classes.<br></p><p>Saying something has value semantics is meaningless without a way to<br>determine equivalence that respects the boundaries of the value.  The<br>*whole point* of value semantics is that initialization, assignment,<br>parameter passing, and returning all create *independent* instances, with<br>no observable shared state, and that can be read and mutated<br>concurrently in different threads.  To even test that, you need to nail<br>down what it means for a value to change, and for that, you need an<br>equality comparison.<br></p><p>&gt; -Joe<br>&gt;<br>&gt;&gt;&gt; I can see value in there being some kind of PureValue protocol, for<br>&gt;&gt;&gt; types that represent fully self-contained values, but conforming to<br>&gt;&gt;&gt; that protocol requires a bit more thought than just being a struct or<br>&gt;&gt;&gt; enum, since there are structs that have reference semantics (such as<br>&gt;&gt;&gt; UnsafePointer), and there are hybrid value types that contain<br>&gt;&gt;&gt; references to data that isn&#39;t part of the value (an Array&lt;Class&gt;, for<br>&gt;&gt;&gt; instance).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TJ<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;&gt;&gt;&gt;  var result = self // not necessarily a copy…<br>&gt;&gt;&gt;&gt;  result.remove(element)<br>&gt;&gt;&gt;&gt;  return result // not necessarily an independent value<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;&gt;&gt;&gt;  // requires inout on ‘nums’  even when it’s a class<br>&gt;&gt;&gt;&gt;  for i in nums.indices {<br>&gt;&gt;&gt;&gt;    if nums[i] &lt; 0 {<br>&gt;&gt;&gt;&gt;      nums.removeAtIndex(i)<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;  // …because of this.<br>&gt;&gt;&gt;&gt;  if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;&gt;&gt;&gt;    nums = C()<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;&gt;&gt;&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;&gt;&gt;&gt; zapBadElements(&amp;refCollection)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In lieu of this, I and a few others brought up the “incorrect” behavior of reassigning ‘self’ in a protocol extension when the model type is a class, and got shot down. I don’t have those discussions on hand at the moment, but I remember we deliberately decided to leave protocol extensions the way they were, allowing them to reassign class references. I think it’s because it means things like zapBadElements are more likely to work correctly^W as expected―if you don’t have any other references at the time you do the mutation, it can work. But yeah, I’m uncomfortable with the situation we’re in right now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 3, 2016, at 13:09, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for the response, I agree this is currently the best<br>&gt;&gt;&gt;&gt;&gt; solution. Unfortunately, it&#39;s not just as simple as just<br>&gt;&gt;&gt;&gt;&gt; implementing each method, since without being able to call super, I<br>&gt;&gt;&gt;&gt;&gt; have to fully reimplement the original behaviour, which at best<br>&gt;&gt;&gt;&gt;&gt; seems like bad practice, and would break in future versions of<br>&gt;&gt;&gt;&gt;&gt; Swift, and at worst could lead to hard-to-detect bugs right now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To recap for anyone reading, protocol extensions currently apply<br>&gt;&gt;&gt;&gt;&gt; mutating methods unmodified to reference types, as I found trying<br>&gt;&gt;&gt;&gt;&gt; to make a reference-type collection. This results in the compiler<br>&gt;&gt;&gt;&gt;&gt; disallowing ‘let’ when calling these functions, and allows methods<br>&gt;&gt;&gt;&gt;&gt; to reassign the reference ‘self’ to a new object. The best solution<br>&gt;&gt;&gt;&gt;&gt; is to manually implement each method, removing the mutating<br>&gt;&gt;&gt;&gt;&gt; modifier, yet this workaround doesn&#39;t extend to generic code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To fix this behaviour, we would need to distinguish between ‘true’<br>&gt;&gt;&gt;&gt;&gt; mutating functions, which reassign self, and ‘partially’ mutating<br>&gt;&gt;&gt;&gt;&gt; functions, for use in generics and protocol extensions, which can<br>&gt;&gt;&gt;&gt;&gt; reassign properties only.<br>&gt;&gt;&gt;&gt;&gt; Is there any support for making this change? Or are there any simpler solutions?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt;&gt;&gt;&gt;&gt; possible without some evolution of the language regarding the<br>&gt;&gt;&gt;&gt;&gt; mutating keyword, so I&#39;m trying to bring this up here in hope of us<br>&gt;&gt;&gt;&gt;&gt; getting an actual solution. I&#39;ve changed the title to what I hope<br>&gt;&gt;&gt;&gt;&gt; is something that better reflects the problem; this thread was<br>&gt;&gt;&gt;&gt;&gt; originally titled ‘[swift-evolution] [Bug?] Reference types and<br>&gt;&gt;&gt;&gt;&gt; mutating methods’.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; PS: I have noticed another side-effect of calling mutating<br>&gt;&gt;&gt;&gt;&gt; functions on my reference-type collection: it seems to trigger<br>&gt;&gt;&gt;&gt;&gt; didChange on properties, even when, upon comparing the new and old<br>&gt;&gt;&gt;&gt;&gt; objects, the reference isn&#39;t being changed. I haven&#39;t done much<br>&gt;&gt;&gt;&gt;&gt; experimentation with this behaviour; this may be an unexpected<br>&gt;&gt;&gt;&gt;&gt; side-effect of an extension method assigning to self, but it feels<br>&gt;&gt;&gt;&gt;&gt; like it could be undefined behaviour.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The problem here seems to be with using the default implementation provided. If you override `append` in ObservedArray, the compiler allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to implement every mutating method, but that is the current solution. I haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt;&gt;&gt;&gt; class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var value: [T]<br>&gt;&gt;&gt;&gt;&gt;&gt;    init(value: [T]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;        self.value = value<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;    required init() {<br>&gt;&gt;&gt;&gt;&gt;&gt;        self.value = []<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    required convenience init(arrayLiteral elements: T...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;        self.init(elements)<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;&gt;    typealias Index = Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    var startIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;        return value.startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    var endIndex: Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;        return value.endIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    subscript(position: Index) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt;        return value[position]<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;&gt;&gt;&gt;&gt;&gt;    typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func generate() -&gt; Generator {<br>&gt;&gt;&gt;&gt;&gt;&gt;        return value.generate()<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension ObservedArray {<br>&gt;&gt;&gt;&gt;&gt;&gt;    func replaceRange&lt;C : CollectionType where C.Generator.Element == Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;&gt;&gt;&gt;&gt;&gt;        value.replaceRange(subRange, with: newElements)<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;&gt;&gt;&gt;&gt;&gt;        value.append(newElement)<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t believe this has been addressed, please correct me if I&#39;m wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --My Situation--<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve recently been working on an observable collection type. Because each stores ‘subscriptions’ to changes that occur, it made sense to me that this should be a reference type, so subscriptions can&#39;t be copied with the values themselves.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have made this class conform to RangeReplaceableCollectionType, providing it with all the standard collection functions. I do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let array: ObservedArray&lt;String&gt; = []<br>&gt;&gt;&gt;&gt;&gt;&gt; array.append(&quot;1&quot;) //Error: Cannot use mutating member on immutable value: ‘array’ is a ‘let’ constant<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have to make the reference immutable just to use my new collection type? This is a bit of a deal-breaker.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --The Problem--<br>&gt;&gt;&gt;&gt;&gt;&gt; Mutating methods allow ‘self’ to be reassigned, which is just another way to mutate a value type. However, reassigning ‘self’ has a special meaning to reference types, which is presumably the reason they are disallowed in classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, classes can conform to protocols with mutating methods, leading to the compiler disallowing calls to mutating methods for ‘let’ values of type ‘protocol&lt;MutatingProtocol, AnyObject&gt;’, which can be an annoyance in generic code. In addition, classes can inherit mutating methods from protocol extensions, leading to the behaviour I describe above.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is this intentional behaviour? Am I going about this in the wrong way? Or is this really an omission in the language?<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 10:03 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 5, 2016, at 8:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt;&gt;&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt;&gt;&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt;&gt;&gt;&gt; reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt;&gt;&gt;&gt; of value. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>&gt;&gt;&gt; them out, this is going to become impossible to resolve.  So let me<br>&gt;&gt;&gt; propose some terms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>&gt;&gt;&gt;  value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>&gt;&gt;&gt;  In this sense, a variable of any type T “has a value.”  Even though<br>&gt;&gt;&gt;  it&#39;s not strictly correct (since the term really applies to<br>&gt;&gt;&gt;  expressions), I propose “rvalue” for this one.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The “value types vs reference types” sense, where every type falls<br>&gt;&gt;&gt;  into one of two crisp buckets based on how it&#39;s declared.  I propose<br>&gt;&gt;&gt;  we always say “reference type” or “value type” for this one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>&gt;&gt;&gt;  category depends on how it is implemented,  and it&#39;s possible (though<br>&gt;&gt;&gt;  inadvisable) to fall outside either bucket.  This is the only<br>&gt;&gt;&gt;  interesting category when you&#39;re discussing protocols and<br>&gt;&gt;&gt;  constraints, and doesn&#39;t have any intrinsic relationship to sense<br>&gt;&gt;&gt;  #2.  I propose we always say “value semantics” or “reference<br>&gt;&gt;&gt;  semantics” for this one.<br>&gt;&gt; <br>&gt;&gt; I claim that my sense is the same as #2. A reference has all the<br>&gt;&gt; properties of a value-type value; it has the additional ability to be<br>&gt;&gt; used as a handle to access independent program state. Int isn&#39;t any<br>&gt;&gt; less of a value because it can be used to reference values in an<br>&gt;&gt; array. <br>&gt; <br>&gt; It&#39;s less of a value in sense #2 because <br>&gt; <br>&gt;  x as Any as? AnyObject<br>&gt; <br>&gt; is always nil for a value in sense #2.<br>&gt; <br>&gt;&gt; Rather than try to break the world down according to categories of<br>&gt;&gt; types, I think it&#39;s more effective to look at the semantics of<br>&gt;&gt; *operations*. So called &quot;reference types&quot; have value semantics<br>&gt;&gt; operations too; <br>&gt; <br>&gt; Please define the term “value semantics operation.”  I wager there is no<br>&gt; such thing.<br></p><p>A mutating operation with no other side effects than modifying the values of its &#39;inout&#39; parameters.<br></p><p>&gt; <br>&gt;&gt; reassigning a class reference, &#39;+=&#39;-ing a pointer,<br>&gt; <br>&gt; A pointer is a value type in every sense of the word.<br>&gt; <br>&gt;&gt; and adding or removing elements from an Array of references are all<br>&gt;&gt; operations that mutate only the value being operated on, even though<br>&gt;&gt; none of these types are strictly &quot;value types&quot;.<br>&gt; <br>&gt; Now you&#39;re really blending meanings, or at least being very fuzzy.  Your<br>&gt; Array of references has a sense #1 value that might not even be altered<br>&gt; when you change the elements in the array.  It is a sense #2 value by<br>&gt; language rules.  It almost has sense #3 value semantics but for our<br>&gt; inability to compare it with &quot;==&quot;, because we don&#39;t implicitly get &quot;==&quot;<br>&gt; defined in terms of &quot;===&quot; for all classes.<br>&gt; <br>&gt; Saying something has value semantics is meaningless without a way to<br>&gt; determine equivalence that respects the boundaries of the value.  The<br>&gt; *whole point* of value semantics is that initialization, assignment,<br>&gt; parameter passing, and returning all create *independent* instances, with<br>&gt; no observable shared state, and that can be read and mutated<br>&gt; concurrently in different threads.  To even test that, you need to nail<br>&gt; down what it means for a value to change, and for that, you need an<br>&gt; equality comparison.<br></p><p>What I&#39;m trying to say is that there are &quot;boundaries of the value&quot; for everything in our system. For class references, that boundary happens to only include the reference itself.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 12:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On May 5, 2016, at 10:03 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu May 05 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On May 5, 2016, at 8:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed May 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 4, 2016, at 5:28 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something about your first paragraph reminded me of a question I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt; had for a while. Is there a reasoning behind not being able to<br>&gt;&gt;&gt;&gt;&gt;&gt; restrict a protocol to value types? One way that this might be<br>&gt;&gt;&gt;&gt;&gt;&gt; workable is if we could overload protocols for Value vs for<br>&gt;&gt;&gt;&gt;&gt;&gt; reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not totally comfortable with this, because references are a kind<br>&gt;&gt;&gt;&gt;&gt; of value. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re using the word “value” in 3 different ways now.  If we don&#39;t sort<br>&gt;&gt;&gt;&gt; them out, this is going to become impossible to resolve.  So let me<br>&gt;&gt;&gt;&gt; propose some terms:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Joe&#39;s sense, i.e. the compiler-implementation-level sense, in which a<br>&gt;&gt;&gt;&gt;  value of type T is essentially what an UnsafePointer&lt;T&gt; points at.<br>&gt;&gt;&gt;&gt;  In this sense, a variable of any type T “has a value.”  Even though<br>&gt;&gt;&gt;&gt;  it&#39;s not strictly correct (since the term really applies to<br>&gt;&gt;&gt;&gt;  expressions), I propose “rvalue” for this one.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. The “value types vs reference types” sense, where every type falls<br>&gt;&gt;&gt;&gt;  into one of two crisp buckets based on how it&#39;s declared.  I propose<br>&gt;&gt;&gt;&gt;  we always say “reference type” or “value type” for this one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. The “value semantics vs reference semantics” sense, where a type&#39;s<br>&gt;&gt;&gt;&gt;  category depends on how it is implemented,  and it&#39;s possible (though<br>&gt;&gt;&gt;&gt;  inadvisable) to fall outside either bucket.  This is the only<br>&gt;&gt;&gt;&gt;  interesting category when you&#39;re discussing protocols and<br>&gt;&gt;&gt;&gt;  constraints, and doesn&#39;t have any intrinsic relationship to sense<br>&gt;&gt;&gt;&gt;  #2.  I propose we always say “value semantics” or “reference<br>&gt;&gt;&gt;&gt;  semantics” for this one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I claim that my sense is the same as #2. A reference has all the<br>&gt;&gt;&gt; properties of a value-type value; it has the additional ability to be<br>&gt;&gt;&gt; used as a handle to access independent program state. Int isn&#39;t any<br>&gt;&gt;&gt; less of a value because it can be used to reference values in an<br>&gt;&gt;&gt; array. <br>&gt;&gt; <br>&gt;&gt; It&#39;s less of a value in sense #2 because <br>&gt;&gt; <br>&gt;&gt;  x as Any as? AnyObject<br>&gt;&gt; <br>&gt;&gt; is always nil for a value in sense #2.<br>&gt;&gt; <br>&gt;&gt;&gt; Rather than try to break the world down according to categories of<br>&gt;&gt;&gt; types, I think it&#39;s more effective to look at the semantics of<br>&gt;&gt;&gt; *operations*. So called &quot;reference types&quot; have value semantics<br>&gt;&gt;&gt; operations too; <br>&gt;&gt; <br>&gt;&gt; Please define the term “value semantics operation.”  I wager there is no<br>&gt;&gt; such thing.<br>&gt;<br>&gt; A mutating operation with no other side effects than modifying the values of its &#39;inout&#39; parameters.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; reassigning a class reference, &#39;+=&#39;-ing a pointer,<br>&gt;&gt; <br>&gt;&gt; A pointer is a value type in every sense of the word.<br>&gt;&gt; <br>&gt;&gt;&gt; and adding or removing elements from an Array of references are all<br>&gt;&gt;&gt; operations that mutate only the value being operated on, even though<br>&gt;&gt;&gt; none of these types are strictly &quot;value types&quot;.<br>&gt;&gt; <br>&gt;&gt; Now you&#39;re really blending meanings, or at least being very fuzzy.  Your<br>&gt;&gt; Array of references has a sense #1 value that might not even be altered<br>&gt;&gt; when you change the elements in the array.  It is a sense #2 value by<br>&gt;&gt; language rules.  It almost has sense #3 value semantics but for our<br>&gt;&gt; inability to compare it with &quot;==&quot;, because we don&#39;t implicitly get &quot;==&quot;<br>&gt;&gt; defined in terms of &quot;===&quot; for all classes.<br>&gt;&gt; <br>&gt;&gt; Saying something has value semantics is meaningless without a way to<br>&gt;&gt; determine equivalence that respects the boundaries of the value.  The<br>&gt;&gt; *whole point* of value semantics is that initialization, assignment,<br>&gt;&gt; parameter passing, and returning all create *independent* instances, with<br>&gt;&gt; no observable shared state, and that can be read and mutated<br>&gt;&gt; concurrently in different threads.  To even test that, you need to nail<br>&gt;&gt; down what it means for a value to change, and for that, you need an<br>&gt;&gt; equality comparison.<br>&gt;<br>&gt; What I&#39;m trying to say is that there are &quot;boundaries of the value&quot; for<br>&gt; everything in our system. For class references, that boundary happens<br>&gt; to only include the reference itself.<br></p><p>I would agree that there are *potential* “boundaries of the value” for<br>everything in our system.  Up to now, there has been no general<br>agreement that the default “boundaries of the value” for references stop<br>at the reference&#39;s own bits, and that mutable classes can&#39;t have an &quot;==&quot;<br>that reaches beyond those bits.  Until we reach such agreement, I don&#39;t<br>think there&#39;s any reasonable way to argue that any of the three<br>categories I listed are the same.  And I think we need those categories<br>in order to create that agreement.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 08:00:00am</p></header><div class="content"><p>on Wed May 04 2016, &quot;T.J. Usiyan&quot; &lt;griotspeak-AT-gmail.com&gt; wrote:<br></p><p>&gt; Something about your first paragraph reminded me of a question I&#39;ve had for a<br>&gt; while. Is there a reasoning behind not being able to restrict a protocol to<br>&gt; value types? <br></p><p>There are two answers:<br></p><p>1. We haven&#39;t gotten around to it<br></p><p>2. As I mentioned elsewhere, that doesn&#39;t really have any meaning unless<br>   we also add some semantic restrictions, because a “value type” can have<br>   reference semantics. <br></p><p>&gt; One way that this might be workable is if we could overload protocols<br>&gt; for Value vs for reference.<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Tue, May 3, 2016 at 11:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;     Dave and I have pondered this before, and considered that one possible<br>&gt;     (drastic) solution is to ban classes from implementing protocols with<br>&gt;     mutating members, on the grounds that it’s very hard to write an algorithm<br>&gt;     that’s correct for both.<br>&gt;<br>&gt;         func removing(_ element: Element) -&gt; Self {<br>&gt;         var result = self // not necessarily a copy…<br>&gt;         result.remove(element)<br>&gt;         return result // not necessarily an independent value<br>&gt;         }<br>&gt;<br>&gt;         func zapBadElements&lt;C: RangeReplaceableCollection where<br>&gt;         C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;         // requires inout on ‘nums’ even when it’s a class<br>&gt;         for i in nums.indices {<br>&gt;         if nums[i] &lt; 0 {<br>&gt;         nums.removeAtIndex(i)<br>&gt;         }<br>&gt;         }<br>&gt;         // …because of this.<br>&gt;         if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;         nums = C()<br>&gt;         }<br>&gt;         }<br>&gt;<br>&gt;         var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt;         // either the variable ‘refCollection’ or the instance of<br>&gt;         ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt;         zapBadElements(&amp;refCollection)<br>&gt;<br>&gt;     There are of course ways to safely use a protocol with mutating requirements<br>&gt;     with classes, namely if you only use them for mutation (i.e. they’re only<br>&gt;     called from ‘mutating’ members or on ‘inout’ parameters) and never rely on<br>&gt;     value copying (no assignment, no returning). Most simple wrappers around<br>&gt;     mutating members would fall into this category.<br>&gt;<br>&gt;     We didn’t really develop the idea very far yet because there’s been more<br>&gt;     pressing things to worry about. I’m bringing it up here because it’s an<br>&gt;     important idea that shouldn’t get lost.<br>&gt;<br>&gt;     ---<br>&gt;<br>&gt;     In lieu of this, I and a few others brought up the “incorrect” behavior of<br>&gt;     reassigning ‘self’ in a protocol extension when the model type is a class,<br>&gt;     and got shot down. I don’t have those discussions on hand at the moment, but<br>&gt;     I remember we deliberately decided to leave protocol extensions the way they<br>&gt;     were, allowing them to reassign class references. I think it’s because it<br>&gt;     means things like zapBadElements are more likely to work correctly^W as<br>&gt;     expected―if you don’t have any other references at the time you do the<br>&gt;     mutation, it can work. But yeah, I’m uncomfortable with the situation we’re<br>&gt;     in right now.<br>&gt;<br>&gt;     Jordan<br>&gt;<br>&gt;         On May 3, 2016, at 13:09, James Froggatt via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         Thanks for the response, I agree this is currently the best solution.<br>&gt;         Unfortunately, it&#39;s not just as simple as just implementing each method,<br>&gt;         since without being able to call super, I have to fully reimplement the<br>&gt;         original behaviour, which at best seems like bad practice, and would<br>&gt;         break in future versions of Swift, and at worst could lead to<br>&gt;         hard-to-detect bugs right now.<br>&gt;<br>&gt;         To recap for anyone reading, protocol extensions currently apply<br>&gt;         mutating methods unmodified to reference types, as I found trying to<br>&gt;         make a reference-type collection. This results in the compiler<br>&gt;         disallowing ‘let’ when calling these functions, and allows methods to<br>&gt;         reassign the reference ‘self’ to a new object. The best solution is to<br>&gt;         manually implement each method, removing the mutating modifier, yet this<br>&gt;         workaround doesn&#39;t extend to generic code.<br>&gt;<br>&gt;         To fix this behaviour, we would need to distinguish between ‘true’<br>&gt;         mutating functions, which reassign self, and ‘partially’ mutating<br>&gt;         functions, for use in generics and protocol extensions, which can<br>&gt;         reassign properties only.<br>&gt;<br>&gt;         Is there any support for making this change? Or are there any simpler<br>&gt;         solutions?<br>&gt;<br>&gt;         I did submit a bug report, but I&#39;m pretty sure a decent fix is not<br>&gt;         possible without some evolution of the language regarding the mutating<br>&gt;         keyword, so I&#39;m trying to bring this up here in hope of us getting an<br>&gt;         actual solution. I&#39;ve changed the title to what I hope is something that<br>&gt;         better reflects the problem; this thread was originally titled<br>&gt;         ‘[swift-evolution] [Bug?] Reference types and mutating methods’.<br>&gt;<br>&gt;         PS: I have noticed another side-effect of calling mutating functions on<br>&gt;         my reference-type collection: it seems to trigger didChange on<br>&gt;         properties, even when, upon comparing the new and old objects, the<br>&gt;         reference isn&#39;t being changed. I haven&#39;t done much experimentation with<br>&gt;         this behaviour; this may be an unexpected side-effect of an extension<br>&gt;         method assigning to self, but it feels like it could be undefined<br>&gt;         behaviour.<br>&gt;<br>&gt;         From James F<br>&gt;<br>&gt;         On 30 Apr 2016, at 16:38, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt;             The problem here seems to be with using the default implementation<br>&gt;             provided. If you override `append` in ObservedArray, the compiler<br>&gt;             allows it. That seems &#39;safe&#39; but odd at first. I wouldn&#39;t *want* to<br>&gt;             implement every mutating method, but that is the current solution. I<br>&gt;             haven&#39;t puzzled out the reasoning behind this myself.<br>&gt;<br>&gt;             ``` swift<br>&gt;<br>&gt;             class ObservedArray&lt;T&gt; : ArrayLiteralConvertible {<br>&gt;             var value: [T]<br>&gt;             init(value: [T]) {<br>&gt;             self.value = value<br>&gt;             }<br>&gt;             required init() {<br>&gt;             self.value = []<br>&gt;             }<br>&gt;<br>&gt;             required convenience init(arrayLiteral elements: T...) {<br>&gt;             self.init(elements)<br>&gt;             }<br>&gt;<br>&gt;             }<br>&gt;<br>&gt;             extension ObservedArray {<br>&gt;             typealias Index = Int<br>&gt;<br>&gt;             var startIndex: Index {<br>&gt;             return value.startIndex<br>&gt;             }<br>&gt;<br>&gt;             var endIndex: Index {<br>&gt;             return value.endIndex<br>&gt;             }<br>&gt;<br>&gt;             subscript(position: Index) -&gt; T {<br>&gt;             return value[position]<br>&gt;             }<br>&gt;<br>&gt;             }<br>&gt;<br>&gt;             extension ObservedArray : RangeReplaceableCollectionType {<br>&gt;             typealias Generator = IndexingGenerator&lt;[T]&gt;<br>&gt;<br>&gt;             func generate() -&gt; Generator {<br>&gt;             return value.generate()<br>&gt;             }<br>&gt;             }<br>&gt;<br>&gt;             extension ObservedArray {<br>&gt;             func replaceRange&lt;C : CollectionType where C.Generator.Element ==<br>&gt;             Generator.Element&gt;(subRange: Range&lt;Index&gt;, with newElements: C) {<br>&gt;             value.replaceRange(subRange, with: newElements)<br>&gt;             }<br>&gt;<br>&gt;             func append(newElement: T) { // &lt;- adding this makes it work<br>&gt;             value.append(newElement)<br>&gt;             }<br>&gt;             }<br>&gt;<br>&gt;             let array: ObservedArray&lt;String&gt; = []<br>&gt;             array.append(&quot;1&quot;)<br>&gt;<br>&gt;             ```<br>&gt;<br>&gt;             On Sat, Apr 30, 2016 at 7:52 AM, James Froggatt via swift-evolution<br>&gt;             &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;             I don&#39;t believe this has been addressed, please correct me if I&#39;m<br>&gt;                 wrong.<br>&gt;<br>&gt;                 --My Situation--<br>&gt;                 I&#39;ve recently been working on an observable collection type.<br>&gt;                 Because each stores ‘subscriptions’ to changes that occur, it<br>&gt;                 made sense to me that this should be a reference type, so<br>&gt;                 subscriptions can&#39;t be copied with the values themselves.<br>&gt;<br>&gt;                 I have made this class conform to<br>&gt;                 RangeReplaceableCollectionType, providing it with all the<br>&gt;                 standard collection functions. I do the following:<br>&gt;<br>&gt;                 let array: ObservedArray&lt;String&gt; = []<br>&gt;                 array.append(&quot;1&quot;) //Error: Cannot use mutating member on<br>&gt;                 immutable value: ‘array’ is a ‘let’ constant<br>&gt;<br>&gt;                 I have to make the reference immutable just to use my new<br>&gt;                 collection type? This is a bit of a deal-breaker.<br>&gt;<br>&gt;                 --The Problem--<br>&gt;                 Mutating methods allow ‘self’ to be reassigned, which is just<br>&gt;                 another way to mutate a value type. However, reassigning ‘self’<br>&gt;                 has a special meaning to reference types, which is presumably<br>&gt;                 the reason they are disallowed in classes.<br>&gt;<br>&gt;                 However, classes can conform to protocols with mutating methods,<br>&gt;                 leading to the compiler disallowing calls to mutating methods<br>&gt;                 for ‘let’ values of type ‘protocol&lt;MutatingProtocol,<br>&gt;                 AnyObject&gt;’, which can be an annoyance in generic code. In<br>&gt;                 addition, classes can inherit mutating methods from protocol<br>&gt;                 extensions, leading to the behaviour I describe above.<br>&gt;<br>&gt;                 Is this intentional behaviour? Am I going about this in the<br>&gt;                 wrong way? Or is this really an omission in the language?<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Oversight] Reference types allow mutating methods through generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 3, 2016, at 8:02 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dave and I have pondered this before, and considered that one possible (drastic) solution is to ban classes from implementing protocols with mutating members, on the grounds that it’s very hard to write an algorithm that’s correct for both.<br>&gt; <br>&gt; func removing(_ element: Element) -&gt; Self {<br>&gt;   var result = self // not necessarily a copy…<br>&gt;   result.remove(element)<br>&gt;   return result // not necessarily an independent value<br>&gt; }<br>&gt; <br>&gt; func zapBadElements&lt;C: RangeReplaceableCollection where C.Generator.Element == Int&gt;(_ nums: inout C) {<br>&gt;   // requires inout on ‘nums’  even when it’s a class<br>&gt;   for i in nums.indices {<br>&gt;     if nums[i] &lt; 0 {<br>&gt;       nums.removeAtIndex(i)<br>&gt;     }<br>&gt;   }<br>&gt;   // …because of this.<br>&gt;   if nums.lazy.filter { $0 == 0 }.count &gt; 5 {<br>&gt;     nums = C()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var refCollection: SharedArrayOfSomeKind&lt;Int&gt; = …<br>&gt; // either the variable ‘refCollection’ or the instance of ‘SharedArrayOfSomeKind’ might be mutated…or both!<br>&gt; zapBadElements(&amp;refCollection)<br>&gt; <br>&gt; There are of course ways to safely use a protocol with mutating requirements with classes, namely if you only use them for mutation (i.e. they’re only called from ‘mutating’ members or on ‘inout’ parameters) and never rely on value copying (no assignment, no returning). Most simple wrappers around mutating members would fall into this category.<br>&gt; <br>&gt; We didn’t really develop the idea very far yet because there’s been more pressing things to worry about. I’m bringing it up here because it’s an important idea that shouldn’t get lost.<br></p><p>Something similar to the &quot;classes can&#39;t conform to protocols with mutating requirements&quot; restriction would fall out if we had a compiler-enforced notion of pure functions. A &quot;pure&quot; mutating method would only be allowed to mutate its `self` value; since a class reference&#39;s referenced instance is not part of the reference value, it wouldn&#39;t be possible for a class method that mutates the referenced instance to satisfy a pure mutating requirement.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
