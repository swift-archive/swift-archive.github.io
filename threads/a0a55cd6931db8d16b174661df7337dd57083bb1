<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Chaining struct-mutating funcs</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August 10, 2016 at 12:00:00pm</p></header><div class="content"><p>on Tue Aug 09 2016, Fritz Anderson &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; I’m sending directly to those who took time over my question, because, per Michael’s request, I have a<br>&gt; minimal case to attach. Phrases in boldface are for skimmability, not shouting. <br>&gt;<br>&gt; Strip out my use case (I’m encouraged that Dave recapitulated exactly<br>&gt; what I was asking about). My remaining question is: How do you safely<br>&gt; reuse a class reference as the backing store for a struct?  Yes, it’s<br>&gt; done all the time, but the trick requirement is that I want to chain<br>&gt; the funcs that do it; chained value returns are immutable; and as far<br>&gt; as I could tell, you can’t get CoW-safe reuse without mutating<br>&gt; self. The result is that you are forced to make expensive copies of<br>&gt; the backing store every time. Joe’s solution looked promising in that<br>&gt; it purported to pass the CoW buffer (if possible) out of the func<br>&gt; after doing all the mutation internally.<br>&gt;<br>&gt; I couldn’t figure out how the answer Joe gave could work: His code<br>&gt; duplicates the struct’s original reference into a copy of the struct,<br>&gt; after which he expects the runtime to report (when possible) that no<br>&gt; such duplicate exists. I asked how this could be, as my attempt to<br>&gt; replicate in a playground showed the reference was never found unique<br>&gt; — which is what I had intuitively expected.<br></p><p>Well, a playground is a terrible way to check this, since lifetimes<br>don&#39;t necessarily obey the normal rules, but... you&#39;re right, it doesn&#39;t<br>seem to be workable today.<br></p><p>&gt;<br>&gt;<br>&gt; He says this fundamental design pattern in Swift works only if you<br>&gt; change the semantics of the language by turning on the<br>&gt; optimizer. <br></p><p>When you count performance characteristics as semantics, yes.<br></p><p>&gt; (Sorry to be all Asperger&#39;s about it, but nobody corrected me the<br>&gt; first time I put it this way.)<br></p><p>Actually I can&#39;t even get it to happen with the optimizer on in my<br>tests.<br></p><p>&gt; I have many, many questions, I might even hazard objections, but<br>&gt; they’re moot: Optimized or not, that code never reuses the backing<br>&gt; object.<br>&gt;<br>&gt; The attached project was built with Xcode 8.0b5. It uses Joe’s code<br>&gt; (except I still must use isUniquelyReferencedNonObjC(_:)). I run<br>&gt; addInts(x:, y:) and check two ways whether the reference was found<br>&gt; unique. Same result, optimized or not.<br>&gt;<br>&gt; It occurred to me that the globals s_x and s_y might bump the reference count. I removed them and used this<br>&gt; instead:<br>&gt;<br>&gt; let s_result = addInts(x: S(c: C(value: 99)), y: S(c: C(value: -98)))<br>&gt;<br>&gt; Still no unique references.<br>&gt;<br>&gt; I recognize I am taking up a lot of god time mere days before a major<br>&gt; release, when the likeliest outcome is that I’m a jackass. <br></p><p>I don&#39;t think so.  What&#39;s more likely is that we could be optimizing<br>better. <br></p><p>&gt; My concern runs deeper than what’s in this message, but I shouldn&#39;t<br>&gt; muddy the waters.  Those deeper things can go back to the public once<br>&gt; I understand the issue better (or you boot me back).<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Context (supplementary, no need to spend time)<br>&gt;<br>&gt; If seeing what I’m trying to do helps, I’ve attached my attempt. I’m<br>&gt; sure there are defects in API style, safety, and correctness. I’d have<br>&gt; done more if I hadn’t suspended the project over this issue. Class<br>&gt; FloatBuffer is the backing store; ManagedFloatBuffer is the wrapper<br>&gt; class that does all the operations. None of the operations are<br>&gt; declared mutating.<br>&gt;<br>&gt; Anything that calls (unary|binary)Operator returns a fresh<br>&gt; ManagedFloatBuffer every time; structs and their buffers are created<br>&gt; and initialized every time — intentionally. It seems to work well<br>&gt; under gentle use.<br>&gt;<br>&gt; Callers of mutabilityWrapper preserve the receiver’s backing buffer<br>&gt; whenever possible and mutate it in-place.  Those funcs always return<br>&gt; self. These might be a big win; I can’t tell because I’ve never been<br>&gt; able to get unique references. Because there’s an allocation (possibly<br>&gt; initialization) every time, they are no better than the<br>&gt; (unary|binary)Operator funcs. malloc and friends take up a significant<br>&gt; amount of time on the scale of vector math.<br>&gt;<br>&gt; Both flavors can cascade; the only problem is that the “in-place”<br>&gt; methods don’t live up to the name.<br></p><p>The question of how to optimize the evaluation of non-mutating<br>expressions using in-place operations is an old one.  Once upon a time<br>we were pursuing language features for that purpose<br>(https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst)<br>but that particular approach is... an ex-approach ;-).<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
