<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>One of the stated focus areas for Swift 3 is to complete the generics system.  <br></p><p>How far along is the design for the “complete” generics system?  Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br></p><p>Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br></p><p>Thanks,<br>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b4263b6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>+1 to this. I would really like to see what is and isn&#39;t in scope for Swift<br>3&#39;s generics system. Among other things, it would help focus the<br>community&#39;s proposals and ideas for the evolution of the type system. An<br>example, people have expressed interest in HKTs, and perhaps a discussion<br>can be opened on how Swift 3&#39;s type system can lay the foundation for<br>further changes.<br></p><p>Austin<br></p><p>On Thu, Dec 10, 2015 at 3:45 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One of the stated focus areas for Swift 3 is to complete the generics<br>&gt; system.<br>&gt;<br>&gt; How far along is the design for the “complete” generics system?  Is there<br>&gt; appetite among the core team to involve the community in evaluating planned<br>&gt; features or submitting proposals to complement existing plans?<br>&gt;<br>&gt; Also, is there any documentation other than<br>&gt; https://github.com/apple/swift/blob/master/docs/Generics.rst describing<br>&gt; in detail what the complete vision for the generics system is and what new<br>&gt; features will be added in Swift 3 (as well as any generics features that<br>&gt; have been decided against for Swift or version 3 specifically)?<br>&gt;<br>&gt; Thanks,<br>&gt; Matthew<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/935e637b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 4:14 PM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 to this. I would really like to see what is and isn&#39;t in scope for<br>&gt; Swift 3&#39;s generics system. Among other things, it would help focus the<br>&gt; community&#39;s proposals and ideas for the evolution of the type system. An<br>&gt; example, people have expressed interest in HKTs, and perhaps a discussion<br>&gt; can be opened on how Swift 3&#39;s type system can lay the foundation for<br>&gt; further changes.<br>&gt;<br></p><p>As far as I understand, the first priority is not fixing issues in the<br>current type checker and runtime for existing generics features (e.g.,<br>implement recursive generic constraints to eliminate protocol Indexable<br>from the standard library), and incremental improvements for the current<br>generics system that allow the standard library to properly express and<br>constrain existing concepts -- like &#39;where&#39; constraints on associated types.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/4bb7a777/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 4:14 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to this. I would really like to see what is and isn&#39;t in scope for Swift 3&#39;s generics system. Among other things, it would help focus the community&#39;s proposals and ideas for the evolution of the type system. An example, people have expressed interest in HKTs, and perhaps a discussion can be opened on how Swift 3&#39;s type system can lay the foundation for further changes.<br>&gt; <br></p><p>Off the top of my head, the following are not currently supported and are requirements for any kind of ‘complete’ generics system:<br></p><p>- Generic types nested inside generic functions<br>- Generic types nested inside generic types<br>- Generic functions nested inside generic functions which capture values or outer generic types<br></p><p>All of these would be easier once we rip out PolymorphicFunctionType and GenericParamList in favor of consistently using GenericFunctionType and GenericSignature everywhere. This is what Sema’s “getType()” vs “getInterfaceType()” business on ValueDecls is all about. Once the old “contextual” types are gone, some tricky parallel code paths for building up the two representations of generic function signatures will be much simpler and more robust, and the missing functionality added easier. This is blocked on a number of architectural changes, for example SIL type lowering has to be able to associate a GenericTypeParamType with the GenericSignature that contains it, and right now it can’t really do that except for one distinguished GenericSignature, which forces us to use non-interface types when forming calls and such.<br></p><p>A large number of compiler_crashers are instances of the above three unsupported constructs which trip Sema bugs — even though we have diagnostics that catch most of these, the fact that the type checker doesn’t just stop after diagnosing once means that internal inconsistencies resulting an incomplete implementation of generics can trigger assertions down the road.<br></p><p>Slava<br></p><p>&gt; Austin<br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt; <br>&gt; How far along is the design for the “complete” generics system?  Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt; <br>&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/2c67a81d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt; <br>&gt; How far along is the design for the “complete” generics system?  <br></p><p>There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br></p><p>&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br></p><p>Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br></p><p>&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br></p><p>No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br></p><p>So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d854e8bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>Dmitri, Slava and Doug thank you for taking the time to respond.  I apologize for not thanking you sooner.  <br></p><p>Since the core team has a loosely shared understanding of the goals but hasn&#39;t had time to write it down yet I thought it might be helpful if I put together a summary of the features that seem to me like obvious candidates for completing the current generic system.  If I have missed anything significant please point that out. <br></p><p>I&#39;m placing a &quot;**&quot; next to items that I beleive I have seen mentioned by the core team as desired features.  This is based on memory and may be innacurate or may be based on desires expressed, but not necessarily pinned to the Swift 3 timeline.  <br></p><p>I&#39;m hoping the core team might be able to indicate which items are likely to be part of the work you&#39;re doing on Swift 3, which items you might be interested in the community contributing to, and which items are unliekly to be considered during the Swift 3 timeframe even with community involvement.  This could help interested contributors start thinking about what they might be interested in working on while we wait for a more complete document describing the vision.<br></p><p>- ** generic typealias<br></p><p>- allow protocols to specify a non-covarying Self in static method declarations (a possible solution to the problem of conforming non-final classes in Cocoa to protocols containing factory methods)<br></p><p>- extensions<br>	- ** allow same type constraints<br>	- ** allow protocol conformance in constrained extensions<br>	- allow protocol conformance in protocol extensions<br></p><p>- associated type constraints<br>	- use of Self as a superclass constraint<br>	- ** where clause constraining inidividual associated types<br>	- ** where clause relating multiple assocated types<br></p><p>- existentials for protocols with associated types<br>	- protocol existentials don&#39;t conform to the protocol itself<br>	- ** fully bound: protocol&lt;GeneratorType where Element == Int&gt; <br>	- ** fully constrained: protocol&lt;GeneratorType where Element: CustomStringConvertible&gt;<br>	- partially bound / constrained - allow access to members only mentioning constrained associated types<br>	- ** unbound - allow access to members not mentioning Self or associated types<br>	- composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated == Int, P1.Other == P2.Other&gt;<br></p><p>- nesting (per Slava&#39;s email)<br>	- ** Generic types nested inside generic functions<br>	- ** Generic types nested inside generic types<br>	- ** Generic functions nested inside generic functions which capture values or outer generic types<br></p><p>Some things that I expect are out of scope for Swift 3 but am mentioning for completeness / confirmation of that:<br></p><p>- variadic generics<br>- higher kinded types<br>- higher rank types<br></p><p>Thanks,<br>Matthew<br></p><p><br></p><p>&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt; <br>&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt; <br>&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt; <br>&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt; <br>&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt; <br>&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt; <br>&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt; <br>&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/0dca7877/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>Thank you for putting together this list.  I will be answering from the<br>standard library perspective.<br></p><p>On Tue, Dec 15, 2015 at 7:25 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; - ** generic typealias<br>&gt;<br></p><p>I don&#39;t know of a usecase in the standard library.<br></p><p>- allow protocols to specify a non-covarying Self in static method<br>&gt; declarations (a possible solution to the problem of conforming non-final<br>&gt; classes in Cocoa to protocols containing factory methods)<br>&gt;<br></p><p>I don&#39;t know of a usecase in the standard library.<br></p><p><br>&gt; - extensions<br>&gt; - ** allow same type constraints<br>&gt; - ** allow protocol conformance in constrained extensions<br>&gt; - allow protocol conformance in protocol extensions<br>&gt;<br></p><p>Yes, the standard library needs all of these.<br></p><p><br>&gt; - associated type constraints<br>&gt; - use of Self as a superclass constraint<br>&gt; - ** where clause constraining inidividual associated types<br>&gt; - ** where clause relating multiple assocated types<br>&gt;<br></p><p>The standard library needs the &#39;where&#39; clauses, but not the &#39;Self&#39;<br>superclass constraint.<br></p><p><br>&gt; - existentials for protocols with associated types<br>&gt; - protocol existentials don&#39;t conform to the protocol itself<br>&gt; - ** fully bound: protocol&lt;GeneratorType where Element == Int&gt;<br>&gt; - ** fully constrained: protocol&lt;GeneratorType where Element:<br>&gt; CustomStringConvertible&gt;<br>&gt; - partially bound / constrained - allow access to members only mentioning<br>&gt; constrained associated types<br>&gt; - ** unbound - allow access to members not mentioning Self or associated<br>&gt; types<br>&gt; - composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated ==<br>&gt; Int, P1.Other == P2.Other&gt;<br>&gt;<br></p><p>Depending on the details, this might replace AnySequence / AnyCollection.<br></p><p><br>&gt; - nesting (per Slava&#39;s email)<br>&gt; - ** Generic types nested inside generic functions<br>&gt; - ** Generic types nested inside generic types<br>&gt; - ** Generic functions nested inside generic functions which capture<br>&gt; values or outer generic types<br>&gt;<br></p><p>The standard library needs generic types nested inside generic types to<br>move types from the top level, like moving DictionaryIndex into Dictionary.<br></p><p>Another thing that we need is recursive associated type constraints:<br></p><p>protocol CollectionType {<br>  typealias SubSequence : CollectionType<br>}<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/f7e6af44/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 15, 2015, at 7:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Dmitri, Slava and Doug thank you for taking the time to respond.  I apologize for not thanking you sooner.  <br>&gt; <br>&gt; Since the core team has a loosely shared understanding of the goals but hasn&#39;t had time to write it down yet I thought it might be helpful if I put together a summary of the features that seem to me like obvious candidates for completing the current generic system.  If I have missed anything significant please point that out. <br></p><p>This is helpful, thank you!<br></p><p>Lots of comments below. An overarching theme here is that I&#39;m trying to scope down the list to what we need to achieve ABI stability and an expressive library  fewer features means we&#39;re more likely to succeed with better quality. <br></p><p>&gt; I&#39;m placing a &quot;**&quot; next to items that I beleive I have seen mentioned by the core team as desired features.  This is based on memory and may be innacurate or may be based on desires expressed, but not necessarily pinned to the Swift 3 timeline.  <br>&gt; <br>&gt; I&#39;m hoping the core team might be able to indicate which items are likely to be part of the work you&#39;re doing on Swift 3, which items you might be interested in the community contributing to, and which items are unliekly to be considered during the Swift 3 timeframe even with community involvement.  This could help interested contributors start thinking about what they might be interested in working on while we wait for a more complete document describing the vision.<br>&gt; <br>&gt; - ** generic typealias<br></p><p>This isn&#39;t high on my list. It&#39;s a good feature, and I want it someday, but introducing generic typealiases won&#39;t have any impact on the ABI and therefore can wait IMO. <br></p><p>&gt; <br>&gt; - allow protocols to specify a non-covarying Self in static method declarations (a possible solution to the problem of conforming non-final classes in Cocoa to protocols containing factory methods)<br></p><p>Maybe. This isn&#39;t terribly high on my list, but in also behind on the discussion. <br>&gt; <br>&gt; - extensions<br>&gt; 	- ** allow same type constraints<br></p><p>I&#39;m assuming you mean an extension like <br></p><p>  extension Array where Element == String  {}<br></p><p>Yes, it&#39;s something we want to support <br></p><p>&gt; 	- ** allow protocol conformance in constrained extensions<br></p><p>This is something like:<br></p><p>  extension Array : Equatable where Element : Equatable {}<br></p><p>It is very very high priority for Swift 3.<br></p><p>&gt; 	- allow protocol conformance in protocol extensions<br></p><p>This is something like:<br></p><p>  extension CollectionType : Equatable where Generator.Element : Equatable {}<br></p><p>This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br></p><p>&gt; <br>&gt; - associated type constraints<br>&gt; 	- use of Self as a superclass constraint<br></p><p>This wasn&#39;t on my list at all. Care to elaborate on why this is important?<br></p><p>&gt; 	- ** where clause constraining inidividual associated types<br>&gt; 	- ** where clause relating multiple assocated types<br></p><p>Yes to both. We need the to properly express some relationships in the standard library types, such as a SubSequence&#39;s Element type matching the Element type of the  sequence itself. <br></p><p>&gt; <br>&gt; - existentials for protocols with associated types<br>&gt; 	- protocol existentials don&#39;t conform to the protocol itself<br>&gt; 	- ** fully bound: protocol&lt;GeneratorType where Element == Int&gt; <br>&gt; 	- ** fully constrained: protocol&lt;GeneratorType where Element: CustomStringConvertible&gt;<br>&gt; 	- partially bound / constrained - allow access to members only mentioning constrained associated types<br>&gt; 	- ** unbound - allow access to members not mentioning Self or associated types<br>&gt; 	- composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated == Int, P1.Other == P2.Other&gt;<br></p><p>This one is tough. It is a very, very common user request and existentials are painfully under implemented in Swift. On the other hand, it&#39;s an additive feature that isn&#39;t likely (IMO!) to be important for ABI stabilization in the language or library. So, I would put it out of scope for Swift 3. <br></p><p>&gt; - nesting (per Slava&#39;s email)<br>&gt; 	- ** Generic types nested inside generic functions<br>&gt; 	- ** Generic types nested inside generic types<br>&gt; 	- ** Generic functions nested inside generic functions which capture values or outer generic types<br></p><p>I think Slava and I disagree on this one ;)<br></p><p>I don&#39;t consider this critical for Swift 3. The compiler will greatly improve simply by making this work (because the dumb assumptions that block this feature likely trigger additional bugs), but we don&#39;t need to allow it for ABI stability. There are a handful of places in the standard library where we&#39;ve had to promote a type that would normally be nested to the top level to work around this, but we could live with that as a smallish ABI wart in the long term and introduce generic typealiases to clean up the syntax once those features become available. <br></p><p>&gt; Some things that I expect are out of scope for Swift 3 but am mentioning for completeness / confirmation of that:<br>&gt; <br>&gt; - variadic generics<br>&gt; - higher kinded types<br>&gt; - higher rank types<br></p><p>Agreed that all are out of scope for Swift 3. The first is a feature of particular interest to me... But absolutely is out of scope. I also want to eventually use variadic generics to extend arbitrary length tuples of Equatable types to make them Equatable, for example ;)<br></p><p>A couple features you didn&#39;t mention that I consider in scope for Swift 3 generics:<br></p><p>- generic subscripts (the standard library might need these), e.g.,<br></p><p>  subscript&lt;C : SequenceType where C.Generator.Element == Index&gt; (indices: C) -&gt; [Index]<br></p><p>- recursive protocol constraints, where an associated type can be stated to conform to its enclosing protocol (directly or indirectly), eg,<br></p><p>  protocol SequenceType {<br>    typealias SubSequence : SequenceType<br>  }<br></p><p>- operators defined in types (only indirectly related to generics):<br></p><p>  extension Array where Element : Equatable {<br>    func ==(lhs: Array, rhs: Array) -&gt; Bool { ... }<br>  }<br></p><p>- &quot;real&quot; default implementations in protocols. It looks like a syntactic simplification from<br>Putting the definition in an extension, but putting the default implementation in the protocol itself has an important effect on resilience: one should be able to add requirements to a protocol without breaking ABI so long as those requirements have a default implementation. <br></p><p>Several of these (recursive constraints, where clauses placing requirements on associated types in protocols, etc) are partly aimed at eliminated many of the underscored protocols in the standard library, because we don&#39;t want them to be part of the library ABI. <br></p><p>I suspect I&#39;ll remember other small things, but that&#39;s the &quot;big&quot; list... and it&#39;s size perhaps illustrates why we need to choose carefully to maintain focus. <br></p><p>  - Doug<br></p><p><br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt;&gt; <br>&gt;&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt;&gt; <br>&gt;&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt;&gt; <br>&gt;&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt;&gt; <br>&gt;&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt;&gt; <br>&gt;&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt;&gt; <br>&gt;&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md)<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/4334410f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 8:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This one is tough. It is a very, very common user request and existentials are painfully under implemented in Swift. On the other hand, it&#39;s an additive feature that isn&#39;t likely (IMO!) to be important for ABI stabilization in the language or library. So, I would put it out of scope for Swift 3. <br></p><p>It could be important to stabilizing the standard library, since existentials ought to replace the ad-hoc type-erased AnySequence etc. wrappers that are currently hand-written in the standard library.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/78749fe3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 17, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 9:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This is something like:<br>&gt; <br>&gt;   extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt; <br>&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br></p><p>I’m not sure about the runtime cost of non-“existential&quot; protocols like Equatable, which can’t be casted to at runtime today. Of course, this makes that there are multiple ‘kinds’ of protocols with different usage that are declared in the same way more complex than it is today.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 12:37 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 9:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is something like:<br>&gt;&gt; <br>&gt;&gt;  extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt;&gt; <br>&gt;&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt; <br>&gt; I’m not sure about the runtime cost of non-“existential&quot; protocols like Equatable, which can’t be casted to at runtime today. Of course, this makes that there are multiple ‘kinds’ of protocols with different usage that are declared in the same way more complex than it is today.<br></p><p><br>The non-“existential” protocol issue is actually separate. We can illustrate the issues with far simpler protocols:<br></p><p>	protocol P { }<br>	protocol Q : P { }<br>	protocol R { }<br>	protocol S { }<br></p><p>	extension P : R { } // #1: every P is also an R<br>	extension R : S { } // #2: every R is also an S<br></p><p>if I then ask the question “is some Any value an S?&quot;:<br></p><p>	func f(x: Any) {<br>		if let xs = x as? S { … }<br>	}<br></p><p>what does it take to make that code produce the right answer for, e.g.,<br></p><p>	struct MyStruct : Q { }<br>	f(MyStruct())<br></p><p>?<br></p><p>Well, at runtime, you start by asking “is MyStruct an S?” It is not directly an S, but...<br>	- we know from #2 that every R is an S. “Is MyStruct an R?” It is not directly an R, but…<br>	- we know from #1 that every P is an R. “Is MyStruct a P?” Ah hah! It is a P because MyStruct declares conformance to Q, and every Q is a P.<br></p><p>So now we need to pull together a “MyStruct as an S” representation—at runtime—and cache it so we don’t have to go through all of that work the next time one asks that question. It’s absolutely implementable, but having to do that potentially-slow search at runtime is a major concern, particularly because adding a new extension that makes one protocol conform to another at any point in the system can cause widespread performance effects.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:54 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 12:37 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 9:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt;&gt; <br>&gt;&gt; I’m not sure about the runtime cost of non-“existential&quot; protocols like Equatable, which can’t be casted to at runtime today. Of course, this makes that there are multiple ‘kinds’ of protocols with different usage that are declared in the same way more complex than it is today.<br>&gt; <br>&gt; <br>&gt; The non-“existential” protocol issue is actually separate. We can illustrate the issues with far simpler protocols:<br>&gt; <br>&gt; 	protocol P { }<br>&gt; 	protocol Q : P { }<br>&gt; 	protocol R { }<br>&gt; 	protocol S { }<br>&gt; <br>&gt; 	extension P : R { } // #1: every P is also an R<br>&gt; 	extension R : S { } // #2: every R is also an S<br>&gt; <br>&gt; if I then ask the question “is some Any value an S?&quot;:<br>&gt; <br>&gt; 	func f(x: Any) {<br>&gt; 		if let xs = x as? S { … }<br>&gt; 	}<br>&gt; <br>&gt; what does it take to make that code produce the right answer for, e.g.,<br>&gt; <br>&gt; 	struct MyStruct : Q { }<br>&gt; 	f(MyStruct())<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; Well, at runtime, you start by asking “is MyStruct an S?” It is not directly an S, but...<br>&gt; 	- we know from #2 that every R is an S. “Is MyStruct an R?” It is not directly an R, but…<br>&gt; 	- we know from #1 that every P is an R. “Is MyStruct a P?” Ah hah! It is a P because MyStruct declares conformance to Q, and every Q is a P.<br>&gt; <br>&gt; So now we need to pull together a “MyStruct as an S” representation—at runtime—and cache it so we don’t have to go through all of that work the next time one asks that question. It’s absolutely implementable, but having to do that potentially-slow search at runtime is a major concern, particularly because adding a new extension that makes one protocol conform to another at any point in the system can cause widespread performance effects.<br></p><p>Couldn’t this work theoretically be done as part of whole program optimization at some point in the future?  Would that add too much potentially unnecessary metadata to the binary?  Is there some other reason that wouldn’t be possible?<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/92177104/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 11:54 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 12:37 AM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 9:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is something like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure about the runtime cost of non-“existential&quot; protocols like Equatable, which can’t be casted to at runtime today. Of course, this makes that there are multiple ‘kinds’ of protocols with different usage that are declared in the same way more complex than it is today.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The non-“existential” protocol issue is actually separate. We can illustrate the issues with far simpler protocols:<br>&gt;&gt; <br>&gt;&gt; 	protocol P { }<br>&gt;&gt; 	protocol Q : P { }<br>&gt;&gt; 	protocol R { }<br>&gt;&gt; 	protocol S { }<br>&gt;&gt; <br>&gt;&gt; 	extension P : R { } // #1: every P is also an R<br>&gt;&gt; 	extension R : S { } // #2: every R is also an S<br>&gt;&gt; <br>&gt;&gt; if I then ask the question “is some Any value an S?&quot;:<br>&gt;&gt; <br>&gt;&gt; 	func f(x: Any) {<br>&gt;&gt; 		if let xs = x as? S { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; what does it take to make that code produce the right answer for, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	struct MyStruct : Q { }<br>&gt;&gt; 	f(MyStruct())<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; Well, at runtime, you start by asking “is MyStruct an S?” It is not directly an S, but...<br>&gt;&gt; 	- we know from #2 that every R is an S. “Is MyStruct an R?” It is not directly an R, but…<br>&gt;&gt; 	- we know from #1 that every P is an R. “Is MyStruct a P?” Ah hah! It is a P because MyStruct declares conformance to Q, and every Q is a P.<br>&gt;&gt; <br>&gt;&gt; So now we need to pull together a “MyStruct as an S” representation—at runtime—and cache it so we don’t have to go through all of that work the next time one asks that question. It’s absolutely implementable, but having to do that potentially-slow search at runtime is a major concern, particularly because adding a new extension that makes one protocol conform to another at any point in the system can cause widespread performance effects.<br>&gt; <br>&gt; Couldn’t this work theoretically be done as part of whole program optimization at some point in the future?  Would that add too much potentially unnecessary metadata to the binary?  Is there some other reason that wouldn’t be possible?<br></p><p>Yes, we could certainly improve this with whole-program optimization, but the potential performance cliff from adding some simple “every Foo is a Bar” declaration anywhere in the program is terrifying.<br></p><p>Do recall that I’m saying “not now” rather than “not ever” for this feature. I think it’s very, very cool, but it’s complicated and we need a while to understand its overall effects.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/f8c5eb76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Do recall that I’m saying “not now” rather than “not ever” for this feature. I think it’s very, very cool, but it’s complicated and we need a while to understand its overall effects.<br></p><p>Sure, that makes sense!<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 10:45 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew,<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 15, 2015, at 7:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Dmitri, Slava and Doug thank you for taking the time to respond.  I apologize for not thanking you sooner.  <br>&gt;&gt; <br>&gt;&gt; Since the core team has a loosely shared understanding of the goals but hasn&#39;t had time to write it down yet I thought it might be helpful if I put together a summary of the features that seem to me like obvious candidates for completing the current generic system.  If I have missed anything significant please point that out. <br>&gt; <br>&gt; This is helpful, thank you!<br></p><p>You’re welcome!  I appreciate the responses as well.  Thank you!<br></p><p>&gt; <br>&gt; Lots of comments below. An overarching theme here is that I&#39;m trying to scope down the list to what we need to achieve ABI stability and an expressive library  fewer features means we&#39;re more likely to succeed with better quality. <br>&gt; <br>&gt;&gt; I&#39;m placing a &quot;**&quot; next to items that I beleive I have seen mentioned by the core team as desired features.  This is based on memory and may be innacurate or may be based on desires expressed, but not necessarily pinned to the Swift 3 timeline.  <br>&gt;&gt; <br>&gt;&gt; I&#39;m hoping the core team might be able to indicate which items are likely to be part of the work you&#39;re doing on Swift 3, which items you might be interested in the community contributing to, and which items are unliekly to be considered during the Swift 3 timeframe even with community involvement.  This could help interested contributors start thinking about what they might be interested in working on while we wait for a more complete document describing the vision.<br>&gt;&gt; <br>&gt;&gt; - ** generic typealias<br>&gt; <br>&gt; This isn&#39;t high on my list. It&#39;s a good feature, and I want it someday, but introducing generic typealiases won&#39;t have any impact on the ABI and therefore can wait IMO. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - allow protocols to specify a non-covarying Self in static method declarations (a possible solution to the problem of conforming non-final classes in Cocoa to protocols containing factory methods)<br>&gt; <br>&gt; Maybe. This isn&#39;t terribly high on my list, but in also behind on the discussion. <br></p><p>This is related to the thread Joe started on “Making protocol conformance inheritance controllable”.  It would solve some (probably not all) of the use cases that prompted that idea.  Of course it solves the ones I have run into which is part of the reason I included it here.  Any solution to this problem would be extremely useful - it doesn’t need to be this specific solution.<br></p><p>&gt;&gt; <br>&gt;&gt; - extensions<br>&gt;&gt; 	- ** allow same type constraints<br>&gt; <br>&gt; I&#39;m assuming you mean an extension like <br>&gt; <br>&gt;   extension Array where Element == String  {}<br>&gt; <br>&gt; Yes, it&#39;s something we want to support <br></p><p>Yep, that’s what I meant.<br></p><p>&gt; <br>&gt;&gt; 	- ** allow protocol conformance in constrained extensions<br>&gt; <br>&gt; This is something like:<br>&gt; <br>&gt;   extension Array : Equatable where Element : Equatable {}<br>&gt; <br>&gt; It is very very high priority for Swift 3.<br>&gt; <br>&gt;&gt; 	- allow protocol conformance in protocol extensions<br>&gt; <br>&gt; This is something like:<br>&gt; <br>&gt;   extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt; <br>&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - associated type constraints<br>&gt;&gt; 	- use of Self as a superclass constraint<br>&gt; <br>&gt; This wasn&#39;t on my list at all. Care to elaborate on why this is important?<br></p><p>I included this one primarily because I know it isn’t possible but other superclass constraints are.  Removing this limitation seems like a natural part of “completing” the current generics system.  But I don’t have concrete uses for it and if implementation is complex I wouldn’t consider it a priority.<br></p><p>&gt; <br>&gt;&gt; 	- ** where clause constraining inidividual associated types<br>&gt;&gt; 	- ** where clause relating multiple assocated types<br>&gt; <br>&gt; Yes to both. We need the to properly express some relationships in the standard library types, such as a SubSequence&#39;s Element type matching the Element type of the  sequence itself. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - existentials for protocols with associated types<br>&gt;&gt; 	- protocol existentials don&#39;t conform to the protocol itself<br>&gt;&gt; 	- ** fully bound: protocol&lt;GeneratorType where Element == Int&gt; <br>&gt;&gt; 	- ** fully constrained: protocol&lt;GeneratorType where Element: CustomStringConvertible&gt;<br>&gt;&gt; 	- partially bound / constrained - allow access to members only mentioning constrained associated types<br>&gt;&gt; 	- ** unbound - allow access to members not mentioning Self or associated types<br>&gt;&gt; 	- composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated == Int, P1.Other == P2.Other&gt;<br>&gt; <br>&gt; This one is tough. It is a very, very common user request and existentials are painfully under implemented in Swift. On the other hand, it&#39;s an additive feature that isn&#39;t likely (IMO!) to be important for ABI stabilization in the language or library. So, I would put it out of scope for Swift 3. <br></p><p>I’m going to hope Joe’s comments about stabilizing the standard library win out.  Ad-hoc type erasure is painful enough that it influences design decisions.  It would be great to see existentials see at least enough improvement to cover the standard library cases.  <br></p><p>If this is an area that could be impacted by community involvement please let us know!  I think you would find people willing to help out.  As you noted, it’s one of the bigger gripes people seem to have about Swift.<br></p><p>&gt; <br>&gt;&gt; - nesting (per Slava&#39;s email)<br>&gt;&gt; 	- ** Generic types nested inside generic functions<br>&gt;&gt; 	- ** Generic types nested inside generic types<br>&gt;&gt; 	- ** Generic functions nested inside generic functions which capture values or outer generic types<br>&gt; <br>&gt; I think Slava and I disagree on this one ;)<br>&gt; <br>&gt; I don&#39;t consider this critical for Swift 3. The compiler will greatly improve simply by making this work (because the dumb assumptions that block this feature likely trigger additional bugs), but we don&#39;t need to allow it for ABI stability. There are a handful of places in the standard library where we&#39;ve had to promote a type that would normally be nested to the top level to work around this, but we could live with that as a smallish ABI wart in the long term and introduce generic typealiases to clean up the syntax once those features become available. <br>&gt; <br>&gt;&gt; Some things that I expect are out of scope for Swift 3 but am mentioning for completeness / confirmation of that:<br>&gt;&gt; <br>&gt;&gt; - variadic generics<br>&gt;&gt; - higher kinded types<br>&gt;&gt; - higher rank types<br>&gt; <br>&gt; Agreed that all are out of scope for Swift 3. The first is a feature of particular interest to me... But absolutely is out of scope. I also want to eventually use variadic generics to extend arbitrary length tuples of Equatable types to make them Equatable, for example ;)<br>&gt; <br>&gt; A couple features you didn&#39;t mention that I consider in scope for Swift 3 generics:<br>&gt; <br>&gt; - generic subscripts (the standard library might need these), e.g.,<br>&gt; <br>&gt;   subscript&lt;C : SequenceType where C.Generator.Element == Index&gt; (indices: C) -&gt; [Index]<br></p><p>Thanks for mentioning this.  I really want to see this one.  I have use cases for it.  Not sure how I forgot to include it in my list.<br></p><p>&gt; <br>&gt; - recursive protocol constraints, where an associated type can be stated to conform to its enclosing protocol (directly or indirectly), eg,<br>&gt; <br>&gt;   protocol SequenceType {<br>&gt;     typealias SubSequence : SequenceType<br>&gt;   }<br>&gt; <br>&gt; - operators defined in types (only indirectly related to generics):<br>&gt; <br>&gt;   extension Array where Element : Equatable {<br>&gt;     func ==(lhs: Array, rhs: Array) -&gt; Bool { ... }<br>&gt;   }<br>&gt; <br>&gt; - &quot;real&quot; default implementations in protocols. It looks like a syntactic simplification from<br>&gt; Putting the definition in an extension, but putting the default implementation in the protocol itself has an important effect on resilience: one should be able to add requirements to a protocol without breaking ABI so long as those requirements have a default implementation. <br></p><p>I appreciate your adding additional items in addition to commenting on my list!  Thank you!<br></p><p>&gt; <br>&gt; Several of these (recursive constraints, where clauses placing requirements on associated types in protocols, etc) are partly aimed at eliminated many of the underscored protocols in the standard library, because we don&#39;t want them to be part of the library ABI. <br>&gt; <br>&gt; I suspect I&#39;ll remember other small things, but that&#39;s the &quot;big&quot; list... and it&#39;s size perhaps illustrates why we need to choose carefully to maintain focus. <br>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/e390a951/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>I’ve been going through some notes and realized I missed a couple of things when I put my list together:<br></p><p>* access control for extensions declaring protocol conformances <br>* memberwise deriving of protocol implementations<br></p><p>I also found an example of the “same type constraints” item I mentioned and it is different than discussed so far:<br></p><p>struct S&lt;T, U&gt; {}<br>extension S where T == U {} // error<br></p><p>Are you considering any of these for Swift 3?  <br></p><p>Access control for extensions declaring protocol conformances seems is the highest priority out of this group IMO.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 15, 2015, at 10:45 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew,<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 15, 2015, at 7:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Dmitri, Slava and Doug thank you for taking the time to respond.  I apologize for not thanking you sooner.  <br>&gt;&gt; <br>&gt;&gt; Since the core team has a loosely shared understanding of the goals but hasn&#39;t had time to write it down yet I thought it might be helpful if I put together a summary of the features that seem to me like obvious candidates for completing the current generic system.  If I have missed anything significant please point that out. <br>&gt; <br>&gt; This is helpful, thank you!<br>&gt; <br>&gt; Lots of comments below. An overarching theme here is that I&#39;m trying to scope down the list to what we need to achieve ABI stability and an expressive library  fewer features means we&#39;re more likely to succeed with better quality. <br>&gt; <br>&gt;&gt; I&#39;m placing a &quot;**&quot; next to items that I beleive I have seen mentioned by the core team as desired features.  This is based on memory and may be innacurate or may be based on desires expressed, but not necessarily pinned to the Swift 3 timeline.  <br>&gt;&gt; <br>&gt;&gt; I&#39;m hoping the core team might be able to indicate which items are likely to be part of the work you&#39;re doing on Swift 3, which items you might be interested in the community contributing to, and which items are unliekly to be considered during the Swift 3 timeframe even with community involvement.  This could help interested contributors start thinking about what they might be interested in working on while we wait for a more complete document describing the vision.<br>&gt;&gt; <br>&gt;&gt; - ** generic typealias<br>&gt; <br>&gt; This isn&#39;t high on my list. It&#39;s a good feature, and I want it someday, but introducing generic typealiases won&#39;t have any impact on the ABI and therefore can wait IMO. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - allow protocols to specify a non-covarying Self in static method declarations (a possible solution to the problem of conforming non-final classes in Cocoa to protocols containing factory methods)<br>&gt; <br>&gt; Maybe. This isn&#39;t terribly high on my list, but in also behind on the discussion. <br>&gt;&gt; <br>&gt;&gt; - extensions<br>&gt;&gt; 	- ** allow same type constraints<br>&gt; <br>&gt; I&#39;m assuming you mean an extension like <br>&gt; <br>&gt;   extension Array where Element == String  {}<br>&gt; <br>&gt; Yes, it&#39;s something we want to support <br>&gt; <br>&gt;&gt; 	- ** allow protocol conformance in constrained extensions<br>&gt; <br>&gt; This is something like:<br>&gt; <br>&gt;   extension Array : Equatable where Element : Equatable {}<br>&gt; <br>&gt; It is very very high priority for Swift 3.<br>&gt; <br>&gt;&gt; 	- allow protocol conformance in protocol extensions<br>&gt; <br>&gt; This is something like:<br>&gt; <br>&gt;   extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt; <br>&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - associated type constraints<br>&gt;&gt; 	- use of Self as a superclass constraint<br>&gt; <br>&gt; This wasn&#39;t on my list at all. Care to elaborate on why this is important?<br>&gt; <br>&gt;&gt; 	- ** where clause constraining inidividual associated types<br>&gt;&gt; 	- ** where clause relating multiple assocated types<br>&gt; <br>&gt; Yes to both. We need the to properly express some relationships in the standard library types, such as a SubSequence&#39;s Element type matching the Element type of the  sequence itself. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - existentials for protocols with associated types<br>&gt;&gt; 	- protocol existentials don&#39;t conform to the protocol itself<br>&gt;&gt; 	- ** fully bound: protocol&lt;GeneratorType where Element == Int&gt; <br>&gt;&gt; 	- ** fully constrained: protocol&lt;GeneratorType where Element: CustomStringConvertible&gt;<br>&gt;&gt; 	- partially bound / constrained - allow access to members only mentioning constrained associated types<br>&gt;&gt; 	- ** unbound - allow access to members not mentioning Self or associated types<br>&gt;&gt; 	- composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated == Int, P1.Other == P2.Other&gt;<br>&gt; <br>&gt; This one is tough. It is a very, very common user request and existentials are painfully under implemented in Swift. On the other hand, it&#39;s an additive feature that isn&#39;t likely (IMO!) to be important for ABI stabilization in the language or library. So, I would put it out of scope for Swift 3. <br>&gt; <br>&gt;&gt; - nesting (per Slava&#39;s email)<br>&gt;&gt; 	- ** Generic types nested inside generic functions<br>&gt;&gt; 	- ** Generic types nested inside generic types<br>&gt;&gt; 	- ** Generic functions nested inside generic functions which capture values or outer generic types<br>&gt; <br>&gt; I think Slava and I disagree on this one ;)<br>&gt; <br>&gt; I don&#39;t consider this critical for Swift 3. The compiler will greatly improve simply by making this work (because the dumb assumptions that block this feature likely trigger additional bugs), but we don&#39;t need to allow it for ABI stability. There are a handful of places in the standard library where we&#39;ve had to promote a type that would normally be nested to the top level to work around this, but we could live with that as a smallish ABI wart in the long term and introduce generic typealiases to clean up the syntax once those features become available. <br>&gt; <br>&gt;&gt; Some things that I expect are out of scope for Swift 3 but am mentioning for completeness / confirmation of that:<br>&gt;&gt; <br>&gt;&gt; - variadic generics<br>&gt;&gt; - higher kinded types<br>&gt;&gt; - higher rank types<br>&gt; <br>&gt; Agreed that all are out of scope for Swift 3. The first is a feature of particular interest to me... But absolutely is out of scope. I also want to eventually use variadic generics to extend arbitrary length tuples of Equatable types to make them Equatable, for example ;)<br>&gt; <br>&gt; A couple features you didn&#39;t mention that I consider in scope for Swift 3 generics:<br>&gt; <br>&gt; - generic subscripts (the standard library might need these), e.g.,<br>&gt; <br>&gt;   subscript&lt;C : SequenceType where C.Generator.Element == Index&gt; (indices: C) -&gt; [Index]<br>&gt; <br>&gt; - recursive protocol constraints, where an associated type can be stated to conform to its enclosing protocol (directly or indirectly), eg,<br>&gt; <br>&gt;   protocol SequenceType {<br>&gt;     typealias SubSequence : SequenceType<br>&gt;   }<br>&gt; <br>&gt; - operators defined in types (only indirectly related to generics):<br>&gt; <br>&gt;   extension Array where Element : Equatable {<br>&gt;     func ==(lhs: Array, rhs: Array) -&gt; Bool { ... }<br>&gt;   }<br>&gt; <br>&gt; - &quot;real&quot; default implementations in protocols. It looks like a syntactic simplification from<br>&gt; Putting the definition in an extension, but putting the default implementation in the protocol itself has an important effect on resilience: one should be able to add requirements to a protocol without breaking ABI so long as those requirements have a default implementation. <br>&gt; <br>&gt; Several of these (recursive constraints, where clauses placing requirements on associated types in protocols, etc) are partly aimed at eliminated many of the underscored protocols in the standard library, because we don&#39;t want them to be part of the library ABI. <br>&gt; <br>&gt; I suspect I&#39;ll remember other small things, but that&#39;s the &quot;big&quot; list... and it&#39;s size perhaps illustrates why we need to choose carefully to maintain focus. <br>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/744c2792/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 7:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been going through some notes and realized I missed a couple of things when I put my list together:<br>&gt; <br>&gt; * access control for extensions declaring protocol conformances <br>&gt; * memberwise deriving of protocol implementations<br>&gt; <br>&gt; I also found an example of the “same type constraints” item I mentioned and it is different than discussed so far:<br>&gt; <br>&gt; struct S&lt;T, U&gt; {}<br>&gt; extension S where T == U {} // error<br>&gt; <br>&gt; Are you considering any of these for Swift 3?  <br></p><p>I’ve been picking Doug’s brain about this kind of stuff lately.<br></p><p>This one is somewhat similar to a same type requirement making a generic type parameter concrete, in the sense that the number of ‘primary archetypes’ becomes smaller than the number of generic parameters, which isn’t handled everywhere yet. For example, SIL walks the list of primary archetypes in order to map a generic type parameter’s depth/index to an archetype in several places.<br></p><p>With ‘secondary archetypes’, things are more flexible so this works:<br></p><p>protocol P { typealias X }<br>func foo&lt;T : P, U : P where T.X == U.X&gt;()<br></p><p>However, as Doug explained to me in person today, we’re still not doing a great job here. The list of requirements in a generic signature line up with the lists of primary and secondary archetypes in a tricky way. Also, type sugar allowing us to distinguish T.X from U.X is lost here since both types are mapped to the same identical type while building the generic signature, which you can imagine leads to poor diagnostics in more complex examples. Instead they need to have the same canonical type but still print differently, much like (X) and X, or [X] and Array&lt;X&gt;.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Access control for extensions declaring protocol conformances seems is the highest priority out of this group IMO.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 10:45 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Matthew,<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 7:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Dmitri, Slava and Doug thank you for taking the time to respond.  I apologize for not thanking you sooner.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the core team has a loosely shared understanding of the goals but hasn&#39;t had time to write it down yet I thought it might be helpful if I put together a summary of the features that seem to me like obvious candidates for completing the current generic system.  If I have missed anything significant please point that out. <br>&gt;&gt; <br>&gt;&gt; This is helpful, thank you!<br>&gt;&gt; <br>&gt;&gt; Lots of comments below. An overarching theme here is that I&#39;m trying to scope down the list to what we need to achieve ABI stability and an expressive library  fewer features means we&#39;re more likely to succeed with better quality. <br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m placing a &quot;**&quot; next to items that I beleive I have seen mentioned by the core team as desired features.  This is based on memory and may be innacurate or may be based on desires expressed, but not necessarily pinned to the Swift 3 timeline.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m hoping the core team might be able to indicate which items are likely to be part of the work you&#39;re doing on Swift 3, which items you might be interested in the community contributing to, and which items are unliekly to be considered during the Swift 3 timeframe even with community involvement.  This could help interested contributors start thinking about what they might be interested in working on while we wait for a more complete document describing the vision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - ** generic typealias<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t high on my list. It&#39;s a good feature, and I want it someday, but introducing generic typealiases won&#39;t have any impact on the ABI and therefore can wait IMO. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - allow protocols to specify a non-covarying Self in static method declarations (a possible solution to the problem of conforming non-final classes in Cocoa to protocols containing factory methods)<br>&gt;&gt; <br>&gt;&gt; Maybe. This isn&#39;t terribly high on my list, but in also behind on the discussion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - extensions<br>&gt;&gt;&gt; 	- ** allow same type constraints<br>&gt;&gt; <br>&gt;&gt; I&#39;m assuming you mean an extension like <br>&gt;&gt; <br>&gt;&gt;   extension Array where Element == String  {}<br>&gt;&gt; <br>&gt;&gt; Yes, it&#39;s something we want to support <br>&gt;&gt; <br>&gt;&gt;&gt; 	- ** allow protocol conformance in constrained extensions<br>&gt;&gt; <br>&gt;&gt; This is something like:<br>&gt;&gt; <br>&gt;&gt;   extension Array : Equatable where Element : Equatable {}<br>&gt;&gt; <br>&gt;&gt; It is very very high priority for Swift 3.<br>&gt;&gt; <br>&gt;&gt;&gt; 	- allow protocol conformance in protocol extensions<br>&gt;&gt; <br>&gt;&gt; This is something like:<br>&gt;&gt; <br>&gt;&gt;   extension CollectionType : Equatable where Generator.Element : Equatable {}<br>&gt;&gt; <br>&gt;&gt; This is probably not a priority for Swift 3. It seems very cool, and I&#39;ve advocated for similar features in the past (in more static generics systems), but the potential for ambiguities with such definitions is very high and the runtime cost for asking questions such as &quot;is this T Equatable?&quot; can be very high when this feature is in play. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - associated type constraints<br>&gt;&gt;&gt; 	- use of Self as a superclass constraint<br>&gt;&gt; <br>&gt;&gt; This wasn&#39;t on my list at all. Care to elaborate on why this is important?<br>&gt;&gt; <br>&gt;&gt;&gt; 	- ** where clause constraining inidividual associated types<br>&gt;&gt;&gt; 	- ** where clause relating multiple assocated types<br>&gt;&gt; <br>&gt;&gt; Yes to both. We need the to properly express some relationships in the standard library types, such as a SubSequence&#39;s Element type matching the Element type of the  sequence itself. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - existentials for protocols with associated types<br>&gt;&gt;&gt; 	- protocol existentials don&#39;t conform to the protocol itself<br>&gt;&gt;&gt; 	- ** fully bound: protocol&lt;GeneratorType where Element == Int&gt; <br>&gt;&gt;&gt; 	- ** fully constrained: protocol&lt;GeneratorType where Element: CustomStringConvertible&gt;<br>&gt;&gt;&gt; 	- partially bound / constrained - allow access to members only mentioning constrained associated types<br>&gt;&gt;&gt; 	- ** unbound - allow access to members not mentioning Self or associated types<br>&gt;&gt;&gt; 	- composition: protocol&lt;P1, P2 where P1.Associated: P3, P2.Associated == Int, P1.Other == P2.Other&gt;<br>&gt;&gt; <br>&gt;&gt; This one is tough. It is a very, very common user request and existentials are painfully under implemented in Swift. On the other hand, it&#39;s an additive feature that isn&#39;t likely (IMO!) to be important for ABI stabilization in the language or library. So, I would put it out of scope for Swift 3. <br>&gt;&gt; <br>&gt;&gt;&gt; - nesting (per Slava&#39;s email)<br>&gt;&gt;&gt; 	- ** Generic types nested inside generic functions<br>&gt;&gt;&gt; 	- ** Generic types nested inside generic types<br>&gt;&gt;&gt; 	- ** Generic functions nested inside generic functions which capture values or outer generic types<br>&gt;&gt; <br>&gt;&gt; I think Slava and I disagree on this one ;)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t consider this critical for Swift 3. The compiler will greatly improve simply by making this work (because the dumb assumptions that block this feature likely trigger additional bugs), but we don&#39;t need to allow it for ABI stability. There are a handful of places in the standard library where we&#39;ve had to promote a type that would normally be nested to the top level to work around this, but we could live with that as a smallish ABI wart in the long term and introduce generic typealiases to clean up the syntax once those features become available. <br>&gt;&gt; <br>&gt;&gt;&gt; Some things that I expect are out of scope for Swift 3 but am mentioning for completeness / confirmation of that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - variadic generics<br>&gt;&gt;&gt; - higher kinded types<br>&gt;&gt;&gt; - higher rank types<br>&gt;&gt; <br>&gt;&gt; Agreed that all are out of scope for Swift 3. The first is a feature of particular interest to me... But absolutely is out of scope. I also want to eventually use variadic generics to extend arbitrary length tuples of Equatable types to make them Equatable, for example ;)<br>&gt;&gt; <br>&gt;&gt; A couple features you didn&#39;t mention that I consider in scope for Swift 3 generics:<br>&gt;&gt; <br>&gt;&gt; - generic subscripts (the standard library might need these), e.g.,<br>&gt;&gt; <br>&gt;&gt;   subscript&lt;C : SequenceType where C.Generator.Element == Index&gt; (indices: C) -&gt; [Index]<br>&gt;&gt; <br>&gt;&gt; - recursive protocol constraints, where an associated type can be stated to conform to its enclosing protocol (directly or indirectly), eg,<br>&gt;&gt; <br>&gt;&gt;   protocol SequenceType {<br>&gt;&gt;     typealias SubSequence : SequenceType<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; - operators defined in types (only indirectly related to generics):<br>&gt;&gt; <br>&gt;&gt;   extension Array where Element : Equatable {<br>&gt;&gt;     func ==(lhs: Array, rhs: Array) -&gt; Bool { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; - &quot;real&quot; default implementations in protocols. It looks like a syntactic simplification from<br>&gt;&gt; Putting the definition in an extension, but putting the default implementation in the protocol itself has an important effect on resilience: one should be able to add requirements to a protocol without breaking ABI so long as those requirements have a default implementation. <br>&gt;&gt; <br>&gt;&gt; Several of these (recursive constraints, where clauses placing requirements on associated types in protocols, etc) are partly aimed at eliminated many of the underscored protocols in the standard library, because we don&#39;t want them to be part of the library ABI. <br>&gt;&gt; <br>&gt;&gt; I suspect I&#39;ll remember other small things, but that&#39;s the &quot;big&quot; list... and it&#39;s size perhaps illustrates why we need to choose carefully to maintain focus. <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/1e77d389/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift 3 Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 8:45 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; - nesting (per Slava&#39;s email)<br>&gt;&gt; 	- ** Generic types nested inside generic functions<br>&gt;&gt; 	- ** Generic types nested inside generic types<br>&gt;&gt; 	- ** Generic functions nested inside generic functions which capture values or outer generic types<br>&gt; <br>&gt; I think Slava and I disagree on this one ;)<br></p><p>I think mostly we agree actually. :-) Your list of generics ABI tasks makes sense to me.<br></p><p>I don’t have any strong opinions about specific features going in now or later to be honest. I think in the long term we will likely end up implementing most of the features on Matthew&#39;s list, in one form or another. To keep things manageable we need to keep simplifying the conceptual model and paying off technical debt along the way.<br></p><p>So what I’d like to contribute to this effort is helping brainstorm what refactoring work needs to be done, and how to break down into manageable chunks since we can’t realistically fix everything. Also, in general I feel we haven’t nailed down the full conceptual model for the implementation of generics yet, but this is hard to quantify.<br></p><p>&gt; <br>&gt; I don&#39;t consider this critical for Swift 3. The compiler will greatly improve simply by making this work (because the dumb assumptions that block this feature likely trigger additional bugs), but we don&#39;t need to allow it for ABI stability.<br></p><p>I’m just happy now that nested generics don’t crash as much in Sema. It always bothered me when forgetting a ‘}’ could make the compiler crash just because you accidentally introduced nested generic context. :-)<br></p><p>&gt; I suspect I&#39;ll remember other small things, but that&#39;s the &quot;big&quot; list... and it&#39;s size perhaps illustrates why we need to choose carefully to maintain focus. <br></p><p>Not ABI obviously, but what are your thoughts of adding a new ‘assoctype’ keyword instead of overloading ‘typealias’ in protocols? This has come up several times on this list and on Twitter. I’m quite like the idea.<br></p><p>Also, a frequent user request is self-conforming protocols. Personally I have mixed feelings about this — the implementation Joe and I came up with would require double-dispatching through a per-protocol witness table that opened existentials, which creates some conceptual difficulties which may or may not be possible to fix with some hacks, eg if T : P and T is bound to P, existential erasure of T to P would produce a double-wrapped existential P, which would create problems for casts among other things. I haven’t thought about if this impacts the ABI or not.<br></p><p>Slava<br></p><p>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 3:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the stated focus areas for Swift 3 is to complete the generics system.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How far along is the design for the “complete” generics system?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s a loose shared understanding of the pieces we need among the compiler and standard library developers that have been co-evolving the generics system, but it’s not written down in any single place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there appetite among the core team to involve the community in evaluating planned features or submitting proposals to complement existing plans?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, absolutely. I feel like we (the core team) need to articulate our vision here—what we feel we need to accomplish (in features, in the standard library API, in the implementation) in Swift 3 vs. what we believe we can introduce later on, how the pieces all fit together, etc.—to help facilitate those discussions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, is there any documentation other than https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt; describing in detail what the complete vision for the generics system is and what new features will be added in Swift 3 (as well as any generics features that have been decided against for Swift or version 3 specifically)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, that document is the best overall documentation for the vision of the generics system, despite being mostly untouched for more than two years and lacking newer features (protocol extensions, anyone?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, we need to write up a document describing our vision here. It’s going to take a little time, both because it’s a nontrivial task and because the likely principal authors are also engaged in other large Swift 3 tasks (e.g., https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/cf07de51/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
