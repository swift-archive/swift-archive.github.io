<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Large integer literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  3, 2016 at 09:00:00pm</p></header><div class="content"><p>So, `BinaryInteger` means we can now create integer types larger than 64 bits. But how do we write them in our code? Currently, you support integer literals by conforming to `IntegerLiteralConvertible`, filling in its `IntegerLiteralType` associated type with one of the standard library&#39;s integer types. But that means a third-party integer type can&#39;t be initialized from a literal that won&#39;t fit into an `Int64` or `UInt64`.<br></p><p>The current implementation is that `IntegerLiteralConvertible.IntegerLiteralType` is invisibly constrained to `_BuiltinIntegerLiteralConvertible`, a parallel version which takes (via a typealias) a `Builtin.Int2048`. (I believe in my searches, I saw it implied somewhere that 2048 bits is a temporary limitation and it&#39;s eventually intended to be arbitrary precision, but let&#39;s leave that aside for now.) Thus, the Swift compiler internally supports integer literals up to 2048 bits long, but the standard library limits us to 64 bits of that. It&#39;d be nice to do better than that.<br></p><p>I see a few different options here. There are probably others; if you think of something I&#39;ve missed, please pipe up.<br></p><p><br></p><p>1. Conform `String` to `_BuiltinIntegerLiteralConvertible`<br></p><p>`String` could be conformed to `_BuiltinIntegerLiteralConvertible`. If you choose to make your `IntegerLiteralConvertible` use a String, then you&#39;ll receive a string of digits, and you&#39;ll parse those digits into your internal representation. I think we&#39;re even providing a string-to-integer conversion, so it would be fairly convenient.<br></p><p>This is probably the easiest option to implement, and it lends itself to becoming variable-width later. However, there are large and obvious downsides to this: strings are much larger than necessary and the conversion would be relatively slow. In practice, I think this would be a hack.<br></p><p><br></p><p>2. Use a tuple/array of `Int`s/`UInts`<br></p><p>Like `String`, this lends itself to becoming variable-width in a later version; unlike `String`, it&#39;s relatively compact. But also unlike `String`, it would be hard to get this working in Swift 3: tuples cannot be conformed to protocols like `_BuiltinIntegerLiteralConvertible`, and there&#39;s no conditional conformances to make `[Int]`/`[UInt]` conform to it either.<br></p><p><br></p><p>3. Introduce an `Int2048` type<br></p><p>Just as we wrap `Builtin.Int64` in an `Int64` type, so we could wrap `Builtin.Int2048` in a full-featured `Int2048` type. This would have the works: arithmetic operators, conversions, bitshifts, everything that `FixedWidthInteger` has to offer.<br></p><p>Though this would certainly work, and even be rather elegant, I don&#39;t think it&#39;s a good idea. 2048 bits is 256 bytes. It&#39;s *huge* compared to other integer types, and *huge* compared to what people usually need. I suspect that it would be an attractive nuisance: People would be drawn to use `Int2048` instead of writing, or finding a library implementing, the `Int128` or `UInt256` they actually needed. They would end up wasting hundreds of bytes of RAM, bus capacity, and cache every time they accessed one, and hundreds of operations every time they performed arithmetic.<br></p><p>In other words, let&#39;s not do that.<br></p><p><br></p><p>4. Introduce a `LargeIntegerLiteral` type as an alternative `IntegerLiteralType`.<br></p><p>`LargeIntegerLiteral` would be a struct or class that contained a `Builtin.Int2048`. (A class might be a good idea so that we wouldn&#39;t copy around 256 bytes of struct directly.) Its only constructor would be the hidden `_BuiltinIntegerLiteralConvertible` one, so only the compiler could construct one, and it would only support a minimal subset of `BinaryInteger`&#39;s interface. Ideally, the fact that it has a 2048-bit limit would be an implementation detail, so we could change it later.<br></p><p>Rough sketch:<br></p><p>	public final class LargeIntegerLiteral: _BuiltinIntegerLiteralConvertible {<br>		private var _value: Builtin.Int2048<br>		<br>		// hidden from normal code; only available to the compiler<br>		public init(_builtinIntegerLiteral value: Builtin.Int2048) {<br>			_value = value<br>		}<br>		<br>		public var bitWidth: Int { return 2048 }<br>		public func word(at index: Int) -&gt; UInt { ... }<br>		public var minimumSignedRepresentationBitWidth: Int { … }<br>		public var sign: Sign { ... }<br>	}<br></p><p>(There might need to be a separate `LargeUIntegerLiteral`—I haven&#39;t thought deeply about this.)<br></p><p>Usage might be something like (I&#39;ve made no attempt to test or optimize this):<br></p><p>	extension DoubleWidth {<br>		init(integerLiteral value: LargeIntegerLiteral) {<br>			// This precondition isn&#39;t quite right—it isn&#39;t taking into account whether Self is signed.<br>			precondition(value.minimumSignedRepresentationBitWidth &lt;= bitWidth, &quot;Integer literal out of range&quot;)<br>			<br>			// We want the unsigned variant even if we&#39;re currently signed.<br>			var bits = Magnitude()<br>			if value.sign == .minus {<br>				bits = ~bits<br>			}<br>			<br>			for i in 0 ..&lt; countRepresentedWords {<br>				let word = value.word(at: i)<br></p><p>				bits &amp;&lt;&lt;= word.bitWidth<br>				bits |= Magnitude(truncatingOrExtending: word)<br>			}<br>			<br>			self.init(bitPattern: bits)<br>		}<br>	}<br></p><p>Actually, I suspect this could be put into an extension on `FixedWidthInteger` and many types would never have to write it themselves.<br></p><p>(P.S. I didn&#39;t notice the changes to bitshifts when we were reviewing SE-0104. They are *excellent*.)<br></p><p><br></p><p>5. Rework `IntegerLiteralConvertible` to only use `LargeIntegerLiteral`<br></p><p>Well, `LargeIntegerLiteral` would probably be named `IntegerLiteral` in this plan.<br></p><p>Basically, this would follow the previous approach, except it would also eliminate the `_BuiltinIntegerLiteralConvertible` conformance on all other types. Thus, *all* `IntegerLiteralConvertible` types, both standard library and third-party, would be initialized from an `IntegerLiteral` instance:<br></p><p>	public protocol IntegerLiteralConvertible {<br>		init(integerLiteral value: IntegerLiteral)<br>	}<br></p><p>The cool thing about this is that it *massively* simplifies the standard library—it actually eliminates an associated type!—and doesn&#39;t privilege the standard library over other types. (Well, except that stdlib can reach into the `IntegerLiteral` and work on the `value` within.) The less cool thing is that the optimizer might have to re-learn how to elide `init(integerLiteral:)` calls on built-in types.<br></p><p><br></p><p>Recommendation<br></p><p>My preference is an eventual transition to #5 using a version of #4 as a stopgap.<br></p><p>The transitional design would look like this: We underscore `IntegerLiteralConvertible.IntegerLiteralType` and then default it to `IntegerLiteral`; then we also underscore the current version of `init(integerLiteral:)` and introduce a replacement that always takes an `IntegerLiteral`. We implement the new `IntegerLiteral` based initializers on the various conforming types, but probably don&#39;t use them that heavily yet. The compiler would generate the same code, except it would now call the underscored initializer.<br></p><p>	public protocol IntegerLiteralConvertible {<br>		// This is the public face of the protocol…<br>		init(integerLiteral value: IntegerLiteral)<br>		<br>		// …but things actually go through here.<br>		associatedtype _BuiltinIntegerLiteralType: _BuiltinIntegerLiteralConvertible = IntegerLiteral<br>		init(_integerLiteral value: _BuiltinIntegerLiteralType)<br>	}<br>	<br>	extension IntegerLiteralConvertible where _BuiltinIntegerLiteralType == IntegerLiteral {<br>		public init(_integerLiteral value: _BuiltinIntegerLiteralType) {<br>			self.init(integerLiteral: value)<br>		}<br>	}<br></p><p>This would force third-party types to use `IntegerLiteral`, but allow standard library types (and the compiler) to continue using the existing, but slightly renamed, `_BuiltinIntegerLiteralConvertible` conformances instead. Eventually—possibly after Swift 3—we would eliminate the other `_BuiltinIntegerLiteralConvertible` conformances, at which point we can switch the compiler to using the public protocol instead, eliminate the underscored parts of `IntegerLiteralConvertible`, and get on with our lives.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Large integer literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 3, 2016, at 9:20 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; 			for i in 0 ..&lt; countRepresentedWords {<br>&gt; 				let word = value.word(at: i)<br>&gt; <br>&gt; 				bits &amp;&lt;&lt;= word.bitWidth<br>&gt; 				bits |= Magnitude(truncatingOrExtending: word)<br>&gt; 			}<br></p><p>Tangentially, I now realize that this was totally backwards. Should be more like:<br></p><p>			for i in 0 ..&lt; countRepresentedWords {<br>				let word = value.word(at: i)<br>				let shift = i * word.bitWidth<br>				bits |= Magnitude(truncatingOrExtending: word) &amp;&lt;&lt; shift<br>			}<br></p><p>Always fun when your dumb mistakes get sent to large numbers of people.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Idea] Large integer literals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  3, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Jul 3, 2016 at 9:20 PM, Brent Royal-Gordon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 2. Use a tuple/array of `Int`s/`UInts`<br>&gt;<br>&gt; Like `String`, this lends itself to becoming variable-width in a later version; unlike `String`, it&#39;s relatively compact. But also unlike `String`, it would be hard to get this working in Swift 3: tuples cannot be conformed to protocols like `_BuiltinIntegerLiteralConvertible`, and there&#39;s no conditional conformances to make `[Int]`/`[UInt]` conform to it either.<br></p><p>My recommended approach is to follow the example of DictionaryLiteral,<br>and define a &quot;transport&quot; data type that can accurately capture the<br>literal contents.  The transport data type should not have any<br>operations beyond the bare minimum (not even the BinaryInteger<br>conformance), so that the users are not tempted to use it as a<br>big-integer type.<br></p><p>The IntegerLiteral type would probably just wrap an<br>UnsafeBufferPointer to the readonly data segment, where the compiler<br>would lay out the literal.  (Very much like StaticString.  Maybe it<br>should be renamed to StringLiteral?)<br></p><p>I would not recommend wrapping a Builtin.Int2048 by value, this leads<br>to very inefficient code.  When it comes from the standard library,<br>this code is currently cleaned up by the optimizer because everything<br>that touches Builtin.Int2048 is marked @_transparent; but ordinary<br>frameworks can&#39;t do that.<br></p><p><br></p><p>A related issue is that the generic entry point that accepts<br>Builtin.Int2048 is still emitted by the compiler, and it is actually<br>called from unspecialized generic code when creating literals of<br>generic types.<br></p><p>func f&lt;T : Integer&gt;() -&gt; T{<br>  let x: T = 0<br>  return x<br>}<br></p><p>It would be great if we introduced another entry point in<br>IntegerLiteralConvertible that accepted [U]Int64 (and/or [U]Int128),<br>which the compiler would prefer if the literal is small (and it<br>usually is).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
