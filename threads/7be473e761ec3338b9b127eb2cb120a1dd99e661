<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[discussion] Fixing Protocols with Self or Associated Type Requirements</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>Hello all,<br></p><p>If you’ve been (attempting) protocol-oriented development in your own projects, I’m sure you’ve come across a particular build error at one point:<br></p><p>&gt; Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>To be frank, this restriction in the current Swift model sucks, a lot. In *many* cases, this prevents me from using protocols, and instead I have to fall back to using concrete types.<br></p><p>Here are a couple examples of using protocols with collections that should work fine, but simply don’t:<br></p><p>A Set of Types Conforming to Protocol<br></p><p>protocol MyProtocol: Hashable {}<br></p><p>let set = Set&lt;MyProtocol&gt;() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>When declaring a Set, the generic type of the Set’s contents must conform to Hashable. Following this, it would appear that you should be able to declare a Set containing types conforming to a given protocol which in turn conforms to Hashable. Nope! This also means you can’t have a Set&lt;Hashable&gt; (so no type-erased Sets for you!). One potential workaround is to use a box type, but if exposing the set to a user, this is essentially a leaky abstraction.<br></p><p>Finding a Protocol Type Instance in an Array<br></p><p>protocol MyProtocol {}<br>struct MyStruct: MyProtocol {}<br></p><p>var array = [MyProtocol]()<br>array.append(MyStruct())<br></p><p>let index = array.index(of: MyStruct()) // ERROR: Cannot invoke &#39;index&#39; with an argument list of type &#39;(of: MyStruct)&#39;<br></p><p>So, we can’t use Set as a collection for our protocol types, let’s use Array instead! Not so fast: because MyProtocol doesn’t conform to Equatable, we can’t use the Array.index(of:) function to find it. Easy fix though, just make MyProtocol conform to Equatable, right?<br></p><p>protocol MyProtocol: Equatable {}<br>struct MyStruct: MyProtocol {}<br></p><p>var array = [MyProtocol]() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>Nope! Now that it conforms to Equatable, it can no longer be used in Array’s type declaration. However, there is a (somewhat) workaround for this problem:<br></p><p>protocol MyProtocol {}<br>func ==(lhs: MyProtocol, rhs: MyProtocol) -&gt; Bool { return true }<br></p><p>struct MyStruct: MyProtocol {}<br></p><p>var array = [MyProtocol]()<br>array.append(MyStruct())<br></p><p>let index = array.index(where: { $0 == MyStruct() })<br></p><p>Basically, we can define the == function for MyProtocol, and then instead of using Array.index(of:), we use Array.index(where:) to manually compare each item to see if it matches, aka what Array.index(of:) would do for us normally if we simply could declare MyProtocol as conforming to equatable.<br></p><p>TL;DR<br>Swift really pushes the idea of protocol-oriented programming, and for the most part this works well. However, due to some underlying restrictions in the current Swift model, you can’t use protocols in all the same places you can use concrete types, which sucks. This is especially confusing for beginners who are trying to use protocols, but get frustrated when it doesn’t work where they want it to (and don’t understand why), so they fall back to using concrete types (usually implemented with class inheritance). For this reason, I think these restrictions need to be fixed ASAP, or else the Swift language is essentially pushing people away from protocol-oriented programming.<br></p><p>Riley Testut<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/7be4e661/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[discussion] Fixing Protocols with Self or Associated Type Requirements</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Yes, the restriction &quot;sucks&quot;, but it is there for a reason.  A protocol is not just a convenient collection of methods and properties you can generalize over, it&#39;s a contract.  Each tells you something about what its implementers have to do before they can call themselves &#39;Equatable&#39; or &#39;MyProtocol&#39; etc.  Let&#39;s see what happens at a very high level if we relax this constraint for Equatable as you have written here.<br></p><p>protocol Equatable {<br>  func ==(_: Equatable, _: Equatable) -&gt; Bool<br>}<br></p><p>And now two implementers (implementation abbreviated for brevity)<br></p><p>extension String: Equatable {}<br>extension Int: Equatable {}<br></p><p>// ...<br></p><p>Given this definition, the following typecheck<br></p><p>1 == 2 // false<br>&quot;A&quot; == &quot;A&quot; // true<br>1 == &quot;1&quot; // ?<br>&quot;ABC&quot; == 123 // ?<br></p><p>Being Equatable suddenly must include a component of self-identity.  We have to be able to constrain the implementation to only those Equatable things that look like ourselves.  Thus, Self constraints.  Because &#39;MyProtocol&#39; is not defining a protocol for things that understand equality, it is defining an equivalence relation over all possible implementations of ==, and that means that anything goes.  <br></p><p>So you might modify this to use associated types then.  What about an iteration that asks the implementer to specify the type made in the comparison?<br></p><p>protocol Equatable {<br>  associatedtype Comparator<br>  func ==(_: Equatable.Comparator, _: Equatable.Comparator) -&gt; Bool<br>}<br></p><p>This also solves nothing.  You can&#39;t actually constrain the associated types here with a needed equality constraint.  You can only push the problem down a needless level of abstraction.<br></p><p>Yes it&#39;s a pain to have to use Generics to reify restricted protocols.  Yes it&#39;s a pain to give up use of protocol-ified collections.  Yes it&#39;s not immediately obvious why these restrictions are in place.  But to drop them would severely dilute the intended semantics and use of protocols that require knowledge of their reifications.  Unfortunately, equality just happens to be one such protocol.<br></p><p>There are ways around this.  If you have a sealed hierarchy you can write an enum that enumerates all possible implementations and delegates it&#39;s equatable conformance out to them.  Often, identity can be found elsewhere in a type.  For example, a hypothetical &#39;UUIDable&#39; protocol could specify it&#39;s implementers produce a String UUID that could be stored in collections instead of UUIDable types themselves.  For most other cases try to re-evaluate.  Why do you need to generalize over this set of types in this way?  Is there some other more generic way of handling this case?<br></p><p>~Robert Widmann<br></p><p>2016/06/28 23:17、Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Hello all,<br>&gt; <br>&gt; If you’ve been (attempting) protocol-oriented development in your own projects, I’m sure you’ve come across a particular build error at one point:<br>&gt; <br>&gt;&gt; Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; To be frank, this restriction in the current Swift model sucks, a lot. In *many* cases, this prevents me from using protocols, and instead I have to fall back to using concrete types.<br>&gt; <br>&gt; Here are a couple examples of using protocols with collections that should work fine, but simply don’t:<br>&gt; <br>&gt; A Set of Types Conforming to Protocol<br>&gt; <br>&gt; protocol MyProtocol: Hashable {}<br>&gt; <br>&gt; let set = Set&lt;MyProtocol&gt;() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; When declaring a Set, the generic type of the Set’s contents must conform to Hashable. Following this, it would appear that you should be able to declare a Set containing types conforming to a given protocol which in turn conforms to Hashable. Nope! This also means you can’t have a Set&lt;Hashable&gt; (so no type-erased Sets for you!). One potential workaround is to use a box type, but if exposing the set to a user, this is essentially a leaky abstraction.<br>&gt; <br>&gt; Finding a Protocol Type Instance in an Array<br>&gt; <br>&gt; protocol MyProtocol {}<br>&gt; struct MyStruct: MyProtocol {}<br>&gt; <br>&gt; var array = [MyProtocol]()<br>&gt; array.append(MyStruct())<br>&gt; <br>&gt; let index = array.index(of: MyStruct()) // ERROR: Cannot invoke &#39;index&#39; with an argument list of type &#39;(of: MyStruct)&#39;<br>&gt; <br>&gt; So, we can’t use Set as a collection for our protocol types, let’s use Array instead! Not so fast: because MyProtocol doesn’t conform to Equatable, we can’t use the Array.index(of:) function to find it. Easy fix though, just make MyProtocol conform to Equatable, right?<br>&gt; <br>&gt; protocol MyProtocol: Equatable {}<br>&gt; struct MyStruct: MyProtocol {}<br>&gt; <br>&gt; var array = [MyProtocol]() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; Nope! Now that it conforms to Equatable, it can no longer be used in Array’s type declaration. However, there is a (somewhat) workaround for this problem:<br>&gt; <br>&gt; protocol MyProtocol {}<br>&gt; func ==(lhs: MyProtocol, rhs: MyProtocol) -&gt; Bool { return true }<br>&gt; <br>&gt; struct MyStruct: MyProtocol {}<br>&gt; <br>&gt; var array = [MyProtocol]()<br>&gt; array.append(MyStruct())<br>&gt; <br>&gt; let index = array.index(where: { $0 == MyStruct() })<br>&gt; <br>&gt; Basically, we can define the == function for MyProtocol, and then instead of using Array.index(of:), we use Array.index(where:) to manually compare each item to see if it matches, aka what Array.index(of:) would do for us normally if we simply could declare MyProtocol as conforming to equatable.<br>&gt; <br>&gt; TL;DR<br>&gt; Swift really pushes the idea of protocol-oriented programming, and for the most part this works well. However, due to some underlying restrictions in the current Swift model, you can’t use protocols in all the same places you can use concrete types, which sucks. This is especially confusing for beginners who are trying to use protocols, but get frustrated when it doesn’t work where they want it to (and don’t understand why), so they fall back to using concrete types (usually implemented with class inheritance). For this reason, I think these restrictions need to be fixed ASAP, or else the Swift language is essentially pushing people away from protocol-oriented programming.<br>&gt; <br>&gt; Riley Testut<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/10cdc7cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[discussion] Fixing Protocols with Self or Associated Type Requirements</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>Things will get better once we have existentials.<br></p><p>&gt; On 29 Jun 2016, at 08:49, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, the restriction &quot;sucks&quot;, but it is there for a reason.  A protocol is not just a convenient collection of methods and properties you can generalize over, it&#39;s a contract.  Each tells you something about what its implementers have to do before they can call themselves &#39;Equatable&#39; or &#39;MyProtocol&#39; etc.  Let&#39;s see what happens at a very high level if we relax this constraint for Equatable as you have written here.<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(_: Equatable, _: Equatable) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; And now two implementers (implementation abbreviated for brevity)<br>&gt; <br>&gt; extension String: Equatable {}<br>&gt; extension Int: Equatable {}<br>&gt; <br>&gt; // ...<br>&gt; <br>&gt; Given this definition, the following typecheck<br>&gt; <br>&gt; 1 == 2 // false<br>&gt; &quot;A&quot; == &quot;A&quot; // true<br>&gt; 1 == &quot;1&quot; // ?<br>&gt; &quot;ABC&quot; == 123 // ?<br>&gt; <br>&gt; Being Equatable suddenly must include a component of self-identity.  We have to be able to constrain the implementation to only those Equatable things that look like ourselves.  Thus, Self constraints.  Because &#39;MyProtocol&#39; is not defining a protocol for things that understand equality, it is defining an equivalence relation over all possible implementations of ==, and that means that anything goes.  <br>&gt; <br>&gt; So you might modify this to use associated types then.  What about an iteration that asks the implementer to specify the type made in the comparison?<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   associatedtype Comparator<br>&gt;   func ==(_: Equatable.Comparator, _: Equatable.Comparator) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; This also solves nothing.  You can&#39;t actually constrain the associated types here with a needed equality constraint.  You can only push the problem down a needless level of abstraction.<br>&gt; <br>&gt; Yes it&#39;s a pain to have to use Generics to reify restricted protocols.  Yes it&#39;s a pain to give up use of protocol-ified collections.  Yes it&#39;s not immediately obvious why these restrictions are in place.  But to drop them would severely dilute the intended semantics and use of protocols that require knowledge of their reifications.  Unfortunately, equality just happens to be one such protocol.<br>&gt; <br>&gt; There are ways around this.  If you have a sealed hierarchy you can write an enum that enumerates all possible implementations and delegates it&#39;s equatable conformance out to them.  Often, identity can be found elsewhere in a type.  For example, a hypothetical &#39;UUIDable&#39; protocol could specify it&#39;s implementers produce a String UUID that could be stored in collections instead of UUIDable types themselves.  For most other cases try to re-evaluate.  Why do you need to generalize over this set of types in this way?  Is there some other more generic way of handling this case?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/28 23:17、Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; If you’ve been (attempting) protocol-oriented development in your own projects, I’m sure you’ve come across a particular build error at one point:<br>&gt;&gt; <br>&gt;&gt;&gt; Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt;&gt; <br>&gt;&gt; To be frank, this restriction in the current Swift model sucks, a lot. In *many* cases, this prevents me from using protocols, and instead I have to fall back to using concrete types.<br>&gt;&gt; <br>&gt;&gt; Here are a couple examples of using protocols with collections that should work fine, but simply don’t:<br>&gt;&gt; <br>&gt;&gt; A Set of Types Conforming to Protocol<br>&gt;&gt; <br>&gt;&gt; protocol MyProtocol: Hashable {}<br>&gt;&gt; <br>&gt;&gt; let set = Set&lt;MyProtocol&gt;() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt;&gt; <br>&gt;&gt; When declaring a Set, the generic type of the Set’s contents must conform to Hashable. Following this, it would appear that you should be able to declare a Set containing types conforming to a given protocol which in turn conforms to Hashable. Nope! This also means you can’t have a Set&lt;Hashable&gt; (so no type-erased Sets for you!). One potential workaround is to use a box type, but if exposing the set to a user, this is essentially a leaky abstraction.<br>&gt;&gt; <br>&gt;&gt; Finding a Protocol Type Instance in an Array<br>&gt;&gt; <br>&gt;&gt; protocol MyProtocol {}<br>&gt;&gt; struct MyStruct: MyProtocol {}<br>&gt;&gt; <br>&gt;&gt; var array = [MyProtocol]()<br>&gt;&gt; array.append(MyStruct())<br>&gt;&gt; <br>&gt;&gt; let index = array.index(of: MyStruct()) // ERROR: Cannot invoke &#39;index&#39; with an argument list of type &#39;(of: MyStruct)&#39;<br>&gt;&gt; <br>&gt;&gt; So, we can’t use Set as a collection for our protocol types, let’s use Array instead! Not so fast: because MyProtocol doesn’t conform to Equatable, we can’t use the Array.index(of:) function to find it. Easy fix though, just make MyProtocol conform to Equatable, right?<br>&gt;&gt; <br>&gt;&gt; protocol MyProtocol: Equatable {}<br>&gt;&gt; struct MyStruct: MyProtocol {}<br>&gt;&gt; <br>&gt;&gt; var array = [MyProtocol]() // ERROR: Protocol ‘MyProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt;&gt; <br>&gt;&gt; Nope! Now that it conforms to Equatable, it can no longer be used in Array’s type declaration. However, there is a (somewhat) workaround for this problem:<br>&gt;&gt; <br>&gt;&gt; protocol MyProtocol {}<br>&gt;&gt; func ==(lhs: MyProtocol, rhs: MyProtocol) -&gt; Bool { return true }<br>&gt;&gt; <br>&gt;&gt; struct MyStruct: MyProtocol {}<br>&gt;&gt; <br>&gt;&gt; var array = [MyProtocol]()<br>&gt;&gt; array.append(MyStruct())<br>&gt;&gt; <br>&gt;&gt; let index = array.index(where: { $0 == MyStruct() })<br>&gt;&gt; <br>&gt;&gt; Basically, we can define the == function for MyProtocol, and then instead of using Array.index(of:), we use Array.index(where:) to manually compare each item to see if it matches, aka what Array.index(of:) would do for us normally if we simply could declare MyProtocol as conforming to equatable.<br>&gt;&gt; <br>&gt;&gt; TL;DR<br>&gt;&gt; Swift really pushes the idea of protocol-oriented programming, and for the most part this works well. However, due to some underlying restrictions in the current Swift model, you can’t use protocols in all the same places you can use concrete types, which sucks. This is especially confusing for beginners who are trying to use protocols, but get frustrated when it doesn’t work where they want it to (and don’t understand why), so they fall back to using concrete types (usually implemented with class inheritance). For this reason, I think these restrictions need to be fixed ASAP, or else the Swift language is essentially pushing people away from protocol-oriented programming.<br>&gt;&gt; <br>&gt;&gt; Riley Testut<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/731b1358/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
