<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Variadics through tuples</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Currently, the following code is allowed:<br></p><p>//function application operator<br>infix operator =&gt; {}<br>func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>    return try b(a)<br>}<br></p><p>infix operator ?=&gt; {}<br>func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>    if let unwrapped = a {<br>        return try b(a)<br>    }<br>    return nil<br>}<br></p><p>//some defined functions<br></p><p>func defaultDestination() -&gt; (x: Int, y: Int)<br>func loadedDestination() -&gt; (x: Int, y: Int)?<br>func moveTo(x: Int, y: Int)<br></p><p>//actual code<br></p><p>defaultDestination() =&gt; moveTo<br>loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br></p><p>//code without functional chaining<br></p><p>let point = defaultDestination()<br>moveTo(x: point.x, y: point.y)<br></p><p>if let loaded = loadedDestination() {<br>    moveTo(x: loaded.x, y: loaded.y)<br>} else {<br>    print(&quot;load failed&quot;)<br>}<br></p><p>I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br></p><p>moveTo(*defaultDestination())<br></p><p>So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br></p><p>defaultDestination() =&gt; *moveTo(x:y:)<br></p><p>The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br></p><p><br></p><p>So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br></p><p>takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br></p><p>takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br></p><p>takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br></p><p><br></p><p>Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Variadics through tuples</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Yes, I expect that with the implemented proposal SE-0110 your code will not <br>compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required <br>`((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple <br>argument or use some function/operator to transform argument list <br>parametrized function to function with tuple argument.<br></p><p>For example (this compiles now and IMO should after SE-0110 implemented, if <br>accepted):<br></p><p>//function application operator<br>infix operator =&gt; {}<br>func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>     return try b(a)<br>}<br></p><p>infix operator ?=&gt; {}<br>func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>     if let unwrapped = a {<br>         return try b(unwrapped)<br>     }<br>     return nil<br>}<br></p><p>//some defined functions<br></p><p>func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br></p><p><br>// ---- Variant 1 ----<br>func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br></p><p><br>// ---- Variant 2 ----<br>func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br></p><p>func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>     return { tu in return f(tu.0, tu.1) }<br>}<br></p><p><br>//actual code<br></p><p>defaultDestination() =&gt; moveTo1<br>(loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br></p><p>defaultDestination() =&gt; tupleize(moveTo2)<br>(loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br></p><p><br>If we&#39;ll have such `tupleize` as built-in operator, then things will be <br>even better. Don&#39;t see any problem here just like you, for example, don&#39;t <br>expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, <br>Int, String)-&gt;() is required an so on. List of function arguments is not <br>tuple at these days and so IMO only explicit conversion can exist to accept <br>second when first is required and vice-versa. But I&#39;m storng +1 to have <br>such handy convertion operator.<br></p><p><br>On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt; Currently, the following code is allowed:<br>&gt;<br>&gt; //function application operator<br>&gt; infix operator =&gt; {}<br>&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;     return try b(a)<br>&gt; }<br>&gt;<br>&gt; infix operator ?=&gt; {}<br>&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;     if let unwrapped = a {<br>&gt;         return try b(a)<br>&gt;     }<br>&gt;     return nil<br>&gt; }<br>&gt;<br>&gt; //some defined functions<br>&gt;<br>&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt; func moveTo(x: Int, y: Int)<br>&gt;<br>&gt; //actual code<br>&gt;<br>&gt; defaultDestination() =&gt; moveTo<br>&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;<br>&gt; //code without functional chaining<br>&gt;<br>&gt; let point = defaultDestination()<br>&gt; moveTo(x: point.x, y: point.y)<br>&gt;<br>&gt; if let loaded = loadedDestination() {<br>&gt;     moveTo(x: loaded.x, y: loaded.y)<br>&gt; } else {<br>&gt;     print(&quot;load failed&quot;)<br>&gt; }<br>&gt;<br>&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;<br>&gt; moveTo(*defaultDestination())<br>&gt;<br>&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;<br>&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;<br>&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;<br>&gt;<br>&gt;<br>&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;<br>&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;<br>&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;<br>&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;<br>&gt;<br>&gt;<br>&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Variadics through tuples</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br></p><p>However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br></p><p>let paramsClosure: (Int, Int) -&gt; () = â€¦<br>let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br></p><p><br>The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br></p><p><br>moveTo(x: Int, y: Int)<br>moveTo(_: (x: Int, y: Int)) //sneaky<br>moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br></p><p>let a = moveTo(x:y:)<br>let b = moveTo(_:)<br>let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br></p><p>let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br></p><p>Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br></p><p><br>A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br></p><p>moveTo(x: point.x, y: point.y)<br></p><p>(moveTo*)(point)<br></p><p>So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br></p><p>From James F<br></p><p><br>PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br></p><p>&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt; <br>&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt; <br>&gt; //function application operator<br>&gt; infix operator =&gt; {}<br>&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;    return try b(a)<br>&gt; }<br>&gt; <br>&gt; infix operator ?=&gt; {}<br>&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;    if let unwrapped = a {<br>&gt;        return try b(unwrapped)<br>&gt;    }<br>&gt;    return nil<br>&gt; }<br>&gt; <br>&gt; //some defined functions<br>&gt; <br>&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt; <br>&gt; <br>&gt; // ---- Variant 1 ----<br>&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt; <br>&gt; <br>&gt; // ---- Variant 2 ----<br>&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt; <br>&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;    return { tu in return f(tu.0, tu.1) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; //actual code<br>&gt; <br>&gt; defaultDestination() =&gt; moveTo1<br>&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt; <br>&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt; <br>&gt; <br>&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt; <br>&gt; <br>&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt; <br>&gt;&gt; //function application operator<br>&gt;&gt; infix operator =&gt; {}<br>&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;    return try b(a)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;    if let unwrapped = a {<br>&gt;&gt;        return try b(a)<br>&gt;&gt;    }<br>&gt;&gt;    return nil<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //some defined functions<br>&gt;&gt; <br>&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt; <br>&gt;&gt; //actual code<br>&gt;&gt; <br>&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt; <br>&gt;&gt; //code without functional chaining<br>&gt;&gt; <br>&gt;&gt; let point = defaultDestination()<br>&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt; <br>&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;    moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt; } else {<br>&gt;&gt;    print(&quot;load failed&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt; <br>&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt; <br>&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt; <br>&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt; <br>&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt; <br>&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt; <br>&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt; <br>&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Variadics through tuples</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  2, 2016 at 12:00:00am</p></header><div class="content"><p>On 01.07.2016 23:55, James Froggatt wrote:<br>&gt; Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br></p><p><br>Yes, agree.<br></p><p>&gt;<br>&gt; However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br>&gt;<br>&gt; let paramsClosure: (Int, Int) -&gt; () = â€¦<br>&gt; let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br>&gt;<br>&gt;<br>&gt; The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br>&gt;<br></p><p><br>Personally I also think that we need such `as` conversions from one to <br>another. At least because IMO there is a lot of code that already use the <br>feature of tuple splatting.<br></p><p>&gt;<br>&gt; moveTo(x: Int, y: Int)<br>&gt; moveTo(_: (x: Int, y: Int)) //sneaky<br>&gt; moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br>&gt;<br>&gt; let a = moveTo(x:y:)<br>&gt; let b = moveTo(_:)<br>&gt; let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br>&gt;<br>&gt; let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br>&gt;<br>&gt; Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br>&gt;<br>&gt;<br>&gt; A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br>&gt;<br>&gt; moveTo(x: point.x, y: point.y)<br>&gt;<br>&gt; (moveTo*)(point)<br>&gt;<br>&gt; So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br>&gt;<br>&gt; From James F<br>&gt;<br></p><p><br>Actually I also see a solution in having both: explicit &#39;as&#39; conversion and <br>in special operator. I feel like such special operator could be important <br>for functional programming in Swift. &#39;as&#39; conversion is very verbose and <br>you have to write it for each function again and again(or use typealias), <br>but operator will use one compiler magic for all functions.<br></p><p>I believe core team should decide if they want to keep/allow such &#39;as&#39; <br>conversion in case the proposal will be accepted.<br></p><p>&gt;<br>&gt; PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br>&gt;<br></p><p><br>:-) Yes, I also was surprised with just warnings in these places, but not <br>errors. Don&#39;t know if it is a bug or not. Can someone explain ?<br></p><p>Hint: check compilation warnings for your code.<br></p><p><br>&gt;&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt;&gt;<br>&gt;&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt;&gt;<br>&gt;&gt; //function application operator<br>&gt;&gt; infix operator =&gt; {}<br>&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;&gt;    return try b(a)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;&gt;    if let unwrapped = a {<br>&gt;&gt;        return try b(unwrapped)<br>&gt;&gt;    }<br>&gt;&gt;    return nil<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //some defined functions<br>&gt;&gt;<br>&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // ---- Variant 1 ----<br>&gt;&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // ---- Variant 2 ----<br>&gt;&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt;&gt;<br>&gt;&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;&gt;    return { tu in return f(tu.0, tu.1) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; //actual code<br>&gt;&gt;<br>&gt;&gt; defaultDestination() =&gt; moveTo1<br>&gt;&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt;&gt;<br>&gt;&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt;&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;    return try b(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;    if let unwrapped = a {<br>&gt;&gt;&gt;        return try b(a)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    return nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //code without functional chaining<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let point = defaultDestination()<br>&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;&gt;    moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;    print(&quot;load failed&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Variadics through tuples</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks. I agree, a standard library operator would clearly be the preferred way to do this, at least for general use. Basing it upon the â€˜asâ€™ cast just means we don&#39;t have to have to deal with another magical operator (looking at the inability to overload â€˜!â€™ and â€˜?â€™), as well as easing the transition from Swift 2.<br></p><p>From James F<br></p><p>&gt; On 1 Jul 2016, at 22:11, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 01.07.2016 23:55, James Froggatt wrote:<br>&gt;&gt; Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br>&gt; <br>&gt; <br>&gt; Yes, agree.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br>&gt;&gt; <br>&gt;&gt; let paramsClosure: (Int, Int) -&gt; () = â€¦<br>&gt;&gt; let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; Personally I also think that we need such `as` conversions from one to another. At least because IMO there is a lot of code that already use the feature of tuple splatting.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; moveTo(x: Int, y: Int)<br>&gt;&gt; moveTo(_: (x: Int, y: Int)) //sneaky<br>&gt;&gt; moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br>&gt;&gt; <br>&gt;&gt; let a = moveTo(x:y:)<br>&gt;&gt; let b = moveTo(_:)<br>&gt;&gt; let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br>&gt;&gt; <br>&gt;&gt; let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br>&gt;&gt; <br>&gt;&gt; Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br>&gt;&gt; <br>&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt; <br>&gt;&gt; (moveTo*)(point)<br>&gt;&gt; <br>&gt;&gt; So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; Actually I also see a solution in having both: explicit &#39;as&#39; conversion and in special operator. I feel like such special operator could be important for functional programming in Swift. &#39;as&#39; conversion is very verbose and you have to write it for each function again and again(or use typealias), but operator will use one compiler magic for all functions.<br>&gt; <br>&gt; I believe core team should decide if they want to keep/allow such &#39;as&#39; conversion in case the proposal will be accepted.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; :-) Yes, I also was surprised with just warnings in these places, but not errors. Don&#39;t know if it is a bug or not. Can someone explain ?<br>&gt; <br>&gt; Hint: check compilation warnings for your code.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;   return try b(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;   if let unwrapped = a {<br>&gt;&gt;&gt;       return try b(unwrapped)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   return nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ---- Variant 1 ----<br>&gt;&gt;&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ---- Variant 2 ----<br>&gt;&gt;&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;&gt;&gt;   return { tu in return f(tu.0, tu.1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; defaultDestination() =&gt; moveTo1<br>&gt;&gt;&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt;&gt;&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;   return try b(a)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;   if let unwrapped = a {<br>&gt;&gt;&gt;&gt;       return try b(a)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   return nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt;&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt;&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //code without functional chaining<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let point = defaultDestination()<br>&gt;&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;&gt;&gt;   moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;   print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Variadics through tuples</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks for pointing out the warning, I wouldn&#39;t have known otherwise. I tested using â€˜tryâ€™ on a non-throwing function in the iOS Swift Playgrounds app, and didn&#39;t get a warning. The app doesn&#39;t seem to give warnings, only errors.<br></p><p><br></p><p>Relatedly, I think bracketless T -&gt; T should be an error, not a warning, in Swift 3.<br></p><p>Int -&gt; Int //returns the same type<br>(Int) -&gt; Int //returnsâ€¦ yes, it is the same type, it&#39;s just stating the obvious<br></p><p>Especially if we&#39;re removing argument labels from function types, this just seems so redundant. I&#39;m not sure I can bring myself to hurt the readability of my code just to silence pointless compiler warnings. :P<br></p><p>Int, Int -&gt; (Int, Int) //multiple parameters, not equivalent to the return type<br>(Int, Int) -&gt; (Int, Int) //this function can be called with its tuple return type (I wish)<br></p><p>From James F<br></p><p>&gt; On 1 Jul 2016, at 22:24, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; Thanks. I agree, a standard library operator would clearly be the preferred way to do this, at least for general use. Basing it upon the â€˜asâ€™ cast just means we don&#39;t have to have to deal with another magical operator (looking at the inability to overload â€˜!â€™ and â€˜?â€™), as well as easing the transition from Swift 2.<br>&gt; <br>&gt; From James F<br>&gt; <br>&gt;&gt;&gt; On 1 Jul 2016, at 22:11, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 01.07.2016 23:55, James Froggatt wrote:<br>&gt;&gt;&gt; Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, agree.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let paramsClosure: (Int, Int) -&gt; () = â€¦<br>&gt;&gt;&gt; let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Personally I also think that we need such `as` conversions from one to another. At least because IMO there is a lot of code that already use the feature of tuple splatting.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; moveTo(x: Int, y: Int)<br>&gt;&gt;&gt; moveTo(_: (x: Int, y: Int)) //sneaky<br>&gt;&gt;&gt; moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = moveTo(x:y:)<br>&gt;&gt;&gt; let b = moveTo(_:)<br>&gt;&gt;&gt; let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (moveTo*)(point)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually I also see a solution in having both: explicit &#39;as&#39; conversion and in special operator. I feel like such special operator could be important for functional programming in Swift. &#39;as&#39; conversion is very verbose and you have to write it for each function again and again(or use typealias), but operator will use one compiler magic for all functions.<br>&gt;&gt; <br>&gt;&gt; I believe core team should decide if they want to keep/allow such &#39;as&#39; conversion in case the proposal will be accepted.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; :-) Yes, I also was surprised with just warnings in these places, but not errors. Don&#39;t know if it is a bug or not. Can someone explain ?<br>&gt;&gt; <br>&gt;&gt; Hint: check compilation warnings for your code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;      return try b(unwrapped)<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ---- Variant 1 ----<br>&gt;&gt;&gt;&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ---- Variant 2 ----<br>&gt;&gt;&gt;&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;&gt;&gt;&gt;  return { tu in return f(tu.0, tu.1) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo1<br>&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;&gt;      return try b(a)<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt;&gt;&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt;&gt;&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //code without functional chaining<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let point = defaultDestination()<br>&gt;&gt;&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;&gt;&gt;&gt;  moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;&gt;  print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Variadics through tuples</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  2, 2016 at 02:00:00am</p></header><div class="content"><p>On 02.07.2016 0:42, James Froggatt wrote:<br>&gt; Thanks for pointing out the warning, I wouldn&#39;t have known otherwise. I tested using â€˜tryâ€™ on a non-throwing function in the iOS Swift Playgrounds app, and didn&#39;t get a warning. The app doesn&#39;t seem to give warnings, only errors.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Relatedly, I think bracketless T -&gt; T should be an error, not a warning, in Swift 3.<br></p><p>Strange, I also thought the proposal was to disallow such syntax, not just <br>produce warnings. May be the work is in progress still..<br></p><p>&gt;<br>&gt; Int -&gt; Int //returns the same type<br>&gt; (Int) -&gt; Int //returnsâ€¦ yes, it is the same type, it&#39;s just stating the obvious<br>&gt;<br>&gt; Especially if we&#39;re removing argument labels from function types, this just seems so redundant. I&#39;m not sure I can bring myself to hurt the readability of my code just to silence pointless compiler warnings. :P<br>&gt;<br>&gt; Int, Int -&gt; (Int, Int) //multiple parameters, not equivalent to the return type<br>&gt; (Int, Int) -&gt; (Int, Int) //this function can be called with its tuple return type (I wish)<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt;&gt; On 1 Jul 2016, at 22:24, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks. I agree, a standard library operator would clearly be the preferred way to do this, at least for general use. Basing it upon the â€˜asâ€™ cast just means we don&#39;t have to have to deal with another magical operator (looking at the inability to overload â€˜!â€™ and â€˜?â€™), as well as easing the transition from Swift 2.<br>&gt;&gt;<br>&gt;&gt; From James F<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; On 1 Jul 2016, at 22:11, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 01.07.2016 23:55, James Froggatt wrote:<br>&gt;&gt;&gt;&gt; Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, agree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let paramsClosure: (Int, Int) -&gt; () = â€¦<br>&gt;&gt;&gt;&gt; let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Personally I also think that we need such `as` conversions from one to another. At least because IMO there is a lot of code that already use the feature of tuple splatting.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;&gt; moveTo(_: (x: Int, y: Int)) //sneaky<br>&gt;&gt;&gt;&gt; moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let a = moveTo(x:y:)<br>&gt;&gt;&gt;&gt; let b = moveTo(_:)<br>&gt;&gt;&gt;&gt; let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (moveTo*)(point)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually I also see a solution in having both: explicit &#39;as&#39; conversion and in special operator. I feel like such special operator could be important for functional programming in Swift. &#39;as&#39; conversion is very verbose and you have to write it for each function again and again(or use typealias), but operator will use one compiler magic for all functions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I believe core team should decide if they want to keep/allow such &#39;as&#39; conversion in case the proposal will be accepted.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; :-) Yes, I also was surprised with just warnings in these places, but not errors. Don&#39;t know if it is a bug or not. Can someone explain ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hint: check compilation warnings for your code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;&gt;      return try b(unwrapped)<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt;&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // ---- Variant 1 ----<br>&gt;&gt;&gt;&gt;&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // ---- Variant 2 ----<br>&gt;&gt;&gt;&gt;&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;&gt;&gt;&gt;&gt;  return { tu in return f(tu.0, tu.1) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo1<br>&gt;&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt;&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;&gt;&gt;      return try b(a)<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt;&gt;&gt;&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt;&gt;&gt;&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; //code without functional chaining<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; let point = defaultDestination()<br>&gt;&gt;&gt;&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;&gt;&gt;&gt;&gt;  moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt;&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;  print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Variadics through tuples</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 4:05 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 02.07.2016 0:42, James Froggatt wrote:<br>&gt;&gt; Thanks for pointing out the warning, I wouldn&#39;t have known otherwise. I tested using â€˜tryâ€™ on a non-throwing function in the iOS Swift Playgrounds app, and didn&#39;t get a warning. The app doesn&#39;t seem to give warnings, only errors.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Relatedly, I think bracketless T -&gt; T should be an error, not a warning, in Swift 3.<br>&gt; <br>&gt; Strange, I also thought the proposal was to disallow such syntax, not just produce warnings. May be the work is in progress still..<br></p><p>Correct, it should be an error, but is staged in as a warning.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Variadics through tuples</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 02:00:00am</p></header><div class="content"><p>So what&#39;s the official stance on this?<br></p><p>Is SE0029 specifically prohibiting the use of tuple splat as pure syntactic sugar?<br>Or does it extend toâ€¦<br></p><p><br>Tuple splat in generic contexts:<br></p><p>function&lt;A, B&gt;(a: A, b: (A) -&gt; B) -&gt; B {<br>    b(a)<br>}<br>function(a: tupleValue, b: splattableFunction)<br></p><p><br>Explicit casts, of the form:<br></p><p>let closure: (A, B) -&gt; ()<br>let explicitSplatted = closure as ((A, B)) -&gt; ()<br></p><p><br>In addition, with the explicit parameter list for function types requirement, variadic generic functions become unambiguous:<br></p><p>function&lt;A, B&gt;(a: A, b: A -&gt; B) { //the parameter list is the generic type<br>    b(a)<br>}<br></p><p>//implying this should be possible<br>function(a: (&amp;self.local, aConstant), b: aFunction)<br></p><p>It&#39;s worth considering under the old/current syntax, A -&gt; B implicitly allows variadic parameter lists (splatting the parameter list internally, since parameter lists don&#39;t have a better type-system model).<br>If we are to remove this feature, it is a breaking change, severely so to functional libraries and their users, which ought to get its own proposal.<br>If we are to fix this, parameter lists would be properly be modelled as a nonescaping tuple-like type, which would also require a proposal.<br>We could also just leave it as it is now, and introduce parameter lists or variadics to the type system in the future with minor changes to this particular case&#39;s syntax.<br></p><p>From James F<br></p><p>&gt; On 1 Jul 2016, at 22:24, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; Thanks. I agree, a standard library operator would clearly be the preferred way to do this, at least for general use. Basing it upon the â€˜asâ€™ cast just means we don&#39;t have to have to deal with another magical operator (looking at the inability to overload â€˜!â€™ and â€˜?â€™), as well as easing the transition from Swift 2.<br>&gt; <br>&gt; From James F<br>&gt; <br>&gt;&gt;&gt; On 1 Jul 2016, at 22:11, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 01.07.2016 23:55, James Froggatt wrote:<br>&gt;&gt;&gt; Thanks for the response. I understand function overloading is possible, but it isn&#39;t nearly as convinient.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, agree.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if explicit conversion is the way forward, then in the spirit of keeping backwards-compatibility in some form, we could simply allow this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let paramsClosure: (Int, Int) -&gt; () = â€¦<br>&gt;&gt;&gt; let tupleClosure = paramsClosure as ((Int, Int)) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The â€˜asâ€™ operator is already used for various type system magic (like converting T to Optional&lt;T&gt;), so this seems fairly natural. There shouldn&#39;t be any ambiguity, since overloads taking tuples would have either different labels or type signature:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Personally I also think that we need such `as` conversions from one to another. At least because IMO there is a lot of code that already use the feature of tuple splatting.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; moveTo(x: Int, y: Int)<br>&gt;&gt;&gt; moveTo(_: (x: Int, y: Int)) //sneaky<br>&gt;&gt;&gt; moveTo(x: (x: Int, y: Int), y: Int) //plain dumb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = moveTo(x:y:)<br>&gt;&gt;&gt; let b = moveTo(_:)<br>&gt;&gt;&gt; let c = moveTo(x:y:) as ((x: Int, y: Int), Int) -&gt; () //cast needed, same as for any type-based overload<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let d = moveTo(x:y:) as ((Int, Int)) -&gt; () //unambiguously the first function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this is clearly an explicit cast, which doesn&#39;t fall under the â€˜remove implicit tuple splatâ€™ proposal, can we explicity decide to keep this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A splat operator would then be user-definable (meaning fewer magic operators), just being applied to the function rather than the arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (moveTo*)(point)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, rather than a language addition, or even a modification of an existing proposal, this is something which sensibly should still be allowed even once â€˜implicit tuple splatâ€™ is removed. We&#39;d actually be losing a decent feature if we remove this completely, as is acknowledged by the suggestion of an explicit splat operator in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually I also see a solution in having both: explicit &#39;as&#39; conversion and in special operator. I feel like such special operator could be important for functional programming in Swift. &#39;as&#39; conversion is very verbose and you have to write it for each function again and again(or use typealias), but operator will use one compiler magic for all functions.<br>&gt;&gt; <br>&gt;&gt; I believe core team should decide if they want to keep/allow such &#39;as&#39; conversion in case the proposal will be accepted.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: Actually, I&#39;m surprised your code compiles, since I removed the â€˜rethrowsâ€™ decoration from the operator&#39;s function signature for brevity, but left the â€˜tryâ€™ in the implementation itself. Does Swift promote non-throwing functions to throwing ones like that? I have to double-check I don&#39;t have stray â€˜tryâ€™s lying around.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; :-) Yes, I also was surprised with just warnings in these places, but not errors. Don&#39;t know if it is a bug or not. Can someone explain ?<br>&gt;&gt; <br>&gt;&gt; Hint: check compilation warnings for your code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 Jul 2016, at 19:15, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I expect that with the implemented proposal SE-0110 your code will not compile because `moveTo` has type `(Int, Int)-&gt;Void` and not required `((Int, Int))-&gt;Void`. You&#39;ll need to change the moveTo to accept tuple argument or use some function/operator to transform argument list parametrized function to function with tuple argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example (this compiles now and IMO should after SE-0110 implemented, if accepted):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: (In) -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: (In) -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;      return try b(unwrapped)<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int) {return (1,1) }<br>&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)? {return nil }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ---- Variant 1 ----<br>&gt;&gt;&gt;&gt; func moveTo1(point: (x: Int, y: Int)) {print(&quot;move1 to: &quot;, point.x, point.y)}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ---- Variant 2 ----<br>&gt;&gt;&gt;&gt; func moveTo2(x: Int, y: Int) {print(&quot;move2 to: &quot;, x, y)}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func tupleize&lt;T,U,V&gt;(_ f: (T,U)-&gt;V ) -&gt; ( ((T, U))-&gt;V ) {<br>&gt;&gt;&gt;&gt;  return { tu in return f(tu.0, tu.1) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo1<br>&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; moveTo1) ?? print(&quot;load1 failed&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultDestination() =&gt; tupleize(moveTo2)<br>&gt;&gt;&gt;&gt; (loadedDestination() ?=&gt; tupleize(moveTo2)) ?? print(&quot;load2 failed&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we&#39;ll have such `tupleize` as built-in operator, then things will be even better. Don&#39;t see any problem here just like you, for example, don&#39;t expect function of (Int, (Int, String))-&gt;() will be accepted where (Int, Int, String)-&gt;() is required an so on. List of function arguments is not tuple at these days and so IMO only explicit conversion can exist to accept second when first is required and vice-versa. But I&#39;m storng +1 to have such handy convertion operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 01.07.2016 17:16, James Froggatt via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Currently, the following code is allowed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //function application operator<br>&gt;&gt;&gt;&gt;&gt; infix operator =&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func =&gt;&lt;In, Out&gt;(a: In, b: In -&gt; Out) -&gt; Out {<br>&gt;&gt;&gt;&gt;&gt;  return try b(a)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; infix operator ?=&gt; {}<br>&gt;&gt;&gt;&gt;&gt; func ?=&gt;&lt;In, Out&gt;(a: In?, b: In -&gt; Out?) -&gt; Out? {<br>&gt;&gt;&gt;&gt;&gt;  if let unwrapped = a {<br>&gt;&gt;&gt;&gt;&gt;      return try b(a)<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;  return nil<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //some defined functions<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func defaultDestination() -&gt; (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt; func loadedDestination() -&gt; (x: Int, y: Int)?<br>&gt;&gt;&gt;&gt;&gt; func moveTo(x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //actual code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; moveTo<br>&gt;&gt;&gt;&gt;&gt; loadedDestination() ?=&gt; moveTo ?? print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //code without functional chaining<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let point = defaultDestination()<br>&gt;&gt;&gt;&gt;&gt; moveTo(x: point.x, y: point.y)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let loaded = loadedDestination() {<br>&gt;&gt;&gt;&gt;&gt;  moveTo(x: loaded.x, y: loaded.y)<br>&gt;&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;&gt;  print(&quot;load failed&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m expecting this to stop working at some point in Swift 3&#39;s development, since it is related to tuple splat. I&#39;ve heard talk of tuple splat returning in the future through an operator, with the stand-in syntax:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; moveTo(*defaultDestination())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, how would a functional chaining operator work under these conditions? It would require a second variadic splat operator:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; defaultDestination() =&gt; *moveTo(x:y:)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The motivation for removing the standard form of tuple splat is that the calling syntax looks like an overload. But in this case, an explicit splat operator doesn&#39;t add any clarity, since the function being referred to can be unambiguous.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, my question is whether this is worth removing full support for in the first place. This behaviour can be make to fit Swift 3&#39;s distinction of parameter lists and tuples, by applying specific rules to the existing behaviour to create a lightweight variadics system:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: (T) -&gt; ()) //closure explicitly takes a single parameter<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T -&gt; ()) //closure takes any number of parameters<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; takesAClosure&lt;T&gt;(_: T, _: T -&gt; ()) //closure takes any number of parameters, but must have a parameter list which can be directly represented as a tuple<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Either way, I&#39;m hoping whatever syntax ends up chosen for variadics is nearly as simple to use as tuple splat has been, tuples are (literally) made for this purpose. I&#39;ll be disappointed to see this feature removed.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
