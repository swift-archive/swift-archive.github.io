<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Fwd: Union instead of Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 15, 2016 at 06:00:00pm</p></header><div class="content"><p>for example, there is a method input union of 3 types: A, B, C,<br></p><p>This is the three class.<br></p><p>class A {}<br></p><p>class B {}<br></p><p>class C {}<br></p><p>This is how it implemented under Swift 2:<br></p><p>enum UnionABC {<br>    case classA(A)<br>    case classB(B)<br>    case classC(C)<br>}<br></p><p>func input(value: UnionABC) {<br>    <br>}<br></p><p>let a = A()<br>let b = B()<br>let c = C()<br>input(UnionABC.classA(a))<br></p><p><br>It needs announce all the cases and name each cases and cannot use class names as their case names.<br></p><p>what about using union? It is more easy and rational.<br></p><p><br>func input(value: (A | B | C)) {<br>    <br>}<br></p><p>let a= A()<br>input(a)<br></p><p>Or you can implement it with protocol and extension, but compiler will not know how many cases it should have.<br></p><p><br>protocol UnionABC {<br>    <br>}<br></p><p>extension A: UnionABC {}<br>extension B: UnionABC {}<br>extension C: UnionABC {}<br></p><p><br>func input(value: UnionABC) {<br>    if value is A {<br>        <br>    } else if value is B {<br>        <br>    } else if value is C {<br>        <br>    } else {<br>        // There are other cases? Compiler doesn&#39;t know<br>    }<br>}<br></p><p>let a = A()<br>input(a)<br></p><p><br></p><p>&gt; 下面是被转发的邮件：<br>&gt; <br>&gt; 发件人: frogcjn at 163.com<br>&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt; 日期: 2016年5月15日 GMT+8 18:00:55<br>&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; <br>&gt; <br>&gt; Enum and Union are two things.<br>&gt; <br>&gt; If you use Enum to implement Union, you should announce it with case name.<br>&gt; <br>&gt; Another issue using enum instead of union is that,  union can combine types as many as possible, you just write ( A | B | C ... | Z), but for enum, you should carefully announce it for each case. <br>&gt; <br>&gt; 在 2016年5月15日，15:22，Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; 写道：<br>&gt; <br>&gt;&gt; In addition, not everything in Swift can be modeled in terms of inheritance relationships.<br>&gt;&gt; <br>&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/5bf009e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 16, 2016 at 03:00:00am</p></header><div class="content"><p>This doesn&#39;t explain how I can use &#39;value&#39; once an A() is passed into the<br>function:<br></p><p>func input(value: (A | B | C)) {<br></p><p><br>}<br></p><p>If A, B, and C are not related via protocol or class inheritance, then<br>there is almost nothing you can do with value. Otherwise you still need to<br>test against the concrete type using a case statement or a if-else ladder.<br></p><p>The other &#39;gain&#39; is being able to call &#39;input(A())&#39;, rather than<br>&#39;input(.caseA(A()))&#39;. I agree that the first form is prettier than the<br>second one. I also think you could make the language pervasively prettier<br>and more expressive by allowing for all sorts of implicit conversions. At<br>some point clarity at the point of use beats conciseness, especially when<br>code within a complex codebase needs to be maintained.<br></p><p>I understand that this is largely a matter of style - different people<br>value different things, and that&#39;s wonderful. I welcome a formal proposal<br>submitted to the swift-evolution process, and if one appears I&#39;m happy to<br>consider it in more detail and argue for or against it based on that.<br></p><p>Austin<br></p><p><br></p><p>On Sun, May 15, 2016 at 3:34 AM, Cao Jiannan &lt;frogcjn at 163.com&gt; wrote:<br></p><p>&gt; for example, there is a method input union of 3 types: A, B, C,<br>&gt;<br>&gt; This is the three class.<br>&gt;<br>&gt; class A {}<br>&gt;<br>&gt; class B {}<br>&gt;<br>&gt; class C {}<br>&gt;<br>&gt; This is how it implemented under Swift 2:<br>&gt;<br>&gt; enum UnionABC {<br>&gt;     case classA(A)<br>&gt;     case classB(B)<br>&gt;     case classC(C)<br>&gt; }<br>&gt;<br>&gt; func input(value: UnionABC) {<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; let c = C()<br>&gt; input(UnionABC.classA(a))<br>&gt;<br>&gt;<br>&gt; It needs announce all the cases and name each cases and cannot use class<br>&gt; names as their case names.<br>&gt;<br>&gt; what about using union? It is more easy and rational.<br>&gt;<br>&gt;<br>&gt; func input(value: (A | B | C)) {<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let a= A()<br>&gt; input(a)<br>&gt;<br>&gt; Or you can implement it with protocol and extension, but compiler will not<br>&gt; know how many cases it should have.<br>&gt;<br>&gt;<br>&gt; protocol UnionABC {<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension A: UnionABC {}<br>&gt; extension B: UnionABC {}<br>&gt; extension C: UnionABC {}<br>&gt;<br>&gt;<br>&gt; func input(value: UnionABC) {<br>&gt;     if value is A {<br>&gt;<br>&gt;<br>&gt;     } else if value is B {<br>&gt;<br>&gt;<br>&gt;     } else if value is C {<br>&gt;<br>&gt;<br>&gt;     } else {<br>&gt;         // There are other cases? Compiler doesn&#39;t know<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let a = A()<br>&gt; input(a)<br>&gt;<br>&gt;<br>&gt;<br>&gt; 下面是被转发的邮件：<br>&gt;<br>&gt; *发件人: *frogcjn at 163.com<br>&gt; *主题: **回复： [swift-evolution] Union instead of Optional*<br>&gt; *日期: *2016年5月15日 GMT+8 18:00:55<br>&gt; *收件人: *Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;<br>&gt;<br>&gt; Enum and Union are two things.<br>&gt;<br>&gt; If you use Enum to implement Union, you should announce it with case name.<br>&gt;<br>&gt; Another issue using enum instead of union is that,  union can combine<br>&gt; types as many as possible, you just write ( A | B | C ... | Z), but for<br>&gt; enum, you should carefully announce it for each case.<br>&gt;<br>&gt; 在 2016年5月15日，15:22，Austin Zheng &lt;austinzheng at gmail.com&gt; 写道：<br>&gt;<br>&gt; In addition, not everything in Swift can be modeled in terms of<br>&gt; inheritance relationships.<br>&gt;<br>&gt; I&#39;m a little curious as to why union types keep on coming up, when enums<br>&gt; can do everything they can and much more (methods, constraints on generic<br>&gt; types, conformance to protocols).<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/84a551ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Union instead of Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Consider this case:<br></p><p>class A {<br>    var someCommonProperty: Int = 0<br>}<br>class B {<br>    var someCommonProperty: Int = 0<br>}<br>class C {<br>    var someCommonProperty: Int = 0<br>}<br></p><p>protocol UnionABC {<br>    var someCommonProperty: Int<br>}<br></p><p>extension A: UnionABC {}<br>extension B: UnionABC {}<br>extension C: UnionABC {}<br></p><p><br>===================== If we using protocol<br></p><p><br>func input(value: UnionABC) {<br>    print(value.someCommonProperty) // Compiler will know their common properties automatically.<br>    if value is A {<br>        <br>    } else if value is B {<br>        <br>    } else if value is C {<br>        <br>    } else {<br>        // There are other cases? Compiler doesn&#39;t know<br>    }<br>}<br></p><p>let a = A()<br>input(a)<br></p><p>===================== If we using union<br></p><p>func input(value: (A | B | C)) {<br>    print(value.someCommonProperty) // Compiler will know their common properties automatically.<br></p><p>    if value is A {<br>        <br>    } else if value is B {<br>        <br>    } else if value is C {<br>        <br>    } else {<br>        // There no other cases, so the compiler trigger a warning.<br>    }<br>}<br></p><p>let a = A()<br>input(a)<br></p><p><br>=====================<br></p><p>If using generic enum,<br>the compiler doesn’t know the type relation between generic union with original type.<br>class A and UnionOf3&lt;A,B,C&gt; are totally two different types, has no relationship.<br>But class A and (A | B | C) keeps a relationship.<br></p><p>If using union, these two cases will be allowed:<br></p><p>let a = A()<br>let union: (A|B|C) = a // Automatically wrap.<br></p><p>a == union // Can be compared, Yes<br></p><p>sub-typing: <br></p><p>var fn0: A-&gt;Void = {print(v0)}<br>var fn1: (A|B)-&gt;Void = {print(v0)}<br></p><p>fn0 = fn1 // Original Type and Union Type has a sub-typing relationship, OK<br></p><p>var fn2: (A|B|C)-&gt;Void = {print($0)}<br></p><p>fn0 = fn2 // OK<br>fn1 = fn2 // OK<br></p><p><br>&gt; 在 2016年5月16日，18:17，Austin Zheng &lt;austinzheng at gmail.com&gt; 写道：<br>&gt; <br>&gt; This doesn&#39;t explain how I can use &#39;value&#39; once an A() is passed into the function:<br>&gt; <br>&gt; func input(value: (A | B | C)) {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br>&gt; <br>&gt; The other &#39;gain&#39; is being able to call &#39;input(A())&#39;, rather than &#39;input(.caseA(A()))&#39;. I agree that the first form is prettier than the second one. I also think you could make the language pervasively prettier and more expressive by allowing for all sorts of implicit conversions. At some point clarity at the point of use beats conciseness, especially when code within a complex codebase needs to be maintained.<br>&gt; <br>&gt; I understand that this is largely a matter of style - different people value different things, and that&#39;s wonderful. I welcome a formal proposal submitted to the swift-evolution process, and if one appears I&#39;m happy to consider it in more detail and argue for or against it based on that.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, May 15, 2016 at 3:34 AM, Cao Jiannan &lt;frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;&gt; wrote:<br>&gt; for example, there is a method input union of 3 types: A, B, C,<br>&gt; <br>&gt; This is the three class.<br>&gt; <br>&gt; class A {}<br>&gt; <br>&gt; class B {}<br>&gt; <br>&gt; class C {}<br>&gt; <br>&gt; This is how it implemented under Swift 2:<br>&gt; <br>&gt; enum UnionABC {<br>&gt;     case classA(A)<br>&gt;     case classB(B)<br>&gt;     case classC(C)<br>&gt; }<br>&gt; <br>&gt; func input(value: UnionABC) {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; let c = C()<br>&gt; input(UnionABC.classA(a))<br>&gt; <br>&gt; <br>&gt; It needs announce all the cases and name each cases and cannot use class names as their case names.<br>&gt; <br>&gt; what about using union? It is more easy and rational.<br>&gt; <br>&gt; <br>&gt; func input(value: (A | B | C)) {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let a= A()<br>&gt; input(a)<br>&gt; <br>&gt; Or you can implement it with protocol and extension, but compiler will not know how many cases it should have.<br>&gt; <br>&gt; <br>&gt; protocol UnionABC {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; extension A: UnionABC {}<br>&gt; extension B: UnionABC {}<br>&gt; extension C: UnionABC {}<br>&gt; <br>&gt; <br>&gt; func input(value: UnionABC) {<br>&gt;     if value is A {<br>&gt;         <br>&gt;     } else if value is B {<br>&gt;         <br>&gt;     } else if value is C {<br>&gt;         <br>&gt;     } else {<br>&gt;         // There are other cases? Compiler doesn&#39;t know<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; input(a)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt; <br>&gt;&gt; 发件人: frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;<br>&gt;&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt;&gt; 日期: 2016年5月15日 GMT+8 18:00:55<br>&gt;&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Enum and Union are two things.<br>&gt;&gt; <br>&gt;&gt; If you use Enum to implement Union, you should announce it with case name.<br>&gt;&gt; <br>&gt;&gt; Another issue using enum instead of union is that,  union can combine types as many as possible, you just write ( A | B | C ... | Z), but for enum, you should carefully announce it for each case. <br>&gt;&gt; <br>&gt;&gt; 在 2016年5月15日，15:22，Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt;&gt; In addition, not everything in Swift can be modeled in terms of inheritance relationships.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/7585b68e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 16, 2016 at 03:00:00am</p></header><div class="content"><p>I&#39;m sorry, but I don&#39;t understand the point you are trying to make.<br></p><p>If you pass in a value of type (A | B | C) to a function, what might you want to do with that value?<br></p><p>If you want to do one thing if the value is type A, something else if the value is type B, and something else if the value is type C, then you need to switch or otherwise type check the value at runtime. You can&#39;t get around this, no matter whether you use enums, protocols, generics, or union type.<br></p><p>If you want it to do something that A, B, and C all support, use a generic and/or a protocol. In this case limiting the inputs to only those three types is probably a design smell. The whole point of a shared interface is that it only matters that the interface is properly implemented by a type, not what that type is.<br></p><p>If you don&#39;t care about doing anything with the value, just make your function generic: func&lt;T&gt;(input: T).<br></p><p>Austin<br></p><p><br>&gt; On May 16, 2016, at 3:29 AM, Cao Jiannan &lt;frogcjn at 163.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Consider this case:<br>&gt; <br>&gt; class A {<br>&gt;     var someCommonProperty: Int = 0<br>&gt; }<br>&gt; class B {<br>&gt;     var someCommonProperty: Int = 0<br>&gt; }<br>&gt; class C {<br>&gt;     var someCommonProperty: Int = 0<br>&gt; }<br>&gt; <br>&gt; protocol UnionABC {<br>&gt;     var someCommonProperty: Int<br>&gt; }<br>&gt; <br>&gt; extension A: UnionABC {}<br>&gt; extension B: UnionABC {}<br>&gt; extension C: UnionABC {}<br>&gt; <br>&gt; <br>&gt; ===================== If we using protocol<br>&gt; <br>&gt; <br>&gt; func input(value: UnionABC) {<br>&gt;     print(value.someCommonProperty) // Compiler will know their common properties automatically.<br>&gt;     if value is A {<br>&gt;         <br>&gt;     } else if value is B {<br>&gt;         <br>&gt;     } else if value is C {<br>&gt;         <br>&gt;     } else {<br>&gt;         // There are other cases? Compiler doesn&#39;t know<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; input(a)<br>&gt; <br>&gt; ===================== If we using union<br>&gt; <br>&gt; func input(value: (A | B | C)) {<br>&gt;     print(value.someCommonProperty) // Compiler will know their common properties automatically.<br>&gt; <br>&gt;     if value is A {<br>&gt;         <br>&gt;     } else if value is B {<br>&gt;         <br>&gt;     } else if value is C {<br>&gt;         <br>&gt;     } else {<br>&gt;         // There no other cases, so the compiler trigger a warning.<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; input(a)<br>&gt; <br>&gt; <br>&gt; =====================<br>&gt; <br>&gt; If using generic enum,<br>&gt; the compiler doesn’t know the type relation between generic union with original type.<br>&gt; class A and UnionOf3&lt;A,B,C&gt; are totally two different types, has no relationship.<br>&gt; But class A and (A | B | C) keeps a relationship.<br>&gt; <br>&gt; If using union, these two cases will be allowed:<br>&gt; <br>&gt; let a = A()<br>&gt; let union: (A|B|C) = a // Automatically wrap.<br>&gt; <br>&gt; a == union // Can be compared, Yes<br>&gt; <br>&gt; sub-typing: <br>&gt; <br>&gt; var fn0: A-&gt;Void = {print(v0)}<br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt; <br>&gt; fn0 = fn1 // Original Type and Union Type has a sub-typing relationship, OK<br>&gt; <br>&gt; var fn2: (A|B|C)-&gt;Void = {print($0)}<br>&gt; <br>&gt; fn0 = fn2 // OK<br>&gt; fn1 = fn2 // OK<br>&gt; <br>&gt; <br>&gt;&gt; 在 2016年5月16日，18:17，Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t explain how I can use &#39;value&#39; once an A() is passed into the function:<br>&gt;&gt; <br>&gt;&gt; func input(value: (A | B | C)) {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br>&gt;&gt; <br>&gt;&gt; The other &#39;gain&#39; is being able to call &#39;input(A())&#39;, rather than &#39;input(.caseA(A()))&#39;. I agree that the first form is prettier than the second one. I also think you could make the language pervasively prettier and more expressive by allowing for all sorts of implicit conversions. At some point clarity at the point of use beats conciseness, especially when code within a complex codebase needs to be maintained.<br>&gt;&gt; <br>&gt;&gt; I understand that this is largely a matter of style - different people value different things, and that&#39;s wonderful. I welcome a formal proposal submitted to the swift-evolution process, and if one appears I&#39;m happy to consider it in more detail and argue for or against it based on that.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, May 15, 2016 at 3:34 AM, Cao Jiannan &lt;frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;&gt; wrote:<br>&gt;&gt; for example, there is a method input union of 3 types: A, B, C,<br>&gt;&gt; <br>&gt;&gt; This is the three class.<br>&gt;&gt; <br>&gt;&gt; class A {}<br>&gt;&gt; <br>&gt;&gt; class B {}<br>&gt;&gt; <br>&gt;&gt; class C {}<br>&gt;&gt; <br>&gt;&gt; This is how it implemented under Swift 2:<br>&gt;&gt; <br>&gt;&gt; enum UnionABC {<br>&gt;&gt;     case classA(A)<br>&gt;&gt;     case classB(B)<br>&gt;&gt;     case classC(C)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func input(value: UnionABC) {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = A()<br>&gt;&gt; let b = B()<br>&gt;&gt; let c = C()<br>&gt;&gt; input(UnionABC.classA(a))<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It needs announce all the cases and name each cases and cannot use class names as their case names.<br>&gt;&gt; <br>&gt;&gt; what about using union? It is more easy and rational.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func input(value: (A | B | C)) {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a= A()<br>&gt;&gt; input(a)<br>&gt;&gt; <br>&gt;&gt; Or you can implement it with protocol and extension, but compiler will not know how many cases it should have.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; protocol UnionABC {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A: UnionABC {}<br>&gt;&gt; extension B: UnionABC {}<br>&gt;&gt; extension C: UnionABC {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func input(value: UnionABC) {<br>&gt;&gt;     if value is A {<br>&gt;&gt;         <br>&gt;&gt;     } else if value is B {<br>&gt;&gt;         <br>&gt;&gt;     } else if value is C {<br>&gt;&gt;         <br>&gt;&gt;     } else {<br>&gt;&gt;         // There are other cases? Compiler doesn&#39;t know<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = A()<br>&gt;&gt; input(a)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 发件人: frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;<br>&gt;&gt;&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt;&gt;&gt; 日期: 2016年5月15日 GMT+8 18:00:55<br>&gt;&gt;&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enum and Union are two things.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you use Enum to implement Union, you should announce it with case name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another issue using enum instead of union is that,  union can combine types as many as possible, you just write ( A | B | C ... | Z), but for enum, you should carefully announce it for each case. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 在 2016年5月15日，15:22，Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, not everything in Swift can be modeled in terms of inheritance relationships.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/34993ce4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Union instead of Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Austin,<br></p><p>let me repeat the example so that clarify my point from this example.<br></p><p>protocol cannot do this:<br></p><p>func input(value: ProtocolForABC) {<br>    print(value.someCommonProperty)<br></p><p>    if value is A {<br>        <br>    } else if value is B {<br>        <br>    } else if value is C {<br>        <br>    } else {<br>        // There no other cases, but compiler will not trigger a warning.<br>    }<br>}<br></p><p>The compiler will not know your protocol is only conformed to these three classes.<br>So the else block will not trigger a warning.<br></p><p>- Jiannan<br></p><p><br>&gt; 在 2016年5月16日，18:37，Austin Zheng &lt;austinzheng at gmail.com&gt; 写道：<br>&gt; <br>&gt; I&#39;m sorry, but I don&#39;t understand the point you are trying to make.<br>&gt; <br>&gt; If you pass in a value of type (A | B | C) to a function, what might you want to do with that value?<br>&gt; <br>&gt; If you want to do one thing if the value is type A, something else if the value is type B, and something else if the value is type C, then you need to switch or otherwise type check the value at runtime. You can&#39;t get around this, no matter whether you use enums, protocols, generics, or union type.<br>&gt; <br>&gt; If you want it to do something that A, B, and C all support, use a generic and/or a protocol. In this case limiting the inputs to only those three types is probably a design smell. The whole point of a shared interface is that it only matters that the interface is properly implemented by a type, not what that type is.<br>&gt; <br>&gt; If you don&#39;t care about doing anything with the value, just make your function generic: func&lt;T&gt;(input: T).<br>&gt; <br>&gt; Austin<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/3de15fab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t really get it why the compiler is to complain about the if block not having an else in this case. That seems like a bug that will push us to write unnecessary code. The compiler is not capable of inferring there are more conditions to evaluate in an if statement opposed to a switch statement. Even with the proposed union the compiler cannot infer the need for an else block here because the programmer might not want to do anything else with whatever doesn&#39;t match the first condition.<br></p><p>On the other hand, if you intend to add to this proposal that a switch statement could evaluate the type of the value like the following code, I&#39;d agree with you. I&#39;m just not sure one could do this as of today.<br></p><p>func input(value: (A | B | C)) {<br>   switch value.type {<br>      case A:<br>         ...<br>      case B:<br>         ...<br>      default:<br>         // here the compiler knows I didn&#39;t cover all possible types<br>         // adding &#39;case C&#39; here makes &#39;default&#39; unnecessary<br>   }<br>}<br></p><p>I would add to this discussion if this would be the best syntax for the proposed type. I&#39;d think about &#39;union&lt;A, B, C&gt;&#39; as it matched other existing syntax and is a bit more explicit about what&#39;s going on the code.<br></p><p>&gt; On 16 May 2016, at 7:55 am, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; let me repeat the example so that clarify my point from this example.<br>&gt; <br>&gt; protocol cannot do this:<br>&gt; <br>&gt; func input(value: ProtocolForABC) {<br>&gt;     print(value.someCommonProperty)<br>&gt; <br>&gt;     if value is A {<br>&gt;         <br>&gt;     } else if value is B {<br>&gt;         <br>&gt;     } else if value is C {<br>&gt;         <br>&gt;     } else {<br>&gt;         // There no other cases, but compiler will not trigger a warning.<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The compiler will not know your protocol is only conformed to these three classes.<br>&gt; So the else block will not trigger a warning.<br>&gt; <br>&gt; - Jiannan<br>&gt; <br>&gt; <br>&gt;&gt; 在 2016年5月16日，18:37，Austin Zheng &lt;austinzheng at gmail.com&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; I&#39;m sorry, but I don&#39;t understand the point you are trying to make.<br>&gt;&gt; <br>&gt;&gt; If you pass in a value of type (A | B | C) to a function, what might you want to do with that value?<br>&gt;&gt; <br>&gt;&gt; If you want to do one thing if the value is type A, something else if the value is type B, and something else if the value is type C, then you need to switch or otherwise type check the value at runtime. You can&#39;t get around this, no matter whether you use enums, protocols, generics, or union type.<br>&gt;&gt; <br>&gt;&gt; If you want it to do something that A, B, and C all support, use a generic and/or a protocol. In this case limiting the inputs to only those three types is probably a design smell. The whole point of a shared interface is that it only matters that the interface is properly implemented by a type, not what that type is.<br>&gt;&gt; <br>&gt;&gt; If you don&#39;t care about doing anything with the value, just make your function generic: func&lt;T&gt;(input: T).<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/f08ae38e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br></p><p>I think that a case statement or similar syntax will still be needed, and the case names would just be the types themselves. This would work best with support for type-narrowing, for example:<br></p><p>	func someMethod(value:(A|B|C)) {<br>		switch (value) {<br>			case .A:<br>				value.someMethodForTypeA()<br>			case .B:<br>				value.someMethodForTypeB()<br>			case .C:<br>				value.someMethodForTypeC()<br>		}<br>	}<br></p><p>A union should really just be though of as a lightweight, restricted form of enum that can be declared in a quick ad-hoc fashion, similar to how tuples are a simpler form of struct.<br></p><p>I’m generally a +1 for the feature, but I’d be interested to hear about how well equipped the compiler is for optimising something like this. In most cases an Optional covers what I need, and in more complex cases I’d probably declare overloads for each type (i.e- someMethod(value:A), someMethod(value:B) etc.); unions could make the latter case simpler, but will the compiler produce the same code behind the scenes, i.e- by isolating what’s unique to each type?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 16, 2016 at 03:00:00am</p></header><div class="content"><p>I like the justification of unions as lightweight restricted ad-hoc enums. Definitely agreed with you in that the compiler will have to do more work, and should be able to handle the implicit conversion without going bonkers.<br></p><p>Thanks!<br></p><p>Austin<br></p><p>&gt; On May 16, 2016, at 3:35 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br>&gt; <br>&gt; I think that a case statement or similar syntax will still be needed, and the case names would just be the types themselves. This would work best with support for type-narrowing, for example:<br>&gt; <br>&gt; 	func someMethod(value:(A|B|C)) {<br>&gt; 		switch (value) {<br>&gt; 			case .A:<br>&gt; 				value.someMethodForTypeA()<br>&gt; 			case .B:<br>&gt; 				value.someMethodForTypeB()<br>&gt; 			case .C:<br>&gt; 				value.someMethodForTypeC()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; A union should really just be though of as a lightweight, restricted form of enum that can be declared in a quick ad-hoc fashion, similar to how tuples are a simpler form of struct.<br>&gt; <br>&gt; I’m generally a +1 for the feature, but I’d be interested to hear about how well equipped the compiler is for optimising something like this. In most cases an Optional covers what I need, and in more complex cases I’d probably declare overloads for each type (i.e- someMethod(value:A), someMethod(value:B) etc.); unions could make the latter case simpler, but will the compiler produce the same code behind the scenes, i.e- by isolating what’s unique to each type?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 16, 2016 at 10:00:00am</p></header><div class="content"><p>I can understand this proposal nite and I don&#39;t really think they&#39;re related to enums at all. You can today achieve the very same behaviour using an empty protocol.<br></p><p>protocol P { }<br></p><p>class A : P { }<br>class B : P { }<br>struct C : P { }<br></p><p>func test(value : P) { }<br></p><p>IMO, the proposed syntax will only create a shortcut for this. And we&#39;d still need to test type and cast the to get anything useful. My question now is: is this such a common practice that justifies the shortcut?<br></p><p>-----Original Message-----<br>From: &quot;Haravikk via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎16/‎05/‎2016 07:35 AM<br>To: &quot;Austin Zheng&quot; &lt;austinzheng at gmail.com&gt;<br>Cc: &quot;Adrian Zubarev via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;; &quot;Cao Jiannan&quot; &lt;frogcjn at 163.com&gt;<br>Subject: Re: [swift-evolution] Union instead of Optional<br></p><p><br>&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br></p><p>I think that a case statement or similar syntax will still be needed, and the case names would just be the types themselves. This would work best with support for type-narrowing, for example:<br></p><p>	func someMethod(value:(A|B|C)) {<br>		switch (value) {<br>			case .A:<br>				value.someMethodForTypeA()<br>			case .B:<br>				value.someMethodForTypeB()<br>			case .C:<br>				value.someMethodForTypeC()<br>		}<br>	}<br></p><p>A union should really just be though of as a lightweight, restricted form of enum that can be declared in a quick ad-hoc fashion, similar to how tuples are a simpler form of struct.<br></p><p>I’m generally a +1 for the feature, but I’d be interested to hear about how well equipped the compiler is for optimising something like this. In most cases an Optional covers what I need, and in more complex cases I’d probably declare overloads for each type (i.e- someMethod(value:A), someMethod(value:B) etc.); unions could make the latter case simpler, but will the compiler produce the same code behind the scenes, i.e- by isolating what’s unique to each type?<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/7c4141f4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
