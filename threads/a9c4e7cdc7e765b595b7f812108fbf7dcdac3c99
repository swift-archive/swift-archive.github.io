<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 19, 2016 at 07:00:00am</p></header><div class="content"><p>Hey all,<br></p><p>I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br></p><p>Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br></p><p>let useFoo = true<br></p><p>if useFoo {<br>// Foo code<br>} else {<br>// Non-Foo code<br>}<br></p><p>I will get compiler warnings either way that there’s unreachable code based on the value of useFoo.  That makes sense in most cases, but in some cases I need to leave the code as is for a while, and I hate leaving long-standing compiler warnings in production code.  (If it’s yellow, you need to pay attention to it.)  So I poked around and discovered that if I use the following declaration of useFoo, the warnings go away.<br></p><p>let useFoo = { return true }()<br></p><p>So, the question is, is this intentional? The compiler could certainly ascertain that useFoo will always be true and carry out the same dead code detection as for the first declaration.  If this isn’t intentional, and the compiler may at some point optimize away the closure and trigger dead code warnings, I might come up with a proposal that there is some idiom that allows one to do the above without the warnings.  I’m really not a fan of #define (because it’s just butt-ugly in such a beautiful language), but its existence is unavoidable for some cases.  <br></p><p>And, as I write this, I realized I haven’t tried declaring useFoo as var, but I expect that would trigger a warning that useFoo is not modified and should be defined by let.  I think this is a use case that, for practical purposes, should be covered to allow this type of evolution of code without generating warnings.  If the current behavior is intentional and going to stay, then that’s probably the best solution.<br></p><p>-d<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/a9c43c99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>I find these warning useful at times, annoying at others - like in your case.<br></p><p>I&#39;ve personally come to a solution where I&#39;ve declared a struct that contains these values:<br></p><p>struct Debug {<br>    static let useFoo = true<br>}<br></p><p>if Debug.useFoo {<br>    print(&quot;yes&quot;)<br>} else {<br>    print(&quot;no&quot;)<br>}<br></p><p>I&#39;ve come to realize that this has a huge advantage of keeping all the debugging options together within the entire project and it eliminates any warnings.<br></p><p>&gt; On Oct 19, 2016, at 1:50 PM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt; <br>&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt; <br>&gt; let useFoo = true<br>&gt; <br>&gt; if useFoo {<br>&gt; // Foo code<br>&gt; } else {<br>&gt; // Non-Foo code<br>&gt; }<br>&gt; <br>&gt; I will get compiler warnings either way that there’s unreachable code based on the value of useFoo.  That makes sense in most cases, but in some cases I need to leave the code as is for a while, and I hate leaving long-standing compiler warnings in production code.  (If it’s yellow, you need to pay attention to it.)  So I poked around and discovered that if I use the following declaration of useFoo, the warnings go away.<br>&gt; <br>&gt; let useFoo = { return true }()<br>&gt; <br>&gt; So, the question is, is this intentional? The compiler could certainly ascertain that useFoo will always be true and carry out the same dead code detection as for the first declaration.  If this isn’t intentional, and the compiler may at some point optimize away the closure and trigger dead code warnings, I might come up with a proposal that there is some idiom that allows one to do the above without the warnings.  I’m really not a fan of #define (because it’s just butt-ugly in such a beautiful language), but its existence is unavoidable for some cases.  <br>&gt; <br>&gt; And, as I write this, I realized I haven’t tried declaring useFoo as var, but I expect that would trigger a warning that useFoo is not modified and should be defined by let.  I think this is a use case that, for practical purposes, should be covered to allow this type of evolution of code without generating warnings.  If the current behavior is intentional and going to stay, then that’s probably the best solution.<br>&gt; <br>&gt; -d<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/03ef4884/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 19, 2016 at 08:00:00am</p></header><div class="content"><p>That’s an interesting approach.  My cases tend to be more localized (the let is right before the if), but I can see how the struct approach would be better if the code switching were expected to be more long term, or even permanent.  It still raises the original question whether this is intended or if the compiler just hasn’t gotten to the point of detecting this case as well.<br></p><p>-d<br></p><p><br>&gt; On Oct 19, 2016, at 7:57 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; I find these warning useful at times, annoying at others - like in your case.<br>&gt; <br>&gt; I&#39;ve personally come to a solution where I&#39;ve declared a struct that contains these values:<br>&gt; <br>&gt; struct Debug {<br>&gt;     static let useFoo = true<br>&gt; }<br>&gt; <br>&gt; if Debug.useFoo {<br>&gt;     print(&quot;yes&quot;)<br>&gt; } else {<br>&gt;     print(&quot;no&quot;)<br>&gt; }<br>&gt; <br>&gt; I&#39;ve come to realize that this has a huge advantage of keeping all the debugging options together within the entire project and it eliminates any warnings.<br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 1:50 PM, David Goodine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt;&gt; <br>&gt;&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt;&gt; <br>&gt;&gt; let useFoo = true<br>&gt;&gt; <br>&gt;&gt; if useFoo {<br>&gt;&gt; // Foo code<br>&gt;&gt; } else {<br>&gt;&gt; // Non-Foo code<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I will get compiler warnings either way that there’s unreachable code based on the value of useFoo.  That makes sense in most cases, but in some cases I need to leave the code as is for a while, and I hate leaving long-standing compiler warnings in production code.  (If it’s yellow, you need to pay attention to it.)  So I poked around and discovered that if I use the following declaration of useFoo, the warnings go away.<br>&gt;&gt; <br>&gt;&gt; let useFoo = { return true }()<br>&gt;&gt; <br>&gt;&gt; So, the question is, is this intentional? The compiler could certainly ascertain that useFoo will always be true and carry out the same dead code detection as for the first declaration.  If this isn’t intentional, and the compiler may at some point optimize away the closure and trigger dead code warnings, I might come up with a proposal that there is some idiom that allows one to do the above without the warnings.  I’m really not a fan of #define (because it’s just butt-ugly in such a beautiful language), but its existence is unavoidable for some cases.  <br>&gt;&gt; <br>&gt;&gt; And, as I write this, I realized I haven’t tried declaring useFoo as var, but I expect that would trigger a warning that useFoo is not modified and should be defined by let.  I think this is a use case that, for practical purposes, should be covered to allow this type of evolution of code without generating warnings.  If the current behavior is intentional and going to stay, then that’s probably the best solution.<br>&gt;&gt; <br>&gt;&gt; -d<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/6b4b6a35/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 4:50 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt; <br>&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt; <br>&gt; let useFoo = true<br>&gt; <br>&gt; if useFoo {<br>&gt; // Foo code<br>&gt; } else {<br>&gt; // Non-Foo code<br>&gt; }<br></p><p>In your debugging, do you actually need this condition to be evaluated at runtime?  For example, in the debugger, are you changing the value of useFoo at runtime to switch which branch is used?<br></p><p>If not, maybe #if would be better — it makes the decision at compile time.  I don&#39;t get any warnings from the following code:<br></p><p>let useFoo = true<br></p><p>#if useFoo<br>    print(&quot;foo code&quot;)<br>#else<br>    print(&quot;non-foo code&quot;)<br>#endif<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/fc1c7319/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 9:37 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 4:50 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt;&gt; <br>&gt;&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt;&gt; <br>&gt;&gt; let useFoo = true<br>&gt;&gt; <br>&gt;&gt; if useFoo {<br>&gt;&gt; // Foo code<br>&gt;&gt; } else {<br>&gt;&gt; // Non-Foo code<br>&gt;&gt; }<br>&gt; <br>&gt; In your debugging, do you actually need this condition to be evaluated at runtime?  For example, in the debugger, are you changing the value of useFoo at runtime to switch which branch is used?<br>&gt; <br>&gt; If not, maybe #if would be better — it makes the decision at compile time.  I don&#39;t get any warnings from the following code:<br>&gt; <br>&gt; let useFoo = true<br>&gt; <br>&gt; #if useFoo<br>&gt;     print(&quot;foo code&quot;)<br>&gt; #else<br>&gt;     print(&quot;non-foo code&quot;)<br>&gt; #endif<br></p><p>Sorry, I hit Send too soon.  That listing should read:<br></p><p>#if useFoo<br>    print(&quot;foo code&quot;)<br>#else<br>    print(&quot;non-foo code&quot;)<br>#endif<br></p><p>You switch useFoo on and off by passing &quot;-D useFoo&quot; to the compiler.  For example:<br></p><p>% swift test.swift<br>non-foo code<br></p><p>% swift -D useFoo test.swift<br>foo code<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/cdab6f8e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 5:50 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt; <br>&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt; <br>&gt; let useFoo = true<br>&gt; <br>&gt; if useFoo {<br>&gt; // Foo code<br>&gt; } else {<br>&gt; // Non-Foo code<br>&gt; }<br>&gt; <br>&gt; I will get compiler warnings either way that there’s unreachable code based on the value of useFoo.  That makes sense in most cases, but in some cases I need to leave the code as is for a while, and I hate leaving long-standing compiler warnings in production code.  (If it’s yellow, you need to pay attention to it.)  So I poked around and discovered that if I use the following declaration of useFoo, the warnings go away.<br>&gt; <br>&gt; let useFoo = { return true }()<br>&gt; <br>&gt; So, the question is, is this intentional? The compiler could certainly ascertain that useFoo will always be true and carry out the same dead code detection as for the first declaration.  If this isn’t intentional, and the compiler may at some point optimize away the closure and trigger dead code warnings, I might come up with a proposal that there is some idiom that allows one to do the above without the warnings.  I’m really not a fan of #define (because it’s just butt-ugly in such a beautiful language), but its existence is unavoidable for some cases.  <br>&gt; <br>&gt; And, as I write this, I realized I haven’t tried declaring useFoo as var, but I expect that would trigger a warning that useFoo is not modified and should be defined by let.  I think this is a use case that, for practical purposes, should be covered to allow this type of evolution of code without generating warnings.  If the current behavior is intentional and going to stay, then that’s probably the best solution.<br>&gt; <br>&gt; -d<br></p><p>You should use Active Compilation Conditions to create flags for conditional compilation you can check with #if. If you’re not yet using Xcode 8, you can manually define the flags under the Other Swift Flags build setting (e.g., -DUSEFOO).<br></p><p>Preston<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/e68bb01b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>Constant initialization and unreachable code.</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 19, 2016 at 07:00:00pm</p></header><div class="content"><p>William and Alex, thanks for the reply.  I’m aware of the compile-time option.  My post was originally to ask if the difference between constant and closure initialization for constants was intentional (and likely to remain) or just a temporary idiosyncrasy.  I find #ifdef to be ugly and like prefer to avoid it unless absolutely necessary.  Thanks for the <br>head up on Active Compilation Conditions William, I wasn’t aware of it.  Anything I can do to avoid the Build Settings tab is more than welcome.<br>-d<br></p><p><br>&gt; On Oct 19, 2016, at 1:57 PM, William Sumner &lt;prestonsumner at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 5:50 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; I don’t know if this is really an ‘evolution’ topic per se, and I’m not on Swift Dev, but thought someone here could shed some light on this.<br>&gt;&gt; <br>&gt;&gt; Often when developing code, if I need create mode switches (constant Bools) so that I can move back and forth between different features/implementations for testing, developing experimental features, migration, etc.  Currently if I write the following:<br>&gt;&gt; <br>&gt;&gt; let useFoo = true<br>&gt;&gt; <br>&gt;&gt; if useFoo {<br>&gt;&gt; // Foo code<br>&gt;&gt; } else {<br>&gt;&gt; // Non-Foo code<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I will get compiler warnings either way that there’s unreachable code based on the value of useFoo.  That makes sense in most cases, but in some cases I need to leave the code as is for a while, and I hate leaving long-standing compiler warnings in production code.  (If it’s yellow, you need to pay attention to it.)  So I poked around and discovered that if I use the following declaration of useFoo, the warnings go away.<br>&gt;&gt; <br>&gt;&gt; let useFoo = { return true }()<br>&gt;&gt; <br>&gt;&gt; So, the question is, is this intentional? The compiler could certainly ascertain that useFoo will always be true and carry out the same dead code detection as for the first declaration.  If this isn’t intentional, and the compiler may at some point optimize away the closure and trigger dead code warnings, I might come up with a proposal that there is some idiom that allows one to do the above without the warnings.  I’m really not a fan of #define (because it’s just butt-ugly in such a beautiful language), but its existence is unavoidable for some cases.  <br>&gt;&gt; <br>&gt;&gt; And, as I write this, I realized I haven’t tried declaring useFoo as var, but I expect that would trigger a warning that useFoo is not modified and should be defined by let.  I think this is a use case that, for practical purposes, should be covered to allow this type of evolution of code without generating warnings.  If the current behavior is intentional and going to stay, then that’s probably the best solution.<br>&gt;&gt; <br>&gt;&gt; -d<br>&gt; <br>&gt; You should use Active Compilation Conditions to create flags for conditional compilation you can check with #if. If you’re not yet using Xcode 8, you can manually define the flags under the Other Swift Flags build setting (e.g., -DUSEFOO).<br>&gt; <br>&gt; Preston<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/de22618a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
