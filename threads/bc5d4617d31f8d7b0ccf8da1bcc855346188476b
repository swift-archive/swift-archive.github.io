<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi there!<br></p><p>Considering that I just read that someone wants to have „willGet“, I guess willSet and didSet are here to stay — but for me, the concept has several downsides:<br>- two special keywords<br>- oldValue as another special word (there are some of those, but afaics only self and super are used often)<br>- imho it is not intuitive in which order those methods are called when subclassing<br>… and all those special rules only work for properties.<br></p><p>I think NS_REQUIRES_SUPER (beside the hard name) is much better, because<br>- it works for every method (I guess everyone knows some classes in Cocoa where the docs say you must call super, but the compiler cannot enforce this)<br>- order of execution is clear<br>- it is easy to block a change, instead of doing a rollback in „didSet“<br></p><p>The only advantage of willSet/didSet is that it is easy to create a stored property and be notified when it is changed, without the need to create an additional field — but I think it wouldn’t be that bad to just write „super.property = value“, even if there is no superclass as backing store: It may appear odd, but shouldn’t cause any problems.<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 05:00:00am</p></header><div class="content"><p>&gt; The only advantage of willSet/didSet is that it is easy to create a stored property and be notified when it is changed, without the need to create an additional field — but I think it wouldn’t be that bad to just write „super.property = value“, even if there is no superclass as backing store: It may appear odd, but shouldn’t cause any problems.<br></p><p>It *is* odd, and I do the described didSet trick *all* the time.<br></p><p>Stuff like:<br></p><p>public class MyView: UIView {<br></p><p>  public var foo: Int {<br>    didSet {<br>      setNeedsDisplay()<br>    }<br>  }<br></p><p>  // ... ditto for 10 more properties ...<br></p><p>}<br></p><p>I would not appreciate that code getting any longer. It&#39;s such a relief after what I had to write in Objective-C!<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 15, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt; <br>&gt; Stuff like:<br>The alternative wouldn’t be that complicated:<br></p><p>public class MyView: UIView {<br>	public var foo: Int {<br>		set(value) {<br>			super.foo = value<br>			setNeedsDisplay()<br>		}<br>	}<br>}<br></p><p>It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>I’m not sure I understand your example. `super` is a reference to the superclass implementation of `foo`, but `UIView` doesn’t declare a property called `foo`. <br></p><p>Jack<br></p><p>&gt; On Dec 14, 2015, at 11:23 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt;&gt; <br>&gt;&gt; Stuff like:<br>&gt; The alternative wouldn’t be that complicated:<br>&gt; <br>&gt; public class MyView: UIView {<br>&gt; 	public var foo: Int {<br>&gt; 		set(value) {<br>&gt; 			super.foo = value<br>&gt; 			setNeedsDisplay()<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; I’m not sure I understand your example. `super` is a reference to the superclass implementation of `foo`, but `UIView` doesn’t declare a property called `foo`. <br>It’s quite simple: „super“ is just a string that can have a special meaning for the tokenizer, and normally, we read it as „please do what the class I’m inheriting from would do“ — but you could as well interpret it as „do what would happen if my implementation didn’t exist“, which has a slightly wider scope.<br></p><p>In the old dark ages, when properties with todays comfort didn’t exist, the only thing we could do was declare a pair of methods to read and write a field. Those are boring, but under the hood, they are still there, lurking in a dark thin layer in the hierarchy of inheritance.<br>Of course, the method that actually copies the bytes of class Bs instance variable „foo“ doesn’t belong to Bs parent A, so with the narrow interpretation of super, there is no way to utilize the nifty helper method that is created for us: When we write our custom accessor for foo, it is overwritten, and there is no path to reach it… unless we add our setter in subclass C, where Bs syntax problem disappears, and „super.foo“ connects us to those helper methods.<br></p><p>The alternative to subclassing is creating a backing field, just like old Objective-C did, and even a young language like Kotlin has something similar (afaik it is more secure, and $foo only exists in foos accessor). Swift, on the other hand, shirks the problem by introducing of a whole set of new keywords that aren’t useful anywhere else.<br></p><p>Guess I should have started this small discussion coming from the other direction: Seems I just created refusal by „attacking“ a tiny useful feature, instead of writing about the benefits that NS_REQUIRES_SUPER has to offer in the first place, and reach the conclusion that it can make existing constructs obsolete when everyone is thrilled about the potential advantages… so, maybe we could forget about the subject of this message and argue about the pros and cons of that cool attribute? ;-)<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/265868676ac8f12472cc3cc0fc59d827?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Nicky Gerritsen</string> &lt;nickygerritsen at me.com&gt;<p>December 15, 2015 at 08:00:00am</p></header><div class="content"><p>But how does this work if `super` does not have `foo`, exactly like in <br>this example? UIView does not have a member named `foo`, so it will not <br>work.<br>Moreover, currently if creating a setter, you also need to supply a getter.<br></p><p>Regards,<br></p><p>Nicky<br></p><p>On 12/15/2015 08:23 AM, Tino Heth via swift-evolution wrote:<br>&gt;&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt;&gt;<br>&gt;&gt; Stuff like:<br>&gt; The alternative wouldn’t be that complicated:<br>&gt;<br>&gt; public class MyView: UIView {<br>&gt; 	public var foo: Int {<br>&gt; 		set(value) {<br>&gt; 			super.foo = value<br>&gt; 			setNeedsDisplay()<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt;<br>&gt; It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December 15, 2015 at 09:00:00am</p></header><div class="content"><p>I&#39;m -1 on that, willSet and didSet are great tools for performing side effects (such as locking, for example). It was a major problem in Objective-C, as no easy solution (except overriding accessors) existed and still you&#39;d have to write a lot of boilerplate code.<br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Nicky Gerritsen via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 15.12.2015, o godz. 08:50:<br>&gt; <br>&gt; But how does this work if `super` does not have `foo`, exactly like in this example? UIView does not have a member named `foo`, so it will not work.<br>&gt; Moreover, currently if creating a setter, you also need to supply a getter.<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Nicky<br>&gt; <br>&gt; On 12/15/2015 08:23 AM, Tino Heth via swift-evolution wrote:<br>&gt;&gt;&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stuff like:<br>&gt;&gt; The alternative wouldn’t be that complicated:<br>&gt;&gt; <br>&gt;&gt; public class MyView: UIView {<br>&gt;&gt; 	public var foo: Int {<br>&gt;&gt; 		set(value) {<br>&gt;&gt; 			super.foo = value<br>&gt;&gt; 			setNeedsDisplay()<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/a686f143/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 15, 2015 at 08:00:00am</p></header><div class="content"><p>I think the below proposal also tries to pave over the difference between will and didSet, which are both important. In addition to unclear use of super.foo.<br></p><p>&gt; On Dec 15, 2015, at 12:57 AM, Adrian Kashivskyy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m -1 on that, willSet and didSet are great tools for performing side effects (such as locking, for example). It was a major problem in Objective-C, as no easy solution (except overriding accessors) existed and still you&#39;d have to write a lot of boilerplate code.<br>&gt; <br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomość napisana przez Nicky Gerritsen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 15.12.2015, o godz. 08:50:<br>&gt;&gt; <br>&gt;&gt; But how does this work if `super` does not have `foo`, exactly like in this example? UIView does not have a member named `foo`, so it will not work.<br>&gt;&gt; Moreover, currently if creating a setter, you also need to supply a getter.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; <br>&gt;&gt; Nicky<br>&gt;&gt; <br>&gt;&gt; On 12/15/2015 08:23 AM, Tino Heth via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stuff like:<br>&gt;&gt;&gt; The alternative wouldn’t be that complicated:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class MyView: UIView {<br>&gt;&gt;&gt; 	public var foo: Int {<br>&gt;&gt;&gt; 		set(value) {<br>&gt;&gt;&gt; 			super.foo = value<br>&gt;&gt;&gt; 			setNeedsDisplay()<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/f843351c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Getting rid of willSet/didSet</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 1:23 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; It *is* odd, and I do the described didSet trick *all* the time.<br>&gt;&gt; <br>&gt;&gt; Stuff like:<br>&gt; The alternative wouldn’t be that complicated:<br>&gt; <br>&gt; public class MyView: UIView {<br>&gt; 	public var foo: Int {<br>&gt; 		set(value) {<br>&gt; 			super.foo = value<br>&gt; 			setNeedsDisplay()<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; It’s just one line more, but three(!) keywords less that could be removed from the language; and I bet in the wild there are many thousand errors in subclasses of UIViewController that happen because the author didn’t remember wether he has to call super in viewDid…, loadView etc.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-1 on this. As others have mentioned, willSet and didSet are extremely useful, and the above is a misuse of “super”, misleading the reader to suppose that UIView implements “foo”, when it does not.<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
