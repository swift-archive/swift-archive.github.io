<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>I was inspired to put together a draft proposal based on an older<br>discussion in the Universal Equality, Hashability, and Comparability thread<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that<br>recently got necromanced (thanks Mark Sands!).<br></p><p>I&#39;m guessing that this would be a significant enough change that it&#39;s not<br>possible for the Swift 3 timeline, but it&#39;s something that would benefit<br>enough people that I want to make sure the discussion stays alive. If there<br>are enough good feelings about it, I&#39;ll move it from my gist into an actual<br>proposal PR.<br></p><p>Automatically deriving Equatable andHashable for value types<br></p><p>   - Proposal: SE-0000<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>   - Author(s): Tony Allevato &lt;https://github.com/allevato&gt;<br>   - Status: Awaiting review<br>   &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#rationale&gt;<br>   - Review manager: TBD<br></p><p>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#introduction&gt;<br>Introduction<br></p><p>Value types are prevalent throughout the Swift language, and we encourage<br>developers to think in those terms when writing their own types.<br>Frequently, developers find themselves writing large amounts of boilerplate<br>code to support equatability and hashability of value types. This proposal<br>offers a way for the compiler to automatically derive conformance to<br>Equatable and Hashable to reduce this boilerplate, in a subset of scenarios<br>where generating the correct implementation is likely to be possible.<br></p><p>Swift-evolution thread: Universal Equatability, Hashability, and<br>Comparability &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919&gt;<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#motivation&gt;<br>Motivation<br></p><p>Building robust value types in Swift can involve writing significant<br>boilerplate code to support concepts of hashability and equatability.<br>Equality is pervasive across many value types, and for each one users must<br>implement the == operator such that it performs a fairly rote memberwise<br>equality test. As an example, an equality test for a struct looks fairly<br>uninteresting:<br></p><p>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>  return lhs.property1 == rhs.property1 &amp;&amp;<br>         lhs.property2 == rhs.property2 &amp;&amp;<br>         lhs.property3 == rhs.property3 &amp;&amp;<br>         ...<br>}<br></p><p>What&#39;s worse is that this operator must be updated if any properties are<br>added, removed, or changed, and since it must be manually written, it&#39;s<br>possible to get it wrong, either by omission or typographical error.<br></p><p>Likewise, hashability is necessary when one wishes to store a value type in<br>a Set or use one as a multi-valuedDictionary key. Writing high-quality,<br>well-distributed hash functions is not trivial so developers may not put a<br>great deal of thought into them – especially as the number of properties<br>increases – not realizing that their performance could potentially suffer<br>as a result. And as with equality, writing it manually means there is the<br>potential to get it wrong.<br></p><p>In particular, the code that must be written to implement equality for<br>enums is quite verbose. One such real-world example (source<br>&lt;https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189&gt;<br>):<br></p><p>func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool {<br>  switch (lhs, rhs) {<br>  case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank<br>, let rSuit)):<br>    return lRank == rRank &amp;&amp; lSuit == rSuit<br>  case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let rFour)):<br>    return lFour == rFour<br>  case (.fullHouse(three: let lThree), .fullHouse(three: let rThree)):<br>    return lThree == rThree<br>  case (.flush(let lRank, let lSuit), .flush(let rRank, let rSuit)):<br>    return lSuit == rSuit &amp;&amp; lRank == rRank<br>  case (.straight(high: let lRank), .straight(high: let rRank)):<br>    return lRank == rRank<br>  case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let rRank)):<br>    return lRank == rRank<br>  case (.twoPair(high: let lHigh, low: let lLow, highCard: let lCard),<br>        .twoPair(high: let rHigh, low: let rLow, highCard: let rCard)):<br>    return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard == rCard<br>  case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2,<br>card3: let lCard3),<br>        .onePair(let rPairRank, card1: let rCard1, card2: let rCard2,<br>card3: let rCard3)):<br>    return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 ==<br>rCard2 &amp;&amp; lCard3 == rCard3<br>  case (.highCard(let lCard), .highCard(let rCard)):<br>    return lCard == rCard<br>  default:<br>    return false<br>  }<br>}<br></p><p>Crafting a high-quality hash function for this enum would be similarly<br>inconvenient to write, involving another large switchstatement.<br></p><p>Swift already provides implicit protocol conformance in some cases;<br>notably, enums with raw values conform toRawRepresentable, Equatable, and<br>Hashable without the user explicitly declaring them:<br></p><p>enum Foo: Int {<br>  case one = 1<br>  case two = 2<br>}<br>let x = (Foo.one == Foo.two)  // workslet y = Foo.one.hashValue     //<br>also workslet z = Foo.one.rawValue      // also also works<br></p><p>Since there is precedent for this in Swift, we propose extending this<br>support to more value types.<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#proposed-solution&gt;Proposed<br>solution<br></p><p>We propose that a value type be Equatable/Hashable if all of its members are<br> Equatable/Hashable, with the result for the outer type being composed from<br>its members.<br></p><p>Specifically, we propose the following rules for deriving Equatable:<br></p><p>   -<br></p><p>   A struct implicitly conforms to Equatable if all of its fields are of<br>   types that conform to Equatable – either explicitly, or implicitly by<br>   the application of these rules. The compiler will generate an<br>   implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x<br>   == rhs.x for all fields x in T.<br>   -<br></p><p>   An enum implicitly conforms to Equatable if all of its associated values<br>   across all of its cases are of types that conform to Equatable – either<br>   explicitly, or implicitly by the application of these rules. The compiler<br>   will generate an implementation of ==(lhs: T, rhs: T) that returns true<br>   if and only if lhs and rhs are the same case and have payloads that are<br>   memberwise-equal.<br></p><p>Likewise, we propose the following rules for deriving Hashable:<br></p><p>   -<br></p><p>   A struct implicitly conforms to Hashable if all of its fields are of<br>   types that conform to Hashable – either explicitly, or implicitly by the<br>   application of these rules. The compiler will generate an implementation of<br>    hashValue that uses a pre-defined hash function† to compute the hash<br>   value of the struct from the hash values of its members.<br></p><p>   Since order of the terms affects the hash value computation, we<br>   recommend ordering the terms in member definition order.<br>   -<br></p><p>   An enum implicitly conforms to Hashable if all of its associated values<br>   across all of its cases are of types that conform to Hashable – either<br>   explicitly, or implicitly by the application of these rules. The compiler<br>   will generate an implementation of hashValue that uses a pre-defined<br>   hash function† to compute the hash value of an enum value by using the<br>   case&#39;s ordinal (i.e., definition order) followed by the hash values of its<br>   associated values as its terms, also in definition order.<br></p><p>† We leave the exact definition of the hash function unspecified here; a<br>multiplicative hash function such as Kernighan and Ritchie or Bernstein is<br>easy to implement, but we do not rule out other possibilities.<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#overriding-defaults&gt;Overriding<br>defaults<br></p><p>Any user-provided implementations of == or hashValue should override the<br>default implementations that would be provided by the compiler. This is<br>already possible today with raw-value enums so the same behavior should be<br>extended to other value types that are made to implicitly conform to these<br>protocols.<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#open-questions&gt;Open<br>questions<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#omission-of-fields-from-generated-computations&gt;Omission<br>of fields from generated computations<br></p><p>Should it be possible to easily omit certain properties from automatically<br>generated equality tests or hash value computation? This could be valuable,<br>for example, if a property is merely used as an internal cache and does not<br>actually contribute to the &quot;value&quot; of the instance. Under the rules above,<br>if this cached value was equatable, a user would have to override == and<br>hashValue and provide their own implementations to ignore it. If there is<br>significant evidence that this pattern is common and useful, we could<br>consider adding a custom attribute, such as @transient, that would omit the<br>property from the generated computations.<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#explicit-or-implicit-derivation&gt;Explicit<br>or implicit derivation<br></p><p>As with raw-value enums today, should the derived conformance be completely<br>explicit, or should users have to explicitly list conformance with Equatable<br> and Hashable in order for the compiler to generate the derived<br>implementation?<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>This change will have no impact on existing code because it is purely<br>additive. Value types that already provide custom implementations of == or<br>hashValue but satisfy the rules above would keep the custom implementation<br>because it would override the compiler-provided default.<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#alternatives-considered&gt;Alternatives<br>considered<br></p><p>The original discussion thread also included Comparable as a candidate for<br>automatic generation. Unlike equatability and hashability, however,<br>comparability requires an ordering among the members being compared.<br>Automatically using the definition order here might be too surprising for<br>users, but worse, it also means that reordering properties in the source<br>code changes the code&#39;s behavior at runtime. (This is true for hashability<br>as well if a multiplicative hash function is used, but hash values are not<br>intended to be persistent and reordering the terms does not produce a<br>significant *behavioral* change.)<br>&lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#acknowledgments&gt;<br>Acknowledgments<br></p><p>Thanks to Joe Groff for spinning off the original discussion thread, Jose<br>Cheyo Jimenez for providing great real-world examples of boilerplate needed<br>to support equatability for some value types, and to Mark Sands for<br>necromancing the swift-evolution thread that convinced me to write this up.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/aa57482d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Omission of fields from generated computations<br>&gt; <br>&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br></p><p>A word of warning: an earlier proposal on memberwise initializers ran aground because it tried to annotate properties to tell the compiler which ones should be included in the generated initializer. It was ultimately judged too complex a solution for the specialized problem space it was trying to tackle.<br></p><p>In other words, Keep It Simple, Stupid. &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 25, 2016, at 8:08 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Omission of fields from generated computations<br>&gt;&gt; <br>&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; <br>&gt; A word of warning: an earlier proposal on memberwise initializers ran aground because it tried to annotate properties to tell the compiler which ones should be included in the generated initializer. It was ultimately judged too complex a solution for the specialized problem space it was trying to tackle.<br></p><p>That&#39;s not entirely true.  The solution the core team was leaning towards in their feedback also included property annotations.  The proposal was deferred because a lot of new ideas were discussed during the review period and our understanding of the design space was refined.  By the end of the review not even I was convinced that the proposal as written was the right long term solution.<br></p><p>If we&#39;re going to derive automatic Equatable and Hashable implementations it is necessary to exclude certain members.  We can talk about strategies for doing that, and possibly for minimizing cases where the annotations are used, but we need some kind of control.  <br></p><p>The common case where annotations will be required is likely to be for a small number of members relative to those contributing to Equatable and Hashable.  An annotation or two are much better than writing out manual implementations.  They also scale nicely if we are able to derive implementations of other protocols in the future.<br></p><p>&gt; <br>&gt; In other words, Keep It Simple, Stupid. &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 05:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 26, 2016, at 3:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 25, 2016, at 8:08 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; <br>&gt;&gt; A word of warning: an earlier proposal on memberwise initializers ran aground because it tried to annotate properties to tell the compiler which ones should be included in the generated initializer. It was ultimately judged too complex a solution for the specialized problem space it was trying to tackle.<br>&gt; <br>&gt; That&#39;s not entirely true.  The solution the core team was leaning towards in their feedback also included property annotations.  The proposal was deferred because a lot of new ideas were discussed during the review period and our understanding of the design space was refined.  By the end of the review not even I was convinced that the proposal as written was the right long term solution.<br>&gt; <br>&gt; If we&#39;re going to derive automatic Equatable and Hashable implementations it is necessary to exclude certain members.  We can talk about strategies for doing that, and possibly for minimizing cases where the annotations are used, but we need some kind of control.  <br>&gt; <br>&gt; The common case where annotations will be required is likely to be for a small number of members relative to those contributing to Equatable and Hashable.  An annotation or two are much better than writing out manual implementations.  They also scale nicely if we are able to derive implementations of other protocols in the future.<br>&gt; <br></p><p>There are existing precedents that even show what the code looks like... and it is not bad at all.<br></p><p><br>&gt;&gt; <br>&gt;&gt; In other words, Keep It Simple, Stupid. &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 04:00:00am</p></header><div class="content"><p>On May 26, 2016, at 3:08 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Omission of fields from generated computations<br>&gt;&gt; <br>&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; <br>&gt; A word of warning: an earlier proposal on memberwise initializers ran aground because it tried to annotate properties to tell the compiler which ones should be included in the generated initializer. It was ultimately judged too complex a solution for the specialized problem space it was trying to tackle.<br>&gt; <br></p><p>Can&#39;t fathom how one would not see the difference in complexity between the initializer proposals (untainable as they were proposed) and how simple it is to discriminate during generation of identity. Not to mention the other reasons why initializer generation could be turned down.<br></p><p>&gt; In other words, Keep It Simple, Stupid. &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Mark Sands</string> &lt;marksands07 at gmail.com&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Thanks so much for putting this together, Tony! Glad I was able to be some<br>inspiration. :^)<br></p><p><br>On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was inspired to put together a draft proposal based on an older<br>&gt; discussion in the Universal Equality, Hashability, and Comparability thread<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that<br>&gt; recently got necromanced (thanks Mark Sands!).<br>&gt;<br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not<br>&gt; possible for the Swift 3 timeline, but it&#39;s something that would benefit<br>&gt; enough people that I want to make sure the discussion stays alive. If there<br>&gt; are enough good feelings about it, I&#39;ll move it from my gist into an actual<br>&gt; proposal PR.<br>&gt;<br>&gt; Automatically deriving Equatable andHashable for value types<br>&gt;<br>&gt;    - Proposal: SE-0000<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author(s): Tony Allevato &lt;https://github.com/allevato&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#rationale&gt;<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Value types are prevalent throughout the Swift language, and we encourage<br>&gt; developers to think in those terms when writing their own types.<br>&gt; Frequently, developers find themselves writing large amounts of boilerplate<br>&gt; code to support equatability and hashability of value types. This proposal<br>&gt; offers a way for the compiler to automatically derive conformance to<br>&gt; Equatable and Hashable to reduce this boilerplate, in a subset of<br>&gt; scenarios where generating the correct implementation is likely to be<br>&gt; possible.<br>&gt;<br>&gt; Swift-evolution thread: Universal Equatability, Hashability, and<br>&gt; Comparability<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Building robust value types in Swift can involve writing significant<br>&gt; boilerplate code to support concepts of hashability and equatability.<br>&gt; Equality is pervasive across many value types, and for each one users must<br>&gt; implement the == operator such that it performs a fairly rote memberwise<br>&gt; equality test. As an example, an equality test for a struct looks fairly<br>&gt; uninteresting:<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;   return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;          lhs.property2 == rhs.property2 &amp;&amp;<br>&gt;          lhs.property3 == rhs.property3 &amp;&amp;<br>&gt;          ...<br>&gt; }<br>&gt;<br>&gt; What&#39;s worse is that this operator must be updated if any properties are<br>&gt; added, removed, or changed, and since it must be manually written, it&#39;s<br>&gt; possible to get it wrong, either by omission or typographical error.<br>&gt;<br>&gt; Likewise, hashability is necessary when one wishes to store a value type<br>&gt; in a Set or use one as a multi-valuedDictionary key. Writing<br>&gt; high-quality, well-distributed hash functions is not trivial so developers<br>&gt; may not put a great deal of thought into them – especially as the number of<br>&gt; properties increases – not realizing that their performance could<br>&gt; potentially suffer as a result. And as with equality, writing it manually<br>&gt; means there is the potential to get it wrong.<br>&gt;<br>&gt; In particular, the code that must be written to implement equality for<br>&gt; enums is quite verbose. One such real-world example (source<br>&gt; &lt;https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189&gt;<br>&gt; ):<br>&gt;<br>&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool {<br>&gt;   switch (lhs, rhs) {<br>&gt;   case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let rSuit)):<br>&gt;     return lRank == rRank &amp;&amp; lSuit == rSuit<br>&gt;   case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let rFour)):<br>&gt;     return lFour == rFour<br>&gt;   case (.fullHouse(three: let lThree), .fullHouse(three: let rThree)):<br>&gt;     return lThree == rThree<br>&gt;   case (.flush(let lRank, let lSuit), .flush(let rRank, let rSuit)):<br>&gt;     return lSuit == rSuit &amp;&amp; lRank == rRank<br>&gt;   case (.straight(high: let lRank), .straight(high: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.twoPair(high: let lHigh, low: let lLow, highCard: let lCard),<br>&gt;         .twoPair(high: let rHigh, low: let rLow, highCard: let rCard)):<br>&gt;     return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard == rCard<br>&gt;   case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let lCard3),<br>&gt;         .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let rCard3)):<br>&gt;     return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 == rCard3<br>&gt;   case (.highCard(let lCard), .highCard(let rCard)):<br>&gt;     return lCard == rCard<br>&gt;   default:<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Crafting a high-quality hash function for this enum would be similarly<br>&gt; inconvenient to write, involving another large switchstatement.<br>&gt;<br>&gt; Swift already provides implicit protocol conformance in some cases;<br>&gt; notably, enums with raw values conform toRawRepresentable, Equatable, and<br>&gt; Hashable without the user explicitly declaring them:<br>&gt;<br>&gt; enum Foo: Int {<br>&gt;   case one = 1<br>&gt;   case two = 2<br>&gt; }<br>&gt; let x = (Foo.one == Foo.two)  // workslet y = Foo.one.hashValue     // also workslet z = Foo.one.rawValue      // also also works<br>&gt;<br>&gt; Since there is precedent for this in Swift, we propose extending this<br>&gt; support to more value types.<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; We propose that a value type be Equatable/Hashable if all of its members<br>&gt; are Equatable/Hashable, with the result for the outer type being composed<br>&gt; from its members.<br>&gt;<br>&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    A struct implicitly conforms to Equatable if all of its fields are of<br>&gt;    types that conform to Equatable – either explicitly, or implicitly by<br>&gt;    the application of these rules. The compiler will generate an<br>&gt;    implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x<br>&gt;    == rhs.x for all fields x in T.<br>&gt;    -<br>&gt;<br>&gt;    An enum implicitly conforms to Equatable if all of its associated<br>&gt;    values across all of its cases are of types that conform to Equatable –<br>&gt;    either explicitly, or implicitly by the application of these rules. The<br>&gt;    compiler will generate an implementation of ==(lhs: T, rhs: T) that<br>&gt;    returns true if and only if lhs and rhs are the same case and have<br>&gt;    payloads that are memberwise-equal.<br>&gt;<br>&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    A struct implicitly conforms to Hashable if all of its fields are of<br>&gt;    types that conform to Hashable – either explicitly, or implicitly by<br>&gt;    the application of these rules. The compiler will generate an<br>&gt;    implementation of hashValue that uses a pre-defined hash function† to<br>&gt;    compute the hash value of the struct from the hash values of its members.<br>&gt;<br>&gt;    Since order of the terms affects the hash value computation, we<br>&gt;    recommend ordering the terms in member definition order.<br>&gt;    -<br>&gt;<br>&gt;    An enum implicitly conforms to Hashable if all of its associated<br>&gt;    values across all of its cases are of types that conform to Hashable –<br>&gt;    either explicitly, or implicitly by the application of these rules. The<br>&gt;    compiler will generate an implementation of hashValue that uses a<br>&gt;    pre-defined hash function† to compute the hash value of an enum value<br>&gt;    by using the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;    values of its associated values as its terms, also in definition order.<br>&gt;<br>&gt; † We leave the exact definition of the hash function unspecified here; a<br>&gt; multiplicative hash function such as Kernighan and Ritchie or Bernstein is<br>&gt; easy to implement, but we do not rule out other possibilities.<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#overriding-defaults&gt;Overriding<br>&gt; defaults<br>&gt;<br>&gt; Any user-provided implementations of == or hashValue should override the<br>&gt; default implementations that would be provided by the compiler. This is<br>&gt; already possible today with raw-value enums so the same behavior should be<br>&gt; extended to other value types that are made to implicitly conform to these<br>&gt; protocols.<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#open-questions&gt;Open<br>&gt; questions<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#omission-of-fields-from-generated-computations&gt;Omission<br>&gt; of fields from generated computations<br>&gt;<br>&gt; Should it be possible to easily omit certain properties from automatically<br>&gt; generated equality tests or hash value computation? This could be valuable,<br>&gt; for example, if a property is merely used as an internal cache and does not<br>&gt; actually contribute to the &quot;value&quot; of the instance. Under the rules above,<br>&gt; if this cached value was equatable, a user would have to override == and<br>&gt; hashValue and provide their own implementations to ignore it. If there is<br>&gt; significant evidence that this pattern is common and useful, we could<br>&gt; consider adding a custom attribute, such as @transient, that would omit<br>&gt; the property from the generated computations.<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#explicit-or-implicit-derivation&gt;Explicit<br>&gt; or implicit derivation<br>&gt;<br>&gt; As with raw-value enums today, should the derived conformance be<br>&gt; completely explicit, or should users have to explicitly list conformance<br>&gt; with Equatable and Hashable in order for the compiler to generate the<br>&gt; derived implementation?<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This change will have no impact on existing code because it is purely<br>&gt; additive. Value types that already provide custom implementations of == or<br>&gt;  hashValue but satisfy the rules above would keep the custom<br>&gt; implementation because it would override the compiler-provided default.<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The original discussion thread also included Comparable as a candidate<br>&gt; for automatic generation. Unlike equatability and hashability, however,<br>&gt; comparability requires an ordering among the members being compared.<br>&gt; Automatically using the definition order here might be too surprising for<br>&gt; users, but worse, it also means that reordering properties in the source<br>&gt; code changes the code&#39;s behavior at runtime. (This is true for hashability<br>&gt; as well if a multiplicative hash function is used, but hash values are not<br>&gt; intended to be persistent and reordering the terms does not produce a<br>&gt; significant *behavioral* change.)<br>&gt;<br>&gt; &lt;https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad#acknowledgments&gt;<br>&gt; Acknowledgments<br>&gt;<br>&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose<br>&gt; Cheyo Jimenez for providing great real-world examples of boilerplate needed<br>&gt; to support equatability for some value types, and to Mark Sands for<br>&gt; necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/d5ede3ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br></p><p>struct Polygon deriving Equatable, Hashable {<br>    ...<br>}<br></p><p>This has several advantages:<br>- you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>- Deriving becomes an explicit choice.<br>- If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>- It doesn&#39;t break any code that is unaware of the change<br>- It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>- It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>- It is proven to work in production.<br></p><p>-Michael<br></p><p>&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt; <br>&gt; <br>&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; <br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt; <br>&gt; Automatically deriving Equatable andHashable for value types<br>&gt; <br>&gt; 	• Proposal: SE-0000<br>&gt; 	• Author(s): Tony Allevato<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt; <br>&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;  {<br>&gt;   <br>&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt; <br>&gt;          lhs<br>&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt; <br>&gt;          lhs<br>&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt; <br>&gt;          <br>&gt; ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt; <br>&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt; <br>&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt; <br>&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;  {<br>&gt;   <br>&gt; switch<br>&gt;  (lhs, rhs) {<br>&gt;   <br>&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;  rSuit)):<br>&gt;     <br>&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;  rSuit<br>&gt;   <br>&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;  rFour)):<br>&gt;     <br>&gt; return lFour ==<br>&gt;  rFour<br>&gt;   <br>&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;  rThree)):<br>&gt;     <br>&gt; return lThree ==<br>&gt;  rThree<br>&gt;   <br>&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;  rSuit)):<br>&gt;     <br>&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;  rRank<br>&gt;   <br>&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;  rRank)):<br>&gt;     <br>&gt; return lRank ==<br>&gt;  rRank<br>&gt;   <br>&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;  rRank)):<br>&gt;     <br>&gt; return lRank ==<br>&gt;  rRank<br>&gt;   <br>&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;  lCard),<br>&gt;         <br>&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;  rCard)):<br>&gt;     <br>&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;  rCard<br>&gt;   <br>&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;  lCard3),<br>&gt;         <br>&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;  rCard3)):<br>&gt;     <br>&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;  rCard3<br>&gt;   <br>&gt; case (.highCard(let lCard), .highCard(let<br>&gt;  rCard)):<br>&gt;     <br>&gt; return lCard ==<br>&gt;  rCard<br>&gt;   <br>&gt; default<br>&gt; :<br>&gt;     <br>&gt; return false<br>&gt; <br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt; <br>&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt; <br>&gt; enum Foo: Int<br>&gt;  {<br>&gt;   <br>&gt; case one = 1<br>&gt; <br>&gt;   <br>&gt; case two = 2<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; let x = (Foo.one == Foo.two)  // works<br>&gt; let y = Foo.one.hashValue     // also works<br>&gt; let z = Foo.one.rawValue      // also also works<br>&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt; <br>&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt; <br>&gt; 	• A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt; <br>&gt; 	• An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt; <br>&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt; <br>&gt; 	• A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt; <br>&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt; <br>&gt; 	• An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt; <br>&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt; <br>&gt; Overriding defaults<br>&gt; <br>&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt; <br>&gt; Open questions<br>&gt; <br>&gt; Omission of fields from generated computations<br>&gt; <br>&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; <br>&gt; Explicit or implicit derivation<br>&gt; <br>&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt; <br>&gt; Acknowledgments<br>&gt; <br>&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 26, 2016 at 09:00:00am</p></header><div class="content"><p>+1 to a `deriving` keyword<br></p><p>On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our<br>&gt; own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable`<br>&gt; would become<br>&gt;<br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be<br>&gt; automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason),<br>&gt; you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any<br>&gt; new incompatibilities. For example, `CustomStringConvertible` could be<br>&gt; derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt; Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if<br>&gt; `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not<br>&gt; used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something<br>&gt; in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this<br>&gt; produces an error.)<br>&gt; - It is proven to work in production.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be<br>&gt; some inspiration. :^)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I was inspired to put together a draft proposal based on an older<br>&gt; discussion in the Universal Equality, Hashability, and Comparability thread<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that<br>&gt; recently got necromanced (thanks Mark Sands!).<br>&gt; &gt;<br>&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s<br>&gt; not possible for the Swift 3 timeline, but it&#39;s something that would<br>&gt; benefit enough people that I want to make sure the discussion stays alive.<br>&gt; If there are enough good feelings about it, I&#39;ll move it from my gist into<br>&gt; an actual proposal PR.<br>&gt; &gt;<br>&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt; &gt;<br>&gt; &gt;       • Proposal: SE-0000<br>&gt; &gt;       • Author(s): Tony Allevato<br>&gt; &gt;       • Status: Awaiting review<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; Value types are prevalent throughout the Swift language, and we<br>&gt; encourage developers to think in those terms when writing their own types.<br>&gt; Frequently, developers find themselves writing large amounts of boilerplate<br>&gt; code to support equatability and hashability of value types. This proposal<br>&gt; offers a way for the compiler to automatically derive conformance<br>&gt; toEquatable and Hashable to reduce this boilerplate, in a subset of<br>&gt; scenarios where generating the correct implementation is likely to be<br>&gt; possible.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and<br>&gt; Comparability<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Building robust value types in Swift can involve writing significant<br>&gt; boilerplate code to support concepts of hashability and equatability.<br>&gt; Equality is pervasive across many value types, and for each one users must<br>&gt; implement the == operator such that it performs a fairly rote memberwise<br>&gt; equality test. As an example, an equality test for a struct looks fairly<br>&gt; uninteresting:<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are<br>&gt; added, removed, or changed, and since it must be manually written, it&#39;s<br>&gt; possible to get it wrong, either by omission or typographical error.<br>&gt; &gt;<br>&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type<br>&gt; in a Set or use one as a multi-valuedDictionary key. Writing high-quality,<br>&gt; well-distributed hash functions is not trivial so developers may not put a<br>&gt; great deal of thought into them – especially as the number of properties<br>&gt; increases – not realizing that their performance could potentially suffer<br>&gt; as a result. And as with equality, writing it manually means there is the<br>&gt; potential to get it wrong.<br>&gt; &gt;<br>&gt; &gt; In particular, the code that must be written to implement equality for<br>&gt; enums is quite verbose. One such real-world example (source):<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; switch<br>&gt; &gt;  (lhs, rhs) {<br>&gt; &gt;<br>&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank ,<br>&gt; let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt; &gt;  rSuit<br>&gt; &gt;<br>&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt; &gt;  rFour)):<br>&gt; &gt;<br>&gt; &gt; return lFour ==<br>&gt; &gt;  rFour<br>&gt; &gt;<br>&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt; &gt;  rThree)):<br>&gt; &gt;<br>&gt; &gt; return lThree ==<br>&gt; &gt;  rThree<br>&gt; &gt;<br>&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt; &gt;  lCard),<br>&gt; &gt;<br>&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2,<br>&gt; card3: let<br>&gt; &gt;  lCard3),<br>&gt; &gt;<br>&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt; &gt;  rCard3)):<br>&gt; &gt;<br>&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp;<br>&gt; lCard3 ==<br>&gt; &gt;  rCard3<br>&gt; &gt;<br>&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; default<br>&gt; &gt; :<br>&gt; &gt;<br>&gt; &gt; return false<br>&gt; &gt;<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Crafting a high-quality hash function for this enum would be similarly<br>&gt; inconvenient to write, involving another large switchstatement.<br>&gt; &gt;<br>&gt; &gt; Swift already provides implicit protocol conformance in some cases;<br>&gt; notably, enums with raw values conform toRawRepresentable, Equatable, and<br>&gt; Hashable without the user explicitly declaring them:<br>&gt; &gt;<br>&gt; &gt; enum Foo: Int<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; case one = 1<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; case two = 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt; &gt; Since there is precedent for this in Swift, we propose extending this<br>&gt; support to more value types.<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members<br>&gt; are Equatable/Hashable, with the result for the outer type being composed<br>&gt; from its members.<br>&gt; &gt;<br>&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields<br>&gt; are of types that conform to Equatable – either explicitly, or implicitly<br>&gt; by the application of these rules. The compiler will generate an<br>&gt; implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x<br>&gt; == rhs.x for all fields x in T.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Equatable if all of its<br>&gt; associated values across all of its cases are of types that conform to<br>&gt; Equatable – either explicitly, or implicitly by the application of these<br>&gt; rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)<br>&gt; that returns true if and only if lhs and rhs are the same case and have<br>&gt; payloads that are memberwise-equal.<br>&gt; &gt;<br>&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields<br>&gt; are of types that conform to Hashable – either explicitly, or implicitly by<br>&gt; the application of these rules. The compiler will generate an<br>&gt; implementation of hashValue that uses a pre-defined hash function† to<br>&gt; compute the hash value of the struct from the hash values of its members.<br>&gt; &gt;<br>&gt; &gt; Since order of the terms affects the hash value computation, we<br>&gt; recommend ordering the terms in member definition order.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated<br>&gt; values across all of its cases are of types that conform to Hashable –<br>&gt; either explicitly, or implicitly by the application of these rules. The<br>&gt; compiler will generate an implementation of hashValue that uses a<br>&gt; pre-defined hash function† to compute the hash value of an enum value by<br>&gt; using the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt; values of its associated values as its terms, also in definition order.<br>&gt; &gt;<br>&gt; &gt; † We leave the exact definition of the hash function unspecified here; a<br>&gt; multiplicative hash function such as Kernighan and Ritchie or Bernstein is<br>&gt; easy to implement, but we do not rule out other possibilities.<br>&gt; &gt;<br>&gt; &gt; Overriding defaults<br>&gt; &gt;<br>&gt; &gt; Any user-provided implementations of == or hashValue should override the<br>&gt; default implementations that would be provided by the compiler. This is<br>&gt; already possible today with raw-value enums so the same behavior should be<br>&gt; extended to other value types that are made to implicitly conform to these<br>&gt; protocols.<br>&gt; &gt;<br>&gt; &gt; Open questions<br>&gt; &gt;<br>&gt; &gt; Omission of fields from generated computations<br>&gt; &gt;<br>&gt; &gt; Should it be possible to easily omit certain properties from<br>&gt; automatically generated equality tests or hash value computation? This<br>&gt; could be valuable, for example, if a property is merely used as an internal<br>&gt; cache and does not actually contribute to the &quot;value&quot; of the instance.<br>&gt; Under the rules above, if this cached value was equatable, a user would<br>&gt; have to override == and hashValue and provide their own implementations to<br>&gt; ignore it. If there is significant evidence that this pattern is common and<br>&gt; useful, we could consider adding a custom attribute, such as @transient,<br>&gt; that would omit the property from the generated computations.<br>&gt; &gt;<br>&gt; &gt; Explicit or implicit derivation<br>&gt; &gt;<br>&gt; &gt; As with raw-value enums today, should the derived conformance be<br>&gt; completely explicit, or should users have to explicitly list conformance<br>&gt; with Equatable and Hashable in order for the compiler to generate the<br>&gt; derived implementation?<br>&gt; &gt;<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; This change will have no impact on existing code because it is purely<br>&gt; additive. Value types that already provide custom implementations of == or<br>&gt; hashValue but satisfy the rules above would keep the custom implementation<br>&gt; because it would override the compiler-provided default.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; The original discussion thread also included Comparable as a candidate<br>&gt; for automatic generation. Unlike equatability and hashability, however,<br>&gt; comparability requires an ordering among the members being compared.<br>&gt; Automatically using the definition order here might be too surprising for<br>&gt; users, but worse, it also means that reordering properties in the source<br>&gt; code changes the code&#39;s behavior at runtime. (This is true for hashability<br>&gt; as well if a multiplicative hash function is used, but hash values are not<br>&gt; intended to be persistent and reordering the terms does not produce a<br>&gt; significant behavioral change.)<br>&gt; &gt;<br>&gt; &gt; Acknowledgments<br>&gt; &gt;<br>&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread,<br>&gt; Jose Cheyo Jimenez for providing great real-world examples of boilerplate<br>&gt; needed to support equatability for some value types, and to Mark Sands for<br>&gt; necromancing the swift-evolution thread that convinced me to write this up.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/ef9a258b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to a `deriving` keyword<br></p><p>+ 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br></p><p>This bullet makes me uncomfortable though:<br></p><p>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br></p><p><br>You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br></p><p>extension Shape deriving Equatable where T: Equatable {}<br></p><p>Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br></p><p>&gt; <br>&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt; <br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt; - It is proven to work in production.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; &gt;<br>&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt; &gt;<br>&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt; &gt;<br>&gt; &gt;       • Proposal: SE-0000<br>&gt; &gt;       • Author(s): Tony Allevato<br>&gt; &gt;       • Status: Awaiting review<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt; &gt;<br>&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt; &gt;<br>&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; switch<br>&gt; &gt;  (lhs, rhs) {<br>&gt; &gt;<br>&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt; &gt;  rSuit<br>&gt; &gt;<br>&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt; &gt;  rFour)):<br>&gt; &gt;<br>&gt; &gt; return lFour ==<br>&gt; &gt;  rFour<br>&gt; &gt;<br>&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt; &gt;  rThree)):<br>&gt; &gt;<br>&gt; &gt; return lThree ==<br>&gt; &gt;  rThree<br>&gt; &gt;<br>&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt; &gt;  lCard),<br>&gt; &gt;<br>&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt; &gt;  lCard3),<br>&gt; &gt;<br>&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt; &gt;  rCard3)):<br>&gt; &gt;<br>&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt; &gt;  rCard3<br>&gt; &gt;<br>&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; default<br>&gt; &gt; :<br>&gt; &gt;<br>&gt; &gt; return false<br>&gt; &gt;<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt; &gt;<br>&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt; &gt;<br>&gt; &gt; enum Foo: Int<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; case one = 1<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; case two = 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt; &gt;<br>&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt; &gt;<br>&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt; &gt;<br>&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt; &gt;<br>&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt; &gt;<br>&gt; &gt; Overriding defaults<br>&gt; &gt;<br>&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt; &gt;<br>&gt; &gt; Open questions<br>&gt; &gt;<br>&gt; &gt; Omission of fields from generated computations<br>&gt; &gt;<br>&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; &gt;<br>&gt; &gt; Explicit or implicit derivation<br>&gt; &gt;<br>&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt; &gt;<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt; &gt;<br>&gt; &gt; Acknowledgments<br>&gt; &gt;<br>&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/5ee7180b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 26.05.2016 um 17:35 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to a `deriving` keyword<br>&gt; <br>&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt; <br>&gt; This bullet makes me uncomfortable though:<br>&gt; <br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt; <br>&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt; <br>&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt; <br>&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br></p><p>I agree that this might be a problem that needs some consideration. The difference in Haskell is that type declarations are usually very short, e.g.<br></p><p>    data Maybe a = Nothing | Just a deriving (Eq, Ord)<br></p><p>and to any sane reader it is obvious, that if `a` is not in `Eq`, then `Maybe a` is not in `Eq` as well. Having to write something like<br></p><p>    data Maybe a = Nothing | Just a deriving ({Eq where Eq a}, {Ord where Ord a})<br></p><p>would produce no benefit. The situation is a bit different in Swift, because type declarations are usually much larger. On the other hand, Generics are less important in Swift than they are in Haskell, so having a slightly more awkward syntax when using it in a generic way is not that bad. Maybe we could say<br></p><p>    struct Shape&lt;T&gt; deriving Eq? { ... }<br></p><p>and the &quot;?&quot; after Eq means &quot;if possible&quot;? To opt-in for &quot;derive if you can&quot; behavior? However, I would like to see an example where the &quot;derive if you can&quot; behavior would lead to problems / confusing language semantics. I&#39;m not saying that there is no such example, I just cannot think of one currently. The worst that can happen is that the developer is surprised that a particular type is not equatable, even though he has &quot;derived&quot; an Equatable &quot;instance&quot;. He will find out at compile time I guess, and Stackoverflow will have the answer (&quot;swift deriving doesn&#39;t work&quot;). But still, the question is also how obvious the requirements for a type are for `deriving Equatable` to work well.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>I get this sense that everyone is foxussing on the how, without having clearly defined the what. And this is not the first time I see a lot of great ideas flaring about how to convey a given syntax, without reading a proper definition of the concept.<br></p><p>&gt; On May 26, 2016, at 6:15 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 17:35 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt; <br>&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt; <br>&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt; <br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well.<br>&gt;&gt; <br>&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt; <br>&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt; <br>&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt; <br>&gt; I agree that this might be a problem that needs some consideration. The difference in Haskell is that type declarations are usually very short, e.g.<br>&gt; <br>&gt;    data Maybe a = Nothing | Just a deriving (Eq, Ord)<br>&gt; <br>&gt; and to any sane reader it is obvious, that if `a` is not in `Eq`, then `Maybe a` is not in `Eq` as well. Having to write something like<br>&gt; <br>&gt;    data Maybe a = Nothing | Just a deriving ({Eq where Eq a}, {Ord where Ord a})<br>&gt; <br>&gt; would produce no benefit. The situation is a bit different in Swift, because type declarations are usually much larger. On the other hand, Generics are less important in Swift than they are in Haskell, so having a slightly more awkward syntax when using it in a generic way is not that bad. Maybe we could say<br>&gt; <br>&gt;    struct Shape&lt;T&gt; deriving Eq? { ... }<br>&gt; <br>&gt; and the &quot;?&quot; after Eq means &quot;if possible&quot;? To opt-in for &quot;derive if you can&quot; behavior? However, I would like to see an example where the &quot;derive if you can&quot; behavior would lead to problems / confusing language semantics. I&#39;m not saying that there is no such example, I just cannot think of one currently. The worst that can happen is that the developer is surprised that a particular type is not equatable, even though he has &quot;derived&quot; an Equatable &quot;instance&quot;. He will find out at compile time I guess, and Stackoverflow will have the answer (&quot;swift deriving doesn&#39;t work&quot;). But still, the question is also how obvious the requirements for a type are for `deriving Equatable` to work well.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br></p><p><br>&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to a `deriving` keyword<br>&gt; <br>&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt; <br>&gt; This bullet makes me uncomfortable though:<br>&gt; <br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt; <br>&gt; <br>&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt; <br>&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt; <br>&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt; <br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt; &gt; Introduction<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; switch<br>&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt; &gt;  rSuit<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt; &gt;  rFour)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lFour ==<br>&gt;&gt; &gt;  rFour<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt; &gt;  rThree)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lThree ==<br>&gt;&gt; &gt;  rThree<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt; &gt;  lCard),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt; &gt;  lCard3),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt; &gt;  rCard3)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt; &gt;  rCard3<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; default<br>&gt;&gt; &gt; :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return false<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case one = 1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case two = 2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposed solution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Overriding defaults<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Open questions<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Impact on existing code<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Acknowledgments<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/134d55d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 12:48 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br></p><p>Yes.  It would also be bad if implicit synthesis resulted in an unintentional and incorrect definition of equality.  By requiring synthesis to be requested with `deriving` the programmer is at least prompted to consider the meaning of equality for their type.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt; <br>&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt; <br>&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt; <br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt; <br>&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt; <br>&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/3da314ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Inline<br></p><p><br>&gt; On May 27, 2016, at 2:52 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:48 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br>&gt; <br>&gt; Yes.  It would also be bad if implicit synthesis resulted in an unintentional and incorrect definition of equality.  By requiring synthesis to be requested with `deriving` the programmer is at least prompted to consider the meaning of equality for their type.<br></p><p>Incorrect definition of equality? Hmm... :-)<br></p><p>I guess I have been running under the wrong assumption that if a struct uses values that are all Equatable then the default implementation for the struct which will compare the values against the values in the other struct will ALWAYS be correct. But I guess I can come up with an example where some of the values stored in the struct do not play a role in the definition of equality even if those values are Equatable. Then the default implementation would be incorrect. <br></p><p>But I am not convince that is bad because   that can happen regardless of whether equatable is an opt-in thing or automatic. For example, let&#39;s say you opt-in by saying that it implements Equatable or by using the derived / synthesizes keyword that we have mentioned. The developer may not realize until later that the default implementation would be wrong for your fancy/unusual struct.  It is likely that opting in may raise a flag in your brain that says &quot;hey, is the default implementation going to do the right thing? Do you need to customize it for your struct?&quot; But it&#39;s not a guarantee either. And if it&#39;s not a guarantee then should it be automatic then? Most developer will go with the default implementation when they opt-in and then realize later that they may need to customize when things are not working quite the way the expected. <br></p><p><br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2ff7c891/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 3:22 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; <br>&gt; On May 27, 2016, at 2:52 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 12:48 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br>&gt;&gt; <br>&gt;&gt; Yes.  It would also be bad if implicit synthesis resulted in an unintentional and incorrect definition of equality.  By requiring synthesis to be requested with `deriving` the programmer is at least prompted to consider the meaning of equality for their type.<br>&gt; <br>&gt; Incorrect definition of equality? Hmm... :-)<br>&gt; <br>&gt; I guess I have been running under the wrong assumption that if a struct uses values that are all Equatable then the default implementation for the struct which will compare the values against the values in the other struct will ALWAYS be correct. But I guess I can come up with an example where some of the values stored in the struct do not play a role in the definition of equality even if those values are Equatable. Then the default implementation would be incorrect. <br>&gt; <br>&gt; But I am not convince that is bad because   that can happen regardless of whether equatable is an opt-in thing or automatic. For example, let&#39;s say you opt-in by saying that it implements Equatable or by using the derived / synthesizes keyword that we have mentioned. The developer may not realize until later that the default implementation would be wrong for your fancy/unusual struct.  It is likely that opting in may raise a flag in your brain that says &quot;hey, is the default implementation going to do the right thing? Do you need to customize it for your struct?&quot; But it&#39;s not a guarantee either. And if it&#39;s not a guarantee then should it be automatic then?<br></p><p>No, I don’t think so.  Opting in localizes any errors and also prompts the developer to consider what the synthesized implementation will do.<br></p><p>&gt; Most developer will go with the default implementation when they opt-in and then realize later that they may need to customize when things are not working quite the way the expected. <br></p><p>This is exactly why opting in is the right way to go.  It may not prevent all developers from such mistakes, but it might help some, especially those who understand the issues involved but may *forget* to consider the issues if they don’t have to type `deriving Equatable, Hashable`.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2fa64203/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 3:22 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; <br>&gt; On May 27, 2016, at 2:52 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 12:48 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br>&gt;&gt; <br>&gt;&gt; Yes.  It would also be bad if implicit synthesis resulted in an unintentional and incorrect definition of equality.  By requiring synthesis to be requested with `deriving` the programmer is at least prompted to consider the meaning of equality for their type.<br>&gt; <br>&gt; Incorrect definition of equality? Hmm... :-)<br>&gt; <br>&gt; I guess I have been running under the wrong assumption that if a struct uses values that are all Equatable then the default implementation for the struct which will compare the values against the values in the other struct will ALWAYS be correct. But I guess I can come up with an example where some of the values stored in the struct do not play a role in the definition of equality even if those values are Equatable. Then the default implementation would be incorrect. <br></p><p>A recent one for me was a rational type, e.g. you’d want things like `1/2 == 2/4` (and in this case I didn’t want an implementation that *would* always automatically use fully-reduced internal representations).<br></p><p>I *do* think Swift is missing a “bit-by-bit/physical&quot; equality operator (for which 1/2 and 2/4 would be distinct, here), and Swift should probably get one at some point, but that’s IMHO another (but related) discussion.<br></p><p>&gt; But I am not convince that is bad because   that can happen regardless of whether equatable is an opt-in thing or automatic. For example, let&#39;s say you opt-in by saying that it implements Equatable or by using the derived / synthesizes keyword that we have mentioned. The developer may not realize until later that the default implementation would be wrong for your fancy/unusual struct.  It is likely that opting in may raise a flag in your brain that says &quot;hey, is the default implementation going to do the right thing? Do you need to customize it for your struct?&quot; But it&#39;s not a guarantee either. And if it&#39;s not a guarantee then should it be automatic then? Most developer will go with the default implementation when they opt-in and then realize later that they may need to customize when things are not working quite the way the expected. <br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/413c5540/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 5:07 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	<br>&gt;&gt; On May 27, 2016, at 3:22 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Inline<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 2:52 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 12:48 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we get the error when trying to use it?  For example, if a struct uses a value that is not Equatable / Hashable then it would not be Equatable / Hashable and you would not find out until you tried to use it.  Would that be bad?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.  It would also be bad if implicit synthesis resulted in an unintentional and incorrect definition of equality.  By requiring synthesis to be requested with `deriving` the programmer is at least prompted to consider the meaning of equality for their type.<br>&gt;&gt; <br>&gt;&gt; Incorrect definition of equality? Hmm... :-)<br>&gt;&gt; <br>&gt;&gt; I guess I have been running under the wrong assumption that if a struct uses values that are all Equatable then the default implementation for the struct which will compare the values against the values in the other struct will ALWAYS be correct. But I guess I can come up with an example where some of the values stored in the struct do not play a role in the definition of equality even if those values are Equatable. Then the default implementation would be incorrect. <br>&gt; <br>&gt; A recent one for me was a rational type, e.g. you’d want things like `1/2 == 2/4` (and in this case I didn’t want an implementation that *would* always automatically use fully-reduced internal representations).<br></p><p>It’s a bit of a tangent, but you might want to take a look at John Lakos’ discussion of rational equality in the talk Dave A posted a link to.  There are subtle differences in behavior (overflow, etc) between 1/2 and 2/4.  They are not actually substitutable when you have bounded integer types.  John makes some interesting observations on this topic.<br></p><p>&gt; <br>&gt; I *do* think Swift is missing a “bit-by-bit/physical&quot; equality operator (for which 1/2 and 2/4 would be distinct, here), and Swift should probably get one at some point, but that’s IMHO another (but related) discussion.<br>&gt; <br>&gt;&gt; But I am not convince that is bad because   that can happen regardless of whether equatable is an opt-in thing or automatic. For example, let&#39;s say you opt-in by saying that it implements Equatable or by using the derived / synthesizes keyword that we have mentioned. The developer may not realize until later that the default implementation would be wrong for your fancy/unusual struct.  It is likely that opting in may raise a flag in your brain that says &quot;hey, is the default implementation going to do the right thing? Do you need to customize it for your struct?&quot; But it&#39;s not a guarantee either. And if it&#39;s not a guarantee then should it be automatic then? Most developer will go with the default implementation when they opt-in and then realize later that they may need to customize when things are not working quite the way the expected. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 11:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 10:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + 1.  I like it as well.  It makes the feature opt-in, declaring conformance and requesting synthesis at the same time.  The syntactic difference from a simple conformance declaration means manual conformance can still be checked properly with no ambiguity about whether you were requesting synthesis or not.  This approach also generalizes well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This bullet makes me uncomfortable though:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You should not be able to just say `struct Shape&lt;T&gt; deriving Equatable`.  You should have to do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Shape deriving Equatable where T: Equatable {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or some equivalent syntax that makes it clear that you only intend to derive equatable when T meets the stated conditions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/05f9308a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>what i care about is to have a choice about what DEFINES the identity of my values, not just an all-or-nothing situation.<br></p><p>&gt; On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to a `deriving` keyword<br>&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt; <br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt; &gt; Introduction<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; switch<br>&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt; &gt;  rSuit<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt; &gt;  rFour)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lFour ==<br>&gt;&gt; &gt;  rFour<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt; &gt;  rThree)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lThree ==<br>&gt;&gt; &gt;  rThree<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt; &gt;  lCard),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt; &gt;  lCard3),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt; &gt;  rCard3)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt; &gt;  rCard3<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; default<br>&gt;&gt; &gt; :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return false<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case one = 1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case two = 2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposed solution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Overriding defaults<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Open questions<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Impact on existing code<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Acknowledgments<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/c506f6a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 12:20 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; what i care about is to have a choice about what DEFINES the identity of my values, not just an all-or-nothing situation.<br></p><p>I&#39;m sure nobody would object if you offers suggestions.<br></p><p>I have some thoughts I am considering on this but am not ready to share them just yet.<br></p><p>&gt; <br>&gt;&gt; On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/defab74a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>all-or-nothing situation. If you want to define equality/hashability for<br>your type manually, don&#39;t use `deriving`. This should leave the simplest<br>cases to auto generation and anything more complex should be handled by the<br>developer.<br></p><p>On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic &lt;<br>laurent.mihalkovic at gmail.com&gt; wrote:<br></p><p>&gt; what i care about is to have a choice about what DEFINES the identity of<br>&gt; my values, not just an all-or-nothing situation.<br>&gt;<br>&gt; On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 to a `deriving` keyword<br>&gt;<br>&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our<br>&gt;&gt; own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable`<br>&gt;&gt; would become<br>&gt;&gt;<br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be<br>&gt;&gt; automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason),<br>&gt;&gt; you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any<br>&gt;&gt; new incompatibilities. For example, `CustomStringConvertible` could be<br>&gt;&gt; derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt; Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if<br>&gt;&gt; `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not<br>&gt;&gt; used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something<br>&gt;&gt; in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this<br>&gt;&gt; produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt;<br>&gt;&gt; -Michael<br>&gt;&gt;<br>&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be<br>&gt;&gt; some inspiration. :^)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older<br>&gt;&gt; discussion in the Universal Equality, Hashability, and Comparability thread<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that<br>&gt;&gt; recently got necromanced (thanks Mark Sands!).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s<br>&gt;&gt; not possible for the Swift 3 timeline, but it&#39;s something that would<br>&gt;&gt; benefit enough people that I want to make sure the discussion stays alive.<br>&gt;&gt; If there are enough good feelings about it, I&#39;ll move it from my gist into<br>&gt;&gt; an actual proposal PR.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt; &gt; Introduction<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we<br>&gt;&gt; encourage developers to think in those terms when writing their own types.<br>&gt;&gt; Frequently, developers find themselves writing large amounts of boilerplate<br>&gt;&gt; code to support equatability and hashability of value types. This proposal<br>&gt;&gt; offers a way for the compiler to automatically derive conformance<br>&gt;&gt; toEquatable and Hashable to reduce this boilerplate, in a subset of<br>&gt;&gt; scenarios where generating the correct implementation is likely to be<br>&gt;&gt; possible.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and<br>&gt;&gt; Comparability<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Building robust value types in Swift can involve writing significant<br>&gt;&gt; boilerplate code to support concepts of hashability and equatability.<br>&gt;&gt; Equality is pervasive across many value types, and for each one users must<br>&gt;&gt; implement the == operator such that it performs a fairly rote memberwise<br>&gt;&gt; equality test. As an example, an equality test for a struct looks fairly<br>&gt;&gt; uninteresting:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties<br>&gt;&gt; are added, removed, or changed, and since it must be manually written, it&#39;s<br>&gt;&gt; possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value<br>&gt;&gt; type in a Set or use one as a multi-valuedDictionary key. Writing<br>&gt;&gt; high-quality, well-distributed hash functions is not trivial so developers<br>&gt;&gt; may not put a great deal of thought into them – especially as the number of<br>&gt;&gt; properties increases – not realizing that their performance could<br>&gt;&gt; potentially suffer as a result. And as with equality, writing it manually<br>&gt;&gt; means there is the potential to get it wrong.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, the code that must be written to implement equality for<br>&gt;&gt; enums is quite verbose. One such real-world example (source):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; switch<br>&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank ,<br>&gt;&gt; let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt; &gt;  rSuit<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt; &gt;  rFour)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lFour ==<br>&gt;&gt; &gt;  rFour<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt; &gt;  rThree)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lThree ==<br>&gt;&gt; &gt;  rThree<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt; &gt;  lCard),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2,<br>&gt;&gt; card3: let<br>&gt;&gt; &gt;  lCard3),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt; &gt;  rCard3)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2<br>&gt;&gt; &amp;&amp; lCard3 ==<br>&gt;&gt; &gt;  rCard3<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; default<br>&gt;&gt; &gt; :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return false<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly<br>&gt;&gt; inconvenient to write, involving another large switchstatement.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases;<br>&gt;&gt; notably, enums with raw values conform toRawRepresentable, Equatable, and<br>&gt;&gt; Hashable without the user explicitly declaring them:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case one = 1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case two = 2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this<br>&gt;&gt; support to more value types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposed solution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its<br>&gt;&gt; members are Equatable/Hashable, with the result for the outer type being<br>&gt;&gt; composed from its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields<br>&gt;&gt; are of types that conform to Equatable – either explicitly, or implicitly<br>&gt;&gt; by the application of these rules. The compiler will generate an<br>&gt;&gt; implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x<br>&gt;&gt; == rhs.x for all fields x in T.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its<br>&gt;&gt; associated values across all of its cases are of types that conform to<br>&gt;&gt; Equatable – either explicitly, or implicitly by the application of these<br>&gt;&gt; rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)<br>&gt;&gt; that returns true if and only if lhs and rhs are the same case and have<br>&gt;&gt; payloads that are memberwise-equal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields<br>&gt;&gt; are of types that conform to Hashable – either explicitly, or implicitly by<br>&gt;&gt; the application of these rules. The compiler will generate an<br>&gt;&gt; implementation of hashValue that uses a pre-defined hash function† to<br>&gt;&gt; compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Since order of the terms affects the hash value computation, we<br>&gt;&gt; recommend ordering the terms in member definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its<br>&gt;&gt; associated values across all of its cases are of types that conform to<br>&gt;&gt; Hashable – either explicitly, or implicitly by the application of these<br>&gt;&gt; rules. The compiler will generate an implementation of hashValue that uses<br>&gt;&gt; a pre-defined hash function† to compute the hash value of an enum value by<br>&gt;&gt; using the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;&gt; values of its associated values as its terms, also in definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here;<br>&gt;&gt; a multiplicative hash function such as Kernighan and Ritchie or Bernstein<br>&gt;&gt; is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Overriding defaults<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override<br>&gt;&gt; the default implementations that would be provided by the compiler. This is<br>&gt;&gt; already possible today with raw-value enums so the same behavior should be<br>&gt;&gt; extended to other value types that are made to implicitly conform to these<br>&gt;&gt; protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Open questions<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Should it be possible to easily omit certain properties from<br>&gt;&gt; automatically generated equality tests or hash value computation? This<br>&gt;&gt; could be valuable, for example, if a property is merely used as an internal<br>&gt;&gt; cache and does not actually contribute to the &quot;value&quot; of the instance.<br>&gt;&gt; Under the rules above, if this cached value was equatable, a user would<br>&gt;&gt; have to override == and hashValue and provide their own implementations to<br>&gt;&gt; ignore it. If there is significant evidence that this pattern is common and<br>&gt;&gt; useful, we could consider adding a custom attribute, such as @transient,<br>&gt;&gt; that would omit the property from the generated computations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be<br>&gt;&gt; completely explicit, or should users have to explicitly list conformance<br>&gt;&gt; with Equatable and Hashable in order for the compiler to generate the<br>&gt;&gt; derived implementation?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Impact on existing code<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This change will have no impact on existing code because it is purely<br>&gt;&gt; additive. Value types that already provide custom implementations of == or<br>&gt;&gt; hashValue but satisfy the rules above would keep the custom implementation<br>&gt;&gt; because it would override the compiler-provided default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate<br>&gt;&gt; for automatic generation. Unlike equatability and hashability, however,<br>&gt;&gt; comparability requires an ordering among the members being compared.<br>&gt;&gt; Automatically using the definition order here might be too surprising for<br>&gt;&gt; users, but worse, it also means that reordering properties in the source<br>&gt;&gt; code changes the code&#39;s behavior at runtime. (This is true for hashability<br>&gt;&gt; as well if a multiplicative hash function is used, but hash values are not<br>&gt;&gt; intended to be persistent and reordering the terms does not produce a<br>&gt;&gt; significant behavioral change.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Acknowledgments<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread,<br>&gt;&gt; Jose Cheyo Jimenez for providing great real-world examples of boilerplate<br>&gt;&gt; needed to support equatability for some value types, and to Mark Sands for<br>&gt;&gt; necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/2c96e57f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an all-or-nothing situation. If you want to define equality/hashability for your type manually, don&#39;t use `deriving`. This should leave the simplest cases to auto generation and anything more complex should be handled by the developer.<br></p><p>It’s all-or-nothing in the sense you can’t use a naive `deriving` implementation to assist in any case where what you need is *almost* the trivial implementation, but not quite.<br></p><p>Consider a case like this:<br></p><p>  class QuxEvaluator  {<br>  <br>    let foo: Foo // Equatable<br>    let bar: Bar // Equatable<br>    let baz: Baz // Equatable<br></p><p>    private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br></p><p>    // pure function of `foo`, `bar`, `baz`, and `identifier`<br>    // expensive, and uses `quxCache` for memoization <br>    func qux(for identifier: QuxIdentifier) -&gt; Qux<br></p><p>  }<br></p><p>…if it weren’t for `quxCache` we could easily synthesize `==` for `QuxEvaluator`, but the trivial synthesis will yield invalid results due to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be equatable once conditional conformances are in place).<br></p><p>So we’re back to e.g. writing this: <br></p><p>  extension QuxEvaluator : Equatable {<br></p><p>  }<br></p><p>  func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>    return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp; lhs.baz == rhs.baz)<br>  }<br></p><p>…just to omit a single field from the `==` consideration; this is another sense in which you can say deriving is an all-or-none; there’s just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br></p><p>On the one hand, it’s possible to imagine a finer-grained form of this synthesis that’d allow you to e.g. indicate a certain field should be omitted (and also perhaps specialize how fields are compared, customize the synthesized comparison ordering to put cheaper comparisons earlier, and an endless list of other possible requests…).<br></p><p>On the other hand, the memberwise-init proposal had a very similar situation: the naive approach was arguably too narrow, but it proved very difficult to find a workable balance between customization and implementation complexity (leaving it postponed for the foreseeable future); it’d be a pity if synthesis like this fell into the same trap.<br></p><p>But, on the gripping hand, I highly suspect that a naive `deriving`/synthesis will wind up being too narrowly-useful to really justify; that’s just my opinion, of course.<br></p><p>&gt; <br>&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt; what i care about is to have a choice about what DEFINES the identity of my values, not just an all-or-nothing situation.<br>&gt; <br>&gt; On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt; <br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt; &gt; Introduction<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;          lhs<br>&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; switch<br>&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt; &gt;  rSuit<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt; &gt;  rFour)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lFour ==<br>&gt;&gt; &gt;  rFour<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt; &gt;  rThree)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lThree ==<br>&gt;&gt; &gt;  rThree<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt; &gt;  rSuit)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt; &gt;  rRank)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lRank ==<br>&gt;&gt; &gt;  rRank<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt; &gt;  lCard),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt; &gt;  lCard3),<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt; &gt;  rCard3)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt; &gt;  rCard3<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt; &gt;  rCard)):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return lCard ==<br>&gt;&gt; &gt;  rCard<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; default<br>&gt;&gt; &gt; :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return false<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt; &gt;  {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case one = 1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case two = 2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposed solution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Overriding defaults<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Open questions<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Impact on existing code<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Acknowledgments<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/c5f90c2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an all-or-nothing situation. If you want to define equality/hashability for your type manually, don&#39;t use `deriving`. This should leave the simplest cases to auto generation and anything more complex should be handled by the developer.<br>&gt; <br>&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving` implementation to assist in any case where what you need is *almost* the trivial implementation, but not quite.<br>&gt; <br>&gt; Consider a case like this:<br>&gt; <br>&gt;   class QuxEvaluator  {<br>&gt;   <br>&gt;     let foo: Foo // Equatable<br>&gt;     let bar: Bar // Equatable<br>&gt;     let baz: Baz // Equatable<br>&gt; <br>&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt; <br>&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;     // expensive, and uses `quxCache` for memoization <br>&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for `QuxEvaluator`, but the trivial synthesis will yield invalid results due to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be equatable once conditional conformances are in place).<br>&gt; <br>&gt; So we’re back to e.g. writing this: <br>&gt; <br>&gt;   extension QuxEvaluator : Equatable {<br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp; lhs.baz == rhs.baz)<br>&gt;   }<br>&gt; <br>&gt; …just to omit a single field from the `==` consideration; this is another sense in which you can say deriving is an all-or-none; there’s just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br></p><p>I don’t see why this must necessarily be the case.  Annotations such as you describe below could be taken into account by `deriving`.  `deriving` is just a way to invoke the synthesis mechanism.<br></p><p>&gt; <br>&gt; On the one hand, it’s possible to imagine a finer-grained form of this synthesis that’d allow you to e.g. indicate a certain field should be omitted (and also perhaps specialize how fields are compared, customize the synthesized comparison ordering to put cheaper comparisons earlier, and an endless list of other possible requests…).<br></p><p>If you don’t trust the compiler to optimize this well and therefore want control over order of comparisons you should probably just implement it manually.  As you note below, this is a convenience feature that needs to strike a fine balance.<br></p><p>IMO there are two issues involved:<br></p><p>1. How do we invoke the automatic synthesis.<br>2. How do we have some degree of control over the synthesis that happens.<br></p><p>`deriving` addresses issue 1 and says nothing about issue 2.<br></p><p>&gt; <br>&gt; On the other hand, the memberwise-init proposal had a very similar situation: the naive approach was arguably too narrow, but it proved very difficult to find a workable balance between customization and implementation complexity (leaving it postponed for the foreseeable future); it’d be a pity if synthesis like this fell into the same trap.<br>&gt; <br>&gt; But, on the gripping hand, I highly suspect that a naive `deriving`/synthesis will wind up being too narrowly-useful to really justify; that’s just my opinion, of course.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; what i care about is to have a choice about what DEFINES the identity of my values, not just an all-or-nothing situation.<br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; +1 to a `deriving` keyword<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt; &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt; &gt;       • Status: Awaiting review<br>&gt;&gt;&gt; &gt;       • Review manager: TBD<br>&gt;&gt;&gt; &gt; Introduction<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Motivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;          lhs<br>&gt;&gt;&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ...<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; switch<br>&gt;&gt;&gt; &gt;  (lhs, rhs) {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt; &gt;  rSuit<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt; &gt;  rFour)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lFour ==<br>&gt;&gt;&gt; &gt;  rFour<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt; &gt;  rThree)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lThree ==<br>&gt;&gt;&gt; &gt;  rThree<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt; &gt;  rSuit)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt; &gt;  rRank)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lRank ==<br>&gt;&gt;&gt; &gt;  rRank<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt; &gt;  lCard),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt; &gt;  lCard3),<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt; &gt;  rCard3)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt; &gt;  rCard3<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt; &gt;  rCard)):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return lCard ==<br>&gt;&gt;&gt; &gt;  rCard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; default<br>&gt;&gt;&gt; &gt; :<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; return false<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;   }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum Foo: Int<br>&gt;&gt;&gt; &gt;  {<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case one = 1<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; case two = 2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Proposed solution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Overriding defaults<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Open questions<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Omission of fields from generated computations<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Explicit or implicit derivation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Impact on existing code<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Alternatives considered<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Acknowledgments<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/5325706d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 10:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an all-or-nothing situation. If you want to define equality/hashability for your type manually, don&#39;t use `deriving`. This should leave the simplest cases to auto generation and anything more complex should be handled by the developer.<br>&gt;&gt; <br>&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving` implementation to assist in any case where what you need is *almost* the trivial implementation, but not quite.<br>&gt;&gt; <br>&gt;&gt; Consider a case like this:<br>&gt;&gt; <br>&gt;&gt;   class QuxEvaluator  {<br>&gt;&gt;   <br>&gt;&gt;     let foo: Foo // Equatable<br>&gt;&gt;     let bar: Bar // Equatable<br>&gt;&gt;     let baz: Baz // Equatable<br>&gt;&gt; <br>&gt;&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt; <br>&gt;&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;     // expensive, and uses `quxCache` for memoization <br>&gt;&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for `QuxEvaluator`, but the trivial synthesis will yield invalid results due to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be equatable once conditional conformances are in place).<br>&gt;&gt; <br>&gt;&gt; So we’re back to e.g. writing this: <br>&gt;&gt; <br>&gt;&gt;   extension QuxEvaluator : Equatable {<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp; lhs.baz == rhs.baz)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …just to omit a single field from the `==` consideration; this is another sense in which you can say deriving is an all-or-none; there’s just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt; <br>&gt; I don’t see why this must necessarily be the case.  Annotations such as you describe below could be taken into account by `deriving`.  `deriving` is just a way to invoke the synthesis mechanism.<br></p><p>Different people are using it differently I think; I agree with you if it’s just the name of the invocation, but I think at least some people are using it as a shorthand for the “naive” implementation (all fields equatable =&gt; equatable).<br></p><p>That is, I meant &quot;naive deriving” to refer to something like this (quoting Patrick):<br></p><p>&gt; It would fail if not all members were Equatable or Hashable. If it was automatic, you wouldn’t get any warning or sign at all. If you have to explicitly conform to the protocols, then your intention is clear, and if an automatic implementation cannot be made (because not all members were Equatable or Hashable), then you will get an error that you need to implement the protocol yourself like you do now (i.e. implement == and hashValue).<br></p><p><br>…but I could’ve been clearer!<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this synthesis that’d allow you to e.g. indicate a certain field should be omitted (and also perhaps specialize how fields are compared, customize the synthesized comparison ordering to put cheaper comparisons earlier, and an endless list of other possible requests…).<br>&gt; <br>&gt; If you don’t trust the compiler to optimize this well and therefore want control over order of comparisons you should probably just implement it manually.  As you note below, this is a convenience feature that needs to strike a fine balance.<br></p><p>I agree, but at the same time i think that scenarios like this:<br></p><p>  struct RevisionInfo {<br>    let contentID: NSUUID<br>    let revisionID: NSUUID<br>    let contentData: NSData<br>  }<br></p><p>…aren’t going to be all that uncommon in practice; I think a good “layered” implementation of the derivation/synthesis logic would suffice (e.g. we wouldn&#39;t *need* special-case handling for ordering, potentially…).<br></p><p>&gt; <br>&gt; IMO there are two issues involved:<br>&gt; <br>&gt; 1. How do we invoke the automatic synthesis.<br>&gt; 2. How do we have some degree of control over the synthesis that happens.<br>&gt; <br>&gt; `deriving` addresses issue 1 and says nothing about issue 2.<br></p><p>Agreed here; 2 is the interesting question. If you look at my initial response in this thread I tried to suggest a “layered” approach:<br></p><p>Layer A: have some way of directly invoking the synthesis mechanism itself (e.g. as a special-purpose macro-like construct); it should be powerful enough to make `==` easy to write, but have some flexibility (implemented or planned-for-future).<br></p><p>Layer B: add a way to synthesize `==` (etc.) via the construct from Layer A.<br> <br>That’s my 2c on this topic; given it’s a Swift 4 topic at the very earliest there’s a lot of time to figure it out.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/740fb4e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>A different way of layering could be allowing value types to be composed, where the outer type inherits the inner member’s properties and methods.<br></p><p>Let’s say you want only fields ‘contentID’ and ‘contentData&#39; to participate in equality and hashing, but not ‘revisionID&#39;:<br></p><p>  struct ContentInfo : Equatable, Hashable { // Automatic implementations for == and hashValue are provided since members conform<br>    let contentID: NSUUID<br>    let contentData: NSData<br>  }<br></p><p>  struct RevisionInfo : Equatable, Hashable {<br>    let revisionID: NSUUID<br>    private let content: ContentInfo // Hidden from the outside world<br>    public compose content // Adds .contentID, .contentData, .hashValue properties to RevisionInfo that delegate to those of `content`<br>  }<br></p><p>  func ==(lhs: RevisionInfo, rhs: RevisionInfo) -&gt; Bool {<br>    return lhs.content == rhs.content<br>  }<br></p><p><br>&gt; On 28 May 2016, at 5:41 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 10:48 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an all-or-nothing situation. If you want to define equality/hashability for your type manually, don&#39;t use `deriving`. This should leave the simplest cases to auto generation and anything more complex should be handled by the developer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving` implementation to assist in any case where what you need is *almost* the trivial implementation, but not quite.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider a case like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   class QuxEvaluator  {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;     let foo: Foo // Equatable<br>&gt;&gt;&gt;     let bar: Bar // Equatable<br>&gt;&gt;&gt;     let baz: Baz // Equatable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;&gt;     // expensive, and uses `quxCache` for memoization <br>&gt;&gt;&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for `QuxEvaluator`, but the trivial synthesis will yield invalid results due to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be equatable once conditional conformances are in place).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we’re back to e.g. writing this: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   extension QuxEvaluator : Equatable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp; lhs.baz == rhs.baz)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …just to omit a single field from the `==` consideration; this is another sense in which you can say deriving is an all-or-none; there’s just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt; <br>&gt;&gt; I don’t see why this must necessarily be the case.  Annotations such as you describe below could be taken into account by `deriving`.  `deriving` is just a way to invoke the synthesis mechanism.<br>&gt; <br>&gt; Different people are using it differently I think; I agree with you if it’s just the name of the invocation, but I think at least some people are using it as a shorthand for the “naive” implementation (all fields equatable =&gt; equatable).<br>&gt; <br>&gt; That is, I meant &quot;naive deriving” to refer to something like this (quoting Patrick):<br>&gt; <br>&gt;&gt; It would fail if not all members were Equatable or Hashable. If it was automatic, you wouldn’t get any warning or sign at all. If you have to explicitly conform to the protocols, then your intention is clear, and if an automatic implementation cannot be made (because not all members were Equatable or Hashable), then you will get an error that you need to implement the protocol yourself like you do now (i.e. implement == and hashValue).<br>&gt; <br>&gt; <br>&gt; …but I could’ve been clearer!<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this synthesis that’d allow you to e.g. indicate a certain field should be omitted (and also perhaps specialize how fields are compared, customize the synthesized comparison ordering to put cheaper comparisons earlier, and an endless list of other possible requests…).<br>&gt;&gt; <br>&gt;&gt; If you don’t trust the compiler to optimize this well and therefore want control over order of comparisons you should probably just implement it manually.  As you note below, this is a convenience feature that needs to strike a fine balance.<br>&gt; <br>&gt; I agree, but at the same time i think that scenarios like this:<br>&gt; <br>&gt;   struct RevisionInfo {<br>&gt;     let contentID: NSUUID<br>&gt;     let revisionID: NSUUID<br>&gt;     let contentData: NSData<br>&gt;   }<br>&gt; <br>&gt; …aren’t going to be all that uncommon in practice; I think a good “layered” implementation of the derivation/synthesis logic would suffice (e.g. we wouldn&#39;t *need* special-case handling for ordering, potentially…).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; IMO there are two issues involved:<br>&gt;&gt; <br>&gt;&gt; 1. How do we invoke the automatic synthesis.<br>&gt;&gt; 2. How do we have some degree of control over the synthesis that happens.<br>&gt;&gt; <br>&gt;&gt; `deriving` addresses issue 1 and says nothing about issue 2.<br>&gt; <br>&gt; Agreed here; 2 is the interesting question. If you look at my initial response in this thread I tried to suggest a “layered” approach:<br>&gt; <br>&gt; Layer A: have some way of directly invoking the synthesis mechanism itself (e.g. as a special-purpose macro-like construct); it should be powerful enough to make `==` easy to write, but have some flexibility (implemented or planned-for-future).<br>&gt; <br>&gt; Layer B: add a way to synthesize `==` (etc.) via the construct from Layer A.<br>&gt;  <br>&gt; That’s my 2c on this topic; given it’s a Swift 4 topic at the very earliest there’s a lot of time to figure it out.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/66d4b699/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 10:08 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A different way of layering could be allowing value types to be composed, where the outer type inherits the inner member’s properties and methods.<br>&gt; <br>&gt; Let’s say you want only fields ‘contentID’ and ‘contentData&#39; to participate in equality and hashing, but not ‘revisionID&#39;:<br>&gt; <br>&gt;   struct ContentInfo : Equatable, Hashable { // Automatic implementations for == and hashValue are provided since members conform<br>&gt;     let contentID: NSUUID<br>&gt;     let contentData: NSData<br>&gt;   }<br>&gt; <br>&gt;   struct RevisionInfo : Equatable, Hashable {<br>&gt;     let revisionID: NSUUID<br>&gt;     private let content: ContentInfo // Hidden from the outside world<br>&gt;     public compose content // Adds .contentID, .contentData, .hashValue properties to RevisionInfo that delegate to those of `content`<br>&gt;   }<br>&gt; <br>&gt;   func ==(lhs: RevisionInfo, rhs: RevisionInfo) -&gt; Bool {<br>&gt;     return lhs.content == rhs.content<br>&gt;   }<br></p><p>This is pretty similar to embedding in Go.  It is an interesting feature but I don&#39;t think it&#39;s that relevant to compiler synthesized Equatable and Hashable. <br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; On 28 May 2016, at 5:41 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 10:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an all-or-nothing situation. If you want to define equality/hashability for your type manually, don&#39;t use `deriving`. This should leave the simplest cases to auto generation and anything more complex should be handled by the developer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving` implementation to assist in any case where what you need is *almost* the trivial implementation, but not quite.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider a case like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   class QuxEvaluator  {<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;     let foo: Foo // Equatable<br>&gt;&gt;&gt;&gt;     let bar: Bar // Equatable<br>&gt;&gt;&gt;&gt;     let baz: Baz // Equatable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;&gt;&gt;     // expensive, and uses `quxCache` for memoization <br>&gt;&gt;&gt;&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for `QuxEvaluator`, but the trivial synthesis will yield invalid results due to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be equatable once conditional conformances are in place).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So we’re back to e.g. writing this: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   extension QuxEvaluator : Equatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp; lhs.baz == rhs.baz)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …just to omit a single field from the `==` consideration; this is another sense in which you can say deriving is an all-or-none; there’s just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see why this must necessarily be the case.  Annotations such as you describe below could be taken into account by `deriving`.  `deriving` is just a way to invoke the synthesis mechanism.<br>&gt;&gt; <br>&gt;&gt; Different people are using it differently I think; I agree with you if it’s just the name of the invocation, but I think at least some people are using it as a shorthand for the “naive” implementation (all fields equatable =&gt; equatable).<br>&gt;&gt; <br>&gt;&gt; That is, I meant &quot;naive deriving” to refer to something like this (quoting Patrick):<br>&gt;&gt; <br>&gt;&gt;&gt; It would fail if not all members were Equatable or Hashable. If it was automatic, you wouldn’t get any warning or sign at all. If you have to explicitly conform to the protocols, then your intention is clear, and if an automatic implementation cannot be made (because not all members were Equatable or Hashable), then you will get an error that you need to implement the protocol yourself like you do now (i.e. implement == and hashValue).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; …but I could’ve been clearer!<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this synthesis that’d allow you to e.g. indicate a certain field should be omitted (and also perhaps specialize how fields are compared, customize the synthesized comparison ordering to put cheaper comparisons earlier, and an endless list of other possible requests…).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don’t trust the compiler to optimize this well and therefore want control over order of comparisons you should probably just implement it manually.  As you note below, this is a convenience feature that needs to strike a fine balance.<br>&gt;&gt; <br>&gt;&gt; I agree, but at the same time i think that scenarios like this:<br>&gt;&gt; <br>&gt;&gt;   struct RevisionInfo {<br>&gt;&gt;     let contentID: NSUUID<br>&gt;&gt;     let revisionID: NSUUID<br>&gt;&gt;     let contentData: NSData<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …aren’t going to be all that uncommon in practice; I think a good “layered” implementation of the derivation/synthesis logic would suffice (e.g. we wouldn&#39;t *need* special-case handling for ordering, potentially…).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO there are two issues involved:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. How do we invoke the automatic synthesis.<br>&gt;&gt;&gt; 2. How do we have some degree of control over the synthesis that happens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `deriving` addresses issue 1 and says nothing about issue 2.<br>&gt;&gt; <br>&gt;&gt; Agreed here; 2 is the interesting question. If you look at my initial response in this thread I tried to suggest a “layered” approach:<br>&gt;&gt; <br>&gt;&gt; Layer A: have some way of directly invoking the synthesis mechanism itself (e.g. as a special-purpose macro-like construct); it should be powerful enough to make `==` easy to write, but have some flexibility (implemented or planned-for-future).<br>&gt;&gt; <br>&gt;&gt; Layer B: add a way to synthesize `==` (etc.) via the construct from Layer A.<br>&gt;&gt;  <br>&gt;&gt; That’s my 2c on this topic; given it’s a Swift 4 topic at the very earliest there’s a lot of time to figure it out.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/66bf14a5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Saw `class` in examples and want to clarify.. Are we discussing <br>auto-deriving for *value types only*. Or for classes also?<br>As I understand, there could be some additional questions/issues for this <br>feature because of class inheritance. But probably this feature could be <br>discussed for `final` classes also?<br></p><p>On 27.05.2016 22:41, plx via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 27, 2016, at 10:48 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt;&gt;&gt; all-or-nothing situation. If you want to define equality/hashability<br>&gt;&gt;&gt;&gt; for your type manually, don&#39;t use `deriving`. This should leave the<br>&gt;&gt;&gt;&gt; simplest cases to auto generation and anything more complex should be<br>&gt;&gt;&gt;&gt; handled by the developer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt;&gt;&gt; implementation to assist in any case where what you need is *almost* the<br>&gt;&gt;&gt; trivial implementation, but not quite.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider a case like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   class QuxEvaluator  {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let foo: Foo // Equatable<br>&gt;&gt;&gt;     let bar: Bar // Equatable<br>&gt;&gt;&gt;     let baz: Baz // Equatable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;&gt;     // expensive, and uses `quxCache` for memoization<br>&gt;&gt;&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt;&gt;&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due<br>&gt;&gt;&gt; to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also<br>&gt;&gt;&gt; be equatable once conditional conformances are in place).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So we’re back to e.g. writing this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   extension QuxEvaluator : Equatable {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt;&gt;&gt; lhs.baz == rhs.baz)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …just to omit a single field from the `==` consideration; this is<br>&gt;&gt;&gt; another sense in which you can say deriving is an all-or-none; there’s<br>&gt;&gt;&gt; just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt;<br>&gt;&gt; I don’t see why this must necessarily be the case.  Annotations such as<br>&gt;&gt; you describe below could be taken into account by `deriving`.  `deriving`<br>&gt;&gt; is just a way to invoke the synthesis mechanism.<br>&gt;<br>&gt; Different people are using it differently I think; I agree with you if it’s<br>&gt; just the name of the invocation, but I think at least some people are using<br>&gt; it as a shorthand for the “naive” implementation (all fields equatable =&gt;<br>&gt; equatable).<br>&gt;<br>&gt; That is, I meant &quot;naive deriving” to refer to something like this (quoting<br>&gt; Patrick):<br>&gt;<br>&gt;&gt; It would fail if not all members were Equatable or Hashable. If it was<br>&gt;&gt; automatic, you wouldn’t get any warning or sign at all. If you have to<br>&gt;&gt; explicitly conform to the protocols, then your intention is clear, and if<br>&gt;&gt; an automatic implementation cannot be made (because not all members were<br>&gt;&gt; Equatable or Hashable), then you will get an error that you need to<br>&gt;&gt; implement the protocol yourself like you do now (i.e. implement == and<br>&gt;&gt; hashValue).<br>&gt;<br>&gt; …but I could’ve been clearer!<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt;&gt;&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt;&gt;&gt; omitted (and also perhaps specialize how fields are compared, customize<br>&gt;&gt;&gt; the synthesized comparison ordering to put cheaper comparisons earlier,<br>&gt;&gt;&gt; and an endless list of other possible requests…).<br>&gt;&gt;<br>&gt;&gt; If you don’t trust the compiler to optimize this well and therefore want<br>&gt;&gt; control over order of comparisons you should probably just implement it<br>&gt;&gt; manually.  As you note below, this is a convenience feature that needs to<br>&gt;&gt; strike a fine balance.<br>&gt;<br>&gt; I agree, but at the same time i think that scenarios like this:<br>&gt;<br>&gt;   struct RevisionInfo {<br>&gt;     let contentID: NSUUID<br>&gt;     let revisionID: NSUUID<br>&gt;     let contentData: NSData<br>&gt;   }<br>&gt;<br>&gt; …aren’t going to be all that uncommon in practice; I think a good “layered”<br>&gt; implementation of the derivation/synthesis logic would suffice (e.g. we<br>&gt; wouldn&#39;t *need* special-case handling for ordering, potentially…).<br>&gt;<br>&gt;&gt;<br>&gt;&gt; IMO there are two issues involved:<br>&gt;&gt;<br>&gt;&gt; 1. How do we invoke the automatic synthesis.<br>&gt;&gt; 2. How do we have some degree of control over the synthesis that happens.<br>&gt;&gt;<br>&gt;&gt; `deriving` addresses issue 1 and says nothing about issue 2.<br>&gt;<br>&gt; Agreed here; 2 is the interesting question. If you look at my initial<br>&gt; response in this thread I tried to suggest a “layered” approach:<br>&gt;<br>&gt; Layer A: have some way of directly invoking the synthesis mechanism itself<br>&gt; (e.g. as a special-purpose macro-like construct); it should be powerful<br>&gt; enough to make `==` easy to write, but have some flexibility (implemented<br>&gt; or planned-for-future).<br>&gt;<br>&gt; Layer B: add a way to synthesize `==` (etc.) via the construct from Layer A.<br>&gt;<br>&gt; That’s my 2c on this topic; given it’s a Swift 4 topic at the very earliest<br>&gt; there’s a lot of time to figure it out.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 8:41 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Saw `class` in examples and want to clarify.. Are we discussing auto-deriving for *value types only*. Or for classes also?<br>&gt; As I understand, there could be some additional questions/issues for this feature because of class inheritance. But probably this feature could be discussed for `final` classes also?<br></p><p>Classes usually have reference semantics.  In that case reference identity is the appropriate definition of equality.  Other kinds of equivalence tests are possible but should not have the name ==.<br></p><p>Immutable classes can have value semantics.  In that case a memberwise equality is as likely to be correct as it is for structs.  So it is possible we could allow synthesis to be requested for classes, it would just result in an error more frequently than with structs.<br></p><p><br>&gt; <br>&gt;&gt; On 27.05.2016 22:41, plx via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 10:48 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 10:37 AM, plx via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt;&gt;&gt;&gt; all-or-nothing situation. If you want to define equality/hashability<br>&gt;&gt;&gt;&gt;&gt; for your type manually, don&#39;t use `deriving`. This should leave the<br>&gt;&gt;&gt;&gt;&gt; simplest cases to auto generation and anything more complex should be<br>&gt;&gt;&gt;&gt;&gt; handled by the developer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt;&gt;&gt;&gt; implementation to assist in any case where what you need is *almost* the<br>&gt;&gt;&gt;&gt; trivial implementation, but not quite.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider a case like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  class QuxEvaluator  {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let foo: Foo // Equatable<br>&gt;&gt;&gt;&gt;    let bar: Bar // Equatable<br>&gt;&gt;&gt;&gt;    let baz: Baz // Equatable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;&gt;&gt;    // expensive, and uses `quxCache` for memoization<br>&gt;&gt;&gt;&gt;    func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt;&gt;&gt;&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due<br>&gt;&gt;&gt;&gt; to `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also<br>&gt;&gt;&gt;&gt; be equatable once conditional conformances are in place).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So we’re back to e.g. writing this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  extension QuxEvaluator : Equatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt;&gt;&gt;&gt; lhs.baz == rhs.baz)<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …just to omit a single field from the `==` consideration; this is<br>&gt;&gt;&gt;&gt; another sense in which you can say deriving is an all-or-none; there’s<br>&gt;&gt;&gt;&gt; just no way to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see why this must necessarily be the case.  Annotations such as<br>&gt;&gt;&gt; you describe below could be taken into account by `deriving`.  `deriving`<br>&gt;&gt;&gt; is just a way to invoke the synthesis mechanism.<br>&gt;&gt; <br>&gt;&gt; Different people are using it differently I think; I agree with you if it’s<br>&gt;&gt; just the name of the invocation, but I think at least some people are using<br>&gt;&gt; it as a shorthand for the “naive” implementation (all fields equatable =&gt;<br>&gt;&gt; equatable).<br>&gt;&gt; <br>&gt;&gt; That is, I meant &quot;naive deriving” to refer to something like this (quoting<br>&gt;&gt; Patrick):<br>&gt;&gt; <br>&gt;&gt;&gt; It would fail if not all members were Equatable or Hashable. If it was<br>&gt;&gt;&gt; automatic, you wouldn’t get any warning or sign at all. If you have to<br>&gt;&gt;&gt; explicitly conform to the protocols, then your intention is clear, and if<br>&gt;&gt;&gt; an automatic implementation cannot be made (because not all members were<br>&gt;&gt;&gt; Equatable or Hashable), then you will get an error that you need to<br>&gt;&gt;&gt; implement the protocol yourself like you do now (i.e. implement == and<br>&gt;&gt;&gt; hashValue).<br>&gt;&gt; <br>&gt;&gt; …but I could’ve been clearer!<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt;&gt;&gt;&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt;&gt;&gt;&gt; omitted (and also perhaps specialize how fields are compared, customize<br>&gt;&gt;&gt;&gt; the synthesized comparison ordering to put cheaper comparisons earlier,<br>&gt;&gt;&gt;&gt; and an endless list of other possible requests…).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don’t trust the compiler to optimize this well and therefore want<br>&gt;&gt;&gt; control over order of comparisons you should probably just implement it<br>&gt;&gt;&gt; manually.  As you note below, this is a convenience feature that needs to<br>&gt;&gt;&gt; strike a fine balance.<br>&gt;&gt; <br>&gt;&gt; I agree, but at the same time i think that scenarios like this:<br>&gt;&gt; <br>&gt;&gt;  struct RevisionInfo {<br>&gt;&gt;    let contentID: NSUUID<br>&gt;&gt;    let revisionID: NSUUID<br>&gt;&gt;    let contentData: NSData<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; …aren’t going to be all that uncommon in practice; I think a good “layered”<br>&gt;&gt; implementation of the derivation/synthesis logic would suffice (e.g. we<br>&gt;&gt; wouldn&#39;t *need* special-case handling for ordering, potentially…).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO there are two issues involved:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. How do we invoke the automatic synthesis.<br>&gt;&gt;&gt; 2. How do we have some degree of control over the synthesis that happens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `deriving` addresses issue 1 and says nothing about issue 2.<br>&gt;&gt; <br>&gt;&gt; Agreed here; 2 is the interesting question. If you look at my initial<br>&gt;&gt; response in this thread I tried to suggest a “layered” approach:<br>&gt;&gt; <br>&gt;&gt; Layer A: have some way of directly invoking the synthesis mechanism itself<br>&gt;&gt; (e.g. as a special-purpose macro-like construct); it should be powerful<br>&gt;&gt; enough to make `==` easy to write, but have some flexibility (implemented<br>&gt;&gt; or planned-for-future).<br>&gt;&gt; <br>&gt;&gt; Layer B: add a way to synthesize `==` (etc.) via the construct from Layer A.<br>&gt;&gt; <br>&gt;&gt; That’s my 2c on this topic; given it’s a Swift 4 topic at the very earliest<br>&gt;&gt; there’s a lot of time to figure it out.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On 27.05.2016 18:37, plx via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt; all-or-nothing situation. If you want to define equality/hashability for<br>&gt;&gt; your type manually, don&#39;t use `deriving`. This should leave the simplest<br>&gt;&gt; cases to auto generation and anything more complex should be handled by<br>&gt;&gt; the developer.<br>&gt;<br>&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt; implementation to assist in any case where what you need is *almost* the<br>&gt; trivial implementation, but not quite.<br></p><p>I support that we need a way to exclude some fields from participate in <br>auto-derived code. It is not handy if we&#39;ll have just one-two excluded <br>properties (of 10 for example) and we&#39;ll need to implement the boilerplate <br>code because of this. Probably, this should be another proposal for this <br>feature.<br></p><p>Just some thoughts: such a method to decorate some fields as <br>`nonequatable`/`nonhashable` has no meaning *if* Equatable/Hashable is <br>later implemented manually. So, to remove confusion, it seems like such <br>&#39;method&#39; to exclude should be disallowed(by compiler) if protocols are <br>implemented manually by coder.<br>I.e., I don&#39;t want to see a code where we have *both* explicit <br>implementations of protocols *and* some decorators/special functions to <br>exclude some fields as this will no any sense.<br></p><p>Also for me it seems like we need to be able to define such attribute near <br>the field itself, to prevent later errors when you define new field but <br>forgot to add it to some &#39;special list&#39; of excluded field somewhere in code.<br>So, probably I&#39;d prefer some kind of @nonequatable and @nonhashable :<br>@nonequatable var field = 0<br></p><p><br>&gt;<br>&gt; Consider a case like this:<br>&gt;<br>&gt;   class QuxEvaluator  {<br>&gt;<br>&gt;     let foo: Foo // Equatable<br>&gt;     let bar: Bar // Equatable<br>&gt;     let baz: Baz // Equatable<br>&gt;<br>&gt;     private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;<br>&gt;     // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;     // expensive, and uses `quxCache` for memoization<br>&gt;     func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due to<br>&gt; `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be<br>&gt; equatable once conditional conformances are in place).<br>&gt;<br>&gt; So we’re back to e.g. writing this:<br>&gt;<br>&gt;   extension QuxEvaluator : Equatable {<br>&gt;<br>&gt;   }<br>&gt;<br>&gt;   func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;     return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt; lhs.baz == rhs.baz)<br>&gt;   }<br>&gt;<br>&gt; …just to omit a single field from the `==` consideration; this is another<br>&gt; sense in which you can say deriving is an all-or-none; there’s just no way<br>&gt; to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;<br>&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt; omitted (and also perhaps specialize how fields are compared, customize the<br>&gt; synthesized comparison ordering to put cheaper comparisons earlier, and an<br>&gt; endless list of other possible requests…).<br>&gt;<br>&gt; On the other hand, the memberwise-init proposal had a very similar<br>&gt; situation: the naive approach was arguably too narrow, but it proved very<br>&gt; difficult to find a workable balance between customization and<br>&gt; implementation complexity (leaving it postponed for the foreseeable<br>&gt; future); it’d be a pity if synthesis like this fell into the same trap.<br>&gt;<br>&gt; But, on the gripping hand, I highly suspect that a naive<br>&gt; `deriving`/synthesis will wind up being too narrowly-useful to really<br>&gt; justify; that’s just my opinion, of course.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic<br>&gt;&gt; &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     what i care about is to have a choice about what DEFINES the identity<br>&gt;&gt;     of my values, not just an all-or-nothing situation.<br>&gt;&gt;<br>&gt;&gt;     On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;     +1 to a `deriving` keyword<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via<br>&gt;&gt;&gt;     swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Can we just copy&amp;paste the solution from Haskell instead of<br>&gt;&gt;&gt;         creating our own? It&#39;s just better in every aspect. Deriving<br>&gt;&gt;&gt;         `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         This has several advantages:<br>&gt;&gt;&gt;         - you don&#39;t have to guess wether `Equatable` or `Hashable`<br>&gt;&gt;&gt;         should be automatically derived or not.<br>&gt;&gt;&gt;         - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;         - If you need a custom `Equatable` implementation (for whatever<br>&gt;&gt;&gt;         reason), you can still do it.<br>&gt;&gt;&gt;         - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;         - It can be extended in future versions of Swift, without<br>&gt;&gt;&gt;         introducing any new incompatibilities. For example,<br>&gt;&gt;&gt;         `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;         - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt;&gt;         Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is<br>&gt;&gt;&gt;         equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used<br>&gt;&gt;&gt;         as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;`<br>&gt;&gt;&gt;         would be equatable. Unless something in the definition of<br>&gt;&gt;&gt;         `Shape` makes deriving `Equatable` impossible =&gt; this produces<br>&gt;&gt;&gt;         an error.)<br>&gt;&gt;&gt;         - It is proven to work in production.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         -Michael<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution<br>&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Thanks so much for putting this together, Tony! Glad I was<br>&gt;&gt;&gt;         able to be some inspiration. :^)<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via<br>&gt;&gt;&gt;         swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;         &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;         &gt; I was inspired to put together a draft proposal based on an<br>&gt;&gt;&gt;         older discussion in the Universal Equality, Hashability, and<br>&gt;&gt;&gt;         Comparability thread<br>&gt;&gt;&gt;         &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;<br>&gt;&gt;&gt;         that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; I&#39;m guessing that this would be a significant enough change<br>&gt;&gt;&gt;         that it&#39;s not possible for the Swift 3 timeline, but it&#39;s<br>&gt;&gt;&gt;         something that would benefit enough people that I want to make<br>&gt;&gt;&gt;         sure the discussion stays alive. If there are enough good<br>&gt;&gt;&gt;         feelings about it, I&#39;ll move it from my gist into an actual<br>&gt;&gt;&gt;         proposal PR.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;         &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;         &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;         &gt;       • Review manager: TBD<br>&gt;&gt;&gt;         &gt; Introduction<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Value types are prevalent throughout the Swift language, and<br>&gt;&gt;&gt;         we encourage developers to think in those terms when writing<br>&gt;&gt;&gt;         their own types. Frequently, developers find themselves writing<br>&gt;&gt;&gt;         large amounts of boilerplate code to support equatability and<br>&gt;&gt;&gt;         hashability of value types. This proposal offers a way for the<br>&gt;&gt;&gt;         compiler to automatically derive conformance toEquatable and<br>&gt;&gt;&gt;         Hashable to reduce this boilerplate, in a subset of scenarios<br>&gt;&gt;&gt;         where generating the correct implementation is likely to be<br>&gt;&gt;&gt;         possible.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Swift-evolution thread: Universal Equatability, Hashability,<br>&gt;&gt;&gt;         and Comparability<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Motivation<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Building robust value types in Swift can involve writing<br>&gt;&gt;&gt;         significant boilerplate code to support concepts of hashability<br>&gt;&gt;&gt;         and equatability. Equality is pervasive across many value types,<br>&gt;&gt;&gt;         and for each one users must implement the == operator such that<br>&gt;&gt;&gt;         it performs a fairly rote memberwise equality test. As an<br>&gt;&gt;&gt;         example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;         &gt;  {<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;          lhs<br>&gt;&gt;&gt;         &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;          lhs<br>&gt;&gt;&gt;         &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; ...<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; }<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; What&#39;s worse is that this operator must be updated if any<br>&gt;&gt;&gt;         properties are added, removed, or changed, and since it must be<br>&gt;&gt;&gt;         manually written, it&#39;s possible to get it wrong, either by<br>&gt;&gt;&gt;         omission or typographical error.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Likewise, hashability is necessary when one wishes to store a<br>&gt;&gt;&gt;         value type in a Set or use one as a multi-valuedDictionary key.<br>&gt;&gt;&gt;         Writing high-quality, well-distributed hash functions is not<br>&gt;&gt;&gt;         trivial so developers may not put a great deal of thought into<br>&gt;&gt;&gt;         them – especially as the number of properties increases – not<br>&gt;&gt;&gt;         realizing that their performance could potentially suffer as a<br>&gt;&gt;&gt;         result. And as with equality, writing it manually means there is<br>&gt;&gt;&gt;         the potential to get it wrong.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; In particular, the code that must be written to implement<br>&gt;&gt;&gt;         equality for enums is quite verbose. One such real-world example<br>&gt;&gt;&gt;         (source):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;         &gt;  {<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; switch<br>&gt;&gt;&gt;         &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let<br>&gt;&gt;&gt;         rRank , let<br>&gt;&gt;&gt;         &gt;  rSuit)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;         &gt;  rSuit<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;         &gt;  rFour)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lFour ==<br>&gt;&gt;&gt;         &gt;  rFour<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;         &gt;  rThree)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lThree ==<br>&gt;&gt;&gt;         &gt;  rThree<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;         &gt;  rSuit)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;         &gt;  rRank<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;         &gt;  rRank)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lRank ==<br>&gt;&gt;&gt;         &gt;  rRank<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;         &gt;  rRank)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lRank ==<br>&gt;&gt;&gt;         &gt;  rRank<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;         &gt;  lCard),<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;         &gt;  rCard)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;         &gt;  rCard<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let<br>&gt;&gt;&gt;         lCard2, card3: let<br>&gt;&gt;&gt;         &gt;  lCard3),<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2,<br>&gt;&gt;&gt;         card3: let<br>&gt;&gt;&gt;         &gt;  rCard3)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 ==<br>&gt;&gt;&gt;         rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;         &gt;  rCard3<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;         &gt;  rCard)):<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return lCard ==<br>&gt;&gt;&gt;         &gt;  rCard<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; default<br>&gt;&gt;&gt;         &gt; :<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; return false<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;   }<br>&gt;&gt;&gt;         &gt; }<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Crafting a high-quality hash function for this enum would be<br>&gt;&gt;&gt;         similarly inconvenient to write, involving another large<br>&gt;&gt;&gt;         switchstatement.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Swift already provides implicit protocol conformance in some<br>&gt;&gt;&gt;         cases; notably, enums with raw values conform<br>&gt;&gt;&gt;         toRawRepresentable, Equatable, and Hashable without the user<br>&gt;&gt;&gt;         explicitly declaring them:<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; enum Foo: Int<br>&gt;&gt;&gt;         &gt;  {<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case one = 1<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; case two = 2<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; }<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;         &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;         &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;         &gt; Since there is precedent for this in Swift, we propose<br>&gt;&gt;&gt;         extending this support to more value types.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Proposed solution<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; We propose that a value type be Equatable/Hashable if all of<br>&gt;&gt;&gt;         its members are Equatable/Hashable, with the result for the<br>&gt;&gt;&gt;         outer type being composed from its members.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Specifically, we propose the following rules for deriving<br>&gt;&gt;&gt;         Equatable:<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;       • A struct implicitly conforms to Equatable if all of<br>&gt;&gt;&gt;         its fields are of types that conform to Equatable – either<br>&gt;&gt;&gt;         explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;         compiler will generate an implementation of ==(lhs: T, rhs:<br>&gt;&gt;&gt;         T)that returns true if and only if lhs.x == rhs.x for all fields<br>&gt;&gt;&gt;         x in T.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;       • An enum implicitly conforms to Equatable if all of its<br>&gt;&gt;&gt;         associated values across all of its cases are of types that<br>&gt;&gt;&gt;         conform to Equatable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;         application of these rules. The compiler will generate an<br>&gt;&gt;&gt;         implementation of ==(lhs: T, rhs: T) that returns true if and<br>&gt;&gt;&gt;         only if lhs and rhs are the same case and have payloads that are<br>&gt;&gt;&gt;         memberwise-equal.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;       • A struct implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;         fields are of types that conform to Hashable – either<br>&gt;&gt;&gt;         explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;         compiler will generate an implementation of hashValue that uses<br>&gt;&gt;&gt;         a pre-defined hash function† to compute the hash value of the<br>&gt;&gt;&gt;         struct from the hash values of its members.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Since order of the terms affects the hash value computation,<br>&gt;&gt;&gt;         we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;       • An enum implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;         associated values across all of its cases are of types that<br>&gt;&gt;&gt;         conform to Hashable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;         application of these rules. The compiler will generate an<br>&gt;&gt;&gt;         implementation of hashValue that uses a pre-defined hash<br>&gt;&gt;&gt;         function† to compute the hash value of an enum value by using<br>&gt;&gt;&gt;         the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;&gt;&gt;         values of its associated values as its terms, also in definition<br>&gt;&gt;&gt;         order.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; † We leave the exact definition of the hash function<br>&gt;&gt;&gt;         unspecified here; a multiplicative hash function such as<br>&gt;&gt;&gt;         Kernighan and Ritchie or Bernstein is easy to implement, but we<br>&gt;&gt;&gt;         do not rule out other possibilities.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Overriding defaults<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Any user-provided implementations of == or hashValue should<br>&gt;&gt;&gt;         override the default implementations that would be provided by<br>&gt;&gt;&gt;         the compiler. This is already possible today with raw-value<br>&gt;&gt;&gt;         enums so the same behavior should be extended to other value<br>&gt;&gt;&gt;         types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Open questions<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Should it be possible to easily omit certain properties from<br>&gt;&gt;&gt;         automatically generated equality tests or hash value<br>&gt;&gt;&gt;         computation? This could be valuable, for example, if a property<br>&gt;&gt;&gt;         is merely used as an internal cache and does not actually<br>&gt;&gt;&gt;         contribute to the &quot;value&quot; of the instance. Under the rules<br>&gt;&gt;&gt;         above, if this cached value was equatable, a user would have to<br>&gt;&gt;&gt;         override == and hashValue and provide their own implementations<br>&gt;&gt;&gt;         to ignore it. If there is significant evidence that this pattern<br>&gt;&gt;&gt;         is common and useful, we could consider adding a custom<br>&gt;&gt;&gt;         attribute, such as @transient, that would omit the property from<br>&gt;&gt;&gt;         the generated computations.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; As with raw-value enums today, should the derived conformance<br>&gt;&gt;&gt;         be completely explicit, or should users have to explicitly list<br>&gt;&gt;&gt;         conformance with Equatable and Hashable in order for the<br>&gt;&gt;&gt;         compiler to generate the derived implementation?<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Impact on existing code<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; This change will have no impact on existing code because it is<br>&gt;&gt;&gt;         purely additive. Value types that already provide custom<br>&gt;&gt;&gt;         implementations of == or hashValue but satisfy the rules above<br>&gt;&gt;&gt;         would keep the custom implementation because it would override<br>&gt;&gt;&gt;         the compiler-provided default.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Alternatives considered<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; The original discussion thread also included Comparable as a<br>&gt;&gt;&gt;         candidate for automatic generation. Unlike equatability and<br>&gt;&gt;&gt;         hashability, however, comparability requires an ordering among<br>&gt;&gt;&gt;         the members being compared. Automatically using the definition<br>&gt;&gt;&gt;         order here might be too surprising for users, but worse, it also<br>&gt;&gt;&gt;         means that reordering properties in the source code changes the<br>&gt;&gt;&gt;         code&#39;s behavior at runtime. (This is true for hashability as<br>&gt;&gt;&gt;         well if a multiplicative hash function is used, but hash values<br>&gt;&gt;&gt;         are not intended to be persistent and reordering the terms does<br>&gt;&gt;&gt;         not produce a significant behavioral change.)<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Acknowledgments<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; Thanks to Joe Groff for spinning off the original discussion<br>&gt;&gt;&gt;         thread, Jose Cheyo Jimenez for providing great real-world<br>&gt;&gt;&gt;         examples of boilerplate needed to support equatability for some<br>&gt;&gt;&gt;         value types, and to Mark Sands for necromancing the<br>&gt;&gt;&gt;         swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; _______________________________________________<br>&gt;&gt;&gt;         &gt; swift-evolution mailing list<br>&gt;&gt;&gt;         &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt;<br>&gt;&gt;&gt;         &gt; _______________________________________________<br>&gt;&gt;&gt;         &gt; swift-evolution mailing list<br>&gt;&gt;&gt;         &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 9:12 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 27.05.2016 18:37, plx via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt;&gt; all-or-nothing situation. If you want to define equality/hashability for<br>&gt;&gt;&gt; your type manually, don&#39;t use `deriving`. This should leave the simplest<br>&gt;&gt;&gt; cases to auto generation and anything more complex should be handled by<br>&gt;&gt;&gt; the developer.<br>&gt;&gt; <br>&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt;&gt; implementation to assist in any case where what you need is *almost* the<br>&gt;&gt; trivial implementation, but not quite.<br>&gt; <br>&gt; I support that we need a way to exclude some fields from participate in auto-derived code. It is not handy if we&#39;ll have just one-two excluded properties (of 10 for example) and we&#39;ll need to implement the boilerplate code because of this. Probably, this should be another proposal for this feature.<br>&gt; <br>&gt; Just some thoughts: such a method to decorate some fields as `nonequatable`/`nonhashable` has no meaning *if* Equatable/Hashable is later implemented manually. So, to remove confusion, it seems like such &#39;method&#39; to exclude should be disallowed(by compiler) if protocols are implemented manually by coder.<br>&gt; I.e., I don&#39;t want to see a code where we have *both* explicit implementations of protocols *and* some decorators/special functions to exclude some fields as this will no any sense.<br>&gt; <br>&gt; Also for me it seems like we need to be able to define such attribute near the field itself, to prevent later errors when you define new field but forgot to add it to some &#39;special list&#39; of excluded field somewhere in code.<br>&gt; So, probably I&#39;d prefer some kind of @nonequatable and @nonhashable :<br>&gt; @nonequatable var field = 0<br></p><p>The same members should be considered by both Equatable and Hashable so there would be no need for two separate annotations.  A more general annotation (maybe &quot;nonessential&quot;?) is what we want.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Consider a case like this:<br>&gt;&gt; <br>&gt;&gt;  class QuxEvaluator  {<br>&gt;&gt; <br>&gt;&gt;    let foo: Foo // Equatable<br>&gt;&gt;    let bar: Bar // Equatable<br>&gt;&gt;    let baz: Baz // Equatable<br>&gt;&gt; <br>&gt;&gt;    private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt; <br>&gt;&gt;    // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;    // expensive, and uses `quxCache` for memoization<br>&gt;&gt;    func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt;&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due to<br>&gt;&gt; `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be<br>&gt;&gt; equatable once conditional conformances are in place).<br>&gt;&gt; <br>&gt;&gt; So we’re back to e.g. writing this:<br>&gt;&gt; <br>&gt;&gt;  extension QuxEvaluator : Equatable {<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;    return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt;&gt; lhs.baz == rhs.baz)<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; …just to omit a single field from the `==` consideration; this is another<br>&gt;&gt; sense in which you can say deriving is an all-or-none; there’s just no way<br>&gt;&gt; to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt; <br>&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt;&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt;&gt; omitted (and also perhaps specialize how fields are compared, customize the<br>&gt;&gt; synthesized comparison ordering to put cheaper comparisons earlier, and an<br>&gt;&gt; endless list of other possible requests…).<br>&gt;&gt; <br>&gt;&gt; On the other hand, the memberwise-init proposal had a very similar<br>&gt;&gt; situation: the naive approach was arguably too narrow, but it proved very<br>&gt;&gt; difficult to find a workable balance between customization and<br>&gt;&gt; implementation complexity (leaving it postponed for the foreseeable<br>&gt;&gt; future); it’d be a pity if synthesis like this fell into the same trap.<br>&gt;&gt; <br>&gt;&gt; But, on the gripping hand, I highly suspect that a naive<br>&gt;&gt; `deriving`/synthesis will wind up being too narrowly-useful to really<br>&gt;&gt; justify; that’s just my opinion, of course.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic<br>&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    what i care about is to have a choice about what DEFINES the identity<br>&gt;&gt;&gt;    of my values, not just an all-or-nothing situation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via<br>&gt;&gt;&gt;&gt;    swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Can we just copy&amp;paste the solution from Haskell instead of<br>&gt;&gt;&gt;&gt;        creating our own? It&#39;s just better in every aspect. Deriving<br>&gt;&gt;&gt;&gt;        `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;            ...<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        This has several advantages:<br>&gt;&gt;&gt;&gt;        - you don&#39;t have to guess wether `Equatable` or `Hashable`<br>&gt;&gt;&gt;&gt;        should be automatically derived or not.<br>&gt;&gt;&gt;&gt;        - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;        - If you need a custom `Equatable` implementation (for whatever<br>&gt;&gt;&gt;&gt;        reason), you can still do it.<br>&gt;&gt;&gt;&gt;        - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;        - It can be extended in future versions of Swift, without<br>&gt;&gt;&gt;&gt;        introducing any new incompatibilities. For example,<br>&gt;&gt;&gt;&gt;        `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;        - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt;&gt;&gt;        Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is<br>&gt;&gt;&gt;&gt;        equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used<br>&gt;&gt;&gt;&gt;        as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;`<br>&gt;&gt;&gt;&gt;        would be equatable. Unless something in the definition of<br>&gt;&gt;&gt;&gt;        `Shape` makes deriving `Equatable` impossible =&gt; this produces<br>&gt;&gt;&gt;&gt;        an error.)<br>&gt;&gt;&gt;&gt;        - It is proven to work in production.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution<br>&gt;&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Thanks so much for putting this together, Tony! Glad I was<br>&gt;&gt;&gt;&gt;        able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via<br>&gt;&gt;&gt;&gt;        swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;        &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;        &gt; I was inspired to put together a draft proposal based on an<br>&gt;&gt;&gt;&gt;        older discussion in the Universal Equality, Hashability, and<br>&gt;&gt;&gt;&gt;        Comparability thread<br>&gt;&gt;&gt;&gt;        &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;<br>&gt;&gt;&gt;&gt;        that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; I&#39;m guessing that this would be a significant enough change<br>&gt;&gt;&gt;&gt;        that it&#39;s not possible for the Swift 3 timeline, but it&#39;s<br>&gt;&gt;&gt;&gt;        something that would benefit enough people that I want to make<br>&gt;&gt;&gt;&gt;        sure the discussion stays alive. If there are enough good<br>&gt;&gt;&gt;&gt;        feelings about it, I&#39;ll move it from my gist into an actual<br>&gt;&gt;&gt;&gt;        proposal PR.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;        &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;        &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;        &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;        &gt; Introduction<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Value types are prevalent throughout the Swift language, and<br>&gt;&gt;&gt;&gt;        we encourage developers to think in those terms when writing<br>&gt;&gt;&gt;&gt;        their own types. Frequently, developers find themselves writing<br>&gt;&gt;&gt;&gt;        large amounts of boilerplate code to support equatability and<br>&gt;&gt;&gt;&gt;        hashability of value types. This proposal offers a way for the<br>&gt;&gt;&gt;&gt;        compiler to automatically derive conformance toEquatable and<br>&gt;&gt;&gt;&gt;        Hashable to reduce this boilerplate, in a subset of scenarios<br>&gt;&gt;&gt;&gt;        where generating the correct implementation is likely to be<br>&gt;&gt;&gt;&gt;        possible.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Swift-evolution thread: Universal Equatability, Hashability,<br>&gt;&gt;&gt;&gt;        and Comparability<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Motivation<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Building robust value types in Swift can involve writing<br>&gt;&gt;&gt;&gt;        significant boilerplate code to support concepts of hashability<br>&gt;&gt;&gt;&gt;        and equatability. Equality is pervasive across many value types,<br>&gt;&gt;&gt;&gt;        and for each one users must implement the == operator such that<br>&gt;&gt;&gt;&gt;        it performs a fairly rote memberwise equality test. As an<br>&gt;&gt;&gt;&gt;        example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;          lhs<br>&gt;&gt;&gt;&gt;        &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;          lhs<br>&gt;&gt;&gt;&gt;        &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; ...<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; What&#39;s worse is that this operator must be updated if any<br>&gt;&gt;&gt;&gt;        properties are added, removed, or changed, and since it must be<br>&gt;&gt;&gt;&gt;        manually written, it&#39;s possible to get it wrong, either by<br>&gt;&gt;&gt;&gt;        omission or typographical error.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Likewise, hashability is necessary when one wishes to store a<br>&gt;&gt;&gt;&gt;        value type in a Set or use one as a multi-valuedDictionary key.<br>&gt;&gt;&gt;&gt;        Writing high-quality, well-distributed hash functions is not<br>&gt;&gt;&gt;&gt;        trivial so developers may not put a great deal of thought into<br>&gt;&gt;&gt;&gt;        them – especially as the number of properties increases – not<br>&gt;&gt;&gt;&gt;        realizing that their performance could potentially suffer as a<br>&gt;&gt;&gt;&gt;        result. And as with equality, writing it manually means there is<br>&gt;&gt;&gt;&gt;        the potential to get it wrong.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; In particular, the code that must be written to implement<br>&gt;&gt;&gt;&gt;        equality for enums is quite verbose. One such real-world example<br>&gt;&gt;&gt;&gt;        (source):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; switch<br>&gt;&gt;&gt;&gt;        &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let<br>&gt;&gt;&gt;&gt;        rRank , let<br>&gt;&gt;&gt;&gt;        &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;        &gt;  rSuit<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;        &gt;  rFour)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lFour ==<br>&gt;&gt;&gt;&gt;        &gt;  rFour<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;        &gt;  rThree)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lThree ==<br>&gt;&gt;&gt;&gt;        &gt;  rThree<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;        &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;        &gt;  rRank)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;        &gt;  rRank)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;        &gt;  lCard),<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;        &gt;  rCard)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let<br>&gt;&gt;&gt;&gt;        lCard2, card3: let<br>&gt;&gt;&gt;&gt;        &gt;  lCard3),<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2,<br>&gt;&gt;&gt;&gt;        card3: let<br>&gt;&gt;&gt;&gt;        &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 ==<br>&gt;&gt;&gt;&gt;        rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard3<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;        &gt;  rCard)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lCard ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; default<br>&gt;&gt;&gt;&gt;        &gt; :<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return false<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;   }<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Crafting a high-quality hash function for this enum would be<br>&gt;&gt;&gt;&gt;        similarly inconvenient to write, involving another large<br>&gt;&gt;&gt;&gt;        switchstatement.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Swift already provides implicit protocol conformance in some<br>&gt;&gt;&gt;&gt;        cases; notably, enums with raw values conform<br>&gt;&gt;&gt;&gt;        toRawRepresentable, Equatable, and Hashable without the user<br>&gt;&gt;&gt;&gt;        explicitly declaring them:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case one = 1<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case two = 2<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;        &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;        &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;        &gt; Since there is precedent for this in Swift, we propose<br>&gt;&gt;&gt;&gt;        extending this support to more value types.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Proposed solution<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; We propose that a value type be Equatable/Hashable if all of<br>&gt;&gt;&gt;&gt;        its members are Equatable/Hashable, with the result for the<br>&gt;&gt;&gt;&gt;        outer type being composed from its members.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Specifically, we propose the following rules for deriving<br>&gt;&gt;&gt;&gt;        Equatable:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • A struct implicitly conforms to Equatable if all of<br>&gt;&gt;&gt;&gt;        its fields are of types that conform to Equatable – either<br>&gt;&gt;&gt;&gt;        explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;        compiler will generate an implementation of ==(lhs: T, rhs:<br>&gt;&gt;&gt;&gt;        T)that returns true if and only if lhs.x == rhs.x for all fields<br>&gt;&gt;&gt;&gt;        x in T.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • An enum implicitly conforms to Equatable if all of its<br>&gt;&gt;&gt;&gt;        associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;        conform to Equatable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;        application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;        implementation of ==(lhs: T, rhs: T) that returns true if and<br>&gt;&gt;&gt;&gt;        only if lhs and rhs are the same case and have payloads that are<br>&gt;&gt;&gt;&gt;        memberwise-equal.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • A struct implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;        fields are of types that conform to Hashable – either<br>&gt;&gt;&gt;&gt;        explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;        compiler will generate an implementation of hashValue that uses<br>&gt;&gt;&gt;&gt;        a pre-defined hash function† to compute the hash value of the<br>&gt;&gt;&gt;&gt;        struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Since order of the terms affects the hash value computation,<br>&gt;&gt;&gt;&gt;        we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • An enum implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;        associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;        conform to Hashable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;        application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;        implementation of hashValue that uses a pre-defined hash<br>&gt;&gt;&gt;&gt;        function† to compute the hash value of an enum value by using<br>&gt;&gt;&gt;&gt;        the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;&gt;&gt;&gt;        values of its associated values as its terms, also in definition<br>&gt;&gt;&gt;&gt;        order.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; † We leave the exact definition of the hash function<br>&gt;&gt;&gt;&gt;        unspecified here; a multiplicative hash function such as<br>&gt;&gt;&gt;&gt;        Kernighan and Ritchie or Bernstein is easy to implement, but we<br>&gt;&gt;&gt;&gt;        do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Any user-provided implementations of == or hashValue should<br>&gt;&gt;&gt;&gt;        override the default implementations that would be provided by<br>&gt;&gt;&gt;&gt;        the compiler. This is already possible today with raw-value<br>&gt;&gt;&gt;&gt;        enums so the same behavior should be extended to other value<br>&gt;&gt;&gt;&gt;        types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Open questions<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Should it be possible to easily omit certain properties from<br>&gt;&gt;&gt;&gt;        automatically generated equality tests or hash value<br>&gt;&gt;&gt;&gt;        computation? This could be valuable, for example, if a property<br>&gt;&gt;&gt;&gt;        is merely used as an internal cache and does not actually<br>&gt;&gt;&gt;&gt;        contribute to the &quot;value&quot; of the instance. Under the rules<br>&gt;&gt;&gt;&gt;        above, if this cached value was equatable, a user would have to<br>&gt;&gt;&gt;&gt;        override == and hashValue and provide their own implementations<br>&gt;&gt;&gt;&gt;        to ignore it. If there is significant evidence that this pattern<br>&gt;&gt;&gt;&gt;        is common and useful, we could consider adding a custom<br>&gt;&gt;&gt;&gt;        attribute, such as @transient, that would omit the property from<br>&gt;&gt;&gt;&gt;        the generated computations.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; As with raw-value enums today, should the derived conformance<br>&gt;&gt;&gt;&gt;        be completely explicit, or should users have to explicitly list<br>&gt;&gt;&gt;&gt;        conformance with Equatable and Hashable in order for the<br>&gt;&gt;&gt;&gt;        compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; This change will have no impact on existing code because it is<br>&gt;&gt;&gt;&gt;        purely additive. Value types that already provide custom<br>&gt;&gt;&gt;&gt;        implementations of == or hashValue but satisfy the rules above<br>&gt;&gt;&gt;&gt;        would keep the custom implementation because it would override<br>&gt;&gt;&gt;&gt;        the compiler-provided default.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; The original discussion thread also included Comparable as a<br>&gt;&gt;&gt;&gt;        candidate for automatic generation. Unlike equatability and<br>&gt;&gt;&gt;&gt;        hashability, however, comparability requires an ordering among<br>&gt;&gt;&gt;&gt;        the members being compared. Automatically using the definition<br>&gt;&gt;&gt;&gt;        order here might be too surprising for users, but worse, it also<br>&gt;&gt;&gt;&gt;        means that reordering properties in the source code changes the<br>&gt;&gt;&gt;&gt;        code&#39;s behavior at runtime. (This is true for hashability as<br>&gt;&gt;&gt;&gt;        well if a multiplicative hash function is used, but hash values<br>&gt;&gt;&gt;&gt;        are not intended to be persistent and reordering the terms does<br>&gt;&gt;&gt;&gt;        not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Thanks to Joe Groff for spinning off the original discussion<br>&gt;&gt;&gt;&gt;        thread, Jose Cheyo Jimenez for providing great real-world<br>&gt;&gt;&gt;&gt;        examples of boilerplate needed to support equatability for some<br>&gt;&gt;&gt;&gt;        value types, and to Mark Sands for necromancing the<br>&gt;&gt;&gt;&gt;        swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 29, 2016, at 9:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 29, 2016, at 9:12 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 27.05.2016 18:37, plx via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt;&gt;&gt; all-or-nothing situation. If you want to define equality/hashability for<br>&gt;&gt;&gt;&gt; your type manually, don&#39;t use `deriving`. This should leave the simplest<br>&gt;&gt;&gt;&gt; cases to auto generation and anything more complex should be handled by<br>&gt;&gt;&gt;&gt; the developer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt;&gt;&gt; implementation to assist in any case where what you need is *almost* the<br>&gt;&gt;&gt; trivial implementation, but not quite.<br>&gt;&gt; <br>&gt;&gt; I support that we need a way to exclude some fields from participate in auto-derived code. It is not handy if we&#39;ll have just one-two excluded properties (of 10 for example) and we&#39;ll need to implement the boilerplate code because of this. Probably, this should be another proposal for this feature.<br>&gt;&gt; <br>&gt;&gt; Just some thoughts: such a method to decorate some fields as `nonequatable`/`nonhashable` has no meaning *if* Equatable/Hashable is later implemented manually. So, to remove confusion, it seems like such &#39;method&#39; to exclude should be disallowed(by compiler) if protocols are implemented manually by coder.<br>&gt;&gt; I.e., I don&#39;t want to see a code where we have *both* explicit implementations of protocols *and* some decorators/special functions to exclude some fields as this will no any sense.<br>&gt;&gt; <br>&gt;&gt; Also for me it seems like we need to be able to define such attribute near the field itself, to prevent later errors when you define new field but forgot to add it to some &#39;special list&#39; of excluded field somewhere in code.<br>&gt;&gt; So, probably I&#39;d prefer some kind of @nonequatable and @nonhashable :<br>&gt;&gt; @nonequatable var field = 0<br>&gt; <br>&gt; The same members should be considered by both Equatable and Hashable so there would be no need for two separate annotations.  A more general annotation (maybe &quot;nonessential&quot;?) is what we want.<br></p><p>I strongly disagree; IMHO the members considered for hashing *should* be a subset of those considered for equality (and “be the same” is a safe default).<br></p><p>As an example, I find I quite frequently wind up with types effectively like so:<br></p><p>struct ArticleContent {<br>  let articleID: NSUUID <br>  let veryLongFullArticleContent: NSData // potentially huge, possibly slow<br>}<br></p><p>…for which, at least for the intended uses (and the intended data, etc.), hashing `articleID` is enough to get a well-behaved hash, and incorporating hashes of the other field(s) doesn’t have any apparent benefit.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider a case like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class QuxEvaluator  {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let foo: Foo // Equatable<br>&gt;&gt;&gt;   let bar: Bar // Equatable<br>&gt;&gt;&gt;   let baz: Baz // Equatable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;&gt;   // expensive, and uses `quxCache` for memoization<br>&gt;&gt;&gt;   func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt;&gt;&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due to<br>&gt;&gt;&gt; `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be<br>&gt;&gt;&gt; equatable once conditional conformances are in place).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we’re back to e.g. writing this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension QuxEvaluator : Equatable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;&gt;   return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt;&gt;&gt; lhs.baz == rhs.baz)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …just to omit a single field from the `==` consideration; this is another<br>&gt;&gt;&gt; sense in which you can say deriving is an all-or-none; there’s just no way<br>&gt;&gt;&gt; to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt;&gt;&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt;&gt;&gt; omitted (and also perhaps specialize how fields are compared, customize the<br>&gt;&gt;&gt; synthesized comparison ordering to put cheaper comparisons earlier, and an<br>&gt;&gt;&gt; endless list of other possible requests…).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, the memberwise-init proposal had a very similar<br>&gt;&gt;&gt; situation: the naive approach was arguably too narrow, but it proved very<br>&gt;&gt;&gt; difficult to find a workable balance between customization and<br>&gt;&gt;&gt; implementation complexity (leaving it postponed for the foreseeable<br>&gt;&gt;&gt; future); it’d be a pity if synthesis like this fell into the same trap.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, on the gripping hand, I highly suspect that a naive<br>&gt;&gt;&gt; `deriving`/synthesis will wind up being too narrowly-useful to really<br>&gt;&gt;&gt; justify; that’s just my opinion, of course.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic<br>&gt;&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   what i care about is to have a choice about what DEFINES the identity<br>&gt;&gt;&gt;&gt;   of my values, not just an all-or-nothing situation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;&gt;   &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;   &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       Can we just copy&amp;paste the solution from Haskell instead of<br>&gt;&gt;&gt;&gt;&gt;       creating our own? It&#39;s just better in every aspect. Deriving<br>&gt;&gt;&gt;&gt;&gt;       `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;           ...<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       This has several advantages:<br>&gt;&gt;&gt;&gt;&gt;       - you don&#39;t have to guess wether `Equatable` or `Hashable`<br>&gt;&gt;&gt;&gt;&gt;       should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt;       - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt;       - If you need a custom `Equatable` implementation (for whatever<br>&gt;&gt;&gt;&gt;&gt;       reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt;       - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt;       - It can be extended in future versions of Swift, without<br>&gt;&gt;&gt;&gt;&gt;       introducing any new incompatibilities. For example,<br>&gt;&gt;&gt;&gt;&gt;       `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt;       - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt;&gt;&gt;&gt;       Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is<br>&gt;&gt;&gt;&gt;&gt;       equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used<br>&gt;&gt;&gt;&gt;&gt;       as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;`<br>&gt;&gt;&gt;&gt;&gt;       would be equatable. Unless something in the definition of<br>&gt;&gt;&gt;&gt;&gt;       `Shape` makes deriving `Equatable` impossible =&gt; this produces<br>&gt;&gt;&gt;&gt;&gt;       an error.)<br>&gt;&gt;&gt;&gt;&gt;       - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was<br>&gt;&gt;&gt;&gt;&gt;       able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via<br>&gt;&gt;&gt;&gt;&gt;       swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;       &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an<br>&gt;&gt;&gt;&gt;&gt;       older discussion in the Universal Equality, Hashability, and<br>&gt;&gt;&gt;&gt;&gt;       Comparability thread<br>&gt;&gt;&gt;&gt;&gt;       &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;<br>&gt;&gt;&gt;&gt;&gt;       that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change<br>&gt;&gt;&gt;&gt;&gt;       that it&#39;s not possible for the Swift 3 timeline, but it&#39;s<br>&gt;&gt;&gt;&gt;&gt;       something that would benefit enough people that I want to make<br>&gt;&gt;&gt;&gt;&gt;       sure the discussion stays alive. If there are enough good<br>&gt;&gt;&gt;&gt;&gt;       feelings about it, I&#39;ll move it from my gist into an actual<br>&gt;&gt;&gt;&gt;&gt;       proposal PR.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt;&gt;      • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt;&gt;      • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;      • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and<br>&gt;&gt;&gt;&gt;&gt;       we encourage developers to think in those terms when writing<br>&gt;&gt;&gt;&gt;&gt;       their own types. Frequently, developers find themselves writing<br>&gt;&gt;&gt;&gt;&gt;       large amounts of boilerplate code to support equatability and<br>&gt;&gt;&gt;&gt;&gt;       hashability of value types. This proposal offers a way for the<br>&gt;&gt;&gt;&gt;&gt;       compiler to automatically derive conformance toEquatable and<br>&gt;&gt;&gt;&gt;&gt;       Hashable to reduce this boilerplate, in a subset of scenarios<br>&gt;&gt;&gt;&gt;&gt;       where generating the correct implementation is likely to be<br>&gt;&gt;&gt;&gt;&gt;       possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability,<br>&gt;&gt;&gt;&gt;&gt;       and Comparability<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing<br>&gt;&gt;&gt;&gt;&gt;       significant boilerplate code to support concepts of hashability<br>&gt;&gt;&gt;&gt;&gt;       and equatability. Equality is pervasive across many value types,<br>&gt;&gt;&gt;&gt;&gt;       and for each one users must implement the == operator such that<br>&gt;&gt;&gt;&gt;&gt;       it performs a fairly rote memberwise equality test. As an<br>&gt;&gt;&gt;&gt;&gt;       example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any<br>&gt;&gt;&gt;&gt;&gt;       properties are added, removed, or changed, and since it must be<br>&gt;&gt;&gt;&gt;&gt;       manually written, it&#39;s possible to get it wrong, either by<br>&gt;&gt;&gt;&gt;&gt;       omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a<br>&gt;&gt;&gt;&gt;&gt;       value type in a Set or use one as a multi-valuedDictionary key.<br>&gt;&gt;&gt;&gt;&gt;       Writing high-quality, well-distributed hash functions is not<br>&gt;&gt;&gt;&gt;&gt;       trivial so developers may not put a great deal of thought into<br>&gt;&gt;&gt;&gt;&gt;       them – especially as the number of properties increases – not<br>&gt;&gt;&gt;&gt;&gt;       realizing that their performance could potentially suffer as a<br>&gt;&gt;&gt;&gt;&gt;       result. And as with equality, writing it manually means there is<br>&gt;&gt;&gt;&gt;&gt;       the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In particular, the code that must be written to implement<br>&gt;&gt;&gt;&gt;&gt;       equality for enums is quite verbose. One such real-world example<br>&gt;&gt;&gt;&gt;&gt;       (source):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let<br>&gt;&gt;&gt;&gt;&gt;       rRank , let<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let<br>&gt;&gt;&gt;&gt;&gt;       lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2,<br>&gt;&gt;&gt;&gt;&gt;       card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 ==<br>&gt;&gt;&gt;&gt;&gt;       rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be<br>&gt;&gt;&gt;&gt;&gt;       similarly inconvenient to write, involving another large<br>&gt;&gt;&gt;&gt;&gt;       switchstatement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some<br>&gt;&gt;&gt;&gt;&gt;       cases; notably, enums with raw values conform<br>&gt;&gt;&gt;&gt;&gt;       toRawRepresentable, Equatable, and Hashable without the user<br>&gt;&gt;&gt;&gt;&gt;       explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose<br>&gt;&gt;&gt;&gt;&gt;       extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of<br>&gt;&gt;&gt;&gt;&gt;       its members are Equatable/Hashable, with the result for the<br>&gt;&gt;&gt;&gt;&gt;       outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving<br>&gt;&gt;&gt;&gt;&gt;       Equatable:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      • A struct implicitly conforms to Equatable if all of<br>&gt;&gt;&gt;&gt;&gt;       its fields are of types that conform to Equatable – either<br>&gt;&gt;&gt;&gt;&gt;       explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;&gt;       compiler will generate an implementation of ==(lhs: T, rhs:<br>&gt;&gt;&gt;&gt;&gt;       T)that returns true if and only if lhs.x == rhs.x for all fields<br>&gt;&gt;&gt;&gt;&gt;       x in T.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      • An enum implicitly conforms to Equatable if all of its<br>&gt;&gt;&gt;&gt;&gt;       associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;&gt;       conform to Equatable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;&gt;       application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;&gt;       implementation of ==(lhs: T, rhs: T) that returns true if and<br>&gt;&gt;&gt;&gt;&gt;       only if lhs and rhs are the same case and have payloads that are<br>&gt;&gt;&gt;&gt;&gt;       memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      • A struct implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;&gt;       fields are of types that conform to Hashable – either<br>&gt;&gt;&gt;&gt;&gt;       explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;&gt;       compiler will generate an implementation of hashValue that uses<br>&gt;&gt;&gt;&gt;&gt;       a pre-defined hash function† to compute the hash value of the<br>&gt;&gt;&gt;&gt;&gt;       struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation,<br>&gt;&gt;&gt;&gt;&gt;       we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      • An enum implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;&gt;       associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;&gt;       conform to Hashable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;&gt;       application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;&gt;       implementation of hashValue that uses a pre-defined hash<br>&gt;&gt;&gt;&gt;&gt;       function† to compute the hash value of an enum value by using<br>&gt;&gt;&gt;&gt;&gt;       the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;&gt;&gt;&gt;&gt;       values of its associated values as its terms, also in definition<br>&gt;&gt;&gt;&gt;&gt;       order.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function<br>&gt;&gt;&gt;&gt;&gt;       unspecified here; a multiplicative hash function such as<br>&gt;&gt;&gt;&gt;&gt;       Kernighan and Ritchie or Bernstein is easy to implement, but we<br>&gt;&gt;&gt;&gt;&gt;       do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should<br>&gt;&gt;&gt;&gt;&gt;       override the default implementations that would be provided by<br>&gt;&gt;&gt;&gt;&gt;       the compiler. This is already possible today with raw-value<br>&gt;&gt;&gt;&gt;&gt;       enums so the same behavior should be extended to other value<br>&gt;&gt;&gt;&gt;&gt;       types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from<br>&gt;&gt;&gt;&gt;&gt;       automatically generated equality tests or hash value<br>&gt;&gt;&gt;&gt;&gt;       computation? This could be valuable, for example, if a property<br>&gt;&gt;&gt;&gt;&gt;       is merely used as an internal cache and does not actually<br>&gt;&gt;&gt;&gt;&gt;       contribute to the &quot;value&quot; of the instance. Under the rules<br>&gt;&gt;&gt;&gt;&gt;       above, if this cached value was equatable, a user would have to<br>&gt;&gt;&gt;&gt;&gt;       override == and hashValue and provide their own implementations<br>&gt;&gt;&gt;&gt;&gt;       to ignore it. If there is significant evidence that this pattern<br>&gt;&gt;&gt;&gt;&gt;       is common and useful, we could consider adding a custom<br>&gt;&gt;&gt;&gt;&gt;       attribute, such as @transient, that would omit the property from<br>&gt;&gt;&gt;&gt;&gt;       the generated computations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance<br>&gt;&gt;&gt;&gt;&gt;       be completely explicit, or should users have to explicitly list<br>&gt;&gt;&gt;&gt;&gt;       conformance with Equatable and Hashable in order for the<br>&gt;&gt;&gt;&gt;&gt;       compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is<br>&gt;&gt;&gt;&gt;&gt;       purely additive. Value types that already provide custom<br>&gt;&gt;&gt;&gt;&gt;       implementations of == or hashValue but satisfy the rules above<br>&gt;&gt;&gt;&gt;&gt;       would keep the custom implementation because it would override<br>&gt;&gt;&gt;&gt;&gt;       the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a<br>&gt;&gt;&gt;&gt;&gt;       candidate for automatic generation. Unlike equatability and<br>&gt;&gt;&gt;&gt;&gt;       hashability, however, comparability requires an ordering among<br>&gt;&gt;&gt;&gt;&gt;       the members being compared. Automatically using the definition<br>&gt;&gt;&gt;&gt;&gt;       order here might be too surprising for users, but worse, it also<br>&gt;&gt;&gt;&gt;&gt;       means that reordering properties in the source code changes the<br>&gt;&gt;&gt;&gt;&gt;       code&#39;s behavior at runtime. (This is true for hashability as<br>&gt;&gt;&gt;&gt;&gt;       well if a multiplicative hash function is used, but hash values<br>&gt;&gt;&gt;&gt;&gt;       are not intended to be persistent and reordering the terms does<br>&gt;&gt;&gt;&gt;&gt;       not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion<br>&gt;&gt;&gt;&gt;&gt;       thread, Jose Cheyo Jimenez for providing great real-world<br>&gt;&gt;&gt;&gt;&gt;       examples of boilerplate needed to support equatability for some<br>&gt;&gt;&gt;&gt;&gt;       value types, and to Mark Sands for necromancing the<br>&gt;&gt;&gt;&gt;&gt;       swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;       swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;       swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 4:12 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 27.05.2016 18:37, plx via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 1:00 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `deriving` keyword, at the very least, is pretty explicitly *not* an<br>&gt;&gt;&gt; all-or-nothing situation. If you want to define equality/hashability for<br>&gt;&gt;&gt; your type manually, don&#39;t use `deriving`. This should leave the simplest<br>&gt;&gt;&gt; cases to auto generation and anything more complex should be handled by<br>&gt;&gt;&gt; the developer.<br>&gt;&gt; <br>&gt;&gt; It’s all-or-nothing in the sense you can’t use a naive `deriving`<br>&gt;&gt; implementation to assist in any case where what you need is *almost* the<br>&gt;&gt; trivial implementation, but not quite.<br>&gt; <br>&gt; I support that we need a way to exclude some fields from participate in auto-derived code. It is not handy if we&#39;ll have just one-two excluded properties (of 10 for example) and we&#39;ll need to implement the boilerplate code because of this. Probably, this should be another proposal for this feature.<br>&gt; <br></p><p>the fact that other existing systems work that way for years is a good indication that it is a REAL need.<br></p><p><br>&gt; Just some thoughts: such a method to decorate some fields as `nonequatable`/`nonhashable` has no meaning *if* Equatable/Hashable is later implemented manually. So, to remove confusion, it seems like such &#39;method&#39; to exclude should be disallowed(by compiler) if protocols are implemented manually by coder.<br>&gt; I.e., I don&#39;t want to see a code where we have *both* explicit implementations of protocols *and* some decorators/special functions to exclude some fields as this will no any sense.<br>&gt; <br>&gt; Also for me it seems like we need to be able to define such attribute near the field itself, to prevent later errors when you define new field but forgot to add it to some &#39;special list&#39; of excluded field somewhere in code.<br>&gt; So, probably I&#39;d prefer some kind of @nonequatable and @nonhashable :<br>&gt; @nonequatable var field = 0<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Consider a case like this:<br>&gt;&gt; <br>&gt;&gt;  class QuxEvaluator  {<br>&gt;&gt; <br>&gt;&gt;    let foo: Foo // Equatable<br>&gt;&gt;    let bar: Bar // Equatable<br>&gt;&gt;    let baz: Baz // Equatable<br>&gt;&gt; <br>&gt;&gt;    private var quxCache: [QuxIdentifier:Qux] // [Equatable:Equatable] = [:]<br>&gt;&gt; <br>&gt;&gt;    // pure function of `foo`, `bar`, `baz`, and `identifier`<br>&gt;&gt;    // expensive, and uses `quxCache` for memoization<br>&gt;&gt;    func qux(for identifier: QuxIdentifier) -&gt; Qux<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; …if it weren’t for `quxCache` we could easily synthesize `==` for<br>&gt;&gt; `QuxEvaluator`, but the trivial synthesis will yield invalid results due to<br>&gt;&gt; `[QuxIdentifier:Qux]` also being `Equatable` (really: it *will* also be<br>&gt;&gt; equatable once conditional conformances are in place).<br>&gt;&gt; <br>&gt;&gt; So we’re back to e.g. writing this:<br>&gt;&gt; <br>&gt;&gt;  extension QuxEvaluator : Equatable {<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  func ==(lhs: QuxEvaluator, rhs: QuxEvaluator) -&gt; Bool {<br>&gt;&gt;    return (lhs === rhs) || (lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar &amp;&amp;<br>&gt;&gt; lhs.baz == rhs.baz)<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; …just to omit a single field from the `==` consideration; this is another<br>&gt;&gt; sense in which you can say deriving is an all-or-none; there’s just no way<br>&gt;&gt; to invoke the synthesis mechanism other than for &quot;all fields”.<br>&gt;&gt; <br>&gt;&gt; On the one hand, it’s possible to imagine a finer-grained form of this<br>&gt;&gt; synthesis that’d allow you to e.g. indicate a certain field should be<br>&gt;&gt; omitted (and also perhaps specialize how fields are compared, customize the<br>&gt;&gt; synthesized comparison ordering to put cheaper comparisons earlier, and an<br>&gt;&gt; endless list of other possible requests…).<br>&gt;&gt; <br>&gt;&gt; On the other hand, the memberwise-init proposal had a very similar<br>&gt;&gt; situation: the naive approach was arguably too narrow, but it proved very<br>&gt;&gt; difficult to find a workable balance between customization and<br>&gt;&gt; implementation complexity (leaving it postponed for the foreseeable<br>&gt;&gt; future); it’d be a pity if synthesis like this fell into the same trap.<br>&gt;&gt; <br>&gt;&gt; But, on the gripping hand, I highly suspect that a naive<br>&gt;&gt; `deriving`/synthesis will wind up being too narrowly-useful to really<br>&gt;&gt; justify; that’s just my opinion, of course.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 11:20 AM, L. Mihalkovic<br>&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    what i care about is to have a choice about what DEFINES the identity<br>&gt;&gt;&gt;    of my values, not just an all-or-nothing situation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On May 26, 2016, at 5:18 PM, T.J. Usiyan via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    +1 to a `deriving` keyword<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via<br>&gt;&gt;&gt;&gt;    swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Can we just copy&amp;paste the solution from Haskell instead of<br>&gt;&gt;&gt;&gt;        creating our own? It&#39;s just better in every aspect. Deriving<br>&gt;&gt;&gt;&gt;        `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;            ...<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        This has several advantages:<br>&gt;&gt;&gt;&gt;        - you don&#39;t have to guess wether `Equatable` or `Hashable`<br>&gt;&gt;&gt;&gt;        should be automatically derived or not.<br>&gt;&gt;&gt;&gt;        - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;        - If you need a custom `Equatable` implementation (for whatever<br>&gt;&gt;&gt;&gt;        reason), you can still do it.<br>&gt;&gt;&gt;&gt;        - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;        - It can be extended in future versions of Swift, without<br>&gt;&gt;&gt;&gt;        introducing any new incompatibilities. For example,<br>&gt;&gt;&gt;&gt;        `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;        - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt;&gt;&gt;        Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is<br>&gt;&gt;&gt;&gt;        equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used<br>&gt;&gt;&gt;&gt;        as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;`<br>&gt;&gt;&gt;&gt;        would be equatable. Unless something in the definition of<br>&gt;&gt;&gt;&gt;        `Shape` makes deriving `Equatable` impossible =&gt; this produces<br>&gt;&gt;&gt;&gt;        an error.)<br>&gt;&gt;&gt;&gt;        - It is proven to work in production.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution<br>&gt;&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Thanks so much for putting this together, Tony! Glad I was<br>&gt;&gt;&gt;&gt;        able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via<br>&gt;&gt;&gt;&gt;        swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;        &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;        &gt; I was inspired to put together a draft proposal based on an<br>&gt;&gt;&gt;&gt;        older discussion in the Universal Equality, Hashability, and<br>&gt;&gt;&gt;&gt;        Comparability thread<br>&gt;&gt;&gt;&gt;        &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;<br>&gt;&gt;&gt;&gt;        that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; I&#39;m guessing that this would be a significant enough change<br>&gt;&gt;&gt;&gt;        that it&#39;s not possible for the Swift 3 timeline, but it&#39;s<br>&gt;&gt;&gt;&gt;        something that would benefit enough people that I want to make<br>&gt;&gt;&gt;&gt;        sure the discussion stays alive. If there are enough good<br>&gt;&gt;&gt;&gt;        feelings about it, I&#39;ll move it from my gist into an actual<br>&gt;&gt;&gt;&gt;        proposal PR.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;        &gt;       • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;        &gt;       • Status: Awaiting review<br>&gt;&gt;&gt;&gt;        &gt;       • Review manager: TBD<br>&gt;&gt;&gt;&gt;        &gt; Introduction<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Value types are prevalent throughout the Swift language, and<br>&gt;&gt;&gt;&gt;        we encourage developers to think in those terms when writing<br>&gt;&gt;&gt;&gt;        their own types. Frequently, developers find themselves writing<br>&gt;&gt;&gt;&gt;        large amounts of boilerplate code to support equatability and<br>&gt;&gt;&gt;&gt;        hashability of value types. This proposal offers a way for the<br>&gt;&gt;&gt;&gt;        compiler to automatically derive conformance toEquatable and<br>&gt;&gt;&gt;&gt;        Hashable to reduce this boilerplate, in a subset of scenarios<br>&gt;&gt;&gt;&gt;        where generating the correct implementation is likely to be<br>&gt;&gt;&gt;&gt;        possible.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Swift-evolution thread: Universal Equatability, Hashability,<br>&gt;&gt;&gt;&gt;        and Comparability<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Motivation<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Building robust value types in Swift can involve writing<br>&gt;&gt;&gt;&gt;        significant boilerplate code to support concepts of hashability<br>&gt;&gt;&gt;&gt;        and equatability. Equality is pervasive across many value types,<br>&gt;&gt;&gt;&gt;        and for each one users must implement the == operator such that<br>&gt;&gt;&gt;&gt;        it performs a fairly rote memberwise equality test. As an<br>&gt;&gt;&gt;&gt;        example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;          lhs<br>&gt;&gt;&gt;&gt;        &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;          lhs<br>&gt;&gt;&gt;&gt;        &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; ...<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; What&#39;s worse is that this operator must be updated if any<br>&gt;&gt;&gt;&gt;        properties are added, removed, or changed, and since it must be<br>&gt;&gt;&gt;&gt;        manually written, it&#39;s possible to get it wrong, either by<br>&gt;&gt;&gt;&gt;        omission or typographical error.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Likewise, hashability is necessary when one wishes to store a<br>&gt;&gt;&gt;&gt;        value type in a Set or use one as a multi-valuedDictionary key.<br>&gt;&gt;&gt;&gt;        Writing high-quality, well-distributed hash functions is not<br>&gt;&gt;&gt;&gt;        trivial so developers may not put a great deal of thought into<br>&gt;&gt;&gt;&gt;        them – especially as the number of properties increases – not<br>&gt;&gt;&gt;&gt;        realizing that their performance could potentially suffer as a<br>&gt;&gt;&gt;&gt;        result. And as with equality, writing it manually means there is<br>&gt;&gt;&gt;&gt;        the potential to get it wrong.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; In particular, the code that must be written to implement<br>&gt;&gt;&gt;&gt;        equality for enums is quite verbose. One such real-world example<br>&gt;&gt;&gt;&gt;        (source):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; switch<br>&gt;&gt;&gt;&gt;        &gt;  (lhs, rhs) {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let<br>&gt;&gt;&gt;&gt;        rRank , let<br>&gt;&gt;&gt;&gt;        &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;        &gt;  rSuit<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;        &gt;  rFour)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lFour ==<br>&gt;&gt;&gt;&gt;        &gt;  rFour<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;        &gt;  rThree)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lThree ==<br>&gt;&gt;&gt;&gt;        &gt;  rThree<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;        &gt;  rSuit)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;        &gt;  rRank)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;        &gt;  rRank)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lRank ==<br>&gt;&gt;&gt;&gt;        &gt;  rRank<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;        &gt;  lCard),<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;        &gt;  rCard)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let<br>&gt;&gt;&gt;&gt;        lCard2, card3: let<br>&gt;&gt;&gt;&gt;        &gt;  lCard3),<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2,<br>&gt;&gt;&gt;&gt;        card3: let<br>&gt;&gt;&gt;&gt;        &gt;  rCard3)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 ==<br>&gt;&gt;&gt;&gt;        rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard3<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;        &gt;  rCard)):<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return lCard ==<br>&gt;&gt;&gt;&gt;        &gt;  rCard<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; default<br>&gt;&gt;&gt;&gt;        &gt; :<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; return false<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;   }<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Crafting a high-quality hash function for this enum would be<br>&gt;&gt;&gt;&gt;        similarly inconvenient to write, involving another large<br>&gt;&gt;&gt;&gt;        switchstatement.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Swift already provides implicit protocol conformance in some<br>&gt;&gt;&gt;&gt;        cases; notably, enums with raw values conform<br>&gt;&gt;&gt;&gt;        toRawRepresentable, Equatable, and Hashable without the user<br>&gt;&gt;&gt;&gt;        explicitly declaring them:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;        &gt;  {<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case one = 1<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; case two = 2<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; }<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;        &gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;        &gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;        &gt; Since there is precedent for this in Swift, we propose<br>&gt;&gt;&gt;&gt;        extending this support to more value types.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Proposed solution<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; We propose that a value type be Equatable/Hashable if all of<br>&gt;&gt;&gt;&gt;        its members are Equatable/Hashable, with the result for the<br>&gt;&gt;&gt;&gt;        outer type being composed from its members.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Specifically, we propose the following rules for deriving<br>&gt;&gt;&gt;&gt;        Equatable:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • A struct implicitly conforms to Equatable if all of<br>&gt;&gt;&gt;&gt;        its fields are of types that conform to Equatable – either<br>&gt;&gt;&gt;&gt;        explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;        compiler will generate an implementation of ==(lhs: T, rhs:<br>&gt;&gt;&gt;&gt;        T)that returns true if and only if lhs.x == rhs.x for all fields<br>&gt;&gt;&gt;&gt;        x in T.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • An enum implicitly conforms to Equatable if all of its<br>&gt;&gt;&gt;&gt;        associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;        conform to Equatable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;        application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;        implementation of ==(lhs: T, rhs: T) that returns true if and<br>&gt;&gt;&gt;&gt;        only if lhs and rhs are the same case and have payloads that are<br>&gt;&gt;&gt;&gt;        memberwise-equal.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • A struct implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;        fields are of types that conform to Hashable – either<br>&gt;&gt;&gt;&gt;        explicitly, or implicitly by the application of these rules. The<br>&gt;&gt;&gt;&gt;        compiler will generate an implementation of hashValue that uses<br>&gt;&gt;&gt;&gt;        a pre-defined hash function† to compute the hash value of the<br>&gt;&gt;&gt;&gt;        struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Since order of the terms affects the hash value computation,<br>&gt;&gt;&gt;&gt;        we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;       • An enum implicitly conforms to Hashable if all of its<br>&gt;&gt;&gt;&gt;        associated values across all of its cases are of types that<br>&gt;&gt;&gt;&gt;        conform to Hashable – either explicitly, or implicitly by the<br>&gt;&gt;&gt;&gt;        application of these rules. The compiler will generate an<br>&gt;&gt;&gt;&gt;        implementation of hashValue that uses a pre-defined hash<br>&gt;&gt;&gt;&gt;        function† to compute the hash value of an enum value by using<br>&gt;&gt;&gt;&gt;        the case&#39;s ordinal (i.e., definition order) followed by the hash<br>&gt;&gt;&gt;&gt;        values of its associated values as its terms, also in definition<br>&gt;&gt;&gt;&gt;        order.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; † We leave the exact definition of the hash function<br>&gt;&gt;&gt;&gt;        unspecified here; a multiplicative hash function such as<br>&gt;&gt;&gt;&gt;        Kernighan and Ritchie or Bernstein is easy to implement, but we<br>&gt;&gt;&gt;&gt;        do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Overriding defaults<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Any user-provided implementations of == or hashValue should<br>&gt;&gt;&gt;&gt;        override the default implementations that would be provided by<br>&gt;&gt;&gt;&gt;        the compiler. This is already possible today with raw-value<br>&gt;&gt;&gt;&gt;        enums so the same behavior should be extended to other value<br>&gt;&gt;&gt;&gt;        types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Open questions<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Should it be possible to easily omit certain properties from<br>&gt;&gt;&gt;&gt;        automatically generated equality tests or hash value<br>&gt;&gt;&gt;&gt;        computation? This could be valuable, for example, if a property<br>&gt;&gt;&gt;&gt;        is merely used as an internal cache and does not actually<br>&gt;&gt;&gt;&gt;        contribute to the &quot;value&quot; of the instance. Under the rules<br>&gt;&gt;&gt;&gt;        above, if this cached value was equatable, a user would have to<br>&gt;&gt;&gt;&gt;        override == and hashValue and provide their own implementations<br>&gt;&gt;&gt;&gt;        to ignore it. If there is significant evidence that this pattern<br>&gt;&gt;&gt;&gt;        is common and useful, we could consider adding a custom<br>&gt;&gt;&gt;&gt;        attribute, such as @transient, that would omit the property from<br>&gt;&gt;&gt;&gt;        the generated computations.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; As with raw-value enums today, should the derived conformance<br>&gt;&gt;&gt;&gt;        be completely explicit, or should users have to explicitly list<br>&gt;&gt;&gt;&gt;        conformance with Equatable and Hashable in order for the<br>&gt;&gt;&gt;&gt;        compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Impact on existing code<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; This change will have no impact on existing code because it is<br>&gt;&gt;&gt;&gt;        purely additive. Value types that already provide custom<br>&gt;&gt;&gt;&gt;        implementations of == or hashValue but satisfy the rules above<br>&gt;&gt;&gt;&gt;        would keep the custom implementation because it would override<br>&gt;&gt;&gt;&gt;        the compiler-provided default.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Alternatives considered<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; The original discussion thread also included Comparable as a<br>&gt;&gt;&gt;&gt;        candidate for automatic generation. Unlike equatability and<br>&gt;&gt;&gt;&gt;        hashability, however, comparability requires an ordering among<br>&gt;&gt;&gt;&gt;        the members being compared. Automatically using the definition<br>&gt;&gt;&gt;&gt;        order here might be too surprising for users, but worse, it also<br>&gt;&gt;&gt;&gt;        means that reordering properties in the source code changes the<br>&gt;&gt;&gt;&gt;        code&#39;s behavior at runtime. (This is true for hashability as<br>&gt;&gt;&gt;&gt;        well if a multiplicative hash function is used, but hash values<br>&gt;&gt;&gt;&gt;        are not intended to be persistent and reordering the terms does<br>&gt;&gt;&gt;&gt;        not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Acknowledgments<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; Thanks to Joe Groff for spinning off the original discussion<br>&gt;&gt;&gt;&gt;        thread, Jose Cheyo Jimenez for providing great real-world<br>&gt;&gt;&gt;&gt;        examples of boilerplate needed to support equatability for some<br>&gt;&gt;&gt;&gt;        value types, and to Mark Sands for necromancing the<br>&gt;&gt;&gt;&gt;        swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt;<br>&gt;&gt;&gt;&gt;        &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30ea8887f16ee8e189bc651adfcb8896?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Frank Ecsedy</string> &lt;fecsedy at gmail.com&gt;<p>May 30, 2016 at 11:00:00am</p></header><div class="content"><p>In Java I would use Project Lombok&#39;s @EqualsAndHashCode annotation on a<br>class. Caveats:<br></p><p>1. Swift is not Java and that&#39;s a good thing (TM).<br>2. Project Lombok is not Java, either.<br>3. &#39;deriving Equatable, Hashable&#39; makes those interfaces &#39;magic&#39;. Is that<br>good?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/bc595f35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 30, 2016 at 09:00:00pm</p></header><div class="content"><p>It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br></p><p>I think I chose an easy strategy when proposing the `deriving` keyword. Haskell is a mature language, and &quot;copying&quot; a feature from them is usually a safe choice. For each language feature, someone has to think through all the implications of it; this is usually far from trivial. I argue that if I take a feature from another language, someone has probably already thought about all the pros and cons of different solutions. This is just a plea for embracing precedent.<br></p><p>There is one advantage of method 2 that (I think) hasn&#39;t been discussed so far: when you declare a type `S`, and an `Equatable` instance is automatically derived, there is no way to override that instance in another module. With method 1, there is also no way to request that an `Equatable` instance should *not* be generated. I think no one will vote for something like `struct S @notderiving(Equateble,Hashable) { ... }`.<br></p><p>Also, a `deriving` keyword is less magical than just automatically deriving `Equatable` and `Hashable` instances. I think the language rules should be as simple as possible, by default. If you want any kind of special behavior, you have to ask for it: `deriving Equatable`, `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the developer is aware that there is an &quot;==&quot; method somewhere, specifically for this new type. The compiler should not arbitrarily create methods, because someone may need them. Even if it is very likely that you will need them. Just like in a coffee house, you are asked if you want a coffee, even if you are visiting it every day. For example with Objective-C, I want each developer to be aware of the difference between a property and an iVar, and be aware of the connection between properties, methods, and key-value-coding. The complexities of the language shouldn&#39;t be hidden completely.<br></p><p>Just my two cents..<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 10:00:00pm</p></header><div class="content"><p>Seems to me like a heavy weight solution to invent a special keyword that will be applicable to 2 protocols in the entire standard library. <br></p><p>If I am not mistaken, the Swift philosophy seems to be that Protocols carry the meaning, not how we apply them. So in this instance, something like the following might convey the meaning of both equality, and how the compiler should assist.<br></p><p>public protocol Equatable {<br>    @warn_unused_result<br>    public func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p><br>/// Declaring conformance to this protocol results in the compiler<br>/// automatically generating a deep-equal between each members of<br>/// the conforming instances<br>public protocol AutoDeepEquatable : Equatable {<br>}<br></p><p>/// Declaring conformance to this protocol results in the compiler<br>/// automatically generating a shallow-equal between each members <br>/// of the conforming instances<br>public protocol AutoShallowEquatable : Equatable {<br>}<br></p><p><br></p><p><br>&gt; On May 30, 2016, at 9:04 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br>&gt; <br>&gt; I think I chose an easy strategy when proposing the `deriving` keyword. Haskell is a mature language, and &quot;copying&quot; a feature from them is usually a safe choice. For each language feature, someone has to think through all the implications of it; this is usually far from trivial. I argue that if I take a feature from another language, someone has probably already thought about all the pros and cons of different solutions. This is just a plea for embracing precedent.<br>&gt; <br>&gt; There is one advantage of method 2 that (I think) hasn&#39;t been discussed so far: when you declare a type `S`, and an `Equatable` instance is automatically derived, there is no way to override that instance in another module. With method 1, there is also no way to request that an `Equatable` instance should *not* be generated. I think no one will vote for something like `struct S @notderiving(Equateble,Hashable) { ... }`.<br>&gt; <br>&gt; Also, a `deriving` keyword is less magical than just automatically deriving `Equatable` and `Hashable` instances. I think the language rules should be as simple as possible, by default. If you want any kind of special behavior, you have to ask for it: `deriving Equatable`, `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the developer is aware that there is an &quot;==&quot; method somewhere, specifically for this new type. The compiler should not arbitrarily create methods, because someone may need them. Even if it is very likely that you will need them. Just like in a coffee house, you are asked if you want a coffee, even if you are visiting it every day. For example with Objective-C, I want each developer to be aware of the difference between a property and an iVar, and be aware of the connection between properties, methods, and key-value-coding. The complexities of the language shouldn&#39;t be hidden completely.<br>&gt; <br>&gt; Just my two cents..<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/49795945/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I see these two groups: both wants explicit conformance to protocols, but <br>first thinks that current syntax is enough (`: Equatable`) and second <br>thinks we should introduce new keyword `deriving` for this(`: deriving <br>Equatable`). I see no opinions(except the one opinion in proposal itself) <br>to automatically deriving without explicit decoration.<br></p><p>On 30.05.2016 22:04, Michael Peternell via swift-evolution wrote:<br>&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br>&gt;<br>&gt; I think I chose an easy strategy when proposing the `deriving` keyword. Haskell is a mature language, and &quot;copying&quot; a feature from them is usually a safe choice. For each language feature, someone has to think through all the implications of it; this is usually far from trivial. I argue that if I take a feature from another language, someone has probably already thought about all the pros and cons of different solutions. This is just a plea for embracing precedent.<br>&gt;<br>&gt; There is one advantage of method 2 that (I think) hasn&#39;t been discussed so far: when you declare a type `S`, and an `Equatable` instance is automatically derived, there is no way to override that instance in another module. With method 1, there is also no way to request that an `Equatable` instance should *not* be generated. I think no one will vote for something like `struct S @notderiving(Equateble,Hashable) { ... }`.<br>&gt;<br>&gt; Also, a `deriving` keyword is less magical than just automatically deriving `Equatable` and `Hashable` instances. I think the language rules should be as simple as possible, by default. If you want any kind of special behavior, you have to ask for it: `deriving Equatable`, `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the developer is aware that there is an &quot;==&quot; method somewhere, specifically for this new type. The compiler should not arbitrarily create methods, because someone may need them. Even if it is very likely that you will need them. Just like in a coffee house, you are asked if you want a coffee, even if you are visiting it every day. For example with Objective-C, I want each developer to be aware of the difference between a property and an iVar, and be aware of the connection between properties, methods, and key-value-coding. The complexities of the language shouldn&#39;t be hidden completely.<br>&gt;<br>&gt; Just my two cents..<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 30, 2016 at 03:00:00pm</p></header><div class="content"><p>What about declaring the requirements for auto-conformance in a sub-protocol?<br>@auto protocol AutoEquatable : Equatable {<br>    //&quot;syntax&quot; for how to conform to Equatable<br>}<br></p><p>struct Foo : AutoEquatable {} //the compiler automatically synthesizes everything<br>struct Bar : Equatable {} //you manually conform<br></p><p>It would be a compiler error to conform to an `@auto` protocol if the compiler couldn&#39;t apply the provided &quot;syntax&quot; to the conforming type.<br></p><p>(I have no clue what this &quot;syntax&quot; could be, other than some expansion of generics and/or a macro system)<br></p><p>Anyway, does that help? It satisfies both the &quot;explicit conformance&quot; crowd and the &quot;no new keywords&quot; (at least at the &quot;call&quot; site) crowd.<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 30, 2016, at 15:26, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I see these two groups: both wants explicit conformance to protocols, but first thinks that current syntax is enough (`: Equatable`) and second thinks we should introduce new keyword `deriving` for this(`: deriving Equatable`). I see no opinions(except the one opinion in proposal itself) to automatically deriving without explicit decoration.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 12:00:00am</p></header><div class="content"><p>In case we discuss this feature not for just value types but for classes <br>also - will such AutoEquatable allows to implement protocol manually?<br></p><p>Now we can have:<br></p><p>func == (lhs: A, rhs: A) -&gt; Bool { return true }<br>class A: Hashable { var hashValue: Int { return 100 } }<br>class B: A { override var hashValue: Int { return 200 } }<br></p><p>So, if we&#39;ll have<br>class A: AutoHashable { }<br>or<br>class A: deriving Hashable { }<br>will we be able to have:<br>class B: A { override var hashValue: Int { return 200 } }<br>?<br></p><p>(The same question was for `deriving` proposal)<br>Please note that we probably don&#39;t want/have no rights to modify the <br>definition of class A.<br></p><p>There is no such question for auto-derived Hashable in case of simple <br>conformance as we do now `class A: Hashable`.<br></p><p>On 30.05.2016 23:45, David Sweeris wrote:<br>&gt; What about declaring the requirements for auto-conformance in a sub-protocol?<br>&gt; @auto protocol AutoEquatable : Equatable {<br>&gt;     //&quot;syntax&quot; for how to conform to Equatable<br>&gt; }<br>&gt;<br>&gt; struct Foo : AutoEquatable {} //the compiler automatically synthesizes everything<br>&gt; struct Bar : Equatable {} //you manually conform<br>&gt;<br>&gt; It would be a compiler error to conform to an `@auto` protocol if the compiler couldn&#39;t apply the provided &quot;syntax&quot; to the conforming type.<br>&gt;<br>&gt; (I have no clue what this &quot;syntax&quot; could be, other than some expansion of generics and/or a macro system)<br>&gt;<br>&gt; Anyway, does that help? It satisfies both the &quot;explicit conformance&quot; crowd and the &quot;no new keywords&quot; (at least at the &quot;call&quot; site) crowd.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt;&gt; On May 30, 2016, at 15:26, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I see these two groups: both wants explicit conformance to protocols, but first thinks that current syntax is enough (`: Equatable`) and second thinks we should introduce new keyword `deriving` for this(`: deriving Equatable`). I see no opinions(except the one opinion in proposal itself) to automatically deriving without explicit decoration.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 30, 2016 at 04:00:00pm</p></header><div class="content"><p>If you&#39;re asking me, it depends on what gets filled in for &quot;syntax&quot;. I see no reason to explicitly prohibit classes from participating, though.<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 30, 2016, at 16:12, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; In case we discuss this feature not for just value types but for classes also - will such AutoEquatable allows to implement protocol manually?<br>&gt; <br>&gt; Now we can have:<br>&gt; <br>&gt; func == (lhs: A, rhs: A) -&gt; Bool { return true }<br>&gt; class A: Hashable { var hashValue: Int { return 100 } }<br>&gt; class B: A { override var hashValue: Int { return 200 } }<br>&gt; <br>&gt; So, if we&#39;ll have<br>&gt; class A: AutoHashable { }<br>&gt; or<br>&gt; class A: deriving Hashable { }<br>&gt; will we be able to have:<br>&gt; class B: A { override var hashValue: Int { return 200 } }<br>&gt; ?<br>&gt; <br>&gt; (The same question was for `deriving` proposal)<br>&gt; Please note that we probably don&#39;t want/have no rights to modify the definition of class A.<br>&gt; <br>&gt; There is no such question for auto-derived Hashable in case of simple conformance as we do now `class A: Hashable`.<br>&gt; <br>&gt;&gt; On 30.05.2016 23:45, David Sweeris wrote:<br>&gt;&gt; What about declaring the requirements for auto-conformance in a sub-protocol?<br>&gt;&gt; @auto protocol AutoEquatable : Equatable {<br>&gt;&gt;    //&quot;syntax&quot; for how to conform to Equatable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Foo : AutoEquatable {} //the compiler automatically synthesizes everything<br>&gt;&gt; struct Bar : Equatable {} //you manually conform<br>&gt;&gt; <br>&gt;&gt; It would be a compiler error to conform to an `@auto` protocol if the compiler couldn&#39;t apply the provided &quot;syntax&quot; to the conforming type.<br>&gt;&gt; <br>&gt;&gt; (I have no clue what this &quot;syntax&quot; could be, other than some expansion of generics and/or a macro system)<br>&gt;&gt; <br>&gt;&gt; Anyway, does that help? It satisfies both the &quot;explicit conformance&quot; crowd and the &quot;no new keywords&quot; (at least at the &quot;call&quot; site) crowd.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On May 30, 2016, at 15:26, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see these two groups: both wants explicit conformance to protocols, but first thinks that current syntax is enough (`: Equatable`) and second thinks we should introduce new keyword `deriving` for this(`: deriving Equatable`). I see no opinions(except the one opinion in proposal itself) to automatically deriving without explicit decoration.<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Michael Peternell</string> &lt;Michael.Peternell at gmx.at&gt;<p>May 31, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;m not a fan of AutoEquatable or AutoHashable. These protocols suggest that automatic conformance can be defined in the language itself and that derived protocol instances don&#39;t have to be implemented as compiler intrinsics. That&#39;s just not the case. You cannot define something like<br></p><p>@auto protocol AutoEquatable : Equatable {<br>   ...<br>}<br></p><p>because what would you write instead of &quot;...&quot;? Copy Lisp-Macros? Copy Template-Haskell? I don&#39;t really need to disagree here, I could just say &quot;good idea, do you want to make a proposal for this?&quot; and then I will never hear again anything from this idea, because no one will be able to write the &quot;detailed design&quot; section of that proposal. (at least, I don&#39;t know how to design such a feature; the solution space looks empty to me. there are similar issues with &quot;property behaviors&quot; IMHO, but that&#39;s another story.)<br></p><p>Second, there is no point in &quot;prohibiting&quot; any protocols from being &quot;derived&quot;. But deriving will only work for protocols for which someone has implemented a deriving algorithm. And that algorithm has to be implemented in the compiler. I think `Comparable`, `CustomStringConvertible` would be good candidates for deriving too. The whole point of all of this is to reduce boilerplate code that is trivial to write, and also error-prone because no one wants to read that boring code carefully (e.g. a custom to-string-function for an enum with 30 cases, that just returns the name of the symbol and that has to be extended each time another case is added: `case Foo1: return &quot;Foo1&quot;; case Bla: return &quot;Bla&quot;; ...`).<br></p><p>Third, what is the difference between &quot;deep equality&quot; (AutoDeepEquatable) and &quot;shallow equality&quot; (AutoShallowEquatable)?<br></p><p>(A tiny bit) sorry for bashing any other opinions... :-/ But, a solution has to 1) work, 2) be practical, 3) be implementable, 4) have a possible detailed design that is not overly baroque, 5) shouldn&#39;t have funny edge cases that will disturb users as soon as the feature is used widely.<br></p><p>But since this feature is out-of-scope for Swift 3 anyways, we now have plenty of time resolving all these issues.. I may try to write a proposal later this year, after Swift 3 has been released. Thanks to everyone who participated in the discussion.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; I&#39;m not a fan of AutoEquatable or AutoHashable. These protocols suggest that automatic conformance can be defined in the language itself and that derived protocol instances don&#39;t have to be implemented as compiler intrinsics. That&#39;s just not the case. You cannot define something like<br>&gt; <br>&gt; @auto protocol AutoEquatable : Equatable {<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; because what would you write instead of &quot;...&quot;? Copy Lisp-Macros? Copy Template-Haskell? I don&#39;t really need to disagree here, I could just say &quot;good idea, do you want to make a proposal for this?&quot; and then I will never hear again anything from this idea, because no one will be able to write the &quot;detailed design&quot; section of that proposal. (at least, I don&#39;t know how to design such a feature; the solution space looks empty to me. there are similar issues with &quot;property behaviors&quot; IMHO, but that&#39;s another story.)<br></p><p>Actually, I believe you could write a version of AutoEquatable merely by adding a couple items from the generics manifesto:<br></p><p>	protocol AutoEquatable: Equatable {}<br>	<br>	func == &lt;T: AutoEquatable&gt; (lhs: T, rhs: T) -&gt; Bool {<br>		let lhsMirror = Mirror(reflecting: lhs)<br>		let rhsMirror = Mirror(reflecting: rhs)<br>		<br>		for ((lhsLabel, lhsValue), (rhsLabel, rhsValue)) in zip(lhs.children, rhs.children) {<br>			guard lhsLabel == rhsLabel else { return false }<br>			<br>			guard let lhsValue = (lhsValue as! Equatable) openas U else { return false }<br>			guard let rhsValue = rhsValue as? U else { return false }<br>			guard lhsValue == rhsValue else { return false }<br>		}<br>		<br>		return true<br>	}<br></p><p>This is not the all-powerful code-generation-based solution everyone&#39;s pining for, of course. But (modulo a few bugs stemming from this being a proof of concept) it *would* work. If the compiler occasionally decides to write a more specialized equivalent, well, that&#39;s its prerogative, right?<br></p><p>(In a recent thread on property reflection, I discussed the possibility of attaching lists of properties to types, with property behaviors being used to add properties to the lists. That would actually work better than `Mirror` for this task, but it&#39;s a more speculative feature.)<br></p><p>As for an eventual compile-time-generated implementation, well, that kind of thing *does* seem to be on the design team&#39;s radar. We&#39;ve already seen a concrete proposal along those lines in property behaviors; I could imagine a &quot;type behaviors&quot; feature being introduced in the future which could introspect a type and generate new members based on what it sees. And generalized hygienic macros keep coming up too. Just because they aren&#39;t in Swift 3 doesn&#39;t mean we can&#39;t design as though they&#39;ll be here eventually.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 11:00:00am</p></header><div class="content"><p>If Swift is to be used for serious data handling, might as well learn from the java early errors and directly go highly optimized intrinsic code for this type of features: even phones have very good vectorized instructions ... would be tragic to use run of the mill gereral purpose code instead<br></p><p>On May 31, 2016, at 9:03 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; I&#39;m not a fan of AutoEquatable or AutoHashable. These protocols suggest that automatic conformance can be defined in the language itself and that derived protocol instances don&#39;t have to be implemented as compiler intrinsics. That&#39;s just not the case. You cannot define something like<br>&gt;&gt; <br>&gt;&gt; @auto protocol AutoEquatable : Equatable {<br>&gt;&gt;  ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; because what would you write instead of &quot;...&quot;? Copy Lisp-Macros? Copy Template-Haskell? I don&#39;t really need to disagree here, I could just say &quot;good idea, do you want to make a proposal for this?&quot; and then I will never hear again anything from this idea, because no one will be able to write the &quot;detailed design&quot; section of that proposal. (at least, I don&#39;t know how to design such a feature; the solution space looks empty to me. there are similar issues with &quot;property behaviors&quot; IMHO, but that&#39;s another story.)<br>&gt; <br>&gt; Actually, I believe you could write a version of AutoEquatable merely by adding a couple items from the generics manifesto:<br>&gt; <br>&gt;    protocol AutoEquatable: Equatable {}<br>&gt;    <br>&gt;    func == &lt;T: AutoEquatable&gt; (lhs: T, rhs: T) -&gt; Bool {<br>&gt;        let lhsMirror = Mirror(reflecting: lhs)<br>&gt;        let rhsMirror = Mirror(reflecting: rhs)<br>&gt;        <br>&gt;        for ((lhsLabel, lhsValue), (rhsLabel, rhsValue)) in zip(lhs.children, rhs.children) {<br>&gt;            guard lhsLabel == rhsLabel else { return false }<br>&gt;            <br>&gt;            guard let lhsValue = (lhsValue as! Equatable) openas U else { return false }<br>&gt;            guard let rhsValue = rhsValue as? U else { return false }<br>&gt;            guard lhsValue == rhsValue else { return false }<br>&gt;        }<br>&gt;        <br>&gt;        return true<br>&gt;    }<br>&gt; <br>&gt; This is not the all-powerful code-generation-based solution everyone&#39;s pining for, of course. But (modulo a few bugs stemming from this being a proof of concept) it *would* work. If the compiler occasionally decides to write a more specialized equivalent, well, that&#39;s its prerogative, right?<br>&gt; <br>&gt; (In a recent thread on property reflection, I discussed the possibility of attaching lists of properties to types, with property behaviors being used to add properties to the lists. That would actually work better than `Mirror` for this task, but it&#39;s a more speculative feature.)<br>&gt; <br>&gt; As for an eventual compile-time-generated implementation, well, that kind of thing *does* seem to be on the design team&#39;s radar. We&#39;ve already seen a concrete proposal along those lines in property behaviors; I could imagine a &quot;type behaviors&quot; feature being introduced in the future which could introspect a type and generate new members based on what it sees. And generalized hygienic macros keep coming up too. Just because they aren&#39;t in Swift 3 doesn&#39;t mean we can&#39;t design as though they&#39;ll be here eventually.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 31, 2016 at 09:00:00am</p></header><div class="content"><p>Yes exactly, use the protocol conformance syntax, Michael’s description was mistaken I think.<br></p><p>Just the same way you get protocol extensions without having to use a special keyword.<br></p><p><br>&gt; On 31 May 2016, at 6:26 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I see these two groups: both wants explicit conformance to protocols, but first thinks that current syntax is enough (`: Equatable`) and second thinks we should introduce new keyword `deriving` for this(`: deriving Equatable`). I see no opinions(except the one opinion in proposal itself) to automatically deriving without explicit decoration.<br>&gt; <br>&gt; On 30.05.2016 22:04, Michael Peternell via swift-evolution wrote:<br>&gt;&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br>&gt;&gt; <br>&gt;&gt; I think I chose an easy strategy when proposing the `deriving` keyword. Haskell is a mature language, and &quot;copying&quot; a feature from them is usually a safe choice. For each language feature, someone has to think through all the implications of it; this is usually far from trivial. I argue that if I take a feature from another language, someone has probably already thought about all the pros and cons of different solutions. This is just a plea for embracing precedent.<br>&gt;&gt; <br>&gt;&gt; There is one advantage of method 2 that (I think) hasn&#39;t been discussed so far: when you declare a type `S`, and an `Equatable` instance is automatically derived, there is no way to override that instance in another module. With method 1, there is also no way to request that an `Equatable` instance should *not* be generated. I think no one will vote for something like `struct S @notderiving(Equateble,Hashable) { ... }`.<br>&gt;&gt; <br>&gt;&gt; Also, a `deriving` keyword is less magical than just automatically deriving `Equatable` and `Hashable` instances. I think the language rules should be as simple as possible, by default. If you want any kind of special behavior, you have to ask for it: `deriving Equatable`, `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the developer is aware that there is an &quot;==&quot; method somewhere, specifically for this new type. The compiler should not arbitrarily create methods, because someone may need them. Even if it is very likely that you will need them. Just like in a coffee house, you are asked if you want a coffee, even if you are visiting it every day. For example with Objective-C, I want each developer to be aware of the difference between a property and an iVar, and be aware of the connection between properties, methods, and key-value-coding. The complexities of the language shouldn&#39;t be hidden completely.<br>&gt;&gt; <br>&gt;&gt; Just my two cents..<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Mark Sands</string> &lt;marksands07 at gmail.com&gt;<p>May 30, 2016 at 07:00:00pm</p></header><div class="content"><p>In light of Chris and Dave&#39;s responses about how this discussion will be mostly absent of core team members until Swift 3 is more or less wrapped up, perhaps we should let this thread sit idle until then. As the original necromancer, I&#39;m sure this will be brought back to life when it&#39;s appropriate.<br></p><p>Mark<br></p><p>&gt; On May 30, 2016, at 18:23, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes exactly, use the protocol conformance syntax, Michael’s description was mistaken I think.<br>&gt; <br>&gt; Just the same way you get protocol extensions without having to use a special keyword.<br>&gt; <br>&gt; <br>&gt;&gt; On 31 May 2016, at 6:26 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I see these two groups: both wants explicit conformance to protocols, but first thinks that current syntax is enough (`: Equatable`) and second thinks we should introduce new keyword `deriving` for this(`: deriving Equatable`). I see no opinions(except the one opinion in proposal itself) to automatically deriving without explicit decoration.<br>&gt;&gt; <br>&gt;&gt;&gt; On 30.05.2016 22:04, Michael Peternell via swift-evolution wrote:<br>&gt;&gt;&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I chose an easy strategy when proposing the `deriving` keyword. Haskell is a mature language, and &quot;copying&quot; a feature from them is usually a safe choice. For each language feature, someone has to think through all the implications of it; this is usually far from trivial. I argue that if I take a feature from another language, someone has probably already thought about all the pros and cons of different solutions. This is just a plea for embracing precedent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is one advantage of method 2 that (I think) hasn&#39;t been discussed so far: when you declare a type `S`, and an `Equatable` instance is automatically derived, there is no way to override that instance in another module. With method 1, there is also no way to request that an `Equatable` instance should *not* be generated. I think no one will vote for something like `struct S @notderiving(Equateble,Hashable) { ... }`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, a `deriving` keyword is less magical than just automatically deriving `Equatable` and `Hashable` instances. I think the language rules should be as simple as possible, by default. If you want any kind of special behavior, you have to ask for it: `deriving Equatable`, `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the developer is aware that there is an &quot;==&quot; method somewhere, specifically for this new type. The compiler should not arbitrarily create methods, because someone may need them. Even if it is very likely that you will need them. Just like in a coffee house, you are asked if you want a coffee, even if you are visiting it every day. For example with Objective-C, I want each developer to be aware of the difference between a property and an iVar, and be aware of the connection between properties, methods, and key-value-coding. The complexities of the language shouldn&#39;t be hidden completely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just my two cents..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 12:04 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and others) be derived automatically unless specifically overridden: similar to auto-synthesis of properties in Objective-C. 2) The other group (Group 2) wants Equatable (and others) be derived explicitly using a `deriving` keyword (or something semantically equivalent). Unless I missed something, there were no voices for keeping the status quo, and not introducing any process to automatically derive these protocols.<br></p><p>FWIW, I’m pretty firmly in “camp 2” by the definition above.<br></p><p>That said, any work in this area is significantly outside the scope of what we can do in Swift 3, so I can’t engage in further discussion until we can get past the things that are pressing and critical for this release.  PRs for an evolution proposal along these lines won’t be accepted until Swift 3 is winding way down, and at that point, we’ll have to have the whole “pitch” discussion again.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Is there no one that thinks it&#39;s sufficient if users can create a tuple<br>from a list of properties and reuse tuple equality and hash?<br></p><p>Is there no one that thinks it&#39;s sufficient if the system were to supply a<br>named function for comparing two Any&#39;s for equality (with reference<br>equality semantics for reference types, bit equality for value types) that<br>users could use in their type&#39;s implementations of ==?<br></p><p>Is there no one that thinks the opt-in mechanism should be a call to a<br>system supplied function, instead of coming up with new keywords or opting<br>in directly through the protocol?<br>(Well I know there&#39;s at least one person that thinks the opt in mechanism<br>should be by calling a function)<br></p><p>-- Callionica<br></p><p>On Mon, May 30, 2016 at 12:04 PM, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It seems that there are two groups here. 1) Group 1 wants Equatable (and<br>&gt; others) be derived automatically unless specifically overridden: similar to<br>&gt; auto-synthesis of properties in Objective-C. 2) The other group (Group 2)<br>&gt; wants Equatable (and others) be derived explicitly using a `deriving`<br>&gt; keyword (or something semantically equivalent). Unless I missed something,<br>&gt; there were no voices for keeping the status quo, and not introducing any<br>&gt; process to automatically derive these protocols.<br>&gt;<br>&gt; I think I chose an easy strategy when proposing the `deriving` keyword.<br>&gt; Haskell is a mature language, and &quot;copying&quot; a feature from them is usually<br>&gt; a safe choice. For each language feature, someone has to think through all<br>&gt; the implications of it; this is usually far from trivial. I argue that if I<br>&gt; take a feature from another language, someone has probably already thought<br>&gt; about all the pros and cons of different solutions. This is just a plea for<br>&gt; embracing precedent.<br>&gt;<br>&gt; There is one advantage of method 2 that (I think) hasn&#39;t been discussed so<br>&gt; far: when you declare a type `S`, and an `Equatable` instance is<br>&gt; automatically derived, there is no way to override that instance in another<br>&gt; module. With method 1, there is also no way to request that an `Equatable`<br>&gt; instance should *not* be generated. I think no one will vote for something<br>&gt; like `struct S @notderiving(Equateble,Hashable) { ... }`.<br>&gt;<br>&gt; Also, a `deriving` keyword is less magical than just automatically<br>&gt; deriving `Equatable` and `Hashable` instances. I think the language rules<br>&gt; should be as simple as possible, by default. If you want any kind of<br>&gt; special behavior, you have to ask for it: `deriving Equatable`,<br>&gt; `@IBOutlet`, `@NSManaged`. Furthermore, I think it is good that the<br>&gt; developer is aware that there is an &quot;==&quot; method somewhere, specifically for<br>&gt; this new type. The compiler should not arbitrarily create methods, because<br>&gt; someone may need them. Even if it is very likely that you will need them.<br>&gt; Just like in a coffee house, you are asked if you want a coffee, even if<br>&gt; you are visiting it every day. For example with Objective-C, I want each<br>&gt; developer to be aware of the difference between a property and an iVar, and<br>&gt; be aware of the connection between properties, methods, and<br>&gt; key-value-coding. The complexities of the language shouldn&#39;t be hidden<br>&gt; completely.<br>&gt;<br>&gt; Just my two cents..<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/f4e02d68/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>I agree.<br></p><p>This also isn&#39;t the only case where a &#39;deriving&#39; keyword would come in handy. I&#39;m mulling a proposal for a compiler-derived enum, and I worried the magic-ness of it would face strong opposition. Having a &#39;deriving&#39; keyword is the perfect solution, since it becomes explicit.<br></p><p><br></p><p>&gt; On May 26, 2016, at 11:18 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to a `deriving` keyword<br>&gt; <br>&gt; On Thu, May 26, 2016 at 3:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt; <br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt; - It is proven to work in production.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; &gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; &gt;<br>&gt; &gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt; &gt;<br>&gt; &gt; Automatically deriving Equatable andHashable for value types<br>&gt; &gt;<br>&gt; &gt;       • Proposal: SE-0000<br>&gt; &gt;       • Author(s): Tony Allevato<br>&gt; &gt;       • Status: Awaiting review<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property2 == rhs.property2 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;          lhs<br>&gt; &gt; .property3 == rhs.property3 &amp;&amp;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt; &gt;<br>&gt; &gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt; &gt;<br>&gt; &gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; switch<br>&gt; &gt;  (lhs, rhs) {<br>&gt; &gt;<br>&gt; &gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt; &gt;  rSuit<br>&gt; &gt;<br>&gt; &gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt; &gt;  rFour)):<br>&gt; &gt;<br>&gt; &gt; return lFour ==<br>&gt; &gt;  rFour<br>&gt; &gt;<br>&gt; &gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt; &gt;  rThree)):<br>&gt; &gt;<br>&gt; &gt; return lThree ==<br>&gt; &gt;  rThree<br>&gt; &gt;<br>&gt; &gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt; &gt;  rSuit)):<br>&gt; &gt;<br>&gt; &gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.straight(high: let lRank), .straight(high: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt; &gt;  rRank)):<br>&gt; &gt;<br>&gt; &gt; return lRank ==<br>&gt; &gt;  rRank<br>&gt; &gt;<br>&gt; &gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt; &gt;  lCard),<br>&gt; &gt;<br>&gt; &gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt; &gt;  lCard3),<br>&gt; &gt;<br>&gt; &gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt; &gt;  rCard3)):<br>&gt; &gt;<br>&gt; &gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt; &gt;  rCard3<br>&gt; &gt;<br>&gt; &gt; case (.highCard(let lCard), .highCard(let<br>&gt; &gt;  rCard)):<br>&gt; &gt;<br>&gt; &gt; return lCard ==<br>&gt; &gt;  rCard<br>&gt; &gt;<br>&gt; &gt; default<br>&gt; &gt; :<br>&gt; &gt;<br>&gt; &gt; return false<br>&gt; &gt;<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt; &gt;<br>&gt; &gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt; &gt;<br>&gt; &gt; enum Foo: Int<br>&gt; &gt;  {<br>&gt; &gt;<br>&gt; &gt; case one = 1<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; case two = 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; let x = (Foo.one == Foo.two)  // works<br>&gt; &gt; let y = Foo.one.hashValue     // also works<br>&gt; &gt; let z = Foo.one.rawValue      // also also works<br>&gt; &gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt; &gt;<br>&gt; &gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt; &gt;<br>&gt; &gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt; &gt;<br>&gt; &gt;       • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt; &gt;<br>&gt; &gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt; &gt;<br>&gt; &gt;       • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt; &gt;<br>&gt; &gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt; &gt;<br>&gt; &gt; Overriding defaults<br>&gt; &gt;<br>&gt; &gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt; &gt;<br>&gt; &gt; Open questions<br>&gt; &gt;<br>&gt; &gt; Omission of fields from generated computations<br>&gt; &gt;<br>&gt; &gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; &gt;<br>&gt; &gt; Explicit or implicit derivation<br>&gt; &gt;<br>&gt; &gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt; &gt;<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt; &gt;<br>&gt; &gt; Acknowledgments<br>&gt; &gt;<br>&gt; &gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/8ffb9f89/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I wonder if synthesizes would be a better choice than deriving. <br></p><p><br></p><p>&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt; <br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt; - It is proven to work in production.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt; <br>&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt; <br>&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt; <br>&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;    • Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt; <br>&gt;&gt;         lhs<br>&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt; <br>&gt;&gt;         lhs<br>&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt; <br>&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt; <br>&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; switch<br>&gt;&gt; (lhs, rhs) {<br>&gt;&gt; <br>&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt; rSuit)):<br>&gt;&gt; <br>&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt; rSuit<br>&gt;&gt; <br>&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt; rFour)):<br>&gt;&gt; <br>&gt;&gt; return lFour ==<br>&gt;&gt; rFour<br>&gt;&gt; <br>&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt; rThree)):<br>&gt;&gt; <br>&gt;&gt; return lThree ==<br>&gt;&gt; rThree<br>&gt;&gt; <br>&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt; rSuit)):<br>&gt;&gt; <br>&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt; rRank<br>&gt;&gt; <br>&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt; rRank)):<br>&gt;&gt; <br>&gt;&gt; return lRank ==<br>&gt;&gt; rRank<br>&gt;&gt; <br>&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt; rRank)):<br>&gt;&gt; <br>&gt;&gt; return lRank ==<br>&gt;&gt; rRank<br>&gt;&gt; <br>&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt; lCard),<br>&gt;&gt; <br>&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt; rCard)):<br>&gt;&gt; <br>&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt; rCard<br>&gt;&gt; <br>&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt; lCard3),<br>&gt;&gt; <br>&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt; rCard3)):<br>&gt;&gt; <br>&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt; rCard3<br>&gt;&gt; <br>&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt; rCard)):<br>&gt;&gt; <br>&gt;&gt; return lCard ==<br>&gt;&gt; rCard<br>&gt;&gt; <br>&gt;&gt; default<br>&gt;&gt; :<br>&gt;&gt; <br>&gt;&gt; return false<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt; <br>&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt; <br>&gt;&gt; enum Foo: Int<br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; case one = 1<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; case two = 2<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt; <br>&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt; <br>&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt; <br>&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt; <br>&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt; <br>&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt; <br>&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt; <br>&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt; <br>&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt; <br>&gt;&gt; Overriding defaults<br>&gt;&gt; <br>&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt; <br>&gt;&gt; Open questions<br>&gt;&gt; <br>&gt;&gt; Omission of fields from generated computations<br>&gt;&gt; <br>&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt; <br>&gt;&gt; Explicit or implicit derivation<br>&gt;&gt; <br>&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt; <br>&gt;&gt; Acknowledgments<br>&gt;&gt; <br>&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/68f4bafe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>I don’t understand why you couldn’t conform to Equatable, and if it fulfils the requirements (all members are also Equatable), then its implementation is automatically created for you. That way you don’t need a new keyword. It’s like Objective-C’s property automatic synthesising that get used unless you implement ones yourself.<br></p><p><br>&gt; On 27 May 2016, at 12:57 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt; <br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch<br>&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt; rFour<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt; rThree<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt; rCard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt; rCard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; default<br>&gt;&gt;&gt; :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/26a8671c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>I agree, I think there is no need for deriving/synthesizes, but also, no need to specify Equatable, Hashable. They should get the functionality by default but allow for override and customization. <br></p><p><br>&gt; On May 26, 2016, at 11:02 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don’t understand why you couldn’t conform to Equatable, and if it fulfils the requirements (all members are also Equatable), then its implementation is automatically created for you. That way you don’t need a new keyword. It’s like Objective-C’s property automatic synthesising that get used unless you implement ones yourself.<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 12:57 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/5e095abc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 12:00:00am</p></header><div class="content"><p>If you have to specify Equatable / Hashable, then you can get an error if the automatic implementation failed, due to a member also not being Equatable/Hashable. If it’s automatic, then it will just quietly fail, making problems harder to know about and track. It will also always add to the compile size, even if you didn’t want the functionality.<br></p><p><br>&gt; On 27 May 2016, at 10:46 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; I agree, I think there is no need for deriving/synthesizes, but also, no need to specify Equatable, Hashable. They should get the functionality by default but allow for override and customization. <br>&gt; <br>&gt; <br>&gt; On May 26, 2016, at 11:02 PM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t understand why you couldn’t conform to Equatable, and if it fulfils the requirements (all members are also Equatable), then its implementation is automatically created for you. That way you don’t need a new keyword. It’s like Objective-C’s property automatic synthesising that get used unless you implement ones yourself.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 12:57 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/b72e62ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>When would the automatic implementation fail?<br></p><p>I see your point about adding to the compile size and I had previously mentioned that. Usually in the apps I develop that is not a concern. However I can see it could be a concern for apps that are more restrictive. If Swift is to be used to build such apps too then I agree that not being automatic would be important. It would have to be opt-in. I would be okay with that solution. Hopefully most would make use of it in high-level frameworks.<br></p><p>I guess similar to reflection and enabling dynamism. I look forward to eventually being able to do key-value-coding in pure Swift and being able to implement a framework similar to WebObjects which would require being able to find properties by their name, getting and setting values. That would be another example of opting in for a richer run-time. <br></p><p><br>&gt; On May 27, 2016, at 10:11 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; If you have to specify Equatable / Hashable, then you can get an error if the automatic implementation failed, due to a member also not being Equatable/Hashable. If it’s automatic, then it will just quietly fail, making problems harder to know about and track. It will also always add to the compile size, even if you didn’t want the functionality.<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 10:46 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree, I think there is no need for deriving/synthesizes, but also, no need to specify Equatable, Hashable. They should get the functionality by default but allow for override and customization. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 11:02 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t understand why you couldn’t conform to Equatable, and if it fulfils the requirements (all members are also Equatable), then its implementation is automatically created for you. That way you don’t need a new keyword. It’s like Objective-C’s property automatic synthesising that get used unless you implement ones yourself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 May 2016, at 12:57 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/a61cce9e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 02:00:00am</p></header><div class="content"><p>It would fail if not all members were Equatable or Hashable. If it was automatic, you wouldn’t get any warning or sign at all. If you have to explicitly conform to the protocols, then your intention is clear, and if an automatic implementation cannot be made (because not all members were Equatable or Hashable), then you will get an error that you need to implement the protocol yourself like you do now (i.e. implement == and hashValue).<br></p><p>Patrick<br></p><p>&gt; On 28 May 2016, at 1:38 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; When would the automatic implementation fail?<br>&gt; <br>&gt; I see your point about adding to the compile size and I had previously mentioned that. Usually in the apps I develop that is not a concern. However I can see it could be a concern for apps that are more restrictive. If Swift is to be used to build such apps too then I agree that not being automatic would be important. It would have to be opt-in. I would be okay with that solution. Hopefully most would make use of it in high-level frameworks.<br>&gt; <br>&gt; I guess similar to reflection and enabling dynamism. I look forward to eventually being able to do key-value-coding in pure Swift and being able to implement a framework similar to WebObjects which would require being able to find properties by their name, getting and setting values. That would be another example of opting in for a richer run-time. <br>&gt; <br>&gt; <br>&gt; On May 27, 2016, at 10:11 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; If you have to specify Equatable / Hashable, then you can get an error if the automatic implementation failed, due to a member also not being Equatable/Hashable. If it’s automatic, then it will just quietly fail, making problems harder to know about and track. It will also always add to the compile size, even if you didn’t want the functionality.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 10:46 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree, I think there is no need for deriving/synthesizes, but also, no need to specify Equatable, Hashable. They should get the functionality by default but allow for override and customization. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 11:02 PM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t understand why you couldn’t conform to Equatable, and if it fulfils the requirements (all members are also Equatable), then its implementation is automatically created for you. That way you don’t need a new keyword. It’s like Objective-C’s property automatic synthesising that get used unless you implement ones yourself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 May 2016, at 12:57 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt;&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt;&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt;&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt;&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt;&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt;&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/a4df6d19/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 26, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 for &quot;deriving&quot;, &quot;synthesizes&quot;, or some other keyword. How are we going to tell the compiler what protocols can participate? Something like &quot;@memberwise&quot; is all I can think of, but I&#39;m too tired for deep thought at the moment.<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 26, 2016, at 21:57, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt; <br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch<br>&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt; rFour<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt; rThree<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt; rRank<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt; rCard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt; rCard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; default<br>&gt;&gt;&gt; :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/7700370b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 27, 2016, at 6:27 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for &quot;deriving&quot;, &quot;synthesizes&quot;, or some other keyword. How are we going to tell the compiler what protocols can participate? Something like &quot;@memberwise&quot; is all I can think of, but I&#39;m too tired for deep thought at the moment.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On May 26, 2016, at 21:57, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder if synthesizes would be a better choice than deriving. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 5:58 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br></p><p>Can&#39;t make sense of the idea.<br>By vitue of being values, they de-facto carry the notion of something identifying them (basically their &#39;value&#39;), makes them defacto hashable/equatable. Inventing a pseudo inheritance just so that what&#39;s already there can be restated makes no logical sense to me. So say we have invented this new (IMO highly contrived and redundant) syntax, it still does not address what most people will IMO wind-up asking for (just google around and you&#39;ll see): the ability to influence how the identity of their structs is composed.<br></p><p>So:<br>  -1 for deriving Equatable/Hashble<br></p><p>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt;&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt;&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt;&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt;&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt;&gt;&gt; - It is proven to work in production.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 03:48 schrieb Mark Sands via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks so much for putting this together, Tony! Glad I was able to be some inspiration. :^)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Automatically deriving Equatable andHashable for value types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • Proposal: SE-0000<br>&gt;&gt;&gt;&gt;    • Author(s): Tony Allevato<br>&gt;&gt;&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt; .property2 == rhs.property2 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         lhs<br>&gt;&gt;&gt;&gt; .property3 == rhs.property3 &amp;&amp;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt; (lhs, rhs) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let<br>&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank == rRank &amp;&amp; lSuit ==<br>&gt;&gt;&gt;&gt; rSuit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let<br>&gt;&gt;&gt;&gt; rFour)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lFour ==<br>&gt;&gt;&gt;&gt; rFour<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.fullHouse(three: let lThree), .fullHouse(three: let<br>&gt;&gt;&gt;&gt; rThree)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lThree ==<br>&gt;&gt;&gt;&gt; rThree<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.flush(let lRank, let lSuit), .flush(let rRank, let<br>&gt;&gt;&gt;&gt; rSuit)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lSuit == rSuit &amp;&amp; lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.straight(high: let lRank), .straight(high: let<br>&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let<br>&gt;&gt;&gt;&gt; rRank)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lRank ==<br>&gt;&gt;&gt;&gt; rRank<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.twoPair(high: let lHigh, low: let lLow, highCard: let<br>&gt;&gt;&gt;&gt; lCard),<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .twoPair(high: let rHigh, low: let rLow, highCard: let<br>&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard ==<br>&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let<br>&gt;&gt;&gt;&gt; lCard3),<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let<br>&gt;&gt;&gt;&gt; rCard3)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 ==<br>&gt;&gt;&gt;&gt; rCard3<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case (.highCard(let lCard), .highCard(let<br>&gt;&gt;&gt;&gt; rCard)):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return lCard ==<br>&gt;&gt;&gt;&gt; rCard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Foo: Int<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case one = 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case two = 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = (Foo.one == Foo.two)  // works<br>&gt;&gt;&gt;&gt; let y = Foo.one.hashValue     // also works<br>&gt;&gt;&gt;&gt; let z = Foo.one.rawValue      // also also works<br>&gt;&gt;&gt;&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    • An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overriding defaults<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Omission of fields from generated computations<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Explicit or implicit derivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Acknowledgments<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/1a2af1a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85d9971b4047fb2f720357fee59a5f98?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Pedro Vieira</string> &lt;pedrovieira.swift at gmail.com&gt;<p>May 29, 2016 at 01:00:00am</p></header><div class="content"><p>I really think this would be a great addition to Swift. Although, I don&#39;t<br>see the need to use a new keyword `deriving` for this feature.<br>The following would be enough:<br></p><p>struct Foo: Equatable, Hashable {<br>  ...<br>}<br></p><p>It&#39;s explicit and it uses features already in the language. With this, the<br>compiler would generate all the functions needed for `Foo` to conform to<br>`Equatable` and `Hashable` and, in case the developer wants custom behavior<br>on any of those functions, he/she could just write it from scratch and the<br>compiler would use it over the generated one.<br></p><p>Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; escreveu<br>no dia quinta, 26/05/2016 às 10:58:<br></p><p>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our<br>&gt; own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable`<br>&gt; would become<br>&gt;<br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be<br>&gt; automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason),<br>&gt; you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any<br>&gt; new incompatibilities. For example, `CustomStringConvertible` could be<br>&gt; derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt; Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if<br>&gt; `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not<br>&gt; used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something<br>&gt; in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this<br>&gt; produces an error.)<br>&gt; - It is proven to work in production.<br>&gt;<br>&gt; -Michael<br>&gt;<br></p><p>Pedro Vieira<br>http://pedrovieira.me<br>-- <br>Pedro Vieira<br>http://pedrovieira.me<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/86ed1aac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 8:43 PM, Pedro Vieira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really think this would be a great addition to Swift. Although, I don&#39;t see the need to use a new keyword `deriving` for this feature.<br>&gt; The following would be enough:<br>&gt; <br>&gt; struct Foo: Equatable, Hashable {<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; It&#39;s explicit and it uses features already in the language. With this, the compiler would generate all the functions needed for `Foo` to conform to `Equatable` and `Hashable` and, in case the developer wants custom behavior on any of those functions, he/she could just write it from scratch and the compiler would use it over the generated one.<br></p><p>The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br></p><p>&gt; <br>&gt; Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu no dia quinta, 26/05/2016 às 10:58:<br>&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable` would become<br>&gt; <br>&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; This has several advantages:<br>&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be automatically derived or not.<br>&gt; - Deriving becomes an explicit choice.<br>&gt; - If you need a custom `Equatable` implementation (for whatever reason), you can still do it.<br>&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt; - It can be extended in future versions of Swift, without introducing any new incompatibilities. For example, `CustomStringConvertible` could be derived just as easily.<br>&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this produces an error.)<br>&gt; - It is proven to work in production.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; Pedro Vieira<br>&gt; http://pedrovieira.me &lt;http://pedrovieira.me/&gt;<br>&gt; -- <br>&gt; Pedro Vieira<br>&gt; http://pedrovieira.me &lt;http://pedrovieira.me/&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/fc0cc712/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>May 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br></p><p>	I don’t think it’s reasonable to force the language down the path where developers don’t have to be familiar with its features in order to use them correctly. If types in Swift were to automatically gain Equatable and Hashable conformances whenever they were used by something that required them, that would be a core language feature, like type inference, that even junior developers in the language would need to know. Yet few (though not none) would insist that all types be manually declared, despite otherwise not knowing when our type inference goes wrong. It’s just a basic feature of the language that anyone using the language should know about, otherwise it can bite them in the ass when weird compiler errors start popping up. <br>	Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast majority of cases where my types are trivially equatable, I should just be able to declare them as such and gain the compiler-synthesized ==. In the cases where that’s not possible, the compiler can emit an error. And in the cases where I want a custom == implementation I can provide it. Requiring a new keyword and not making this feature as simple as possible because the rare developer with a custom type who doesn’t want the synthesized == they just said they did by declaring Equatable conformance is an unnecessary defaulting to the rare case. <br>	<br></p><p><br></p><p>Jon Shier<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c6979191/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 29, 2016 at 05:00:00am</p></header><div class="content"><p>That&#39;s quite the assertion you make. What&#39;s your evidence that 80% of the<br>time an Equatable type is &#39;trivially&#39; equatable? In stdlib? Foundation?<br></p><p>If you could demonstrate that it&#39;s really the case, I&#39;d probably be<br>inclined to support default synthesis of conformance to Equatable.<br>On Sat, May 28, 2016 at 23:19 Jon Shier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The problem with this is that it doesn’t differentiate between synthesized<br>&gt; and manual conformance.  You won’t get error messages you otherwise would<br>&gt; when you intend to supply manual conformance.  It is also less clear to a<br>&gt; reader of the code that the default, compiler synthesized implementation is<br>&gt; being generated.<br>&gt;<br>&gt;<br>&gt; I don’t think it’s reasonable to force the language down the path where<br>&gt; developers don’t have to be familiar with its features in order to use them<br>&gt; correctly. If types in Swift were to automatically gain Equatable and<br>&gt; Hashable conformances whenever they were used by something that required<br>&gt; them, that would be a core language feature, like type inference, that even<br>&gt; junior developers in the language would need to know. Yet few (though not<br>&gt; none) would insist that all types be manually declared, despite otherwise<br>&gt; not knowing when our type inference goes wrong. It’s just a basic feature<br>&gt; of the language that anyone using the language should know about, otherwise<br>&gt; it can bite them in the ass when weird compiler errors start popping up.<br>&gt; Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast<br>&gt; majority of cases where my types are trivially equatable, I should just be<br>&gt; able to declare them as such and gain the compiler-synthesized ==. In the<br>&gt; cases where that’s not possible, the compiler can emit an error. And in the<br>&gt; cases where I want a custom == implementation I can provide it. Requiring a<br>&gt; new keyword and not making this feature as simple as possible because the<br>&gt; rare developer with a custom type who doesn’t want the synthesized == they<br>&gt; just said they did by declaring Equatable conformance is an unnecessary<br>&gt; defaulting to the rare case.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jon Shier<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/ad4cd993/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>May 29, 2016 at 01:00:00am</p></header><div class="content"><p>I’m sorry, I was misusing the 80/20 principle there, not making an argument that 80% of all types are trivially Equatable (though I would assert the number types that are trivially Equatable would be far greater than those that are not). I was merely stating that the rare cases in which a synthesized Equatable implementation might not be desired, even if possible, should not prevent this feature from existing and being as simple as possible. That is, some simple struct that contains only a few stored properties should be prevented from having a synthesized Equatable implementation because some representation of rational numbers may not be. Nor should I or the language have to use some special syntax or keyword to trigger such generation.<br></p><p><br>Jon Shier<br></p><p>&gt; On May 29, 2016, at 1:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; That&#39;s quite the assertion you make. What&#39;s your evidence that 80% of the time an Equatable type is &#39;trivially&#39; equatable? In stdlib? Foundation?<br>&gt; <br>&gt; If you could demonstrate that it&#39;s really the case, I&#39;d probably be inclined to support default synthesis of conformance to Equatable.<br>&gt; On Sat, May 28, 2016 at 23:19 Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br>&gt; <br>&gt; 	I don’t think it’s reasonable to force the language down the path where developers don’t have to be familiar with its features in order to use them correctly. If types in Swift were to automatically gain Equatable and Hashable conformances whenever they were used by something that required them, that would be a core language feature, like type inference, that even junior developers in the language would need to know. Yet few (though not none) would insist that all types be manually declared, despite otherwise not knowing when our type inference goes wrong. It’s just a basic feature of the language that anyone using the language should know about, otherwise it can bite them in the ass when weird compiler errors start popping up. <br>&gt; 	Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast majority of cases where my types are trivially equatable, I should just be able to declare them as such and gain the compiler-synthesized ==. In the cases where that’s not possible, the compiler can emit an error. And in the cases where I want a custom == implementation I can provide it. Requiring a new keyword and not making this feature as simple as possible because the rare developer with a custom type who doesn’t want the synthesized == they just said they did by declaring Equatable conformance is an unnecessary defaulting to the rare case. <br>&gt; 	<br>&gt; <br>&gt; <br>&gt; <br>&gt; Jon Shier<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f58c71c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 29, 2016 at 06:00:00am</p></header><div class="content"><p>I feel like there&#39;s some parallels here between the design you&#39;re proposing<br>(which is neat) and the discussion that&#39;s going on in two other threads<br>about how almost any type can be converted to a String by default. There,<br>we&#39;ve heard deep dissatisfaction about that facility being invoked<br>unintentionally.<br></p><p>I love the adage that code you don&#39;t write is code you don&#39;t have to debug.<br>But I would add that code that&#39;s written for you because you chose not to<br>write any yourself is code that someone else will have to debug.<br></p><p>On Sun, May 29, 2016 at 01:58 Jon Shier &lt;jon at jonshier.com&gt; wrote:<br></p><p>&gt; I’m sorry, I was misusing the 80/20 principle there, not making an<br>&gt; argument that 80% of all types are trivially Equatable (though I would<br>&gt; assert the number types that are trivially Equatable would be far greater<br>&gt; than those that are not). I was merely stating that the rare cases in which<br>&gt; a synthesized Equatable implementation might not be desired, even if<br>&gt; possible, should not prevent this feature from existing and being as simple<br>&gt; as possible. That is, some simple struct that contains only a few stored<br>&gt; properties should be prevented from having a synthesized Equatable<br>&gt; implementation because some representation of rational numbers may not be.<br>&gt; Nor should I or the language have to use some special syntax or keyword to<br>&gt; trigger such generation.<br>&gt;<br>&gt;<br>&gt; Jon Shier<br>&gt;<br>&gt; On May 29, 2016, at 1:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; That&#39;s quite the assertion you make. What&#39;s your evidence that 80% of the<br>&gt; time an Equatable type is &#39;trivially&#39; equatable? In stdlib? Foundation?<br>&gt;<br>&gt; If you could demonstrate that it&#39;s really the case, I&#39;d probably be<br>&gt; inclined to support default synthesis of conformance to Equatable.<br>&gt; On Sat, May 28, 2016 at 23:19 Jon Shier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The problem with this is that it doesn’t differentiate between<br>&gt;&gt; synthesized and manual conformance.  You won’t get error messages you<br>&gt;&gt; otherwise would when you intend to supply manual conformance.  It is also<br>&gt;&gt; less clear to a reader of the code that the default, compiler synthesized<br>&gt;&gt; implementation is being generated.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think it’s reasonable to force the language down the path where<br>&gt;&gt; developers don’t have to be familiar with its features in order to use them<br>&gt;&gt; correctly. If types in Swift were to automatically gain Equatable and<br>&gt;&gt; Hashable conformances whenever they were used by something that required<br>&gt;&gt; them, that would be a core language feature, like type inference, that even<br>&gt;&gt; junior developers in the language would need to know. Yet few (though not<br>&gt;&gt; none) would insist that all types be manually declared, despite otherwise<br>&gt;&gt; not knowing when our type inference goes wrong. It’s just a basic feature<br>&gt;&gt; of the language that anyone using the language should know about, otherwise<br>&gt;&gt; it can bite them in the ass when weird compiler errors start popping up.<br>&gt;&gt; Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast<br>&gt;&gt; majority of cases where my types are trivially equatable, I should just be<br>&gt;&gt; able to declare them as such and gain the compiler-synthesized ==. In the<br>&gt;&gt; cases where that’s not possible, the compiler can emit an error. And in the<br>&gt;&gt; cases where I want a custom == implementation I can provide it. Requiring a<br>&gt;&gt; new keyword and not making this feature as simple as possible because the<br>&gt;&gt; rare developer with a custom type who doesn’t want the synthesized == they<br>&gt;&gt; just said they did by declaring Equatable conformance is an unnecessary<br>&gt;&gt; defaulting to the rare case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Jon Shier<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/1c62db65/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Yeah I don’t see a problem. It’s the same way that protocol extensions just work. Think of this automatic synthesis as a really flexible protocol extension:<br></p><p>extension Hashable where Members : Hashable {<br>  var hashValue : Int {<br>    return self.allMembers.reduce(^) // Or whatever combiner is best<br>  }<br>}<br></p><p><br>&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br>&gt; <br>&gt; 	I don’t think it’s reasonable to force the language down the path where developers don’t have to be familiar with its features in order to use them correctly. If types in Swift were to automatically gain Equatable and Hashable conformances whenever they were used by something that required them, that would be a core language feature, like type inference, that even junior developers in the language would need to know. Yet few (though not none) would insist that all types be manually declared, despite otherwise not knowing when our type inference goes wrong. It’s just a basic feature of the language that anyone using the language should know about, otherwise it can bite them in the ass when weird compiler errors start popping up. <br>&gt; 	Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast majority of cases where my types are trivially equatable, I should just be able to declare them as such and gain the compiler-synthesized ==. In the cases where that’s not possible, the compiler can emit an error. And in the cases where I want a custom == implementation I can provide it. Requiring a new keyword and not making this feature as simple as possible because the rare developer with a custom type who doesn’t want the synthesized == they just said they did by declaring Equatable conformance is an unnecessary defaulting to the rare case. <br>&gt; 	<br>&gt; <br>&gt; <br>&gt; <br>&gt; Jon Shier<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/ee173d38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 12:28 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yeah I don’t see a problem. It’s the same way that protocol extensions just work. Think of this automatic synthesis as a really flexible protocol extension:<br>&gt; <br>&gt; extension Hashable where Members : Hashable {<br>&gt;   var hashValue : Int {<br>&gt;     return self.allMembers.reduce(^) // Or whatever combiner is best<br>&gt;   }<br>&gt; }<br></p><p>Protocol extensions require you to declare conformance before your type receives their implementation and it must be identical for all do conforming types.  <br></p><p>You should have to declare conformance to receive Equatable conformance and synthesis.  IMO it makes sense to do that with &#39;deriving&#39; which makes it clear that you are requesting synthesized rather than manual conformance.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br>&gt;&gt; <br>&gt;&gt; 	I don’t think it’s reasonable to force the language down the path where developers don’t have to be familiar with its features in order to use them correctly. If types in Swift were to automatically gain Equatable and Hashable conformances whenever they were used by something that required them, that would be a core language feature, like type inference, that even junior developers in the language would need to know. Yet few (though not none) would insist that all types be manually declared, despite otherwise not knowing when our type inference goes wrong. It’s just a basic feature of the language that anyone using the language should know about, otherwise it can bite them in the ass when weird compiler errors start popping up. <br>&gt;&gt; 	Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast majority of cases where my types are trivially equatable, I should just be able to declare them as such and gain the compiler-synthesized ==. In the cases where that’s not possible, the compiler can emit an error. And in the cases where I want a custom == implementation I can provide it. Requiring a new keyword and not making this feature as simple as possible because the rare developer with a custom type who doesn’t want the synthesized == they just said they did by declaring Equatable conformance is an unnecessary defaulting to the rare case. <br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jon Shier<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/48cd1294/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Should &#39;deriving&#39; allows us to manually implement protocol requirements? <br>For example<br>struct A : deriving Hashable {<br>   var hasValue : Int {...}<br>}<br></p><p>Or there should be a compilation error in this case?<br></p><p>Right now I feel that if we can have auto-deriving by using current syntax <br>for protocol conformance - we sholdn&#39;t introduce new keyword and new rules <br>for this.<br>The requirement to explicitly conform your type to protocol for <br>auto-deriving is IMO reasonable compromise between separate &#39;deriving&#39; <br>decoration and implicit derivation(when your type is Hashable without any <br>conformance to protocol, just if each property is Hashable).<br></p><p>On 29.05.2016 14:42, Matthew Johnson via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 29, 2016, at 12:28 AM, Patrick Smith &lt;pgwsmith at gmail.com<br>&gt; &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Yeah I don’t see a problem. It’s the same way that protocol extensions<br>&gt;&gt; just work. Think of this automatic synthesis as a really flexible<br>&gt;&gt; protocol extension:<br>&gt;&gt;<br>&gt;&gt; extension Hashable where Members : Hashable {<br>&gt;&gt;   var hashValue : Int {<br>&gt;&gt;     return self.allMembers.reduce(^) // Or whatever combiner is best<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;<br>&gt; Protocol extensions require you to declare conformance before your type<br>&gt; receives their implementation and it must be identical for all do<br>&gt; conforming types.<br>&gt;<br>&gt; You should have to declare conformance to receive Equatable conformance and<br>&gt; synthesis.  IMO it makes sense to do that with &#39;deriving&#39; which makes it<br>&gt; clear that you are requesting synthesized rather than manual conformance.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem with this is that it doesn’t differentiate between<br>&gt;&gt;&gt;&gt; synthesized and manual conformance.  You won’t get error messages you<br>&gt;&gt;&gt;&gt; otherwise would when you intend to supply manual conformance.  It is<br>&gt;&gt;&gt;&gt; also less clear to a reader of the code that the default, compiler<br>&gt;&gt;&gt;&gt; synthesized implementation is being generated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think it’s reasonable to force the language down the path where<br>&gt;&gt;&gt; developers don’t have to be familiar with its features in order to use<br>&gt;&gt;&gt; them correctly. If types in Swift were to automatically gain Equatable<br>&gt;&gt;&gt; and Hashable conformances whenever they were used by something that<br>&gt;&gt;&gt; required them, that would be a core language feature, like type<br>&gt;&gt;&gt; inference, that even junior developers in the language would need to<br>&gt;&gt;&gt; know. Yet few (though not none) would insist that all types be manually<br>&gt;&gt;&gt; declared, despite otherwise not knowing when our type inference goes<br>&gt;&gt;&gt; wrong. It’s just a basic feature of the language that anyone using the<br>&gt;&gt;&gt; language should know about, otherwise it can bite them in the ass when<br>&gt;&gt;&gt; weird compiler errors start popping up.<br>&gt;&gt;&gt; Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast<br>&gt;&gt;&gt; majority of cases where my types are trivially equatable, I should just<br>&gt;&gt;&gt; be able to declare them as such and gain the compiler-synthesized ==. In<br>&gt;&gt;&gt; the cases where that’s not possible, the compiler can emit an error. And<br>&gt;&gt;&gt; in the cases where I want a custom == implementation I can provide it.<br>&gt;&gt;&gt; Requiring a new keyword and not making this feature as simple as<br>&gt;&gt;&gt; possible because the rare developer with a custom type who doesn’t want<br>&gt;&gt;&gt; the synthesized == they just said they did by declaring Equatable<br>&gt;&gt;&gt; conformance is an unnecessary defaulting to the rare case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 8:25 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Should &#39;deriving&#39; allows us to manually implement protocol requirements? For example<br>&gt; struct A : deriving Hashable {<br>&gt;  var hasValue : Int {...}<br>&gt; }<br>&gt; <br>&gt; Or there should be a compilation error in this case?<br></p><p>This should be an error.  If you want to implement it manually your should use the usual conformance declaration syntax.<br></p><p>&gt; <br>&gt; Right now I feel that if we can have auto-deriving by using current syntax for protocol conformance - we sholdn&#39;t introduce new keyword and new rules for this.<br></p><p>We&#39;ve already covered the reasons why this is problematic.  It&#39;s better to be explicit about the request for synthesized conformance.<br></p><p>&gt; The requirement to explicitly conform your type to protocol for auto-deriving is IMO reasonable compromise between separate &#39;deriving&#39; decoration and implicit derivation(when your type is Hashable without any conformance to protocol, just if each property is Hashable).<br>&gt; <br>&gt;&gt; On 29.05.2016 14:42, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 12:28 AM, Patrick Smith &lt;pgwsmith at gmail.com<br>&gt;&gt; &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Yeah I don’t see a problem. It’s the same way that protocol extensions<br>&gt;&gt;&gt; just work. Think of this automatic synthesis as a really flexible<br>&gt;&gt;&gt; protocol extension:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Hashable where Members : Hashable {<br>&gt;&gt;&gt;  var hashValue : Int {<br>&gt;&gt;&gt;    return self.allMembers.reduce(^) // Or whatever combiner is best<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Protocol extensions require you to declare conformance before your type<br>&gt;&gt; receives their implementation and it must be identical for all do<br>&gt;&gt; conforming types.<br>&gt;&gt; <br>&gt;&gt; You should have to declare conformance to receive Equatable conformance and<br>&gt;&gt; synthesis.  IMO it makes sense to do that with &#39;deriving&#39; which makes it<br>&gt;&gt; clear that you are requesting synthesized rather than manual conformance.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem with this is that it doesn’t differentiate between<br>&gt;&gt;&gt;&gt;&gt; synthesized and manual conformance.  You won’t get error messages you<br>&gt;&gt;&gt;&gt;&gt; otherwise would when you intend to supply manual conformance.  It is<br>&gt;&gt;&gt;&gt;&gt; also less clear to a reader of the code that the default, compiler<br>&gt;&gt;&gt;&gt;&gt; synthesized implementation is being generated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it’s reasonable to force the language down the path where<br>&gt;&gt;&gt;&gt; developers don’t have to be familiar with its features in order to use<br>&gt;&gt;&gt;&gt; them correctly. If types in Swift were to automatically gain Equatable<br>&gt;&gt;&gt;&gt; and Hashable conformances whenever they were used by something that<br>&gt;&gt;&gt;&gt; required them, that would be a core language feature, like type<br>&gt;&gt;&gt;&gt; inference, that even junior developers in the language would need to<br>&gt;&gt;&gt;&gt; know. Yet few (though not none) would insist that all types be manually<br>&gt;&gt;&gt;&gt; declared, despite otherwise not knowing when our type inference goes<br>&gt;&gt;&gt;&gt; wrong. It’s just a basic feature of the language that anyone using the<br>&gt;&gt;&gt;&gt; language should know about, otherwise it can bite them in the ass when<br>&gt;&gt;&gt;&gt; weird compiler errors start popping up.<br>&gt;&gt;&gt;&gt; Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast<br>&gt;&gt;&gt;&gt; majority of cases where my types are trivially equatable, I should just<br>&gt;&gt;&gt;&gt; be able to declare them as such and gain the compiler-synthesized ==. In<br>&gt;&gt;&gt;&gt; the cases where that’s not possible, the compiler can emit an error. And<br>&gt;&gt;&gt;&gt; in the cases where I want a custom == implementation I can provide it.<br>&gt;&gt;&gt;&gt; Requiring a new keyword and not making this feature as simple as<br>&gt;&gt;&gt;&gt; possible because the rare developer with a custom type who doesn’t want<br>&gt;&gt;&gt;&gt; the synthesized == they just said they did by declaring Equatable<br>&gt;&gt;&gt;&gt; conformance is an unnecessary defaulting to the rare case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 3:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 29, 2016, at 8:25 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Should &#39;deriving&#39; allows us to manually implement protocol requirements? For example<br>&gt;&gt; struct A : deriving Hashable {<br>&gt;&gt; var hasValue : Int {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Or there should be a compilation error in this case?<br>&gt; <br>&gt; This should be an error.  If you want to implement it manually your should use the usual conformance declaration syntax.<br></p><p>Considering it can all be done without deriving, so I wager they will never add it <br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Right now I feel that if we can have auto-deriving by using current syntax for protocol conformance - we sholdn&#39;t introduce new keyword and new rules for this.<br>&gt; <br>&gt; We&#39;ve already covered the reasons why this is problematic.  It&#39;s better to be explicit about the request for synthesized conformance.<br>&gt; <br>&gt;&gt; The requirement to explicitly conform your type to protocol for auto-deriving is IMO reasonable compromise between separate &#39;deriving&#39; decoration and implicit derivation(when your type is Hashable without any conformance to protocol, just if each property is Hashable).<br>&gt;&gt; <br>&gt;&gt;&gt; On 29.05.2016 14:42, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 12:28 AM, Patrick Smith &lt;pgwsmith at gmail.com<br>&gt;&gt;&gt; &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah I don’t see a problem. It’s the same way that protocol extensions<br>&gt;&gt;&gt;&gt; just work. Think of this automatic synthesis as a really flexible<br>&gt;&gt;&gt;&gt; protocol extension:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Hashable where Members : Hashable {<br>&gt;&gt;&gt;&gt; var hashValue : Int {<br>&gt;&gt;&gt;&gt;   return self.allMembers.reduce(^) // Or whatever combiner is best<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol extensions require you to declare conformance before your type<br>&gt;&gt;&gt; receives their implementation and it must be identical for all do<br>&gt;&gt;&gt; conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You should have to declare conformance to receive Equatable conformance and<br>&gt;&gt;&gt; synthesis.  IMO it makes sense to do that with &#39;deriving&#39; which makes it<br>&gt;&gt;&gt; clear that you are requesting synthesized rather than manual conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The problem with this is that it doesn’t differentiate between<br>&gt;&gt;&gt;&gt;&gt;&gt; synthesized and manual conformance.  You won’t get error messages you<br>&gt;&gt;&gt;&gt;&gt;&gt; otherwise would when you intend to supply manual conformance.  It is<br>&gt;&gt;&gt;&gt;&gt;&gt; also less clear to a reader of the code that the default, compiler<br>&gt;&gt;&gt;&gt;&gt;&gt; synthesized implementation is being generated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think it’s reasonable to force the language down the path where<br>&gt;&gt;&gt;&gt;&gt; developers don’t have to be familiar with its features in order to use<br>&gt;&gt;&gt;&gt;&gt; them correctly. If types in Swift were to automatically gain Equatable<br>&gt;&gt;&gt;&gt;&gt; and Hashable conformances whenever they were used by something that<br>&gt;&gt;&gt;&gt;&gt; required them, that would be a core language feature, like type<br>&gt;&gt;&gt;&gt;&gt; inference, that even junior developers in the language would need to<br>&gt;&gt;&gt;&gt;&gt; know. Yet few (though not none) would insist that all types be manually<br>&gt;&gt;&gt;&gt;&gt; declared, despite otherwise not knowing when our type inference goes<br>&gt;&gt;&gt;&gt;&gt; wrong. It’s just a basic feature of the language that anyone using the<br>&gt;&gt;&gt;&gt;&gt; language should know about, otherwise it can bite them in the ass when<br>&gt;&gt;&gt;&gt;&gt; weird compiler errors start popping up.<br>&gt;&gt;&gt;&gt;&gt; Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast<br>&gt;&gt;&gt;&gt;&gt; majority of cases where my types are trivially equatable, I should just<br>&gt;&gt;&gt;&gt;&gt; be able to declare them as such and gain the compiler-synthesized ==. In<br>&gt;&gt;&gt;&gt;&gt; the cases where that’s not possible, the compiler can emit an error. And<br>&gt;&gt;&gt;&gt;&gt; in the cases where I want a custom == implementation I can provide it.<br>&gt;&gt;&gt;&gt;&gt; Requiring a new keyword and not making this feature as simple as<br>&gt;&gt;&gt;&gt;&gt; possible because the rare developer with a custom type who doesn’t want<br>&gt;&gt;&gt;&gt;&gt; the synthesized == they just said they did by declaring Equatable<br>&gt;&gt;&gt;&gt;&gt; conformance is an unnecessary defaulting to the rare case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/67c80086/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 30, 2016 at 01:00:00am</p></header><div class="content"><p>Yes, and I’ve been arguing for it being explicit by conforming to the Equatable / Hashable protocol. This would then work the same way as protocol extensions. Protocol extension don’t require a special ‘deriving’ keyword, so I don’t believe there needs to be one here. Just conforming to the protocols is enough.<br></p><p><br>&gt; On 29 May 2016, at 9:42 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 29, 2016, at 12:28 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Yeah I don’t see a problem. It’s the same way that protocol extensions just work. Think of this automatic synthesis as a really flexible protocol extension:<br>&gt;&gt; <br>&gt;&gt; extension Hashable where Members : Hashable {<br>&gt;&gt;   var hashValue : Int {<br>&gt;&gt;     return self.allMembers.reduce(^) // Or whatever combiner is best<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Protocol extensions require you to declare conformance before your type receives their implementation and it must be identical for all do conforming types.  <br>&gt; <br>&gt; You should have to declare conformance to receive Equatable conformance and synthesis.  IMO it makes sense to do that with &#39;deriving&#39; which makes it clear that you are requesting synthesized rather than manual conformance.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 May 2016, at 1:19 PM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem with this is that it doesn’t differentiate between synthesized and manual conformance.  You won’t get error messages you otherwise would when you intend to supply manual conformance.  It is also less clear to a reader of the code that the default, compiler synthesized implementation is being generated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	I don’t think it’s reasonable to force the language down the path where developers don’t have to be familiar with its features in order to use them correctly. If types in Swift were to automatically gain Equatable and Hashable conformances whenever they were used by something that required them, that would be a core language feature, like type inference, that even junior developers in the language would need to know. Yet few (though not none) would insist that all types be manually declared, despite otherwise not knowing when our type inference goes wrong. It’s just a basic feature of the language that anyone using the language should know about, otherwise it can bite them in the ass when weird compiler errors start popping up. <br>&gt;&gt;&gt; 	Frankly, IMO, this is an obvious case of 80/20 optimization. In the vast majority of cases where my types are trivially equatable, I should just be able to declare them as such and gain the compiler-synthesized ==. In the cases where that’s not possible, the compiler can emit an error. And in the cases where I want a custom == implementation I can provide it. Requiring a new keyword and not making this feature as simple as possible because the rare developer with a custom type who doesn’t want the synthesized == they just said they did by declaring Equatable conformance is an unnecessary defaulting to the rare case. <br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/1b9630da/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 29, 2016 at 12:00:00am</p></header><div class="content"><p>It isn&#39;t explicit that you are synthesizing code. This is especially true<br>because we can still declare conformance on one declaration/extension and<br>implement in another. You could even conform in another file. This isn&#39;t<br>generally good form but it is valid code and it is even, in some cases,<br>somewhat reasonable.(You might have moved an extension or it might be<br>relevant to some other bit of code somewhere but you want the conformance<br>visible on the declaration because it is of prime importance.<br></p><p>On Sat, May 28, 2016 at 7:43 PM, Pedro Vieira via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I really think this would be a great addition to Swift. Although, I don&#39;t<br>&gt; see the need to use a new keyword `deriving` for this feature.<br>&gt; The following would be enough:<br>&gt;<br>&gt; struct Foo: Equatable, Hashable {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; It&#39;s explicit and it uses features already in the language. With this, the<br>&gt; compiler would generate all the functions needed for `Foo` to conform to<br>&gt; `Equatable` and `Hashable` and, in case the developer wants custom behavior<br>&gt; on any of those functions, he/she could just write it from scratch and the<br>&gt; compiler would use it over the generated one.<br>&gt;<br>&gt; Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; escreveu no dia quinta, 26/05/2016 às 10:58:<br>&gt;<br>&gt;&gt; Can we just copy&amp;paste the solution from Haskell instead of creating our<br>&gt;&gt; own? It&#39;s just better in every aspect. Deriving `Equatable` and `Hashable`<br>&gt;&gt; would become<br>&gt;&gt;<br>&gt;&gt; struct Polygon deriving Equatable, Hashable {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This has several advantages:<br>&gt;&gt; - you don&#39;t have to guess wether `Equatable` or `Hashable` should be<br>&gt;&gt; automatically derived or not.<br>&gt;&gt; - Deriving becomes an explicit choice.<br>&gt;&gt; - If you need a custom `Equatable` implementation (for whatever reason),<br>&gt;&gt; you can still do it.<br>&gt;&gt; - It doesn&#39;t break any code that is unaware of the change<br>&gt;&gt; - It can be extended in future versions of Swift, without introducing any<br>&gt;&gt; new incompatibilities. For example, `CustomStringConvertible` could be<br>&gt;&gt; derived just as easily.<br>&gt;&gt; - It is compatible with generics. E.g. `struct Shape&lt;T&gt; deriving<br>&gt;&gt; Equatable` will make every `Shape&lt;X&gt;` equatable if `X` is equatable. But if<br>&gt;&gt; `X` is not equatable, `Shape&lt;X&gt;` can be used as well. (Unless `X` is not<br>&gt;&gt; used, in which case every `Shape&lt;T&gt;` would be equatable. Unless something<br>&gt;&gt; in the definition of `Shape` makes deriving `Equatable` impossible =&gt; this<br>&gt;&gt; produces an error.)<br>&gt;&gt; - It is proven to work in production.<br>&gt;&gt;<br>&gt;&gt; -Michael<br>&gt;&gt;<br>&gt;<br>&gt; Pedro Vieira<br>&gt; http://pedrovieira.me<br>&gt; --<br>&gt; Pedro Vieira<br>&gt; http://pedrovieira.me<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/0d3e7dba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>This would be very handy! It’s one of those rare scenarios where I think “I can’t believe Swift makes me type all this out, there must be an easier way”.<br></p><p>I think explicitly conformance to Equatable and Hashable would be preferable. This means if one of the members is not Equable/Hashable, the user knows by getting an error of ‘Does not conform to Equatable, must implement func ==’ at the type level rather than scratching their head when instances are not automatically Equatable. It also means code is only generated when it is needed.<br></p><p>There’s a small typo (before [sic] below):<br></p><p>&gt; On 26 May 2016, at 4:28 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As with raw-value enums today, should the derived conformance be completely explicit [sic], or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/9e290be9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 26, 2016 at 11:00:00pm</p></header><div class="content"><p>As Steve Jobs once said when demoing Interface Builder during the NeXT days: &quot;The line of code you don&#39;t have to write is the line of code you don&#39;t have to debug.&quot;<br></p><p>P.S. I hope I got the quote right, but that was the idea. :-)<br></p><p><br></p><p><br></p><p>Sent from my iPhone<br></p><p>&gt; On May 25, 2016, at 10:02 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This would be very handy! It’s one of those rare scenarios where I think “I can’t believe Swift makes me type all this out, there must be an easier way”.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>I really want synthesized equality (etc.), but having seen the previous discussions on this and related topics I am not sure that directly-deriving the `==` function is the right approach. <br></p><p>The main reason I say this is that although this works great for the easy case — all fields equatable, do the obvious thing! — sooner or later people will want to customize it, which would ideally allow someone to say “do the obvious thing for a,b,c but let me handle d and e”, e.g. still get synthesis for the easy parts…but an approach that directly-synthesizes `==` for a type seems like it’ll be difficult to expand to support such customization.<br></p><p>Suppose instead that we had a “magic function” `T#memberwiseEqual(_:_:)` we could invoke like so:<br> <br>  // the details are *very* bikesheddable here:<br>  func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>    return Foo#memberwiseEqual(lhs,rhs) // `#` b/c of &quot;compiler magic”<br>    // ^ compiler error iff any of `Foo`’s members aren’t Equatable<br>  }<br></p><p>…which’d expand to the expected “lhs.a == rhs.a &amp;&amp; lhs.b == rhs.b &amp;&amp; …”. <br></p><p>For trivial equatable synthesis this isn’t as nice as a full automatic derivation, but it seems like an *approach* that’d be much-better positioned for future expansion and enhancement, e.g.:<br></p><p>  extension Foo: Equatable {<br></p><p>   // mock syntax; probably too ambiguous for actual use but i think the idea is clear:<br>   private static func boringComponentsEqual(lhs: Foo, _ rhs: Foo) -&gt; Bool {<br>      return Foo(boring,boring2,boringIII)#memberwiseEqual(lhs,rhs)<br>   }<br></p><p>  }<br></p><p>  func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>    return Foo.boringComponentsEqual(lhs,rhs) &amp;&amp; // non-trivial equality logic here<br>  }<br></p><p>…as opposed to trying to retrofit various “customizations&quot; onto a system that directly synthesizes `==` (without exposing any “internals&quot;, so to speak).<br></p><p>You can easily imagine a similar `#casewiseEqual` for enums (it seems likely to be trickier, but not impossible), and again a #memberwiseHash for hashing, and so on.<br></p><p>I think you can summarize the above as “all-in-one derivation is appealing, but I think pragmatically and looking-ahead it’s a better move to expose the &#39;synthesis mechanism’ itself (leaving it the user to do the &#39;final assembly’)”.<br></p><p>&gt; On May 25, 2016, at 1:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt;&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; <br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/07607d4a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 26, 2016 at 11:00:00pm</p></header><div class="content"><p>I like this. <br></p><p>I don&#39;t see why not make this the default. <br></p><p>If someone thinks it is not needed for their application then they simply don&#39;t use it. Having it there would not cause any harm.  Unless someone had a requirement to have strict control on the size of the application and had to cut down on the amount of code. <br></p><p>If we establish that value types get this by default then there is no need to make it explicit. It would become a known fact for value types in the Swift language. <br></p><p>I don&#39;t see a reason to make this opt-in. I think there is more beneficial to make the behavior automatic and allow a way to override/ customize. <br></p><p><br>&gt; On May 25, 2016, at 2:28 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was inspired to put together a draft proposal based on an older discussion in the Universal Equality, Hashability, and Comparability thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently got necromanced (thanks Mark Sands!).<br>&gt; <br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not possible for the Swift 3 timeline, but it&#39;s something that would benefit enough people that I want to make sure the discussion stays alive. If there are enough good feelings about it, I&#39;ll move it from my gist into an actual proposal PR.<br>&gt; <br>&gt; Automatically deriving Equatable andHashable for value types<br>&gt; Proposal: SE-0000<br>&gt; Author(s): Tony Allevato<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Value types are prevalent throughout the Swift language, and we encourage developers to think in those terms when writing their own types. Frequently, developers find themselves writing large amounts of boilerplate code to support equatability and hashability of value types. This proposal offers a way for the compiler to automatically derive conformance toEquatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is likely to be possible.<br>&gt; <br>&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Building robust value types in Swift can involve writing significant boilerplate code to support concepts of hashability and equatability. Equality is pervasive across many value types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a struct looks fairly uninteresting:<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;   return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;          lhs.property2 == rhs.property2 &amp;&amp;<br>&gt;          lhs.property3 == rhs.property3 &amp;&amp;<br>&gt;          ...<br>&gt; }<br>&gt; What&#39;s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it&#39;s possible to get it wrong, either by omission or typographical error.<br>&gt; <br>&gt; Likewise, hashability is necessary when one wishes to store a value type in a Set or use one as a multi-valuedDictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them – especially as the number of properties increases – not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential to get it wrong.<br>&gt; <br>&gt; In particular, the code that must be written to implement equality for enums is quite verbose. One such real-world example (source):<br>&gt; <br>&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool {<br>&gt;   switch (lhs, rhs) {<br>&gt;   case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let rSuit)):<br>&gt;     return lRank == rRank &amp;&amp; lSuit == rSuit<br>&gt;   case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let rFour)):<br>&gt;     return lFour == rFour<br>&gt;   case (.fullHouse(three: let lThree), .fullHouse(three: let rThree)):<br>&gt;     return lThree == rThree<br>&gt;   case (.flush(let lRank, let lSuit), .flush(let rRank, let rSuit)):<br>&gt;     return lSuit == rSuit &amp;&amp; lRank == rRank<br>&gt;   case (.straight(high: let lRank), .straight(high: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.twoPair(high: let lHigh, low: let lLow, highCard: let lCard),<br>&gt;         .twoPair(high: let rHigh, low: let rLow, highCard: let rCard)):<br>&gt;     return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard == rCard<br>&gt;   case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let lCard3),<br>&gt;         .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let rCard3)):<br>&gt;     return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 == rCard3<br>&gt;   case (.highCard(let lCard), .highCard(let rCard)):<br>&gt;     return lCard == rCard<br>&gt;   default:<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; Crafting a high-quality hash function for this enum would be similarly inconvenient to write, involving another large switchstatement.<br>&gt; <br>&gt; Swift already provides implicit protocol conformance in some cases; notably, enums with raw values conform toRawRepresentable, Equatable, and Hashable without the user explicitly declaring them:<br>&gt; <br>&gt; enum Foo: Int {<br>&gt;   case one = 1<br>&gt;   case two = 2<br>&gt; }<br>&gt; <br>&gt; let x = (Foo.one == Foo.two)  // works<br>&gt; let y = Foo.one.hashValue     // also works<br>&gt; let z = Foo.one.rawValue      // also also works<br>&gt; Since there is precedent for this in Swift, we propose extending this support to more value types.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; We propose that a value type be Equatable/Hashable if all of its members are Equatable/Hashable, with the result for the outer type being composed from its members.<br>&gt; <br>&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt; <br>&gt; A struct implicitly conforms to Equatable if all of its fields are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields x in T.<br>&gt; <br>&gt; An enum implicitly conforms to Equatable if all of its associated values across all of its cases are of types that conform to Equatable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of ==(lhs: T, rhs: T) that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt; <br>&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt; <br>&gt; A struct implicitly conforms to Hashable if all of its fields are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of the struct from the hash values of its members.<br>&gt; <br>&gt; Since order of the terms affects the hash value computation, we recommend ordering the terms in member definition order.<br>&gt; <br>&gt; An enum implicitly conforms to Hashable if all of its associated values across all of its cases are of types that conform to Hashable – either explicitly, or implicitly by the application of these rules. The compiler will generate an implementation of hashValue that uses a pre-defined hash function† to compute the hash value of an enum value by using the case&#39;s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order.<br>&gt; <br>&gt; † We leave the exact definition of the hash function unspecified here; a multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy to implement, but we do not rule out other possibilities.<br>&gt; <br>&gt; Overriding defaults<br>&gt; <br>&gt; Any user-provided implementations of == or hashValue should override the default implementations that would be provided by the compiler. This is already possible today with raw-value enums so the same behavior should be extended to other value types that are made to implicitly conform to these protocols.<br>&gt; <br>&gt; Open questions<br>&gt; <br>&gt; Omission of fields from generated computations<br>&gt; <br>&gt; Should it be possible to easily omit certain properties from automatically generated equality tests or hash value computation? This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. If there is significant evidence that this pattern is common and useful, we could consider adding a custom attribute, such as @transient, that would omit the property from the generated computations.<br>&gt; <br>&gt; Explicit or implicit derivation<br>&gt; <br>&gt; As with raw-value enums today, should the derived conformance be completely explicit, or should users have to explicitly list conformance with Equatable and Hashable in order for the compiler to generate the derived implementation?<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This change will have no impact on existing code because it is purely additive. Value types that already provide custom implementations of == or hashValue but satisfy the rules above would keep the custom implementation because it would override the compiler-provided default.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code&#39;s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.)<br>&gt; <br>&gt; Acknowledgments<br>&gt; <br>&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, and to Mark Sands for necromancing the swift-evolution thread that convinced me to write this up.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/e95cc988/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
