<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Going back and forth from Strings to their byte representations is an<br>important part of solving many problems, including object<br>serialization, binary file formats, wire/network interfaces, and<br>cryptography.<br></p><p>In developing such a parser, a coworker did the yeoman&#39;s work of<br>benchmarking<br>Swift&#39;s Unicode types. He swore up and down that<br>String.Type.fromCString(_:) [0]<br>was the fastest way he found. I, stubborn and noobish as I am, was<br>skeptical<br>that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br></p><p>After reading through stdlib source and doing my own testing, this is no<br>wives&#39;<br>tale. fromCString [1] is essentially the only public user of<br>String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>of<br>both efficient and safe initialization-by-buffer-copy.<br></p><p>Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>sentinel,<br>requiring a copy of the origin buffer if one needs to be added (as is<br>the<br>case with formats that specify the length up front, or unstructured<br>payloads<br>that use unescaped double quotes as the terminator). It also prevents<br>the string<br>itself from containing the null character.<br></p><p>I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>If that<br>can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>would be<br>nice, and we can just eat the performance hit on other code unit<br>sequences.<br></p><p>I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>believe<br>I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>;-)<br></p><p>There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>have<br>anything close to the same speed. [3] Profiling indicates that I keep<br>hitting<br>_StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>creating<br>an Array of the bytes and performing fromCString on it. Similar story<br>with<br>crossing the NSString bridge, which is even stranger. [4]<br></p><p>Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>whether<br>this can be turned into a proposal.<br></p><p>[0]:<br>https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>[1]:<br>https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>[2]:<br>https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>[3]:<br>https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>[4]:<br>https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br></p><p>Cheers,<br>Zachary Waldowski<br>zach at waldowski.me<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API <br></p><p>I am very much in favor of this. I have had *exactly* the same experience.<br></p><p>String.reserveCapacity() seems to act like a no-op for some reason so append() is incredibly slow, and fromCString() often necessitates a copy to an intermediate buffer because of the the null-byte requirement.<br></p><p>This has been one of the weakest areas of Swift performance for me.<br></p><p>-CK<br></p><p>&gt; On Jan 8, 2016, at 12:21 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Going back and forth from Strings to their byte representations is an<br>&gt; important part of solving many problems, including object<br>&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; cryptography.<br>&gt; <br>&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt; benchmarking<br>&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; String.Type.fromCString(_:) [0]<br>&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; skeptical<br>&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt; <br>&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; wives&#39;<br>&gt; tale. fromCString [1] is essentially the only public user of<br>&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt; of<br>&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; <br>&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt; sentinel,<br>&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; the<br>&gt; case with formats that specify the length up front, or unstructured<br>&gt; payloads<br>&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; the string<br>&gt; itself from containing the null character.<br>&gt; <br>&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt; If that<br>&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt; would be<br>&gt; nice, and we can just eat the performance hit on other code unit<br>&gt; sequences.<br>&gt; <br>&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt; believe<br>&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt; ;-)<br>&gt; <br>&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt; have<br>&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt; hitting<br>&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt; creating<br>&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt; with<br>&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt; <br>&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt; whether<br>&gt; this can be turned into a proposal.<br>&gt; <br>&gt; [0]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt; [1]:<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt; [2]:<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt; [3]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt; [4]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt; <br>&gt; Cheers,<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Complete agreement from me. I would like to see a String constructor from a Sequence of code units.<br>Also, why is String.fromCString() a factory function rather than a fallible constructor?<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>I support this change as well.<br></p><p>TJ<br></p><p>On Fri, Jan 8, 2016 at 6:06 PM, Guillaume Lessard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Complete agreement from me. I would like to see a String constructor from<br>&gt; a Sequence of code units.<br>&gt; Also, why is String.fromCString() a factory function rather than a<br>&gt; fallible constructor?<br>&gt;<br>&gt; Guillaume Lessard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/7b25e83d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Sorry, I didn&#39;t get it, are you talking about:<br></p><p>var bytes : [UInt8] = [65, 66, 67, 68, 69, 70];<br></p><p>var s = String.init(bytes: bytes, encoding: NSUTF8StringEncoding)<br></p><p>?<br></p><p>On Sat, Jan 9, 2016 at 8:22 AM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I support this change as well.<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Fri, Jan 8, 2016 at 6:06 PM, Guillaume Lessard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Complete agreement from me. I would like to see a String constructor from<br>&gt;&gt; a Sequence of code units.<br>&gt;&gt; Also, why is String.fromCString() a factory function rather than a<br>&gt;&gt; fallible constructor?<br>&gt;&gt;<br>&gt;&gt; Guillaume Lessard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/9241adac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>The String initializer that would actually be of most value to me would be:<br></p><p>String.init(utf8: UnsafePointer&lt;UInt8&gt;, length: Int)<br></p><p>as long as it is as fast (preferably faster) than String.fromCString() and doesn’t require bridging to NSString. A similar initializer is available for NSString, but as Zach indicated in his link, using it is slow.<br></p><p>Several other initializers, including the one you showed, would be useful, as long as they are performant.<br></p><p>—CK<br></p><p>&gt; On Jan 8, 2016, at 9:04 PM, 品雪 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, I didn&#39;t get it, are you talking about:<br>&gt; <br>&gt; var bytes : [UInt8] = [65, 66, 67, 68, 69, 70];<br>&gt; var s = String.init(bytes: bytes, encoding: NSUTF8StringEncoding)<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; On Sat, Jan 9, 2016 at 8:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I support this change as well.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Fri, Jan 8, 2016 at 6:06 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Complete agreement from me. I would like to see a String constructor from a Sequence of code units.<br>&gt; Also, why is String.fromCString() a factory function rather than a fallible constructor?<br>&gt; <br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Best Regards!<br>&gt; <br>&gt; Yang Wu<br>&gt; --------------------------------------------------------<br>&gt; Location: Pudong, Shanghai, China.<br>&gt; EMail    : pinxue at gmail.com &lt;mailto:pinxue at gmail.com&gt;<br>&gt; Website: http://www.time2change.mobi &lt;http://www.time2change.mobi/&gt; http://rockplayer.com &lt;http://rockplayer.com/&gt;<br>&gt; Twitter/Weibo : @pinxue<br>&gt;  &lt;http://www.pinxue.net/&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/44bea0e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  8, 2016 at 10:00:00pm</p></header><div class="content"><p>I think it would be more appropriate to use `init(utf8:<br>UnsafeBufferPointer&lt;UInt8&gt;)`, which comprises both a base pointer and a<br>length.<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, Jan 8, 2016 at 9:58 PM, Charles Kissinger via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The String initializer that would actually be of most value to me would be:<br>&gt;<br>&gt; String.init(utf8: UnsafePointer&lt;UInt8&gt;, length: Int)<br>&gt;<br>&gt; as long as it is as fast (preferably faster) than String.fromCString() and<br>&gt; doesn’t require bridging to NSString. A similar initializer is available<br>&gt; for NSString, but as Zach indicated in his link, using it is slow.<br>&gt;<br>&gt; Several other initializers, including the one you showed, would be useful,<br>&gt; as long as they are performant.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt; On Jan 8, 2016, at 9:04 PM, 品雪 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sorry, I didn&#39;t get it, are you talking about:<br>&gt;<br>&gt; var bytes : [UInt8] = [65, 66, 67, 68, 69, 70];<br>&gt; var s = String.init(bytes: bytes, encoding: NSUTF8StringEncoding)<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 8:22 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I support this change as well.<br>&gt;&gt;<br>&gt;&gt; TJ<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 8, 2016 at 6:06 PM, Guillaume Lessard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Complete agreement from me. I would like to see a String constructor<br>&gt;&gt;&gt; from a Sequence of code units.<br>&gt;&gt;&gt; Also, why is String.fromCString() a factory function rather than a<br>&gt;&gt;&gt; fallible constructor?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Guillaume Lessard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Best Regards!<br>&gt;<br>&gt; Yang Wu<br>&gt; --------------------------------------------------------<br>&gt; Location: Pudong, Shanghai, China.<br>&gt; EMail    : pinxue at gmail.com<br>&gt; Website: http://www.time2change.mobi http://rockplayer.com<br>&gt; Twitter/Weibo : @pinxue<br>&gt; &lt;http://www.pinxue.net/&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/73d5df61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Faster/lower-level external String initialization</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:02 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think it would be more appropriate to use `init(utf8: UnsafeBufferPointer&lt;UInt8&gt;)`, which comprises both a base pointer and a length.<br></p><p>Yes. Better.<br></p><p>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Fri, Jan 8, 2016 at 9:58 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The String initializer that would actually be of most value to me would be:<br>&gt; <br>&gt; String.init(utf8: UnsafePointer&lt;UInt8&gt;, length: Int)<br>&gt; <br>&gt; as long as it is as fast (preferably faster) than String.fromCString() and doesn’t require bridging to NSString. A similar initializer is available for NSString, but as Zach indicated in his link, using it is slow.<br>&gt; <br>&gt; Several other initializers, including the one you showed, would be useful, as long as they are performant.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:04 PM, 品雪 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I didn&#39;t get it, are you talking about:<br>&gt;&gt; <br>&gt;&gt; var bytes : [UInt8] = [65, 66, 67, 68, 69, 70];<br>&gt;&gt; var s = String.init(bytes: bytes, encoding: NSUTF8StringEncoding)<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; On Sat, Jan 9, 2016 at 8:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I support this change as well.<br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 8, 2016 at 6:06 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Complete agreement from me. I would like to see a String constructor from a Sequence of code units.<br>&gt;&gt; Also, why is String.fromCString() a factory function rather than a fallible constructor?<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Best Regards!<br>&gt;&gt; <br>&gt;&gt; Yang Wu<br>&gt;&gt; --------------------------------------------------------<br>&gt;&gt; Location: Pudong, Shanghai, China.<br>&gt;&gt; EMail    : pinxue at gmail.com &lt;mailto:pinxue at gmail.com&gt;<br>&gt;&gt; Website: http://www.time2change.mobi &lt;http://www.time2change.mobi/&gt; http://rockplayer.com &lt;http://rockplayer.com/&gt;<br>&gt;&gt; Twitter/Weibo : @pinxue<br>&gt;&gt;  &lt;http://www.pinxue.net/&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/0da9414e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Given the initial positive response, I&#39;ve taken a crack both at<br>implementation and converting the request to a proposal. The proposal<br>draft is located at:<br></p><p>    https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br></p><p>The code is located at:<br></p><p>    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br></p><p>The proposal is reproduced below:<br></p><p># Expose code unit initializers on String<br></p><p>* Proposal:<br>[SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>* Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>* Status: **Awaiting review**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>Going back and forth from Strings to their byte representations is an<br>important part of solving many problems, including object<br>serialization, binary file formats, wire/network interfaces, and<br>cryptography. Swift has such utilities, currently only exposed through<br>`String.Type.fromCString(_:)`.<br></p><p>See swift-evolution<br>[thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br></p><p>## Motivation<br></p><p>In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>Swift&#39;s Unicode types. He swore up and down that<br>`String.Type.fromCString(_:)`<br>([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>was the fastest way he found. I, stubborn and noobish as I am, was<br>skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>`UnicodeCodecType`s.<br></p><p>After reading through stdlib source and doing my own testing, this is no<br>wives&#39;<br>tale. `fromCString` is essentially the only public-facing user of<br>`String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>role of<br>both efficient and safe initialization-by-buffer-copy.<br></p><p>Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>sentinel,<br>requiring a copy of the origin buffer if one needs to be added (as is<br>the<br>case with formats that specify the length up front, or unstructured<br>payloads<br>that use unescaped double quotes as the terminator). It also prevents<br>the string itself from containing the null character.<br></p><p># Proposed solution<br></p><p>I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>public API:<br></p><p>```swift<br>init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>encoding: Encoding.Type)<br>```<br></p><p>And, for consistency with<br>`String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br></p><p>```swift<br>static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>UnicodeCodecType where Encoding.CodeUnit ==<br>Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br></p><p>## Detailed design<br></p><p>See [full<br>implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br></p><p>This is a fairly straightforward renaming of the internal APIs.<br></p><p>The initializer, its labels, and their order were chosen to match other<br>non-cast<br>initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>misnomer.<br>&quot;input&quot; was kept as a generic name in order to allow for future<br>refinements.<br></p><p>The static initializer made the same changes, but was otherwise kept as<br>a<br>factory function due to its multiple return values.<br></p><p>`String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>for<br>internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>for<br>lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>the<br>wellformedness of their code units. Since it is a simple call through,<br>its<br>use could be elided throughout the stdlib.<br></p><p>## Impact on existing code<br></p><p>This is an additive change to the API.<br></p><p>## Alternatives considered<br></p><p>* A protocol-oriented API.<br></p><p>Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>really<br>clear this method would be related to string processing, and would<br>require<br>some kind of bounding (like `where Generator.Element:<br>UnsignedIntegerType`), but<br>that would be introducing a type bound that doesn&#39;t exist on<br></p><p>* Do nothing.<br></p><p>This seems suboptimal. For many use cases, `String` lacking this<br>constructor is<br>a limiting factor on performance for many kinds of pure-Swift<br>implementations.<br></p><p>* Make the `NSString` [bridge<br>faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br></p><p>After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>Maybe it&#39;s<br>a bug.<br></p><p>* Make `String.append(_:)`<br>[faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br></p><p>I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>`reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>noted that<br>it seems like `reserveCapacity` acts like a no-op.<br></p><p>----<br></p><p>Cheers,<br>Zachary Waldowski<br>zach at waldowski.me<br></p><p>On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt; Going back and forth from Strings to their byte representations is an<br>&gt; important part of solving many problems, including object<br>&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; cryptography.<br>&gt; <br>&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt; benchmarking<br>&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; String.Type.fromCString(_:) [0]<br>&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; skeptical<br>&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt; <br>&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; wives&#39;<br>&gt; tale. fromCString [1] is essentially the only public user of<br>&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt; of<br>&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; <br>&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt; sentinel,<br>&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; the<br>&gt; case with formats that specify the length up front, or unstructured<br>&gt; payloads<br>&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; the string<br>&gt; itself from containing the null character.<br>&gt; <br>&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt; If that<br>&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt; would be<br>&gt; nice, and we can just eat the performance hit on other code unit<br>&gt; sequences.<br>&gt; <br>&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt; believe<br>&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt; ;-)<br>&gt; <br>&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt; have<br>&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt; hitting<br>&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt; creating<br>&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt; with<br>&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt; <br>&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt; whether<br>&gt; this can be turned into a proposal.<br>&gt; <br>&gt; [0]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt; [1]:<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt; [2]:<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt; [3]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt; [4]:<br>&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt; <br>&gt; Cheers,<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 12, 2016 at 11:00:00am</p></header><div class="content"><p>Zach,<br></p><p>Thanks very much for writing up this proposal! This will be a very valuable addition to the standard library for some of us. My comments are below:<br></p><p>&gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt; implementation and converting the request to a proposal. The proposal<br>&gt; draft is located at:<br>&gt; <br>&gt;    https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt; <br>&gt; The code is located at:<br>&gt; <br>&gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; <br>&gt; The proposal is reproduced below:<br>&gt; <br>&gt; # Expose code unit initializers on String<br>&gt; <br>&gt; * Proposal:<br>&gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Going back and forth from Strings to their byte representations is an<br>&gt; important part of solving many problems, including object<br>&gt; serialization, binary file formats,<br></p><p>binary *and* text file formats!<br></p><p>&gt; wire/network interfaces, and<br>&gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt; `String.Type.fromCString(_:)`.<br>&gt; <br>&gt; See swift-evolution<br>&gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; `String.Type.fromCString(_:)`<br>&gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt; `UnicodeCodecType`s.<br>&gt; <br>&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; wives&#39;<br>&gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt; role of<br>&gt; both efficient and safe initialization-by-buffer-copy.<br></p><p>It might be worth mentioning here in the Motivation section that String.append(_: UnicodeScalar) is not a viable alternative in many cases because it has much slower performance. (I know it is discussed below under alternatives.)<br></p><p>&gt; <br>&gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt; sentinel,<br>&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; the<br>&gt; case with formats that specify the length up front, or unstructured<br>&gt; payloads<br>&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; the string itself from containing the null character.<br></p><p>This also means that something as fundamental as parsing sub-strings out of an NSData object requires copying to intermediate buffers or the use of much slower character-by-character appends.<br></p><p>Another limitation is that `fromCString` only works with UTF8 (or ASCII) encoding.<br></p><p>It is worth mentioning also that the implementation of fromCString() involves a string length calculation (call to strlen()). In many cases that length has already been calculated in the client code. The proposed solution has the potential of being at least slightly faster because the strlen call is not needed. Maybe this should go in the Proposed Solution section.<br></p><p>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt; public API:<br>&gt; <br>&gt; ```swift<br>&gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt; encoding: Encoding.Type)<br>&gt; ```<br>&gt; <br>&gt; And, for consistency with<br>&gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt; <br>&gt; ```swift<br>&gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt; <br></p><p>These two functions seem like a good approach. The only alternatives I can think of are either to have a `withRepair: Bool` parameter to the initializer (possibly with a default value) or to make the initializer a type method instead for complete consistency with fromCString() and fromCStringRepairingIllFormedUTF8().<br></p><p>It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br></p><p>&gt; ## Detailed design<br>&gt; <br>&gt; See [full<br>&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt; <br>&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt; <br>&gt; The initializer, its labels, and their order were chosen to match other<br>&gt; non-cast<br>&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt; misnomer.<br>&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt; refinements.<br>&gt; <br>&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt; a<br>&gt; factory function due to its multiple return values.<br>&gt; <br>&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt; for<br>&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt; for<br>&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt; the<br>&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt; its<br>&gt; use could be elided throughout the stdlib.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This is an additive change to the API.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; * A protocol-oriented API.<br>&gt; <br>&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt; really<br>&gt; clear this method would be related to string processing, and would<br>&gt; require<br>&gt; some kind of bounding (like `where Generator.Element:<br>&gt; UnsignedIntegerType`), but<br>&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt; <br>&gt; * Do nothing.<br>&gt; <br>&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt; constructor is<br>&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt; implementations.<br></p><p>And performance is extremely important in many file parsing scenarios because the size of the input files is unpredictable (and often large!).<br></p><p>&gt; * Make the `NSString` [bridge<br>&gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt; <br>&gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt; Maybe it&#39;s<br>&gt; a bug.<br>&gt; <br>&gt; * Make `String.append(_:)`<br>&gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt; <br>&gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt; noted that<br>&gt; it seems like `reserveCapacity` acts like a no-op.<br></p><p>Even if the performance problems here are fixed, relying on String.append() would still lead to more verbose code than the proposed direct initializer or factory function.<br></p><p>&gt; ----<br>&gt; <br>&gt; Cheers,<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt; important part of solving many problems, including object<br>&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt; cryptography.<br>&gt;&gt; <br>&gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt;&gt; benchmarking<br>&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt; String.Type.fromCString(_:) [0]<br>&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt; skeptical<br>&gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt;&gt; <br>&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt; wives&#39;<br>&gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt;&gt; of<br>&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt; <br>&gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt; sentinel,<br>&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt; the<br>&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt; payloads<br>&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt; the string<br>&gt;&gt; itself from containing the null character.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt;&gt; If that<br>&gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt;&gt; would be<br>&gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt;&gt; sequences.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt;&gt; believe<br>&gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt;&gt; ;-)<br>&gt;&gt; <br>&gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt;&gt; have<br>&gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt;&gt; hitting<br>&gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt;&gt; creating<br>&gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt;&gt; with<br>&gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt;&gt; <br>&gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt;&gt; whether<br>&gt;&gt; this can be turned into a proposal.<br>&gt;&gt; <br>&gt;&gt; [0]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt;&gt; [1]:<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt;&gt; [2]:<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt;&gt; [3]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt;&gt; [4]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Zachary Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br></p><p>There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br></p><p>&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; See [full<br>&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt;&gt; <br>&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt; <br>&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt; non-cast<br>&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt; misnomer.<br>&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt; refinements.<br>&gt;&gt; <br>&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt; a<br>&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt; <br>&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt; for<br>&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt; for<br>&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt; the<br>&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt; its<br>&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is an additive change to the API.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; * A protocol-oriented API.<br>&gt;&gt; <br>&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt; really<br>&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt; require<br>&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt; <br>&gt;&gt; * Do nothing.<br>&gt;&gt; <br>&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt; constructor is<br>&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt; implementations.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/51ca5014/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>January 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 12:08 PM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt; <br>&gt; There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br></p><p>Can the initializer take an inout parameter instead? Seems like it would be better to keep a consistent &quot;initializer story.&quot;<br></p><p>&gt;&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See [full<br>&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt; its<br>&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt; really<br>&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt; require<br>&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt; implementations.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/81669854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Alex,<br></p><p>If you mean that we still need to have initializers for both cases, we do. It’s just that in one of them (the repairing on) we throw away the information about whether repairs were made, which a) we don’t care in many cases and b) can still have using String.decodeCString.<br></p><p>Having an inout parameter in an initializer will break the (I think) common use case, where you get a CString from some C API, and want to call some Swift API that accepts String. I would do it like `swiftApi(String(cString))`, with inout it gets weird.<br></p><p>What do you think?<br></p><p>max<br></p><p>&gt; On Jan 12, 2016, at 1:00 PM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Jan 12, 2016, at 12:08 PM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt; <br>&gt;&gt; There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br>&gt; <br>&gt; Can the initializer take an inout parameter instead? Seems like it would be better to keep a consistent &quot;initializer story.&quot;<br>&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See [full<br>&gt;&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units &lt;https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt;&gt; its<br>&gt;&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt;&gt; really<br>&gt;&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt;&gt; require<br>&gt;&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt;&gt; implementations.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/08fba509/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I was trying to say that any tuple returning factory method can be turned into an initializer with an inout param. e.g.<br></p><p>struct F {<br>     func makeF() -&gt; (F?, Int)<br>}<br></p><p>can be made into:<br></p><p>struct F {<br>     init?(inout result: Int) { … }<br>}<br></p><p>I think you should still be able to call an initializer like that with your `swiftApi(String(cString))` example, right? It would just be `swiftApi(String(cString, foo: &amp;otherTupleValue). I thought the proposed alternative would look more like `swiftApi(String.fromCString(cString).0)` (I’ve lost track at this point about what the exact API proposal is, sorry).<br></p><p>With this approach every time you need to create a String you go through a String initializer—you don’t need to think if it’s a factory method or an initializer. That’s what I was trying to get at about keeping the “initializer story&quot; consistent.<br></p><p>- Alex<br></p><p>&gt; On Jan 12, 2016, at 5:01 PM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Alex,<br>&gt; <br>&gt; If you mean that we still need to have initializers for both cases, we do. It’s just that in one of them (the repairing on) we throw away the information about whether repairs were made, which a) we don’t care in many cases and b) can still have using String.decodeCString.<br>&gt; <br>&gt; Having an inout parameter in an initializer will break the (I think) common use case, where you get a CString from some C API, and want to call some Swift API that accepts String. I would do it like `swiftApi(String(cString))`, with inout it gets weird.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; max<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 1:00 PM, Alex Migicovsky &lt;migi at apple.com &lt;mailto:migi at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 12, 2016, at 12:08 PM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br>&gt;&gt; <br>&gt;&gt; Can the initializer take an inout parameter instead? Seems like it would be better to keep a consistent &quot;initializer story.&quot;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See [full<br>&gt;&gt;&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units &lt;https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units&gt;).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt;&gt;&gt; its<br>&gt;&gt;&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt;&gt;&gt; really<br>&gt;&gt;&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt;&gt;&gt; require<br>&gt;&gt;&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt;&gt;&gt; implementations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/84e20bf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>Oops, that first struct should be this:<br></p><p>struct F {<br>     static func makeF() -&gt; (F?, Int)<br>}<br></p><p>- Alex<br></p><p>&gt; On Jan 12, 2016, at 5:25 PM, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was trying to say that any tuple returning factory method can be turned into an initializer with an inout param. e.g.<br>&gt; <br>&gt; struct F {<br>&gt;      func makeF() -&gt; (F?, Int)<br>&gt; }<br>&gt; <br>&gt; can be made into:<br>&gt; <br>&gt; struct F {<br>&gt;      init?(inout result: Int) { … }<br>&gt; }<br>&gt; <br>&gt; I think you should still be able to call an initializer like that with your `swiftApi(String(cString))` example, right? It would just be `swiftApi(String(cString, foo: &amp;otherTupleValue). I thought the proposed alternative would look more like `swiftApi(String.fromCString(cString).0)` (I’ve lost track at this point about what the exact API proposal is, sorry).<br>&gt; <br>&gt; With this approach every time you need to create a String you go through a String initializer—you don’t need to think if it’s a factory method or an initializer. That’s what I was trying to get at about keeping the “initializer story&quot; consistent.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:01 PM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Alex,<br>&gt;&gt; <br>&gt;&gt; If you mean that we still need to have initializers for both cases, we do. It’s just that in one of them (the repairing on) we throw away the information about whether repairs were made, which a) we don’t care in many cases and b) can still have using String.decodeCString.<br>&gt;&gt; <br>&gt;&gt; Having an inout parameter in an initializer will break the (I think) common use case, where you get a CString from some C API, and want to call some Swift API that accepts String. I would do it like `swiftApi(String(cString))`, with inout it gets weird.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; max<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 1:00 PM, Alex Migicovsky &lt;migi at apple.com &lt;mailto:migi at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 12:08 PM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can the initializer take an inout parameter instead? Seems like it would be better to keep a consistent &quot;initializer story.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; See [full<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units &lt;https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt;&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt;&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt;&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt;&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt;&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt;&gt;&gt;&gt; its<br>&gt;&gt;&gt;&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt;&gt;&gt;&gt; really<br>&gt;&gt;&gt;&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt;&gt;&gt;&gt; require<br>&gt;&gt;&gt;&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt;&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt;&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt;&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/314faf65/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; I think you should still be able to call an initializer like that with your `swiftApi(String(cString))` example, right? It would just be `swiftApi(String(cString, foo: &amp;otherTupleValue). I thought the proposed alternative would look more like `swiftApi(String.fromCString(cString).0)`<br></p><p>Yes, you can do that, but the variable you pass as inout should be declared somewhere, so you call becomes `var inoutVar: Bool; swiftApi(String(cString, foo: &amp;inoutVar))`. Slightly more complicated, that is.<br></p><p>&gt;  (I’ve lost track at this point about what the exact API proposal is, sorry).<br>That we are trying to figure out here =)<br></p><p>max<br></p><p>&gt; On Jan 12, 2016, at 5:25 PM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt; <br>&gt; I was trying to say that any tuple returning factory method can be turned into an initializer with an inout param. e.g.<br>&gt; <br>&gt; struct F {<br>&gt;      func makeF() -&gt; (F?, Int)<br>&gt; }<br>&gt; <br>&gt; can be made into:<br>&gt; <br>&gt; struct F {<br>&gt;      init?(inout result: Int) { … }<br>&gt; }<br>&gt; <br>&gt; I think you should still be able to call an initializer like that with your `swiftApi(String(cString))` example, right? It would just be `swiftApi(String(cString, foo: &amp;otherTupleValue). I thought the proposed alternative would look more like `swiftApi(String.fromCString(cString).0)` (I’ve lost track at this point about what the exact API proposal is, sorry).<br>&gt; <br>&gt; With this approach every time you need to create a String you go through a String initializer—you don’t need to think if it’s a factory method or an initializer. That’s what I was trying to get at about keeping the “initializer story&quot; consistent.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:01 PM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Alex,<br>&gt;&gt; <br>&gt;&gt; If you mean that we still need to have initializers for both cases, we do. It’s just that in one of them (the repairing on) we throw away the information about whether repairs were made, which a) we don’t care in many cases and b) can still have using String.decodeCString.<br>&gt;&gt; <br>&gt;&gt; Having an inout parameter in an initializer will break the (I think) common use case, where you get a CString from some C API, and want to call some Swift API that accepts String. I would do it like `swiftApi(String(cString))`, with inout it gets weird.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; max<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 1:00 PM, Alex Migicovsky &lt;migi at apple.com &lt;mailto:migi at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 12:08 PM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There probably were no failable initializers when it was first implemented. The other thing is `fromCStringRepairingIllFormedUTF8` returns a tuple, so cannot be an initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can the initializer take an inout parameter instead? Seems like it would be better to keep a consistent &quot;initializer story.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 12, 2016, at 11:18 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be nice to get some feedback from someone at Apple as to why fromCString() was implemented as a type method instead of a failable initializer. Presumably it was because there is both a repairing and a failable, non-repairing version. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; See [full<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units &lt;https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt;&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt;&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt;&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt;&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt;&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt;&gt;&gt;&gt; its<br>&gt;&gt;&gt;&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt;&gt;&gt;&gt; really<br>&gt;&gt;&gt;&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt;&gt;&gt;&gt; require<br>&gt;&gt;&gt;&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt;&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt;&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt;&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/fe557e57/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Though Max&#39;s follow-up might call into question the need for the<br>proposal (in a perfect world I&#39;d like to see this in 2.2), I&#39;ve<br>addressed your comments. Thanks!<br></p><p>-- <br>Zach Waldowski<br>zach at waldowski.me<br></p><p>On Tue, Jan 12, 2016, at 02:18 PM, Charles Kissinger wrote:<br>&gt; Zach,<br>&gt; <br>&gt; Thanks very much for writing up this proposal! This will be a very<br>&gt; valuable addition to the standard library for some of us. My comments are<br>&gt; below:<br>&gt; <br>&gt; &gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt; &gt; implementation and converting the request to a proposal. The proposal<br>&gt; &gt; draft is located at:<br>&gt; &gt; <br>&gt; &gt;    https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt; &gt; <br>&gt; &gt; The code is located at:<br>&gt; &gt; <br>&gt; &gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; &gt; <br>&gt; &gt; The proposal is reproduced below:<br>&gt; &gt; <br>&gt; &gt; # Expose code unit initializers on String<br>&gt; &gt; <br>&gt; &gt; * Proposal:<br>&gt; &gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt; &gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt; &gt; * Status: **Awaiting review**<br>&gt; &gt; * Review manager: TBD<br>&gt; &gt; <br>&gt; &gt; ## Introduction<br>&gt; &gt; <br>&gt; &gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt; important part of solving many problems, including object<br>&gt; &gt; serialization, binary file formats,<br>&gt; <br>&gt; binary *and* text file formats!<br>&gt; <br>&gt; &gt; wire/network interfaces, and<br>&gt; &gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt; &gt; `String.Type.fromCString(_:)`.<br>&gt; &gt; <br>&gt; &gt; See swift-evolution<br>&gt; &gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt; &gt; <br>&gt; &gt; ## Motivation<br>&gt; &gt; <br>&gt; &gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt; &gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt; `String.Type.fromCString(_:)`<br>&gt; &gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt; &gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt; &gt; `UnicodeCodecType`s.<br>&gt; &gt; <br>&gt; &gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt; wives&#39;<br>&gt; &gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt; &gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt; &gt; role of<br>&gt; &gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; <br>&gt; It might be worth mentioning here in the Motivation section that<br>&gt; String.append(_: UnicodeScalar) is not a viable alternative in many cases<br>&gt; because it has much slower performance. (I know it is discussed below<br>&gt; under alternatives.)<br>&gt; <br>&gt; &gt; <br>&gt; &gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt; sentinel,<br>&gt; &gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt; the<br>&gt; &gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt; payloads<br>&gt; &gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt; the string itself from containing the null character.<br>&gt; <br>&gt; This also means that something as fundamental as parsing sub-strings out<br>&gt; of an NSData object requires copying to intermediate buffers or the use<br>&gt; of much slower character-by-character appends.<br>&gt; <br>&gt; Another limitation is that `fromCString` only works with UTF8 (or ASCII)<br>&gt; encoding.<br>&gt; <br>&gt; It is worth mentioning also that the implementation of fromCString()<br>&gt; involves a string length calculation (call to strlen()). In many cases<br>&gt; that length has already been calculated in the client code. The proposed<br>&gt; solution has the potential of being at least slightly faster because the<br>&gt; strlen call is not needed. Maybe this should go in the Proposed Solution<br>&gt; section.<br>&gt; <br>&gt; &gt; <br>&gt; &gt; # Proposed solution<br>&gt; &gt; <br>&gt; &gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt; &gt; public API:<br>&gt; &gt; <br>&gt; &gt; ```swift<br>&gt; &gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt; &gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt; &gt; encoding: Encoding.Type)<br>&gt; &gt; ```<br>&gt; &gt; <br>&gt; &gt; And, for consistency with<br>&gt; &gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt; &gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt; &gt; <br>&gt; &gt; ```swift<br>&gt; &gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt; &gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt; &gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt; &gt; <br>&gt; <br>&gt; These two functions seem like a good approach. The only alternatives I<br>&gt; can think of are either to have a `withRepair: Bool` parameter to the<br>&gt; initializer (possibly with a default value) or to make the initializer a<br>&gt; type method instead for complete consistency with fromCString() and<br>&gt; fromCStringRepairingIllFormedUTF8().<br>&gt; <br>&gt; It would be nice to get some feedback from someone at Apple as to why<br>&gt; fromCString() was implemented as a type method instead of a failable<br>&gt; initializer. Presumably it was because there is both a repairing and a<br>&gt; failable, non-repairing version. <br>&gt; <br>&gt; &gt; ## Detailed design<br>&gt; &gt; <br>&gt; &gt; See [full<br>&gt; &gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt; &gt; <br>&gt; &gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt; &gt; <br>&gt; &gt; The initializer, its labels, and their order were chosen to match other<br>&gt; &gt; non-cast<br>&gt; &gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt; &gt; misnomer.<br>&gt; &gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt; &gt; refinements.<br>&gt; &gt; <br>&gt; &gt; The static initializer made the same changes, but was otherwise kept as<br>&gt; &gt; a<br>&gt; &gt; factory function due to its multiple return values.<br>&gt; &gt; <br>&gt; &gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt; &gt; for<br>&gt; &gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt; &gt; for<br>&gt; &gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt; &gt; the<br>&gt; &gt; wellformedness of their code units. Since it is a simple call through,<br>&gt; &gt; its<br>&gt; &gt; use could be elided throughout the stdlib.<br>&gt; &gt; <br>&gt; &gt; ## Impact on existing code<br>&gt; &gt; <br>&gt; &gt; This is an additive change to the API.<br>&gt; &gt; <br>&gt; &gt; ## Alternatives considered<br>&gt; &gt; <br>&gt; &gt; * A protocol-oriented API.<br>&gt; &gt; <br>&gt; &gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt; &gt; really<br>&gt; &gt; clear this method would be related to string processing, and would<br>&gt; &gt; require<br>&gt; &gt; some kind of bounding (like `where Generator.Element:<br>&gt; &gt; UnsignedIntegerType`), but<br>&gt; &gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt; &gt; <br>&gt; &gt; * Do nothing.<br>&gt; &gt; <br>&gt; &gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt; &gt; constructor is<br>&gt; &gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt; &gt; implementations.<br>&gt; <br>&gt; And performance is extremely important in many file parsing scenarios<br>&gt; because the size of the input files is unpredictable (and often large!).<br>&gt; <br>&gt; &gt; * Make the `NSString` [bridge<br>&gt; &gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt; &gt; <br>&gt; &gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt; &gt; Maybe it&#39;s<br>&gt; &gt; a bug.<br>&gt; &gt; <br>&gt; &gt; * Make `String.append(_:)`<br>&gt; &gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt; &gt; <br>&gt; &gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt; &gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt; &gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt; &gt; noted that<br>&gt; &gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt; <br>&gt; Even if the performance problems here are fixed, relying on<br>&gt; String.append() would still lead to more verbose code than the proposed<br>&gt; direct initializer or factory function.<br>&gt; <br>&gt; &gt; ----<br>&gt; &gt; <br>&gt; &gt; Cheers,<br>&gt; &gt; Zachary Waldowski<br>&gt; &gt; zach at waldowski.me<br>&gt; &gt; <br>&gt; &gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt; &gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt;&gt; important part of solving many problems, including object<br>&gt; &gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; &gt;&gt; cryptography.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt; &gt;&gt; benchmarking<br>&gt; &gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt;&gt; String.Type.fromCString(_:) [0]<br>&gt; &gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt;&gt; skeptical<br>&gt; &gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt;&gt; wives&#39;<br>&gt; &gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt; &gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt; &gt;&gt; of<br>&gt; &gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt;&gt; sentinel,<br>&gt; &gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt;&gt; the<br>&gt; &gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt;&gt; payloads<br>&gt; &gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt;&gt; the string<br>&gt; &gt;&gt; itself from containing the null character.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt; &gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt; &gt;&gt; If that<br>&gt; &gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt; &gt;&gt; would be<br>&gt; &gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt; &gt;&gt; sequences.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt; &gt;&gt; believe<br>&gt; &gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt; &gt;&gt; ;-)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt; &gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt; &gt;&gt; have<br>&gt; &gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt; &gt;&gt; hitting<br>&gt; &gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt; &gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt; &gt;&gt; creating<br>&gt; &gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt; &gt;&gt; with<br>&gt; &gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt; &gt;&gt; whether<br>&gt; &gt;&gt; this can be turned into a proposal.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; [0]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt; &gt;&gt; [1]:<br>&gt; &gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt; &gt;&gt; [2]:<br>&gt; &gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt; &gt;&gt; [3]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt; &gt;&gt; [4]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt; Zachary Waldowski<br>&gt; &gt;&gt; zach at waldowski.me<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 12, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Zach,<br></p><p>We looked at the CString APIs as part of API Naming Guidelines application effort.<br>You can see the results here: https://github.com/apple/swift/commit/f4aaece75e97379db6ba0a1fdb1da42c231a1c3b<br></p><p>The main idea is to turn static factories into initializers and make init(cString:) do ‘most probably the right thing’, i.e. repair UTF8 code units.<br></p><p>Haven’t looked at your proposal in details, but I think that if we add a new String.decodeCString that accepts an UnsafeBufferPointer instead of an UnsafePointer (and does not have to call _swift_stdlib_strlen), that would solve the problem. Unless I’m missing something.<br></p><p>regards,<br>max<br></p><p>&gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt; implementation and converting the request to a proposal. The proposal<br>&gt; draft is located at:<br>&gt; <br>&gt;    https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt; <br>&gt; The code is located at:<br>&gt; <br>&gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; <br>&gt; The proposal is reproduced below:<br>&gt; <br>&gt; # Expose code unit initializers on String<br>&gt; <br>&gt; * Proposal:<br>&gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Going back and forth from Strings to their byte representations is an<br>&gt; important part of solving many problems, including object<br>&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt; `String.Type.fromCString(_:)`.<br>&gt; <br>&gt; See swift-evolution<br>&gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; `String.Type.fromCString(_:)`<br>&gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt; `UnicodeCodecType`s.<br>&gt; <br>&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; wives&#39;<br>&gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt; role of<br>&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; <br>&gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt; sentinel,<br>&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; the<br>&gt; case with formats that specify the length up front, or unstructured<br>&gt; payloads<br>&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; the string itself from containing the null character.<br>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt; public API:<br>&gt; <br>&gt; ```swift<br>&gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt; encoding: Encoding.Type)<br>&gt; ```<br>&gt; <br>&gt; And, for consistency with<br>&gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt; <br>&gt; ```swift<br>&gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; See [full<br>&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt; <br>&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt; <br>&gt; The initializer, its labels, and their order were chosen to match other<br>&gt; non-cast<br>&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt; misnomer.<br>&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt; refinements.<br>&gt; <br>&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt; a<br>&gt; factory function due to its multiple return values.<br>&gt; <br>&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt; for<br>&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt; for<br>&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt; the<br>&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt; its<br>&gt; use could be elided throughout the stdlib.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This is an additive change to the API.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; * A protocol-oriented API.<br>&gt; <br>&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt; really<br>&gt; clear this method would be related to string processing, and would<br>&gt; require<br>&gt; some kind of bounding (like `where Generator.Element:<br>&gt; UnsignedIntegerType`), but<br>&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt; <br>&gt; * Do nothing.<br>&gt; <br>&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt; constructor is<br>&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt; implementations.<br>&gt; <br>&gt; * Make the `NSString` [bridge<br>&gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt; <br>&gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt; Maybe it&#39;s<br>&gt; a bug.<br>&gt; <br>&gt; * Make `String.append(_:)`<br>&gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt; <br>&gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt; noted that<br>&gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Cheers,<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt; important part of solving many problems, including object<br>&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt; cryptography.<br>&gt;&gt; <br>&gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt;&gt; benchmarking<br>&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt; String.Type.fromCString(_:) [0]<br>&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt; skeptical<br>&gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt;&gt; <br>&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt; wives&#39;<br>&gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt;&gt; of<br>&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt; <br>&gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt; sentinel,<br>&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt; the<br>&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt; payloads<br>&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt; the string<br>&gt;&gt; itself from containing the null character.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt;&gt; If that<br>&gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt;&gt; would be<br>&gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt;&gt; sequences.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt;&gt; believe<br>&gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt;&gt; ;-)<br>&gt;&gt; <br>&gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt;&gt; have<br>&gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt;&gt; hitting<br>&gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt;&gt; creating<br>&gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt;&gt; with<br>&gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt;&gt; <br>&gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt;&gt; whether<br>&gt;&gt; this can be turned into a proposal.<br>&gt;&gt; <br>&gt;&gt; [0]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt;&gt; [1]:<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt;&gt; [2]:<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt;&gt; [3]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt;&gt; [4]:<br>&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Zachary Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Max,<br></p><p>Seems like a fantastic change, if indeed the move is made from<br>UnsafePointer to UnsafeBufferPointer! That still doesn&#39;t cover the case<br>where you&#39;d be doing code-unit level transforms (i.e., for custom<br>encoding schemes in some formats, like the Unicode escapes in JSON), but<br>that can probably also be done at the String level after-the-fact.<br></p><p>Awesome change, though! It&#39;d be a shame to have to wait until 3.0 for it<br>to land.<br></p><p>-- <br>Zach Waldowski<br>zach at waldowski.me<br></p><p>On Tue, Jan 12, 2016, at 02:57 PM, Max Moiseev wrote:<br>&gt; Hi Zach,<br>&gt; <br>&gt; We looked at the CString APIs as part of API Naming Guidelines<br>&gt; application effort.<br>&gt; You can see the results here:<br>&gt; https://github.com/apple/swift/commit/f4aaece75e97379db6ba0a1fdb1da42c231a1c3b<br>&gt; <br>&gt; The main idea is to turn static factories into initializers and make<br>&gt; init(cString:) do ‘most probably the right thing’, i.e. repair UTF8 code<br>&gt; units.<br>&gt; <br>&gt; Haven’t looked at your proposal in details, but I think that if we add a<br>&gt; new String.decodeCString that accepts an UnsafeBufferPointer instead of<br>&gt; an UnsafePointer (and does not have to call _swift_stdlib_strlen), that<br>&gt; would solve the problem. Unless I’m missing something.<br>&gt; <br>&gt; regards,<br>&gt; max<br>&gt; <br>&gt; &gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt; &gt; implementation and converting the request to a proposal. The proposal<br>&gt; &gt; draft is located at:<br>&gt; &gt; <br>&gt; &gt;    https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt; &gt; <br>&gt; &gt; The code is located at:<br>&gt; &gt; <br>&gt; &gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; &gt; <br>&gt; &gt; The proposal is reproduced below:<br>&gt; &gt; <br>&gt; &gt; # Expose code unit initializers on String<br>&gt; &gt; <br>&gt; &gt; * Proposal:<br>&gt; &gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt; &gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt; &gt; * Status: **Awaiting review**<br>&gt; &gt; * Review manager: TBD<br>&gt; &gt; <br>&gt; &gt; ## Introduction<br>&gt; &gt; <br>&gt; &gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt; important part of solving many problems, including object<br>&gt; &gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; &gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt; &gt; `String.Type.fromCString(_:)`.<br>&gt; &gt; <br>&gt; &gt; See swift-evolution<br>&gt; &gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt; &gt; <br>&gt; &gt; ## Motivation<br>&gt; &gt; <br>&gt; &gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt; &gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt; `String.Type.fromCString(_:)`<br>&gt; &gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt; &gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt; &gt; `UnicodeCodecType`s.<br>&gt; &gt; <br>&gt; &gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt; wives&#39;<br>&gt; &gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt; &gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt; &gt; role of<br>&gt; &gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; &gt; <br>&gt; &gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt; sentinel,<br>&gt; &gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt; the<br>&gt; &gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt; payloads<br>&gt; &gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt; the string itself from containing the null character.<br>&gt; &gt; <br>&gt; &gt; # Proposed solution<br>&gt; &gt; <br>&gt; &gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt; &gt; public API:<br>&gt; &gt; <br>&gt; &gt; ```swift<br>&gt; &gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt; &gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt; &gt; encoding: Encoding.Type)<br>&gt; &gt; ```<br>&gt; &gt; <br>&gt; &gt; And, for consistency with<br>&gt; &gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt; &gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt; &gt; <br>&gt; &gt; ```swift<br>&gt; &gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt; &gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt; &gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt; &gt; <br>&gt; &gt; ## Detailed design<br>&gt; &gt; <br>&gt; &gt; See [full<br>&gt; &gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt; &gt; <br>&gt; &gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt; &gt; <br>&gt; &gt; The initializer, its labels, and their order were chosen to match other<br>&gt; &gt; non-cast<br>&gt; &gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt; &gt; misnomer.<br>&gt; &gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt; &gt; refinements.<br>&gt; &gt; <br>&gt; &gt; The static initializer made the same changes, but was otherwise kept as<br>&gt; &gt; a<br>&gt; &gt; factory function due to its multiple return values.<br>&gt; &gt; <br>&gt; &gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt; &gt; for<br>&gt; &gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt; &gt; for<br>&gt; &gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt; &gt; the<br>&gt; &gt; wellformedness of their code units. Since it is a simple call through,<br>&gt; &gt; its<br>&gt; &gt; use could be elided throughout the stdlib.<br>&gt; &gt; <br>&gt; &gt; ## Impact on existing code<br>&gt; &gt; <br>&gt; &gt; This is an additive change to the API.<br>&gt; &gt; <br>&gt; &gt; ## Alternatives considered<br>&gt; &gt; <br>&gt; &gt; * A protocol-oriented API.<br>&gt; &gt; <br>&gt; &gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt; &gt; really<br>&gt; &gt; clear this method would be related to string processing, and would<br>&gt; &gt; require<br>&gt; &gt; some kind of bounding (like `where Generator.Element:<br>&gt; &gt; UnsignedIntegerType`), but<br>&gt; &gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt; &gt; <br>&gt; &gt; * Do nothing.<br>&gt; &gt; <br>&gt; &gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt; &gt; constructor is<br>&gt; &gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt; &gt; implementations.<br>&gt; &gt; <br>&gt; &gt; * Make the `NSString` [bridge<br>&gt; &gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt; &gt; <br>&gt; &gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt; &gt; Maybe it&#39;s<br>&gt; &gt; a bug.<br>&gt; &gt; <br>&gt; &gt; * Make `String.append(_:)`<br>&gt; &gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt; &gt; <br>&gt; &gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt; &gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt; &gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt; &gt; noted that<br>&gt; &gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt; &gt; <br>&gt; &gt; ----<br>&gt; &gt; <br>&gt; &gt; Cheers,<br>&gt; &gt; Zachary Waldowski<br>&gt; &gt; zach at waldowski.me<br>&gt; &gt; <br>&gt; &gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt; &gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt;&gt; important part of solving many problems, including object<br>&gt; &gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; &gt;&gt; cryptography.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt; &gt;&gt; benchmarking<br>&gt; &gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt;&gt; String.Type.fromCString(_:) [0]<br>&gt; &gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt;&gt; skeptical<br>&gt; &gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt;&gt; wives&#39;<br>&gt; &gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt; &gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt; &gt;&gt; of<br>&gt; &gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt;&gt; sentinel,<br>&gt; &gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt;&gt; the<br>&gt; &gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt;&gt; payloads<br>&gt; &gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt;&gt; the string<br>&gt; &gt;&gt; itself from containing the null character.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt; &gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt; &gt;&gt; If that<br>&gt; &gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt; &gt;&gt; would be<br>&gt; &gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt; &gt;&gt; sequences.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt; &gt;&gt; believe<br>&gt; &gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt; &gt;&gt; ;-)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt; &gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt; &gt;&gt; have<br>&gt; &gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt; &gt;&gt; hitting<br>&gt; &gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt; &gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt; &gt;&gt; creating<br>&gt; &gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt; &gt;&gt; with<br>&gt; &gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt; &gt;&gt; whether<br>&gt; &gt;&gt; this can be turned into a proposal.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; [0]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt; &gt;&gt; [1]:<br>&gt; &gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt; &gt;&gt; [2]:<br>&gt; &gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt; &gt;&gt; [3]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt; &gt;&gt; [4]:<br>&gt; &gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt; Zachary Waldowski<br>&gt; &gt;&gt; zach at waldowski.me<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Zach, Charles. I’ll try to reply to both of you in one shot.<br></p><p>As @gribozavr pointed out in a private conversation, `UnsafeBufferPointer` conforms to CollectionType, so we can generalize String.decodeCString to accept a CollectionType and constrain it precisely as you, Zach, did in your proposal.<br>(I remember there were some troubles with the fact that CChar is Int8 (signed) and UTF8.CodeUnit is UInt8, but that might not affect this new method).<br></p><p>I don’t quite understand what you mean by `custom code-unit level transforms’, but maybe having a CollectionType can address that.<br></p><p>As for the proposal. This does not have to wait until Swift 3. The change I pointed at was a side effect of revisiting all the APIs in stdlib. So if you guys feel strongly about this change (and I think you do, otherwise you wouldn’t go as far as writing a proposal document), you can take what’s in the swift-3-api-guidelines branch, implement the new method we’ve discussed, add some ‘deprecation’ magic to make it compatible with Swift 2.1 and run it through the evolution process.<br></p><p>max<br></p><p><br>&gt; On Jan 12, 2016, at 12:22 PM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; Max,<br>&gt; <br>&gt; Seems like a fantastic change, if indeed the move is made from<br>&gt; UnsafePointer to UnsafeBufferPointer! That still doesn&#39;t cover the case<br>&gt; where you&#39;d be doing code-unit level transforms (i.e., for custom<br>&gt; encoding schemes in some formats, like the Unicode escapes in JSON), but<br>&gt; that can probably also be done at the String level after-the-fact.<br>&gt; <br>&gt; Awesome change, though! It&#39;d be a shame to have to wait until 3.0 for it<br>&gt; to land.<br>&gt; <br>&gt; -- <br>&gt; Zach Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Tue, Jan 12, 2016, at 02:57 PM, Max Moiseev wrote:<br>&gt;&gt; Hi Zach,<br>&gt;&gt; <br>&gt;&gt; We looked at the CString APIs as part of API Naming Guidelines<br>&gt;&gt; application effort.<br>&gt;&gt; You can see the results here:<br>&gt;&gt; https://github.com/apple/swift/commit/f4aaece75e97379db6ba0a1fdb1da42c231a1c3b<br>&gt;&gt; <br>&gt;&gt; The main idea is to turn static factories into initializers and make<br>&gt;&gt; init(cString:) do ‘most probably the right thing’, i.e. repair UTF8 code<br>&gt;&gt; units.<br>&gt;&gt; <br>&gt;&gt; Haven’t looked at your proposal in details, but I think that if we add a<br>&gt;&gt; new String.decodeCString that accepts an UnsafeBufferPointer instead of<br>&gt;&gt; an UnsafePointer (and does not have to call _swift_stdlib_strlen), that<br>&gt;&gt; would solve the problem. Unless I’m missing something.<br>&gt;&gt; <br>&gt;&gt; regards,<br>&gt;&gt; max<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt;&gt;&gt; implementation and converting the request to a proposal. The proposal<br>&gt;&gt;&gt; draft is located at:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code is located at:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is reproduced below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Expose code unit initializers on String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal:<br>&gt;&gt;&gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt;&gt;&gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt;&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt;&gt; important part of solving many problems, including object<br>&gt;&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt;&gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt;&gt;&gt; `String.Type.fromCString(_:)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See swift-evolution<br>&gt;&gt;&gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt;&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt;&gt; `String.Type.fromCString(_:)`<br>&gt;&gt;&gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt;&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt;&gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt;&gt;&gt; `UnicodeCodecType`s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt;&gt; wives&#39;<br>&gt;&gt;&gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt;&gt;&gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt;&gt;&gt; role of<br>&gt;&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt;&gt; sentinel,<br>&gt;&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt;&gt; payloads<br>&gt;&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt;&gt; the string itself from containing the null character.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt;&gt;&gt; public API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt;&gt;&gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt;&gt;&gt; encoding: Encoding.Type)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And, for consistency with<br>&gt;&gt;&gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt;&gt;&gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt;&gt;&gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt;&gt;&gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See [full<br>&gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt;&gt; non-cast<br>&gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt;&gt; misnomer.<br>&gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt;&gt; refinements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt;&gt; its<br>&gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change to the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A protocol-oriented API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt;&gt; really<br>&gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt;&gt; require<br>&gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Do nothing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt;&gt; constructor is<br>&gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt;&gt; implementations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Make the `NSString` [bridge<br>&gt;&gt;&gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt;&gt;&gt; Maybe it&#39;s<br>&gt;&gt;&gt; a bug.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Make `String.append(_:)`<br>&gt;&gt;&gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt;&gt;&gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt;&gt;&gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt;&gt;&gt; noted that<br>&gt;&gt;&gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ----<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt;&gt;&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt;&gt;&gt; important part of solving many problems, including object<br>&gt;&gt;&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt;&gt;&gt; cryptography.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt;&gt;&gt;&gt; benchmarking<br>&gt;&gt;&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt;&gt;&gt; String.Type.fromCString(_:) [0]<br>&gt;&gt;&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt;&gt;&gt; skeptical<br>&gt;&gt;&gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt;&gt;&gt; wives&#39;<br>&gt;&gt;&gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt;&gt;&gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt;&gt;&gt; sentinel,<br>&gt;&gt;&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt;&gt;&gt; payloads<br>&gt;&gt;&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt;&gt;&gt; the string<br>&gt;&gt;&gt;&gt; itself from containing the null character.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt;&gt;&gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt;&gt;&gt;&gt; If that<br>&gt;&gt;&gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt;&gt;&gt;&gt; would be<br>&gt;&gt;&gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt;&gt;&gt;&gt; believe<br>&gt;&gt;&gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt;&gt;&gt;&gt; ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt;&gt;&gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt;&gt;&gt;&gt; have<br>&gt;&gt;&gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt;&gt;&gt;&gt; hitting<br>&gt;&gt;&gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt;&gt;&gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt;&gt;&gt;&gt; creating<br>&gt;&gt;&gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt;&gt;&gt;&gt; whether<br>&gt;&gt;&gt;&gt; this can be turned into a proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [0]:<br>&gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt;&gt;&gt;&gt; [1]:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt;&gt;&gt;&gt; [2]:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt;&gt;&gt;&gt; [3]:<br>&gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt;&gt;&gt;&gt; [4]:<br>&gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 13, 2016 at 04:00:00am</p></header><div class="content"><p>Max -<br></p><p>Great! Looking through it again, big +1 in favor of a<br>`repairIllFormedSequences: true` being the normal path.<br></p><p>I&#39;m trying now to suss out the full gamut of methods that are needed, so<br>I can adapt the proposal + stdlib while backporting the changes from<br>3.0.<br></p><p>I&#39;m in favor of two inits + decodeCString, with the latter sort of<br>becoming a &quot;primitive&quot;. Just figuring out the best permutations of<br>those…<br></p><p>I might&#39;ve mis-parsed the meaning of &quot;&#39;deprecation&#39; magic&quot;. What&#39;s the<br>best path forward in the near-term? Would `decodeCString` be the only<br>one that becomes generic? Or, phrased differently, should there still be<br>`UnsafePointer&lt;CChar&gt;`+`strlen` versions?<br></p><p>-- <br>Zach Waldowski<br>zach at waldowski.me<br></p><p>On Tue, Jan 12, 2016, at 07:54 PM, Max Moiseev wrote:<br>&gt; Zach, Charles. I’ll try to reply to both of you in one shot.<br>&gt; <br>&gt; As @gribozavr pointed out in a private conversation,<br>&gt; `UnsafeBufferPointer` conforms to CollectionType, so we can generalize<br>&gt; String.decodeCString to accept a CollectionType and constrain it<br>&gt; precisely as you, Zach, did in your proposal.<br>&gt; (I remember there were some troubles with the fact that CChar is Int8<br>&gt; (signed) and UTF8.CodeUnit is UInt8, but that might not affect this new<br>&gt; method).<br>&gt; <br>&gt; I don’t quite understand what you mean by `custom code-unit level<br>&gt; transforms’, but maybe having a CollectionType can address that.<br>&gt; <br>&gt; As for the proposal. This does not have to wait until Swift 3. The change<br>&gt; I pointed at was a side effect of revisiting all the APIs in stdlib. So<br>&gt; if you guys feel strongly about this change (and I think you do,<br>&gt; otherwise you wouldn’t go as far as writing a proposal document), you can<br>&gt; take what’s in the swift-3-api-guidelines branch, implement the new<br>&gt; method we’ve discussed, add some ‘deprecation’ magic to make it<br>&gt; compatible with Swift 2.1 and run it through the evolution process.<br>&gt; <br>&gt; max<br>&gt; <br>&gt; <br>&gt; &gt; On Jan 12, 2016, at 12:22 PM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Max,<br>&gt; &gt; <br>&gt; &gt; Seems like a fantastic change, if indeed the move is made from<br>&gt; &gt; UnsafePointer to UnsafeBufferPointer! That still doesn&#39;t cover the case<br>&gt; &gt; where you&#39;d be doing code-unit level transforms (i.e., for custom<br>&gt; &gt; encoding schemes in some formats, like the Unicode escapes in JSON), but<br>&gt; &gt; that can probably also be done at the String level after-the-fact.<br>&gt; &gt; <br>&gt; &gt; Awesome change, though! It&#39;d be a shame to have to wait until 3.0 for it<br>&gt; &gt; to land.<br>&gt; &gt; <br>&gt; &gt; -- <br>&gt; &gt; Zach Waldowski<br>&gt; &gt; zach at waldowski.me<br>&gt; &gt; <br>&gt; &gt; On Tue, Jan 12, 2016, at 02:57 PM, Max Moiseev wrote:<br>&gt; &gt;&gt; Hi Zach,<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; We looked at the CString APIs as part of API Naming Guidelines<br>&gt; &gt;&gt; application effort.<br>&gt; &gt;&gt; You can see the results here:<br>&gt; &gt;&gt; https://github.com/apple/swift/commit/f4aaece75e97379db6ba0a1fdb1da42c231a1c3b<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The main idea is to turn static factories into initializers and make<br>&gt; &gt;&gt; init(cString:) do ‘most probably the right thing’, i.e. repair UTF8 code<br>&gt; &gt;&gt; units.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Haven’t looked at your proposal in details, but I think that if we add a<br>&gt; &gt;&gt; new String.decodeCString that accepts an UnsafeBufferPointer instead of<br>&gt; &gt;&gt; an UnsafePointer (and does not have to call _swift_stdlib_strlen), that<br>&gt; &gt;&gt; would solve the problem. Unless I’m missing something.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; regards,<br>&gt; &gt;&gt; max<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt; &gt;&gt;&gt; implementation and converting the request to a proposal. The proposal<br>&gt; &gt;&gt;&gt; draft is located at:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;   https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The code is located at:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;   https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The proposal is reproduced below:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; # Expose code unit initializers on String<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; * Proposal:<br>&gt; &gt;&gt;&gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt; &gt;&gt;&gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt; &gt;&gt;&gt; * Status: **Awaiting review**<br>&gt; &gt;&gt;&gt; * Review manager: TBD<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ## Introduction<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt;&gt;&gt; important part of solving many problems, including object<br>&gt; &gt;&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; &gt;&gt;&gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt; &gt;&gt;&gt; `String.Type.fromCString(_:)`.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; See swift-evolution<br>&gt; &gt;&gt;&gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ## Motivation<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt; &gt;&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt;&gt;&gt; `String.Type.fromCString(_:)`<br>&gt; &gt;&gt;&gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt; &gt;&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt;&gt;&gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt; &gt;&gt;&gt; `UnicodeCodecType`s.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt;&gt;&gt; wives&#39;<br>&gt; &gt;&gt;&gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt; &gt;&gt;&gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt; &gt;&gt;&gt; role of<br>&gt; &gt;&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt;&gt;&gt; sentinel,<br>&gt; &gt;&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt;&gt;&gt; the<br>&gt; &gt;&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt;&gt;&gt; payloads<br>&gt; &gt;&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt;&gt;&gt; the string itself from containing the null character.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; # Proposed solution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt; &gt;&gt;&gt; public API:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ```swift<br>&gt; &gt;&gt;&gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt; &gt;&gt;&gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt; &gt;&gt;&gt; encoding: Encoding.Type)<br>&gt; &gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; And, for consistency with<br>&gt; &gt;&gt;&gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt; &gt;&gt;&gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ```swift<br>&gt; &gt;&gt;&gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt; &gt;&gt;&gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt; &gt;&gt;&gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ## Detailed design<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; See [full<br>&gt; &gt;&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt; &gt;&gt;&gt; non-cast<br>&gt; &gt;&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt; &gt;&gt;&gt; misnomer.<br>&gt; &gt;&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt; &gt;&gt;&gt; refinements.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt; &gt;&gt;&gt; a<br>&gt; &gt;&gt;&gt; factory function due to its multiple return values.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt; &gt;&gt;&gt; for<br>&gt; &gt;&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt; &gt;&gt;&gt; for<br>&gt; &gt;&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt; &gt;&gt;&gt; the<br>&gt; &gt;&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt; &gt;&gt;&gt; its<br>&gt; &gt;&gt;&gt; use could be elided throughout the stdlib.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ## Impact on existing code<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; This is an additive change to the API.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ## Alternatives considered<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; * A protocol-oriented API.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt; &gt;&gt;&gt; really<br>&gt; &gt;&gt;&gt; clear this method would be related to string processing, and would<br>&gt; &gt;&gt;&gt; require<br>&gt; &gt;&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt; &gt;&gt;&gt; UnsignedIntegerType`), but<br>&gt; &gt;&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; * Do nothing.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt; &gt;&gt;&gt; constructor is<br>&gt; &gt;&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt; &gt;&gt;&gt; implementations.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; * Make the `NSString` [bridge<br>&gt; &gt;&gt;&gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt; &gt;&gt;&gt; Maybe it&#39;s<br>&gt; &gt;&gt;&gt; a bug.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; * Make `String.append(_:)`<br>&gt; &gt;&gt;&gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt; &gt;&gt;&gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt; &gt;&gt;&gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt; &gt;&gt;&gt; noted that<br>&gt; &gt;&gt;&gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; ----<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt; Zachary Waldowski<br>&gt; &gt;&gt;&gt; zach at waldowski.me<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt; &gt;&gt;&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt; &gt;&gt;&gt;&gt; important part of solving many problems, including object<br>&gt; &gt;&gt;&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt; &gt;&gt;&gt;&gt; cryptography.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt; &gt;&gt;&gt;&gt; benchmarking<br>&gt; &gt;&gt;&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt; &gt;&gt;&gt;&gt; String.Type.fromCString(_:) [0]<br>&gt; &gt;&gt;&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt; &gt;&gt;&gt;&gt; skeptical<br>&gt; &gt;&gt;&gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt; &gt;&gt;&gt;&gt; wives&#39;<br>&gt; &gt;&gt;&gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt; &gt;&gt;&gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt; &gt;&gt;&gt;&gt; of<br>&gt; &gt;&gt;&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt; &gt;&gt;&gt;&gt; sentinel,<br>&gt; &gt;&gt;&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt; &gt;&gt;&gt;&gt; the<br>&gt; &gt;&gt;&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt; &gt;&gt;&gt;&gt; payloads<br>&gt; &gt;&gt;&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt; &gt;&gt;&gt;&gt; the string<br>&gt; &gt;&gt;&gt;&gt; itself from containing the null character.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt; &gt;&gt;&gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt; &gt;&gt;&gt;&gt; If that<br>&gt; &gt;&gt;&gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt; &gt;&gt;&gt;&gt; would be<br>&gt; &gt;&gt;&gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt; &gt;&gt;&gt;&gt; sequences.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt; &gt;&gt;&gt;&gt; believe<br>&gt; &gt;&gt;&gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt; &gt;&gt;&gt;&gt; ;-)<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt; &gt;&gt;&gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt; &gt;&gt;&gt;&gt; have<br>&gt; &gt;&gt;&gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt; &gt;&gt;&gt;&gt; hitting<br>&gt; &gt;&gt;&gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt; &gt;&gt;&gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt; &gt;&gt;&gt;&gt; creating<br>&gt; &gt;&gt;&gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt; &gt;&gt;&gt;&gt; with<br>&gt; &gt;&gt;&gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt; &gt;&gt;&gt;&gt; whether<br>&gt; &gt;&gt;&gt;&gt; this can be turned into a proposal.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; [0]:<br>&gt; &gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt; &gt;&gt;&gt;&gt; [1]:<br>&gt; &gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt; &gt;&gt;&gt;&gt; [2]:<br>&gt; &gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt; &gt;&gt;&gt;&gt; [3]:<br>&gt; &gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt; &gt;&gt;&gt;&gt; [4]:<br>&gt; &gt;&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt; Zachary Waldowski<br>&gt; &gt;&gt;&gt;&gt; zach at waldowski.me<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 1:14 AM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; I might&#39;ve mis-parsed the meaning of &quot;&#39;deprecation&#39; magic&quot;. What&#39;s the<br>&gt; best path forward in the near-term? Would `decodeCString` be the only<br>&gt; one that becomes generic? Or, phrased differently, should there still be<br>&gt; `UnsafePointer&lt;CChar&gt;`+`strlen` versions?<br></p><p>Sorry for not being clear. This is a breaking API change, and I think it would be nice of us to keep existing API in place marking it as deprecated for Swift 2.2 and later remove it in Swift 3. Here is an example &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Index.swift#L76&gt; of what I meant by ‘deprecation magic’.<br></p><p><br>max<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/27b742b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Oh, alright!<br></p><p>So the complete API set would be, as I see it right now:<br>* `decodeCString(_:encoding:repairingInvalidCodeUnits:)`, generic over<br>both collection and codec for maximum flexibility<br>* `init(cString:)`, generic over collection<br>* `init?(validatingUTF8:)`, generic over collection<br></p><p>2.2 (by this proposal) would also have `init(cString:)` and<br>`init?(validatingUTF8:)` that take `UnsafePointer&lt;CChar&gt;` for<br>compatibility.<br></p><p>Does that make sense, or should the new inits take buffer pointers?<br></p><p>----<br>Zach Waldowski<br>zach at waldowski.me<br></p><p>On Wed, Jan 13, 2016, at 12:32 PM, Max Moiseev wrote:<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 1:14 AM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I might&#39;ve mis-parsed the meaning of &quot;&#39;deprecation&#39; magic&quot;. What&#39;s the<br>&gt;&gt; best path forward in the near-term? Would `decodeCString` be the only<br>&gt;&gt; one that becomes generic? Or, phrased differently, should there still be<br>&gt;&gt; `UnsafePointer&lt;CChar&gt;`+`strlen` versions?<br>&gt; <br>&gt; Sorry for not being clear. This is a breaking API change, and I think it would be nice of us to keep existing API in place marking it as deprecated for Swift 2.2 and later remove it in Swift 3. Here is an example[https://github.com/apple/swift/blob/master/stdlib/public/core/Index.swift#L76] of what I meant by ‘deprecation magic’.<br>&gt; <br>&gt; <br>&gt; max<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>The way I see it:<br>Since we are designing a new API here, I don’t see why it should not be similar in both 2.2 and 3.<br>I’m thinking of 2 different versions of decodeCString though: one accepting a CollectionType and another one accepting an UnsafePointer and calling strlen, since there are still cases, where the length of a cstring is unknown and it is a null-terminated one.<br>All the existing API’s will remain in place for Swift 2.2 but should be annotated with a deprecation attribute.<br></p><p>&gt; On Jan 13, 2016, at 9:41 AM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; Oh, alright!<br>&gt; <br>&gt; So the complete API set would be, as I see it right now:<br>&gt; * `decodeCString(_:encoding:repairingInvalidCodeUnits:)`, generic over<br>&gt; both collection and codec for maximum flexibility<br>&gt; * `init(cString:)`, generic over collection<br>&gt; * `init?(validatingUTF8:)`, generic over collection<br>&gt; <br>&gt; 2.2 (by this proposal) would also have `init(cString:)` and<br>&gt; `init?(validatingUTF8:)` that take `UnsafePointer&lt;CChar&gt;` for<br>&gt; compatibility.<br>&gt; <br>&gt; Does that make sense, or should the new inits take buffer pointers?<br>&gt; <br>&gt; ----<br>&gt; Zach Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Wed, Jan 13, 2016, at 12:32 PM, Max Moiseev wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 1:14 AM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I might&#39;ve mis-parsed the meaning of &quot;&#39;deprecation&#39; magic&quot;. What&#39;s the<br>&gt;&gt;&gt; best path forward in the near-term? Would `decodeCString` be the only<br>&gt;&gt;&gt; one that becomes generic? Or, phrased differently, should there still be<br>&gt;&gt;&gt; `UnsafePointer&lt;CChar&gt;`+`strlen` versions?<br>&gt;&gt; <br>&gt;&gt; Sorry for not being clear. This is a breaking API change, and I think it would be nice of us to keep existing API in place marking it as deprecated for Swift 2.2 and later remove it in Swift 3. Here is an example[https://github.com/apple/swift/blob/master/stdlib/public/core/Index.swift#L76] of what I meant by ‘deprecation magic’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; max<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Draft proposal] Faster/lower-level external String initialization</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 11:57 AM, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Zach,<br>&gt; <br>&gt; We looked at the CString APIs as part of API Naming Guidelines application effort.<br>&gt; You can see the results here: https://github.com/apple/swift/commit/f4aaece75e97379db6ba0a1fdb1da42c231a1c3b<br>&gt; <br>&gt; The main idea is to turn static factories into initializers and make init(cString:) do ‘most probably the right thing’, i.e. repair UTF8 code units.<br>&gt; <br>&gt; Haven’t looked at your proposal in details, but I think that if we add a new String.decodeCString that accepts an UnsafeBufferPointer instead of an UnsafePointer (and does not have to call _swift_stdlib_strlen), that would solve the problem. Unless I’m missing something.<br></p><p>That would solve my particular problems anyway. Will a proposal still be required for this to happen?<br></p><p>-CK<br></p><p>&gt; <br>&gt; regards,<br>&gt; max<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 1:56 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Given the initial positive response, I&#39;ve taken a crack both at<br>&gt;&gt; implementation and converting the request to a proposal. The proposal<br>&gt;&gt; draft is located at:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/zwaldowski/swift-evolution/blob/string-from-code-units/proposals/0000-string-from-code-units.md<br>&gt;&gt; <br>&gt;&gt; The code is located at:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt;&gt; <br>&gt;&gt; The proposal is reproduced below:<br>&gt;&gt; <br>&gt;&gt; # Expose code unit initializers on String<br>&gt;&gt; <br>&gt;&gt; * Proposal:<br>&gt;&gt; [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-string-from-code-units.md)<br>&gt;&gt; * Author: [Zachary Waldowski](https://github.com/zwaldowski)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt; important part of solving many problems, including object<br>&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt; cryptography. Swift has such utilities, currently only exposed through<br>&gt;&gt; `String.Type.fromCString(_:)`.<br>&gt;&gt; <br>&gt;&gt; See swift-evolution<br>&gt;&gt; [thread](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005951.html).<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; In developing a parser, a coworker did the yeoman&#39;s work of benchmarking<br>&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt; `String.Type.fromCString(_:)`<br>&gt;&gt; ([use](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift))<br>&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt; skeptical that a better way couldn&#39;t be wrought from Swift&#39;s<br>&gt;&gt; `UnicodeCodecType`s.<br>&gt;&gt; <br>&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt; wives&#39;<br>&gt;&gt; tale. `fromCString` is essentially the only public-facing user of<br>&gt;&gt; `String.Type._fromCodeUnitSequence(_:input:)`, which serves the exact<br>&gt;&gt; role of<br>&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt; <br>&gt;&gt; Of course, `fromCString` isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt; sentinel,<br>&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt; the<br>&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt; payloads<br>&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt; the string itself from containing the null character.<br>&gt;&gt; <br>&gt;&gt; # Proposed solution<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to expose `String.Type._fromCodeUnitSequence(_:input:)` as<br>&gt;&gt; public API:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; init?&lt;Input: CollectionType, Encoding: UnicodeCodecType where<br>&gt;&gt; Encoding.CodeUnit == Input.Generator.Element&gt;(codeUnits input: Input,<br>&gt;&gt; encoding: Encoding.Type)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; And, for consistency with<br>&gt;&gt; `String.Type.fromCStringRepairingIllFormedUTF8(_:)`,<br>&gt;&gt; exposing `String.Type._fromCodeUnitSequenceWithRepair(_:input:)`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; static func fromCodeUnitsWithRepair&lt;Input: CollectionType, Encoding:<br>&gt;&gt; UnicodeCodecType where Encoding.CodeUnit ==<br>&gt;&gt; Input.Generator.Element&gt;(input: Input, encoding: Encoding.Type)```<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; See [full<br>&gt;&gt; implementation](https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units).<br>&gt;&gt; <br>&gt;&gt; This is a fairly straightforward renaming of the internal APIs.<br>&gt;&gt; <br>&gt;&gt; The initializer, its labels, and their order were chosen to match other<br>&gt;&gt; non-cast<br>&gt;&gt; initializers in the stdlib. &quot;Sequence&quot; was removed, as it was a<br>&gt;&gt; misnomer.<br>&gt;&gt; &quot;input&quot; was kept as a generic name in order to allow for future<br>&gt;&gt; refinements.<br>&gt;&gt; <br>&gt;&gt; The static initializer made the same changes, but was otherwise kept as<br>&gt;&gt; a<br>&gt;&gt; factory function due to its multiple return values.<br>&gt;&gt; <br>&gt;&gt; `String.Type._fromWellFormedCodeUnitSequence(_:input:)` was kept as-is<br>&gt;&gt; for<br>&gt;&gt; internal use. I assume it wouldn&#39;t be good to expose publicly because,<br>&gt;&gt; for<br>&gt;&gt; lack of a better phrase, we only &quot;trust&quot; the stdlib to accurately know<br>&gt;&gt; the<br>&gt;&gt; wellformedness of their code units. Since it is a simple call through,<br>&gt;&gt; its<br>&gt;&gt; use could be elided throughout the stdlib.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is an additive change to the API.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; * A protocol-oriented API.<br>&gt;&gt; <br>&gt;&gt; Some kind of `func decode&lt;Encoding&gt;(_:)` on `SequenceType`. It&#39;s not<br>&gt;&gt; really<br>&gt;&gt; clear this method would be related to string processing, and would<br>&gt;&gt; require<br>&gt;&gt; some kind of bounding (like `where Generator.Element:<br>&gt;&gt; UnsignedIntegerType`), but<br>&gt;&gt; that would be introducing a type bound that doesn&#39;t exist on<br>&gt;&gt; <br>&gt;&gt; * Do nothing.<br>&gt;&gt; <br>&gt;&gt; This seems suboptimal. For many use cases, `String` lacking this<br>&gt;&gt; constructor is<br>&gt;&gt; a limiting factor on performance for many kinds of pure-Swift<br>&gt;&gt; implementations.<br>&gt;&gt; <br>&gt;&gt; * Make the `NSString` [bridge<br>&gt;&gt; faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift).<br>&gt;&gt; <br>&gt;&gt; After reading the bridge code, I don&#39;t really know why it&#39;s slower.<br>&gt;&gt; Maybe it&#39;s<br>&gt;&gt; a bug.<br>&gt;&gt; <br>&gt;&gt; * Make `String.append(_:)`<br>&gt;&gt; [faster](https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t completely understand the growth strategy of `_StringCore`, but<br>&gt;&gt; it doesn&#39;t seem to exhibit the documented amortized `O(1)`, even when<br>&gt;&gt; `reserveCapacity(_:)` is used. In the pre-proposal discussion, a user<br>&gt;&gt; noted that<br>&gt;&gt; it seems like `reserveCapacity` acts like a no-op.<br>&gt;&gt; <br>&gt;&gt; ----<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Zachary Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 8, 2016, at 03:21 PM, Zach Waldowski wrote:<br>&gt;&gt;&gt; Going back and forth from Strings to their byte representations is an<br>&gt;&gt;&gt; important part of solving many problems, including object<br>&gt;&gt;&gt; serialization, binary file formats, wire/network interfaces, and<br>&gt;&gt;&gt; cryptography.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In developing such a parser, a coworker did the yeoman&#39;s work of<br>&gt;&gt;&gt; benchmarking<br>&gt;&gt;&gt; Swift&#39;s Unicode types. He swore up and down that<br>&gt;&gt;&gt; String.Type.fromCString(_:) [0]<br>&gt;&gt;&gt; was the fastest way he found. I, stubborn and noobish as I am, was<br>&gt;&gt;&gt; skeptical<br>&gt;&gt;&gt; that a better way couldn&#39;t be wrought from Swift&#39;s UnicodeCodecTypes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After reading through stdlib source and doing my own testing, this is no<br>&gt;&gt;&gt; wives&#39;<br>&gt;&gt;&gt; tale. fromCString [1] is essentially the only public user of<br>&gt;&gt;&gt; String.Type._fromCodeUnitSequence(_:input:), which serves the exact role<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; both efficient and safe initialization-by-buffer-copy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, fromCString isn&#39;t a silver bullet; it has to have a null<br>&gt;&gt;&gt; sentinel,<br>&gt;&gt;&gt; requiring a copy of the origin buffer if one needs to be added (as is<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; case with formats that specify the length up front, or unstructured<br>&gt;&gt;&gt; payloads<br>&gt;&gt;&gt; that use unescaped double quotes as the terminator). It also prevents<br>&gt;&gt;&gt; the string<br>&gt;&gt;&gt; itself from containing the null character.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to see _fromCodeUnitSequence [2] become public API as (just<br>&gt;&gt;&gt; spittballing here) String.init?&lt;Collection, Codec&gt;(codeUnits:encoding:).<br>&gt;&gt;&gt; If that<br>&gt;&gt;&gt; can&#39;t happen, an alternative to fromCString that doesn&#39;t use strlen<br>&gt;&gt;&gt; would be<br>&gt;&gt;&gt; nice, and we can just eat the performance hit on other code unit<br>&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t really think of a reason why it&#39;s not exposed yet, so I&#39;m led to<br>&gt;&gt;&gt; believe<br>&gt;&gt;&gt; I&#39;m just missing something major, and not that a reason doesn&#39;t exist.<br>&gt;&gt;&gt; ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s also discussion to be had of if API is needed. Try as I might, I<br>&gt;&gt;&gt; can&#39;t seem to get the reserveCapacity/append(UnicodeScalar) workflow to<br>&gt;&gt;&gt; have<br>&gt;&gt;&gt; anything close to the same speed. [3] Profiling indicates that I keep<br>&gt;&gt;&gt; hitting<br>&gt;&gt;&gt; _StringBuffer.grow. I don&#39;t know if that means the buffer isn&#39;t uniquely<br>&gt;&gt;&gt; referenced, or it&#39;s a bug, or what, but it&#39;s consistently slower than<br>&gt;&gt;&gt; creating<br>&gt;&gt;&gt; an Array of the bytes and performing fromCString on it. Similar story<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; crossing the NSString bridge, which is even stranger. [4]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, I wanted to stir up discussion, see if I&#39;m way off base and/or<br>&gt;&gt;&gt; whether<br>&gt;&gt;&gt; this can be turned into a proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [0]:<br>&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-fromcstring-swift<br>&gt;&gt;&gt; [1]:<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CString.swift#L18-L31<br>&gt;&gt;&gt; [2]:<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L134-L150<br>&gt;&gt;&gt; [3]:<br>&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-unicodescalar-swift<br>&gt;&gt;&gt; [4]:<br>&gt;&gt;&gt; https://gist.github.com/zwaldowski/5f1a1011ea368e1c833e#file-nsstring-swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
