<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/708abe8093c1b67c209e6713070d0fd0?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Lane Schwartz</string> &lt;dowobeha at gmail.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I&#39;m writing some code where I&#39;d like multiple threads to be writing to a<br>common dictionary object.<br></p><p>Is there a recommended mechanism for doing this?<br></p><p>Thanks,<br>Lane<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151210/d5bd0877/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/965c169cdb452086f1c1d81a4127702f?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Pelaia II, Tom</string> &lt;pelaiata at ornl.gov&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I have one that I created for Swift on OS X which uses libdispatch to protect access to the underlying data:<br></p><p>/* dictionary that allows thread safe concurrent access */<br>final class ConcurrentDictionary&lt;KeyType:Hashable,ValueType&gt; : NSObject, SequenceType, DictionaryLiteralConvertible {<br>/* internal dictionary */<br>private var internalDictionary : [KeyType:ValueType]<br></p><p>/* queue modfications using a barrier and allow concurrent read operations */<br>private let queue = dispatch_queue_create( &quot;dictionary access&quot;, DISPATCH_QUEUE_CONCURRENT )<br></p><p><br>/* count of key-value pairs in this dicitionary */<br>var count : Int {<br>var count = 0<br>dispatch_sync(self.queue) { () -&gt; Void in<br>count = self.internalDictionary.count<br>}<br>return count<br>}<br></p><p><br>// safely get or set a copy of the internal dictionary value<br>var dictionary : [KeyType:ValueType] {<br>get {<br>var dictionaryCopy : [KeyType:ValueType]?<br>dispatch_sync(self.queue) { () -&gt; Void in<br>dictionaryCopy = self.dictionary<br>}<br>return dictionaryCopy!<br>}<br></p><p>set {<br>let dictionaryCopy = newValue // create a local copy on the current thread<br>dispatch_async(self.queue) { () -&gt; Void in<br>self.internalDictionary = dictionaryCopy<br>}<br>}<br>}<br></p><p><br>/* initialize an empty dictionary */<br>override convenience init() {<br>self.init( dictionary: [KeyType:ValueType]() )<br>}<br></p><p><br>/* allow a concurrent dictionary to be initialized using a dictionary literal of form: [key1:value1, key2:value2, ...] */<br>convenience required init(dictionaryLiteral elements: (KeyType, ValueType)...) {<br>var dictionary = Dictionary&lt;KeyType,ValueType&gt;()<br></p><p>for (key,value) in elements {<br>dictionary[key] = value<br>}<br></p><p>self.init(dictionary: dictionary)<br>}<br></p><p><br>/* initialize a concurrent dictionary from a copy of a standard dictionary */<br>init( dictionary: [KeyType:ValueType] ) {<br>self.internalDictionary = dictionary<br>}<br></p><p><br>/* provide subscript accessors */<br>subscript(key: KeyType) -&gt; ValueType? {<br>get {<br>var value : ValueType?<br>dispatch_sync(self.queue) { () -&gt; Void in<br>value = self.internalDictionary[key]<br>}<br>return value<br>}<br></p><p>set {<br>setValue(newValue, forKey: key)<br>}<br>}<br></p><p><br>/* assign the specified value to the specified key */<br>func setValue(value: ValueType?, forKey key: KeyType) {<br>// need to synchronize writes for consistent modifications<br>dispatch_barrier_async(self.queue) { () -&gt; Void in<br>self.internalDictionary[key] = value<br>}<br>}<br></p><p><br>/* remove the value associated with the specified key and return its value if any */<br>func removeValueForKey(key: KeyType) -&gt; ValueType? {<br>var oldValue : ValueType? = nil<br>// need to synchronize removal for consistent modifications<br>dispatch_barrier_sync(self.queue) { () -&gt; Void in<br>oldValue = self.internalDictionary.removeValueForKey(key)<br>}<br>return oldValue<br>}<br></p><p><br>/* Generator of key-value pairs suitable for for-in loops */<br>func generate() -&gt; Dictionary&lt;KeyType,ValueType&gt;.Generator {<br>var generator : Dictionary&lt;KeyType,ValueType&gt;.Generator!<br>dispatch_sync(self.queue) { () -&gt; Void in<br>generator = self.internalDictionary.generate()<br>}<br>return generator<br>}<br>}<br></p><p>_____________________________________________________________________________________<br>Thomas Pelaia II, Ph.D.  | Applications Leader, Accelerator Physics, Research Accelerator Division<br>Spallation Neutron Source  |  Oak Ridge National Lab, Building 8600, MS-6462, Oak Ridge, TN 37831<br>phone: (865) 414-7960  | FaceTime: t6p at ornl.gov&lt;mailto:t6p at ornl.gov&gt; |  fax: (865) 574-6617  |  homepage: http://www.ornl.gov/~t6p<br></p><p>On Dec 10, 2015, at 12:18 PM, swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br></p><p>Hi,<br></p><p>I&#39;m writing some code where I&#39;d like multiple threads to be writing to a common dictionary object.<br></p><p>Is there a recommended mechanism for doing this?<br></p><p>Thanks,<br>Lane<br></p><p> _______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151210/c0516ce1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 9:24 AM, Pelaia II, Tom via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; /* provide subscript accessors */<br>&gt; subscript(key: KeyType) -&gt; ValueType? {<br>&gt; get {<br>&gt; var value : ValueType?<br>&gt; dispatch_sync(self.queue) { () -&gt; Void in<br>&gt; value = self.internalDictionary[key]<br>&gt; }<br>&gt; return value<br>&gt; }<br>&gt;<br>&gt; set {<br>&gt; setValue(newValue, forKey: key)<br>&gt; }<br>&gt; }<br>&gt;<br></p><p>Please don&#39;t do this, unless you have a very special use case.  This is<br>inherently racy on high level, even though it is safe in the language.<br>Consider two threads operating on a shared ConcurrentDictionary&lt;Int, Int&gt;:<br></p><p>d[42] += 1<br></p><p>Here&#39;s what the code compiles into:<br></p><p>var tmp = d.subscript_get(42)<br>tmp += 1<br>d.subscript_set(42, tmp)<br></p><p>The &#39;get&#39; and &#39;set&#39; operations are atomic, but the whole sequence isn&#39;t.<br>The results of operations that other threads execute during &quot;tmp += 1&quot; will<br>be overwritten by the following &#39;subscript_set&#39;.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151210/739526a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/965c169cdb452086f1c1d81a4127702f?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Pelaia II, Tom</string> &lt;pelaiata at ornl.gov&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>But isn’t that really a problem with that use case rather than the concurrent dictionary itself? There are a lot of bad things one can do with almost any code. For example, one can naively use the standard library dictionary in subtle, unsafe ways with concurrency and get into trouble.<br></p><p>Of course “+-&quot; would be a bad idea to do in this context. Indeed, I am using this concurrent dictionary in a special use case, and I would never do the “+=“ operation as you suggest. It’s not even relevant in my code. I am just using this concurrent dictionary to keep track of concurrent events being completed and posted from different threads. When the event completes it gets put into the dictionary with the value being the immutable result. Alternatively, I could have put the concurrency code outside of the dictionary, but in my case that made for awkward access and opened the possibility of accidentally referencing the dictionary directly in an unsafe way. The safest option for me was to create the concurrent dictionary and the subscript allowed the code to be easier to read and write.<br>_____________________________________________________________________________________<br>Thomas Pelaia II, Ph.D.  | Applications Leader, Accelerator Physics, Research Accelerator Division<br>Spallation Neutron Source  |  Oak Ridge National Lab, Building 8600, MS-6462, Oak Ridge, TN 37831<br>phone: (865) 414-7960  | FaceTime: t6p at ornl.gov&lt;mailto:t6p at ornl.gov&gt; |  fax: (865) 574-6617  |  homepage: http://www.ornl.gov/~t6p<br></p><p>On Dec 10, 2015, at 12:44 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br></p><p>On Thu, Dec 10, 2015 at 9:24 AM, Pelaia II, Tom via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>/* provide subscript accessors */<br>subscript(key: KeyType) -&gt; ValueType? {<br>get {<br>var value : ValueType?<br>dispatch_sync(self.queue) { () -&gt; Void in<br>value = self.internalDictionary[key]<br>}<br>return value<br>}<br></p><p>set {<br>setValue(newValue, forKey: key)<br>}<br>}<br></p><p>Please don&#39;t do this, unless you have a very special use case.  This is inherently racy on high level, even though it is safe in the language.  Consider two threads operating on a shared ConcurrentDictionary&lt;Int, Int&gt;:<br></p><p>d[42] += 1<br></p><p>Here&#39;s what the code compiles into:<br></p><p>var tmp = d.subscript_get(42)<br>tmp += 1<br>d.subscript_set(42, tmp)<br></p><p>The &#39;get&#39; and &#39;set&#39; operations are atomic, but the whole sequence isn&#39;t.  The results of operations that other threads execute during &quot;tmp += 1&quot; will be overwritten by the following &#39;subscript_set&#39;.<br></p><p>Dmitri<br></p><p>--<br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151210/6200723a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 10:06 AM, Pelaia II, Tom &lt;pelaiata at ornl.gov&gt; wrote:<br>&gt; But isn’t that really a problem with that use case rather than the<br>&gt; concurrent dictionary itself? There are a lot of bad things one can do with<br>&gt; almost any code. For example, one can naively use the standard library<br>&gt; dictionary in subtle, unsafe ways with concurrency and get into trouble.<br></p><p>The concurrency considerations and safety conditions for Dictionary<br>are the same as for Int, so I don&#39;t think there is anything subtle<br>here.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:06 AM, Pelaia II, Tom via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; But isn’t that really a problem with that use case rather than the concurrent dictionary itself?<br></p><p>It’s a problem with _most_ use cases of a concurrent dictionary, unfortunately. The values in such a dictionary can be read and written atomically, but that’s not sufficient for anything that wants to use multiple values in a coordinated way, or update a value, etc. etc.<br></p><p>&gt; It’s not even relevant in my code. I am just using this concurrent dictionary to keep track of concurrent events being completed and posted from different threads. When the event completes it gets put into the dictionary with the value being the immutable result.<br></p><p>That sounds like a case where a simple concurrent dictionary would be an appropriate data structure. So go ahead and write one for your own needs. All we’re saying is that a class like this isn’t commonly useful enough to go into a library.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 11:20 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; All we’re saying is that a class like this isn’t commonly useful enough to go into a library.<br></p><p>And too easy to misuse if provided.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>I would do something like:<br></p><p>    import Foundation<br></p><p>    class Task { // Must be a class to prevent Swift copy semantics<br>eliminating the result<br></p><p>        private static let queue = dispatch_get_global_queue(<br>DISPATCH_QUEUE_PRIORITY_HIGH, 0)<br></p><p>        private let group = dispatch_group_create()<br></p><p>        private var _result: String?<br></p><p>        init(name: String) {<br></p><p>            dispatch_group_async(group, Task.queue) {<br></p><p>                self._result = name // The asynchronous task!<br></p><p>            }<br></p><p>        }<br></p><p>        var result: String { // Provide safe access to result<br></p><p>            dispatch_group_wait(group, DISPATCH_TIME_FOREVER) // Block<br>until task finished<br></p><p>            return _result!<br></p><p>        }<br></p><p>    }<br></p><p><br>    var tasks = [String : Task]()<br></p><p>    let names = [&quot;One&quot;, &quot;Two&quot;]<br></p><p>    names.forEach {<br></p><p>        tasks[$0] = Task(name: $0)<br></p><p>    }<br></p><p>    tasks.map { (_, task) in // Prints [One, Two] in playground<br></p><p>        task.result<br></p><p>    }<br></p><p>On 11 December 2015 at 07:02, Dmitri Gribenko via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Dec 10, 2015 at 11:20 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; &gt; All we’re saying is that a class like this isn’t commonly useful enough<br>&gt; to go into a library.<br>&gt;<br>&gt; And too easy to misuse if provided.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p><p><br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151211/fa6e4ea3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:18 AM, Lane Schwartz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m writing some code where I&#39;d like multiple threads to be writing to a common dictionary object.<br>&gt; Is there a recommended mechanism for doing this?<br></p><p>Wrap mutexes* around dictionary accesses. If you have a lot more reads than writes, a read/write mutex will be more efficient.<br></p><p>Making a thread-safe dictionary class is usually not a good idea. (This is something Java learned in between JDK 1.0 and 1.2.) It adds unavoidable overhead to every single access, and doesn’t solve the higher-level synchronization problems of the code that’s using the dictionary. Instead, use synchronization primitives in your higher-level class at the appropriate points.<br></p><p>—Jens<br></p><p>* which I guess you’ll have to implement using C calls to pthreads, since the Swift concurrency library isn’t ready yet<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>+1.  I learned this the hard way, once upon a time.  For code that is primarily CPU bound (like dictionary reads/writes), opt for using your objects in a thread-safe way rather than creating thread-safe objects.  Either make sure the callers wrap each access around a mutex/semaphore lock, or (if you’re working in OSX/iOS) ensure that each access is dispatched onto the same serial Grand Central Dispatch queue.<br></p><p>Dan<br></p><p>&gt; On Dec 10, 2015, at 9:28 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:18 AM, Lane Schwartz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m writing some code where I&#39;d like multiple threads to be writing to a common dictionary object.<br>&gt;&gt; Is there a recommended mechanism for doing this?<br>&gt; <br>&gt; Wrap mutexes* around dictionary accesses. If you have a lot more reads than writes, a read/write mutex will be more efficient.<br>&gt; <br>&gt; Making a thread-safe dictionary class is usually not a good idea. (This is something Java learned in between JDK 1.0 and 1.2.) It adds unavoidable overhead to every single access, and doesn’t solve the higher-level synchronization problems of the code that’s using the dictionary. Instead, use synchronization primitives in your higher-level class at the appropriate points.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; * which I guess you’ll have to implement using C calls to pthreads, since the Swift concurrency library isn’t ready yet<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Recommendation for thread-safe dictionary</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; I&#39;m writing some code where I&#39;d like multiple threads to be writing to a common dictionary object.<br>&gt;&gt; Is there a recommended mechanism for doing this?<br>&gt; <br>&gt; Wrap mutexes* around dictionary accesses. If you have a lot more reads than writes, a read/write mutex will be more efficient.<br></p><p><br>Speaking of which, the CleanroomConcurrency project for Swift provides a ReadWriteCoordinator that provides similar functionality using a Grand Central Dispatch feature:<br></p><p>https://github.com/emaloney/CleanroomConcurrency/tree/master/Code#readwritecoordinator &lt;https://github.com/emaloney/CleanroomConcurrency/tree/master/Code#readwritecoordinator&gt;<br></p><p>The flip side of the threadsafe dictionary is the thread-local dictionary associated with each NSThread which can be used in a Swifty fashion with:<br></p><p>https://github.com/emaloney/CleanroomConcurrency/tree/master/Code#threadlocalvalue &lt;https://github.com/emaloney/CleanroomConcurrency/tree/master/Code#threadlocalvalue&gt;<br></p><p>Disclosure: This open-source code is provided courtesy of my employer, Gilt Groupe, and ships in our &quot;Gilt on TV&quot; app for the new Apple TV.<br></p><p><br></p><p><br>&gt; On Dec 10, 2015, at 12:28 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:18 AM, Lane Schwartz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m writing some code where I&#39;d like multiple threads to be writing to a common dictionary object.<br>&gt;&gt; Is there a recommended mechanism for doing this?<br>&gt; <br>&gt; Wrap mutexes* around dictionary accesses. If you have a lot more reads than writes, a read/write mutex will be more efficient.<br>&gt; <br>&gt; Making a thread-safe dictionary class is usually not a good idea. (This is something Java learned in between JDK 1.0 and 1.2.) It adds unavoidable overhead to every single access, and doesn’t solve the higher-level synchronization problems of the code that’s using the dictionary. Instead, use synchronization primitives in your higher-level class at the appropriate points.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; * which I guess you’ll have to implement using C calls to pthreads, since the Swift concurrency library isn’t ready yet<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151210/0ad415f3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
