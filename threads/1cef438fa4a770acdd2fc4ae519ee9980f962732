<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>On 2016-07-18 09:17:43 +0000, David Hart via swift-evolution said:<br></p><p>&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution <br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution <br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution <br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution <br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there a summary somewhere of the motivation for allowing methods <br>&gt; to be declared non-overridable within open classes?<br>&gt; [...]<br>&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The <br>&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that <br>&gt; every member in it is designed to be subclassed. Consider <br>&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some <br>&gt; methods in it (such as `loadView`) are intended to be overridden, but <br>&gt; others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt; <br>&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good <br>&gt; reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final? <br>&gt; <br>&gt; I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be <br>&gt; overridden internally, if one knows the precise internal workings of <br>&gt; UIViewController. That would require open, to allow overriding <br>&gt; internally but not externally.<br></p><p><br>I thought about this aspect a little more. I think it&#39;s fair to say <br>that we&#39;re breaking new ground for language design here. Classes <br>limiting inheritance to a certain set of subclasses are nothing new <br>(I&#39;ve written &amp; used classes doing this in C++, Java and C#), but no <br>language that I know of allows limiting overrides of a specific public <br>member in such a way. I think we need a convincing rationale for making <br>this esoteric middle ground between final and open members the new <br>default.<br></p><p>The UIKit example above isn&#39;t convincing at all. It is already quite <br>easy to allow package-internal subclasses to configure the behavior of <br>loadViewIfNeeded without such a novel language feature. E.g., the UIKit <br>team can simply make loadViewIfNeeded call into a non-final but <br>internal method:<br></p><p>public open class UIViewController {<br>	private var _view: UIView? = nil<br></p><p>	public final func loadViewIfNeeded() {<br>		internalLoadViewIfNeeded()<br>	}<br></p><p>	internal func internalLoadViewIfNeeded() { // overridable internally<br>		if let view = _view { return }<br>		loadView()<br>	}<br></p><p>	public open func loadView() {<br>		// Load it from a nib or whatevs<br>	}<br>}<br></p><p>I see no drawback to this pattern; it is quite clear and simple. <br>Therefore, in the interest of keeping the language free of needless <br>complexity, I suggest we change the proposal to remove the implicit <br>&quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; <br>or &quot;final&quot; class members.<br></p><p>For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels <br>in between. Member-level openness should be entirely independent of <br>visibility; so it should be possible to say &quot;internal open&quot; to mean an <br>internally overridable member that&#39;s not at all visible outside the <br>module -- the same as today&#39;s default.<br></p><p>(Note that (on platforms with an Objective-C runtime) &quot;dynamic&quot; <br>provides a third level of flexibility for class members; I argue that <br>it should imply &quot;open&quot;. So in order of increasing flexibility, we&#39;d <br>have &quot;final&quot;, &quot;open&quot; and &quot;dynamic&quot; members. This seems easy enough to <br>describe and understand.)<br></p><p>I also suggest that for now, we should make neither &quot;final&quot; nor &quot;open&quot; <br>nor &quot;dynamic&quot; the default for public members of open classes: we should <br>rather require class authors to explicity add one of these qualifiers <br>to all public member declarations. This way, we can defer the argument <br>for choosing a default to a later (additive) proposal, once we have <br>some experience with this setup. Non-public members can safely keep <br>defaulting to &quot;internal open&quot;, like they do today.<br></p><p>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 7:07 AM, Károly Lőrentey &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; On 2016-07-18 09:17:43 +0000, David Hart via swift-evolution said:<br>&gt;<br>&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a summary somewhere of the motivation for allowing methods to<br>&gt;&gt; be declared non-overridable within open classes?<br>&gt;&gt; [...]<br>&gt;&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The<br>&gt;&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that<br>&gt;&gt; every member in it is designed to be subclassed. Consider<br>&gt;&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some<br>&gt;&gt; methods in it (such as `loadView`) are intended to be overridden, but<br>&gt;&gt; others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt;&gt;<br>&gt;&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good<br>&gt;&gt; reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final?<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be<br>&gt;&gt; overridden internally, if one knows the precise internal workings of<br>&gt;&gt; UIViewController. That would require open, to allow overriding internally<br>&gt;&gt; but not externally.<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; I thought about this aspect a little more. I think it&#39;s fair to say that<br>&gt; we&#39;re breaking new ground for language design here. Classes limiting<br>&gt; inheritance to a certain set of subclasses are nothing new (I&#39;ve written &amp;<br>&gt; used classes doing this in C++, Java and C#), but no language that I know<br>&gt; of allows limiting overrides of a specific public member in such a way. I<br>&gt; think we need a convincing rationale for making this esoteric middle ground<br>&gt; between final and open members the new default.<br>&gt;<br>&gt; The UIKit example above isn&#39;t convincing at all. It is already quite easy<br>&gt; to allow package-internal subclasses to configure the behavior of<br>&gt; loadViewIfNeeded without such a novel language feature. E.g., the UIKit<br>&gt; team can simply make loadViewIfNeeded call into a non-final but internal<br>&gt; method:<br>&gt;<br>&gt; public open class UIViewController {<br>&gt;         private var _view: UIView? = nil<br>&gt;<br>&gt;         public final func loadViewIfNeeded() {<br>&gt;                 internalLoadViewIfNeeded()<br>&gt;         }<br>&gt;<br>&gt;         internal func internalLoadViewIfNeeded() { // overridable<br>&gt; internally<br>&gt;                 if let view = _view { return }<br>&gt;                 loadView()<br>&gt;         }<br>&gt;<br>&gt;         public open func loadView() {<br>&gt;                 // Load it from a nib or whatevs<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; I see no drawback to this pattern; it is quite clear and simple.<br>&gt; Therefore, in the interest of keeping the language free of needless<br>&gt; complexity, I suggest we change the proposal to remove the implicit<br>&gt; &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or<br>&gt; &quot;final&quot; class members.<br>&gt;<br></p><p>I&#39;m impressed by this analysis. You&#39;ve convinced me that the proposed<br>default for public members is rather esoteric; given this very clean<br>alternative way of achieving the same result, an esoteric default (though<br>formally consistent with Swift conventions) seems unduly burdensome.<br></p><p>For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels in<br>&gt; between. Member-level openness should be entirely independent of<br>&gt; visibility; so it should be possible to say &quot;internal open&quot; to mean an<br>&gt; internally overridable member that&#39;s not at all visible outside the module<br>&gt; -- the same as today&#39;s default.<br>&gt;<br>&gt; (Note that (on platforms with an Objective-C runtime) &quot;dynamic&quot; provides a<br>&gt; third level of flexibility for class members; I argue that it should imply<br>&gt; &quot;open&quot;. So in order of increasing flexibility, we&#39;d have &quot;final&quot;, &quot;open&quot;<br>&gt; and &quot;dynamic&quot; members. This seems easy enough to describe and understand.)<br>&gt;<br>&gt; I also suggest that for now, we should make neither &quot;final&quot; nor &quot;open&quot; nor<br>&gt; &quot;dynamic&quot; the default for public members of open classes: we should rather<br>&gt; require class authors to explicity add one of these qualifiers to all<br>&gt; public member declarations. This way, we can defer the argument for<br>&gt; choosing a default to a later (additive) proposal, once we have some<br>&gt; experience with this setup. Non-public members can safely keep defaulting<br>&gt; to &quot;internal open&quot;, like they do today.<br>&gt;<br>&gt; --<br>&gt; Károly<br>&gt; @lorentey<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/5ab9d920/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 18, 2016 at 01:00:00pm</p></header><div class="content"><p>I believe sealed by default applied to functions makes the behaviour<br>consistent with classes and allows for the same behaviour we wanted<br>with this proposal. It would allows us to create subclassable classes<br>in which we would be able to internally override a method but not<br>outside the library and selectively allow other methods to be<br>overriden. Final won&#39;t do it so if this is not the default behaviour,<br>it will be necessary to introduce the sealed keyword so we can achieve<br>this. It&#39;s inconsistent to have to explicitly open a class and<br>explicitly seal its methods and vice-versa. It was my assumption that<br>when we chose sealed by default with the proposal we were talking<br>about everything and not just classes (I at least was talking<br>everything).<br></p><p>Introducing &quot;dynamic&quot; or some other keyword to mark explicitly methods<br>that should be overriden is just the same &quot;open&quot; with sealed methods<br>by default would mean for public methods so it makes no difference to<br>me. Also having no default will not change that some library<br>developers will have everything sealed and selectively open. No<br>default shall also make developers prone to open to think more about<br>the keyword they&#39;ll choose to use, but I&#39;m not fond of no default.<br></p><p>As for the inheritance of openness, I firmly believe it shouldn&#39;t. If<br>a class inherited from an open class is open by default, there will be<br>no libraries making use of other libraries or we should also introduce<br>the sealed keyword in order to make the class (or method) sealed<br>again. This behaviour seems inconsistent to me too.<br></p><p>L<br></p><p><br>On 18 July 2016 at 09:07, Károly Lőrentey &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On 2016-07-18 09:17:43 +0000, David Hart via swift-evolution said:<br>&gt;<br>&gt;&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a summary somewhere of the motivation for allowing methods to<br>&gt;&gt; &gt;&gt; be declared non-overridable within open classes?<br>&gt;&gt; [...]<br>&gt;&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The<br>&gt;&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that<br>&gt;&gt; every member in it is designed to be subclassed. Consider<br>&gt;&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some<br>&gt;&gt; methods in it (such as `loadView`) are intended to be overridden, but others<br>&gt;&gt; (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt;&gt;<br>&gt;&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good<br>&gt;&gt; reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final?<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be<br>&gt;&gt; overridden internally, if one knows the precise internal workings of<br>&gt;&gt; UIViewController. That would require open, to allow overriding internally<br>&gt;&gt; but not externally.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I thought about this aspect a little more. I think it&#39;s fair to say that<br>&gt; we&#39;re breaking new ground for language design here. Classes limiting<br>&gt; inheritance to a certain set of subclasses are nothing new (I&#39;ve written &amp;<br>&gt; used classes doing this in C++, Java and C#), but no language that I know of<br>&gt; allows limiting overrides of a specific public member in such a way. I think<br>&gt; we need a convincing rationale for making this esoteric middle ground<br>&gt; between final and open members the new default.<br>&gt;<br>&gt; The UIKit example above isn&#39;t convincing at all. It is already quite easy to<br>&gt; allow package-internal subclasses to configure the behavior of<br>&gt; loadViewIfNeeded without such a novel language feature. E.g., the UIKit team<br>&gt; can simply make loadViewIfNeeded call into a non-final but internal method:<br>&gt;<br>&gt; public open class UIViewController {<br>&gt;         private var _view: UIView? = nil<br>&gt;<br>&gt;         public final func loadViewIfNeeded() {<br>&gt;                 internalLoadViewIfNeeded()<br>&gt;         }<br>&gt;<br>&gt;         internal func internalLoadViewIfNeeded() { // overridable internally<br>&gt;                 if let view = _view { return }<br>&gt;                 loadView()<br>&gt;         }<br>&gt;<br>&gt;         public open func loadView() {<br>&gt;                 // Load it from a nib or whatevs<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; I see no drawback to this pattern; it is quite clear and simple. Therefore,<br>&gt; in the interest of keeping the language free of needless complexity, I<br>&gt; suggest we change the proposal to remove the implicit &quot;sealed&quot; level of<br>&gt; public member overridability, and support only &quot;open&quot; or &quot;final&quot; class<br>&gt; members.<br>&gt;<br>&gt; For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels in<br>&gt; between. Member-level openness should be entirely independent of visibility;<br>&gt; so it should be possible to say &quot;internal open&quot; to mean an internally<br>&gt; overridable member that&#39;s not at all visible outside the module -- the same<br>&gt; as today&#39;s default.<br>&gt;<br>&gt; (Note that (on platforms with an Objective-C runtime) &quot;dynamic&quot; provides a<br>&gt; third level of flexibility for class members; I argue that it should imply<br>&gt; &quot;open&quot;. So in order of increasing flexibility, we&#39;d have &quot;final&quot;, &quot;open&quot; and<br>&gt; &quot;dynamic&quot; members. This seems easy enough to describe and understand.)<br>&gt;<br>&gt; I also suggest that for now, we should make neither &quot;final&quot; nor &quot;open&quot; nor<br>&gt; &quot;dynamic&quot; the default for public members of open classes: we should rather<br>&gt; require class authors to explicity add one of these qualifiers to all public<br>&gt; member declarations. This way, we can defer the argument for choosing a<br>&gt; default to a later (additive) proposal, once we have some experience with<br>&gt; this setup. Non-public members can safely keep defaulting to &quot;internal<br>&gt; open&quot;, like they do today.<br>&gt;<br>&gt; --<br>&gt; Károly<br>&gt; @lorentey<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 18 Jul 2016, at 14:07, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I see no drawback to this pattern; it is quite clear and simple. Therefore, in the interest of keeping the language free of needless complexity, I suggest we change the proposal to remove the implicit &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or &quot;final&quot; class members.<br></p><p><br>At the same time, your solution results in a lot of unnecessary boilerplate. Sure, it might be rare with methods, but don’t forget about properties! It makes perfect sense to have properties that should be only overridable internally while being accessible publicly. Imagine adding that boilerplate to every such property.. <br></p><p>Basically, if we do it your way, then it won’t be long that someone submits a proposal for a keyword for synthesising the boilerplate, which more or less brings us back to square one.  <br></p><p>T.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 11:24 AM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 18 Jul 2016, at 14:07, Károly Lőrentey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I see no drawback to this pattern; it is quite clear and simple.<br>&gt; Therefore, in the interest of keeping the language free of needless<br>&gt; complexity, I suggest we change the proposal to remove the implicit<br>&gt; &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or<br>&gt; &quot;final&quot; class members.<br>&gt;<br>&gt;<br>&gt; At the same time, your solution results in a lot of unnecessary<br>&gt; boilerplate.<br></p><p><br>It&#39;s an exaggeration to say that it&#39;s *a lot* of boilerplate. It&#39;s one line<br>or two in the base class.<br></p><p><br>&gt; Sure, it might be rare with methods, but don’t forget about properties! It<br>&gt; makes perfect sense to have properties that should be only overridable<br>&gt; internally while being accessible publicly.<br></p><p><br>My first reaction here was: of course, good point! But then, on reflection,<br>what properties should behave this way? Can you give an example of a<br>property that makes sense to override in internal subclasses but not in<br>external subclasses, but that must be accessible publicly?<br></p><p><br>&gt; Imagine adding that boilerplate to every such property..<br>&gt;<br></p><p>On balance, I think the number of `open` annotations would far exceed the<br>amount of this boilerplate. I&#39;m not convinced it is even a mildly common<br>use case.<br></p><p><br>&gt; Basically, if we do it your way, then it won’t be long that someone<br>&gt; submits a proposal for a keyword for synthesising the boilerplate, which<br>&gt; more or less brings us back to square one.<br>&gt;<br>&gt; T.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/3a06775b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 9:31 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 11:24 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On 18 Jul 2016, at 14:07, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I see no drawback to this pattern; it is quite clear and simple. Therefore, in the interest of keeping the language free of needless complexity, I suggest we change the proposal to remove the implicit &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or &quot;final&quot; class members.<br>&gt; <br>&gt; <br>&gt; At the same time, your solution results in a lot of unnecessary boilerplate.<br>&gt;  <br>&gt; It&#39;s an exaggeration to say that it&#39;s *a lot* of boilerplate. It&#39;s one line or two in the base class.<br></p><p>The basic effect of Károly&#39;s counter-proposal is that every public member of an open class has to be marked either &quot;open&quot; or &quot;final&quot;.  That&#39;s boilerplate.<br></p><p>I think you and Károly are evaluating the addition of non-open methods as if they were being added primarily to increase expressive capabilities.  They do marginally increase expressiveness, but I agree that it&#39;s not a common situation to explicitly want.  However, neither are non-open classes.  The goal here is not to create new expressive power, it&#39;s to establish a comprehensible intermediate position that&#39;s acceptable as a default so that publicizing an API doesn&#39;t require so much annotation and bookkeeping.  Otherwise, programmers are forced to immediately decide between over-promising (by making the method publicly overridable) or breaking their own code (if they have internal overrides).<br></p><p>Furthermore, I don&#39;t agree that non-open methods add significant new complexity.  For clients of a library, a non-open method is final; there are no semantically-detectable differences (ignoring covariant overrides).  Within a library, non-open methods remove the need for some unnecessary bookkeeping.  And just on a conceptual level, the analogy to class behavior is quite simple.<br></p><p>John.<br></p><p>&gt;  <br>&gt; Sure, it might be rare with methods, but don’t forget about properties! It makes perfect sense to have properties that should be only overridable internally while being accessible publicly.<br>&gt; <br>&gt; My first reaction here was: of course, good point! But then, on reflection, what properties should behave this way? Can you give an example of a property that makes sense to override in internal subclasses but not in external subclasses, but that must be accessible publicly?<br>&gt;  <br>&gt; Imagine adding that boilerplate to every such property..<br>&gt; <br>&gt; On balance, I think the number of `open` annotations would far exceed the amount of this boilerplate. I&#39;m not convinced it is even a mildly common use case.<br>&gt; <br>&gt; <br>&gt; Basically, if we do it your way, then it won’t be long that someone submits a proposal for a keyword for synthesising the boilerplate, which more or less brings us back to square one.<br>&gt; <br>&gt; T.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c6e02a60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 2016-07-18, at 19:05, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The basic effect of Károly&#39;s counter-proposal is that every public member of an open class has to be marked either &quot;open&quot; or &quot;final&quot;.  That&#39;s boilerplate.<br></p><p>My primary point was that there is no need for a middle ground between &quot;final&quot; and &quot;open&quot; members.<br></p><p>I want to push my primary point a little more, so let’s forget my secondary suggestion to have no default, and let’s set an implicit choice. <br></p><p>I&#39;d still argue for having no middle ground. “final” seems to be a good default; its effect matches the proposal.<br></p><p>&gt; I think you and Károly are evaluating the addition of non-open methods as if they were being added primarily to increase expressive capabilities.  They do marginally increase expressiveness, but I agree that it&#39;s not a common situation to explicitly want.  However, neither are non-open classes.  <br></p><p>It&#39;s more of an Occam&#39;s razor thing. The proposal prevents people from unintentionally exposing a wider API area than they intended. I agree with this wholeheartedly. I just don&#39;t believe that we need to add a brand new access level for members to achieve this goal.<br></p><p>Having an implicit &quot;sealed&quot; class level is a much easier sell for me, because it is sometimes desirable to expose a sealed class hierarchy, but Swift doesn&#39;t currently support it well -- AFAICT not as an intentional choice, but rather as an unfortunate side-effect of the initializer rules. You could&#39;ve simply chosen to propose making &quot;final&quot; the default for public classes. Kotlin&#39;s troubles mostly wouldn&#39;t apply as long as internal classes would remain open, so I&#39;d have supported that too. But rather than this, the proposal is built on top a nice solution to the sealed class problem. Solving it is obviously a good idea, and it is closely related to the goal of the proposal.<br></p><p>There is no such language problem in Swift 2 with sealed methods: an internal open member is sealed by virtue of not being externally visible. It’s straightforward to add a public final trampoline in the rare case when a sealed member should also be made externally callable. I believe the proposal works perfectly well without adding a language feature for this uncommon usecase.<br></p><p>&gt; The goal here is not to create new expressive power, it&#39;s to establish a comprehensible intermediate position that&#39;s acceptable as a default so that publicizing an API doesn&#39;t require so much annotation and bookkeeping.  Otherwise, programmers are forced to immediately decide between over-promising (by making the method publicly overridable) or breaking their own code (if they have internal overrides).<br></p><p>But making API public should never be done in a hurry. It includes making the API presentable, which involves some amount of refactoring. Granted, if an API has internally overridden methods that the author wants to make public but sealed, then they&#39;d need to refactor these methods. But given how rare this is, and how easy it is to implement the trampoline pattern, is such a trivial refactoring step really too much to ask? (There are a number of much more complicated refactorings involved in making an API public; e.g., it is often the case that a method I want to make public has a parameter or return value with a type that I wish to keep internal.)<br></p><p>I believe that apart from this one little wrinkle, the behavior that SE-0117 proposes can be fully implemented by allowing just &quot;final&quot;, &quot;open&quot; and &quot;dynamic&quot; members, with &quot;final&quot; being the default for public members of open classes, and &quot;open&quot; being the default for all other members (including non-open classes).<br></p><p>Is smoothing out that wrinkle worth introducing a whole new default level of member overridability? I think this is worth some more discussion.<br></p><p>Note that if we end up with &quot;final” members by default and it turns out to be the wrong choice, changing the default to sealed would not be a source-breaking change.<br></p><p>&gt; Furthermore, I don&#39;t agree that non-open methods add significant new complexity.  For clients of a library, a non-open method is final; there are no semantically-detectable differences (ignoring covariant overrides).  Within a library, non-open methods remove the need for some unnecessary bookkeeping.  And just on a conceptual level, the analogy to class behavior is quite simple.<br></p><p>This reminds me: Whether or not we allow the sealed level on methods, I suggest we provide a contextual keyword to (optionally) spell it. A &quot;sealed&quot; keyword is the obvious choice. This would encourage people to use common terminology, and makes it easier to use search engines to find an explanation of the concept. Autogenerated API summaries should add the &quot;sealed&quot; keyword.<br></p><p>We never have to spell &quot;internal&quot;, but I think it is still very useful that it exists.<br></p><p>--<br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 10:13 AM, Károly Lőrentey &lt;karoly at lorentey.hu&gt; wrote:<br>&gt;&gt; On 2016-07-18, at 19:05, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The basic effect of Károly&#39;s counter-proposal is that every public member of an open class has to be marked either &quot;open&quot; or &quot;final&quot;.  That&#39;s boilerplate.<br>&gt; <br>&gt; My primary point was that there is no need for a middle ground between &quot;final&quot; and &quot;open&quot; members.<br>&gt; <br>&gt; I want to push my primary point a little more, so let’s forget my secondary suggestion to have no default, and let’s set an implicit choice. <br>&gt; <br>&gt; I&#39;d still argue for having no middle ground. “final” seems to be a good default; its effect matches the proposal.<br>&gt; <br>&gt;&gt; I think you and Károly are evaluating the addition of non-open methods as if they were being added primarily to increase expressive capabilities.  They do marginally increase expressiveness, but I agree that it&#39;s not a common situation to explicitly want.  However, neither are non-open classes.  <br>&gt; <br>&gt; It&#39;s more of an Occam&#39;s razor thing. The proposal prevents people from unintentionally exposing a wider API area than they intended. I agree with this wholeheartedly. I just don&#39;t believe that we need to add a brand new access level for members to achieve this goal.<br>&gt; <br>&gt; Having an implicit &quot;sealed&quot; class level is a much easier sell for me, because it is sometimes desirable to expose a sealed class hierarchy, but Swift doesn&#39;t currently support it well -- AFAICT not as an intentional choice, but rather as an unfortunate side-effect of the initializer rules. You could&#39;ve simply chosen to propose making &quot;final&quot; the default for public classes. Kotlin&#39;s troubles mostly wouldn&#39;t apply as long as internal classes would remain open, so I&#39;d have supported that too. But rather than this, the proposal is built on top a nice solution to the sealed class problem. Solving it is obviously a good idea, and it is closely related to the goal of the proposal.<br>&gt; <br>&gt; There is no such language problem in Swift 2 with sealed methods: an internal open member is sealed by virtue of not being externally visible. It’s straightforward to add a public final trampoline in the rare case when a sealed member should also be made externally callable. I believe the proposal works perfectly well without adding a language feature for this uncommon usecase.<br>&gt; <br>&gt;&gt; The goal here is not to create new expressive power, it&#39;s to establish a comprehensible intermediate position that&#39;s acceptable as a default so that publicizing an API doesn&#39;t require so much annotation and bookkeeping.  Otherwise, programmers are forced to immediately decide between over-promising (by making the method publicly overridable) or breaking their own code (if they have internal overrides).<br>&gt; <br>&gt; But making API public should never be done in a hurry. It includes making the API presentable, which involves some amount of refactoring. Granted, if an API has internally overridden methods that the author wants to make public but sealed, then they&#39;d need to refactor these methods. But given how rare this is, and how easy it is to implement the trampoline pattern, is such a trivial refactoring step really too much to ask? (There are a number of much more complicated refactorings involved in making an API public; e.g., it is often the case that a method I want to make public has a parameter or return value with a type that I wish to keep internal.)<br></p><p>I agree that having the concept of &quot;visible publicly but only arbitrary modifiable internally&quot; adds complexity to the language.  However, once we&#39;ve got non-open public classes — and as I understand it, you still support those — that complexity already exists.  You&#39;re not really eliminating anything by preventing this from being applied to methods.<br></p><p>Also, we&#39;re going to be proposing a lot of new things for library-resilience over the next six months or so that will add appreciable but unavoidable complexity to the language around module boundaries.  Module boundaries have a lot of special significance in the language design because Swift takes the stable binary interface problem much more seriously than, I think, almost any other language can claim to.<br></p><p>&gt; I believe that apart from this one little wrinkle, the behavior that SE-0117 proposes can be fully implemented by allowing just &quot;final&quot;, &quot;open&quot; and &quot;dynamic&quot; members, with &quot;final&quot; being the default for public members of open classes, and &quot;open&quot; being the default for all other members (including non-open classes).<br>&gt; <br>&gt; Is smoothing out that wrinkle worth introducing a whole new default level of member overridability? I think this is worth some more discussion.<br>&gt; <br>&gt; Note that if we end up with &quot;final” members by default and it turns out to be the wrong choice, changing the default to sealed would not be a source-breaking change.<br>&gt; <br>&gt;&gt; Furthermore, I don&#39;t agree that non-open methods add significant new complexity.  For clients of a library, a non-open method is final; there are no semantically-detectable differences (ignoring covariant overrides).  Within a library, non-open methods remove the need for some unnecessary bookkeeping.  And just on a conceptual level, the analogy to class behavior is quite simple.<br>&gt; <br>&gt; This reminds me: Whether or not we allow the sealed level on methods, I suggest we provide a contextual keyword to (optionally) spell it. A &quot;sealed&quot; keyword is the obvious choice. This would encourage people to use common terminology, and makes it easier to use search engines to find an explanation of the concept. Autogenerated API summaries should add the &quot;sealed&quot; keyword.<br></p><p>Yes, we should probably add some way to spell it.  &quot;sealed&quot; does not feel like a natural opposite to &quot;open&quot;, however, and I think we&#39;re quite taken with &quot;open&quot;.  I would suggest &quot;nonopen&quot; or &quot;closed&quot;.<br></p><p>John.<br></p><p>&gt; <br>&gt; We never have to spell &quot;internal&quot;, but I think it is still very useful that it exists.<br>&gt; <br>&gt; --<br>&gt; Károly<br>&gt; @lorentey<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 2016-07-20, at 19:34, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; I agree that having the concept of &quot;visible publicly but only arbitrary modifiable internally&quot; adds complexity to the language.  However, once we&#39;ve got non-open public classes — and as I understand it, you still support those — that complexity already exists.  You&#39;re not really eliminating anything by preventing this from being applied to methods.<br>&gt; <br>&gt; Also, we&#39;re going to be proposing a lot of new things for library-resilience over the next six months or so that will add appreciable but unavoidable complexity to the language around module boundaries. Module boundaries have a lot of special significance in the language design because Swift takes the stable binary interface problem much more seriously than, I think, almost any other language can claim to.<br></p><p>Fair enough! Let’s move on.<br></p><p>&gt;&gt; This reminds me: Whether or not we allow the sealed level on methods, I suggest we provide a contextual keyword to (optionally) spell it. A &quot;sealed&quot; keyword is the obvious choice. This would encourage people to use common terminology, and makes it easier to use search engines to find an explanation of the concept. Autogenerated API summaries should add the &quot;sealed&quot; keyword.<br>&gt; <br>&gt; Yes, we should probably add some way to spell it.  &quot;sealed&quot; does not feel like a natural opposite to &quot;open&quot;, however, and I think we&#39;re quite taken with &quot;open&quot;.  I would suggest &quot;nonopen&quot; or &quot;closed”.<br></p><p>Ah, interesting! Kotlin and Scala uses the “sealed” keyword for their own variants for the same concept. C# is popular and uses “sealed” to mean what we call “final”; it’s in the same general ballpark. MATLAB (!!!) does the same. So it can be argued “sealed&quot; is a somewhat common term of art for roughly this pattern. <br></p><p>I could get used to “closed”, though.<br></p><p>But I think “nonopen” is a no-no (pen): it makes my eyes bleed.<br></p><p>-- <br>Károly<br>@lorentey<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/16af2841/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; However, once we&#39;ve got non-open public classes — and as I understand it,<br>&gt; you still support those — that complexity already exists.  You&#39;re not<br>&gt; really eliminating anything by preventing this from being applied to<br>&gt; methods.<br></p><p><br>We may not need to prevent public members from being declared non-open,<br>however I think that by *default* public members should be open.<br></p><p>Notably, one of the primary reasons for opening a class is to allow its<br>members to be overridden outside the module. In the by-all-accounts-rare<br>scenario that one or more public members of an open class should be<br>non-open, then they can be marked as such (or just use Károly’s trick with<br>`final` forwarding to `internal`).<br></p><p>I am reminded of the `atomic` / `nonatomic` situation in Objective-C. Yes,<br>`atomic` is generally safer, but almost every property in almost every<br>class is declared `nonatomic`. It was a mistake to set `atomic` as the<br>default, which caused a profusion of noise in property declarations.<br></p><p>If we were to make public members default to non-open, the result would be<br>similar: an extra keyword (`open`) appearing in almost every public<br>declaration in almost every open class.<br></p><p>The 80-20 rule may be applicable here: if even 1 out of 5 public members<br>ought to be non-open, then perhaps a consistency argument could be made.<br>But with non-open members being an essentially negligible fraction, I do<br>not see anything gained by *de facto* changing the spelling of `public` to<br>`public open` for members of open classes.<br></p><p>In sum, the default for public members should probably be `open`.<br></p><p>(I am fully on board with public *classes* defaulting to non-open.)<br></p><p>Nevin<br></p><p><br>On Wed, Jul 20, 2016 at 1:34 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jul 20, 2016, at 10:13 AM, Károly Lőrentey &lt;karoly at lorentey.hu&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; On 2016-07-18, at 19:05, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; The basic effect of Károly&#39;s counter-proposal is that every public<br>&gt; member of an open class has to be marked either &quot;open&quot; or &quot;final&quot;.  That&#39;s<br>&gt; boilerplate.<br>&gt; &gt;<br>&gt; &gt; My primary point was that there is no need for a middle ground between<br>&gt; &quot;final&quot; and &quot;open&quot; members.<br>&gt; &gt;<br>&gt; &gt; I want to push my primary point a little more, so let’s forget my<br>&gt; secondary suggestion to have no default, and let’s set an implicit choice.<br>&gt; &gt;<br>&gt; &gt; I&#39;d still argue for having no middle ground. “final” seems to be a good<br>&gt; default; its effect matches the proposal.<br>&gt; &gt;<br>&gt; &gt;&gt; I think you and Károly are evaluating the addition of non-open methods<br>&gt; as if they were being added primarily to increase expressive capabilities.<br>&gt; They do marginally increase expressiveness, but I agree that it&#39;s not a<br>&gt; common situation to explicitly want.  However, neither are non-open classes.<br>&gt; &gt;<br>&gt; &gt; It&#39;s more of an Occam&#39;s razor thing. The proposal prevents people from<br>&gt; unintentionally exposing a wider API area than they intended. I agree with<br>&gt; this wholeheartedly. I just don&#39;t believe that we need to add a brand new<br>&gt; access level for members to achieve this goal.<br>&gt; &gt;<br>&gt; &gt; Having an implicit &quot;sealed&quot; class level is a much easier sell for me,<br>&gt; because it is sometimes desirable to expose a sealed class hierarchy, but<br>&gt; Swift doesn&#39;t currently support it well -- AFAICT not as an intentional<br>&gt; choice, but rather as an unfortunate side-effect of the initializer rules.<br>&gt; You could&#39;ve simply chosen to propose making &quot;final&quot; the default for public<br>&gt; classes. Kotlin&#39;s troubles mostly wouldn&#39;t apply as long as internal<br>&gt; classes would remain open, so I&#39;d have supported that too. But rather than<br>&gt; this, the proposal is built on top a nice solution to the sealed class<br>&gt; problem. Solving it is obviously a good idea, and it is closely related to<br>&gt; the goal of the proposal.<br>&gt; &gt;<br>&gt; &gt; There is no such language problem in Swift 2 with sealed methods: an<br>&gt; internal open member is sealed by virtue of not being externally visible.<br>&gt; It’s straightforward to add a public final trampoline in the rare case when<br>&gt; a sealed member should also be made externally callable. I believe the<br>&gt; proposal works perfectly well without adding a language feature for this<br>&gt; uncommon usecase.<br>&gt; &gt;<br>&gt; &gt;&gt; The goal here is not to create new expressive power, it&#39;s to establish<br>&gt; a comprehensible intermediate position that&#39;s acceptable as a default so<br>&gt; that publicizing an API doesn&#39;t require so much annotation and<br>&gt; bookkeeping.  Otherwise, programmers are forced to immediately decide<br>&gt; between over-promising (by making the method publicly overridable) or<br>&gt; breaking their own code (if they have internal overrides).<br>&gt; &gt;<br>&gt; &gt; But making API public should never be done in a hurry. It includes<br>&gt; making the API presentable, which involves some amount of refactoring.<br>&gt; Granted, if an API has internally overridden methods that the author wants<br>&gt; to make public but sealed, then they&#39;d need to refactor these methods. But<br>&gt; given how rare this is, and how easy it is to implement the trampoline<br>&gt; pattern, is such a trivial refactoring step really too much to ask? (There<br>&gt; are a number of much more complicated refactorings involved in making an<br>&gt; API public; e.g., it is often the case that a method I want to make public<br>&gt; has a parameter or return value with a type that I wish to keep internal.)<br>&gt;<br>&gt; I agree that having the concept of &quot;visible publicly but only arbitrary<br>&gt; modifiable internally&quot; adds complexity to the language.  However, once<br>&gt; we&#39;ve got non-open public classes — and as I understand it, you still<br>&gt; support those — that complexity already exists.  You&#39;re not really<br>&gt; eliminating anything by preventing this from being applied to methods.<br>&gt;<br>&gt; Also, we&#39;re going to be proposing a lot of new things for<br>&gt; library-resilience over the next six months or so that will add appreciable<br>&gt; but unavoidable complexity to the language around module boundaries.<br>&gt; Module boundaries have a lot of special significance in the language design<br>&gt; because Swift takes the stable binary interface problem much more seriously<br>&gt; than, I think, almost any other language can claim to.<br>&gt;<br>&gt; &gt; I believe that apart from this one little wrinkle, the behavior that<br>&gt; SE-0117 proposes can be fully implemented by allowing just &quot;final&quot;, &quot;open&quot;<br>&gt; and &quot;dynamic&quot; members, with &quot;final&quot; being the default for public members of<br>&gt; open classes, and &quot;open&quot; being the default for all other members (including<br>&gt; non-open classes).<br>&gt; &gt;<br>&gt; &gt; Is smoothing out that wrinkle worth introducing a whole new default<br>&gt; level of member overridability? I think this is worth some more discussion.<br>&gt; &gt;<br>&gt; &gt; Note that if we end up with &quot;final” members by default and it turns out<br>&gt; to be the wrong choice, changing the default to sealed would not be a<br>&gt; source-breaking change.<br>&gt; &gt;<br>&gt; &gt;&gt; Furthermore, I don&#39;t agree that non-open methods add significant new<br>&gt; complexity.  For clients of a library, a non-open method is final; there<br>&gt; are no semantically-detectable differences (ignoring covariant overrides).<br>&gt; Within a library, non-open methods remove the need for some unnecessary<br>&gt; bookkeeping.  And just on a conceptual level, the analogy to class behavior<br>&gt; is quite simple.<br>&gt; &gt;<br>&gt; &gt; This reminds me: Whether or not we allow the sealed level on methods, I<br>&gt; suggest we provide a contextual keyword to (optionally) spell it. A<br>&gt; &quot;sealed&quot; keyword is the obvious choice. This would encourage people to use<br>&gt; common terminology, and makes it easier to use search engines to find an<br>&gt; explanation of the concept. Autogenerated API summaries should add the<br>&gt; &quot;sealed&quot; keyword.<br>&gt;<br>&gt; Yes, we should probably add some way to spell it.  &quot;sealed&quot; does not feel<br>&gt; like a natural opposite to &quot;open&quot;, however, and I think we&#39;re quite taken<br>&gt; with &quot;open&quot;.  I would suggest &quot;nonopen&quot; or &quot;closed&quot;.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; We never have to spell &quot;internal&quot;, but I think it is still very useful<br>&gt; that it exists.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Károly<br>&gt; &gt; @lorentey<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/7238beb3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Jul 20, 2016, at 7:34 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; On Jul 20, 2016, at 10:13 AM, Károly Lőrentey &lt;karoly at lorentey.hu&gt; wrote:<br>&gt;&gt;&gt; On 2016-07-18, at 19:05, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; The basic effect of Károly&#39;s counter-proposal is that every public member of an open class has to be marked either &quot;open&quot; or &quot;final&quot;.  That&#39;s boilerplate.<br>&gt;&gt; <br>&gt;&gt; My primary point was that there is no need for a middle ground between &quot;final&quot; and &quot;open&quot; members.<br>&gt;&gt; <br>&gt;&gt; I want to push my primary point a little more, so let’s forget my secondary suggestion to have no default, and let’s set an implicit choice. <br>&gt;&gt; <br>&gt;&gt; I&#39;d still argue for having no middle ground. “final” seems to be a good default; its effect matches the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; I think you and Károly are evaluating the addition of non-open methods as if they were being added primarily to increase expressive capabilities.  They do marginally increase expressiveness, but I agree that it&#39;s not a common situation to explicitly want.  However, neither are non-open classes.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s more of an Occam&#39;s razor thing. The proposal prevents people from unintentionally exposing a wider API area than they intended. I agree with this wholeheartedly. I just don&#39;t believe that we need to add a brand new access level for members to achieve this goal.<br>&gt;&gt; <br>&gt;&gt; Having an implicit &quot;sealed&quot; class level is a much easier sell for me, because it is sometimes desirable to expose a sealed class hierarchy, but Swift doesn&#39;t currently support it well -- AFAICT not as an intentional choice, but rather as an unfortunate side-effect of the initializer rules. You could&#39;ve simply chosen to propose making &quot;final&quot; the default for public classes. Kotlin&#39;s troubles mostly wouldn&#39;t apply as long as internal classes would remain open, so I&#39;d have supported that too. But rather than this, the proposal is built on top a nice solution to the sealed class problem. Solving it is obviously a good idea, and it is closely related to the goal of the proposal.<br>&gt;&gt; <br>&gt;&gt; There is no such language problem in Swift 2 with sealed methods: an internal open member is sealed by virtue of not being externally visible. It’s straightforward to add a public final trampoline in the rare case when a sealed member should also be made externally callable. I believe the proposal works perfectly well without adding a language feature for this uncommon usecase.<br>&gt;&gt; <br>&gt;&gt;&gt; The goal here is not to create new expressive power, it&#39;s to establish a comprehensible intermediate position that&#39;s acceptable as a default so that publicizing an API doesn&#39;t require so much annotation and bookkeeping.  Otherwise, programmers are forced to immediately decide between over-promising (by making the method publicly overridable) or breaking their own code (if they have internal overrides).<br>&gt;&gt; <br>&gt;&gt; But making API public should never be done in a hurry. It includes making the API presentable, which involves some amount of refactoring. Granted, if an API has internally overridden methods that the author wants to make public but sealed, then they&#39;d need to refactor these methods. But given how rare this is, and how easy it is to implement the trampoline pattern, is such a trivial refactoring step really too much to ask? (There are a number of much more complicated refactorings involved in making an API public; e.g., it is often the case that a method I want to make public has a parameter or return value with a type that I wish to keep internal.)<br>&gt; <br>&gt; I agree that having the concept of &quot;visible publicly but only arbitrary modifiable internally&quot; adds complexity to the language.  However, once we&#39;ve got non-open public classes — and as I understand it, you still support those — that complexity already exists.  You&#39;re not really eliminating anything by preventing this from being applied to methods.<br>&gt; <br>&gt; Also, we&#39;re going to be proposing a lot of new things for library-resilience over the next six months or so that will add appreciable but unavoidable complexity to the language around module boundaries.  Module boundaries have a lot of special significance in the language design because Swift takes the stable binary interface problem much more seriously than, I think, almost any other language can claim to.<br></p><p>Considering how most people in this list likely do not understand where there is an issue and the fact that most of the planet&#39;s servers have done reasonably until today with only a pre9-java solution, i wonder who these enhancements are meant for? Binary sharing in the apple world is very limited outside apple, so at this point I question if these will be for users or something else we will have to overcome. <br></p><p>&gt;&gt; I believe that apart from this one little wrinkle, the behavior that SE-0117 proposes can be fully implemented by allowing just &quot;final&quot;, &quot;open&quot; and &quot;dynamic&quot; members, with &quot;final&quot; being the default for public members of open classes, and &quot;open&quot; being the default for all other members (including non-open classes).<br>&gt;&gt; <br>&gt;&gt; Is smoothing out that wrinkle worth introducing a whole new default level of member overridability? I think this is worth some more discussion.<br>&gt;&gt; <br>&gt;&gt; Note that if we end up with &quot;final” members by default and it turns out to be the wrong choice, changing the default to sealed would not be a source-breaking change.<br>&gt;&gt; <br>&gt;&gt;&gt; Furthermore, I don&#39;t agree that non-open methods add significant new complexity.  For clients of a library, a non-open method is final; there are no semantically-detectable differences (ignoring covariant overrides).  Within a library, non-open methods remove the need for some unnecessary bookkeeping.  And just on a conceptual level, the analogy to class behavior is quite simple.<br>&gt;&gt; <br>&gt;&gt; This reminds me: Whether or not we allow the sealed level on methods, I suggest we provide a contextual keyword to (optionally) spell it. A &quot;sealed&quot; keyword is the obvious choice. This would encourage people to use common terminology, and makes it easier to use search engines to find an explanation of the concept. Autogenerated API summaries should add the &quot;sealed&quot; keyword.<br>&gt; <br>&gt; Yes, we should probably add some way to spell it.  &quot;sealed&quot; does not feel like a natural opposite to &quot;open&quot;, however, and I think we&#39;re quite taken with &quot;open&quot;.  I would suggest &quot;nonopen&quot; or &quot;closed&quot;.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; We never have to spell &quot;internal&quot;, but I think it is still very useful that it exists.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Károly<br>&gt;&gt; @lorentey<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 19, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 18 Jul 2016, at 18:31, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; At the same time, your solution results in a lot of unnecessary boilerplate.<br>&gt;  <br>&gt; It&#39;s an exaggeration to say that it&#39;s *a lot* of boilerplate. It&#39;s one line or two in the base class.<br></p><p>&gt; Sure, it might be rare with methods, but don’t forget about properties! It makes perfect sense to have properties that should be only overridable internally while being accessible publicly.<br>&gt; <br>&gt; My first reaction here was: of course, good point! But then, on reflection, what properties should behave this way? Can you give an example of a property that makes sense to override in internal subclasses but not in external subclasses, but that must be accessible publicly?<br>&gt;  <br></p><p>Well, boilerplate is boilerplate. I can imagine a number of situations where you’d need it — any time where you can some sort of logical division in your class design, where some functionality relies on internal invariants that are no business of the user while functionality is tweakable. At the same time, after thinking about it for a while, I agree that such cases might be rare:<br></p><p>1. If your class requires a lot of sealed members, then probably there is a better design somewhere that splits that class in multiple components. <br>2. If your members are overriden internally but sealed publicly, the performance argument seems to be diminished to me — the compiler still needs to do some sort of vtable dispatch if <br>    the identity of the instance type is not known at compile-time. <br>3. I did a quick rudimentary regex through AppKit headers looking for stuff like &quot;((n&#39;t)|(not)).{1,15}override“ and its true that there seem to be only a few dozens of documented methods where the documentation explicitly warns agains overriding them.  I have no idea how reliable the headers are or what the documentation is generated from, but that appears to me to be quite strong evidence <br>in support of Károly’s and others arguments. <br></p><p>I still think that explicit open is a better design conceptually, as it requires one to grant per-declaration permission instead than per-declaration prohibition, but I agree that it might be a sub optional design from the practical standpoint because of low frequency of sealed members in practice. In retrospect, It might be indeed worth seriously considering making ‚open‘ a class-level annotation only. But then, there are good arguments for having an additional ‚sealed‘ keyword for the relatively rare case where we want to explicitly exclude a method/property from being overridable. <br></p><p>T.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/1f7bbac2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 19, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Taras Zakharko: I did a quick rudimentary regex through AppKit headers looking for stuff like &quot;((n&#39;t)|(not)).{1,15}override“ and its true that there seem to be only a few dozens of documented methods where the documentation explicitly warns agains overriding them.  I have no idea how reliable the headers are or what the documentation is generated from, but that appears to me to be quite strong evidence in support of Károly’s and others arguments. <br></p><p>That sounds informative and relevant.<br></p><p>Taras didn’t post his results, so I repeated the same basic procedure against the headers included in Xcode 8 beta 3. I’ll describe the procedure I used below, but for the impatient, here’s what I found. Keep in mind that the data quality is pretty low: it derives from comments in header files for libraries written in another language, searched for with one regex. Make of this what you will.<br></p><p>That said, there does not appear to be much obvious support in the existing iOS API for the idea that some kind of method-level indicator of non-overridability would be helpful. Individual methods and properties notated as being non-overridable are exceptionally rare (as are “don’t subclass” classes, for that matter). Among non-overridable methods, virtually all cases would be well handled by the existing “final” specifier, because they are defined in one class and never reimplemented by subclasses.<br></p><p>It’s also interesting, and heartening, to see the general tenor of the header comments that warn developers away from subclassing or overriding things. &quot;Most clients will not need to subclass UITabBarController,” is a typical discouragement. I can’t help wondering how many such demurrals will simply become prohibitions under the new defaults.<br></p><p>Procedure: I ran the regex<br></p><p>	((n&#39;t)|(not)).{1,15}(override|subclass|specialize|implement)<br></p><p>over everything within<br></p><p>	/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform<br></p><p>That produced 200 matches spread over 3981 files. I then examined each match in detail. The vast majority of matches were comments of the form “if a subclass does not implement…” or comments about functionality that was in fact not implemented. (That is, noise.)<br></p><p>Six classes were commented as being non-subclassable. Since a decision has already been made to allow Swift to support explicitly non-subclassable classes. I didn’t investigate these in detail. But for reference, they are:<br></p><p>ABNewPersonViewController<br>ABPeoplePickerNavigationController<br>AVMetadataObject<br>NSPointerFunctions<br>SKView<br>UITextInputMode<br></p><p>There were 12 methods commented as being non-overridable (the exact terminology varied). They were:<br></p><p>[UIViewController childViewControllerContainingSegueSource:]<br>[UIStackView +layerClass]<br>[UIResponder inputAssistantItem] (property)<br>[NSFileProviderExtension writePlaceholderAtURL:withMetadata:error:]<br>[NSFileProviderExtension placeholderForURL:]<br>[NEPacketTunnelProvider setTunnelNetworkSettings:completionHandler:]<br>[NEAppProxyProvider cancelProxyWithError:]<br>[NSIncrementalStore newObjectIDForEntity:referenceObject:]<br>[NSIncrementalStore referenceObjectForObjectID:]<br>[AUAudioUnit scheduleParameterBlock] (property)<br>[AUAudioUnit scheduleMIDIEventBlock] (property)<br></p><p>For these, I wanted to answer the question, “Had these classes been written in Swift, would a designation of ‘final’ have sufficed to limit their overridability?” Which is to say, “Are there no subclasses of the classes whose methods or properties bear the ‘don’t override’ notations that also implement these methods?” If there are no subclasses with implementations, then “final” on the original method would be sufficient to keep the method public but forestall unwanted overrides.<br></p><p>To investigate that, I ran nm on the corresponding framework dylib from iPhoneSimulator.platform, then grepped for the first component of the method names. Unfortunately, there’s no code in the AudioUnit.framework directory for either iPhoneSimulator.platform or MacOS.platform, so I couldn’t assess the AUAudioUnit properties. (I’m sure there’s a better way to do this; I just don’t know what it is.)<br></p><p>Of the remaining 10 methods, 9 were never overridden by a subclass within the same framework, meaning that they’d be covered perfectly well by “final”.<br></p><p>The one remaining case is the inputAssistantItem property on UIResponder. That’s implemented both by UIResponder and its indirect descendant UISearchBar. This property is read-only and is used only on iPad; it configures extra controls that appear above the keyboard when a responder interested in keyboard events has the input focus. You configure the assistant items by accessing the inputAssistantItem on an existing view and setting its properties. It’s not obvious to me on initial inspection why exactly inputAssistantItem must never be overridden. <br></p><p>Garth<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/ae392807/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Just wanted to leave a quick +1 for the reworked version. `overridable`<br>looked awful, but I reread the proposal, and `open` complements `final`<br>nicely.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/2b776337/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Károly wrote: I suggest we change the proposal to remove the implicit &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or &quot;final&quot; class members. For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels in between. Member-level openness should be entirely independent of visibility; so it should be possible to say &quot;internal open&quot; to mean an internally overridable member that&#39;s not at all visible outside the module -- the same as today&#39;s default.<br></p><p>What is the distinction between this approach and simply omitting the ability to apply the “open” keyword to anything but a class?<br></p><p>The current behavior is (IIUC) that you cannot override a superclass’s final method. Aside from that, you can override any other method that’s visible to you, wherever you stand with regard to the superclass’s origin. If there’s no sealed status for members, why is any change to member annotations needed at all?<br></p><p>Garth<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Garth makes an excellent point. Károly is correct that we can already<br>achieve “sealed” by making a `final` member call through to an `internal`<br>one.<br></p><p>Therefore, it seem clear that “open” should only be applicable to classes,<br>not to members. This should simplify the proposal nicely.<br></p><p>Nevin<br></p><p><br>On Mon, Jul 18, 2016 at 2:39 PM, Garth Snyder via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Károly wrote: I suggest we change the proposal to remove the implicit<br>&gt; &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or<br>&gt; &quot;final&quot; class members. For members, &quot;open&quot; should mean the opposite of<br>&gt; &quot;final&quot;, with no levels in between. Member-level openness should be<br>&gt; entirely independent of visibility; so it should be possible to say<br>&gt; &quot;internal open&quot; to mean an internally overridable member that&#39;s not at all<br>&gt; visible outside the module -- the same as today&#39;s default.<br>&gt;<br>&gt; What is the distinction between this approach and simply omitting the<br>&gt; ability to apply the “open” keyword to anything but a class?<br>&gt;<br>&gt; The current behavior is (IIUC) that you cannot override a superclass’s<br>&gt; final method. Aside from that, you can override any other method that’s<br>&gt; visible to you, wherever you stand with regard to the superclass’s origin.<br>&gt; If there’s no sealed status for members, why is any change to member<br>&gt; annotations needed at all?<br>&gt;<br>&gt; Garth<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/cd850c8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>Nevin/Garth, please remember final and sealed are two different<br>concepts: final prevents anyone from subclassing/overriding while<br>sealed prevents from subclassing/overriding *outside* the module they<br>are declared. Thus final is not the same as sealed.<br></p><p>L<br></p><p><br>On 18 July 2016 at 15:45, Nevin Brackett-Rozinsky via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Garth makes an excellent point. Károly is correct that we can already<br>&gt; achieve “sealed” by making a `final` member call through to an `internal`<br>&gt; one.<br>&gt;<br>&gt; Therefore, it seem clear that “open” should only be applicable to classes,<br>&gt; not to members. This should simplify the proposal nicely.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 2:39 PM, Garth Snyder via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Károly wrote: I suggest we change the proposal to remove the implicit<br>&gt;&gt; &gt; &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or<br>&gt;&gt; &gt; &quot;final&quot; class members. For members, &quot;open&quot; should mean the opposite of<br>&gt;&gt; &gt; &quot;final&quot;, with no levels in between. Member-level openness should be entirely<br>&gt;&gt; &gt; independent of visibility; so it should be possible to say &quot;internal open&quot;<br>&gt;&gt; &gt; to mean an internally overridable member that&#39;s not at all visible outside<br>&gt;&gt; &gt; the module -- the same as today&#39;s default.<br>&gt;&gt;<br>&gt;&gt; What is the distinction between this approach and simply omitting the<br>&gt;&gt; ability to apply the “open” keyword to anything but a class?<br>&gt;&gt;<br>&gt;&gt; The current behavior is (IIUC) that you cannot override a superclass’s<br>&gt;&gt; final method. Aside from that, you can override any other method that’s<br>&gt;&gt; visible to you, wherever you stand with regard to the superclass’s origin.<br>&gt;&gt; If there’s no sealed status for members, why is any change to member<br>&gt;&gt; annotations needed at all?<br>&gt;&gt;<br>&gt;&gt; Garth<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Nevin/Garth, please remember final and sealed are two different<br>&gt; concepts: final prevents anyone from subclassing/overriding while<br>&gt; sealed prevents from subclassing/overriding *outside* the module they<br>&gt; are declared. Thus final is not the same as sealed.<br></p><p>No, of course it isn’t. I could well be misguided, but I don’t think I’m disoriented. :-)<br></p><p>Ultimately, the question is whether sealed methods offer any additional utility or advantage beyond that of sealed classes plus final. The existence of “final” is certainly relevant, as it already provides some, but not all, of the features of method-level sealing.<br></p><p>I’d still like to see a really solid use case that requires the full semantics of sealing at the method level.<br></p><p>Garth<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Sealed methods can be overriden inside the defined module/library but<br>not outside. Same benefit of classes.<br></p><p>L<br></p><p><br>On 18 July 2016 at 16:32, Garth Snyder via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Nevin/Garth, please remember final and sealed are two different<br>&gt;&gt; concepts: final prevents anyone from subclassing/overriding while<br>&gt;&gt; sealed prevents from subclassing/overriding *outside* the module they<br>&gt;&gt; are declared. Thus final is not the same as sealed.<br>&gt;<br>&gt; No, of course it isn’t. I could well be misguided, but I don’t think I’m disoriented. :-)<br>&gt;<br>&gt; Ultimately, the question is whether sealed methods offer any additional utility or advantage beyond that of sealed classes plus final. The existence of “final” is certainly relevant, as it already provides some, but not all, of the features of method-level sealing.<br>&gt;<br>&gt; I’d still like to see a really solid use case that requires the full semantics of sealing at the method level.<br>&gt;<br>&gt; Garth<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>July 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 23:37 schrieb Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Sealed methods can be overriden inside the defined module/library but<br>&gt; not outside. Same benefit of classes.<br></p><p>Interesting how the supporters of the proposal seem to imply that the opponents of the proposal don&#39;t get the difference between sealed and final. This has happened more than once here.<br></p><p>I know that sealed and final are different, but still I think that sealed has no proper use case that cannot be achieved with final as well (and more elegantly so). Interestingly, no one has yet created a simple example with more than 60 lines of code that demonstrates the use of sealed, and why it is better than final. (Not counting contrived examples with class names like `SomeClass` and similar method names.) I guess that you will not find such a use-case. But who should prove this? Do the opponents of the proposal have to prove that there is no single good use case? Or should the supporters at least demonstrate 2 good use cases (again, non-contrived examples with more than 60 lines of code.) If the supporters are not able to make some good example code with sealed/open, the library developers of the future will not either. I agree with everything Garth said below. I hope for a miracle that the core team will see soon that SE-0117 should be deallocated fast ;) I&#39;m sure we will all learn this in a year or two, when there will be experience with the sealed implementation.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; L<br>&gt; <br>&gt; <br>&gt; On 18 July 2016 at 16:32, Garth Snyder via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Nevin/Garth, please remember final and sealed are two different<br>&gt;&gt;&gt; concepts: final prevents anyone from subclassing/overriding while<br>&gt;&gt;&gt; sealed prevents from subclassing/overriding *outside* the module they<br>&gt;&gt;&gt; are declared. Thus final is not the same as sealed.<br>&gt;&gt; <br>&gt;&gt; No, of course it isn’t. I could well be misguided, but I don’t think I’m disoriented. :-)<br>&gt;&gt; <br>&gt;&gt; Ultimately, the question is whether sealed methods offer any additional utility or advantage beyond that of sealed classes plus final. The existence of “final” is certainly relevant, as it already provides some, but not all, of the features of method-level sealing.<br>&gt;&gt; <br>&gt;&gt; I’d still like to see a really solid use case that requires the full semantics of sealing at the method level.<br>&gt;&gt; <br>&gt;&gt; Garth<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>What you said back then lead me to understand you did not get the<br>difference. Forgive me if it wasn&#39;t the case but I&#39;ve also seen it<br>happen more than once in this list, hence the repeatition. I also<br>understand that there are other ways to implement the same behaviour<br>we want without sealed by default but I wouldn&#39;t call a lot of<br>boilerplate &quot;elegant&quot;.<br></p><p>The examples you asked for have already been provided a few times in<br>this thread and the previous and trying to disqualify them won&#39;t make<br>them go away. And I didn&#39;t ask you to prove there is no valid use case<br>for this; I asked you to give a good technical reason (one that is not<br>&quot;being able to fix someone elses&#39; code&quot;) to keep it as is today, which<br>is different.<br></p><p>I&#39;m placing my view here that by default would have to mean<br>non-propagating open to subclasses unless the one writing the subclass<br>means it too by explicitly keeping it open. To me, meaning (intention)<br>is the keyword here. I believe there is no need to really introduce a<br>new keyword for sealed but it will be necessary should open propagates<br>in order to allow a library extending from another library to re-seal<br>methods. This is inconsistent with sealed **by default** (that is,<br>unless stated otherwise).<br></p><p>The core team has already said that this is on, so I think it is a<br>waste of time to continue trying to disqualify the proposal<br>altogether. We have to focus on the issues the core team pointed out<br>that needed solving. Just like David, I also didn&#39;t like fileprivate<br>but I&#39;m not here trying to disqualify it (how long has it been,<br>actually?). I also liked to know that there are other examples of<br>languages that follow this model of sealed by default and they work,<br>even though most of them are little known languages. It&#39;s a model to<br>work with and every language has one; we&#39;re just changing Swift&#39;s.<br></p><p>L<br></p><p><br>On 20 July 2016 at 16:05, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;<br>&gt;&gt; Am 18.07.2016 um 23:37 schrieb Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Sealed methods can be overriden inside the defined module/library but<br>&gt;&gt; not outside. Same benefit of classes.<br>&gt;<br>&gt; Interesting how the supporters of the proposal seem to imply that the opponents of the proposal don&#39;t get the difference between sealed and final. This has happened more than once here.<br>&gt;<br>&gt; I know that sealed and final are different, but still I think that sealed has no proper use case that cannot be achieved with final as well (and more elegantly so). Interestingly, no one has yet created a simple example with more than 60 lines of code that demonstrates the use of sealed, and why it is better than final. (Not counting contrived examples with class names like `SomeClass` and similar method names.) I guess that you will not find such a use-case. But who should prove this? Do the opponents of the proposal have to prove that there is no single good use case? Or should the supporters at least demonstrate 2 good use cases (again, non-contrived examples with more than 60 lines of code.) If the supporters are not able to make some good example code with sealed/open, the library developers of the future will not either. I agree with everything Garth said below. I hope for a miracle that the core team will see soon that SE-0117 should be deallocated fast ;) I&#39;m sure we will all learn this in a year or two, when there will be experience with the sealed implementation.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt;<br>&gt;&gt; L<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18 July 2016 at 16:32, Garth Snyder via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Nevin/Garth, please remember final and sealed are two different<br>&gt;&gt;&gt;&gt; concepts: final prevents anyone from subclassing/overriding while<br>&gt;&gt;&gt;&gt; sealed prevents from subclassing/overriding *outside* the module they<br>&gt;&gt;&gt;&gt; are declared. Thus final is not the same as sealed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No, of course it isn’t. I could well be misguided, but I don’t think I’m disoriented. :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ultimately, the question is whether sealed methods offer any additional utility or advantage beyond that of sealed classes plus final. The existence of “final” is certainly relevant, as it already provides some, but not all, of the features of method-level sealing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d still like to see a really solid use case that requires the full semantics of sealing at the method level.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Garth<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 19, 2016 at 04:00:00pm</p></header><div class="content"><p>I was a little confused by this - I believe the previous proposal involved replacing final (and assuming it unless opened).<br>  <br></p><p>  <br>I do not support &quot;sealed&quot;. -1000 from me. I would absolutely holeheartedly support &quot;final&quot; by default; it&#39;s not very different to turning WMO on by default - and actually since we did so, classes you don&#39;t open up or internally subclass are implicitly final already, so it fits really nicely.<br>  <br></p><p>  <br>I don&#39;t want there to be both &quot;sealed by default&quot; and &quot;final&quot; in the language describing the same concept; it&#39;s confusing, users won&#39;t know immediately which is the standard behaviour. I also don&#39;t agree with a &quot;final outside module&quot; (sealed) attribute - it&#39;s an ugly compromise because we don&#39;t want to anger subclassers, but at the same time we clearly arent convinced by their arguments. This is a cowardly concession which makes the language uglier and less easy to reason about, just so complainers will keep quiet.<br>  <br></p><p>  <br>If the core team believes subclassability should be explicit, make it explicit everywhere. It honestly doesn&#39;t come up too often, and when it does tacking an &#39;internal(open)&#39;    isn&#39;t the hardest thing to make people do. It would make all code involving classes much easier to locally reason about - &quot;is this class overridden? By whom? How much freedom do I have to change things? Oh, all of the subclasses are internal? That&#39;s great, change away...&quot;<br>  <br></p><p>  <br>We don&#39;t have header files any more. Our source should be maximally self-documenting; not just for the compiler and optimisation potential, but for human beings too.   <br>  <br></p><p>  <br>Karl<br>  <br></p><p>  <br></p><p>  <br> Sent from my new   Email (https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=my_new_email)<br>  <br>  <br>  <br>  <br></p><p>  <br>  <br>&gt;   <br>&gt; On Jul 18, 2016 at 8:57 PM,  &lt;Leonardo Pessoa via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;  Nevin/Garth, please remember final and sealed are two different<br>&gt; concepts: final prevents anyone from subclassing/overriding while<br>&gt; sealed prevents from subclassing/overriding *outside* the module they<br>&gt; are declared. Thus final is not the same as sealed.<br>&gt;<br>&gt; L<br>&gt;<br>&gt;<br>&gt; On 18 July 2016 at 15:45, Nevin Brackett-Rozinsky via swift-evolution<br>&gt; &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;  Garth makes an excellent point. Károly is correct that we can already<br>&gt; &gt;  achieve “sealed” by making a `final` member call through to an `internal`<br>&gt; &gt;  one.<br>&gt; &gt;<br>&gt; &gt;  Therefore, it seem clear that “open” should only be applicable to classes,<br>&gt; &gt;  not to members. This should simplify the proposal nicely.<br>&gt; &gt;<br>&gt; &gt;  Nevin<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  On Mon, Jul 18, 2016 at 2:39 PM, Garth Snyder via swift-evolution<br>&gt; &gt;   &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   &gt;  Károly wrote: I suggest we change the proposal to remove the implicit<br>&gt; &gt;&gt;   &gt;  &quot;sealed&quot; level of public member overridability, and support only &quot;open&quot; or<br>&gt; &gt;&gt;   &gt;  &quot;final&quot; class members. For members, &quot;open&quot; should mean the opposite of<br>&gt; &gt;&gt;   &gt;  &quot;final&quot;, with no levels in between. Member-level openness should be entirely<br>&gt; &gt;&gt;   &gt;  independent of visibility; so it should be possible to say &quot;internal open&quot;<br>&gt; &gt;&gt;   &gt;  to mean an internally overridable member that&#39;s not at all visible outside<br>&gt; &gt;&gt;   &gt;  the module -- the same as today&#39;s default.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  What is the distinction between this approach and simply omitting the<br>&gt; &gt;&gt;  ability to apply the “open” keyword to anything but a class?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  The current behavior is (IIUC) that you cannot override a superclass’s<br>&gt; &gt;&gt;  final method. Aside from that, you can override any other method that’s<br>&gt; &gt;&gt;  visible to you, wherever you stand with regard to the superclass’s origin.<br>&gt; &gt;&gt;  If there’s no sealed status for members, why is any change to member<br>&gt; &gt;&gt;  annotations needed at all?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  Garth<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  _______________________________________________<br>&gt; &gt;&gt;  swift-evolution mailing list<br>&gt; &gt;&gt;   swift-evolution at swift.org (mailto:swift-evolution at swift.org)<br>&gt; &gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt;  swift-evolution mailing list<br>&gt; &gt;   swift-evolution at swift.org (mailto:swift-evolution at swift.org)<br>&gt; &gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing  list (mailto:listswift-evolution at swift.orghttps)<br>&gt; swift-evolution at swift.org (mailto:listswift-evolution at swift.orghttps)<br>&gt; https (mailto:listswift-evolution at swift.orghttps)://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/b44e346c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Károly demonstrated that it’s already possible to achieve the effect of a nonoverridable method:<br></p><p>&gt; public open class UIViewController {<br>&gt; 	private var _view: UIView? = nil<br>&gt; <br>&gt; 	public final func loadViewIfNeeded() {<br>&gt; 		internalLoadViewIfNeeded()<br>&gt; 	}<br>&gt; <br>&gt; 	internal func internalLoadViewIfNeeded() { // overridable internally<br>&gt; 		if let view = _view { return }<br>&gt; 		loadView()<br>&gt; 	}<br>&gt; <br>&gt; 	public open func loadView() {<br>&gt; 		// Load it from a nib or whatevs<br>&gt; 	}<br>&gt; }<br></p><p>Because the compiler understands “final” for vars, Károly&#39;s example works for them, too:<br></p><p>public class Argle {<br>    public final var value: Int {<br>        get { return internalGetValue() }<br>        set { internalSetValue(newValue) }<br>    }<br>    func internalGetValue() -&gt; Int { return 1 }<br>    func internalSetValue(_ newValue: Int) {}<br>}<br></p><p>I agree that both of these forms are unsightly. If this were a common idiom, I don’t think it would be unreasonable to weaponize the compiler to make the setup cleaner.<br></p><p>Since we’re already living in a world that includes the possibility of (functionally) nonoverridable members, I would imagine there’s some probative value in assessing the codebases of current libraries. Is anyone aware of a library that uses such a form? I’m skeptical that library authors have demonstrated much interest in this kind of thing, but facts are friendly… <br></p><p>Although loadViewIfNeeded() makes for an elegant code demo, I don’t really accept it as a motivating example for the need to make members non-overridable. I suspect it would be covered pretty well by the existing definition of “final”. There’s also no demonstrable harm to overriding it; the main argument seems to be that newcomers to UIKit might override it out of confusion.<br></p><p>Garth<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/f91846fb/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
