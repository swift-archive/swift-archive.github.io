<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;     On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;     &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;     on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;         &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Matthew Johnson<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Adrian Zubarev<br>&gt;         &lt;swift-evolution at swift.org&gt;<br>&gt;         wrote:<br>&gt;<br>&gt;         Not sure what to think about the enum cases inside a<br>&gt;         protocol (if AnyEnum would<br>&gt;         even exist), it could be a nice addition to the language, but<br>&gt;         this is an own<br>&gt;         proposal I guess.<br>&gt;<br>&gt;         We should start by adding AnyValue protocol to which all value<br>&gt;         types<br>&gt;         conforms.<br>&gt;<br>&gt;         Having a way to constrain conformance to things with value semantics<br>&gt;         is<br>&gt;         something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;         simplistic. It&#39;s possible to build classes whose instances have<br>&gt;         value<br>&gt;         semantics (just make them immutable) and it&#39;s possible to build<br>&gt;         structs<br>&gt;         whose instances have reference semantics (just put the struct&#39;s<br>&gt;         storage<br>&gt;         in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;         do<br>&gt;         copy-on-write). <br>&gt;<br>&gt;         In order for something like AnyValue to have meaning, we need to<br>&gt;         impose<br>&gt;         greater order. After thinking through many approaches over the<br>&gt;         years, I<br>&gt;         have arrived at the (admittedly rather drastic) opinion that the<br>&gt;         language should effectively outlaw the creation of structs and enums<br>&gt;         that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;         that<br>&gt;         immutable classes that want to act as values should be wrapped in a<br>&gt;         struct). The language could then do lots of things much more<br>&gt;         intelligently, such as correctly generating implementations of<br>&gt;         equality.<br>&gt;<br>&gt;         That is a drastic solution indeed! How would this impact things like<br>&gt;         Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;         obviously does not as it contains references which usually be mutated<br>&gt;         underneath us. <br>&gt;<br>&gt;         Value semantics and mutation can only be measured with respect to<br>&gt;         equality. The definition of == for all class types would be equivalent<br>&gt;         to ===. Problem solved.<br>&gt;<br>&gt;         Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;<br>&gt;         Same answer.<br>&gt;<br>&gt;         Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;         enums<br>&gt;         would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;         “feel”<br>&gt;         value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;         associated with value semantics (won’t mutate behind your back, thread<br>&gt;         safe,<br>&gt;         etc).<br>&gt;<br>&gt;         Sure it does.<br>&gt;<br>&gt;         public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;         init(_ x: T) { self.x = x }<br>&gt;         private x: T<br>&gt;         }<br>&gt;<br>&gt;         func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;         return lhs.x === rhs.x<br>&gt;         }<br>&gt;<br>&gt;         I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;         semantics, whether T is mutable or not.<br>&gt;<br>&gt;         Alternately, you can look at the Array implementation. Array is a<br>&gt;         struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;         CoW.<br>&gt;<br>&gt;         This goes back to where you draw the line as to the “boundary of the<br>&gt;         value”.<br>&gt;         Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;         of deep<br>&gt;         value semantics when T is deeply value semantic. <br>&gt;<br>&gt;     No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;     not understanding the boundaries of your value. Or, put more<br>&gt;     solicitously: sure, you can look at the world that way, but it just<br>&gt;     makes everything prohibitively complicated, so why would you want to?<br>&gt;<br>&gt;     In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;     there&#39;s just “copy,” which logically creates an independent version of<br>&gt;     everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;     “deep value semantics” or “shallow value semantics.” <br>&gt;<br>&gt;     Equality defines<br>&gt;     value semantics, and the boundaries of an Array value always includes<br>&gt;     the values of its elements. The *only* problem here is that we have no<br>&gt;     way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;     Equatable. IMO the costs of not having everything be equatable, in<br>&gt;     complexity-of-programming-model terms, are too high.<br>&gt;<br>&gt; Thank you for clarifying the terminology for me. This is helpful. <br>&gt;<br>&gt; I think I may have misunderstood what you meant by “boundary of the value”. Do<br>&gt; you mean that the boundary of an Array value stops at the reference identity for<br>&gt; elements with reference semantics? <br></p><p>Yes.<br></p><p>&gt; If you have an Array whose elements are of an immutable reference type<br>&gt; that has value semantics would you say the boundary extends past the<br>&gt; reference identity of an element and includes a definition of equality<br>&gt; defined by that type?<br></p><p>Yes!<br></p><p>&gt; Are you arguing that reference types should be equatable by default, using<br>&gt; equality of the reference if the type does not provide a custom definition of<br>&gt; equality?<br></p><p>Yes!!<br></p><p>&gt;         Both have their place, but the maximum benefit of value semantics<br>&gt;         (purity) <br>&gt;<br>&gt;     I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;     know of applies to functions and implies no side effects. In that<br>&gt;     world, there is no mutation and value semantics is equivalent to<br>&gt;     reference semantics.<br>&gt;<br>&gt; I was using it in the sense of “PureValue” as discussed in this<br>&gt; thread. <br></p><p>Sorry, this is the first mention I can find in the whole thread, honest.<br>Oh, it was a different thread.  Joe describes it as a protocol for<br>“types that represent fully self-contained values,” which is just fuzzy<br>enough that everyone reading it can have his own interpretation of what<br>it means.<br></p><p>&gt; I was using it to mean values for which no *observable* mutation is<br>&gt; possible (allowing for CoW, etc). Is there a better term for this than<br>&gt; purity?<br></p><p>You&#39;re still not making any sense to me.  A type for which no observable<br>mutation is possible is **immutable**.  The “write” part of<br>copy-on-write is a pretty clear indicator that it&#39;s all about<br>**mutation**.  I don&#39;t see how they&#39;re compatible.<br></p><p>I think perhaps what you mean by “purity” is just, “has value<br>semantics.”  But I could be wrong.<br></p><p>&gt;         is derived from deep value semantics. This is when there is no<br>&gt;         possibility of shared mutable state. This is an extremely important<br>&gt;         property.<br>&gt;<br>&gt;     It&#39;s the wrong property, IMO.<br>&gt;<br>&gt; Wrong in what sense? <br></p><p>Wrong in the sense that it rules out using things like Array that are<br>logically value types but happen to be implemented with CoW, and if you<br>have proper encapsulation there&#39;s no way for these types to behave as<br>anything other than values, so it would be extremely limiting.  <br></p><p>&gt; I don’t mean to imply that it is the *only* valuable<br>&gt; property. However, it I (and many others) do believe it is an extremely valuable<br>&gt; property in many cases. Do you disagree?<br></p><p>I think I do.  What is valuable about such a protocol?  What generic<br>algorithms could you write that work on models of PureValue but don&#39;t<br>work just as well on Array&lt;Int&gt;?<br></p><p>&gt;<br>&gt;         let t = MyClass()<br>&gt;         foo.acceptWrapped(Wrap(t))<br>&gt;         t.mutate()<br>&gt;<br>&gt;         In this example, foo had better not depend on the wrapped instance not<br>&gt;         getting<br>&gt;         mutated.<br>&gt;<br>&gt;     foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;     anything about it.<br>&gt;<br>&gt; Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo passes the<br>&gt; wrapped instance back to code that *does* have visibility to the instance. My<br>&gt; point was that shared mutable state is still possible here. <br></p><p>And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>it construct the T in its init rather than accepting a T parameter) and<br>the fact that it&#39;s *possible* to code something with the structure of<br>Wrap so that it has shared mutable state is irrelevant.<br></p><p>HTH,<br></p><p>&gt;         My expectation is a generic aggregate such as Array would have to<br>&gt;         conditionally conform to AnyValue only when Element also conforms to<br>&gt;         AnyValue.<br>&gt;<br>&gt;         I’m also wondering how such a rule would be implemented while still<br>&gt;         allowing for CoW structs that *do* implement value semantics, but do<br>&gt;         so while using references internally.<br>&gt;<br>&gt;         I am not talking about any kind of statically-enforceable rule, although<br>&gt;         we could probably make warnings sophisticated enough to help with this.<br>&gt;<br>&gt;         You said the you have arrived at the opinion that the language should<br>&gt;         “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;         That<br>&gt;         sounded like static enforcement to me. <br>&gt;<br>&gt;         The language outlaws certain kinds of inout aliasing without<br>&gt;         providing static enforcement. This is like that.<br>&gt;<br>&gt;         I did not know this. Now you have me curious. Can you give an example of<br>&gt;         where<br>&gt;         we are able to violate law? I ask mostly because it sounds like there is<br>&gt;         a<br>&gt;         possibility of stumbling into dangerous territory, possibly without<br>&gt;         being aware<br>&gt;         that you have done so.<br>&gt;<br>&gt;     See “In-out Parameters” in<br>&gt;     https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;<br>&gt;         Maybe you meant we should allow the compiler to assume value semantics<br>&gt;         for structs and enums despite the fact that it doesn’t statically<br>&gt;         enforce this?<br>&gt;<br>&gt;         That would be one *consequence* of effectively outlawing it. The library<br>&gt;         could make similar assumptions.<br>&gt;<br>&gt;         If the compiler can be sophisticated enough to verify value semantics<br>&gt;         statically maybe it would be better to have that mechanism be<br>&gt;         triggered by conformance to AnyValue rather than for all structs and<br>&gt;         enums. Types that conform to AnyValue would receive the benefits of<br>&gt;         the compiler knowing they have value semantics, while other uses of<br>&gt;         structs and enums would remain valid. Best practice would be to<br>&gt;         conform structs and enums to AnyValue whenever possible.<br>&gt;<br>&gt;         Another possible advantage of this approach would be allowing<br>&gt;         immutable reference types to conform to AnyValue and receive the<br>&gt;         associated benefits such as the generated implementation of equality,<br>&gt;         etc.<br>&gt;<br>&gt;         -Matthew<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;    &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;        this is an own<br>&gt;&gt;        proposal I guess.<br>&gt;&gt; <br>&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;        types<br>&gt;&gt;        conforms.<br>&gt;&gt; <br>&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;        is<br>&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;        value<br>&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;        structs<br>&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;        storage<br>&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;        do<br>&gt;&gt;        copy-on-write). <br>&gt;&gt; <br>&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;        impose<br>&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;        years, I<br>&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;        that<br>&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;        equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;        to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;        Same answer.<br>&gt;&gt; <br>&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;        enums<br>&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;        “feel”<br>&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;        safe,<br>&gt;&gt;        etc).<br>&gt;&gt; <br>&gt;&gt;        Sure it does.<br>&gt;&gt; <br>&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;        private x: T<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt; <br>&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;        CoW.<br>&gt;&gt; <br>&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;        value”.<br>&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;        of deep<br>&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt; <br>&gt;&gt;    No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;    not understanding the boundaries of your value. Or, put more<br>&gt;&gt;    solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;    makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt; <br>&gt;&gt;    In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;    there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;    everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;    “deep value semantics” or “shallow value semantics.” <br>&gt;&gt; <br>&gt;&gt;    Equality defines<br>&gt;&gt;    value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;    the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;    way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;    Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;    complexity-of-programming-model terms, are too high.<br>&gt;&gt; <br>&gt;&gt; Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt; <br>&gt;&gt; I think I may have misunderstood what you meant by “boundary of the value”. Do<br>&gt;&gt; you mean that the boundary of an Array value stops at the reference identity for<br>&gt;&gt; elements with reference semantics? <br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; If you have an Array whose elements are of an immutable reference type<br>&gt;&gt; that has value semantics would you say the boundary extends past the<br>&gt;&gt; reference identity of an element and includes a definition of equality<br>&gt;&gt; defined by that type?<br>&gt; <br>&gt; Yes!<br>&gt; <br>&gt;&gt; Are you arguing that reference types should be equatable by default, using<br>&gt;&gt; equality of the reference if the type does not provide a custom definition of<br>&gt;&gt; equality?<br>&gt; <br>&gt; Yes!!<br>&gt; <br>&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;        (purity) <br>&gt;&gt; <br>&gt;&gt;    I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;    know of applies to functions and implies no side effects. In that<br>&gt;&gt;    world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;    reference semantics.<br>&gt;&gt; <br>&gt;&gt; I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt; thread. <br>&gt; <br>&gt; Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt; Oh, it was a different thread.  Joe describes it as a protocol for<br>&gt; “types that represent fully self-contained values,” which is just fuzzy<br>&gt; enough that everyone reading it can have his own interpretation of what<br>&gt; it means.<br>&gt; <br>&gt;&gt; I was using it to mean values for which no *observable* mutation is<br>&gt;&gt; possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt; purity?<br>&gt; <br>&gt; You&#39;re still not making any sense to me.  A type for which no observable<br>&gt; mutation is possible is **immutable**.  The “write” part of<br>&gt; copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt; **mutation**.  I don&#39;t see how they&#39;re compatible.<br></p><p>Sorry, I did not write that very clearly.  I should have said no observable mutation *that happens behind your back*.  In other words, the only *observable* mutation possible is local.  Immutability accomplishes this by simply prohibiting all mutation.  Primitive value types like Int and structs or enums that only contain primitive value types accomplish this by getting copied everywhere.  <br></p><p>Swift’s collections also accomplish this through copying, but only when the elements they contain also have the same property.  On the other hand, it is immediately obvious that non-local mutation is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless they are all uniquely referenced.<br></p><p>&gt; <br>&gt; I think perhaps what you mean by “purity” is just, “has value<br>&gt; semantics.”  But I could be wrong.<br></p><p>No, an array storing instances of reference types that are not immutable would not be “pure” (or whatever you want to call it).<br></p><p>&gt; <br>&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;        property.<br>&gt;&gt; <br>&gt;&gt;    It&#39;s the wrong property, IMO.<br>&gt;&gt; <br>&gt;&gt; Wrong in what sense? <br>&gt; <br>&gt; Wrong in the sense that it rules out using things like Array that are<br>&gt; logically value types but happen to be implemented with CoW, and if you<br>&gt; have proper encapsulation there&#39;s no way for these types to behave as<br>&gt; anything other than values, so it would be extremely limiting.  <br></p><p>I’m a big fan of CoW as an implementation detail.  We have definitely been miscommunicating if you thought I was suggesting something that would prohibit CoW.<br></p><p>&gt; <br>&gt;&gt; I don’t mean to imply that it is the *only* valuable<br>&gt;&gt; property. However, it I (and many others) do believe it is an extremely valuable<br>&gt;&gt; property in many cases. Do you disagree?<br>&gt; <br>&gt; I think I do.  What is valuable about such a protocol?  What generic<br>&gt; algorithms could you write that work on models of PureValue but don&#39;t<br>&gt; work just as well on Array&lt;Int&gt;?<br></p><p>Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be any.  Array&lt;AnyObject&gt; is a completely different story.  With Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained in the array will not be mutated by code elsewhere that also happens to have a reference to the same objects.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;        let t = MyClass()<br>&gt;&gt;        foo.acceptWrapped(Wrap(t))<br>&gt;&gt;        t.mutate()<br>&gt;&gt; <br>&gt;&gt;        In this example, foo had better not depend on the wrapped instance not<br>&gt;&gt;        getting<br>&gt;&gt;        mutated.<br>&gt;&gt; <br>&gt;&gt;    foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;    anything about it.<br>&gt;&gt; <br>&gt;&gt; Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo passes the<br>&gt;&gt; wrapped instance back to code that *does* have visibility to the instance. My<br>&gt;&gt; point was that shared mutable state is still possible here. <br>&gt; <br>&gt; And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt; it construct the T in its init rather than accepting a T parameter) and<br>&gt; the fact that it&#39;s *possible* to code something with the structure of<br>&gt; Wrap so that it has shared mutable state is irrelevant.<br></p><p>The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend on the semantic properties of T (whether or not non-local mutation may be observed in this case).  It certainly isn’t irrelevant to that point.<br></p><p>&gt; <br>&gt; HTH,<br>&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;        That<br>&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt; <br>&gt;&gt;        The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;        providing static enforcement. This is like that.<br>&gt;&gt; <br>&gt;&gt;        I did not know this. Now you have me curious. Can you give an example of<br>&gt;&gt;        where<br>&gt;&gt;        we are able to violate law? I ask mostly because it sounds like there is<br>&gt;&gt;        a<br>&gt;&gt;        possibility of stumbling into dangerous territory, possibly without<br>&gt;&gt;        being aware<br>&gt;&gt;        that you have done so.<br>&gt;&gt; <br>&gt;&gt;    See “In-out Parameters” in<br>&gt;&gt;    https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;&gt; <br>&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;        enforce this?<br>&gt;&gt; <br>&gt;&gt;        That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;        could make similar assumptions.<br>&gt;&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/9912c502/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;         &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;         on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;         &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Matthew Johnson<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Adrian Zubarev<br>&gt;         &lt;swift-evolution at swift.org&gt;<br>&gt;         wrote:<br>&gt;<br>&gt;         Not sure what to think about the enum cases inside a<br>&gt;         protocol (if AnyEnum would<br>&gt;         even exist), it could be a nice addition to the language, but<br>&gt;         this is an own<br>&gt;         proposal I guess.<br>&gt;<br>&gt;         We should start by adding AnyValue protocol to which all value<br>&gt;         types<br>&gt;         conforms.<br>&gt;<br>&gt;         Having a way to constrain conformance to things with value semantics<br>&gt;         is<br>&gt;         something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;         simplistic. It&#39;s possible to build classes whose instances have<br>&gt;         value<br>&gt;         semantics (just make them immutable) and it&#39;s possible to build<br>&gt;         structs<br>&gt;         whose instances have reference semantics (just put the struct&#39;s<br>&gt;         storage<br>&gt;         in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;         do<br>&gt;         copy-on-write). <br>&gt;<br>&gt;         In order for something like AnyValue to have meaning, we need to<br>&gt;         impose<br>&gt;         greater order. After thinking through many approaches over the<br>&gt;         years, I<br>&gt;         have arrived at the (admittedly rather drastic) opinion that the<br>&gt;         language should effectively outlaw the creation of structs and enums<br>&gt;         that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;         that<br>&gt;         immutable classes that want to act as values should be wrapped in a<br>&gt;         struct). The language could then do lots of things much more<br>&gt;         intelligently, such as correctly generating implementations of<br>&gt;         equality.<br>&gt;<br>&gt;         That is a drastic solution indeed! How would this impact things like<br>&gt;         Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;         obviously does not as it contains references which usually be mutated<br>&gt;         underneath us. <br>&gt;<br>&gt;         Value semantics and mutation can only be measured with respect to<br>&gt;         equality. The definition of == for all class types would be equivalent<br>&gt;         to ===. Problem solved.<br>&gt;<br>&gt;         Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;<br>&gt;         Same answer.<br>&gt;<br>&gt;         Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;         enums<br>&gt;         would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;         “feel”<br>&gt;         value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;         associated with value semantics (won’t mutate behind your back, thread<br>&gt;         safe,<br>&gt;         etc).<br>&gt;<br>&gt;         Sure it does.<br>&gt;<br>&gt;         public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;         init(_ x: T) { self.x = x }<br>&gt;         private x: T<br>&gt;         }<br>&gt;<br>&gt;         func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;         return lhs.x === rhs.x<br>&gt;         }<br>&gt;<br>&gt;         I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;         semantics, whether T is mutable or not.<br>&gt;<br>&gt;         Alternately, you can look at the Array implementation. Array is a<br>&gt;         struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;         CoW.<br>&gt;<br>&gt;         This goes back to where you draw the line as to the “boundary of the<br>&gt;         value”.<br>&gt;         Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;         of deep<br>&gt;         value semantics when T is deeply value semantic. <br>&gt;<br>&gt;         No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;         not understanding the boundaries of your value. Or, put more<br>&gt;         solicitously: sure, you can look at the world that way, but it just<br>&gt;         makes everything prohibitively complicated, so why would you want to?<br>&gt;<br>&gt;         In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;         there&#39;s just “copy,” which logically creates an independent version of<br>&gt;         everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;         “deep value semantics” or “shallow value semantics.” <br>&gt;<br>&gt;         Equality defines<br>&gt;         value semantics, and the boundaries of an Array value always includes<br>&gt;         the values of its elements. The *only* problem here is that we have no<br>&gt;         way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;         Equatable. IMO the costs of not having everything be equatable, in<br>&gt;         complexity-of-programming-model terms, are too high.<br>&gt;<br>&gt;         Thank you for clarifying the terminology for me. This is helpful. <br>&gt;<br>&gt;         I think I may have misunderstood what you meant by “boundary of the<br>&gt;         value”. Do<br>&gt;         you mean that the boundary of an Array value stops at the reference<br>&gt;         identity for<br>&gt;         elements with reference semantics? <br>&gt;<br>&gt;     Yes.<br>&gt;<br>&gt;         If you have an Array whose elements are of an immutable reference type<br>&gt;         that has value semantics would you say the boundary extends past the<br>&gt;         reference identity of an element and includes a definition of equality<br>&gt;         defined by that type?<br>&gt;<br>&gt;     Yes!<br>&gt;<br>&gt;         Are you arguing that reference types should be equatable by default,<br>&gt;         using<br>&gt;         equality of the reference if the type does not provide a custom<br>&gt;         definition of<br>&gt;         equality?<br>&gt;<br>&gt;     Yes!!<br>&gt;<br>&gt;         Both have their place, but the maximum benefit of value semantics<br>&gt;         (purity) <br>&gt;<br>&gt;         I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;         know of applies to functions and implies no side effects. In that<br>&gt;         world, there is no mutation and value semantics is equivalent to<br>&gt;         reference semantics.<br>&gt;<br>&gt;         I was using it in the sense of “PureValue” as discussed in this<br>&gt;         thread. <br>&gt;<br>&gt;     Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;     Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;     “types that represent fully self-contained values,” which is just fuzzy<br>&gt;     enough that everyone reading it can have his own interpretation of what<br>&gt;     it means.<br>&gt;<br>&gt;         I was using it to mean values for which no *observable* mutation is<br>&gt;         possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;         purity?<br>&gt;<br>&gt;     You&#39;re still not making any sense to me. A type for which no observable<br>&gt;     mutation is possible is **immutable**. The “write” part of<br>&gt;     copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;     **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;<br>&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt; mutation possible is local. <br></p><p>Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>mutation in the value instance.  Then you need to ask, “how do you<br>determine whether there was mutation?”  <br></p><p>&gt; Immutability accomplishes this by simply prohibiting all<br>&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt; only contain primitive value types accomplish this by getting copied<br>&gt; everywhere.<br>&gt;<br>&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt; elements they contain also have the same property. <br></p><p>Only if you think mutable class instances are part of the value of the<br>array that stores references to those class instances.  As I said<br>earlier, you can *take* that point of view, but why would you want to?<br>Today, we have left that question wide open, which makes the whole<br>notion of what is a logical value very indistinct.  I am proposing to<br>close it.<br></p><p>&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt; they are all uniquely referenced.<br></p><p>If you interpret the elements of the array as being *references* to<br>objects, there is no possibility of non-local mutation.  If you<br>interpret the elements as being objects *themselves*, then you&#39;ve got<br>problems.<br></p><p>&gt;     I think perhaps what you mean by “purity” is just, “has value<br>&gt;     semantics.” But I could be wrong.<br>&gt;<br>&gt; No, an array storing instances of reference types that are not immutable would<br>&gt; not be “pure” (or whatever you want to call it).<br>&gt;<br>&gt;         is derived from deep value semantics. This is when there is no<br>&gt;         possibility of shared mutable state. This is an extremely important<br>&gt;         property.<br>&gt;<br>&gt;         It&#39;s the wrong property, IMO.<br>&gt;<br>&gt;         Wrong in what sense? <br>&gt;<br>&gt;     Wrong in the sense that it rules out using things like Array that are<br>&gt;     logically value types but happen to be implemented with CoW, and if you<br>&gt;     have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;     anything other than values, so it would be extremely limiting. <br>&gt;<br>&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt; CoW.<br></p><p>Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br></p><p>&gt;         I don’t mean to imply that it is the *only* valuable<br>&gt;         property. However, it I (and many others) do believe it is an extremely<br>&gt;         valuable<br>&gt;         property in many cases. Do you disagree?<br>&gt;<br>&gt;     I think I do. What is valuable about such a protocol? What generic<br>&gt;     algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;     work just as well on Array&lt;Int&gt;?<br>&gt;<br>&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt; to have a reference to the same objects.<br></p><p>Okay then, what algorithms can you write that operate on PureValue that<br>don&#39;t work equally well on Array&lt;AnyObject&gt;?<br></p><p>&gt;<br>&gt;         let t = MyClass()<br>&gt;         foo.acceptWrapped(Wrap(t))<br>&gt;         t.mutate()<br>&gt;<br>&gt;         In this example, foo had better not depend on the wrapped instance not<br>&gt;         getting<br>&gt;         mutated.<br>&gt;<br>&gt;         foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;         anything about it.<br>&gt;<br>&gt;         Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo<br>&gt;         passes the<br>&gt;         wrapped instance back to code that *does* have visibility to the<br>&gt;         instance. My<br>&gt;         point was that shared mutable state is still possible here. <br>&gt;<br>&gt;     And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt;     it construct the T in its init rather than accepting a T parameter) and<br>&gt;     the fact that it&#39;s *possible* to code something with the structure of<br>&gt;     Wrap so that it has shared mutable state is irrelevant.<br>&gt;<br>&gt; The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend<br>&gt; on the semantic properties of T (whether or not non-local mutation may be<br>&gt; observed in this case). <br></p><p>No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>semantic properties of T.  This was in answer to what you said:<br></p><p>&gt;        A struct wrapping a mutable reference type certainly doesn’t<br>&gt;        “feel” value semantic to me and certainly doesn’t have the<br>&gt;        guarantees usually associated with value semantics (won’t<br>&gt;        mutate behind your back, thread safe, etc).<br></p><p>I have been trying to get you to nail down what you mean by PureValue,<br>and I was trying to illustrate that merely being “a struct wrapping a<br>mutable reference type” is not enough to disqualify anything from being<br>in the category you&#39;re trying to describe.  What are the properties of<br>types in that category, and what generic code would depend on those<br>properties?<br></p><p>&gt; It certainly isn’t irrelevant to that point.<br>&gt;<br>&gt;     HTH,<br>&gt;<br>&gt;         My expectation is a generic aggregate such as Array would have to<br>&gt;         conditionally conform to AnyValue only when Element also conforms to<br>&gt;         AnyValue.<br>&gt;<br>&gt;         I’m also wondering how such a rule would be implemented while still<br>&gt;         allowing for CoW structs that *do* implement value semantics, but do<br>&gt;         so while using references internally.<br>&gt;<br>&gt;         I am not talking about any kind of statically-enforceable rule, although<br>&gt;         we could probably make warnings sophisticated enough to help with this.<br>&gt;<br>&gt;         You said the you have arrived at the opinion that the language should<br>&gt;         “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;         That<br>&gt;         sounded like static enforcement to me. <br>&gt;<br>&gt;         The language outlaws certain kinds of inout aliasing without<br>&gt;         providing static enforcement. This is like that.<br>&gt;<br>&gt;         I did not know this. Now you have me curious. Can you give an example of<br>&gt;         where<br>&gt;         we are able to violate law? I ask mostly because it sounds like there is<br>&gt;         a<br>&gt;         possibility of stumbling into dangerous territory, possibly without<br>&gt;         being aware<br>&gt;         that you have done so.<br>&gt;<br>&gt;         See “In-out Parameters” in<br>&gt;         https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;<br>&gt;         Maybe you meant we should allow the compiler to assume value semantics<br>&gt;         for structs and enums despite the fact that it doesn’t statically<br>&gt;         enforce this?<br>&gt;<br>&gt;         That would be one *consequence* of effectively outlawing it. The library<br>&gt;         could make similar assumptions.<br>&gt;<br>&gt;         If the compiler can be sophisticated enough to verify value semantics<br>&gt;         statically maybe it would be better to have that mechanism be<br>&gt;         triggered by conformance to AnyValue rather than for all structs and<br>&gt;         enums. Types that conform to AnyValue would receive the benefits of<br>&gt;         the compiler knowing they have value semantics, while other uses of<br>&gt;         structs and enums would remain valid. Best practice would be to<br>&gt;         conform structs and enums to AnyValue whenever possible.<br>&gt;<br>&gt;         Another possible advantage of this approach would be allowing<br>&gt;         immutable reference types to conform to AnyValue and receive the<br>&gt;         associated benefits such as the generated implementation of equality,<br>&gt;         etc.<br>&gt;<br>&gt;         -Matthew<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;        this is an own<br>&gt;&gt;        proposal I guess.<br>&gt;&gt; <br>&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;        types<br>&gt;&gt;        conforms.<br>&gt;&gt; <br>&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;        is<br>&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;        value<br>&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;        structs<br>&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;        storage<br>&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;        do<br>&gt;&gt;        copy-on-write). <br>&gt;&gt; <br>&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;        impose<br>&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;        years, I<br>&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;        that<br>&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;        equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;        to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;        Same answer.<br>&gt;&gt; <br>&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;        enums<br>&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;        “feel”<br>&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;        safe,<br>&gt;&gt;        etc).<br>&gt;&gt; <br>&gt;&gt;        Sure it does.<br>&gt;&gt; <br>&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;        private x: T<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt; <br>&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;        CoW.<br>&gt;&gt; <br>&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;        value”.<br>&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;        of deep<br>&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt; <br>&gt;&gt;        No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;        not understanding the boundaries of your value. Or, put more<br>&gt;&gt;        solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;        makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt; <br>&gt;&gt;        In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;        there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;        everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;        “deep value semantics” or “shallow value semantics.” <br>&gt;&gt; <br>&gt;&gt;        Equality defines<br>&gt;&gt;        value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;        the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;        way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;        Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;        complexity-of-programming-model terms, are too high.<br>&gt;&gt; <br>&gt;&gt;        Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt; <br>&gt;&gt;        I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;        value”. Do<br>&gt;&gt;        you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;        identity for<br>&gt;&gt;        elements with reference semantics? <br>&gt;&gt; <br>&gt;&gt;    Yes.<br>&gt;&gt; <br>&gt;&gt;        If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;        that has value semantics would you say the boundary extends past the<br>&gt;&gt;        reference identity of an element and includes a definition of equality<br>&gt;&gt;        defined by that type?<br>&gt;&gt; <br>&gt;&gt;    Yes!<br>&gt;&gt; <br>&gt;&gt;        Are you arguing that reference types should be equatable by default,<br>&gt;&gt;        using<br>&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;        definition of<br>&gt;&gt;        equality?<br>&gt;&gt; <br>&gt;&gt;    Yes!!<br>&gt;&gt; <br>&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;        (purity) <br>&gt;&gt; <br>&gt;&gt;        I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;        know of applies to functions and implies no side effects. In that<br>&gt;&gt;        world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;        reference semantics.<br>&gt;&gt; <br>&gt;&gt;        I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;        thread. <br>&gt;&gt; <br>&gt;&gt;    Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;    Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;    “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;    enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;    it means.<br>&gt;&gt; <br>&gt;&gt;        I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;        possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;        purity?<br>&gt;&gt; <br>&gt;&gt;    You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;    mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;    copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;    **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt; <br>&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt; mutation possible is local. <br>&gt; <br>&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt; determine whether there was mutation?”  <br>&gt; <br>&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt; everywhere.<br>&gt;&gt; <br>&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt; elements they contain also have the same property. <br>&gt; <br>&gt; Only if you think mutable class instances are part of the value of the<br>&gt; array that stores references to those class instances.  As I said<br>&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt; Today, we have left that question wide open, which makes the whole<br>&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt; close it.<br>&gt; <br>&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt; they are all uniquely referenced.<br>&gt; <br>&gt; If you interpret the elements of the array as being *references* to<br>&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt; problems.<br>&gt; <br></p><p>This does not make sense, because you’ve got problems either way. You are arguing, essentially, that everything is a value type because references/pointers are a value. If that were the case then the *only* valid way to compare the equality of types would be to compare their values. Overriding the equality operator would inherently violate the property of immutability, i.e. two immutable objects can change their equality even without mutation of their “values&quot;.<br></p><p>func ==(lhs, rhs) {<br>	...<br>}<br></p><p>class MyClass {<br>    var a: Int<br>    <br>    ...<br></p><p>} <br></p><p>let x = MyClass(a: 5)<br>let y = MyClass(a: 5)<br></p><p>x == y // true<br>y.a = 6<br>x == y // false<br></p><p>&gt;  Are you arguing that reference types should be equatable by default,<br>&gt;        using<br>&gt;        equality of the reference if the type does not provide a custom<br>&gt;        definition of<br>&gt;        equality?<br>&gt; <br>&gt;    Yes!!<br></p><p><br>Custom definitions of equality, inherently, decouple immutability from equality, as shown above. Swift makes it appear as though references and values are on the same level in a way that C does not.<br></p><p>let x = MyStruct()<br>let y = MyClass()<br></p><p>x.myFoo<br>y.myFoo<br></p><p>vs<br></p><p>my_struct *x = …<br>my_struct y = …<br></p><p>x.my_foo<br>y-&gt;my_foo<br></p><p>With C it is explicit that you are crossing a reference. Thus there is only *one* type of equality in C, that the values *are equal*. This exactly the type of equality you are referring to, but this does not carry over to Swift for precisely the reason that Swift paves over the difference between value and reference types, and then allows you to redefine equality.<br></p><p>Therefore, in essentially no circumstances does it make sense to compare a type by its reference if it has any associated data in Swift. Basically, if it will be commonplace to override the equality operator to compare the first level of associated values of a reference type, then the comparison of just the reference has no business being the default.<br></p><p>If the default equality for reference types was defined as the equality of the references it would be inconsistent with the Swift’s current apparent surfacing of the first level of associated data for reference types.<br></p><p>&gt;&gt;    I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;    semantics.” But I could be wrong.<br>&gt;&gt; <br>&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt; <br>&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;        property.<br>&gt;&gt; <br>&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt; <br>&gt;&gt;        Wrong in what sense? <br>&gt;&gt; <br>&gt;&gt;    Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;    logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;    have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;    anything other than values, so it would be extremely limiting. <br>&gt;&gt; <br>&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt; CoW.<br>&gt; <br>&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br></p><p>I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references form a subgraph, within which a change to any of the values would constitute a change in the value of A (thus impermissible if A is immutable). Thus structs would quality as “PureValues”.<br></p><p>I also assume that enforcing immutability on an object graph, via CoW or otherwise, would be unfeasible. You could enforce it on all values accessible by traversing a single reference for reference types, however.<br></p><p>This is why I don’t really buy the argument that there is no such this as deep vs shallow copy. Deep copy means copying the whole “PureValue” or subgraph, shallow copy means traversing a single reference and copying all accessible values.<br> <br>&gt; <br>&gt;&gt;        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;        property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;        valuable<br>&gt;&gt;        property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;    I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;    algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;    work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt; to have a reference to the same objects.<br>&gt; <br>&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;        let t = MyClass()<br>&gt;&gt;        foo.acceptWrapped(Wrap(t))<br>&gt;&gt;        t.mutate()<br>&gt;&gt; <br>&gt;&gt;        In this example, foo had better not depend on the wrapped instance not<br>&gt;&gt;        getting<br>&gt;&gt;        mutated.<br>&gt;&gt; <br>&gt;&gt;        foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;        anything about it.<br>&gt;&gt; <br>&gt;&gt;        Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo<br>&gt;&gt;        passes the<br>&gt;&gt;        wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;        instance. My<br>&gt;&gt;        point was that shared mutable state is still possible here. <br>&gt;&gt; <br>&gt;&gt;    And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt;&gt;    it construct the T in its init rather than accepting a T parameter) and<br>&gt;&gt;    the fact that it&#39;s *possible* to code something with the structure of<br>&gt;&gt;    Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt; <br>&gt;&gt; The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend<br>&gt;&gt; on the semantic properties of T (whether or not non-local mutation may be<br>&gt;&gt; observed in this case). <br>&gt; <br>&gt; No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt; semantic properties of T.  This was in answer to what you said:<br>&gt; <br>&gt;&gt;       A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;       “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;       guarantees usually associated with value semantics (won’t<br>&gt;&gt;       mutate behind your back, thread safe, etc).<br>&gt; <br>&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt; types in that category, and what generic code would depend on those<br>&gt; properties?<br>&gt; <br>&gt;&gt; It certainly isn’t irrelevant to that point.<br>&gt;&gt; <br>&gt;&gt;    HTH,<br>&gt;&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;        That<br>&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt; <br>&gt;&gt;        The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;        providing static enforcement. This is like that.<br>&gt;&gt; <br>&gt;&gt;        I did not know this. Now you have me curious. Can you give an example of<br>&gt;&gt;        where<br>&gt;&gt;        we are able to violate law? I ask mostly because it sounds like there is<br>&gt;&gt;        a<br>&gt;&gt;        possibility of stumbling into dangerous territory, possibly without<br>&gt;&gt;        being aware<br>&gt;&gt;        that you have done so.<br>&gt;&gt; <br>&gt;&gt;        See “In-out Parameters” in<br>&gt;&gt;        https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;&gt; <br>&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;        enforce this?<br>&gt;&gt; <br>&gt;&gt;        That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;        could make similar assumptions.<br>&gt;&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/af5d2d7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 9:19 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;    On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;        wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;&gt;        this is an own<br>&gt;&gt;&gt;        proposal I guess.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;&gt;        types<br>&gt;&gt;&gt;        conforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;&gt;        is<br>&gt;&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;&gt;        value<br>&gt;&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;&gt;        structs<br>&gt;&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;&gt;        storage<br>&gt;&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;&gt;        do<br>&gt;&gt;&gt;        copy-on-write). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;&gt;        impose<br>&gt;&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;&gt;        years, I<br>&gt;&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;&gt;        that<br>&gt;&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt;        equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;&gt;        underneath us. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;&gt;        to ===. Problem solved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Same answer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;&gt;        enums<br>&gt;&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;        “feel”<br>&gt;&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;&gt;        safe,<br>&gt;&gt;&gt;        etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Sure it does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;&gt;        private x: T<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;&gt;        CoW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;&gt;        value”.<br>&gt;&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;&gt;        of deep<br>&gt;&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;&gt;        not understanding the boundaries of your value. Or, put more<br>&gt;&gt;&gt;        solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;&gt;        makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;&gt;        there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;&gt;        everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;&gt;        “deep value semantics” or “shallow value semantics.” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Equality defines<br>&gt;&gt;&gt;        value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;&gt;        the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;&gt;        way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;&gt;        Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;&gt;        complexity-of-programming-model terms, are too high.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;&gt;        value”. Do<br>&gt;&gt;&gt;        you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;&gt;        identity for<br>&gt;&gt;&gt;        elements with reference semantics? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;&gt;        that has value semantics would you say the boundary extends past the<br>&gt;&gt;&gt;        reference identity of an element and includes a definition of equality<br>&gt;&gt;&gt;        defined by that type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;        using<br>&gt;&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;        definition of<br>&gt;&gt;&gt;        equality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;&gt;        (purity) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;&gt;        know of applies to functions and implies no side effects. In that<br>&gt;&gt;&gt;        world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;&gt;        reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;&gt;        thread. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;&gt;    Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;&gt;    “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;&gt;    enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;&gt;    it means.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;&gt;        possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;&gt;        purity?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;&gt;    mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;&gt;    copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;&gt;    **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt;&gt; mutation possible is local. <br>&gt;&gt; <br>&gt;&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt;&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt;&gt; determine whether there was mutation?”  <br>&gt;&gt; <br>&gt;&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt;&gt; everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt;&gt; elements they contain also have the same property. <br>&gt;&gt; <br>&gt;&gt; Only if you think mutable class instances are part of the value of the<br>&gt;&gt; array that stores references to those class instances.  As I said<br>&gt;&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt; Today, we have left that question wide open, which makes the whole<br>&gt;&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt;&gt; close it.<br>&gt;&gt; <br>&gt;&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt; they are all uniquely referenced.<br>&gt;&gt; <br>&gt;&gt; If you interpret the elements of the array as being *references* to<br>&gt;&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt;&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt; problems.<br>&gt;&gt; <br>&gt; <br>&gt; This does not make sense, because you’ve got problems either way. You are arguing, essentially, that everything is a value type because references/pointers are a value. If that were the case then the *only* valid way to compare the equality of types would be to compare their values. Overriding the equality operator would inherently violate the property of immutability, i.e. two immutable objects can change their equality even without mutation of their “values&quot;.<br>&gt; <br>&gt; func ==(lhs, rhs) {<br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; class MyClass {<br>&gt;     var a: Int<br>&gt;     <br>&gt;     ...<br>&gt; <br>&gt; } <br>&gt; <br>&gt; let x = MyClass(a: 5)<br>&gt; let y = MyClass(a: 5)<br>&gt; <br>&gt; x == y // true<br>&gt; y.a = 6<br>&gt; x == y // false<br>&gt; <br>&gt;&gt;  Are you arguing that reference types should be equatable by default,<br>&gt;&gt;        using<br>&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;        definition of<br>&gt;&gt;        equality?<br>&gt;&gt; <br>&gt;&gt;    Yes!!<br>&gt; <br>&gt; <br>&gt; Custom definitions of equality, inherently, decouple immutability from equality, as shown above. Swift makes it appear as though references and values are on the same level in a way that C does not.<br>&gt; <br>&gt; let x = MyStruct()<br>&gt; let y = MyClass()<br>&gt; <br>&gt; x.myFoo<br>&gt; y.myFoo<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; my_struct *x = …<br>&gt; my_struct y = …<br>&gt; <br>&gt; x.my_foo<br>&gt; y-&gt;my_foo<br>&gt; <br>&gt; With C it is explicit that you are crossing a reference. Thus there is only *one* type of equality in C, that the values *are equal*. This exactly the type of equality you are referring to, but this does not carry over to Swift for precisely the reason that Swift paves over the difference between value and reference types, and then allows you to redefine equality.<br>&gt; <br>&gt; Therefore, in essentially no circumstances does it make sense to compare a type by its reference if it has any associated data in Swift. Basically, if it will be commonplace to override the equality operator to compare the first level of associated values of a reference type, then the comparison of just the reference has no business being the default.<br>&gt; <br>&gt; If the default equality for reference types was defined as the equality of the references it would be inconsistent with the Swift’s current apparent surfacing of the first level of associated data for reference types.<br>&gt; <br>&gt;&gt;&gt;    I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;&gt;    semantics.” But I could be wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;&gt;        property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Wrong in what sense? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;&gt;    logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;&gt;    have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;&gt;    anything other than values, so it would be extremely limiting. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt;&gt; CoW.<br>&gt;&gt; <br>&gt;&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br>&gt; <br>&gt; I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references form a subgraph, within which a change to any of the values would constitute a change in the value of A (thus impermissible if A is immutable). Thus structs would quality as “PureValues”.<br>&gt; <br></p><p>Thus structs *without references would qualify.<br></p><p>&gt; I also assume that enforcing immutability on an object graph, via CoW or otherwise, would be unfeasible. You could enforce it on all values accessible by traversing a single reference for reference types, however.<br>&gt; <br>&gt; This is why I don’t really buy the argument that there is no such this as deep vs shallow copy. Deep copy means copying the whole “PureValue” or subgraph, shallow copy means traversing a single reference and copying all accessible values.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt;        property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;&gt;        valuable<br>&gt;&gt;&gt;        property in many cases. Do you disagree?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;&gt;    algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;&gt;    work just as well on Array&lt;Int&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;&gt; to have a reference to the same objects.<br>&gt;&gt; <br>&gt;&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        let t = MyClass()<br>&gt;&gt;&gt;        foo.acceptWrapped(Wrap(t))<br>&gt;&gt;&gt;        t.mutate()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In this example, foo had better not depend on the wrapped instance not<br>&gt;&gt;&gt;        getting<br>&gt;&gt;&gt;        mutated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;&gt;        anything about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo<br>&gt;&gt;&gt;        passes the<br>&gt;&gt;&gt;        wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;&gt;        instance. My<br>&gt;&gt;&gt;        point was that shared mutable state is still possible here. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt;&gt;&gt;    it construct the T in its init rather than accepting a T parameter) and<br>&gt;&gt;&gt;    the fact that it&#39;s *possible* to code something with the structure of<br>&gt;&gt;&gt;    Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend<br>&gt;&gt;&gt; on the semantic properties of T (whether or not non-local mutation may be<br>&gt;&gt;&gt; observed in this case). <br>&gt;&gt; <br>&gt;&gt; No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt; semantic properties of T.  This was in answer to what you said:<br>&gt;&gt; <br>&gt;&gt;&gt;       A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;       “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;&gt;       guarantees usually associated with value semantics (won’t<br>&gt;&gt;&gt;       mutate behind your back, thread safe, etc).<br>&gt;&gt; <br>&gt;&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt;&gt; types in that category, and what generic code would depend on those<br>&gt;&gt; properties?<br>&gt;&gt; <br>&gt;&gt;&gt; It certainly isn’t irrelevant to that point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    HTH,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;&gt;        AnyValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;&gt;        so while using references internally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;&gt;        That<br>&gt;&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;&gt;        providing static enforcement. This is like that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I did not know this. Now you have me curious. Can you give an example of<br>&gt;&gt;&gt;        where<br>&gt;&gt;&gt;        we are able to violate law? I ask mostly because it sounds like there is<br>&gt;&gt;&gt;        a<br>&gt;&gt;&gt;        possibility of stumbling into dangerous territory, possibly without<br>&gt;&gt;&gt;        being aware<br>&gt;&gt;&gt;        that you have done so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        See “In-out Parameters” in<br>&gt;&gt;&gt;        https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;&gt;        enforce this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;&gt;        could make similar assumptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;&gt;        etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    -- <br>&gt;&gt;&gt;    Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/3f9a4140/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 6, 2016, at 11:19 PM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;    On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;&gt;        this is an own<br>&gt;&gt;&gt;        proposal I guess.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;&gt;        types<br>&gt;&gt;&gt;        conforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;&gt;        is<br>&gt;&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;&gt;        value<br>&gt;&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;&gt;        structs<br>&gt;&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;&gt;        storage<br>&gt;&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;&gt;        do<br>&gt;&gt;&gt;        copy-on-write). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;&gt;        impose<br>&gt;&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;&gt;        years, I<br>&gt;&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;&gt;        that<br>&gt;&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt;        equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;&gt;        underneath us. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;&gt;        to ===. Problem solved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Same answer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;&gt;        enums<br>&gt;&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;        “feel”<br>&gt;&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;&gt;        safe,<br>&gt;&gt;&gt;        etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Sure it does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;&gt;        private x: T<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;&gt;        CoW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;&gt;        value”.<br>&gt;&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;&gt;        of deep<br>&gt;&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;&gt;        not understanding the boundaries of your value. Or, put more<br>&gt;&gt;&gt;        solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;&gt;        makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;&gt;        there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;&gt;        everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;&gt;        “deep value semantics” or “shallow value semantics.” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Equality defines<br>&gt;&gt;&gt;        value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;&gt;        the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;&gt;        way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;&gt;        Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;&gt;        complexity-of-programming-model terms, are too high.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;&gt;        value”. Do<br>&gt;&gt;&gt;        you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;&gt;        identity for<br>&gt;&gt;&gt;        elements with reference semantics? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;&gt;        that has value semantics would you say the boundary extends past the<br>&gt;&gt;&gt;        reference identity of an element and includes a definition of equality<br>&gt;&gt;&gt;        defined by that type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;        using<br>&gt;&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;        definition of<br>&gt;&gt;&gt;        equality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;&gt;        (purity) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;&gt;        know of applies to functions and implies no side effects. In that<br>&gt;&gt;&gt;        world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;&gt;        reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;&gt;        thread. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;&gt;    Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;&gt;    “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;&gt;    enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;&gt;    it means.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;&gt;        possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;&gt;        purity?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;&gt;    mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;&gt;    copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;&gt;    **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt;&gt; mutation possible is local. <br>&gt;&gt; <br>&gt;&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt;&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt;&gt; determine whether there was mutation?”  <br>&gt;&gt; <br>&gt;&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt;&gt; everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt;&gt; elements they contain also have the same property. <br>&gt;&gt; <br>&gt;&gt; Only if you think mutable class instances are part of the value of the<br>&gt;&gt; array that stores references to those class instances.  As I said<br>&gt;&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt; Today, we have left that question wide open, which makes the whole<br>&gt;&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt;&gt; close it.<br>&gt;&gt; <br>&gt;&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt; they are all uniquely referenced.<br>&gt;&gt; <br>&gt;&gt; If you interpret the elements of the array as being *references* to<br>&gt;&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt;&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt; problems.<br>&gt; <br>&gt; This does not make sense, because you’ve got problems either way. You are arguing, essentially, that everything is a value type because references/pointers are a value. If that were the case then the *only* valid way to compare the equality of types would be to compare their values. Overriding the equality operator would inherently violate the property of immutability, i.e. two immutable objects can change their equality even without mutation of their “values&quot;.<br>&gt; <br>&gt; func ==(lhs, rhs) {<br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; class MyClass {<br>&gt;     var a: Int<br>&gt;     <br>&gt;     ...<br>&gt; <br>&gt; } <br>&gt; <br>&gt; let x = MyClass(a: 5)<br>&gt; let y = MyClass(a: 5)<br>&gt; <br>&gt; x == y // true<br>&gt; y.a = 6<br>&gt; x == y // false<br>&gt; <br>&gt;&gt;  Are you arguing that reference types should be equatable by default,<br>&gt;&gt;        using<br>&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;        definition of<br>&gt;&gt;        equality?<br>&gt;&gt; <br>&gt;&gt;    Yes!!<br>&gt; <br>&gt; <br>&gt; Custom definitions of equality, inherently, decouple immutability from equality, as shown above. Swift makes it appear as though references and values are on the same level in a way that C does not.<br>&gt; <br>&gt; let x = MyStruct()<br>&gt; let y = MyClass()<br>&gt; <br>&gt; x.myFoo<br>&gt; y.myFoo<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; my_struct *x = …<br>&gt; my_struct y = …<br>&gt; <br>&gt; x.my_foo<br>&gt; y-&gt;my_foo<br>&gt; <br>&gt; With C it is explicit that you are crossing a reference. Thus there is only *one* type of equality in C, that the values *are equal*. This exactly the type of equality you are referring to, but this does not carry over to Swift for precisely the reason that Swift paves over the difference between value and reference types, and then allows you to redefine equality.<br>&gt; <br>&gt; Therefore, in essentially no circumstances does it make sense to compare a type by its reference if it has any associated data in Swift. Basically, if it will be commonplace to override the equality operator to compare the first level of associated values of a reference type, then the comparison of just the reference has no business being the default.<br>&gt; <br>&gt; If the default equality for reference types was defined as the equality of the references it would be inconsistent with the Swift’s current apparent surfacing of the first level of associated data for reference types.<br></p><p>This depends on the type.  For types representing resources, etc it works just fine.  But for models it does not work unless the model subgraph is entirely immutable and instances are unique.  I agree that it isn&#39;t a good idea to provide a default that will certainly be wrong in many cases.<br></p><p>&gt; <br>&gt;&gt;&gt;    I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;&gt;    semantics.” But I could be wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;&gt;        property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Wrong in what sense? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;&gt;    logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;&gt;    have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;&gt;    anything other than values, so it would be extremely limiting. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt;&gt; CoW.<br>&gt;&gt; <br>&gt;&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br>&gt; <br>&gt; I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references form a subgraph, within which a change to any of the values would constitute a change in the value of A (thus impermissible if A is immutable). Thus structs would quality as “PureValues”.<br></p><p>As you noted in a followup, not all structs qualify.  Structs that whose members all qualify will qualify.  References to a subgraph that doesn&#39;t allow for any observable mutation (i.e. deeply immutable reference types) also qualify.<br></p><p>This means the following qualify:<br></p><p>* primitive structs and enums<br>* observable immutable object subgraphs<br>* any type composed from the previous<br></p><p>It follows that generic types often conditionally qualify depending on their type arguments.<br></p><p>&gt; <br>&gt; I also assume that enforcing immutability on an object graph, via CoW or otherwise, would be unfeasible. You could enforce it on all values accessible by traversing a single reference for reference types, however.<br>&gt; <br>&gt; This is why I don’t really buy the argument that there is no such this as deep vs shallow copy. Deep copy means copying the whole “PureValue” or subgraph, shallow copy means traversing a single reference and copying all accessible values.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt;        property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;&gt;        valuable<br>&gt;&gt;&gt;        property in many cases. Do you disagree?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;&gt;    algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;&gt;    work just as well on Array&lt;Int&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;&gt; to have a reference to the same objects.<br>&gt;&gt; <br>&gt;&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        let t = MyClass()<br>&gt;&gt;&gt;        foo.acceptWrapped(Wrap(t))<br>&gt;&gt;&gt;        t.mutate()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In this example, foo had better not depend on the wrapped instance not<br>&gt;&gt;&gt;        getting<br>&gt;&gt;&gt;        mutated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;&gt;        anything about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo<br>&gt;&gt;&gt;        passes the<br>&gt;&gt;&gt;        wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;&gt;        instance. My<br>&gt;&gt;&gt;        point was that shared mutable state is still possible here. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt;&gt;&gt;    it construct the T in its init rather than accepting a T parameter) and<br>&gt;&gt;&gt;    the fact that it&#39;s *possible* to code something with the structure of<br>&gt;&gt;&gt;    Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend<br>&gt;&gt;&gt; on the semantic properties of T (whether or not non-local mutation may be<br>&gt;&gt;&gt; observed in this case). <br>&gt;&gt; <br>&gt;&gt; No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt; semantic properties of T.  This was in answer to what you said:<br>&gt;&gt; <br>&gt;&gt;&gt;       A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;       “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;&gt;       guarantees usually associated with value semantics (won’t<br>&gt;&gt;&gt;       mutate behind your back, thread safe, etc).<br>&gt;&gt; <br>&gt;&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt;&gt; types in that category, and what generic code would depend on those<br>&gt;&gt; properties?<br>&gt;&gt; <br>&gt;&gt;&gt; It certainly isn’t irrelevant to that point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    HTH,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;&gt;        AnyValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;&gt;        so while using references internally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;&gt;        That<br>&gt;&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;&gt;        providing static enforcement. This is like that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I did not know this. Now you have me curious. Can you give an example of<br>&gt;&gt;&gt;        where<br>&gt;&gt;&gt;        we are able to violate law? I ask mostly because it sounds like there is<br>&gt;&gt;&gt;        a<br>&gt;&gt;&gt;        possibility of stumbling into dangerous territory, possibly without<br>&gt;&gt;&gt;        being aware<br>&gt;&gt;&gt;        that you have done so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        See “In-out Parameters” in<br>&gt;&gt;&gt;        https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;&gt;        enforce this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;&gt;        could make similar assumptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;&gt;        etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        -- <br>&gt;&gt;&gt;        Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    -- <br>&gt;&gt;&gt;    Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/80745370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; This depends on the type. For types representing resources, etc it works just<br>&gt; fine. But for models it does not work unless the model subgraph is entirely<br>&gt; immutable and instances are unique. <br>&gt; I agree that it isn&#39;t a good idea to provide a default that will<br>&gt; certainly be wrong in many cases.<br></p><p>Please show an example of a mutable model where such an equality would<br>be wrong.  <br></p><p>&gt;     I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references<br>&gt;     form a subgraph, within which a change to any of the values would constitute<br>&gt;     a change in the value of A (thus impermissible if A is immutable). Thus<br>&gt;     structs would quality as “PureValues”.<br>&gt;<br>&gt; As you noted in a followup, not all structs qualify. Structs that whose members<br>&gt; all qualify will qualify. References to a subgraph that doesn&#39;t allow for any<br>&gt; observable mutation (i.e. deeply immutable reference types) also qualify.<br>&gt;<br>&gt; This means the following qualify:<br>&gt;<br>&gt; * primitive structs and enums<br>&gt; * observable immutable object subgraphs<br>&gt; * any type composed from the previous<br>&gt;<br>&gt; It follows that generic types often conditionally qualify depending on their<br>&gt; type arguments.<br>&gt;<br>&gt;     I also assume that enforcing immutability on an object graph, via CoW or<br>&gt;     otherwise, would be unfeasible. You could enforce it on all values<br>&gt;     accessible by traversing a single reference for reference types, however.<br>&gt;<br>&gt;     This is why I don’t really buy the argument that there is no such this as<br>&gt;     deep vs shallow copy. Deep copy means copying the whole “PureValue” or<br>&gt;     subgraph, shallow copy means traversing a single reference and copying all<br>&gt;     accessible values.<br>&gt;<br>&gt;                 I don’t mean to imply that it is the *only* valuable<br>&gt;             property. However, it I (and many others) do believe it is an<br>&gt;             extremely<br>&gt;             valuable<br>&gt;             property in many cases. Do you disagree?<br>&gt;<br>&gt;             I think I do. What is valuable about such a protocol? What generic<br>&gt;             algorithms could you write that work on models of PureValue but<br>&gt;             don&#39;t<br>&gt;             work just as well on Array&lt;Int&gt;?<br>&gt;<br>&gt;             Array&lt;Int&gt; provides the semantics I have in mind just fine so there<br>&gt;             wouldn’t be<br>&gt;             any. Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;             Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects<br>&gt;             contained<br>&gt;             in the array will not be mutated by code elsewhere that also happens<br>&gt;             to have a reference to the same objects.<br>&gt;<br>&gt;         Okay then, what algorithms can you write that operate on PureValue that<br>&gt;         don&#39;t work equally well on Array&lt;AnyObject&gt;?<br></p><p>You haven&#39;t answered this question.  How would you use this protocol?<br></p><p>&gt;             let t = MyClass()<br>&gt;             foo.acceptWrapped(Wrap(t))<br>&gt;             t.mutate()<br>&gt;<br>&gt;             In this example, foo had better not depend on the wrapped instance<br>&gt;             not<br>&gt;             getting<br>&gt;             mutated.<br>&gt;<br>&gt;             foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;             anything about it.<br>&gt;<br>&gt;             Ok, but this is a toy example. What is the purpose of Wrap? Maybe<br>&gt;             foo<br>&gt;             passes the<br>&gt;             wrapped instance back to code that *does* have visibility to the<br>&gt;             instance. My<br>&gt;             point was that shared mutable state is still possible here. <br>&gt;<br>&gt;             And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have<br>&gt;             let<br>&gt;             it construct the T in its init rather than accepting a T parameter)<br>&gt;             and<br>&gt;             the fact that it&#39;s *possible* to code something with the structure<br>&gt;             of<br>&gt;             Wrap so that it has shared mutable state is irrelevant.<br>&gt;<br>&gt;             The point I am trying to make is that the semantic properties of<br>&gt;             Wrap&lt;T&gt; depend<br>&gt;             on the semantic properties of T (whether or not non-local mutation<br>&gt;             may be<br>&gt;             observed in this case). <br>&gt;<br>&gt;         No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;         semantic properties of T. This was in answer to what you said:<br>&gt;<br>&gt;                 A struct wrapping a mutable reference type certainly doesn’t<br>&gt;             “feel” value semantic to me and certainly doesn’t have the<br>&gt;             guarantees usually associated with value semantics (won’t<br>&gt;             mutate behind your back, thread safe, etc).<br>&gt;<br>&gt;         I have been trying to get you to nail down what you mean by PureValue,<br>&gt;         and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;         mutable reference type” is not enough to disqualify anything from being<br>&gt;         in the category you&#39;re trying to describe. What are the properties of<br>&gt;         types in that category, and what generic code would depend on those<br>&gt;         properties?<br></p><p>Again, the key questions are above, asked a different way.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 3:03 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; This depends on the type. For types representing resources, etc it works just<br>&gt;&gt; fine. But for models it does not work unless the model subgraph is entirely<br>&gt;&gt; immutable and instances are unique. <br>&gt;&gt; I agree that it isn&#39;t a good idea to provide a default that will<br>&gt;&gt; certainly be wrong in many cases.<br>&gt; <br>&gt; Please show an example of a mutable model where such an equality would<br>&gt; be wrong.  <br></p><p>This is somewhat orthogonal to the main points I have been making in this thread.  I have been focused on discussion about reference types that have value semantics and the distinction between value semantics and pure values.  In any case, here you go:<br></p><p>let a: NSMutableArray = [1, 2, 3]<br>let other: NSMutableArray = [1, 2, 3]<br>let same = a === other // false<br>let equal = a == other // true<br></p><p>Reference equality does not match the behavior of many existing mutable model types.  You seem to be making a case that in Swift it should.  But that is a separate discussion from the one I am trying to engage in because mutable reference types *do not* have value semantics.  <br></p><p>&gt; <br>&gt;&gt;    I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references<br>&gt;&gt;    form a subgraph, within which a change to any of the values would constitute<br>&gt;&gt;    a change in the value of A (thus impermissible if A is immutable). Thus<br>&gt;&gt;    structs would quality as “PureValues”.<br>&gt;&gt; <br>&gt;&gt; As you noted in a followup, not all structs qualify. Structs that whose members<br>&gt;&gt; all qualify will qualify. References to a subgraph that doesn&#39;t allow for any<br>&gt;&gt; observable mutation (i.e. deeply immutable reference types) also qualify.<br>&gt;&gt; <br>&gt;&gt; This means the following qualify:<br>&gt;&gt; <br>&gt;&gt; * primitive structs and enums<br>&gt;&gt; * observable immutable object subgraphs<br>&gt;&gt; * any type composed from the previous<br>&gt;&gt; <br>&gt;&gt; It follows that generic types often conditionally qualify depending on their<br>&gt;&gt; type arguments.<br>&gt;&gt; <br>&gt;&gt;    I also assume that enforcing immutability on an object graph, via CoW or<br>&gt;&gt;    otherwise, would be unfeasible. You could enforce it on all values<br>&gt;&gt;    accessible by traversing a single reference for reference types, however.<br>&gt;&gt; <br>&gt;&gt;    This is why I don’t really buy the argument that there is no such this as<br>&gt;&gt;    deep vs shallow copy. Deep copy means copying the whole “PureValue” or<br>&gt;&gt;    subgraph, shallow copy means traversing a single reference and copying all<br>&gt;&gt;    accessible values.<br>&gt;&gt; <br>&gt;&gt;                I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;            property. However, it I (and many others) do believe it is an<br>&gt;&gt;            extremely<br>&gt;&gt;            valuable<br>&gt;&gt;            property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;            I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;            algorithms could you write that work on models of PureValue but<br>&gt;&gt;            don&#39;t<br>&gt;&gt;            work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt;            Array&lt;Int&gt; provides the semantics I have in mind just fine so there<br>&gt;&gt;            wouldn’t be<br>&gt;&gt;            any. Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;            Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects<br>&gt;&gt;            contained<br>&gt;&gt;            in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;            to have a reference to the same objects.<br>&gt;&gt; <br>&gt;&gt;        Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt;        don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt; <br>&gt; You haven&#39;t answered this question.  How would you use this protocol?<br></p><p>I answered elsewhere but I’ll repeat that one use that immediately comes to mind is to constrain values received in the initializer of a (view) controller to ensure that the observable state will not change over time.  This is not an algorithmic use but is still perfectly valid IMO.<br></p><p>If I read Andrew’s post correctly it sounds like it may also be of use to the optimizer in some cases.<br></p><p>&gt; <br>&gt;&gt;            let t = MyClass()<br>&gt;&gt;            foo.acceptWrapped(Wrap(t))<br>&gt;&gt;            t.mutate()<br>&gt;&gt; <br>&gt;&gt;            In this example, foo had better not depend on the wrapped instance<br>&gt;&gt;            not<br>&gt;&gt;            getting<br>&gt;&gt;            mutated.<br>&gt;&gt; <br>&gt;&gt;            foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;            anything about it.<br>&gt;&gt; <br>&gt;&gt;            Ok, but this is a toy example. What is the purpose of Wrap? Maybe<br>&gt;&gt;            foo<br>&gt;&gt;            passes the<br>&gt;&gt;            wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;            instance. My<br>&gt;&gt;            point was that shared mutable state is still possible here. <br>&gt;&gt; <br>&gt;&gt;            And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have<br>&gt;&gt;            let<br>&gt;&gt;            it construct the T in its init rather than accepting a T parameter)<br>&gt;&gt;            and<br>&gt;&gt;            the fact that it&#39;s *possible* to code something with the structure<br>&gt;&gt;            of<br>&gt;&gt;            Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt; <br>&gt;&gt;            The point I am trying to make is that the semantic properties of<br>&gt;&gt;            Wrap&lt;T&gt; depend<br>&gt;&gt;            on the semantic properties of T (whether or not non-local mutation<br>&gt;&gt;            may be<br>&gt;&gt;            observed in this case). <br>&gt;&gt; <br>&gt;&gt;        No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt;        semantic properties of T. This was in answer to what you said:<br>&gt;&gt; <br>&gt;&gt;                A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;            “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;            guarantees usually associated with value semantics (won’t<br>&gt;&gt;            mutate behind your back, thread safe, etc).<br>&gt;&gt; <br>&gt;&gt;        I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt;        and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt;        mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt;        in the category you&#39;re trying to describe. What are the properties of<br>&gt;&gt;        types in that category, and what generic code would depend on those<br>&gt;&gt;        properties?<br>&gt; <br>&gt; Again, the key questions are above, asked a different way.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 10:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On May 7, 2016, at 3:03 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This depends on the type. For types representing resources, etc it works just<br>&gt;&gt;&gt; fine. But for models it does not work unless the model subgraph is entirely<br>&gt;&gt;&gt; immutable and instances are unique. <br>&gt;&gt;&gt; I agree that it isn&#39;t a good idea to provide a default that will<br>&gt;&gt;&gt; certainly be wrong in many cases.<br>&gt;&gt; <br>&gt;&gt; Please show an example of a mutable model where such an equality would<br>&gt;&gt; be wrong.  <br>&gt;<br>&gt; This is somewhat orthogonal to the main points I have been making in<br>&gt; this thread.  I have been focused on discussion about reference types<br>&gt; that have value semantics and the distinction between value semantics<br>&gt; and pure values.  In any case, here you go:<br>&gt;<br>&gt; let a: NSMutableArray = [1, 2, 3]<br>&gt; let other: NSMutableArray = [1, 2, 3]<br>&gt; let same = a === other // false<br>&gt; let equal = a == other // true<br></p><p>That&#39;s not proof that an == for NSMutableArray that matches the behavior<br>of === would be wrong, just that it would be different from what we<br>currently have.  <br></p><p>&gt; Reference equality does not match the behavior of many existing<br>&gt; mutable model types.  You seem to be making a case that in Swift it<br>&gt; should.  <br></p><p>Yes.<br></p><p>&gt; But that is a separate discussion from the one I am trying to engage<br>&gt; in because mutable reference types *do not* have value semantics.<br></p><p>Then maybe I should disengage here?<br></p><p>&gt;&gt;&gt;        Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt;&gt;        don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;&gt; <br>&gt;&gt; You haven&#39;t answered this question.  How would you use this protocol?<br>&gt;<br>&gt; I answered elsewhere but I’ll repeat that one use that immediately<br>&gt; comes to mind is to constrain values received in the initializer of a<br>&gt; (view) controller to ensure that the observable state will not change<br>&gt; over time.  <br></p><p>My claim is that substituting the constraint of “it has value<br>semantics,” while presumably looser than the PureValue constraint, would<br>not compromise the correctness of your view controller, so not only is<br>the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>anything.  If you want to refute that, just show me the code.<br></p><p>&gt; This is not an algorithmic use but is still perfectly valid IMO.<br></p><p>If the properties of PureValue matter to your view controller, there&#39;s<br>an algorithm somewhere that depends on those properties for its<br>correctness.<br></p><p>&gt; If I read Andrew’s post correctly it sounds like it may also be of use<br>&gt; to the optimizer in some cases.<br></p><p>FWIW, I&#39;m only interested in how you use this protocol in the<br>programming model, and I&#39;m not even sure Andrew is talking about the<br>same constraint that you are.<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 8, 2016, at 12:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 7, 2016, at 3:03 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This depends on the type. For types representing resources, etc it works just<br>&gt;&gt;&gt;&gt; fine. But for models it does not work unless the model subgraph is entirely<br>&gt;&gt;&gt;&gt; immutable and instances are unique. <br>&gt;&gt;&gt;&gt; I agree that it isn&#39;t a good idea to provide a default that will<br>&gt;&gt;&gt;&gt; certainly be wrong in many cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please show an example of a mutable model where such an equality would<br>&gt;&gt;&gt; be wrong.  <br>&gt;&gt; <br>&gt;&gt; This is somewhat orthogonal to the main points I have been making in<br>&gt;&gt; this thread.  I have been focused on discussion about reference types<br>&gt;&gt; that have value semantics and the distinction between value semantics<br>&gt;&gt; and pure values.  In any case, here you go:<br>&gt;&gt; <br>&gt;&gt; let a: NSMutableArray = [1, 2, 3]<br>&gt;&gt; let other: NSMutableArray = [1, 2, 3]<br>&gt;&gt; let same = a === other // false<br>&gt;&gt; let equal = a == other // true<br>&gt; <br>&gt; That&#39;s not proof that an == for NSMutableArray that matches the behavior<br>&gt; of === would be wrong, just that it would be different from what we<br>&gt; currently have.  <br>&gt; <br>&gt;&gt; Reference equality does not match the behavior of many existing<br>&gt;&gt; mutable model types.  You seem to be making a case that in Swift it<br>&gt;&gt; should.  <br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; But that is a separate discussion from the one I am trying to engage<br>&gt;&gt; in because mutable reference types *do not* have value semantics.<br>&gt; <br>&gt; Then maybe I should disengage here?<br>&gt; <br>&gt;&gt;&gt;&gt;       Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt;&gt;&gt;       don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You haven&#39;t answered this question.  How would you use this protocol?<br>&gt;&gt; <br>&gt;&gt; I answered elsewhere but I’ll repeat that one use that immediately<br>&gt;&gt; comes to mind is to constrain values received in the initializer of a<br>&gt;&gt; (view) controller to ensure that the observable state will not change<br>&gt;&gt; over time.  <br>&gt; <br>&gt; My claim is that substituting the constraint of “it has value<br>&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt; not compromise the correctness of your view controller, so not only is<br>&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt; anything.  If you want to refute that, just show me the code.<br>&gt; <br>&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt; <br>&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt; an algorithm somewhere that depends on those properties for its<br>&gt; correctness.<br></p><p>In many cases it may just be view configuration that depends on those properties.  I suppose you can call view configuration code an algorithm but I think that would fall outside of common usage.<br></p><p>&gt; <br>&gt;&gt; If I read Andrew’s post correctly it sounds like it may also be of use<br>&gt;&gt; to the optimizer in some cases.<br>&gt; <br>&gt; FWIW, I&#39;m only interested in how you use this protocol in the<br>&gt; programming model, and I&#39;m not even sure Andrew is talking about the<br>&gt; same constraint that you are.<br></p><p>I am also primarily interested in the programming model.  That said, as far as I can tell everything Andrew has said is talking about the exact same thing I am.  Andrew, if I have said anything that doesn’t align with the constraint you’re talking about please let me know!<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/2db5ec84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     My claim is that substituting the constraint of “it has value<br>&gt;     semantics,” while presumably looser than the PureValue constraint, would<br>&gt;     not compromise the correctness of your view controller, so not only is<br>&gt;     the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;     anything.  If you want to refute that, just show me the code.<br>&gt;<br>&gt;         This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;<br>&gt;     If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;     an algorithm somewhere that depends on those properties for its<br>&gt;     correctness.<br>&gt;<br>&gt; In many cases it may just be view configuration that depends on those<br>&gt; properties.  I suppose you can call view configuration code an<br>&gt; algorithm but I think that would fall outside of common usage.<br></p><p>It&#39;s an algorithm, or if the configuration is declarative, there&#39;s an<br>algorithm that manipulates it.  That said, I still don&#39;t have a concrete<br>example of how view configuration can depend on these properties.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    My claim is that substituting the constraint of “it has value<br>&gt;&gt;    semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;    not compromise the correctness of your view controller, so not only is<br>&gt;&gt;    the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;    anything.  If you want to refute that, just show me the code.<br>&gt;&gt; <br>&gt;&gt;        This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt; <br>&gt;&gt;    If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;    an algorithm somewhere that depends on those properties for its<br>&gt;&gt;    correctness.<br>&gt;&gt; <br>&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt; <br>&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s an<br>&gt; algorithm that manipulates it.  That said, I still don&#39;t have a concrete<br>&gt; example of how view configuration can depend on these properties.<br></p><p>The algorithm might just be &quot;copy x bit of data to y view property, etc&quot;.  That is so trivial that it feels like a stretch to call it an algorithm.<br></p><p>That &quot;algorithm&quot; doesn&#39;t depend on this property because it executes at a single point in time.  However, a view controller might depend on that property in order to render properly across time (for example, configuring cells as they scroll on and off screen).  <br></p><p>This property allows us to separate values from non-local mutation and make such separation a requirement.  Rather than observing mutations of objects with KVO, etc we might prefer to observe something that provides a new aggregate value instead, while requiring the entire aggregate value itself to be (observably) immutable at all times (because we stored it with a let property locally).  This can make it easier to reason about correct behavior of your code.  But it doesn&#39;t work unless all visible parts of the aggregate are immutable.<br></p><p> If you&#39;re not familiar with Elm, Redux, etc it might be worth taking a look.  <br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 12:00:00pm</p></header><div class="content"><p>on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;    semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;    not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;    the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;    anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;    an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;    correctness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt; <br>&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s an<br>&gt;&gt; algorithm that manipulates it.  That said, I still don&#39;t have a concrete<br>&gt;&gt; example of how view configuration can depend on these properties.<br>&gt;<br>&gt; The algorithm might just be &quot;copy x bit of data to y view property,<br>&gt; etc&quot;.  That is so trivial that it feels like a stretch to call it an<br>&gt; algorithm.<br></p><p>Algorithms can be trivial.<br></p><p>&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it executes<br>&gt; at a single point in time.  However, a view controller might depend on<br>&gt; that property in order to render properly across time (for example,<br>&gt; configuring cells as they scroll on and off screen).<br></p><p>The example is too abstract for me to understand.<br></p><p>Let me put this differently: I recognize that your concept of<br>“PureValue” may be a *sufficient* condition for some generic<br>algorithm/component to work, but it is never a *necessary* condition,<br>because genericity (or use of a superclass or protocol type) erases<br>details of the actual types involved from the point of view of the<br>algorithm/component.  It doesn&#39;t matter if your type contains a class<br>reference if it has value semantic properties.  My claim is that<br>PureValue is an overly-restrictive constraint that makes many things<br>less useful than they should be.<br></p><p>&gt; This property allows us to separate values from non-local mutation and<br>&gt; make such separation a requirement.  Rather than observing mutations<br>&gt; of objects with KVO, etc we might prefer to observe something that<br>&gt; provides a new aggregate value instead, while requiring the entire<br>&gt; aggregate value itself to be (observably) immutable at all times<br>&gt; (because we stored it with a let property locally).  This can make it<br>&gt; easier to reason about correct behavior of your code.  But it doesn&#39;t<br>&gt; work unless all visible parts of the aggregate are immutable.<br>&gt;<br>&gt;  If you&#39;re not familiar with Elm, Redux, etc it might be worth taking<br>&gt;  a look.  <br></p><p>That&#39;s a pretty broad link.  At which parts do you think I should look?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;   semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;   not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;   the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;   anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;   an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;   correctness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s an<br>&gt;&gt;&gt; algorithm that manipulates it.  That said, I still don&#39;t have a concrete<br>&gt;&gt;&gt; example of how view configuration can depend on these properties.<br>&gt;&gt; <br>&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view property,<br>&gt;&gt; etc&quot;.  That is so trivial that it feels like a stretch to call it an<br>&gt;&gt; algorithm.<br>&gt; <br>&gt; Algorithms can be trivial.<br></p><p>Fair enough.  Although in most contexts people don’t use the word when discussing the trivial.<br></p><p>&gt; <br>&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it executes<br>&gt;&gt; at a single point in time.  However, a view controller might depend on<br>&gt;&gt; that property in order to render properly across time (for example,<br>&gt;&gt; configuring cells as they scroll on and off screen).<br>&gt; <br>&gt; The example is too abstract for me to understand.<br>&gt; <br>&gt; Let me put this differently: I recognize that your concept of<br>&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt; algorithm/component to work, but it is never a *necessary* condition,<br>&gt; because genericity (or use of a superclass or protocol type) erases<br>&gt; details of the actual types involved from the point of view of the<br>&gt; algorithm/component.  It doesn&#39;t matter if your type contains a class<br>&gt; reference if it has value semantic properties.  My claim is that<br>&gt; PureValue is an overly-restrictive constraint that makes many things<br>&gt; less useful than they should be.<br></p><p>In many cases this is true - you don’t need more than value semantics as you define it.  However it is not at all true that PureValue is never necessary for the correctness of code.  I’m going to provide an example to the contrary below.<br></p><p>&gt; <br>&gt;&gt; This property allows us to separate values from non-local mutation and<br>&gt;&gt; make such separation a requirement.  Rather than observing mutations<br>&gt;&gt; of objects with KVO, etc we might prefer to observe something that<br>&gt;&gt; provides a new aggregate value instead, while requiring the entire<br>&gt;&gt; aggregate value itself to be (observably) immutable at all times<br>&gt;&gt; (because we stored it with a let property locally).  This can make it<br>&gt;&gt; easier to reason about correct behavior of your code.  But it doesn&#39;t<br>&gt;&gt; work unless all visible parts of the aggregate are immutable.<br>&gt;&gt; <br>&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth taking<br>&gt;&gt; a look.  <br>&gt; <br>&gt; That&#39;s a pretty broad link.  At which parts do you think I should look?<br></p><p>The piece that matters here is state management.  The core concept is to tightly control how mutations happen.  It is modeled in terms of state type T, an initial value t, an action type A (instances of which are mutation commands, as in the command pattern), and a reducer function (T, A) -&gt; T which produces a new state.<br></p><p>Here’s a toy implementation that is somewhat simplistic but captures the essence of the concept:<br></p><p>class Store&lt;State, Action&gt; {<br>    typealias Reducer = (State, Action) -&gt; State<br>    <br>    var stateHistory: [State]<br>    let reducer: Reducer<br>    <br>    init(initialState: State, reducer: Reducer) {<br>        stateHistory = [initialState]<br>        self.reducer = reducer<br>    }<br>    <br>    func applyAction(action: Action) {<br>        let newState = reducer(stateHistory.last!, action)<br>        stateHistory.append(newState)<br>    }<br>    <br>    var currentState: State {<br>        return stateHistory.last!<br>    }<br>    <br>    var canUndo: Bool {<br>        return stateHistory.count &gt; 1<br>    }<br>    <br>    func undo() {<br>        if canUndo {<br>            stateHistory.popLast()<br>        }<br>    }<br>}<br></p><p>This design relies on State being a PureValue.  The whole idea is that the only way any path of observation rooted at currentState can change is when the reducer returns a new state when it is called by `applyAction`.  That guarantee cannot be provided by value semantics alone under your definition of value semantics.  Further, each state in the history is intended to be a static snapshot of the “currentState” state at a specific point in time.  All states should be logically independent from each other and from anything anywhere else in the program.  This cannot be guaranteed under your definition of value semantics.  <br></p><p>If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value semantics under your definition it is clear that we should have no expectation that the desired properties are preserved.  The Store class is fundamentally broken if it can be used with State types that are not pure values.<br></p><p>I’m not sure why it didn’t occur to me sooner, but this strategy for managing app state is very similar in nature to what Sean Parent discusses in his value semantics talk (https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related https://www.youtube.com/watch?v=bIhUE5uUFOA &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;). <br></p><p>Sean discusses using value semantics to model applications state (he calls it document).  His examples don’t use reified actions and reducer functions so it is a bit different but it relies on the same pure value semantics.  The demo he gives in the talk is a toy example modeled on the design Photoshop uses to implement its history feature.  This design relies on each document in the history being an aggregate which is a PureValue.  This is not an academic discussion, but on with real world practical utility.<br></p><p>Sean says “value semantics is similar to functional programming, except objects still have addresses and in-situ operations…  You&#39;re trying to maintain the ability to locally reason about your code but you&#39;re not denying the fact that the machine has memory and you can do in-situ operations on it”.  Towards the end he quotes from a discussion he had with John Backus (inventor of FP).  John said: “it always annoyed me that FP and the no side effect way of programming had become a religion.  With FP I was trying to come up with a mathematically rigorous way to program and I understood the complexities of having side effects.  I always knew we had to deal with side effects, I just wanted a structured way to do it.”  John agreed that Sean’s approach to value semantics provides such a structure.  Allowing shared mutable references throws away that structured approach.  (As an aside, this is the most exciting thing about value semantics IMO - it provides a structured approach to side effects, allowing local reasoning about code).  <br></p><p>Sean gives an example of how references break the ability to reason locally where he has two shared_ptrs that point to the same object:<br></p><p>&quot;If you look at it in terms of just the individual types you kind of do have value semantics.  When I copy a shared pointer it copies the pointer with value semantic operations...  The problem is the references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if I have the object.  So really what I have is two objects that intersect.  So really my object in the program is this whole connected mess.  At any particular point in code I have difficulty reasoning about the whole thing.  The shared structure breaks our ability to reason locally about code.&quot;<br></p><p>Sean makes an important distinction between looking at individual types and looking at the aggregate as a whole.  It is very important to him that the entire aggregate be logically independent as this facilitates local reasoning.  This is exactly what I have been calling a pure value.  Pure value never allows any intersection to be observed (immutable intersections are allowed because they cannot be observed, which Sean alludes to in passing).  Incidentally, it is pretty clear from the talk that immutable intersection is heavily used in Photoshop history in order to keep memory use reasonable.  This falls into the category of persistent data structures.<br></p><p>My impression is that Sean’s definition of &quot;value semantics” excludes “intersecting objects” (where the intersection is mutable) and is aligned with John’s “full value semantics” and the notion of “pure value” we have been discussing.  <br></p><p>-Matthew<br></p><p><br></p><p><br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/151abe1e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 6:43 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If I read Andrew’s post correctly it sounds like it may also be of use to the optimizer in some cases.<br></p><p><br>I’ll just requote Dave’s example, which made perfect sense to me (so I’m not sure why there’s an argument):<br></p><p>&gt; To me that means, if the behavior of “f” only depends on<br>&gt; data reachable through this array, and f makes no mutations, then in<br>&gt; this code, the two calls to f() are guaranteed have the same effect.<br>&gt; <br>&gt;      func g&lt;T&gt;(a: [T]) {<br>&gt;        var vc = MyViewController(a)<br>&gt;        vc.f() // #1<br>&gt;        h()<br>&gt;        vc.f() // #2<br>&gt;     }<br>&gt; <br>&gt; But clearly, the only way that can be the case is if T is actually<br>&gt; immutable (and contains no references to mutable data), because<br>&gt; otherwise anybody can write:<br>&gt; <br>&gt;    class X { ... }<br>&gt;    let global: [X] = [ X() ]<br>&gt;    func h() { global[0].mutatingMethod() }<br>&gt;    g(global)<br>&gt; <br>&gt; Conclusion: your definition of PureValue, as written, implies conforming<br>&gt; reference types must be immutable.  I&#39;m not saying that&#39;s necessarily<br>&gt; what you meant, but if it isn&#39;t, you need to try to define it again.<br></p><p>Yes, of course. If a PureValue contains a reference it must be immutable or only mutated when uniquely referenced.<br></p><p>There are other ways to communicate what the optimizer needs. I think the more interesting question is how users should express the value semantics of their types.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/ebcdb9a2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 3:03 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; This depends on the type. For types representing resources, etc it works just<br>&gt;&gt; fine. But for models it does not work unless the model subgraph is entirely<br>&gt;&gt; immutable and instances are unique. <br>&gt;&gt; I agree that it isn&#39;t a good idea to provide a default that will<br>&gt;&gt; certainly be wrong in many cases.<br>&gt; <br>&gt; Please show an example of a mutable model where such an equality would<br>&gt; be wrong.  <br></p><p>Maybe wrong is a little bit too strong a word, but it certainly isn’t the behavior people are accustomed to.  I think most people consider model instances to be logically equal if their properties are equal regardless of the address of the instances in memory.  Reference identity only works as expected if the model instances are uniqued in memory.  <br></p><p>let a: NSMutableArray = [1, 2, 3]<br>let b: NSMutableArray = [1, 2, 3]<br></p><p>let referenceEquality = a === b  // false<br>let elementEquality = a == b      // true<br></p><p><br>&gt; <br>&gt;&gt;    I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references<br>&gt;&gt;    form a subgraph, within which a change to any of the values would constitute<br>&gt;&gt;    a change in the value of A (thus impermissible if A is immutable). Thus<br>&gt;&gt;    structs would quality as “PureValues”.<br>&gt;&gt; <br>&gt;&gt; As you noted in a followup, not all structs qualify. Structs that whose members<br>&gt;&gt; all qualify will qualify. References to a subgraph that doesn&#39;t allow for any<br>&gt;&gt; observable mutation (i.e. deeply immutable reference types) also qualify.<br>&gt;&gt; <br>&gt;&gt; This means the following qualify:<br>&gt;&gt; <br>&gt;&gt; * primitive structs and enums<br>&gt;&gt; * observable immutable object subgraphs<br>&gt;&gt; * any type composed from the previous<br>&gt;&gt; <br>&gt;&gt; It follows that generic types often conditionally qualify depending on their<br>&gt;&gt; type arguments.<br>&gt;&gt; <br>&gt;&gt;    I also assume that enforcing immutability on an object graph, via CoW or<br>&gt;&gt;    otherwise, would be unfeasible. You could enforce it on all values<br>&gt;&gt;    accessible by traversing a single reference for reference types, however.<br>&gt;&gt; <br>&gt;&gt;    This is why I don’t really buy the argument that there is no such this as<br>&gt;&gt;    deep vs shallow copy. Deep copy means copying the whole “PureValue” or<br>&gt;&gt;    subgraph, shallow copy means traversing a single reference and copying all<br>&gt;&gt;    accessible values.<br>&gt;&gt; <br>&gt;&gt;                I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;            property. However, it I (and many others) do believe it is an<br>&gt;&gt;            extremely<br>&gt;&gt;            valuable<br>&gt;&gt;            property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;            I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;            algorithms could you write that work on models of PureValue but<br>&gt;&gt;            don&#39;t<br>&gt;&gt;            work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt;            Array&lt;Int&gt; provides the semantics I have in mind just fine so there<br>&gt;&gt;            wouldn’t be<br>&gt;&gt;            any. Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;            Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects<br>&gt;&gt;            contained<br>&gt;&gt;            in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;            to have a reference to the same objects.<br>&gt;&gt; <br>&gt;&gt;        Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt;        don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt; <br>&gt; You haven&#39;t answered this question.  How would you use this protocol?<br></p><p>I think the best example was given by Andy when discussing pure functions.  Maybe I want to write a generic function and ensure it is pure.  I can only do this if I know that any arguments received that compare equal will always present the same observable state.  For example, maybe I wish to memoize the result.  <br></p><p>I cannot write such a function for all T, and I also cannot write such a function for all T that have value semantics if we adopt the “references are values” view of the world.  I need an additional constraint that rejects things like Array&lt;UIView&gt;.  (T would obviously also be constrained by a protocol that exposes the properties or methods my function requires to compute its result)<br></p><p>In general, it would be used where you need to ensure that the result of any operation observing the state of any part of the aggregate value will always return the same value at any point in the future.  If I observe a[0].foo now I know with certainty the result of observing a[0].foo at any point in the future.  This aspect of preservation of observed values across time is essential to the distinction between Array&lt;LayoutValue&gt; (see below) and Array&lt;UIView&gt;.  It doesn’t matter when I observe the frames of the elements of Array&lt;LayoutValue&gt;, I will always get the same rects back.  With Array&lt;UIView&gt; that is obviously not the case as the frame of the view could be mutated by anyone with a reference to the views at any time in between my observations of the frame values.<br></p><p>struct LayoutValue {<br>	frame: CGRect<br>}<br></p><p><br>&gt; <br>&gt;&gt;            let t = MyClass()<br>&gt;&gt;            foo.acceptWrapped(Wrap(t))<br>&gt;&gt;            t.mutate()<br>&gt;&gt; <br>&gt;&gt;            In this example, foo had better not depend on the wrapped instance<br>&gt;&gt;            not<br>&gt;&gt;            getting<br>&gt;&gt;            mutated.<br>&gt;&gt; <br>&gt;&gt;            foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;            anything about it.<br>&gt;&gt; <br>&gt;&gt;            Ok, but this is a toy example. What is the purpose of Wrap? Maybe<br>&gt;&gt;            foo<br>&gt;&gt;            passes the<br>&gt;&gt;            wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;            instance. My<br>&gt;&gt;            point was that shared mutable state is still possible here. <br>&gt;&gt; <br>&gt;&gt;            And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have<br>&gt;&gt;            let<br>&gt;&gt;            it construct the T in its init rather than accepting a T parameter)<br>&gt;&gt;            and<br>&gt;&gt;            the fact that it&#39;s *possible* to code something with the structure<br>&gt;&gt;            of<br>&gt;&gt;            Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt; <br>&gt;&gt;            The point I am trying to make is that the semantic properties of<br>&gt;&gt;            Wrap&lt;T&gt; depend<br>&gt;&gt;            on the semantic properties of T (whether or not non-local mutation<br>&gt;&gt;            may be<br>&gt;&gt;            observed in this case). <br>&gt;&gt; <br>&gt;&gt;        No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt;        semantic properties of T. This was in answer to what you said:<br>&gt;&gt; <br>&gt;&gt;                A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;            “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;            guarantees usually associated with value semantics (won’t<br>&gt;&gt;            mutate behind your back, thread safe, etc).<br>&gt;&gt; <br>&gt;&gt;        I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt;        and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt;        mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt;        in the category you&#39;re trying to describe. What are the properties of<br>&gt;&gt;        types in that category, and what generic code would depend on those<br>&gt;&gt;        properties?<br>&gt; <br>&gt; Again, the key questions are above, asked a different way.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; <br>&gt;&gt; You haven&#39;t answered this question.  How would you use this protocol?<br>&gt;<br>&gt; I think the best example was given by Andy when discussing pure<br>&gt; functions.  Maybe I want to write a generic function and ensure it is<br>&gt; pure.  I can only do this if I know that any arguments received that<br>&gt; compare equal will always present the same observable state.  <br></p><p>And that it doesn&#39;t touch any globals.<br></p><p>&gt; For example, maybe I wish to memoize the result.<br>&gt;<br>&gt; I cannot write such a function for all T, and I also cannot write such<br>&gt; a function for all T that have value semantics if we adopt the<br>&gt; “references are values” view of the world.  <br></p><p>Oh, you absolutely can, because if the function applies to all T that<br>have value semantics, it only has a few operations to work with:<br>initialization, assignment, and equality.  Assignment is the only<br>mutating one of these.<br></p><p>&gt; I need an additional constraint that rejects things like<br>&gt; Array&lt;UIView&gt;.  (T would obviously also be constrained by a protocol<br>&gt; that exposes the properties or methods my function requires to compute<br>&gt; its result)<br></p><p>Did you just start referring to T as the element type of the array<br>instead of the function&#39;s parameter type?  I think you&#39;re<br>unintentionally pulling a fast one, reasoning-wise.  It might help to<br>write down some actual code.<br></p><p>&gt; In general, it would be used where you need to ensure that the result<br>&gt; of any operation observing the state of any part of the aggregate<br>&gt; value will always return the same value at any point in the future.<br>&gt; If I observe a[0].foo now I know with certainty the result of<br>&gt; observing a[0].foo at any point in the future.  <br></p><p>Sure, but what you need then is a constraint on a&#39;s Element type that it<br>has value semantics, not some kind of new PureValue concept to use as a<br>constraint on the array itself.  <br></p><p>&gt; This aspect of preservation of observed values across time is<br>&gt; essential to the distinction between Array&lt;LayoutValue&gt; (see below)<br>&gt; and Array&lt;UIView&gt;.  It doesn’t matter when I observe the frames of the<br>&gt; elements of Array&lt;LayoutValue&gt;, I will always get the same rects back.<br>&gt; With Array&lt;UIView&gt; that is obviously not the case as the frame of the<br>&gt; view could be mutated by anyone with a reference to the views at any<br>&gt; time in between my observations of the frame values.<br>&gt;<br>&gt; struct LayoutValue {<br>&gt; 	frame: CGRect<br>&gt; }<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;            let t = MyClass()<br>&gt;&gt;&gt;            foo.acceptWrapped(Wrap(t))<br>&gt;&gt;&gt;            t.mutate()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            In this example, foo had better not depend on the wrapped instance<br>&gt;&gt;&gt;            not<br>&gt;&gt;&gt;            getting<br>&gt;&gt;&gt;            mutated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;&gt;            anything about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            Ok, but this is a toy example. What is the purpose of Wrap? Maybe<br>&gt;&gt;&gt;            foo<br>&gt;&gt;&gt;            passes the<br>&gt;&gt;&gt;            wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;&gt;            instance. My<br>&gt;&gt;&gt;            point was that shared mutable state is still possible here. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have<br>&gt;&gt;&gt;            let<br>&gt;&gt;&gt;            it construct the T in its init rather than accepting a T parameter)<br>&gt;&gt;&gt;            and<br>&gt;&gt;&gt;            the fact that it&#39;s *possible* to code something with the structure<br>&gt;&gt;&gt;            of<br>&gt;&gt;&gt;            Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            The point I am trying to make is that the semantic properties of<br>&gt;&gt;&gt;            Wrap&lt;T&gt; depend<br>&gt;&gt;&gt;            on the semantic properties of T (whether or not non-local mutation<br>&gt;&gt;&gt;            may be<br>&gt;&gt;&gt;            observed in this case). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt;&gt;        semantic properties of T. This was in answer to what you said:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;            “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;&gt;            guarantees usually associated with value semantics (won’t<br>&gt;&gt;&gt;            mutate behind your back, thread safe, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt;&gt;        and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt;&gt;        mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt;&gt;        in the category you&#39;re trying to describe. What are the properties of<br>&gt;&gt;&gt;        types in that category, and what generic code would depend on those<br>&gt;&gt;&gt;        properties?<br>&gt;&gt; <br>&gt;&gt; Again, the key questions are above, asked a different way.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 8, 2016, at 1:02 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You haven&#39;t answered this question.  How would you use this protocol?<br>&gt;&gt; <br>&gt;&gt; I think the best example was given by Andy when discussing pure<br>&gt;&gt; functions.  Maybe I want to write a generic function and ensure it is<br>&gt;&gt; pure.  I can only do this if I know that any arguments received that<br>&gt;&gt; compare equal will always present the same observable state.  <br>&gt; <br>&gt; And that it doesn&#39;t touch any globals.<br>&gt; <br>&gt;&gt; For example, maybe I wish to memoize the result.<br>&gt;&gt; <br>&gt;&gt; I cannot write such a function for all T, and I also cannot write such<br>&gt;&gt; a function for all T that have value semantics if we adopt the<br>&gt;&gt; “references are values” view of the world.  <br>&gt; <br>&gt; Oh, you absolutely can, because if the function applies to all T that<br>&gt; have value semantics, it only has a few operations to work with:<br>&gt; initialization, assignment, and equality.  Assignment is the only<br>&gt; mutating one of these.<br></p><p>I was implicitly assuming additional constraints exposing other behavior.  I should have stated that explicitly.<br></p><p>&gt; <br>&gt;&gt; I need an additional constraint that rejects things like<br>&gt;&gt; Array&lt;UIView&gt;.  (T would obviously also be constrained by a protocol<br>&gt;&gt; that exposes the properties or methods my function requires to compute<br>&gt;&gt; its result)<br>&gt; <br>&gt; Did you just start referring to T as the element type of the array<br>&gt; instead of the function&#39;s parameter type?  I think you&#39;re<br>&gt; unintentionally pulling a fast one, reasoning-wise.  It might help to<br>&gt; write down some actual code.<br></p><p>I was intending to refer to T as the element type of the array all along.  The signature I was thinking of would look something like:<br></p><p>pure foo&lt;T&gt;(bar: [T]) -&gt; SomeReturnType<br></p><p>I should have written this down to be clear about it.<br></p><p>&gt; <br>&gt;&gt; In general, it would be used where you need to ensure that the result<br>&gt;&gt; of any operation observing the state of any part of the aggregate<br>&gt;&gt; value will always return the same value at any point in the future.<br>&gt;&gt; If I observe a[0].foo now I know with certainty the result of<br>&gt;&gt; observing a[0].foo at any point in the future.  <br>&gt; <br>&gt; Sure, but what you need then is a constraint on a&#39;s Element type that it<br>&gt; has value semantics, not some kind of new PureValue concept to use as a<br>&gt; constraint on the array itself.  <br></p><p>That works if you follow all observable paths until you get to scalars.  For example maybe A’s element is Array&lt;Array&lt;UIView&gt;&gt; and `foo ` is implemented in an extension off Array where Element == UIVIew (after we get same type constraints).  Once we have conditional conformance that extension could conform to a protocol that makes `foo` visible and it would still have value semantics but it would not be a pure value.<br></p><p>&gt; <br>&gt;&gt; This aspect of preservation of observed values across time is<br>&gt;&gt; essential to the distinction between Array&lt;LayoutValue&gt; (see below)<br>&gt;&gt; and Array&lt;UIView&gt;.  It doesn’t matter when I observe the frames of the<br>&gt;&gt; elements of Array&lt;LayoutValue&gt;, I will always get the same rects back.<br>&gt;&gt; With Array&lt;UIView&gt; that is obviously not the case as the frame of the<br>&gt;&gt; view could be mutated by anyone with a reference to the views at any<br>&gt;&gt; time in between my observations of the frame values.<br>&gt;&gt; <br>&gt;&gt; struct LayoutValue {<br>&gt;&gt; 	frame: CGRect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           let t = MyClass()<br>&gt;&gt;&gt;&gt;           foo.acceptWrapped(Wrap(t))<br>&gt;&gt;&gt;&gt;           t.mutate()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           In this example, foo had better not depend on the wrapped instance<br>&gt;&gt;&gt;&gt;           not<br>&gt;&gt;&gt;&gt;           getting<br>&gt;&gt;&gt;&gt;           mutated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;&gt;&gt;           anything about it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Ok, but this is a toy example. What is the purpose of Wrap? Maybe<br>&gt;&gt;&gt;&gt;           foo<br>&gt;&gt;&gt;&gt;           passes the<br>&gt;&gt;&gt;&gt;           wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;&gt;&gt;           instance. My<br>&gt;&gt;&gt;&gt;           point was that shared mutable state is still possible here. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have<br>&gt;&gt;&gt;&gt;           let<br>&gt;&gt;&gt;&gt;           it construct the T in its init rather than accepting a T parameter)<br>&gt;&gt;&gt;&gt;           and<br>&gt;&gt;&gt;&gt;           the fact that it&#39;s *possible* to code something with the structure<br>&gt;&gt;&gt;&gt;           of<br>&gt;&gt;&gt;&gt;           Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           The point I am trying to make is that the semantic properties of<br>&gt;&gt;&gt;&gt;           Wrap&lt;T&gt; depend<br>&gt;&gt;&gt;&gt;           on the semantic properties of T (whether or not non-local mutation<br>&gt;&gt;&gt;&gt;           may be<br>&gt;&gt;&gt;&gt;           observed in this case). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt;&gt;&gt;&gt;       semantic properties of T. This was in answer to what you said:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;&gt;           “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;&gt;&gt;           guarantees usually associated with value semantics (won’t<br>&gt;&gt;&gt;&gt;           mutate behind your back, thread safe, etc).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt;&gt;&gt;       and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt;&gt;&gt;       mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt;&gt;&gt;       in the category you&#39;re trying to describe. What are the properties of<br>&gt;&gt;&gt;&gt;       types in that category, and what generic code would depend on those<br>&gt;&gt;&gt;&gt;       properties?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, the key questions are above, asked a different way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/a57108bf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 12:00:00pm</p></header><div class="content"><p>on Fri May 06 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;     On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         Swift’s collections also accomplish this through copying, but only when<br>&gt;         the<br>&gt;         elements they contain also have the same property. <br>&gt;<br>&gt;     Only if you think mutable class instances are part of the value of the<br>&gt;     array that stores references to those class instances. As I said<br>&gt;     earlier, you can *take* that point of view, but why would you want to?<br>&gt;     Today, we have left that question wide open, which makes the whole<br>&gt;     notion of what is a logical value very indistinct. I am proposing to<br>&gt;     close it.<br>&gt;<br>&gt;         On the other hand, it is immediately obvious that non-local mutation<br>&gt;         is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;         they are all uniquely referenced.<br>&gt;<br>&gt;     If you interpret the elements of the array as being *references* to<br>&gt;     objects, there is no possibility of non-local mutation. If you<br>&gt;     interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;     problems.<br>&gt;<br>&gt; This does not make sense, because you’ve got problems either way. You are<br>&gt; arguing, essentially, that everything is a value type because<br>&gt; references/pointers are a value. <br></p><p>I am arguing that every type can be viewed as a value, allowing us to<br>preserve a sense in which Array&lt;T&gt; has value semantics irrespective of<br>the details of T.<br></p><p>&gt; If that were the case then the *only* valid way to compare the<br>&gt; equality of types would be to compare their values. Overriding the<br>&gt; equality operator would inherently violate the property of<br>&gt; immutability, i.e. two immutable objects can change their equality<br>&gt; even without mutation of their “values&quot;.<br></p><p>Not at all.  In my world, you can override equality such that it<br>includes referenced storage when either:<br></p><p>1. the referenced storage will not be mutated<br>2. or, the referenced storage will only mutated when uniquely-referenced.<br></p><p>&gt;<br>&gt; func ==(lhs, rhs) {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; class MyClass {<br>&gt; var a: Int<br>&gt; ...<br>&gt;<br>&gt; } <br>&gt;<br>&gt; let x = MyClass(a: 5)<br>&gt; let y = MyClass(a: 5)<br>&gt;<br>&gt; x == y // true<br>&gt; y.a = 6<br>&gt; x == y // false<br></p><p>I don&#39;t understand what point you&#39;re trying to make, here.  I see that x<br>and y are immutable. Notwithstanding the fact that the language tries to<br>hide the difference between a reference and the instance to which it<br>refers from the user (the difference would be clearer if you had to<br>write y-&gt;a = 6 as in C, but it&#39;s still there), that immutability doesn&#39;t<br>extend beyond the variable binding.  The class instance to which y<br>refers, as you&#39;ve ably demonstrated, is mutable.<br></p><p>&gt;     Are you arguing that reference types should be equatable by default,<br>&gt;     using<br>&gt;     equality of the reference if the type does not provide a custom<br>&gt;     definition of<br>&gt;     equality?<br>&gt;<br>&gt;     Yes!!<br>&gt;<br>&gt; Custom definitions of equality, inherently, decouple immutability from<br>&gt; equality,<br></p><p>Not a bit.  They certainly *can* do that, if we allow it, but I am<br>proposing to ban that.  There are still useful custom definitions of<br>equality as I have outlined above.<br></p><p>&gt; as shown above. Swift makes it appear as though references and values<br>&gt; are on the same level in a way that C does not.<br></p><p>Yep.  It&#39;s an illusion that breaks down at the edges and can be really<br>problematic if users fully embrace it.  You can&#39;t write a generic<br>algorithm with well-defined semantics that does mutation-by-part on<br>instances of T without constraining T to have value or reference semantics.<br></p><p>I am not advocating that we require “y-&gt;a” for class member access, but<br>I *am* suggesting that we should accept the fact that reference and<br>value semantics are fundamentally different and make design choices<br>(including language rules) accordingly.<br></p><p>&gt; let x = MyStruct()<br>&gt; let y = MyClass()<br>&gt;<br>&gt; x.myFoo<br>&gt; y.myFoo<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; my_struct *x = …<br>&gt; my_struct y = …<br>&gt;<br>&gt; x.my_foo<br>&gt; y-&gt;my_foo<br>&gt;<br>&gt; With C it is explicit that you are crossing a reference. Thus there is only<br>&gt; *one* type of equality in C, that the values *are equal*. <br></p><p>Well, C doesn&#39;t even *have* struct equality;<br>http://stackoverflow.com/a/141724<br></p><p>&gt; This exactly the type of equality you are referring to, but this does<br>&gt; not carry over to Swift for precisely the reason that Swift paves over<br>&gt; the difference between value and reference types, and then allows you<br>&gt; to redefine equality.<br>&gt;<br>&gt; Therefore, in essentially no circumstances does it make sense to<br>&gt; compare a type by its reference if it has any associated data in<br>&gt; Swift. <br></p><p>Disagreed.  Instances whose *identity* is significant, i.e. basically<br>everything that actually ought to be a class, can be very usefully<br>compared by their references.  For example, if equality and hashing were<br>defined for UIViews, based on their references, you could use a<br>Set&lt;UIView&gt; to keep track of which views had user interaction during a<br>given time interval.<br></p><p>&gt; Basically, if it will be commonplace to override the equality operator<br>&gt; to compare the first level of associated values of a reference type,<br>&gt; then the comparison of just the reference has no business being the<br>&gt; default.<br>&gt;<br>&gt; If the default equality for reference types was defined as the equality of the<br>&gt; references it would be inconsistent with the Swift’s current apparent surfacing<br>&gt; of the first level of associated data for reference types.<br></p><p>Yes, but as I&#39;ve said, that illusion doesn&#39;t work in the presence of<br>mutability.<br></p><p>&gt;         I think perhaps what you mean by “purity” is just, “has value<br>&gt;         semantics.” But I could be wrong.<br>&gt;<br>&gt;         No, an array storing instances of reference types that are not immutable<br>&gt;         would<br>&gt;         not be “pure” (or whatever you want to call it).<br>&gt;<br>&gt;         is derived from deep value semantics. This is when there is no<br>&gt;         possibility of shared mutable state. This is an extremely important<br>&gt;         property.<br>&gt;<br>&gt;         It&#39;s the wrong property, IMO.<br>&gt;<br>&gt;         Wrong in what sense? <br>&gt;<br>&gt;         Wrong in the sense that it rules out using things like Array that are<br>&gt;         logically value types but happen to be implemented with CoW, and if you<br>&gt;         have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;         anything other than values, so it would be extremely limiting. <br>&gt;<br>&gt;         I’m a big fan of CoW as an implementation detail. We have definitely<br>&gt;         been<br>&gt;         miscommunicating if you thought I was suggesting something that would<br>&gt;         prohibit<br>&gt;         CoW.<br>&gt;<br>&gt;     Then what, precisely, are the syntactic and semantic requirements of<br>&gt;     “PureValue?”<br>&gt;<br>&gt; I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references<br>&gt; form a subgraph, within which a change to any of the values would constitute a<br>&gt; change in the value of A (thus impermissible if A is immutable). Thus structs<br>&gt; would quality as “PureValues”.<br></p><p>OK, one vote for that interpretation noted.<br></p><p>&gt; I also assume that enforcing immutability on an object graph, via CoW<br>&gt; or otherwise, would be unfeasible. <br></p><p>I presume by “enforcing” you mean, “enforcing by the compiler.”  It&#39;s<br>very easy to enforce that for particular object graphs in library code,<br>using encapsulation.<br></p><p>&gt; You could enforce it on all values accessible by traversing a single<br>&gt; reference for reference types, however.<br>&gt;<br>&gt; This is why I don’t really buy the argument that there is no such this<br>&gt; as deep vs shallow copy. Deep copy means copying the whole “PureValue”<br>&gt; or subgraph, shallow copy means traversing a single reference and<br>&gt; copying all accessible values.<br></p><p>Well, again, “you can look at the world that way, but why would you want<br>to?”  It makes reasoning about code exponentially more difficult if at<br>every level you have to ask whether a copy is deep or shallow.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 12:52 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri May 06 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        Swift’s collections also accomplish this through copying, but only when<br>&gt;&gt;        the<br>&gt;&gt;        elements they contain also have the same property. <br>&gt;&gt; <br>&gt;&gt;    Only if you think mutable class instances are part of the value of the<br>&gt;&gt;    array that stores references to those class instances. As I said<br>&gt;&gt;    earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt;    Today, we have left that question wide open, which makes the whole<br>&gt;&gt;    notion of what is a logical value very indistinct. I am proposing to<br>&gt;&gt;    close it.<br>&gt;&gt; <br>&gt;&gt;        On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;        is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;        they are all uniquely referenced.<br>&gt;&gt; <br>&gt;&gt;    If you interpret the elements of the array as being *references* to<br>&gt;&gt;    objects, there is no possibility of non-local mutation. If you<br>&gt;&gt;    interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt;    problems.<br>&gt;&gt; <br>&gt;&gt; This does not make sense, because you’ve got problems either way. You are<br>&gt;&gt; arguing, essentially, that everything is a value type because<br>&gt;&gt; references/pointers are a value. <br>&gt; <br>&gt; I am arguing that every type can be viewed as a value, allowing us to<br>&gt; preserve a sense in which Array&lt;T&gt; has value semantics irrespective of<br>&gt; the details of T.<br>&gt; <br>&gt;&gt; If that were the case then the *only* valid way to compare the<br>&gt;&gt; equality of types would be to compare their values. Overriding the<br>&gt;&gt; equality operator would inherently violate the property of<br>&gt;&gt; immutability, i.e. two immutable objects can change their equality<br>&gt;&gt; even without mutation of their “values&quot;.<br>&gt; <br>&gt; Not at all.  In my world, you can override equality such that it<br>&gt; includes referenced storage when either:<br>&gt; <br>&gt; 1. the referenced storage will not be mutated<br>&gt; 2. or, the referenced storage will only mutated when uniquely-referenced.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; func ==(lhs, rhs) {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MyClass {<br>&gt;&gt; var a: Int<br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; let x = MyClass(a: 5)<br>&gt;&gt; let y = MyClass(a: 5)<br>&gt;&gt; <br>&gt;&gt; x == y // true<br>&gt;&gt; y.a = 6<br>&gt;&gt; x == y // false<br>&gt; <br>&gt; I don&#39;t understand what point you&#39;re trying to make, here.  I see that x<br>&gt; and y are immutable. Notwithstanding the fact that the language tries to<br>&gt; hide the difference between a reference and the instance to which it<br>&gt; refers from the user (the difference would be clearer if you had to<br>&gt; write y-&gt;a = 6 as in C, but it&#39;s still there), that immutability doesn&#39;t<br>&gt; extend beyond the variable binding.  The class instance to which y<br>&gt; refers, as you&#39;ve ably demonstrated, is mutable.<br>&gt; <br></p><p>The point I’m trying to make is that in the above code, I am able to violate rule 1 of your world insofar as I am including referenced storage in my definition of equality which can be mutated even though my reference is immutable.<br></p><p>&gt;&gt;    Are you arguing that reference types should be equatable by default,<br>&gt;&gt;    using<br>&gt;&gt;    equality of the reference if the type does not provide a custom<br>&gt;&gt;    definition of<br>&gt;&gt;    equality?<br>&gt;&gt; <br>&gt;&gt;    Yes!!<br>&gt;&gt; <br>&gt;&gt; Custom definitions of equality, inherently, decouple immutability from<br>&gt;&gt; equality,<br>&gt; <br>&gt; Not a bit.  They certainly *can* do that, if we allow it, but I am<br>&gt; proposing to ban that.  There are still useful custom definitions of<br>&gt; equality as I have outlined above.<br></p><p>If you’re proposing to ban that, then I may have misunderstood your position. I think we are in agreement on that, however… (more below)<br></p><p>&gt; <br>&gt;&gt; as shown above. Swift makes it appear as though references and values<br>&gt;&gt; are on the same level in a way that C does not.<br>&gt; <br>&gt; Yep.  It&#39;s an illusion that breaks down at the edges and can be really<br>&gt; problematic if users fully embrace it.  You can&#39;t write a generic<br>&gt; algorithm with well-defined semantics that does mutation-by-part on<br>&gt; instances of T without constraining T to have value or reference semantics.<br>&gt; <br>&gt; I am not advocating that we require “y-&gt;a” for class member access, but<br>&gt; I *am* suggesting that we should accept the fact that reference and<br>&gt; value semantics are fundamentally different and make design choices<br>&gt; (including language rules) accordingly.<br>&gt; <br>&gt;&gt; let x = MyStruct()<br>&gt;&gt; let y = MyClass()<br>&gt;&gt; <br>&gt;&gt; x.myFoo<br>&gt;&gt; y.myFoo<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; my_struct *x = …<br>&gt;&gt; my_struct y = …<br>&gt;&gt; <br>&gt;&gt; x.my_foo<br>&gt;&gt; y-&gt;my_foo<br>&gt;&gt; <br>&gt;&gt; With C it is explicit that you are crossing a reference. Thus there is only<br>&gt;&gt; *one* type of equality in C, that the values *are equal*. <br>&gt; <br>&gt; Well, C doesn&#39;t even *have* struct equality;<br>&gt; http://stackoverflow.com/a/141724<br>&gt; <br>&gt;&gt; This exactly the type of equality you are referring to, but this does<br>&gt;&gt; not carry over to Swift for precisely the reason that Swift paves over<br>&gt;&gt; the difference between value and reference types, and then allows you<br>&gt;&gt; to redefine equality.<br>&gt;&gt; <br>&gt;&gt; Therefore, in essentially no circumstances does it make sense to<br>&gt;&gt; compare a type by its reference if it has any associated data in<br>&gt;&gt; Swift. <br>&gt; <br>&gt; Disagreed.  Instances whose *identity* is significant, i.e. basically<br>&gt; everything that actually ought to be a class, can be very usefully<br>&gt; compared by their references.  For example, if equality and hashing were<br>&gt; defined for UIViews, based on their references, you could use a<br>&gt; Set&lt;UIView&gt; to keep track of which views had user interaction during a<br>&gt; given time interval.<br></p><p>This use case is exploiting the fact that the reference is a unique identifier for a view. For any distributed application this is no longer true for objects. Equality should be used to uniquely define data.<br></p><p>In a non-distributed application comparing references is also an implicit comparison of the entire object graph referenced by that reference. When you allow any other definition of equality for reference types, unless that comparison explicitly includes all values in the each of the object’s referenced object graphs, it is only *partial* equality. Thus custom equality is a lie that should probably be expressed with something more like ~=. It’s only equal up to the boundary, which is arbitrarily defined. <br></p><p>So yes, I agree that at least equality should be consistent with immutability, but in my opinion the only way to accomplish that is to ban custom equality.<br></p><p>I’m of the opinion that there are only two ways of accomplishing this.<br></p><p>EITHER<br></p><p>One could imagine a definition of equality that did explore the entire object graph comparing values (only using references to find other values, not for comparison) as it went. However, this this would not be able to align with the semantics of immutability (maybe by only allowing a single entry point into the graph which was guaranteed to be a unique reference?).<br></p><p>OR<br></p><p>=== should be the only valid equality operator for classes (and you’re right it should be spelled ==), and that if you want to compare classes you should just put all of the data that acts as the “identity” of that class in a value type which can be compared by value. Value types could then have generated equality operators based on the equality of each of their constituent values, some of which could be references (but as I mentioned including references in the identity does not work for distributed applications).<br></p><p>let x = MyClass(…)<br>let y = MyClass(…)<br></p><p>x.identityStruct == y.identityStruct<br></p><p>As it stands now in Swift, a class is more than just a reference. It also includes all sorts of assumptions about it’s associated data based on the fact that a class “pretends” to include the data it’s associated with. Hence the need for custom equality operators.<br></p><p>I really think we’re on the same page here, probably. Or at least in the same book.<br></p><p>&gt; There are still useful custom definitions of<br>&gt; equality as I have outlined above.<br></p><p>I think I am missing these. Could you provide an example?<br></p><p>&gt; <br>&gt;&gt; Basically, if it will be commonplace to override the equality operator<br>&gt;&gt; to compare the first level of associated values of a reference type,<br>&gt;&gt; then the comparison of just the reference has no business being the<br>&gt;&gt; default.<br>&gt;&gt; <br>&gt;&gt; If the default equality for reference types was defined as the equality of the<br>&gt;&gt; references it would be inconsistent with the Swift’s current apparent surfacing<br>&gt;&gt; of the first level of associated data for reference types.<br>&gt; <br>&gt; Yes, but as I&#39;ve said, that illusion doesn&#39;t work in the presence of<br>&gt; mutability.<br>&gt; <br>&gt;&gt;        I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;        semantics.” But I could be wrong.<br>&gt;&gt; <br>&gt;&gt;        No, an array storing instances of reference types that are not immutable<br>&gt;&gt;        would<br>&gt;&gt;        not be “pure” (or whatever you want to call it).<br>&gt;&gt; <br>&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;        property.<br>&gt;&gt; <br>&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt; <br>&gt;&gt;        Wrong in what sense? <br>&gt;&gt; <br>&gt;&gt;        Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;        logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;        have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;        anything other than values, so it would be extremely limiting. <br>&gt;&gt; <br>&gt;&gt;        I’m a big fan of CoW as an implementation detail. We have definitely<br>&gt;&gt;        been<br>&gt;&gt;        miscommunicating if you thought I was suggesting something that would<br>&gt;&gt;        prohibit<br>&gt;&gt;        CoW.<br>&gt;&gt; <br>&gt;&gt;    Then what, precisely, are the syntactic and semantic requirements of<br>&gt;&gt;    “PureValue?”<br>&gt;&gt; <br>&gt;&gt; I assume what is meant by &quot;PureValue&quot;, is any object A, whose own references<br>&gt;&gt; form a subgraph, within which a change to any of the values would constitute a<br>&gt;&gt; change in the value of A (thus impermissible if A is immutable). Thus structs<br>&gt;&gt; would quality as “PureValues”.<br>&gt; <br>&gt; OK, one vote for that interpretation noted.<br>&gt; <br>&gt;&gt; I also assume that enforcing immutability on an object graph, via CoW<br>&gt;&gt; or otherwise, would be unfeasible. <br>&gt; <br>&gt; I presume by “enforcing” you mean, “enforcing by the compiler.”  It&#39;s<br>&gt; very easy to enforce that for particular object graphs in library code,<br>&gt; using encapsulation.<br></p><p>Yes, I do mean by the compiler, but you are right you can enforce this by hiding whatever you’d like behind inaccessible values.<br></p><p>&gt; <br>&gt;&gt; You could enforce it on all values accessible by traversing a single<br>&gt;&gt; reference for reference types, however.<br>&gt;&gt; <br>&gt;&gt; This is why I don’t really buy the argument that there is no such this<br>&gt;&gt; as deep vs shallow copy. Deep copy means copying the whole “PureValue”<br>&gt;&gt; or subgraph, shallow copy means traversing a single reference and<br>&gt;&gt; copying all accessible values.<br>&gt; <br>&gt; Well, again, “you can look at the world that way, but why would you want<br>&gt; to?”  It makes reasoning about code exponentially more difficult if at<br>&gt; every level you have to ask whether a copy is deep or shallow.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 10:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;&gt; On May 7, 2016, at 12:52 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 06 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Swift’s collections also accomplish this through copying, but only when<br>&gt;&gt;&gt;        the<br>&gt;&gt;&gt;        elements they contain also have the same property. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Only if you think mutable class instances are part of the value of the<br>&gt;&gt;&gt;    array that stores references to those class instances. As I said<br>&gt;&gt;&gt;    earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt;&gt;    Today, we have left that question wide open, which makes the whole<br>&gt;&gt;&gt;    notion of what is a logical value very indistinct. I am proposing to<br>&gt;&gt;&gt;    close it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt;        is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt;        they are all uniquely referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    If you interpret the elements of the array as being *references* to<br>&gt;&gt;&gt;    objects, there is no possibility of non-local mutation. If you<br>&gt;&gt;&gt;    interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt;&gt;    problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This does not make sense, because you’ve got problems either way. You are<br>&gt;&gt;&gt; arguing, essentially, that everything is a value type because<br>&gt;&gt;&gt; references/pointers are a value. <br>&gt;&gt; <br>&gt;&gt; I am arguing that every type can be viewed as a value, allowing us to<br>&gt;&gt; preserve a sense in which Array&lt;T&gt; has value semantics irrespective of<br>&gt;&gt; the details of T.<br>&gt;&gt; <br>&gt;&gt;&gt; If that were the case then the *only* valid way to compare the<br>&gt;&gt;&gt; equality of types would be to compare their values. Overriding the<br>&gt;&gt;&gt; equality operator would inherently violate the property of<br>&gt;&gt;&gt; immutability, i.e. two immutable objects can change their equality<br>&gt;&gt;&gt; even without mutation of their “values&quot;.<br>&gt;&gt; <br>&gt;&gt; Not at all.  In my world, you can override equality such that it<br>&gt;&gt; includes referenced storage when either:<br>&gt;&gt; <br>&gt;&gt; 1. the referenced storage will not be mutated<br>&gt;&gt; 2. or, the referenced storage will only mutated when uniquely-referenced.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs, rhs) {<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt; var a: Int<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = MyClass(a: 5)<br>&gt;&gt;&gt; let y = MyClass(a: 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x == y // true<br>&gt;&gt;&gt; y.a = 6<br>&gt;&gt;&gt; x == y // false<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand what point you&#39;re trying to make, here.  I see that x<br>&gt;&gt; and y are immutable. Notwithstanding the fact that the language tries to<br>&gt;&gt; hide the difference between a reference and the instance to which it<br>&gt;&gt; refers from the user (the difference would be clearer if you had to<br>&gt;&gt; write y-&gt;a = 6 as in C, but it&#39;s still there), that immutability doesn&#39;t<br>&gt;&gt; extend beyond the variable binding.  The class instance to which y<br>&gt;&gt; refers, as you&#39;ve ably demonstrated, is mutable.<br>&gt;<br>&gt; The point I’m trying to make is that in the above code, I am able to<br>&gt; violate rule 1 of your world insofar as I am including referenced<br>&gt; storage in my definition of equality which can be mutated even though<br>&gt; my reference is immutable.<br></p><p>Sorry, I guess I don&#39;t understand what difference it makes that it&#39;s<br>possible to write code that violates my rules.  It&#39;s not news to me, as<br>I&#39;m sure you knew when you posted it.<br></p><p>&gt;&gt;&gt;    Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;    using<br>&gt;&gt;&gt;    equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;    definition of<br>&gt;&gt;&gt;    equality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Custom definitions of equality, inherently, decouple immutability from<br>&gt;&gt;&gt; equality,<br>&gt;&gt; <br>&gt;&gt; Not a bit.  They certainly *can* do that, if we allow it, but I am<br>&gt;&gt; proposing to ban that.  There are still useful custom definitions of<br>&gt;&gt; equality as I have outlined above.<br>&gt;<br>&gt; If you’re proposing to ban that, then I may have misunderstood your<br>&gt; position. I think we are in agreement on that, however… (more below)<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; as shown above. Swift makes it appear as though references and values<br>&gt;&gt;&gt; are on the same level in a way that C does not.<br>&gt;&gt; <br>&gt;&gt; Yep.  It&#39;s an illusion that breaks down at the edges and can be really<br>&gt;&gt; problematic if users fully embrace it.  You can&#39;t write a generic<br>&gt;&gt; algorithm with well-defined semantics that does mutation-by-part on<br>&gt;&gt; instances of T without constraining T to have value or reference semantics.<br>&gt;&gt; <br>&gt;&gt; I am not advocating that we require “y-&gt;a” for class member access, but<br>&gt;&gt; I *am* suggesting that we should accept the fact that reference and<br>&gt;&gt; value semantics are fundamentally different and make design choices<br>&gt;&gt; (including language rules) accordingly.<br>&gt;&gt; <br>&gt;&gt;&gt; let x = MyStruct()<br>&gt;&gt;&gt; let y = MyClass()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x.myFoo<br>&gt;&gt;&gt; y.myFoo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; my_struct *x = …<br>&gt;&gt;&gt; my_struct y = …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x.my_foo<br>&gt;&gt;&gt; y-&gt;my_foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With C it is explicit that you are crossing a reference. Thus there is only<br>&gt;&gt;&gt; *one* type of equality in C, that the values *are equal*. <br>&gt;&gt; <br>&gt;&gt; Well, C doesn&#39;t even *have* struct equality;<br>&gt;&gt; http://stackoverflow.com/a/141724<br>&gt;&gt; <br>&gt;&gt;&gt; This exactly the type of equality you are referring to, but this does<br>&gt;&gt;&gt; not carry over to Swift for precisely the reason that Swift paves over<br>&gt;&gt;&gt; the difference between value and reference types, and then allows you<br>&gt;&gt;&gt; to redefine equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, in essentially no circumstances does it make sense to<br>&gt;&gt;&gt; compare a type by its reference if it has any associated data in<br>&gt;&gt;&gt; Swift. <br>&gt;&gt; <br>&gt;&gt; Disagreed.  Instances whose *identity* is significant, i.e. basically<br>&gt;&gt; everything that actually ought to be a class, can be very usefully<br>&gt;&gt; compared by their references.  For example, if equality and hashing were<br>&gt;&gt; defined for UIViews, based on their references, you could use a<br>&gt;&gt; Set&lt;UIView&gt; to keep track of which views had user interaction during a<br>&gt;&gt; given time interval.<br>&gt;<br>&gt; This use case is exploiting the fact that the reference is a unique<br>&gt; identifier for a view. <br></p><p>That&#39;s a fundamental property of class instances.<br></p><p>&gt; For any distributed application this is no longer true for objects.<br></p><p>That certainly depends on your programming model for distributed<br>applications.  If you want to try to maintain the illusion that there&#39;s<br>really only one object when you have a pair communicating across a<br>process or machine boundary, or that a given object travels across<br>process or machine boundaries, *and* you want to build a Set that<br>“holds” objects that may live in other processes, then yes, you&#39;ll need<br>a different system.  <br></p><p>&gt; Equality should be used to uniquely define data.<br></p><p>A mutable thing that has no identity apart from its value is a value<br>type.  Don&#39;t use classes for that, or everything breaks down, because a<br>mutable class always eventually reveals that it&#39;s not a value.<br></p><p>&gt; In a non-distributed application comparing references is also an<br>&gt; implicit comparison of the entire object graph referenced by that<br>&gt; reference. <br></p><p>I don&#39;t think so.  It&#39;s possible for references x and y to have exactly<br>isomorphic object graphs, but still x !=== y.<br></p><p>&gt; When you allow any other definition of equality for reference types,<br>&gt; unless that comparison explicitly includes all values in the each of<br>&gt; the object’s referenced object graphs, it is only *partial*<br>&gt; equality. <br></p><p>It still might not be equality.  Equal things should be effectively<br>interchangeable (except for parts explicitly designated inessential,<br>such as an Array&#39;s capacity).  As soon as you expose identity, that<br>falls apart.<br></p><p>&gt; Thus custom equality is a lie that should probably be expressed with<br>&gt; something more like ~=. It’s only equal up to the boundary, which is<br>&gt; arbitrarily defined.<br>&gt;<br>&gt; So yes, I agree that at least equality should be consistent with<br>&gt; immutability, but in my opinion the only way to accomplish that is to<br>&gt; ban custom equality.<br></p><p>For all types, or for reference types?  I&#39;d be totally OK with banning<br>it for reference types.  I&#39;d disagree strongly with banning it for all<br>types.<br></p><p>&gt; I’m of the opinion that there are only two ways of accomplishing this.<br>&gt;<br>&gt; EITHER<br>&gt;<br>&gt; One could imagine a definition of equality that did explore the entire<br>&gt; object graph comparing values (only using references to find other<br>&gt; values, not for comparison) as it went. However, this this would not<br>&gt; be able to align with the semantics of immutability (maybe by only<br>&gt; allowing a single entry point into the graph which was guaranteed to<br>&gt; be a unique reference?).<br>&gt;<br>&gt; OR<br>&gt;<br>&gt; === should be the only valid equality operator for classes (and you’re<br>&gt; right it should be spelled ==), and that if you want to compare<br>&gt; classes you should just put all of the data that acts as the<br>&gt; “identity” of that class in a value type which can be compared by<br>&gt; value. Value types could then have generated equality operators based<br>&gt; on the equality of each of their constituent values, some of which<br>&gt; could be references (but as I mentioned including references in the<br>&gt; identity does not work for distributed applications).<br>&gt;<br>&gt; let x = MyClass(…)<br>&gt; let y = MyClass(…)<br>&gt;<br>&gt; x.identityStruct == y.identityStruct<br>&gt;<br>&gt; As it stands now in Swift, a class is more than just a reference. It<br>&gt; also includes all sorts of assumptions about it’s associated data<br>&gt; based on the fact that a class “pretends” to include the data it’s<br>&gt; associated with. Hence the need for custom equality operators.<br>&gt;<br>&gt; I really think we’re on the same page here, probably. Or at least in<br>&gt; the same book.<br></p><p>Yes, although I don&#39;t understand a lot of what you&#39;re saying and my<br>instinct is that arguments about “whole object graph” are barking up the<br>wrong tree, or at least making it more complicated than necessary.<br></p><p>&gt;&gt; There are still useful custom definitions of<br>&gt;&gt; equality as I have outlined above.<br>&gt;<br>&gt; I think I am missing these. Could you provide an example?<br></p><p>,----[ quoting myself ]<br>| In my world, you can override equality such that it<br>| includes referenced storage when either:<br>| <br>| 1. the referenced storage will not be mutated<br>| 2. or, the referenced storage will only mutated when uniquely-referenced.<br>`----<br></p><p>Array&lt;T&gt; has a custom equality operator; IMO that&#39;s indispensable.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  8, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 7, 2016, at 10:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 7, 2016, at 12:52 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri May 06 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 6, 2016, at 6:54 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;   &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Swift’s collections also accomplish this through copying, but only when<br>&gt;&gt;&gt;&gt;       the<br>&gt;&gt;&gt;&gt;       elements they contain also have the same property. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Only if you think mutable class instances are part of the value of the<br>&gt;&gt;&gt;&gt;   array that stores references to those class instances. As I said<br>&gt;&gt;&gt;&gt;   earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt;&gt;&gt;   Today, we have left that question wide open, which makes the whole<br>&gt;&gt;&gt;&gt;   notion of what is a logical value very indistinct. I am proposing to<br>&gt;&gt;&gt;&gt;   close it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt;&gt;       is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt;&gt;       they are all uniquely referenced.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   If you interpret the elements of the array as being *references* to<br>&gt;&gt;&gt;&gt;   objects, there is no possibility of non-local mutation. If you<br>&gt;&gt;&gt;&gt;   interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt;&gt;&gt;   problems.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This does not make sense, because you’ve got problems either way. You are<br>&gt;&gt;&gt;&gt; arguing, essentially, that everything is a value type because<br>&gt;&gt;&gt;&gt; references/pointers are a value. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am arguing that every type can be viewed as a value, allowing us to<br>&gt;&gt;&gt; preserve a sense in which Array&lt;T&gt; has value semantics irrespective of<br>&gt;&gt;&gt; the details of T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If that were the case then the *only* valid way to compare the<br>&gt;&gt;&gt;&gt; equality of types would be to compare their values. Overriding the<br>&gt;&gt;&gt;&gt; equality operator would inherently violate the property of<br>&gt;&gt;&gt;&gt; immutability, i.e. two immutable objects can change their equality<br>&gt;&gt;&gt;&gt; even without mutation of their “values&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not at all.  In my world, you can override equality such that it<br>&gt;&gt;&gt; includes referenced storage when either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. the referenced storage will not be mutated<br>&gt;&gt;&gt; 2. or, the referenced storage will only mutated when uniquely-referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs, rhs) {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;&gt; var a: Int<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = MyClass(a: 5)<br>&gt;&gt;&gt;&gt; let y = MyClass(a: 5)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x == y // true<br>&gt;&gt;&gt;&gt; y.a = 6<br>&gt;&gt;&gt;&gt; x == y // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand what point you&#39;re trying to make, here.  I see that x<br>&gt;&gt;&gt; and y are immutable. Notwithstanding the fact that the language tries to<br>&gt;&gt;&gt; hide the difference between a reference and the instance to which it<br>&gt;&gt;&gt; refers from the user (the difference would be clearer if you had to<br>&gt;&gt;&gt; write y-&gt;a = 6 as in C, but it&#39;s still there), that immutability doesn&#39;t<br>&gt;&gt;&gt; extend beyond the variable binding.  The class instance to which y<br>&gt;&gt;&gt; refers, as you&#39;ve ably demonstrated, is mutable.<br>&gt;&gt; <br>&gt;&gt; The point I’m trying to make is that in the above code, I am able to<br>&gt;&gt; violate rule 1 of your world insofar as I am including referenced<br>&gt;&gt; storage in my definition of equality which can be mutated even though<br>&gt;&gt; my reference is immutable.<br>&gt; <br>&gt; Sorry, I guess I don&#39;t understand what difference it makes that it&#39;s<br>&gt; possible to write code that violates my rules.  It&#39;s not news to me, as<br>&gt; I&#39;m sure you knew when you posted it.<br>&gt; <br>&gt;&gt;&gt;&gt;   Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;&gt;   using<br>&gt;&gt;&gt;&gt;   equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;&gt;   definition of<br>&gt;&gt;&gt;&gt;   equality?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Yes!!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Custom definitions of equality, inherently, decouple immutability from<br>&gt;&gt;&gt;&gt; equality,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not a bit.  They certainly *can* do that, if we allow it, but I am<br>&gt;&gt;&gt; proposing to ban that.  There are still useful custom definitions of<br>&gt;&gt;&gt; equality as I have outlined above.<br>&gt;&gt; <br>&gt;&gt; If you’re proposing to ban that, then I may have misunderstood your<br>&gt;&gt; position. I think we are in agreement on that, however… (more below)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; as shown above. Swift makes it appear as though references and values<br>&gt;&gt;&gt;&gt; are on the same level in a way that C does not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep.  It&#39;s an illusion that breaks down at the edges and can be really<br>&gt;&gt;&gt; problematic if users fully embrace it.  You can&#39;t write a generic<br>&gt;&gt;&gt; algorithm with well-defined semantics that does mutation-by-part on<br>&gt;&gt;&gt; instances of T without constraining T to have value or reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not advocating that we require “y-&gt;a” for class member access, but<br>&gt;&gt;&gt; I *am* suggesting that we should accept the fact that reference and<br>&gt;&gt;&gt; value semantics are fundamentally different and make design choices<br>&gt;&gt;&gt; (including language rules) accordingly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = MyStruct()<br>&gt;&gt;&gt;&gt; let y = MyClass()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x.myFoo<br>&gt;&gt;&gt;&gt; y.myFoo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; my_struct *x = …<br>&gt;&gt;&gt;&gt; my_struct y = …<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x.my_foo<br>&gt;&gt;&gt;&gt; y-&gt;my_foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With C it is explicit that you are crossing a reference. Thus there is only<br>&gt;&gt;&gt;&gt; *one* type of equality in C, that the values *are equal*. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, C doesn&#39;t even *have* struct equality;<br>&gt;&gt;&gt; http://stackoverflow.com/a/141724<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This exactly the type of equality you are referring to, but this does<br>&gt;&gt;&gt;&gt; not carry over to Swift for precisely the reason that Swift paves over<br>&gt;&gt;&gt;&gt; the difference between value and reference types, and then allows you<br>&gt;&gt;&gt;&gt; to redefine equality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, in essentially no circumstances does it make sense to<br>&gt;&gt;&gt;&gt; compare a type by its reference if it has any associated data in<br>&gt;&gt;&gt;&gt; Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disagreed.  Instances whose *identity* is significant, i.e. basically<br>&gt;&gt;&gt; everything that actually ought to be a class, can be very usefully<br>&gt;&gt;&gt; compared by their references.  For example, if equality and hashing were<br>&gt;&gt;&gt; defined for UIViews, based on their references, you could use a<br>&gt;&gt;&gt; Set&lt;UIView&gt; to keep track of which views had user interaction during a<br>&gt;&gt;&gt; given time interval.<br>&gt;&gt; <br>&gt;&gt; This use case is exploiting the fact that the reference is a unique<br>&gt;&gt; identifier for a view. <br>&gt; <br>&gt; That&#39;s a fundamental property of class instances.<br>&gt; <br>&gt;&gt; For any distributed application this is no longer true for objects.<br>&gt; <br>&gt; That certainly depends on your programming model for distributed<br>&gt; applications.  If you want to try to maintain the illusion that there&#39;s<br>&gt; really only one object when you have a pair communicating across a<br>&gt; process or machine boundary, or that a given object travels across<br>&gt; process or machine boundaries, *and* you want to build a Set that<br>&gt; “holds” objects that may live in other processes, then yes, you&#39;ll need<br>&gt; a different system.  <br></p><p>This is basically all web applications, or even just saving out to disk.<br></p><p>&gt; <br>&gt;&gt; Equality should be used to uniquely define data.<br>&gt; <br>&gt; A mutable thing that has no identity apart from its value is a value<br>&gt; type.  Don&#39;t use classes for that, or everything breaks down, because a<br>&gt; mutable class always eventually reveals that it&#39;s not a value.<br>&gt; <br>&gt;&gt; In a non-distributed application comparing references is also an<br>&gt;&gt; implicit comparison of the entire object graph referenced by that<br>&gt;&gt; reference. <br>&gt; <br>&gt; I don&#39;t think so.  It&#39;s possible for references x and y to have exactly<br>&gt; isomorphic object graphs, but still x !=== y.<br>&gt; <br>&gt;&gt; When you allow any other definition of equality for reference types,<br>&gt;&gt; unless that comparison explicitly includes all values in the each of<br>&gt;&gt; the object’s referenced object graphs, it is only *partial*<br>&gt;&gt; equality. <br>&gt; <br>&gt; It still might not be equality.  Equal things should be effectively<br>&gt; interchangeable (except for parts explicitly designated inessential,<br>&gt; such as an Array&#39;s capacity).  As soon as you expose identity, that<br>&gt; falls apart.<br>&gt; <br>&gt;&gt; Thus custom equality is a lie that should probably be expressed with<br>&gt;&gt; something more like ~=. It’s only equal up to the boundary, which is<br>&gt;&gt; arbitrarily defined.<br>&gt;&gt; <br>&gt;&gt; So yes, I agree that at least equality should be consistent with<br>&gt;&gt; immutability, but in my opinion the only way to accomplish that is to<br>&gt;&gt; ban custom equality.<br>&gt; <br>&gt; For all types, or for reference types?  I&#39;d be totally OK with banning<br>&gt; it for reference types.  I&#39;d disagree strongly with banning it for all<br>&gt; types.<br>&gt; <br></p><p>I’m thinking all types, but maybe I’m over looking something here? There are three different ways equality is implemented for a linked list built with value types in this blog post<br></p><p>https://airspeedvelocity.net/2015/07/26/linked-lists-enums-value-types-and-identity/<br></p><p>“We can also implement == for List the way users expect == to behave for value-semantic collections, by comparing the elements&quot;<br></p><p>If it’s the way users expect, why not have == be defined as exactly that? And why not just have that automatically generated?<br></p><p>Incidentally, “indirect” for structs would mean it could be generated for structs as well. Best of all structs that do not contain any mutable reference types would be PureValues™, (Andrew or Matthew correct me if I’m misrepresenting PureValues) and would be able to implement any complex structure, without having to wrap the structs in reference types.<br></p><p>It could be enforce by the compiler that nothing inside of these could change. A function foo which takes array of PureValues, as a parameter would *always* return the same result if it is a pure function, no matter how it uses the array.<br></p><p><br>&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt; procedure for determining whether a type is a PureValue.<br></p><p><br>I’m jumping conversations, but shouldn’t this be every value in the Array struct? All internal state as well as all of the elements of the array.<br></p><p><br>&gt;&gt; I’m of the opinion that there are only two ways of accomplishing this.<br>&gt;&gt; <br>&gt;&gt; EITHER<br>&gt;&gt; <br>&gt;&gt; One could imagine a definition of equality that did explore the entire<br>&gt;&gt; object graph comparing values (only using references to find other<br>&gt;&gt; values, not for comparison) as it went. However, this this would not<br>&gt;&gt; be able to align with the semantics of immutability (maybe by only<br>&gt;&gt; allowing a single entry point into the graph which was guaranteed to<br>&gt;&gt; be a unique reference?).<br>&gt;&gt; <br>&gt;&gt; OR<br>&gt;&gt; <br>&gt;&gt; === should be the only valid equality operator for classes (and you’re<br>&gt;&gt; right it should be spelled ==), and that if you want to compare<br>&gt;&gt; classes you should just put all of the data that acts as the<br>&gt;&gt; “identity” of that class in a value type which can be compared by<br>&gt;&gt; value. Value types could then have generated equality operators based<br>&gt;&gt; on the equality of each of their constituent values, some of which<br>&gt;&gt; could be references (but as I mentioned including references in the<br>&gt;&gt; identity does not work for distributed applications).<br>&gt;&gt; <br>&gt;&gt; let x = MyClass(…)<br>&gt;&gt; let y = MyClass(…)<br>&gt;&gt; <br>&gt;&gt; x.identityStruct == y.identityStruct<br>&gt;&gt; <br>&gt;&gt; As it stands now in Swift, a class is more than just a reference. It<br>&gt;&gt; also includes all sorts of assumptions about it’s associated data<br>&gt;&gt; based on the fact that a class “pretends” to include the data it’s<br>&gt;&gt; associated with. Hence the need for custom equality operators.<br>&gt;&gt; <br>&gt;&gt; I really think we’re on the same page here, probably. Or at least in<br>&gt;&gt; the same book.<br>&gt; <br>&gt; Yes, although I don&#39;t understand a lot of what you&#39;re saying and my<br>&gt; instinct is that arguments about “whole object graph” are barking up the<br>&gt; wrong tree, or at least making it more complicated than necessary.<br></p><p>I guess same book, but different languages. <br></p><p>Suffice it to say, that if I were going to create an equality (==) operator for a LinkedList type (or any other complex data structure), implemented with reference types, there’s basically two valid ways to do it. <br></p><p>1. Recursively or iteratively explore the list and check that every value in the list is the same. (Could this not be auto-generated?)<br>2. Just compare the references of each list and call it a day.<br></p><p>What we have now are no guarantees that it will be either of those things. My understanding is that your approach would be number two. I don’t think it’s a drastic approach at all, and it is correct in one sense. But in another sense it’s not correct at all. If I read the list in from a file and want to compare it to another one I already have in memory, no dice. I’ll have to have a special function for that type of comparison.<br></p><p>Anyway, I’m not sure I’m adding much to this conversation. I apologize if I am being confusing.<br></p><p>&gt; <br>&gt;&gt;&gt; There are still useful custom definitions of<br>&gt;&gt;&gt; equality as I have outlined above.<br>&gt;&gt; <br>&gt;&gt; I think I am missing these. Could you provide an example?<br>&gt; <br>&gt; ,----[ quoting myself ]<br>&gt; | In my world, you can override equality such that it<br>&gt; | includes referenced storage when either:<br>&gt; | <br>&gt; | 1. the referenced storage will not be mutated<br>&gt; | 2. or, the referenced storage will only mutated when uniquely-referenced.<br>&gt; `----<br>&gt; <br>&gt; Array&lt;T&gt; has a custom equality operator; IMO that&#39;s indispensable.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>&gt; <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/98a376d5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 6, 2016, at 8:54 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;        this is an own<br>&gt;&gt;        proposal I guess.<br>&gt;&gt; <br>&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;        types<br>&gt;&gt;        conforms.<br>&gt;&gt; <br>&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;        is<br>&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;        value<br>&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;        structs<br>&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;        storage<br>&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;        do<br>&gt;&gt;        copy-on-write). <br>&gt;&gt; <br>&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;        impose<br>&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;        years, I<br>&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;        that<br>&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;        equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;        to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;        Same answer.<br>&gt;&gt; <br>&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;        enums<br>&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;        “feel”<br>&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;        safe,<br>&gt;&gt;        etc).<br>&gt;&gt; <br>&gt;&gt;        Sure it does.<br>&gt;&gt; <br>&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;        private x: T<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt; <br>&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;        CoW.<br>&gt;&gt; <br>&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;        value”.<br>&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;        of deep<br>&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt; <br>&gt;&gt;        No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;        not understanding the boundaries of your value. Or, put more<br>&gt;&gt;        solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;        makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt; <br>&gt;&gt;        In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;        there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;        everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;        “deep value semantics” or “shallow value semantics.” <br>&gt;&gt; <br>&gt;&gt;        Equality defines<br>&gt;&gt;        value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;        the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;        way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;        Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;        complexity-of-programming-model terms, are too high.<br>&gt;&gt; <br>&gt;&gt;        Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt; <br>&gt;&gt;        I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;        value”. Do<br>&gt;&gt;        you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;        identity for<br>&gt;&gt;        elements with reference semantics? <br>&gt;&gt; <br>&gt;&gt;    Yes.<br>&gt;&gt; <br>&gt;&gt;        If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;        that has value semantics would you say the boundary extends past the<br>&gt;&gt;        reference identity of an element and includes a definition of equality<br>&gt;&gt;        defined by that type?<br>&gt;&gt; <br>&gt;&gt;    Yes!<br>&gt;&gt; <br>&gt;&gt;        Are you arguing that reference types should be equatable by default,<br>&gt;&gt;        using<br>&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;        definition of<br>&gt;&gt;        equality?<br>&gt;&gt; <br>&gt;&gt;    Yes!!<br>&gt;&gt; <br>&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;        (purity) <br>&gt;&gt; <br>&gt;&gt;        I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;        know of applies to functions and implies no side effects. In that<br>&gt;&gt;        world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;        reference semantics.<br>&gt;&gt; <br>&gt;&gt;        I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;        thread. <br>&gt;&gt; <br>&gt;&gt;    Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;    Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;    “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;    enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;    it means.<br>&gt;&gt; <br>&gt;&gt;        I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;        possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;        purity?<br>&gt;&gt; <br>&gt;&gt;    You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;    mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;    copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;    **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt; <br>&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt; mutation possible is local.<br>&gt; <br>&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt; determine whether there was mutation?”  <br>&gt; <br>&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt; everywhere.<br>&gt;&gt; <br>&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt; elements they contain also have the same property.<br>&gt; <br>&gt; Only if you think mutable class instances are part of the value of the<br>&gt; array that stores references to those class instances.  As I said<br>&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt; Today, we have left that question wide open, which makes the whole<br>&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt; close it.<br></p><p>I think part of the disconnect here might be the domains in which we work.  Maybe you&#39;re coming at this primarily from an algorithmic perspective and I&#39;m coming at it primarily from an app development perspective.<br></p><p>For example, I think it is perfectly reasonable to write a generic view controller that works with various data types and is initialized with an Array&lt;T&gt; but only works properly when it isn&#39;t possible to observe any mutation in the subgraph of T. <br></p><p>&gt; <br>&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt; they are all uniquely referenced.<br>&gt; <br>&gt; If you interpret the elements of the array as being *references* to<br>&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt; problems.<br></p><p>In application code we are concerned with the objects, not the references.  <br></p><p>&gt; <br>&gt;&gt;    I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;    semantics.” But I could be wrong.<br>&gt;&gt; <br>&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt; <br>&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;        property.<br>&gt;&gt; <br>&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt; <br>&gt;&gt;        Wrong in what sense? <br>&gt;&gt; <br>&gt;&gt;    Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;    logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;    have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;    anything other than values, so it would be extremely limiting. <br>&gt;&gt; <br>&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt; CoW.<br>&gt; <br>&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br></p><p>I believe it is a purely semantic concept.   It means that every name binding is logically and observably distinct, including and objects in the aggregate (if it includes references).  This allows for local mutation on the same binding and also for un observable mutation such as CoW in the implementation.  But it does not allow for a mutation applied to one name binding having the type to be observed through another name binding having the type.<br></p><p>&gt; <br>&gt;&gt;        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;        property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;        valuable<br>&gt;&gt;        property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;    I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;    algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;    work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt; to have a reference to the same objects.<br>&gt; <br>&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br></p><p>I am not sure.  It is possible that it does not apply to purely algorithmic work.  That does not mean it is unimportant.  It is quite valuable in application level code.  It think it would be valuable to reify it with a protocol rather than leaving it to documentation even if the compiler can&#39;t always prove our code meets this semantic. <br></p><p> If you don&#39;t like the name PureValue for this concept lets bike shed.  I only used it because others had already used it.  Maybe there is a better name.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;        let t = MyClass()<br>&gt;&gt;        foo.acceptWrapped(Wrap(t))<br>&gt;&gt;        t.mutate()<br>&gt;&gt; <br>&gt;&gt;        In this example, foo had better not depend on the wrapped instance not<br>&gt;&gt;        getting<br>&gt;&gt;        mutated.<br>&gt;&gt; <br>&gt;&gt;        foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt;&gt;        anything about it.<br>&gt;&gt; <br>&gt;&gt;        Ok, but this is a toy example. What is the purpose of Wrap? Maybe foo<br>&gt;&gt;        passes the<br>&gt;&gt;        wrapped instance back to code that *does* have visibility to the<br>&gt;&gt;        instance. My<br>&gt;&gt;        point was that shared mutable state is still possible here. <br>&gt;&gt; <br>&gt;&gt;    And my point is that Wrap&lt;T&gt; encapsulates a T (almost—I should have let<br>&gt;&gt;    it construct the T in its init rather than accepting a T parameter) and<br>&gt;&gt;    the fact that it&#39;s *possible* to code something with the structure of<br>&gt;&gt;    Wrap so that it has shared mutable state is irrelevant.<br>&gt;&gt; <br>&gt;&gt; The point I am trying to make is that the semantic properties of Wrap&lt;T&gt; depend<br>&gt;&gt; on the semantic properties of T (whether or not non-local mutation may be<br>&gt;&gt; observed in this case).<br>&gt; <br>&gt; No they do not; Wrap&lt;T&gt; was specifically designed *not* to depend on the<br>&gt; semantic properties of T.  This was in answer to what you said:<br>&gt; <br>&gt;&gt;       A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;       “feel” value semantic to me and certainly doesn’t have the<br>&gt;&gt;       guarantees usually associated with value semantics (won’t<br>&gt;&gt;       mutate behind your back, thread safe, etc).<br>&gt; <br>&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt; types in that category, and what generic code would depend on those<br>&gt; properties?<br>&gt; <br></p><p>I hope my previous comments have helped to clarify this.<br></p><p>&gt;&gt; It certainly isn’t irrelevant to that point.<br>&gt;&gt; <br>&gt;&gt;    HTH,<br>&gt;&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;        That<br>&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt; <br>&gt;&gt;        The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;        providing static enforcement. This is like that.<br>&gt;&gt; <br>&gt;&gt;        I did not know this. Now you have me curious. Can you give an example of<br>&gt;&gt;        where<br>&gt;&gt;        we are able to violate law? I ask mostly because it sounds like there is<br>&gt;&gt;        a<br>&gt;&gt;        possibility of stumbling into dangerous territory, possibly without<br>&gt;&gt;        being aware<br>&gt;&gt;        that you have done so.<br>&gt;&gt; <br>&gt;&gt;        See “In-out Parameters” in<br>&gt;&gt;        https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br>&gt;&gt; <br>&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;        enforce this?<br>&gt;&gt; <br>&gt;&gt;        That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;        could make similar assumptions.<br>&gt;&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On May 6, 2016, at 8:54 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;&gt;        &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;&gt;        this is an own<br>&gt;&gt;&gt;        proposal I guess.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;&gt;        types<br>&gt;&gt;&gt;        conforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;&gt;        is<br>&gt;&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;&gt;        value<br>&gt;&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;&gt;        structs<br>&gt;&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;&gt;        storage<br>&gt;&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;&gt;        do<br>&gt;&gt;&gt;        copy-on-write). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;&gt;        impose<br>&gt;&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;&gt;        years, I<br>&gt;&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;&gt;        that<br>&gt;&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt;        equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;&gt;        underneath us. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;&gt;        to ===. Problem solved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Same answer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;&gt;        enums<br>&gt;&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;        “feel”<br>&gt;&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;&gt;        safe,<br>&gt;&gt;&gt;        etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Sure it does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;&gt;        init(_ x: T) { self.x = x }<br>&gt;&gt;&gt;        private x: T<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;        return lhs.x === rhs.x<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;&gt;        semantics, whether T is mutable or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;&gt;        struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;&gt;        CoW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;&gt;        value”.<br>&gt;&gt;&gt;        Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;&gt;        of deep<br>&gt;&gt;&gt;        value semantics when T is deeply value semantic. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;&gt;        not understanding the boundaries of your value. Or, put more<br>&gt;&gt;&gt;        solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;&gt;        makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;&gt;        there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;&gt;        everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;&gt;        “deep value semantics” or “shallow value semantics.” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Equality defines<br>&gt;&gt;&gt;        value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;&gt;        the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;&gt;        way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;&gt;        Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;&gt;        complexity-of-programming-model terms, are too high.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;&gt;        value”. Do<br>&gt;&gt;&gt;        you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;&gt;        identity for<br>&gt;&gt;&gt;        elements with reference semantics? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;&gt;        that has value semantics would you say the boundary extends past the<br>&gt;&gt;&gt;        reference identity of an element and includes a definition of equality<br>&gt;&gt;&gt;        defined by that type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;        using<br>&gt;&gt;&gt;        equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;        definition of<br>&gt;&gt;&gt;        equality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Yes!!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;&gt;        (purity) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;&gt;        know of applies to functions and implies no side effects. In that<br>&gt;&gt;&gt;        world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;&gt;        reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;&gt;        thread. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;&gt;    Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;&gt;    “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;&gt;    enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;&gt;    it means.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;&gt;        possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;&gt;        purity?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;&gt;    mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;&gt;    copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;&gt;    **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt;&gt; mutation possible is local.<br>&gt;&gt; <br>&gt;&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt;&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt;&gt; determine whether there was mutation?”  <br>&gt;&gt; <br>&gt;&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt;&gt; everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt;&gt; elements they contain also have the same property.<br>&gt;&gt; <br>&gt;&gt; Only if you think mutable class instances are part of the value of the<br>&gt;&gt; array that stores references to those class instances.  As I said<br>&gt;&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt; Today, we have left that question wide open, which makes the whole<br>&gt;&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt;&gt; close it.<br>&gt;<br>&gt; I think part of the disconnect here might be the domains in which we<br>&gt; work.  Maybe you&#39;re coming at this primarily from an algorithmic<br>&gt; perspective and I&#39;m coming at it primarily from an app development<br>&gt; perspective.<br></p><p>IMO that&#39;s a false distinction.  Suggestion: look up the definition of<br>“algorithm.”  Your apps are built out of algorithms.  FWIW, I was an app<br>developer long before I was a library writer.  What I discovered, after<br>many years living with my own software and learning from mistakes, was<br>that “an algorithmic perspective” is essential to building any piece of<br>software that you or someone else might have to maintain, that users can<br>rely on, that doesn&#39;t have catastrophic performance problems, etc.<br></p><p>&gt; For example, I think it is perfectly reasonable to write a generic<br>&gt; view controller that works with various data types and is initialized<br>&gt; with an Array&lt;T&gt; but only works properly when it isn&#39;t possible to<br>&gt; observe any mutation in the subgraph of T.<br></p><p>And my claim is that you have picked a really complicated way of saying<br>“T has value semantics,” or if there are differences in your intended<br>constraint, you don&#39;t actually care about those differences.<br></p><p>Just taking the nontrivial case where T is a reference type, let&#39;s look<br>at the the phrase “it isn&#39;t possible to observe any mutation in the<br>subgraph of T.”  This is still a rather fuzzy notion, but let me try to<br>nail it down.  To me that means, if the behavior of “f” only depends on<br>data reachable through this array, and f makes no mutations, then in<br>this code, the two calls to f() are guaranteed have the same effect.<br></p><p>      func g&lt;T&gt;(a: [T]) {<br>        var vc = MyViewController(a)<br>        vc.f() // #1<br>        h()<br>        vc.f() // #2<br>     }<br></p><p>But clearly, the only way that can be the case is if T is actually<br>immutable (and contains no references to mutable data), because<br>otherwise anybody can write:<br></p><p>    class X { ... }<br>    let global: [X] = [ X() ]<br>    func h() { global[0].mutatingMethod() }<br>    g(global)<br></p><p>Conclusion: your definition of PureValue, as written, implies conforming<br>reference types must be immutable.  I&#39;m not saying that&#39;s necessarily<br>what you meant, but if it isn&#39;t, you need to try to define it again.<br></p><p>&gt;&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt; they are all uniquely referenced.<br>&gt;&gt; <br>&gt;&gt; If you interpret the elements of the array as being *references* to<br>&gt;&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt;&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt; problems.<br>&gt;<br>&gt; In application code we are concerned with the objects, not the<br>&gt; references.<br></p><p>Not necessarily, not at all.  A Set&lt;UIView&gt; where you&#39;re interested in<br>the references is totally reasonable.<br></p><p>&gt;&gt;&gt;    I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;&gt;    semantics.” But I could be wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        is derived from deep value semantics. This is when there is no<br>&gt;&gt;&gt;        possibility of shared mutable state. This is an extremely important<br>&gt;&gt;&gt;        property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        It&#39;s the wrong property, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Wrong in what sense? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;&gt;    logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;&gt;    have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;&gt;    anything other than values, so it would be extremely limiting. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt;&gt; CoW.<br>&gt;&gt; <br>&gt;&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br>&gt;<br>&gt; I believe it is a purely semantic concept.  It means that every name<br>&gt; binding is logically and observably distinct, including and objects in<br>&gt; the aggregate (if it includes references).  <br></p><p>That sounds like “value semantics” to me, although I get the sense maybe<br>you&#39;re also adding the restriction that you&#39;re *not allowed* to define<br>the boundary of values as stopping at a reference but not including the<br>instance it references.  IMO that restriction is not actually useful and<br>probably harmful.<br></p><p>&gt; This allows for local mutation on the same binding and also for un<br>&gt; observable mutation such as CoW in the implementation.  But it does<br>&gt; not allow for a mutation applied to one name binding having the type<br>&gt; to be observed through another name binding having the type.<br></p><p>It sounds like you&#39;re trying to capture some notion of “can&#39;t possibly<br>reach shared mutable state through this instance,” but IMO there&#39;s a<br>false distinction here.  Fundamentally, there&#39;s no difference between a<br>reference to an object and an integer that can be used as an index into<br>a global array that contains a reference to the object, or even an<br>integer that can be used as an index into a global array that contains<br>an equivalent struct.<br></p><p>Again, I would like to see some piece of code that *actually depends on<br>this PureValue property for its correctness*.<br></p><p>&gt;&gt;&gt;        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt;        property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;&gt;        valuable<br>&gt;&gt;&gt;        property in many cases. Do you disagree?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;&gt;    algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;&gt;    work just as well on Array&lt;Int&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;&gt; to have a reference to the same objects.<br>&gt;&gt; <br>&gt;&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;<br>&gt; I am not sure.  It is possible that it does not apply to purely<br>&gt; algorithmic work.  That does not mean it is unimportant.  <br>&gt; It is quite valuable in application level code.  It think it would be<br>&gt; valuable to reify it with a protocol rather than leaving it to<br>&gt; documentation even if the compiler can&#39;t always prove our code meets<br>&gt; this semantic.<br></p><p>For the purposes of library and language design, the ability to produce<br>use-cases (and solid definitions) is crucial.  The ability to show how<br>it substantively differs from concepts we already have is crucial.  If<br>we can&#39;t find these things, it doesn&#39;t belong.<br></p><p>&gt;  If you don&#39;t like the name PureValue for this concept lets bike shed.<br>&gt; I only used it because others had already used it.  Maybe there is a<br>&gt; better name.<br></p><p>It&#39;s not the name that&#39;s the problem.  I don&#39;t even understand what<br>you&#39;re reaching for, or why.  Without a demonstration of what this is<br>for, I&#39;m going to continue to argue against it (though I&#39;m about to be<br>on vacation so I&#39;ll be out of your hair for a week).<br></p><p>&gt;&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt;&gt; types in that category, and what generic code would depend on those<br>&gt;&gt; properties?<br>&gt;&gt; <br>&gt;<br>&gt; I hope my previous comments have helped to clarify this.<br></p><p>I&#39;m afraid not yet.<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 3:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 6, 2016, at 8:54 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri May 06 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 6, 2016, at 7:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;   &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   on Thu May 05 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On May 5, 2016, at 10:02 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;       &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On May 5, 2016, at 4:59 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;       &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       on Wed May 04 2016, Matthew Johnson<br>&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       on Wed May 04 2016, Adrian Zubarev<br>&gt;&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;       wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Not sure what to think about the enum cases inside a<br>&gt;&gt;&gt;&gt;       protocol (if AnyEnum would<br>&gt;&gt;&gt;&gt;       even exist), it could be a nice addition to the language, but<br>&gt;&gt;&gt;&gt;       this is an own<br>&gt;&gt;&gt;&gt;       proposal I guess.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       We should start by adding AnyValue protocol to which all value<br>&gt;&gt;&gt;&gt;       types<br>&gt;&gt;&gt;&gt;       conforms.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Having a way to constrain conformance to things with value semantics<br>&gt;&gt;&gt;&gt;       is<br>&gt;&gt;&gt;&gt;       something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;&gt;&gt;       simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;&gt;&gt;       value<br>&gt;&gt;&gt;&gt;       semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;&gt;&gt;       structs<br>&gt;&gt;&gt;&gt;       whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;&gt;&gt;       storage<br>&gt;&gt;&gt;&gt;       in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;&gt;&gt;       do<br>&gt;&gt;&gt;&gt;       copy-on-write). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;&gt;&gt;       impose<br>&gt;&gt;&gt;&gt;       greater order. After thinking through many approaches over the<br>&gt;&gt;&gt;&gt;       years, I<br>&gt;&gt;&gt;&gt;       have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt;&gt;       language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt;&gt;       that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;&gt;&gt;       that<br>&gt;&gt;&gt;&gt;       immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt;&gt;       struct). The language could then do lots of things much more<br>&gt;&gt;&gt;&gt;       intelligently, such as correctly generating implementations of<br>&gt;&gt;&gt;&gt;       equality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;&gt;&gt;       Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;&gt;&gt;       obviously does not as it contains references which usually be mutated<br>&gt;&gt;&gt;&gt;       underneath us. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Value semantics and mutation can only be measured with respect to<br>&gt;&gt;&gt;&gt;       equality. The definition of == for all class types would be equivalent<br>&gt;&gt;&gt;&gt;       to ===. Problem solved.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Same answer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;&gt;&gt;       enums<br>&gt;&gt;&gt;&gt;       would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;&gt;&gt;       “feel”<br>&gt;&gt;&gt;&gt;       value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;&gt;&gt;       associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;&gt;&gt;       safe,<br>&gt;&gt;&gt;&gt;       etc).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Sure it does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;&gt;&gt;       init(_ x: T) { self.x = x }<br>&gt;&gt;&gt;&gt;       private x: T<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;&gt;       return lhs.x === rhs.x<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;&gt;&gt;       semantics, whether T is mutable or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;&gt;&gt;       struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;&gt;&gt;       CoW.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       This goes back to where you draw the line as to the “boundary of the<br>&gt;&gt;&gt;&gt;       value”.<br>&gt;&gt;&gt;&gt;       Wrap and Array are “value semantic” in a shallow sense and are capable<br>&gt;&gt;&gt;&gt;       of deep<br>&gt;&gt;&gt;&gt;       value semantics when T is deeply value semantic. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;&gt;&gt;&gt;       not understanding the boundaries of your value. Or, put more<br>&gt;&gt;&gt;&gt;       solicitously: sure, you can look at the world that way, but it just<br>&gt;&gt;&gt;&gt;       makes everything prohibitively complicated, so why would you want to?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;&gt;&gt;&gt;       there&#39;s just “copy,” which logically creates an independent version of<br>&gt;&gt;&gt;&gt;       everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;&gt;&gt;&gt;       “deep value semantics” or “shallow value semantics.” <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Equality defines<br>&gt;&gt;&gt;&gt;       value semantics, and the boundaries of an Array value always includes<br>&gt;&gt;&gt;&gt;       the values of its elements. The *only* problem here is that we have no<br>&gt;&gt;&gt;&gt;       way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;&gt;&gt;&gt;       Equatable. IMO the costs of not having everything be equatable, in<br>&gt;&gt;&gt;&gt;       complexity-of-programming-model terms, are too high.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Thank you for clarifying the terminology for me. This is helpful. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I think I may have misunderstood what you meant by “boundary of the<br>&gt;&gt;&gt;&gt;       value”. Do<br>&gt;&gt;&gt;&gt;       you mean that the boundary of an Array value stops at the reference<br>&gt;&gt;&gt;&gt;       identity for<br>&gt;&gt;&gt;&gt;       elements with reference semantics? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Yes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       If you have an Array whose elements are of an immutable reference type<br>&gt;&gt;&gt;&gt;       that has value semantics would you say the boundary extends past the<br>&gt;&gt;&gt;&gt;       reference identity of an element and includes a definition of equality<br>&gt;&gt;&gt;&gt;       defined by that type?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Yes!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Are you arguing that reference types should be equatable by default,<br>&gt;&gt;&gt;&gt;       using<br>&gt;&gt;&gt;&gt;       equality of the reference if the type does not provide a custom<br>&gt;&gt;&gt;&gt;       definition of<br>&gt;&gt;&gt;&gt;       equality?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Yes!!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Both have their place, but the maximum benefit of value semantics<br>&gt;&gt;&gt;&gt;       (purity) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I don&#39;t know what definition of purity you&#39;re using. The only one I<br>&gt;&gt;&gt;&gt;       know of applies to functions and implies no side effects. In that<br>&gt;&gt;&gt;&gt;       world, there is no mutation and value semantics is equivalent to<br>&gt;&gt;&gt;&gt;       reference semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I was using it in the sense of “PureValue” as discussed in this<br>&gt;&gt;&gt;&gt;       thread. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt;&gt;&gt;&gt;   Oh, it was a different thread. Joe describes it as a protocol for<br>&gt;&gt;&gt;&gt;   “types that represent fully self-contained values,” which is just fuzzy<br>&gt;&gt;&gt;&gt;   enough that everyone reading it can have his own interpretation of what<br>&gt;&gt;&gt;&gt;   it means.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       I was using it to mean values for which no *observable* mutation is<br>&gt;&gt;&gt;&gt;       possible (allowing for CoW, etc). Is there a better term for this than<br>&gt;&gt;&gt;&gt;       purity?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   You&#39;re still not making any sense to me. A type for which no observable<br>&gt;&gt;&gt;&gt;   mutation is possible is **immutable**. The “write” part of<br>&gt;&gt;&gt;&gt;   copy-on-write is a pretty clear indicator that it&#39;s all about<br>&gt;&gt;&gt;&gt;   **mutation**. I don&#39;t see how they&#39;re compatible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I did not write that very clearly. I should have said no observable<br>&gt;&gt;&gt;&gt; mutation *that happens behind your back*. In other words, the only *observable*<br>&gt;&gt;&gt;&gt; mutation possible is local.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, but you need to ask the question, “mutation in what?”  The answer:<br>&gt;&gt;&gt; mutation in the value instance.  Then you need to ask, “how do you<br>&gt;&gt;&gt; determine whether there was mutation?”  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Immutability accomplishes this by simply prohibiting all<br>&gt;&gt;&gt;&gt; mutation. Primitive value types like Int and structs or enums that<br>&gt;&gt;&gt;&gt; only contain primitive value types accomplish this by getting copied<br>&gt;&gt;&gt;&gt; everywhere.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift’s collections also accomplish this through copying, but only when the<br>&gt;&gt;&gt;&gt; elements they contain also have the same property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Only if you think mutable class instances are part of the value of the<br>&gt;&gt;&gt; array that stores references to those class instances.  As I said<br>&gt;&gt;&gt; earlier, you can *take* that point of view, but why would you want to?<br>&gt;&gt;&gt; Today, we have left that question wide open, which makes the whole<br>&gt;&gt;&gt; notion of what is a logical value very indistinct.  I am proposing to<br>&gt;&gt;&gt; close it.<br>&gt;&gt; <br>&gt;&gt; I think part of the disconnect here might be the domains in which we<br>&gt;&gt; work.  Maybe you&#39;re coming at this primarily from an algorithmic<br>&gt;&gt; perspective and I&#39;m coming at it primarily from an app development<br>&gt;&gt; perspective.<br>&gt; <br>&gt; IMO that&#39;s a false distinction.  Suggestion: look up the definition of<br>&gt; “algorithm.”  Your apps are built out of algorithms.  FWIW, I was an app<br>&gt; developer long before I was a library writer.  What I discovered, after<br>&gt; many years living with my own software and learning from mistakes, was<br>&gt; that “an algorithmic perspective” is essential to building any piece of<br>&gt; software that you or someone else might have to maintain, that users can<br>&gt; rely on, that doesn&#39;t have catastrophic performance problems, etc.<br></p><p>I know quite well what an algorithm is and I agree that apps *contain* algorithms.  However they contain more than just algorithms.  I am concerned here about the ability to be clear in my code about aggregate values which cannot be changed by code elsewhere in the app.  I.e. creating conditions that prevent shared mutable state from being a possibility in various parts of the app.<br></p><p>&gt; <br>&gt;&gt; For example, I think it is perfectly reasonable to write a generic<br>&gt;&gt; view controller that works with various data types and is initialized<br>&gt;&gt; with an Array&lt;T&gt; but only works properly when it isn&#39;t possible to<br>&gt;&gt; observe any mutation in the subgraph of T.<br>&gt; <br>&gt; And my claim is that you have picked a really complicated way of saying<br>&gt; “T has value semantics,” or if there are differences in your intended<br>&gt; constraint, you don&#39;t actually care about those differences.<br></p><p>I disagree wholeheartedly.  I am trying to say that T is a pure value, not that T simply has value semantics.  This is the difference between Array&lt;UIView&gt; and Array&lt;Int&gt;.  <br></p><p>&gt; <br>&gt; Just taking the nontrivial case where T is a reference type, let&#39;s look<br>&gt; at the the phrase “it isn&#39;t possible to observe any mutation in the<br>&gt; subgraph of T.”  This is still a rather fuzzy notion, but let me try to<br>&gt; nail it down.  To me that means, if the behavior of “f” only depends on<br>&gt; data reachable through this array, and f makes no mutations, then in<br>&gt; this code, the two calls to f() are guaranteed have the same effect.<br>&gt; <br>&gt;      func g&lt;T&gt;(a: [T]) {<br>&gt;        var vc = MyViewController(a)<br>&gt;        vc.f() // #1<br>&gt;        h()<br>&gt;        vc.f() // #2<br>&gt;     }<br>&gt; <br>&gt; But clearly, the only way that can be the case is if T is actually<br>&gt; immutable (and contains no references to mutable data), because<br>&gt; otherwise anybody can write:<br>&gt; <br>&gt;    class X { ... }<br>&gt;    let global: [X] = [ X() ]<br>&gt;    func h() { global[0].mutatingMethod() }<br>&gt;    g(global)<br>&gt; <br>&gt; Conclusion: your definition of PureValue, as written, implies conforming<br>&gt; reference types must be immutable.  I&#39;m not saying that&#39;s necessarily<br>&gt; what you meant, but if it isn&#39;t, you need to try to define it again.<br></p><p>Yes, my definition of PureValue would require conforming reference types to be immutable.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; On the other hand, it is immediately obvious that non-local mutation<br>&gt;&gt;&gt;&gt; is quite possibly in the elements of a Swift Array&lt;AnyObject&gt; unless<br>&gt;&gt;&gt;&gt; they are all uniquely referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you interpret the elements of the array as being *references* to<br>&gt;&gt;&gt; objects, there is no possibility of non-local mutation.  If you<br>&gt;&gt;&gt; interpret the elements as being objects *themselves*, then you&#39;ve got<br>&gt;&gt;&gt; problems.<br>&gt;&gt; <br>&gt;&gt; In application code we are concerned with the objects, not the<br>&gt;&gt; references.<br>&gt; <br>&gt; Not necessarily, not at all.  A Set&lt;UIView&gt; where you&#39;re interested in<br>&gt; the references is totally reasonable.<br></p><p>You are correct.  I was thinking of model objects here and should have been more careful.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt;   I think perhaps what you mean by “purity” is just, “has value<br>&gt;&gt;&gt;&gt;   semantics.” But I could be wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, an array storing instances of reference types that are not immutable would<br>&gt;&gt;&gt;&gt; not be “pure” (or whatever you want to call it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       is derived from deep value semantics. This is when there is no<br>&gt;&gt;&gt;&gt;       possibility of shared mutable state. This is an extremely important<br>&gt;&gt;&gt;&gt;       property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       It&#39;s the wrong property, IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Wrong in what sense? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Wrong in the sense that it rules out using things like Array that are<br>&gt;&gt;&gt;&gt;   logically value types but happen to be implemented with CoW, and if you<br>&gt;&gt;&gt;&gt;   have proper encapsulation there&#39;s no way for these types to behave as<br>&gt;&gt;&gt;&gt;   anything other than values, so it would be extremely limiting. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m a big fan of CoW as an implementation detail. We have definitely been<br>&gt;&gt;&gt;&gt; miscommunicating if you thought I was suggesting something that would prohibit<br>&gt;&gt;&gt;&gt; CoW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then what, precisely, are the syntactic and semantic requirements of “PureValue?”<br>&gt;&gt; <br>&gt;&gt; I believe it is a purely semantic concept.  It means that every name<br>&gt;&gt; binding is logically and observably distinct, including and objects in<br>&gt;&gt; the aggregate (if it includes references).  <br>&gt; <br>&gt; That sounds like “value semantics” to me, although I get the sense maybe<br>&gt; you&#39;re also adding the restriction that you&#39;re *not allowed* to define<br>&gt; the boundary of values as stopping at a reference but not including the<br>&gt; instance it references.  IMO that restriction is not actually useful and<br>&gt; probably harmful.<br></p><p>I’m not saying you’re *not allowed* to define it as stopping there.  I’m saying that it depends on the type.  When you’re dealing with a reference type that has value semantics it should not stop there.  If the type has reference semantics then I agree that it should stop at the reference.<br></p><p>&gt; <br>&gt;&gt; This allows for local mutation on the same binding and also for un<br>&gt;&gt; observable mutation such as CoW in the implementation.  But it does<br>&gt;&gt; not allow for a mutation applied to one name binding having the type<br>&gt;&gt; to be observed through another name binding having the type.<br>&gt; <br>&gt; It sounds like you&#39;re trying to capture some notion of “can&#39;t possibly<br>&gt; reach shared mutable state through this instance,” but IMO there&#39;s a<br>&gt; false distinction here.  <br></p><p>That is not correct.  I am trying to capture the notion of an aggregate for which all operations observing the state of any part of the aggregate will always return the same result at any point in time.  This notion still allows for local mutation, which logically replaces the entire aggregate with a new aggregate.  This is a recursive property built from the leaves of the aggregate up.  As long as I am composing types that inherently have this property it will be preserved.  <br></p><p>It possible to preserve this property while making use of types that do not have this property as in the case of Array&lt;Int&gt;, Box&lt;Int&gt;, etc.  The examples I can think of here are all generic, value semantic types who preserve this property when Element has it, but obviously do not introduce the property when Element does not have it.<br></p><p>&gt; Fundamentally, there&#39;s no difference between a<br>&gt; reference to an object and an integer that can be used as an index into<br>&gt; a global array that contains a reference to the object, or even an<br>&gt; integer that can be used as an index into a global array that contains<br>&gt; an equivalent struct.<br></p><p>I understand what you’re saying here but I could’t disagree more.  There is a huge difference between the “value” of an integer and the “value” of a reference.  This difference is exhibited by the fact that we can perform arithmetic on integers and we can’t on references.  Just because you can *use* an integer to do something doesn’t mean that it’s *value* is intricately related to that use.  The *value* of a reference is intricately related to the operation of following the reference whereas the *value* of an integer is not.<br></p><p>&gt; <br>&gt; Again, I would like to see some piece of code that *actually depends on<br>&gt; this PureValue property for its correctness*.<br></p><p>I think Andrew gave a good example.  If I am writing a function that I intend to be a pure function my inputs must be “pure” (referentially transparent).  Identical inputs receive identical outputs.  Maybe I wish to memoize the result.  My function will not work correctly if it is supplied with Array&lt;UIView&gt;.  There is no guarantee that any state of the UIViews it inspects will be the same across function calls even when passed the exact same array in close succession.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt;       I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt;&gt;       property. However, it I (and many others) do believe it is an extremely<br>&gt;&gt;&gt;&gt;       valuable<br>&gt;&gt;&gt;&gt;       property in many cases. Do you disagree?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;&gt;&gt;   algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;&gt;&gt;   work just as well on Array&lt;Int&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Array&lt;Int&gt; provides the semantics I have in mind just fine so there wouldn’t be<br>&gt;&gt;&gt;&gt; any.  Array&lt;AnyObject&gt; is a completely different story. With<br>&gt;&gt;&gt;&gt; Array&lt;AnyObject&gt; you cannot rely on a guarantee the objects contained<br>&gt;&gt;&gt;&gt; in the array will not be mutated by code elsewhere that also happens<br>&gt;&gt;&gt;&gt; to have a reference to the same objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay then, what algorithms can you write that operate on PureValue that<br>&gt;&gt;&gt; don&#39;t work equally well on Array&lt;AnyObject&gt;?<br>&gt;&gt; <br>&gt;&gt; I am not sure.  It is possible that it does not apply to purely<br>&gt;&gt; algorithmic work.  That does not mean it is unimportant.  <br>&gt;&gt; It is quite valuable in application level code.  It think it would be<br>&gt;&gt; valuable to reify it with a protocol rather than leaving it to<br>&gt;&gt; documentation even if the compiler can&#39;t always prove our code meets<br>&gt;&gt; this semantic.<br>&gt; <br>&gt; For the purposes of library and language design, the ability to produce<br>&gt; use-cases (and solid definitions) is crucial.  The ability to show how<br>&gt; it substantively differs from concepts we already have is crucial.  If<br>&gt; we can&#39;t find these things, it doesn&#39;t belong.<br></p><p>I agree with you here.  I will continue trying to make the distinction more clear and precise.<br></p><p>&gt; <br>&gt;&gt; If you don&#39;t like the name PureValue for this concept lets bike shed.<br>&gt;&gt; I only used it because others had already used it.  Maybe there is a<br>&gt;&gt; better name.<br>&gt; <br>&gt; It&#39;s not the name that&#39;s the problem.  I don&#39;t even understand what<br>&gt; you&#39;re reaching for, or why.  Without a demonstration of what this is<br>&gt; for, I&#39;m going to continue to argue against it (though I&#39;m about to be<br>&gt; on vacation so I&#39;ll be out of your hair for a week).<br></p><p>Enjoy your vacation!<br></p><p>&gt; <br>&gt;&gt;&gt; I have been trying to get you to nail down what you mean by PureValue,<br>&gt;&gt;&gt; and I was trying to illustrate that merely being “a struct wrapping a<br>&gt;&gt;&gt; mutable reference type” is not enough to disqualify anything from being<br>&gt;&gt;&gt; in the category you&#39;re trying to describe.  What are the properties of<br>&gt;&gt;&gt; types in that category, and what generic code would depend on those<br>&gt;&gt;&gt; properties?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I hope my previous comments have helped to clarify this.<br>&gt; <br>&gt; I&#39;m afraid not yet.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/df58b0e4/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 19:48, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, this is the first mention I can find in the whole thread, honest.<br>&gt; Oh, it was a different thread.  Joe describes it as a protocol for<br>&gt; “types that represent fully self-contained values,” which is just fuzzy<br>&gt; enough that everyone reading it can have his own interpretation of what<br>&gt; it means.<br>FWIW, I&#39;ve been taking it to mean a) something that can always be correctly copied simply by copying its memory, and b) something for which equality can be determined by comparing memory (or at least won&#39;t give a false positive... I hadn&#39;t considered the &quot;0 == -0&quot; kind of equality until just now).<br></p><p>I&#39;m not sure that&#39;s any less fuzzy than the description you referenced, though. This thread has several terms that I&#39;m not as familiar with as I should be.<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t mean to imply that it is the *only* valuable<br>&gt;&gt; property. However, it I (and many others) do believe it is an extremely valuable<br>&gt;&gt; property in many cases. Do you disagree?<br>&gt; <br>&gt; I think I do.  What is valuable about such a protocol?  What generic<br>&gt; algorithms could you write that work on models of PureValue but don&#39;t<br>&gt; work just as well on Array&lt;Int&gt;?<br></p><p>class Storage {<br>  var element: Int = 0<br>}<br></p><p>struct Value {<br>  var storage: Storage<br>}<br></p><p>func amIPure(v: Value) -&gt; Int {<br>  v.storage.element = 3<br>  return v.storage.element<br>}<br></p><p>I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The developer needs to tell me where the boundaries of the value lie. Does &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer will need to implement CoW, or we need add some language features.<br></p><p>If I know about every operation inside &#39;amIPure&#39;, and know where the value&#39;s boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a &#39;PureValue&#39;. For example, I know that this function is pure without caring about &#39;PureValue&#39;.<br></p><p>func IAmPure(v: Value, s: Storage) -&gt; Int {<br>  var t = v<br>  t.storage = s<br>  return t.storage.element<br>}<br></p><p>However, I might only have summary information. I might know that the function only writes to memory reachable from Value. In that case, it would be nice to have summary information about the storage type. &#39;PureValue&#39; is another way of saying that it does not contain references to objects outside the value&#39;s boundary (I would add that it cannot have a user-defined deinit). The only thing vague about that is that we don&#39;t have a general way for the developer to define the value&#39;s boundary. It certainly should be consistent with &#39;==&#39;, but implementing &#39;==&#39; doesn&#39;t tell the optimizer anything.<br></p><p>Anyway, these are only optimizer concerns, and programming model should take precedence in these discussion. But I thought that might help.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/7f8a1ebc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt; property. However, it I (and many others) do believe it is an extremely valuable<br>&gt;&gt;&gt; property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt; I think I do.  What is valuable about such a protocol?  What generic<br>&gt;&gt; algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt; work just as well on Array&lt;Int&gt;?<br>&gt; <br>&gt; class Storage {<br>&gt;   var element: Int = 0<br>&gt; }<br>&gt; <br>&gt; struct Value {<br>&gt;   var storage: Storage<br>&gt; }<br>&gt; <br>&gt; func amIPure(v: Value) -&gt; Int {<br>&gt;   v.storage.element = 3<br>&gt;   return v.storage.element<br>&gt; }<br>&gt; <br>&gt; I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The developer needs to tell me where the boundaries of the value lie. Does &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer will need to implement CoW, or we need add some language features.<br></p><p>Thank you for this clear exposition of how PureValue relates to pure functions.  This is the exact intuition I have about it but you have stated it much more clearly.<br></p><p>Language features to help automate CoW would be great.  It would eliminate boilerplate, but more importantly it would likely provide more information to the compiler.<br></p><p>&gt; <br>&gt; If I know about every operation inside &#39;amIPure&#39;, and know where the value&#39;s boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a &#39;PureValue&#39;. For example, I know that this function is pure without caring about &#39;PureValue&#39;.<br>&gt; <br>&gt; func IAmPure(v: Value, s: Storage) -&gt; Int {<br>&gt;   var t = v<br>&gt;   t.storage = s<br>&gt;   return t.storage.element<br>&gt; }<br>&gt; <br>&gt; However, I might only have summary information. I might know that the function only writes to memory reachable from Value. In that case, it would be nice to have summary information about the storage type. &#39;PureValue&#39; is another way of saying that it does not contain references to objects outside the value&#39;s boundary (I would add that it cannot have a user-defined deinit). The only thing vague about that is that we don&#39;t have a general way for the developer to define the value&#39;s boundary. It certainly should be consistent with &#39;==&#39;, but implementing &#39;==&#39; doesn&#39;t tell the optimizer anything.<br></p><p>I think the ability to define the value&#39;s boundary would be wonderful.  If we added a way to do this it would be a requirement of PureValue.<br></p><p>&gt; <br>&gt; Anyway, these are only optimizer concerns, and programming model should take precedence in these discussion. But I thought that might help.<br>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/3799b66f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;ve been thinking about this further and can now state my position more clearly and concisely.<br></p><p>1. If we&#39;re going to have reference types with value semantics the boundary of the value must extend through the reference to the value of the object.  Two instances may have the same logical value so reference equality is not good enough.<br></p><p>2. Value types are not &quot;pure&quot; values if any part of the aggregate contains a reference whose type does not have value semantics.  Purity must include the entire aggregate.  Array&lt;UIView&gt; has value semantics but it is not a pure value.<br></p><p>The primary reasons I can think of for creating reference types with value semantics are avoiding copying everything all the time or using inheritance.  (I could also list pre-existing types here but am not as concerned with those)<br></p><p>One could argue that you can avoid copying by writing a struct with a handle and one can simulate inheritance by embedding and forwarding.  The problem is that this involves a lot of boilerplate and makes your code more complex.  For something like the standard library these concerns are far outweighed by the benefit we all gain by having our collections be value types.  However, in application code the benefit may not be worth the cost thus it may be reasonable to prefer immutable objects.<br></p><p>I think there is a viable path for enhancing the language such that there is little or not reason to implement a value semantic type as a reference type.  If we were able to declare value types as &quot;indirect&quot; and / or have a compiler supported Box (probably with syntactic sugar) that automatically forwarded calls, performed CoW, etc this would allow us much more control over copying without requiring boilerplate.  We could also add something along the lines of Go&#39;s embedding (or a more general forwarding mechanism which is my preference) which would likely address many of the reasons for using inheritance in a value semantic reference type.<br></p><p>If we do go down that path I think the case that value semantic types should be implemented as value types, thus reference equality should be the default equality for reference types gets much stronger.  In that hypothetical future Swift we might even be able to go so far as saying that reference types with value semantics are an anti-pattern and &quot;outlaw&quot; them.  This would allow us to simply say &quot;reference types have reference semantics&quot;.  <br></p><p>We might also be able to get to a place where we can &quot;outlaw&quot; value types that do not have value semantics.  I haven&#39;t thought deeply about that so I&#39;m not certain of the implications, particularly with regards to C interop.  IIRC Dave A indicated he would like to see this happen.  If this is possible, we may eventually have a language where &quot;value types have value semantics&quot;, &quot;some value types are pure values&quot;, and &quot;reference types have reference semantics and are never pure values&quot;.  If it is achievable it would be a significant step forward in simplicity and clarity.  <br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On May 7, 2016, at 11:17 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;&gt;&gt; property. However, it I (and many others) do believe it is an extremely valuable<br>&gt;&gt;&gt;&gt; property in many cases. Do you disagree?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I do.  What is valuable about such a protocol?  What generic<br>&gt;&gt;&gt; algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;&gt; work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; class Storage {<br>&gt;&gt;   var element: Int = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Value {<br>&gt;&gt;   var storage: Storage<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func amIPure(v: Value) -&gt; Int {<br>&gt;&gt;   v.storage.element = 3<br>&gt;&gt;   return v.storage.element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The developer needs to tell me where the boundaries of the value lie. Does &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer will need to implement CoW, or we need add some language features.<br>&gt; <br>&gt; Thank you for this clear exposition of how PureValue relates to pure functions.  This is the exact intuition I have about it but you have stated it much more clearly.<br>&gt; <br>&gt; Language features to help automate CoW would be great.  It would eliminate boilerplate, but more importantly it would likely provide more information to the compiler.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If I know about every operation inside &#39;amIPure&#39;, and know where the value&#39;s boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a &#39;PureValue&#39;. For example, I know that this function is pure without caring about &#39;PureValue&#39;.<br>&gt;&gt; <br>&gt;&gt; func IAmPure(v: Value, s: Storage) -&gt; Int {<br>&gt;&gt;   var t = v<br>&gt;&gt;   t.storage = s<br>&gt;&gt;   return t.storage.element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, I might only have summary information. I might know that the function only writes to memory reachable from Value. In that case, it would be nice to have summary information about the storage type. &#39;PureValue&#39; is another way of saying that it does not contain references to objects outside the value&#39;s boundary (I would add that it cannot have a user-defined deinit). The only thing vague about that is that we don&#39;t have a general way for the developer to define the value&#39;s boundary. It certainly should be consistent with &#39;==&#39;, but implementing &#39;==&#39; doesn&#39;t tell the optimizer anything.<br>&gt; <br>&gt; I think the ability to define the value&#39;s boundary would be wonderful.  If we added a way to do this it would be a requirement of PureValue.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Anyway, these are only optimizer concerns, and programming model should take precedence in these discussion. But I thought that might help.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/704bdef8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; I&#39;ve been thinking about this further and can now state my position more clearly<br>&gt; and concisely.<br>&gt;<br>&gt; 1. If we&#39;re going to have reference types with value semantics the boundary of<br>&gt; the value must extend through the reference to the value of the object. Two<br>&gt; instances may have the same logical value so reference equality is not good<br>&gt; enough.<br></p><p>My (radical) position has been that we should decree that if you really<br>want this thing to have value semantics, it should be a struct.  That<br>is, wrap your reference type in a struct and provide an == that looks at<br>what&#39;s in the instance.  This radically simplifies the model because we<br>can then assume that value types have value semantics and reference<br>types only have value semantics if you view their identitity as their<br>value.<br></p><p>&gt; 2. Value types are not &quot;pure&quot; values if any part of the aggregate contains a<br>&gt; reference whose type does not have value semantics. <br></p><p>Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>*not* have value semantics).  I don&#39;t think this is what you intend, and<br>it indicates that you need to keep working on your definition.<br></p><p>&gt; Purity must include the entire aggregate. Array&lt;UIView&gt; has value<br>&gt; semantics but it is not a pure value.<br></p><p>In what sense does it have value semantics?  Unless we can define<br>equality for Array&lt;UIView&gt; it&#39;s hard to make any claim about its value<br>semantics.<br></p><p>&gt; The primary reasons I can think of for creating reference types with value<br>&gt; semantics are avoiding copying everything all the time or using inheritance. (I<br>&gt; could also list pre-existing types here but am not as concerned with those)<br>&gt;<br>&gt; One could argue that you can avoid copying by writing a struct with a handle and<br>&gt; one can simulate inheritance by embedding and forwarding. The problem is that<br>&gt; this involves a lot of boilerplate and makes your code more complex. <br></p><p>The “forwarding boilerplate problem” is something we need to solve in<br>the language regardless.  The fact that we don&#39;t have an answer today<br>shouldn&#39;t prevent us from adopting the right model for values and<br>references.<br></p><p>&gt; For something like the standard library these concerns are far<br>&gt; outweighed by the benefit we all gain by having our collections be<br>&gt; value types. However, in application code the benefit may not be worth<br>&gt; the cost thus it may be reasonable to prefer immutable objects.<br>&gt;<br>&gt; I think there is a viable path for enhancing the language such that there is<br>&gt; little or not reason to implement a value semantic type as a reference type. If<br>&gt; we were able to declare value types as &quot;indirect&quot; and / or have a compiler<br>&gt; supported Box (probably with syntactic sugar) that automatically forwarded<br>&gt; calls, performed CoW, etc this would allow us much more control over copying<br>&gt; without requiring boilerplate. We could also add something along the lines of<br>&gt; Go&#39;s embedding (or a more general forwarding mechanism which is my preference)<br>&gt; which would likely address many of the reasons for using inheritance in a value<br>&gt; semantic reference type.<br>&gt;<br>&gt; If we do go down that path I think the case that value semantic types should be<br>&gt; implemented as value types, thus reference equality should be the default<br>&gt; equality for reference types gets much stronger. In that hypothetical future<br>&gt; Swift we might even be able to go so far as saying that reference types with<br>&gt; value semantics are an anti-pattern and &quot;outlaw&quot; them. This would allow us to<br>&gt; simply say &quot;reference types have reference semantics&quot;. <br>&gt;<br>&gt; We might also be able to get to a place where we can &quot;outlaw&quot; value types that<br>&gt; do not have value semantics. I haven&#39;t thought deeply about that so I&#39;m not<br>&gt; certain of the implications, particularly with regards to C interop. IIRC Dave A<br>&gt; indicated he would like to see this happen. If this is possible, we may<br>&gt; eventually have a language where &quot;value types have value semantics&quot;, &quot;some value<br>&gt; types are pure values&quot;, and &quot;reference types have reference semantics and are<br>&gt; never pure values&quot;. If it is achievable it would be a significant step forward<br>&gt; in simplicity and clarity. <br></p><p>So far, I still don&#39;t believe that introducing a “pure values” distinction is<br>adding simplicity and clarity.  To me it looks like a needless wrinkle.<br></p><p>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 7, 2016, at 11:17 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt;     Sent from my iPad<br>&gt;<br>&gt;     On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;             On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution<br>&gt;             &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;                         I don’t mean to imply that it is the *only* valuable<br>&gt;                 property. However, it I (and many others) do believe it is an<br>&gt;                 extremely valuable<br>&gt;                 property in many cases. Do you disagree?<br>&gt;<br>&gt;             I think I do. What is valuable about such a protocol? What generic<br>&gt;             algorithms could you write that work on models of PureValue but<br>&gt;             don&#39;t<br>&gt;             work just as well on Array&lt;Int&gt;?<br>&gt;<br>&gt;         class Storage {<br>&gt;         var element: Int = 0<br>&gt;         }<br>&gt;<br>&gt;         struct Value {<br>&gt;         var storage: Storage<br>&gt;         }<br>&gt;<br>&gt;         func amIPure(v: Value) -&gt; Int {<br>&gt;         v.storage.element = 3<br>&gt;         return v.storage.element<br>&gt;         }<br>&gt;<br>&gt;         I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The<br>&gt;         developer needs to tell me where the boundaries of the value lie. Does<br>&gt;         &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value<br>&gt;         is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the<br>&gt;         developer will need to implement CoW, or we need add some language<br>&gt;         features.<br>&gt;<br>&gt;     Thank you for this clear exposition of how PureValue relates to pure<br>&gt;     functions. This is the exact intuition I have about it but you have stated<br>&gt;     it much more clearly.<br>&gt;<br>&gt;     Language features to help automate CoW would be great. It would eliminate<br>&gt;     boilerplate, but more importantly it would likely provide more information<br>&gt;     to the compiler.<br>&gt;<br>&gt;         If I know about every operation inside &#39;amIPure&#39;, and know where the<br>&gt;         value&#39;s boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a<br>&gt;         &#39;PureValue&#39;. For example, I know that this function is pure without<br>&gt;         caring about &#39;PureValue&#39;.<br>&gt;<br>&gt;         func IAmPure(v: Value, s: Storage) -&gt; Int {<br>&gt;         var t = v<br>&gt;         t.storage = s<br>&gt;         return t.storage.element<br>&gt;         }<br>&gt;<br>&gt;         However, I might only have summary information. I might know that the<br>&gt;         function only writes to memory reachable from Value. In that case, it<br>&gt;         would be nice to have summary information about the storage type.<br>&gt;         &#39;PureValue&#39; is another way of saying that it does not contain references<br>&gt;         to objects outside the value&#39;s boundary (I would add that it cannot have<br>&gt;         a user-defined deinit). The only thing vague about that is that we don&#39;t<br>&gt;         have a general way for the developer to define the value&#39;s boundary. It<br>&gt;         certainly should be consistent with &#39;==&#39;, but implementing &#39;==&#39; doesn&#39;t<br>&gt;         tell the optimizer anything.<br>&gt;<br>&gt;     I think the ability to define the value&#39;s boundary would be wonderful. If we<br>&gt;     added a way to do this it would be a requirement of PureValue.<br>&gt;<br>&gt;         Anyway, these are only optimizer concerns, and programming model should<br>&gt;         take precedence in these discussion. But I thought that might help.<br>&gt;<br>&gt;         -Andy<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; 2. Value types are not &quot;pure&quot; values if any part of the aggregate contains a<br>&gt;&gt; reference whose type does not have value semantics. <br>&gt; <br>&gt; Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt; Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt; *not* have value semantics).  I don&#39;t think this is what you intend, and<br>&gt; it indicates that you need to keep working on your definition.<br></p><p><br>It sounds like you’re changing the definition of value semantics to make it impossible to define PureValue. Does Array&lt;T&gt; have value semantics then only if T also has value semantics?<br></p><p>The claim has been made that Array always has value semantics, implying that the array value’s boundary ends at the boundary of it’s element values. That fact is what allows the compiler to ignore mutation of the buffer.<br></p><p>It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue. PureValue is nothing more than transitive value semantics.<br></p><p>At any rate, we could add a PureValue magic protocol, and it would have well-defined meaning. I&#39;m not sure that it is worthwhile or even a good way to approach the problem. But we don&#39;t need to argue about the definition.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/172138c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 7:07 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 2. Value types are not &quot;pure&quot; values if any part of the aggregate contains a<br>&gt;&gt;&gt; reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt; Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt; Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt; *not* have value semantics).  I don&#39;t think this is what you intend, and<br>&gt;&gt; it indicates that you need to keep working on your definition.<br>&gt; <br>&gt; <br>&gt; It sounds like you’re changing the definition of value semantics to make it impossible to define PureValue. Does Array&lt;T&gt; have value semantics then only if T also has value semantics?<br>&gt; <br>&gt; The claim has been made that Array always has value semantics, implying that the array value’s boundary ends at the boundary of it’s element values. That fact is what allows the compiler to ignore mutation of the buffer.<br>&gt; <br>&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue. PureValue is nothing more than transitive value semantics.<br>&gt; <br>&gt; At any rate, we could add a PureValue magic protocol, and it would have well-defined meaning. I&#39;m not sure that it is worthwhile or even a good way to approach the problem. But we don&#39;t need to argue about the definition.<br></p><p>Thanks for jumping in again.  I hope we can get past the discussion of definition!<br></p><p>Are you speaking specifically about this being of use to the optimizer or about the value of such a protocol in general?<br></p><p>For example, if we introduce a notion of pure functions into the language wouldn’t it be useful to be able to write generic pure functions by constraining the argument types to PureValue?<br></p><p>IMO this property is important enough that the ability to express it directly in code (rather than documentation) and to take advantage of it in generic code is very desirable.  A PureValue protocol seems like a good way to do this but I am certainly open to other solutions as well.  <br></p><p>Long term it would be really nice if Swift had a logically pure subset and the ability to clearly distinguish code that lives inside that world from code that is outside that world.  I say “logically&quot; pure because I think implementation techniques like CoW, memoization, etc are very valuable and do not violate the spirit of purity despite the fact that they rely on side effects.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/b7878683/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;     On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;         2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;         contains a<br>&gt;         reference whose type does not have value semantics. <br>&gt;<br>&gt;     Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;     Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;     *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;     it indicates that you need to keep working on your definition.<br>&gt;<br>&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt; impossible to define PureValue. <br></p><p>Not on purpose.<br></p><p>&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt; semantics?<br></p><p>This is a great question; I had to rewrite my response four times.<br></p><p>In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>boundaries of element values as defined by ==.  That means that if T is<br>a mutable reference type, you&#39;re not looking through references, because<br>== is equivalent to ===.<br></p><p>Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>ValueSemantics, then<br></p><p>  Array&lt;T: SomeConstraint&gt;<br></p><p>only has value semantics if T has value semantics, since SomeConstraint<br>presumably uses aspects of T other than reference identity.  <br></p><p>&gt; The claim has been made that Array always has value semantics,<br>&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt; element values.<br></p><p>Yes, an array value ends at the boundary of its elements&#39; values.<br></p><p>&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt; buffer.<br></p><p>I don&#39;t know what you mean here.<br></p><p>&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt; PureValue is nothing more than transitive value semantics.<br></p><p>You&#39;re almost there.  “Transitive” implies that you are going to look at<br>the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>of the Array struct does one look at, and why?  Just tell me the<br>procedure for determining whether a type is a PureValue.<br></p><p>&gt; At any rate, we could add a PureValue magic protocol, and it would have<br>&gt; well-defined meaning. I&#39;m not sure that it is worthwhile or even a good way to<br>&gt; approach the problem. But we don&#39;t need to argue about the definition.<br></p><p>I don&#39;t want to argue about anything, really.  I just want a definition.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 7, 2016, at 11:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt; semantics?<br>&gt; <br>&gt; This is a great question; I had to rewrite my response four times.<br>&gt; <br>&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt; == is equivalent to ===.<br>&gt; <br>&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt; ValueSemantics, then<br>&gt; <br>&gt;  Array&lt;T: SomeConstraint&gt;<br>&gt; <br>&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt; presumably uses aspects of T other than reference identity.  <br></p><p>I just had a chance to digest Dave&#39;s answer. It explains a lot.<br></p><p>PureValue was defined in terms of the type&#39;s physical representation:<br>- A struct with no reference properties<br>- Recursively, a reference to immutable or uniquely referenced memory.<br></p><p>It&#39;s defined such that we can say Array&lt;T&gt; is a PureValue iff T is a PureValue.<br></p><p>There is currently no procedure for determining PureValue because we have no way to declare that references are immutable or uniquely referenced. It would be a promise by the developer.<br></p><p>Now attempting to look at it from Dave&#39;s direction, value semantics apply to the variable&#39;s type, not the object&#39;s physical representation:<br></p><p>let v2 = v1<br>f(v1)<br>assert(v1 == v2)<br></p><p>If everything is a value, then this always works. Great!<br></p><p>If the variable&#39;s type does not allow mutating shared state, then operations on the variable are operating on a value.<br></p><p>protocol ValueP {<br>  func compute() -&gt; Result // nonmutating<br>}<br></p><p>func g(v1 : ValueP) {<br>  let v2 = v1<br>  v1.compute()<br>  assert(v1 == v2)<br>}<br></p><p>Nice. ‘compute&#39; cannot change the value. Those value semantics do not tell me anything about shared state or function purity. For that, I need some additional constraint on &#39;compute&#39;. Knowing that it does not mutate the &#39;self&#39; value is insufficient.<br></p><p>One way of doing that, for example, is to declare that &#39;compute&#39; transitively cannot access globals *and* ValueP must be a PureValue. Now I can safely write this:<br></p><p>protocol ValueP : PureValue {<br>  @strawman_noglobal func compute() -&gt; Result<br>}<br></p><p>/// Return (v1.compute, v2.compute)<br>func g(v1 : ValueP, v2 : ValueP) -&gt; (Result, Result) {<br>  let r1 = v1.compute()<br>  if v1 == v2 {<br>    return (r1, r1)<br>  }<br>  return (r1, v2.compute())<br>}<br></p><p>So, Dave is right that we need to decide soon whether we can make stronger assumptions about value semantics. But that is a separate question from how to express function purity. I don&#39;t think there is any urgency in introducing things like the PureValue protocol or @strawman_noglobals attribute, now that we have clearly established shared-state-mutability-by-default. When we want to seriously have that discussion, we should consider other alternatives. I would prefer to wait until indirect structs and improved CoW support have had more discussion.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/4d24bb0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 9, 2016, at 3:01 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 7, 2016, at 11:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt; semantics?<br>&gt;&gt; <br>&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt; == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt; ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;  Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt; <br>&gt; I just had a chance to digest Dave&#39;s answer. It explains a lot.<br>&gt; <br>&gt; PureValue was defined in terms of the type&#39;s physical representation:<br>&gt; - A struct with no reference properties<br>&gt; - Recursively, a reference to immutable or uniquely referenced memory.<br>&gt; <br>&gt; It&#39;s defined such that we can say Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt; <br>&gt; There is currently no procedure for determining PureValue because we have no way to declare that references are immutable or uniquely referenced. It would be a promise by the developer.<br></p><p>Yes.  The same can be said of some semantic requirements in existing protocols, such as complexity requirements.  It is fair to observe that there is a difference here - not meeting complexity requirement slows things down, but doesn&#39;t fundamentally break.  Another example is the requirement to always return nil after you reach the end of IteratorType.<br></p><p>If it is possible to eventually have a mechanism that can be verified by the compiler we should wait to introduce the concept until that is in place.  Verifying value semantics would be the first step in that direction.<br></p><p>&gt; <br>&gt; Now attempting to look at it from Dave&#39;s direction, value semantics apply to the variable&#39;s type, not the object&#39;s physical representation:<br>&gt; <br>&gt; let v2 = v1<br>&gt; f(v1)<br>&gt; assert(v1 == v2)<br>&gt; <br>&gt; If everything is a value, then this always works. Great!<br>&gt; <br>&gt; If the variable&#39;s type does not allow mutating shared state, then operations on the variable are operating on a value.<br>&gt; <br>&gt; protocol ValueP {<br>&gt;   func compute() -&gt; Result // nonmutating<br>&gt; }<br>&gt; <br>&gt; func g(v1 : ValueP) {<br>&gt;   let v2 = v1<br>&gt;   v1.compute()<br>&gt;   assert(v1 == v2)<br>&gt; }<br>&gt; <br>&gt; Nice. ‘compute&#39; cannot change the value. Those value semantics do not tell me anything about shared state or function purity. For that, I need some additional constraint on &#39;compute&#39;. Knowing that it does not mutate the &#39;self&#39; value is insufficient.<br>&gt; <br>&gt; One way of doing that, for example, is to declare that &#39;compute&#39; transitively cannot access globals *and* ValueP must be a PureValue. Now I can safely write this:<br>&gt; <br>&gt; protocol ValueP : PureValue {<br>&gt;   @strawman_noglobal func compute() -&gt; Result<br>&gt; }<br>&gt; <br>&gt; /// Return (v1.compute, v2.compute)<br>&gt; func g(v1 : ValueP, v2 : ValueP) -&gt; (Result, Result) {<br>&gt;   let r1 = v1.compute()<br>&gt;   if v1 == v2 {<br>&gt;     return (r1, r1)<br>&gt;   }<br>&gt;   return (r1, v2.compute())<br>&gt; }<br>&gt; <br>&gt; So, Dave is right that we need to decide soon whether we can make stronger assumptions about value semantics. But that is a separate question from how to express function purity.<br></p><p>Agree.  Nailing down value semantics is a big step in the right direction.<br></p><p>&gt; I don&#39;t think there is any urgency in introducing things like the PureValue protocol or @strawman_noglobals attribute, now that we have clearly established shared-state-mutability-by-default. When we want to seriously have that discussion, we should consider other alternatives.<br></p><p>No argument from me.  I didn&#39;t mean to give a sense of urgency on this and am not attached to a specific mechanism.  I am advocating for the importance of eventually having a way to distinguish pure values from impure values (even if the have value semantics such as Array&lt;UIView&gt;).  If we don&#39;t get there in Swift 3 and the solution looks different than a PureValue protocol that is ok with me.<br></p><p>&gt; I would prefer to wait until indirect structs and improved CoW support have had more discussion.<br></p><p>I&#39;ve been thinking a lot about Dave&#39;s desire to &quot;mandate&quot; that value semantic types must be value types and allowing us to use reference identity for equality of reference types.  I would support that if these features were in place so I think shifting to those topics is a good next step for this discussion.  <br></p><p>Along those lines, I&#39;ve been thinking about a proposal to allow the indirect modifier on any property that has a value type.  It may also be useful to allow the indirect modifier directly on struct and enum to allow type authors to indicate that all instances should be indirect.  Do you think it would it be worthwhile to pursue this proposal now?<br></p><p>Can you elaborate on what you have in mind with regards to improved CoW support?  Is there any chance of doing something here in Swift 3?<br> <br>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/aa866f11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 9, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; I would prefer to wait until indirect structs and improved CoW support have had more discussion.<br>&gt; <br>&gt; I&#39;ve been thinking a lot about Dave&#39;s desire to &quot;mandate&quot; that value semantic types must be value types and allowing us to use reference identity for equality of reference types.  I would support that if these features were in place so I think shifting to those topics is a good next step for this discussion.  <br>&gt; <br>&gt; Along those lines, I&#39;ve been thinking about a proposal to allow the indirect modifier on any property that has a value type.  It may also be useful to allow the indirect modifier directly on struct and enum to allow type authors to indicate that all instances should be indirect.  Do you think it would it be worthwhile to pursue this proposal now?<br>&gt; <br>&gt; Can you elaborate on what you have in mind with regards to improved CoW support?  Is there any chance of doing something here in Swift 3?<br></p><p>I don’t have anything specific planned for CoW support in Swift 3, otherwise I would have started a separate thread :)<br>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/06c19478/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 1:03 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 9, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I would prefer to wait until indirect structs and improved CoW support have had more discussion.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been thinking a lot about Dave&#39;s desire to &quot;mandate&quot; that value semantic types must be value types and allowing us to use reference identity for equality of reference types.  I would support that if these features were in place so I think shifting to those topics is a good next step for this discussion.  <br>&gt;&gt; <br>&gt;&gt; Along those lines, I&#39;ve been thinking about a proposal to allow the indirect modifier on any property that has a value type.  It may also be useful to allow the indirect modifier directly on struct and enum to allow type authors to indicate that all instances should be indirect.  Do you think it would it be worthwhile to pursue this proposal now?<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on what you have in mind with regards to improved CoW support?  Is there any chance of doing something here in Swift 3?<br>&gt; <br>&gt; I don’t have anything specific planned for CoW support in Swift 3, otherwise I would have started a separate thread :)<br></p><p>Sure.  I’m still curious about ideas you have for the future.<br></p><p>I’m also interested in your feedback on whether a proposal around indirect is something worth pursuing right now or whether that is something that should wait until after Swift 3.<br></p><p><br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/09ee588c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 4:07 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I’m also interested in your feedback on whether a proposal around indirect is something worth pursuing right now or whether that is something that should wait until after Swift 3.<br></p><p>I’m not prepared to champion this for Swift 3, I think there are enough other important proposals on the table, and this is an area that requires careful design. If I did have to pick features that we touched on in this thread from most to least important I would say:<br>1. Indirect structs<br>2. Mutability of reference/class types<br>3. Automation or annotations for CoW types.<br>4. Annotations that constrain function side effects.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/5fd39a0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 10, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 00:53, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 9, 2016, at 4:07 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m also interested in your feedback on whether a proposal around indirect is something worth pursuing right now or whether that is something that should wait until after Swift 3.<br>&gt; <br>&gt; I’m not prepared to champion this for Swift 3, I think there are enough other important proposals on the table, and this is an area that requires careful design. If I did have to pick features that we touched on in this thread from most to least important I would say:<br>&gt; 1. Indirect structs<br>&gt; 2. Mutability of reference/class types<br>&gt; 3. Automation or annotations for CoW types.<br>&gt; 4. Annotations that constrain function side effects.<br>&gt; <br>&gt; -Andy<br></p><p>Yes, but with possible exception of #2, none of those sound like source-breaking changes. I&#39;d imagine that changing what types of properties value-types can have will break a few things (although I certainly could be wrong).<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/1d9a521b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 12:53 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 9, 2016, at 4:07 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m also interested in your feedback on whether a proposal around indirect is something worth pursuing right now or whether that is something that should wait until after Swift 3.<br>&gt; <br>&gt; I’m not prepared to champion this for Swift 3, I think there are enough other important proposals on the table, and this is an area that requires careful design.<br></p><p>That&#39;s what I suspected and why I asked before taking time to write something up.  I&#39;ll be patient and look forward to this in the future.<br></p><p>I should add that if a decisions on the changes Dave is looking for must happen in Swift 3 or never I support doing it.  While I am concerned about the boilerplate I would prefer some boilerplate in the short term to a suboptimal design in the long term.<br></p><p>&gt; If I did have to pick features that we touched on in this thread from most to least important I would say:<br>&gt; 1. Indirect structs<br>&gt; 2. Mutability of reference/class types<br>&gt; 3. Automation or annotations for CoW types.<br>&gt; 4. Annotations that constrain function side effects.<br></p><p>That sounds like the right priorities to me as well. <br></p><p>&gt; <br>&gt; -Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/8c517149/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 9, 2016, at 3:01 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 7, 2016, at 11:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt; semantics?<br>&gt;&gt; <br>&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt; == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt; ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;  Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt; <br>&gt; I just had a chance to digest Dave&#39;s answer. It explains a lot.<br>&gt; <br>&gt; PureValue was defined in terms of the type&#39;s physical representation:<br>&gt; - A struct with no reference properties<br>&gt; - Recursively, a reference to immutable or uniquely referenced memory.<br>&gt; <br>&gt; It&#39;s defined such that we can say Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt; <br>&gt; There is currently no procedure for determining PureValue because we have no way to declare that references are immutable or uniquely referenced. It would be a promise by the developer.<br>&gt; <br>&gt; Now attempting to look at it from Dave&#39;s direction, value semantics apply to the variable&#39;s type, not the object&#39;s physical representation:<br>&gt; <br>&gt; let v2 = v1<br>&gt; f(v1)<br>&gt; assert(v1 == v2)<br>&gt; <br>&gt; If everything is a value, then this always works. Great!<br>&gt; <br>&gt; If the variable&#39;s type does not allow mutating shared state, then operations on the variable are operating on a value.<br>&gt; <br>&gt; protocol ValueP {<br>&gt;   func compute() -&gt; Result // nonmutating<br>&gt; }<br>&gt; <br>&gt; func g(v1 : ValueP) {<br>&gt;   let v2 = v1<br>&gt;   v1.compute()<br>&gt;   assert(v1 == v2)<br>&gt; }<br>&gt; <br>&gt; Nice. ‘compute&#39; cannot change the value. Those value semantics do not tell me anything about shared state or function purity. For that, I need some additional constraint on &#39;compute&#39;. Knowing that it does not mutate the &#39;self&#39; value is insufficient.<br>&gt; <br>&gt; One way of doing that, for example, is to declare that &#39;compute&#39; transitively cannot access globals *and* ValueP must be a PureValue. Now I can safely write this:<br>&gt; <br>&gt; protocol ValueP : PureValue {<br>&gt;   @strawman_noglobal func compute() -&gt; Result<br>&gt; }<br>&gt; <br>&gt; /// Return (v1.compute, v2.compute)<br>&gt; func g(v1 : ValueP, v2 : ValueP) -&gt; (Result, Result) {<br>&gt;   let r1 = v1.compute()<br>&gt;   if v1 == v2 {<br>&gt;     return (r1, r1)<br>&gt;   }<br>&gt;   return (r1, v2.compute())<br>&gt; }<br>&gt; <br>&gt; So, Dave is right that we need to decide soon whether we can make stronger assumptions about value semantics. But that is a separate question from how to express function purity. I don&#39;t think there is any urgency in introducing things like the PureValue protocol or @strawman_noglobals attribute, now that we have clearly established shared-state-mutability-by-default. When we want to seriously have that discussion, we should consider other alternatives. I would prefer to wait until indirect structs and improved CoW support have had more discussion.<br></p><p>One more thing that I think we would all agree must come first is some way to specify in code that a type has value semantics (whether or not it is pure).  Is there any ongoing discussion about that?<br></p><p>&gt; <br>&gt; -Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/5ed4dbf3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;        contains a<br>&gt;&gt;        reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt;    Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;    Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;    *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;    it indicates that you need to keep working on your definition.<br>&gt;&gt; <br>&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt; impossible to define PureValue. <br>&gt; <br>&gt; Not on purpose.<br>&gt; <br>&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt; semantics?<br>&gt; <br>&gt; This is a great question; I had to rewrite my response four times.<br>&gt; <br>&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt; == is equivalent to ===.<br>&gt; <br>&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt; ValueSemantics, then<br>&gt; <br>&gt;  Array&lt;T: SomeConstraint&gt;<br>&gt; <br>&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt; presumably uses aspects of T other than reference identity.  <br>&gt; <br>&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt; element values.<br>&gt; <br>&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt; <br>&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt; buffer.<br>&gt; <br>&gt; I don&#39;t know what you mean here.<br>&gt; <br>&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt; <br>&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt; procedure for determining whether a type is a PureValue.<br></p><p>We look at the observable parts.  We do not look at unobservable parts because we want flexibility to use things like CoW, shared immutable references, etc in our implementation.<br></p><p>Can you share your definition of value semantics?  It may be helpful if we start there and refine your definition to exclude impure value types like Array&lt;UIView&gt;.<br></p><p>In the meantime I’ll take another shot:<br></p><p>1. Scalars are pure values.<br>2. Any aggregate type with value semantics is a pure value iff all observable parts of the aggregate are pure values.<br></p><p><br></p><p>&gt; <br>&gt;&gt; At any rate, we could add a PureValue magic protocol, and it would have<br>&gt;&gt; well-defined meaning. I&#39;m not sure that it is worthwhile or even a good way to<br>&gt;&gt; approach the problem. But we don&#39;t need to argue about the definition.<br>&gt; <br>&gt; I don&#39;t want to argue about anything, really.  I just want a definition.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;        contains a<br>&gt;&gt;&gt;        reference whose type does not have value semantics. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;    Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;    *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;    it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt; <br>&gt;&gt; Not on purpose.<br>&gt;&gt; <br>&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt; semantics?<br>&gt;&gt; <br>&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt; == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt; ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;  Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt; <br>&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt; element values.<br>&gt;&gt; <br>&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt; <br>&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt; buffer.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt; <br>&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;<br>&gt; We look at the observable parts.  <br></p><p>That begs the question.  The “parts” of an Array are the observable<br>features that are considered by equality.<br></p><p>&gt; We do not look at unobservable parts because we want flexibility to<br>&gt; use things like CoW, shared immutable references, etc in our<br>&gt; implementation.<br></p><p>IMO the important thing when it comes to functional purity is not what<br>you *can* observe, but what you *do* observe.<br></p><p>&gt; Can you share your definition of value semantics?  <br></p><p>Explaining it well and in sufficient detail for this discussion takes<br>some doing, but I think John Lakos and I share an understanding of value<br>semantics and he has a really detailed explanation in<br>https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>as well to Swift.<br></p><p>&gt; It may be helpful<br>&gt; if we start there and refine your definition to exclude impure value<br>&gt; types like Array&lt;UIView&gt;.<br>&gt;<br>&gt; In the meantime I’ll take another shot:<br>&gt;<br>&gt; 1. Scalars are pure values.<br>&gt;<br>&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;    observable parts of the aggregate are pure values.<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt; <br>&gt;&gt; We look at the observable parts.  <br>&gt; <br>&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt; features that are considered by equality.<br>&gt; <br>&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt; implementation.<br>&gt; <br>&gt; IMO the important thing when it comes to functional purity is not what<br>&gt; you *can* observe, but what you *do* observe.<br>&gt; <br>&gt;&gt; Can you share your definition of value semantics?  <br>&gt; <br>&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt; semantics and he has a really detailed explanation in<br>&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt; as well to Swift.<br>&gt; <br></p><p>Super interesting talk! <br></p><p>But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br></p><p>std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br></p><p>1. the size is<br>2. the values in the vector are<br>3. the capacity, however *is not*<br></p><p>in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br></p><p>John avoids the problem by saying that this must specified in the documentation.<br></p><p>I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br></p><p>This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br></p><p>What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br></p><p>John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br></p><p>I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br></p><p>I really apologize if this seems like rambling again, but I am very interested in this problem.<br></p><p>Tyler<br></p><p><br></p><p><br>&gt;&gt; It may be helpful<br>&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt; <br>&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt; <br>&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt; <br>&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/fcde4f86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 15, 2016, at 11:17 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com &lt;http://atrick-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt; features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt; implementation.<br>&gt;&gt; <br>&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt; as well to Swift.<br>&gt;&gt; <br>&gt; <br>&gt; Super interesting talk! <br>&gt; <br>&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt; <br>&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt; <br>&gt; 1. the size is<br>&gt; 2. the values in the vector are<br>&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br>&gt; <br>&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt; <br>&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt; <br>&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br></p><p>John refers to this at 52:26 in the first video and mentions that this is not full value semantics. I assume, then, that PureValues would have full value semantics.<br></p><p>&gt; <br>&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br>&gt; <br>&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt; <br>&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/687a03b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 16, 2016 at 12:00:00am</p></header><div class="content"><p>on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt; guaranteed to be immutable, since it is allowed to include<br>&gt;&gt; non-salient attributes. For example, a vector’s capacity could<br>&gt;&gt; change at any time, by virtue of it being stored via a reference.<br>&gt;<br>&gt; John refers to this at 52:26 in the first video and mentions that this<br>&gt; is not full value semantics. <br></p><p>Huh, maybe I don&#39;t agree with him as much as I thought.  But I&#39;ll check<br>it out and see.  Thanks for the reference.<br></p><p>-- <br>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 1:38 AM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 15, 2016, at 11:17 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com &lt;http://atrick-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt; features that are considered by equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt;&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt; as well to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt;&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt;&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br>&gt; <br>&gt; John refers to this at 52:26 in the first video and mentions that this is not full value semantics. I assume, then, that PureValues would have full value semantics.<br></p><p>Yes, I believe my notion of “pure value” corresponds exactly with what John calls “full value semantics”<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br>&gt;&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt;&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/fa373ffb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 11:00:00pm</p></header><div class="content"><p>on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;     On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;             On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;             on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;<br>&gt;                   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;                       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;                       contains a<br>&gt;                       reference whose type does not have value semantics. <br>&gt;<br>&gt;                   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;                   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;                   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;                   it indicates that you need to keep working on your definition.<br>&gt;<br>&gt;                 It sounds like you’re changing the definition of value semantics to make it<br>&gt;                 impossible to define PureValue. <br>&gt;<br>&gt;             Not on purpose.<br>&gt;<br>&gt;                 Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;                 semantics?<br>&gt;<br>&gt;             This is a great question; I had to rewrite my response four times.<br>&gt;<br>&gt;             In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;             boundaries of element values as defined by ==.  That means that if T is<br>&gt;             a mutable reference type, you&#39;re not looking through references, because<br>&gt;             == is equivalent to ===.<br>&gt;<br>&gt;             Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;             ValueSemantics, then<br>&gt;<br>&gt;             Array&lt;T: SomeConstraint&gt;<br>&gt;<br>&gt;             only has value semantics if T has value semantics, since SomeConstraint<br>&gt;             presumably uses aspects of T other than reference identity.  <br>&gt;<br>&gt;                 The claim has been made that Array always has value semantics,<br>&gt;                 implying that the array value’s boundary ends at the boundary of it’s<br>&gt;                 element values.<br>&gt;<br>&gt;             Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;<br>&gt;                 That fact is what allows the compiler to ignore mutation of the<br>&gt;                 buffer.<br>&gt;<br>&gt;             I don&#39;t know what you mean here.<br>&gt;<br>&gt;                 It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;                 PureValue is nothing more than transitive value semantics.<br>&gt;<br>&gt;             You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;             the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;             of the Array struct does one look at, and why?  Just tell me the<br>&gt;             procedure for determining whether a type is a PureValue.<br>&gt;<br>&gt;         We look at the observable parts.  <br>&gt;<br>&gt;     That begs the question.  The “parts” of an Array are the observable<br>&gt;     features that are considered by equality.<br>&gt;<br>&gt;         We do not look at unobservable parts because we want flexibility to<br>&gt;         use things like CoW, shared immutable references, etc in our<br>&gt;         implementation.<br>&gt;<br>&gt;     IMO the important thing when it comes to functional purity is not what<br>&gt;     you *can* observe, but what you *do* observe.<br>&gt;<br>&gt;         Can you share your definition of value semantics?  <br>&gt;<br>&gt;     Explaining it well and in sufficient detail for this discussion takes<br>&gt;     some doing, but I think John Lakos and I share an understanding of value<br>&gt;     semantics and he has a really detailed explanation in<br>&gt;     https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;     https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;     but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;     as well to Swift.<br>&gt;<br>&gt; Super interesting talk! <br>&gt;<br>&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt; ethereal types?<br></p><p>“ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br></p><p>&gt;<br>&gt; std::vector is a good example. What are the salient attributes of this<br>&gt; type? In the talk John says that<br>&gt;<br>&gt; 1. the size is<br>&gt; 2. the values in the vector are<br>&gt; 3. the capacity, however *is not*<br></p><p>Yup, just like Array.  Thus the equality test for arrays ignores<br>capacity.<br></p><p>&gt; in which case std::vector would be an approximation of an ethereal<br>&gt; type which has a list of values, and the capacity is just an artifact<br>&gt; of the approximation. But you could also imagine an ethereal type<br>&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt; unwittingly approximates that type too! In this case someone,<br>&gt; unfamiliar with the implementation might use it under the assumption<br>&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt; equality of std::vector.<br>&gt;<br>&gt; John avoids the problem by saying that this must specified in the<br>&gt; documentation.<br></p><p>Yes.<br></p><p>&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt; the implementation of the equality operator to be able to determine if<br>&gt; a public property, the capacity, is part of the ethereal type. <br></p><p>No, you just need documentation.<br></p><p>&gt; It’s not always the case that you have access to either the<br>&gt; documentation or the implementation.<br></p><p>Without the documentation, you&#39;re lost.  We go a lot further with naming<br>conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>expect to fully understand semantics without documentation.<br></p><p>&gt; This implies, therefore, that if salient attributes *define* the<br>&gt; immutability of the value type, then the public interface is not<br>&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt; by virtue of it being stored via a reference.<br>&gt;<br>&gt; What I am saying is that a PureValue is a value type whose public<br>&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt; this is a useful distinction amongst value types.<br></p><p>Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>semantics.<br></p><p>&gt; John also says that a salient attribute must derive *only* from the<br>&gt; state of a particular instance of a type. This by extension implies<br>&gt; that a salient attribute must derive exclusively from pure<br>&gt; values. However, this also means that without some “indirect” keyword,<br>&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;<br>&gt; I also claim that equality can be automatically generated for<br>&gt; PureValues by equating each of there salient attributes.<br></p><p>That&#39;s true for almost any value, provided we define equality for<br>reference types properly.<br></p><p>&gt; I really apologize if this seems like rambling again, but I am very<br>&gt; interested in this problem.<br></p><p>I&#39;m glad you are! Few programmers dig far enough to understand value<br>semantics at a deep level.<br></p><p>All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>forgetting something that happened in the thread two weeks ago, nobody<br>has shown me code that relies on PureValue but could not equally well be<br>written by using a Value constraint.<br></p><p>&gt; Tyler<br>&gt;<br>&gt;         It may be helpful<br>&gt;         if we start there and refine your definition to exclude impure value<br>&gt;         types like Array&lt;UIView&gt;.<br>&gt;<br>&gt;         In the meantime I’ll take another shot:<br>&gt;<br>&gt;         1. Scalars are pure values.<br>&gt;<br>&gt;         2. Any aggregate type with value semantics is a pure value iff all<br>&gt;           observable parts of the aggregate are pure values.<br>&gt;<br>&gt;     -- <br>&gt;     -Dave<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 16, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 11:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                  On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                      2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;                      contains a<br>&gt;&gt;                      reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt;                  Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;                  Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;                  *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;                  it indicates that you need to keep working on your definition.<br>&gt;&gt; <br>&gt;&gt;                It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;                impossible to define PureValue. <br>&gt;&gt; <br>&gt;&gt;            Not on purpose.<br>&gt;&gt; <br>&gt;&gt;                Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;                semantics?<br>&gt;&gt; <br>&gt;&gt;            This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt;            In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;            boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;            a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;            == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt;            Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;            ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;            Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt;            only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;            presumably uses aspects of T other than reference identity.  <br>&gt;&gt; <br>&gt;&gt;                The claim has been made that Array always has value semantics,<br>&gt;&gt;                implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;                element values.<br>&gt;&gt; <br>&gt;&gt;            Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt; <br>&gt;&gt;                That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;                buffer.<br>&gt;&gt; <br>&gt;&gt;            I don&#39;t know what you mean here.<br>&gt;&gt; <br>&gt;&gt;                It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;                PureValue is nothing more than transitive value semantics.<br>&gt;&gt; <br>&gt;&gt;            You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;            the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;            of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;            procedure for determining whether a type is a PureValue.<br>&gt;&gt; <br>&gt;&gt;        We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt;    That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;    features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;        We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;        use things like CoW, shared immutable references, etc in our<br>&gt;&gt;        implementation.<br>&gt;&gt; <br>&gt;&gt;    IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;    you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;        Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt;    Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;    some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;    semantics and he has a really detailed explanation in<br>&gt;&gt;    https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;    https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;    but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;    as well to Swift.<br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt; ethereal types?<br>&gt; <br>&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br></p><p>He does pretty frequently. He also refers to them as Mathematical Types. He means the logical type that the C++ implementation is supposed to approximate.<br></p><p>An example he gives is int and how it only approximates the logical Integer type, because it is represented in many ways, e.g. short, int, long, long long. None of them are exactly the same the logical type.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt; type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt; capacity.<br>&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt; equality of std::vector.<br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt; documentation.<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt; <br>&gt; No, you just need documentation.<br>&gt; <br>&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt; documentation or the implementation.<br>&gt; <br>&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt; expect to fully understand semantics without documentation.<br></p><p>Swift also goes a lot further with enforcing things like immutability by default with let, particularly for value types. I think that with well defined rules you can go further with what’s enforced, and remove the need for documentation, especially since the distinctions with regards to value types can be subtle.<br></p><p>&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt; this is a useful distinction amongst value types.<br>&gt; <br>&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt; semantics.<br></p><p>I would argue, rather, that capacity for Array&lt;Int&gt; *is* a salient attribute, by virtue being public and that Array&lt;Int&gt; is a PureValue by virtue of it not having reference semantics. This I propose is valid, because even though it’s not the most intuitive in this case, it is possible that some algorithm interprets capacity to be salient and relies on two arrays with different capacities being not equal.<br></p><p>I can certainly understand the opposing argument here, but at least this way it is unambiguous.<br></p><p>&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt; reference types properly.<br>&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt; interested in this problem.<br>&gt; <br>&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt; semantics at a deep level.<br>&gt; <br>&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt; written by using a Value constraint.<br></p><p>Let me get back to you here. I need to do more investigation!<br></p><p>Gotta watch that second video.<br></p><p>Tyler<br></p><p>&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;        It may be helpful<br>&gt;&gt;        if we start there and refine your definition to exclude impure value<br>&gt;&gt;        types like Array&lt;UIView&gt;.<br>&gt;&gt; <br>&gt;&gt;        In the meantime I’ll take another shot:<br>&gt;&gt; <br>&gt;&gt;        1. Scalars are pure values.<br>&gt;&gt; <br>&gt;&gt;        2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;          observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    -Dave<br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 16, 2016 at 02:00:00am</p></header><div class="content"><p>on Mon May 16 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;&gt;&gt; Super interesting talk! <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt;&gt; ethereal types?<br>&gt;&gt; <br>&gt;&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt;<br>&gt; He does pretty frequently. He also refers to them as Mathematical<br>&gt; Types. He means the logical type that the C++ implementation is<br>&gt; supposed to approximate.<br></p><p>OK.<br></p><p>&gt; An example he gives is int and how it only approximates the logical<br>&gt; Integer type, because it is represented in many ways, e.g. short, int,<br>&gt; long, long long. None of them are exactly the same the logical type.<br></p><p>Check.<br></p><p>&gt;&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt;&gt; type? In the talk John says that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. the size is<br>&gt;&gt;&gt; 2. the values in the vector are<br>&gt;&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt; <br>&gt;&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt;&gt; capacity.<br>&gt;&gt; <br>&gt;&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt;&gt; unwittingly approximates that type too! <br>&gt;&gt;&gt; In this case someone, unfamiliar with the implementation might use<br>&gt;&gt;&gt; it under the assumption that capacity *is* part of the ethereal type<br>&gt;&gt;&gt; and by extension the equality of std::vector.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt;&gt; documentation.<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt;&gt; <br>&gt;&gt; No, you just need documentation.<br>&gt;&gt; <br>&gt;&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt;&gt; documentation or the implementation.<br>&gt;&gt; <br>&gt;&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt;&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt;&gt; expect to fully understand semantics without documentation.<br>&gt;<br>&gt; Swift also goes a lot further with enforcing things like immutability<br>&gt; by default with let, particularly for value types. I think that with<br>&gt; well defined rules you can go further with what’s enforced, and remove<br>&gt; the need for documentation, especially since the distinctions with<br>&gt; regards to value types can be subtle.<br></p><p>Remove the need for documentation! Good luck with that, my friend.<br></p><p>&gt;&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt;&gt; this is a useful distinction amongst value types.<br>&gt;&gt; <br>&gt;&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt;&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt;&gt; semantics.<br>&gt;<br>&gt; I would argue, rather, that capacity for Array&lt;Int&gt; *is* a salient<br>&gt; attribute, by virtue being public <br></p><p>Then you&#39;re missing the point.  There would be no point in making the<br>distinction “salient” if all public API were salient.  Lakos only<br>considers public API.<br></p><p>&gt; and that Array&lt;Int&gt; is a PureValue by virtue of it not having<br>&gt; reference semantics. This I propose is valid, because even though it’s<br>&gt; not the most intuitive in this case, it is possible that some<br>&gt; algorithm interprets capacity to be salient and relies on two arrays<br>&gt; with different capacities being not equal.<br>&gt;<br>&gt; I can certainly understand the opposing argument here, but at least<br>&gt; this way it is unambiguous.<br></p><p>Capacity, in Lakos&#39; terms, is non-salient, and that&#39;s unambiguous.<br></p><p>&gt;&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt;&gt; <br>&gt;&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt;&gt; reference types properly.<br>&gt;&gt; <br>&gt;&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt;&gt; interested in this problem.<br>&gt;&gt; <br>&gt;&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt;&gt; semantics at a deep level.<br>&gt;&gt; <br>&gt;&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt;&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt;&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt;&gt; written by using a Value constraint.<br>&gt;<br>&gt; Let me get back to you here. I need to do more investigation!<br>&gt;<br>&gt; Gotta watch that second video.<br></p><p>Enjoy!<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 16, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 2:16 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 16 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Super interesting talk! <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt;&gt;&gt; ethereal types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt;&gt; <br>&gt;&gt; He does pretty frequently. He also refers to them as Mathematical<br>&gt;&gt; Types. He means the logical type that the C++ implementation is<br>&gt;&gt; supposed to approximate.<br>&gt; <br>&gt; OK.<br>&gt; <br>&gt;&gt; An example he gives is int and how it only approximates the logical<br>&gt;&gt; Integer type, because it is represented in many ways, e.g. short, int,<br>&gt;&gt; long, long long. None of them are exactly the same the logical type.<br>&gt; <br>&gt; Check.<br>&gt; <br>&gt;&gt;&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt;&gt;&gt; type? In the talk John says that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. the size is<br>&gt;&gt;&gt;&gt; 2. the values in the vector are<br>&gt;&gt;&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt;&gt;&gt; capacity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt;&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt;&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt;&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt;&gt;&gt; unwittingly approximates that type too! <br>&gt;&gt;&gt;&gt; In this case someone, unfamiliar with the implementation might use<br>&gt;&gt;&gt;&gt; it under the assumption that capacity *is* part of the ethereal type<br>&gt;&gt;&gt;&gt; and by extension the equality of std::vector.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt;&gt;&gt; documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt;&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt;&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, you just need documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt;&gt;&gt; documentation or the implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt;&gt;&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt;&gt;&gt; expect to fully understand semantics without documentation.<br>&gt;&gt; <br>&gt;&gt; Swift also goes a lot further with enforcing things like immutability<br>&gt;&gt; by default with let, particularly for value types. I think that with<br>&gt;&gt; well defined rules you can go further with what’s enforced, and remove<br>&gt;&gt; the need for documentation, especially since the distinctions with<br>&gt;&gt; regards to value types can be subtle.<br>&gt; <br>&gt; Remove the need for documentation! Good luck with that, my friend.<br>&gt; <br>&gt;&gt;&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt;&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt;&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt;&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt;&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt;&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt;&gt;&gt; this is a useful distinction amongst value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt;&gt;&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt;&gt;&gt; semantics.<br>&gt;&gt; <br>&gt;&gt; I would argue, rather, that capacity for Array&lt;Int&gt; *is* a salient<br>&gt;&gt; attribute, by virtue being public <br>&gt; <br>&gt; Then you&#39;re missing the point.  There would be no point in making the<br>&gt; distinction “salient” if all public API were salient.  Lakos only<br>&gt; considers public API.<br></p><p>I’m certainly not missing the point. He is saying that not all public API is “salient” because it doesn’t pertain to the logical or ethereal type. I’m saying that not everybody will agree on what the ethereal type is, thus they will not agree on what is salient.<br></p><p>One what to eliminate the possibility of disagreement is do define the ethereal type as what is presented as public API, thus the entire public API is salient. No more need for the “salient” distinction, that all goes away.<br></p><p>Whether or not you think this is a good idea is another thing entirely.<br></p><p>&gt; <br>&gt;&gt; and that Array&lt;Int&gt; is a PureValue by virtue of it not having<br>&gt;&gt; reference semantics. This I propose is valid, because even though it’s<br>&gt;&gt; not the most intuitive in this case, it is possible that some<br>&gt;&gt; algorithm interprets capacity to be salient and relies on two arrays<br>&gt;&gt; with different capacities being not equal.<br>&gt;&gt; <br>&gt;&gt; I can certainly understand the opposing argument here, but at least<br>&gt;&gt; this way it is unambiguous.<br>&gt; <br>&gt; Capacity, in Lakos&#39; terms, is non-salient, and that&#39;s unambiguous.<br>&gt; <br></p><p>“In Lakos’ terms”<br></p><p>I don’t think many people are familiar with Lakos’ terms, and thus it is quite ambiguous, that’s kinda my point. What is salient to you is not necessarily what is salient to me.<br></p><p>I’m suggesting is that == should have a very well defined, enforceable, and auto-generatable meaning based on the actual bits in a value type and that it should only have this meaning. Other such notions of equality, equivalence, similarity, sameness, or whatever, should be reserved for named functions.<br></p><p>Lakos also talks about this type of thing in the next video.<br></p><p>myGraph.isIsomorphicTo(anotherGraph)<br>myRegex.acceptsSameLanguage(as: anotherRegex)<br></p><p>In this way, what is salient is explicit.<br></p><p>==  would just does a component-wise compare on the each of the values, right down to the bits (exactly the same bits that can be rendered immutable with let). With indirect this could be extended to compare the value of arbitrary structures. With references it would just do reference compare. <br></p><p>struct MyRegex {<br>	let regexString: String<br>}<br></p><p>let x = MyRegex(regexString: “(a+b)* b (a+b)* b (a+b)*&quot;)<br>let y = MyRegex(regexString: “a* b a* b (a+b)*&quot;)<br></p><p>y == x // false<br>y.acceptsSameLanguage(as: x) // true<br></p><p>Obviously there are downsides. People might not expect capacity to be compared. It might cause people to go off and create isEqual functions for everything, if the model of public API == saliency is a poor one. Maybe the solution is to mark things as salient or not salient explicitly.<br></p><p><br></p><p>I will admit that these are orthogonal issues.<br></p><p>Right now public API can be salient and have or be derived from something that has reference semantics. Such types are not PureValues. So I think you are right, I was crazy, so I’ll amend my statement to say Array&lt;Int&gt; would be a PureValue regardless of whether capacity is salient. <br></p><p>Public API can also be not salient and have value semantics. Such types define an == operator that does not compare all values in the type. Whether or not this is a good or bad thing is independent of PureValues.<br></p><p><br>&gt;&gt;&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt;&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt;&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt;&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt;&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt;&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt;&gt;&gt; reference types properly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt;&gt;&gt; interested in this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt;&gt;&gt; semantics at a deep level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt;&gt;&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt;&gt;&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt;&gt;&gt; written by using a Value constraint.<br>&gt;&gt; <br>&gt;&gt; Let me get back to you here. I need to do more investigation!<br>&gt;&gt; <br>&gt;&gt; Gotta watch that second video.<br>&gt; <br>&gt; Enjoy!<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 16, 2016, at 8:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                  On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                      2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;                      contains a<br>&gt;&gt;                      reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt;                  Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;                  Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;                  *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;                  it indicates that you need to keep working on your definition.<br>&gt;&gt; <br>&gt;&gt;                It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;                impossible to define PureValue. <br>&gt;&gt; <br>&gt;&gt;            Not on purpose.<br>&gt;&gt; <br>&gt;&gt;                Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;                semantics?<br>&gt;&gt; <br>&gt;&gt;            This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt;            In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;            boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;            a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;            == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt;            Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;            ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;            Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt;            only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;            presumably uses aspects of T other than reference identity.  <br>&gt;&gt; <br>&gt;&gt;                The claim has been made that Array always has value semantics,<br>&gt;&gt;                implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;                element values.<br>&gt;&gt; <br>&gt;&gt;            Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt; <br>&gt;&gt;                That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;                buffer.<br>&gt;&gt; <br>&gt;&gt;            I don&#39;t know what you mean here.<br>&gt;&gt; <br>&gt;&gt;                It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;                PureValue is nothing more than transitive value semantics.<br>&gt;&gt; <br>&gt;&gt;            You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;            the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;            of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;            procedure for determining whether a type is a PureValue.<br>&gt;&gt; <br>&gt;&gt;        We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt;    That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;    features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;        We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;        use things like CoW, shared immutable references, etc in our<br>&gt;&gt;        implementation.<br>&gt;&gt; <br>&gt;&gt;    IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;    you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;        Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt;    Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;    some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;    semantics and he has a really detailed explanation in<br>&gt;&gt;    https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;    https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;    but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;    as well to Swift.<br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt; ethereal types?<br>&gt; <br>&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt; type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt; capacity.<br>&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt; equality of std::vector.<br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt; documentation.<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt; a public property, the capacity, is part of the ethereal type.<br>&gt; <br>&gt; No, you just need documentation.<br>&gt; <br>&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt; documentation or the implementation.<br>&gt; <br>&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt; expect to fully understand semantics without documentation.<br>&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt; this is a useful distinction amongst value types.<br>&gt; <br>&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt; semantics.<br>&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt; reference types properly.<br>&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt; interested in this problem.<br>&gt; <br>&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt; semantics at a deep level.<br>&gt; <br>&gt; All that said, I still think PureValue is a red herring.  <br></p><p>AMEN.... <br></p><p><br>&gt; Unless I&#39;m<br>&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt; written by using a Value constraint.<br>&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;        It may be helpful<br>&gt;&gt;        if we start there and refine your definition to exclude impure value<br>&gt;&gt;        types like Array&lt;UIView&gt;.<br>&gt;&gt; <br>&gt;&gt;        In the meantime I’ll take another shot:<br>&gt;&gt; <br>&gt;&gt;        1. Scalars are pure values.<br>&gt;&gt; <br>&gt;&gt;        2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;          observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    -Dave<br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 1:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                  On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                      2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;                      contains a<br>&gt;&gt;                      reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt;                  Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;                  Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;                  *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;                  it indicates that you need to keep working on your definition.<br>&gt;&gt; <br>&gt;&gt;                It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;                impossible to define PureValue. <br>&gt;&gt; <br>&gt;&gt;            Not on purpose.<br>&gt;&gt; <br>&gt;&gt;                Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;                semantics?<br>&gt;&gt; <br>&gt;&gt;            This is a great question; I had to rewrite my response four times.<br>&gt;&gt; <br>&gt;&gt;            In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;            boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;            a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;            == is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt;            Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;            ValueSemantics, then<br>&gt;&gt; <br>&gt;&gt;            Array&lt;T: SomeConstraint&gt;<br>&gt;&gt; <br>&gt;&gt;            only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;            presumably uses aspects of T other than reference identity.  <br>&gt;&gt; <br>&gt;&gt;                The claim has been made that Array always has value semantics,<br>&gt;&gt;                implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;                element values.<br>&gt;&gt; <br>&gt;&gt;            Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt; <br>&gt;&gt;                That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;                buffer.<br>&gt;&gt; <br>&gt;&gt;            I don&#39;t know what you mean here.<br>&gt;&gt; <br>&gt;&gt;                It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;                PureValue is nothing more than transitive value semantics.<br>&gt;&gt; <br>&gt;&gt;            You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;            the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;            of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;            procedure for determining whether a type is a PureValue.<br>&gt;&gt; <br>&gt;&gt;        We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt;    That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;    features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;        We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;        use things like CoW, shared immutable references, etc in our<br>&gt;&gt;        implementation.<br>&gt;&gt; <br>&gt;&gt;    IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;    you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;        Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt;    Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;    some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;    semantics and he has a really detailed explanation in<br>&gt;&gt;    https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;    https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;    but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;    as well to Swift.<br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt; ethereal types?<br>&gt; <br>&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt; type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt; capacity.<br>&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt; equality of std::vector.<br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt; documentation.<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt; <br>&gt; No, you just need documentation.<br>&gt; <br>&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt; documentation or the implementation.<br>&gt; <br>&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt; expect to fully understand semantics without documentation.<br>&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt; this is a useful distinction amongst value types.<br>&gt; <br>&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt; semantics.<br>&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt; reference types properly.<br>&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt; interested in this problem.<br>&gt; <br>&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt; semantics at a deep level.<br>&gt; <br>&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt; written by using a Value constraint.<br></p><p>Looking forward to hearing your thoughts on the code I just posted.<br></p><p>In addition to that, I think it is also important to note that contained within the notion of PureValue is thread safety.  For example, in CSP PureValues would can be sent as messages on a channel.  Clearly sending Array&lt;MutableReferenceType&gt; over a channel is something you would not do in CSP.  You can also freely share a ImmutableBox&lt;MyPureValue&gt; and read from it in any thread you wish without any trouble.  You cannot do that with ImmutableBox&lt;Array&lt;MutableReferenceType&gt;&gt;.  In the latter, you cannot mutate the array, but you can still mutate the objects it contains references to.<br></p><p>&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;        It may be helpful<br>&gt;&gt;        if we start there and refine your definition to exclude impure value<br>&gt;&gt;        types like Array&lt;UIView&gt;.<br>&gt;&gt; <br>&gt;&gt;        In the meantime I’ll take another shot:<br>&gt;&gt; <br>&gt;&gt;        1. Scalars are pure values.<br>&gt;&gt; <br>&gt;&gt;        2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;          observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    -Dave<br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/69a19259/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 16, 2016, at 8:17 AM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt; features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt; implementation.<br>&gt;&gt; <br>&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt; as well to Swift.<br>&gt; <br>&gt; Super interesting talk! <br>&gt; <br>&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt; <br>&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt; <br>&gt; 1. the size is<br>&gt; 2. the values in the vector are<br>&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br></p><p>Yes, it is possible to look at every situation as a pure cross-product of ever single possibility, however that is of ten a source of waste as some are all clearly associated with a likelyhood of occurance. IMO does does not matter that *someone* might (and certainly will) when we can all agree that most would not. <br></p><p>{bracket}I have watched some of the past discussion in the archive and noticed a number of situations when good proposals get derailed in the name of how difficult the syntax would become for the poor beginner who would start typing swift code before reading the manual. My depiction is a bit itself of an exageration, but if we all thing about it, I am sure we can name one such proposal. Programming is not a magical activity that one should be able to perform without any learning curve, in the name of a universal intuition guiding us all in the right direction. I would even wager that the more languages one learns, the easier it becomes to make wrong assumptions based on how familiar certain patterns or notions seem{/bracket}<br></p><p><br>&gt; <br>&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt; <br>&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt; <br>&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br>&gt; <br>&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br>&gt; <br>&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt; <br>&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/e8773b55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 16, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 12:46 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On May 16, 2016, at 8:17 AM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com &lt;http://atrick-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt; features that are considered by equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt;&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt; as well to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br>&gt; <br>&gt; Yes, it is possible to look at every situation as a pure cross-product of ever single possibility, however that is of ten a source of waste as some are all clearly associated with a likelyhood of occurance. IMO does does not matter that *someone* might (and certainly will) when we can all agree that most would not. <br>&gt; <br>&gt; {bracket}I have watched some of the past discussion in the archive and noticed a number of situations when good proposals get derailed in the name of how difficult the syntax would become for the poor beginner who would start typing swift code before reading the manual. My depiction is a bit itself of an exageration, but if we all thing about it, I am sure we can name one such proposal. Programming is not a magical activity that one should be able to perform without any learning curve, in the name of a universal intuition guiding us all in the right direction. I would even wager that the more languages one learns, the easier it becomes to make wrong assumptions based on how familiar certain patterns or notions seem{/bracket}<br>&gt; <br></p><p>The road to C++ is paved with gnarly syntax, implicit behavior, and the blood of poor beginners. :p I kid. <br></p><p>In this case most people would assume that capacity is not part of equality (probably?). This by no means implies that it will always be so clear.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt;&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt;&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br>&gt;&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt;&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/b191bbae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>FWIW, totally agree with this opinion. I also don&#39;t understand why &quot;poor <br>beginner who would start typing swift code before reading the manual&quot; <br>becomes so important when we decide to accept or not some new feature or <br>change. Are we working on language that must be used just to teach <br>children/beginners for programming or the main purpose of Swift is <br>developing of real(often complex) software products?<br></p><p>Please don&#39;t tell me that Swift *can* be used to teach children/beginners, <br>I know this, and I believe this is good, and only very basic <br>syntax/features will be used for this.<br></p><p>On 16.05.2016 10:46, L. Mihalkovic via swift-evolution wrote:<br>&gt; {bracket}I have watched some of the past discussion in the archive and<br>&gt; noticed a number of situations when good proposals get derailed in the name<br>&gt; of how difficult the syntax would become for the poor beginner who would<br>&gt; start typing swift code before reading the manual. My depiction is a bit<br>&gt; itself of an exageration, but if we all thing about it, I am sure we can<br>&gt; name one such proposal. Programming is not a magical activity that one<br>&gt; should be able to perform without any learning curve, in the name of a<br>&gt; universal intuition guiding us all in the right direction. I would even<br>&gt; wager that the more languages one learns, the easier it becomes to make<br>&gt; wrong assumptions based on how familiar certain patterns or notions<br>&gt; seem{/bracket}<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 1:17 AM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com &lt;http://atrick-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt; <br>&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt; features that are considered by equality.<br>&gt;&gt; <br>&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt; implementation.<br>&gt;&gt; <br>&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt; <br>&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt; <br>&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt; as well to Swift.<br>&gt;&gt; <br>&gt; <br>&gt; Super interesting talk! <br>&gt; <br>&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt; <br>&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt; <br>&gt; 1. the size is<br>&gt; 2. the values in the vector are<br>&gt; 3. the capacity, however *is not*<br>&gt; <br>&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br>&gt; <br>&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt; <br>&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt; <br>&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br>&gt; <br>&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br></p><p>I don&#39;t agree with this.  I consider Array&lt;Int&gt; to be a pure value.  If it exposes a capacity property that fact is incidental to its value.  I agree with John here.<br></p><p>&gt; <br>&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt; <br>&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt; <br>&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/f54bcbc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 9:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 16, 2016, at 1:17 AM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We look at the observable parts.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt; features that are considered by equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt; you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you share your definition of value semantics?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt; some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt; semantics and he has a really detailed explanation in<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt; as well to Swift.<br>&gt;&gt; <br>&gt;&gt; Super interesting talk! <br>&gt;&gt; <br>&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple* ethereal types?<br>&gt;&gt; <br>&gt;&gt; std::vector is a good example. What are the salient attributes of this type? In the talk John says that<br>&gt;&gt; <br>&gt;&gt; 1. the size is<br>&gt;&gt; 2. the values in the vector are<br>&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt; <br>&gt;&gt; in which case std::vector would be an approximation of an ethereal type which has a list of values, and the capacity is just an artifact of the approximation. But you could also imagine an ethereal type which *does* depend of the capacity of the object, and std::vector unwittingly approximates that type too! In this case someone, unfamiliar with the implementation might use it under the assumption that capacity *is* part of the ethereal type and by extension the equality of std::vector. <br>&gt;&gt; <br>&gt;&gt; John avoids the problem by saying that this must specified in the documentation.<br>&gt;&gt; <br>&gt;&gt; I tend to see this as breaking encapsulation since you need to know the implementation of the equality operator to be able to determine if a public property, the capacity, is part of the ethereal type. It’s not always the case that you have access to either the documentation or the implementation.<br>&gt;&gt; <br>&gt;&gt; This implies, therefore, that if salient attributes *define* the immutability of the value type, then the public interface is not guaranteed to be immutable, since it is allowed to include non-salient attributes. For example, a vector’s capacity could change at any time, by virtue of it being stored via a reference.<br>&gt;&gt; <br>&gt;&gt; What I am saying is that a PureValue is a value type whose public interface comprises *only* salient attributes. And I also claim that this is a useful distinction amongst value types. <br>&gt; <br>&gt; I don&#39;t agree with this.  I consider Array&lt;Int&gt; to be a pure value.  If it exposes a capacity property that fact is incidental to its value.  I agree with John here.<br></p><p>Yes, I revised my statement in a later email. I agree with you here.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; John also says that a salient attribute must derive *only* from the state of a particular instance of a type. This by extension implies that a salient attribute must derive exclusively from pure values. However, this also means that without some “indirect” keyword, PureValues are restricted to acyclic and non-recursive structures. <br>&gt;&gt; <br>&gt;&gt; I also claim that equality can be automatically generated for PureValues by equating each of there salient attributes.<br>&gt;&gt; <br>&gt;&gt; I really apologize if this seems like rambling again, but I am very interested in this problem.<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It may be helpful<br>&gt;&gt;&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/8b119050/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 1:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;       contains a<br>&gt;&gt;&gt;&gt;       reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;   Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;   *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;   it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt; impossible to define PureValue. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not on purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt; semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt; boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt; a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt; == is equivalent to ===.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt; ValueSemantics, then<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt; presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt; implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt; element values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt; PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt; the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt; of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt; procedure for determining whether a type is a PureValue.<br>&gt;&gt; <br>&gt;&gt; We look at the observable parts.  <br>&gt; <br>&gt; That begs the question.  The “parts” of an Array are the observable<br>&gt; features that are considered by equality.<br>&gt; <br>&gt;&gt; We do not look at unobservable parts because we want flexibility to<br>&gt;&gt; use things like CoW, shared immutable references, etc in our<br>&gt;&gt; implementation.<br>&gt; <br>&gt; IMO the important thing when it comes to functional purity is not what<br>&gt; you *can* observe, but what you *do* observe.<br>&gt; <br>&gt;&gt; Can you share your definition of value semantics?  <br>&gt; Explaining it well and in sufficient detail for this discussion takes<br>&gt; some doing<br></p><p>I asked for your definition of value semantics because you keep asking for a concise definition of PureValue.  I was trying to identify how to structure a definition in a way that would be acceptable to you.   <br></p><p>&gt; , but I think John Lakos and I share an understanding of value<br>&gt; semantics and he has a really detailed explanation in<br>&gt; https://www.youtube.com/watch?v=W3xI1HJUy7Q &lt;https://www.youtube.com/watch?v=W3xI1HJUy7Q&gt; and<br>&gt; https://www.youtube.com/watch?v=0EvSxHxFknM &lt;https://www.youtube.com/watch?v=0EvSxHxFknM&gt;.  He uses C++ in places,<br>&gt; but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt; as well to Swift.<br></p><p>Thanks, good talks.  I believe I have seen earlier versions of them previously.<br></p><p>I’m still unsure of what structure would be acceptable to you as John doesn’t give a concise “here it is on one slide” definition of the kind you seem to be looking for with regards to pure value.  If anything, the talks demonstrate how nuanced this discussion is.<br></p><p>That said, I’ll take a shot at defining pure value using John’s terminology.  John talks about salient attributes quite a bit.  These are the “observable parts” I have been talking about.  <br></p><p>John also makes a very strong and clear distinction between “value semantics” and “in-core value semantics”.  This distinction is fundamental to the distinction I am making.  Your definition of “value semantics” appears to include both what John calls “value semantics” as well as what John calls “in-core value semantics”.  As far as I can tell my definition of “pure value” aligns with what John simply calls “value semantics” (or in some cases he says “full value semantics”) which *excludes* what he calls “in-core value semantics” (including pointers).  Quoting John:<br></p><p>“What kind of objects do not try to represent a value?  … Pointers actually represent something in the middle.  They don’t represent an ethereal type because pointers are addresses in a local machine.  That’s not a global property.  On the other hand they bear some resemblance so we call them in-core value types but they are not the same.&quot;<br></p><p>John uses “ethereal” interchangeably with platonic in his talk.  In his mind value semantic types are implementations that approximate platonic (or mathematical) values.  In other words, the interpretation / meaning of the value is eternal and is not tied to the current state of memory in the process that is executing.<br></p><p>The fundamental distinction between value semantics and pure value hinges on what salient attributes are allowable.   Pure values cannot have any salient attributes with what John is calling “in-core value semantics”.  All of the salient attributes of a pure value have what John is simply calling &quot;value semantics”, or in other words are themselves pure values.<br></p><p>John doesn’t specifically discuss the semantics of something like vector&lt;shared_ptr&lt;T&gt;&gt; but I believe he would agree that it has different semantics than vector&lt;int&gt; in a fundamental and important way.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt;&gt; It may be helpful<br>&gt;&gt; if we start there and refine your definition to exclude impure value<br>&gt;&gt; types like Array&lt;UIView&gt;.<br>&gt;&gt; <br>&gt;&gt; In the meantime I’ll take another shot:<br>&gt;&gt; <br>&gt;&gt; 1. Scalars are pure values.<br>&gt;&gt; <br>&gt;&gt; 2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;   observable parts of the aggregate are pure values.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/35d0cf72/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 4:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve been thinking about this further and can now state my position more clearly<br>&gt;&gt; and concisely.<br>&gt;&gt; <br>&gt;&gt; 1. If we&#39;re going to have reference types with value semantics the boundary of<br>&gt;&gt; the value must extend through the reference to the value of the object. Two<br>&gt;&gt; instances may have the same logical value so reference equality is not good<br>&gt;&gt; enough.<br>&gt; <br>&gt; My (radical) position has been that we should decree that if you really<br>&gt; want this thing to have value semantics, it should be a struct.  That<br>&gt; is, wrap your reference type in a struct and provide an == that looks at<br>&gt; what&#39;s in the instance.  This radically simplifies the model because we<br>&gt; can then assume that value types have value semantics and reference<br>&gt; types only have value semantics if you view their identitity as their<br>&gt; value.<br></p><p>I agree with this longer term, but it is too soon for that.  <br></p><p>Rather than suggest wrapping the reference in a struct I would suggest that most of the time just making it a struct in the first place is the right path.  The problem with this is that it can lead to excessive copying, reference counting, etc if you’re not careful.  I argue that mainstream developers should not need to bother with writing a reference type and wrapping it in a struct just to get around this.  It would be nice if there were better, less boilerplate-y solutions to this in the future.  <br></p><p>&gt; <br>&gt;&gt; 2. Value types are not &quot;pure&quot; values if any part of the aggregate contains a<br>&gt;&gt; reference whose type does not have value semantics. <br>&gt; <br>&gt; Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt; Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt; *not* have value semantics).  I don&#39;t think this is what you intend, and<br>&gt; it indicates that you need to keep working on your definition.<br></p><p>I have elaborated elsewhere as to why Array&lt;Int&gt; does meet my notion of “pure” value.  I understand that it contains a buffer pointer, etc that does not have value semantics.  But that is an implementation detail and is not externally observable.  I believe that implementation strategies like this are extremely important.  I am only concerned with the externally observable semantics and behavior of the type, not the implementation.  <br></p><p>Just as the internal mutable reference type does not disqualify Array&lt;Int&gt; from having value semantics, it also does not disqualify it from being a “pure value&quot;.<br></p><p>&gt; <br>&gt;&gt; Purity must include the entire aggregate. Array&lt;UIView&gt; has value<br>&gt;&gt; semantics but it is not a pure value.<br>&gt; <br>&gt; In what sense does it have value semantics?  Unless we can define<br>&gt; equality for Array&lt;UIView&gt; it&#39;s hard to make any claim about its value<br>&gt; semantics.<br></p><p>Well it should have value semantics using reference equality of the views because UIView has reference semantics so reference identity is the appropriate definition of equality.  Isn’t that your position as well? <br></p><p>&gt; <br>&gt;&gt; The primary reasons I can think of for creating reference types with value<br>&gt;&gt; semantics are avoiding copying everything all the time or using inheritance. (I<br>&gt;&gt; could also list pre-existing types here but am not as concerned with those)<br>&gt;&gt; <br>&gt;&gt; One could argue that you can avoid copying by writing a struct with a handle and<br>&gt;&gt; one can simulate inheritance by embedding and forwarding. The problem is that<br>&gt;&gt; this involves a lot of boilerplate and makes your code more complex. <br>&gt; <br>&gt; The “forwarding boilerplate problem” is something we need to solve in<br>&gt; the language regardless.  <br></p><p>Yes I agree that it needs to be solved regardless.  In fact, you might remember that I invested quite a bit of effort into drafting a proposal on the topic.  I shelved it mostly because I became very busy with client work, but also partly due to the lukewarm reaction.<br></p><p>&gt; The fact that we don&#39;t have an answer today<br>&gt; shouldn&#39;t prevent us from adopting the right model for values and<br>&gt; references.<br></p><p>I think that depends on what you mean by this.  If you mean providing a default equality of reference identity for reference types I disagree.  I think that should wait until the language reaches a place where there is no good reason to write value semantic reference types.  And I believe the boilerplate currently required to wrap them in a struct is sufficiently burdensome that this is not the case yet.<br></p><p><br>&gt; <br>&gt;&gt; For something like the standard library these concerns are far<br>&gt;&gt; outweighed by the benefit we all gain by having our collections be<br>&gt;&gt; value types. However, in application code the benefit may not be worth<br>&gt;&gt; the cost thus it may be reasonable to prefer immutable objects.<br>&gt;&gt; <br>&gt;&gt; I think there is a viable path for enhancing the language such that there is<br>&gt;&gt; little or not reason to implement a value semantic type as a reference type. If<br>&gt;&gt; we were able to declare value types as &quot;indirect&quot; and / or have a compiler<br>&gt;&gt; supported Box (probably with syntactic sugar) that automatically forwarded<br>&gt;&gt; calls, performed CoW, etc this would allow us much more control over copying<br>&gt;&gt; without requiring boilerplate. We could also add something along the lines of<br>&gt;&gt; Go&#39;s embedding (or a more general forwarding mechanism which is my preference)<br>&gt;&gt; which would likely address many of the reasons for using inheritance in a value<br>&gt;&gt; semantic reference type.<br>&gt;&gt; <br>&gt;&gt; If we do go down that path I think the case that value semantic types should be<br>&gt;&gt; implemented as value types, thus reference equality should be the default<br>&gt;&gt; equality for reference types gets much stronger. In that hypothetical future<br>&gt;&gt; Swift we might even be able to go so far as saying that reference types with<br>&gt;&gt; value semantics are an anti-pattern and &quot;outlaw&quot; them. This would allow us to<br>&gt;&gt; simply say &quot;reference types have reference semantics&quot;. <br>&gt;&gt; <br>&gt;&gt; We might also be able to get to a place where we can &quot;outlaw&quot; value types that<br>&gt;&gt; do not have value semantics. I haven&#39;t thought deeply about that so I&#39;m not<br>&gt;&gt; certain of the implications, particularly with regards to C interop. IIRC Dave A<br>&gt;&gt; indicated he would like to see this happen. If this is possible, we may<br>&gt;&gt; eventually have a language where &quot;value types have value semantics&quot;, &quot;some value<br>&gt;&gt; types are pure values&quot;, and &quot;reference types have reference semantics and are<br>&gt;&gt; never pure values&quot;. If it is achievable it would be a significant step forward<br>&gt;&gt; in simplicity and clarity. <br>&gt; <br>&gt; So far, I still don&#39;t believe that introducing a “pure values” distinction is<br>&gt; adding simplicity and clarity.  To me it looks like a needless wrinkle.<br></p><p>Fair enough.  I suspect that many folks who have been strongly influenced by functional programming may have a different opinion (btw, I don’t mean to imply anything about the degree to which functional programming has or has not influenced your opinion).<br></p><p>&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 7, 2016, at 11:17 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;    On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;            &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                        I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;                property. However, it I (and many others) do believe it is an<br>&gt;&gt;                extremely valuable<br>&gt;&gt;                property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;            I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;            algorithms could you write that work on models of PureValue but<br>&gt;&gt;            don&#39;t<br>&gt;&gt;            work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt;        class Storage {<br>&gt;&gt;        var element: Int = 0<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        struct Value {<br>&gt;&gt;        var storage: Storage<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        func amIPure(v: Value) -&gt; Int {<br>&gt;&gt;        v.storage.element = 3<br>&gt;&gt;        return v.storage.element<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The<br>&gt;&gt;        developer needs to tell me where the boundaries of the value lie. Does<br>&gt;&gt;        &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value<br>&gt;&gt;        is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the<br>&gt;&gt;        developer will need to implement CoW, or we need add some language<br>&gt;&gt;        features.<br>&gt;&gt; <br>&gt;&gt;    Thank you for this clear exposition of how PureValue relates to pure<br>&gt;&gt;    functions. This is the exact intuition I have about it but you have stated<br>&gt;&gt;    it much more clearly.<br>&gt;&gt; <br>&gt;&gt;    Language features to help automate CoW would be great. It would eliminate<br>&gt;&gt;    boilerplate, but more importantly it would likely provide more information<br>&gt;&gt;    to the compiler.<br>&gt;&gt; <br>&gt;&gt;        If I know about every operation inside &#39;amIPure&#39;, and know where the<br>&gt;&gt;        value&#39;s boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a<br>&gt;&gt;        &#39;PureValue&#39;. For example, I know that this function is pure without<br>&gt;&gt;        caring about &#39;PureValue&#39;.<br>&gt;&gt; <br>&gt;&gt;        func IAmPure(v: Value, s: Storage) -&gt; Int {<br>&gt;&gt;        var t = v<br>&gt;&gt;        t.storage = s<br>&gt;&gt;        return t.storage.element<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        However, I might only have summary information. I might know that the<br>&gt;&gt;        function only writes to memory reachable from Value. In that case, it<br>&gt;&gt;        would be nice to have summary information about the storage type.<br>&gt;&gt;        &#39;PureValue&#39; is another way of saying that it does not contain references<br>&gt;&gt;        to objects outside the value&#39;s boundary (I would add that it cannot have<br>&gt;&gt;        a user-defined deinit). The only thing vague about that is that we don&#39;t<br>&gt;&gt;        have a general way for the developer to define the value&#39;s boundary. It<br>&gt;&gt;        certainly should be consistent with &#39;==&#39;, but implementing &#39;==&#39; doesn&#39;t<br>&gt;&gt;        tell the optimizer anything.<br>&gt;&gt; <br>&gt;&gt;    I think the ability to define the value&#39;s boundary would be wonderful. If we<br>&gt;&gt;    added a way to do this it would be a requirement of PureValue.<br>&gt;&gt; <br>&gt;&gt;        Anyway, these are only optimizer concerns, and programming model should<br>&gt;&gt;        take precedence in these discussion. But I thought that might help.<br>&gt;&gt; <br>&gt;&gt;        -Andy<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/07aac27e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     On May 7, 2016, at 4:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;     on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         I&#39;ve been thinking about this further and can now state my position more<br>&gt;         clearly<br>&gt;         and concisely.<br>&gt;<br>&gt;         1. If we&#39;re going to have reference types with value semantics the<br>&gt;         boundary of<br>&gt;         the value must extend through the reference to the value of the object.<br>&gt;         Two<br>&gt;         instances may have the same logical value so reference equality is not<br>&gt;         good<br>&gt;         enough.<br>&gt;<br>&gt;     My (radical) position has been that we should decree that if you really<br>&gt;     want this thing to have value semantics, it should be a struct. That<br>&gt;     is, wrap your reference type in a struct and provide an == that looks at<br>&gt;     what&#39;s in the instance. This radically simplifies the model because we<br>&gt;     can then assume that value types have value semantics and reference<br>&gt;     types only have value semantics if you view their identitity as their<br>&gt;     value.<br>&gt;<br>&gt; I agree with this longer term, but it is too soon for that. <br></p><p>We don&#39;t have much longer to establish the programming model.  It needs<br>to happen soon or it will be too late.<br></p><p>&gt; Rather than suggest wrapping the reference in a struct I would suggest that most<br>&gt; of the time just making it a struct in the first place is the right<br>&gt; path. <br></p><p>Well of course.  But if you already have a reference type and aren&#39;t<br>ready to rewrite it, this is how you do it.<br></p><p>&gt; The problem with this is that it can lead to excessive copying,<br>&gt; reference counting, etc if you’re not careful. I argue that mainstream<br>&gt; developers should not need to bother with writing a reference type and<br>&gt; wrapping it in a struct just to get around this. <br></p><p>Sure, maybe our codegen could be smarter about this, but that shouldn&#39;t<br>hold back the programming model.<br></p><p>&gt; It would be nice if there were better, less boilerplate-y solutions to<br>&gt; this in the future.<br>&gt;<br>&gt;         2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;         contains a<br>&gt;         reference whose type does not have value semantics. <br>&gt;<br>&gt;     Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;     Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;     *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;     it indicates that you need to keep working on your definition.<br>&gt;<br>&gt; I have elaborated elsewhere as to why Array&lt;Int&gt; does meet my notion of “pure”<br>&gt; value. I understand that it contains a buffer pointer, etc that does not have<br>&gt; value semantics. But that is an implementation detail and is not externally<br>&gt; observable. I believe that implementation strategies like this are extremely<br>&gt; important. I am only concerned with the externally observable semantics and<br>&gt; behavior of the type, not the implementation. <br>&gt;<br>&gt; Just as the internal mutable reference type does not disqualify Array&lt;Int&gt; from<br>&gt; having value semantics, it also does not disqualify it from being a “pure<br>&gt; value&quot;.<br></p><p>As I&#39;ve indicated, then, you need a different definition than the one<br>above.  And you have to get the definition all together in one place so<br>it can be evaluated.<br></p><p>&gt;         Purity must include the entire aggregate. Array&lt;UIView&gt; has value<br>&gt;         semantics but it is not a pure value.<br>&gt;<br>&gt;     In what sense does it have value semantics? Unless we can define<br>&gt;     equality for Array&lt;UIView&gt; it&#39;s hard to make any claim about its value<br>&gt;     semantics.<br>&gt;<br>&gt; Well it should have value semantics using reference equality of the views<br>&gt; because UIView has reference semantics so reference identity is the appropriate<br>&gt; definition of equality. Isn’t that your position as well? <br></p><p>Yes.  <br></p><p>&gt;         The primary reasons I can think of for creating reference types with<br>&gt;         value<br>&gt;         semantics are avoiding copying everything all the time or using<br>&gt;         inheritance. (I<br>&gt;         could also list pre-existing types here but am not as concerned with<br>&gt;         those)<br>&gt;<br>&gt;         One could argue that you can avoid copying by writing a struct with a<br>&gt;         handle and<br>&gt;         one can simulate inheritance by embedding and forwarding. The problem is<br>&gt;         that<br>&gt;         this involves a lot of boilerplate and makes your code more complex. <br>&gt;<br>&gt;     The “forwarding boilerplate problem” is something we need to solve in<br>&gt;     the language regardless. <br>&gt;<br>&gt; Yes I agree that it needs to be solved regardless. In fact, you might remember<br>&gt; that I invested quite a bit of effort into drafting a proposal on the topic. I<br>&gt; shelved it mostly because I became very busy with client work, but also partly<br>&gt; due to the lukewarm reaction.<br>&gt;<br>&gt;     The fact that we don&#39;t have an answer today<br>&gt;     shouldn&#39;t prevent us from adopting the right model for values and<br>&gt;     references.<br>&gt;<br>&gt; I think that depends on what you mean by this. If you mean providing a default<br>&gt; equality of reference identity for reference types I disagree. I think that<br>&gt; should wait until the language reaches a place where there is no good reason to<br>&gt; write value semantic reference types. And I believe the boilerplate currently<br>&gt; required to wrap them in a struct is sufficiently burdensome that this is not<br>&gt; the case yet.<br></p><p>As I&#39;ve said, we can&#39;t wait.  We should make the change and use that to<br>drive development of the necessary features to reduce the burden of<br>writing optimized code.  <br></p><p>Remember that the only value semantic reference types are immutable, so<br>the struct rendition of such types has only immutable properties.<br>Personally, I don&#39;t think that transforming<br></p><p>        struct X {<br>          ...<br>        private:<br>          let prop1: Type1<br>          let prop2: Type2<br>          let prop2: Type3<br>        }<br></p><p>into<br></p><p>        struct X {<br>           ...<br>        private:<br>          class Storage {<br>            let prop1: Type1<br>            let prop2: Type2<br>            let prop2: Type3<br>          }<br>          let value: Storage<br>        }<br></p><p>is so awful if you find you need to optimize away some reference<br>counting manually; you just need to add “.value” to property accesses in<br>X&#39;s methods, and this doesn&#39;t require any forwarding.<br></p><p>&gt;<br>&gt;     So far, I still don&#39;t believe that introducing a “pure values”<br>&gt;     distinction is adding simplicity and clarity. To me it looks like<br>&gt;     a needless wrinkle.<br>&gt;<br>&gt; Fair enough. I suspect that many folks who have been strongly influenced by<br>&gt; functional programming may have a different opinion (btw, I don’t mean to imply<br>&gt; anything about the degree to which functional programming has or has not<br>&gt; influenced your opinion).<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt;        The primary reasons I can think of for creating reference types with<br>&gt;&gt;        value<br>&gt;&gt;        semantics are avoiding copying everything all the time or using<br>&gt;&gt;        inheritance. (I<br>&gt;&gt;        could also list pre-existing types here but am not as concerned with<br>&gt;&gt;        those)<br>&gt;&gt; <br>&gt;&gt;        One could argue that you can avoid copying by writing a struct with a<br>&gt;&gt;        handle and<br>&gt;&gt;        one can simulate inheritance by embedding and forwarding. The problem is<br>&gt;&gt;        that<br>&gt;&gt;        this involves a lot of boilerplate and makes your code more complex. <br>&gt;&gt; <br>&gt;&gt;    The “forwarding boilerplate problem” is something we need to solve in<br>&gt;&gt;    the language regardless. <br>&gt;&gt; <br>&gt;&gt; Yes I agree that it needs to be solved regardless. In fact, you might remember<br>&gt;&gt; that I invested quite a bit of effort into drafting a proposal on the topic. I<br>&gt;&gt; shelved it mostly because I became very busy with client work, but also partly<br>&gt;&gt; due to the lukewarm reaction.<br>&gt;&gt; <br>&gt;&gt;    The fact that we don&#39;t have an answer today<br>&gt;&gt;    shouldn&#39;t prevent us from adopting the right model for values and<br>&gt;&gt;    references.<br>&gt;&gt; <br>&gt;&gt; I think that depends on what you mean by this. If you mean providing a default<br>&gt;&gt; equality of reference identity for reference types I disagree. I think that<br>&gt;&gt; should wait until the language reaches a place where there is no good reason to<br>&gt;&gt; write value semantic reference types. And I believe the boilerplate currently<br>&gt;&gt; required to wrap them in a struct is sufficiently burdensome that this is not<br>&gt;&gt; the case yet.<br>&gt; <br>&gt; As I&#39;ve said, we can&#39;t wait.  We should make the change and use that to<br>&gt; drive development of the necessary features to reduce the burden of<br>&gt; writing optimized code.  <br>&gt; <br>&gt; Remember that the only value semantic reference types are immutable, so<br>&gt; the struct rendition of such types has only immutable properties.<br>&gt; Personally, I don&#39;t think that transforming<br>&gt; <br>&gt;        struct X {<br>&gt;          ...<br>&gt;        private:<br>&gt;          let prop1: Type1<br>&gt;          let prop2: Type2<br>&gt;          let prop2: Type3<br>&gt;        }<br>&gt; <br>&gt; into<br>&gt; <br>&gt;        struct X {<br>&gt;           ...<br>&gt;        private:<br>&gt;          class Storage {<br>&gt;            let prop1: Type1<br>&gt;            let prop2: Type2<br>&gt;            let prop2: Type3<br>&gt;          }<br>&gt;          let value: Storage<br>&gt;        }<br>&gt; <br>&gt; is so awful if you find you need to optimize away some reference<br>&gt; counting manually; you just need to add “.value” to property accesses in<br>&gt; X&#39;s methods, and this doesn&#39;t require any forwarding.<br>&gt; <br></p><p><br>FWIW +1. pandora’s box never fully seals back... so it is easier to force explicit extra syntax early and later decide that under some special conditions the requirements can be relaxed. Considering the timeline for 3.00 as well as its associated stake, the aforementioned syntax represents a coherent (if not yet fully minimizing of user’s efforts) programing model that could be lived with for the foreseeable future, all the while not closing the door on certain types of future simplification. <br></p><p>For example the following syntax is a straw man representation of what could be done at a future date to reduce the boilerplate:<br></p><p>       struct X {<br>         ...<br>       private:<br>         @strawman_syntax1 let prop1: Type1<br>         let prop2: @strawman_syntax2 Type2<br>         strawman_syntax3 let prop2: Type3<br>       }<br></p><p>To extend on ‘value semantic reference type’, esthetic considerations would push me towards a solution expressing it at the usage site (like in the straw man syntax above), rather than via the introduction of a new protocol to be used at the definition site. i.e. favoring &quot;my usage here of Type1 instances is to be construed as having value semantic” (with the compiler or me crafting a different definition of identity) over the less self documenting “Class Type1 is for all eternity carrying value semantic”, which ultimately seems more confusing to me. <br>I call it an esthetic argument as it is based on nothing else than a personal view on symmetry: (for no good reason) I value symmetry as the sign of a *good* design. Struct and Class are structural constructs to express a specific notion in the language. Out of my desire for symmetry I would expect that anything altering my perception of this notion would have to be equally conveyed within the structure of the language. Resorting to protocol compliance to do the same strikes me as the kind of deep imbalance I try to avoid.<br></p><p>/LM<br></p><p>&gt;&gt; <br>&gt;&gt;    So far, I still don&#39;t believe that introducing a “pure values”<br>&gt;&gt;    distinction is adding simplicity and clarity. To me it looks like<br>&gt;&gt;    a needless wrinkle.<br>&gt;&gt; <br>&gt;&gt; Fair enough. I suspect that many folks who have been strongly influenced by<br>&gt;&gt; functional programming may have a different opinion (btw, I don’t mean to imply<br>&gt;&gt; anything about the degree to which functional programming has or has not<br>&gt;&gt; influenced your opinion).<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/24c53e5d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 8, 2016, at 1:19 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 7, 2016, at 4:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        I&#39;ve been thinking about this further and can now state my position more<br>&gt;&gt;        clearly<br>&gt;&gt;        and concisely.<br>&gt;&gt; <br>&gt;&gt;        1. If we&#39;re going to have reference types with value semantics the<br>&gt;&gt;        boundary of<br>&gt;&gt;        the value must extend through the reference to the value of the object.<br>&gt;&gt;        Two<br>&gt;&gt;        instances may have the same logical value so reference equality is not<br>&gt;&gt;        good<br>&gt;&gt;        enough.<br>&gt;&gt; <br>&gt;&gt;    My (radical) position has been that we should decree that if you really<br>&gt;&gt;    want this thing to have value semantics, it should be a struct. That<br>&gt;&gt;    is, wrap your reference type in a struct and provide an == that looks at<br>&gt;&gt;    what&#39;s in the instance. This radically simplifies the model because we<br>&gt;&gt;    can then assume that value types have value semantics and reference<br>&gt;&gt;    types only have value semantics if you view their identitity as their<br>&gt;&gt;    value.<br>&gt;&gt; <br>&gt;&gt; I agree with this longer term, but it is too soon for that. <br>&gt; <br>&gt; We don&#39;t have much longer to establish the programming model.  It needs<br>&gt; to happen soon or it will be too late.<br>&gt; <br>&gt;&gt; Rather than suggest wrapping the reference in a struct I would suggest that most<br>&gt;&gt; of the time just making it a struct in the first place is the right<br>&gt;&gt; path. <br>&gt; <br>&gt; Well of course.  But if you already have a reference type and aren&#39;t<br>&gt; ready to rewrite it, this is how you do it.<br>&gt; <br>&gt;&gt; The problem with this is that it can lead to excessive copying,<br>&gt;&gt; reference counting, etc if you’re not careful. I argue that mainstream<br>&gt;&gt; developers should not need to bother with writing a reference type and<br>&gt;&gt; wrapping it in a struct just to get around this. <br>&gt; <br>&gt; Sure, maybe our codegen could be smarter about this, but that shouldn&#39;t<br>&gt; hold back the programming model.<br>&gt; <br>&gt;&gt; It would be nice if there were better, less boilerplate-y solutions to<br>&gt;&gt; this in the future.<br>&gt;&gt; <br>&gt;&gt;        2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;        contains a<br>&gt;&gt;        reference whose type does not have value semantics. <br>&gt;&gt; <br>&gt;&gt;    Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;    Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;    *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;    it indicates that you need to keep working on your definition.<br>&gt;&gt; <br>&gt;&gt; I have elaborated elsewhere as to why Array&lt;Int&gt; does meet my notion of “pure”<br>&gt;&gt; value. I understand that it contains a buffer pointer, etc that does not have<br>&gt;&gt; value semantics. But that is an implementation detail and is not externally<br>&gt;&gt; observable. I believe that implementation strategies like this are extremely<br>&gt;&gt; important. I am only concerned with the externally observable semantics and<br>&gt;&gt; behavior of the type, not the implementation. <br>&gt;&gt; <br>&gt;&gt; Just as the internal mutable reference type does not disqualify Array&lt;Int&gt; from<br>&gt;&gt; having value semantics, it also does not disqualify it from being a “pure<br>&gt;&gt; value&quot;.<br>&gt; <br>&gt; As I&#39;ve indicated, then, you need a different definition than the one<br>&gt; above.  And you have to get the definition all together in one place so<br>&gt; it can be evaluated.<br>&gt; <br>&gt;&gt;        Purity must include the entire aggregate. Array&lt;UIView&gt; has value<br>&gt;&gt;        semantics but it is not a pure value.<br>&gt;&gt; <br>&gt;&gt;    In what sense does it have value semantics? Unless we can define<br>&gt;&gt;    equality for Array&lt;UIView&gt; it&#39;s hard to make any claim about its value<br>&gt;&gt;    semantics.<br>&gt;&gt; <br>&gt;&gt; Well it should have value semantics using reference equality of the views<br>&gt;&gt; because UIView has reference semantics so reference identity is the appropriate<br>&gt;&gt; definition of equality. Isn’t that your position as well? <br>&gt; <br>&gt; Yes.  <br>&gt; <br>&gt;&gt;        The primary reasons I can think of for creating reference types with<br>&gt;&gt;        value<br>&gt;&gt;        semantics are avoiding copying everything all the time or using<br>&gt;&gt;        inheritance. (I<br>&gt;&gt;        could also list pre-existing types here but am not as concerned with<br>&gt;&gt;        those)<br>&gt;&gt; <br>&gt;&gt;        One could argue that you can avoid copying by writing a struct with a<br>&gt;&gt;        handle and<br>&gt;&gt;        one can simulate inheritance by embedding and forwarding. The problem is<br>&gt;&gt;        that<br>&gt;&gt;        this involves a lot of boilerplate and makes your code more complex. <br>&gt;&gt; <br>&gt;&gt;    The “forwarding boilerplate problem” is something we need to solve in<br>&gt;&gt;    the language regardless. <br>&gt;&gt; <br>&gt;&gt; Yes I agree that it needs to be solved regardless. In fact, you might remember<br>&gt;&gt; that I invested quite a bit of effort into drafting a proposal on the topic. I<br>&gt;&gt; shelved it mostly because I became very busy with client work, but also partly<br>&gt;&gt; due to the lukewarm reaction.<br>&gt;&gt; <br>&gt;&gt;    The fact that we don&#39;t have an answer today<br>&gt;&gt;    shouldn&#39;t prevent us from adopting the right model for values and<br>&gt;&gt;    references.<br>&gt;&gt; <br>&gt;&gt; I think that depends on what you mean by this. If you mean providing a default<br>&gt;&gt; equality of reference identity for reference types I disagree. I think that<br>&gt;&gt; should wait until the language reaches a place where there is no good reason to<br>&gt;&gt; write value semantic reference types. And I believe the boilerplate currently<br>&gt;&gt; required to wrap them in a struct is sufficiently burdensome that this is not<br>&gt;&gt; the case yet.<br>&gt; <br>&gt; As I&#39;ve said, we can&#39;t wait.  We should make the change and use that to<br>&gt; drive development of the necessary features to reduce the burden of<br>&gt; writing optimized code.  <br></p><p>I suppose that’s a fair position.<br></p><p>&gt; <br>&gt; Remember that the only value semantic reference types are immutable, so<br>&gt; the struct rendition of such types has only immutable properties.<br>&gt; Personally, I don&#39;t think that transforming<br>&gt; <br>&gt;        struct X {<br>&gt;          ...<br>&gt;        private:<br>&gt;          let prop1: Type1<br>&gt;          let prop2: Type2<br>&gt;          let prop2: Type3<br>&gt;        }<br>&gt; <br>&gt; into<br>&gt; <br>&gt;        struct X {<br>&gt;           ...<br>&gt;        private:<br>&gt;          class Storage {<br>&gt;            let prop1: Type1<br>&gt;            let prop2: Type2<br>&gt;            let prop2: Type3<br>&gt;          }<br>&gt;          let value: Storage<br>&gt;        }<br>&gt; <br>&gt; is so awful if you find you need to optimize away some reference<br>&gt; counting manually; you just need to add “.value” to property accesses in<br>&gt; X&#39;s methods, and this doesn&#39;t require any forwarding.<br></p><p>It’s not too awful but it does expose implementation details.  If we’re going to hide the implementation details maybe it’s worth taking advantage of the type by making the props var and using CoW.<br></p><p>What do you think about a proposal to enhance “indirect” for value types and / or instances of them.  I can think of a few approaches to this that we could consider.  I would be much more comfortable with what you want to do if we tackle that as well.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;    So far, I still don&#39;t believe that introducing a “pure values”<br>&gt;&gt;    distinction is adding simplicity and clarity. To me it looks like<br>&gt;&gt;    a needless wrinkle.<br>&gt;&gt; <br>&gt;&gt; Fair enough. I suspect that many folks who have been strongly influenced by<br>&gt;&gt; functional programming may have a different opinion (btw, I don’t mean to imply<br>&gt;&gt; anything about the degree to which functional programming has or has not<br>&gt;&gt; influenced your opinion).<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/ce8680bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     Remember that the only value semantic reference types are immutable, so<br>&gt;     the struct rendition of such types has only immutable properties.<br>&gt;     Personally, I don&#39;t think that transforming<br>&gt;<br>&gt;            struct X {<br>&gt;              ...<br>&gt;            private:<br>&gt;              let prop1: Type1<br>&gt;              let prop2: Type2<br>&gt;              let prop2: Type3<br>&gt;            }<br>&gt;<br>&gt;     into<br>&gt;<br>&gt;            struct X {<br>&gt;               ...<br>&gt;            private:<br>&gt;              class Storage {<br>&gt;                let prop1: Type1<br>&gt;                let prop2: Type2<br>&gt;                let prop2: Type3<br>&gt;              }<br>&gt;              let value: Storage<br>&gt;            }<br>&gt;<br>&gt;     is so awful if you find you need to optimize away some reference<br>&gt;     counting manually; you just need to add “.value” to property accesses in<br>&gt;     X&#39;s methods, and this doesn&#39;t require any forwarding.<br>&gt;<br>&gt; It’s not too awful but it does expose implementation details.  <br></p><p>How?  All the changes are under “private”<br></p><p>&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;<br>&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt; this that we could consider.  I would be much more comfortable with<br>&gt; what you want to do if we tackle that as well.<br></p><p>It&#39;s a good idea that can help to make CoW easy to implement; I have<br>advocated for it (not in public) in the past.  People should be aware<br>that the resulting automatic CoW will be suboptimal in many cases,<br>because when you discover you need new storage it&#39;s usually better to<br>build a new value than to copy the old one and overwrite it.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 13, 2016, at 9:19 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    Remember that the only value semantic reference types are immutable, so<br>&gt;&gt;    the struct rendition of such types has only immutable properties.<br>&gt;&gt;    Personally, I don&#39;t think that transforming<br>&gt;&gt; <br>&gt;&gt;           struct X {<br>&gt;&gt;             ...<br>&gt;&gt;           private:<br>&gt;&gt;             let prop1: Type1<br>&gt;&gt;             let prop2: Type2<br>&gt;&gt;             let prop2: Type3<br>&gt;&gt;           }<br>&gt;&gt; <br>&gt;&gt;    into<br>&gt;&gt; <br>&gt;&gt;           struct X {<br>&gt;&gt;              ...<br>&gt;&gt;           private:<br>&gt;&gt;             class Storage {<br>&gt;&gt;               let prop1: Type1<br>&gt;&gt;               let prop2: Type2<br>&gt;&gt;               let prop2: Type3<br>&gt;&gt;             }<br>&gt;&gt;             let value: Storage<br>&gt;&gt;           }<br>&gt;&gt; <br>&gt;&gt;    is so awful if you find you need to optimize away some reference<br>&gt;&gt;    counting manually; you just need to add “.value” to property accesses in<br>&gt;&gt;    X&#39;s methods, and this doesn&#39;t require any forwarding.<br>&gt;&gt; <br>&gt;&gt; It’s not too awful but it does expose implementation details.  <br>&gt; <br>&gt; How?  All the changes are under “private”<br></p><p>Sorry, I didn&#39;t notice private.  Probably because I am thinking of model types which expose their stored properties.<br></p><p>&gt;&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt;&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;&gt; <br>&gt;&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt;&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt;&gt; this that we could consider.  I would be much more comfortable with<br>&gt;&gt; what you want to do if we tackle that as well.<br>&gt; <br>&gt; It&#39;s a good idea that can help to make CoW easy to implement; I have<br>&gt; advocated for it (not in public) in the past.  <br></p><p>Glad to hear this.  Maybe in Swift 4?  (I know it&#39;s too early to say)<br></p><p>&gt; People should be aware<br>&gt; that the resulting automatic CoW will be suboptimal in many cases,<br>&gt; because when you discover you need new storage it&#39;s usually better to<br>&gt; build a new value than to copy the old one and overwrite it.<br></p><p>How big a difference does that usually make, especially when compared to the reasons you would use indirect in the first place?  Wouldn&#39;t the compiler be able to do this in the automatic implementation in some cases (such as writing to a stored var)?  Would it be possible to design indirect value types in a way that allows a transition to manual control of CoW without breaking calling code if that becomes necessary?<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On May 13, 2016, at 9:19 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Remember that the only value semantic reference types are immutable, so<br>&gt;&gt;&gt;    the struct rendition of such types has only immutable properties.<br>&gt;&gt;&gt;    Personally, I don&#39;t think that transforming<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;           struct X {<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;           private:<br>&gt;&gt;&gt;             let prop1: Type1<br>&gt;&gt;&gt;             let prop2: Type2<br>&gt;&gt;&gt;             let prop2: Type3<br>&gt;&gt;&gt;           }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    into<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;           struct X {<br>&gt;&gt;&gt;              ...<br>&gt;&gt;&gt;           private:<br>&gt;&gt;&gt;             class Storage {<br>&gt;&gt;&gt;               let prop1: Type1<br>&gt;&gt;&gt;               let prop2: Type2<br>&gt;&gt;&gt;               let prop2: Type3<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             let value: Storage<br>&gt;&gt;&gt;           }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    is so awful if you find you need to optimize away some reference<br>&gt;&gt;&gt;    counting manually; you just need to add “.value” to property accesses in<br>&gt;&gt;&gt;    X&#39;s methods, and this doesn&#39;t require any forwarding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not too awful but it does expose implementation details.  <br>&gt;&gt; <br>&gt;&gt; How?  All the changes are under “private”<br>&gt;<br>&gt; Sorry, I didn&#39;t notice private.  Probably because I am thinking of model types which expose their stored properties.<br>&gt;<br>&gt;&gt;&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt;&gt;&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt;&gt;&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt;&gt;&gt; this that we could consider.  I would be much more comfortable with<br>&gt;&gt;&gt; what you want to do if we tackle that as well.<br>&gt;&gt; <br>&gt;&gt; It&#39;s a good idea that can help to make CoW easy to implement; I have<br>&gt;&gt; advocated for it (not in public) in the past.  <br>&gt;<br>&gt; Glad to hear this.  Maybe in Swift 4?  (I know it&#39;s too early to say)<br>&gt;<br>&gt;&gt; People should be aware<br>&gt;&gt; that the resulting automatic CoW will be suboptimal in many cases,<br>&gt;&gt; because when you discover you need new storage it&#39;s usually better to<br>&gt;&gt; build a new value than to copy the old one and overwrite it.<br>&gt;<br>&gt; How big a difference does that usually make, especially when compared<br>&gt; to the reasons you would use indirect in the first place?  <br></p><p>Usually a big difference.<br></p><p>&gt; Wouldn&#39;t the compiler be able to do this in the automatic<br>&gt; implementation in some cases<br></p><p>Not in any interesting cases I know of.  If you&#39;re inserting into an<br>array and you discover you need new storage because there is more than<br>one reference, starting by copying can double the cost of the insertion<br>(on a large array when memory allocation is fast).<br></p><p>&gt; (such as writing to a stored var)?<br></p><p>I don&#39;t know what you mean here.<br></p><p>&gt; Would it be possible to design indirect value types in a way that<br>&gt; allows a transition to manual control of CoW without breaking calling<br>&gt; code if that becomes necessary?<br></p><p>Sure, anything is possible in design, and in a feature like this I would<br>of course want that capability.  It isn&#39;t the right time (for me) to try<br>to figure it all out though :-)<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 1:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 9:19 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Remember that the only value semantic reference types are immutable, so<br>&gt;&gt;&gt;&gt;   the struct rendition of such types has only immutable properties.<br>&gt;&gt;&gt;&gt;   Personally, I don&#39;t think that transforming<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;          struct X {<br>&gt;&gt;&gt;&gt;            ...<br>&gt;&gt;&gt;&gt;          private:<br>&gt;&gt;&gt;&gt;            let prop1: Type1<br>&gt;&gt;&gt;&gt;            let prop2: Type2<br>&gt;&gt;&gt;&gt;            let prop2: Type3<br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   into<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;          struct X {<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;          private:<br>&gt;&gt;&gt;&gt;            class Storage {<br>&gt;&gt;&gt;&gt;              let prop1: Type1<br>&gt;&gt;&gt;&gt;              let prop2: Type2<br>&gt;&gt;&gt;&gt;              let prop2: Type3<br>&gt;&gt;&gt;&gt;            }<br>&gt;&gt;&gt;&gt;            let value: Storage<br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   is so awful if you find you need to optimize away some reference<br>&gt;&gt;&gt;&gt;   counting manually; you just need to add “.value” to property accesses in<br>&gt;&gt;&gt;&gt;   X&#39;s methods, and this doesn&#39;t require any forwarding.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not too awful but it does expose implementation details.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How?  All the changes are under “private”<br>&gt;&gt; <br>&gt;&gt; Sorry, I didn&#39;t notice private.  Probably because I am thinking of model types which expose their stored properties.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt;&gt;&gt;&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt;&gt;&gt;&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt;&gt;&gt;&gt; this that we could consider.  I would be much more comfortable with<br>&gt;&gt;&gt;&gt; what you want to do if we tackle that as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s a good idea that can help to make CoW easy to implement; I have<br>&gt;&gt;&gt; advocated for it (not in public) in the past.  <br>&gt;&gt; <br>&gt;&gt; Glad to hear this.  Maybe in Swift 4?  (I know it&#39;s too early to say)<br>&gt;&gt; <br>&gt;&gt;&gt; People should be aware<br>&gt;&gt;&gt; that the resulting automatic CoW will be suboptimal in many cases,<br>&gt;&gt;&gt; because when you discover you need new storage it&#39;s usually better to<br>&gt;&gt;&gt; build a new value than to copy the old one and overwrite it.<br>&gt;&gt; <br>&gt;&gt; How big a difference does that usually make, especially when compared<br>&gt;&gt; to the reasons you would use indirect in the first place?  <br>&gt; <br>&gt; Usually a big difference.<br>&gt; <br>&gt;&gt; Wouldn&#39;t the compiler be able to do this in the automatic<br>&gt;&gt; implementation in some cases<br>&gt; <br>&gt; Not in any interesting cases I know of.  If you&#39;re inserting into an<br>&gt; array and you discover you need new storage because there is more than<br>&gt; one reference, starting by copying can double the cost of the insertion<br>&gt; (on a large array when memory allocation is fast).<br></p><p>Of course this is true of data structures.  I wouldn’t expect the compiler to provide a reasonable implementation of CoW for data structures.<br></p><p>Maybe I wasn’t clear.  I was talking about domain model objects like the following:<br></p><p>struct Person {<br>  var firstName: String<br>  var lastName: String<br>  // …<br>}<br></p><p>I find it hard to believe the compiler CoW implementation would do something so suboptimal as to be significant when you write to firstName through an indirect instance in cases like this (which are pervasive in application code).<br></p><p>&gt; <br>&gt;&gt; (such as writing to a stored var)?<br>&gt; <br>&gt; I don&#39;t know what you mean here.<br></p><p>Continuing with the previous example, if the CoW implementation is significantly better when using a memberwise initializer to construct the new box rather than copy the value over from the old box and then update the property that was written to it seems like the compiler should be able to make that optimization in some cases.  (i.e. when there exists a memberwise initializer which exposes all stored properties).<br></p><p>&gt; <br>&gt;&gt; Would it be possible to design indirect value types in a way that<br>&gt;&gt; allows a transition to manual control of CoW without breaking calling<br>&gt;&gt; code if that becomes necessary?<br>&gt; <br>&gt; Sure, anything is possible in design, and in a feature like this I would<br>&gt; of course want that capability.  It isn&#39;t the right time (for me) to try<br>&gt; to figure it all out though :-)<br></p><p>Cool.  Not trying to push for it now.  Hopefully it has a chance in Swift 4.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/41bcd53e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 16 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On May 15, 2016, at 1:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt;&gt;&gt;&gt;&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt;&gt;&gt;&gt;&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt;&gt;&gt;&gt;&gt; this that we could consider.  I would be much more comfortable with<br>&gt;&gt;&gt;&gt;&gt; what you want to do if we tackle that as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s a good idea that can help to make CoW easy to implement; I have<br>&gt;&gt;&gt;&gt; advocated for it (not in public) in the past.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Glad to hear this.  Maybe in Swift 4?  (I know it&#39;s too early to say)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; People should be aware<br>&gt;&gt;&gt;&gt; that the resulting automatic CoW will be suboptimal in many cases,<br>&gt;&gt;&gt;&gt; because when you discover you need new storage it&#39;s usually better to<br>&gt;&gt;&gt;&gt; build a new value than to copy the old one and overwrite it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How big a difference does that usually make, especially when compared<br>&gt;&gt;&gt; to the reasons you would use indirect in the first place?  <br>&gt;&gt; <br>&gt;&gt; Usually a big difference.<br>&gt;&gt; <br>&gt;&gt;&gt; Wouldn&#39;t the compiler be able to do this in the automatic<br>&gt;&gt;&gt; implementation in some cases<br>&gt;&gt; <br>&gt;&gt; Not in any interesting cases I know of.  If you&#39;re inserting into an<br>&gt;&gt; array and you discover you need new storage because there is more than<br>&gt;&gt; one reference, starting by copying can double the cost of the insertion<br>&gt;&gt; (on a large array when memory allocation is fast).<br>&gt;<br>&gt; Of course this is true of data structures.  I wouldn’t expect the<br>&gt; compiler to provide a reasonable implementation of CoW for data<br>&gt; structures.<br>&gt;<br>&gt; Maybe I wasn’t clear.  I was talking about domain model objects like the following:<br>&gt;<br>&gt; struct Person {<br>&gt;   var firstName: String<br>&gt;   var lastName: String<br>&gt;   // …<br>&gt; }<br>&gt;<br>&gt; I find it hard to believe the compiler CoW implementation would do<br>&gt; something so suboptimal as to be significant when you write to<br>&gt; firstName through an indirect instance in cases like this (which are<br>&gt; pervasive in application code).<br></p><p>Oh, OK.  And you want to CoW this because...?  Reducing refcount<br>traffic?<br></p><p>&gt;&gt;&gt; (such as writing to a stored var)?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean here.<br>&gt;<br>&gt; Continuing with the previous example, if the CoW implementation is<br>&gt; significantly better when using a memberwise initializer to construct<br>&gt; the new box rather than copy the value over from the old box and then<br>&gt; update the property that was written to it seems like the compiler<br>&gt; should be able to make that optimization in some cases.  (i.e. when<br>&gt; there exists a memberwise initializer which exposes all stored<br>&gt; properties).<br></p><p>Sure.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>hi there,<br></p><p>just skimmed through the bigger part of this thread — it&#39;s a really interesting discussion, but wouldn&#39;t it be worth a topic on its own?<br>The title of this message addresses a much simpler question (that imho still deserves some answers ;-)<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 16, 2016, at 10:14 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 16 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 15, 2016, at 1:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to hide the implementation details maybe it’s worth<br>&gt;&gt;&gt;&gt;&gt;&gt; taking advantage of the type by making the props var and using CoW.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What do you think about a proposal to enhance “indirect” for value<br>&gt;&gt;&gt;&gt;&gt;&gt; types and / or instances of them.  I can think of a few approaches to<br>&gt;&gt;&gt;&gt;&gt;&gt; this that we could consider.  I would be much more comfortable with<br>&gt;&gt;&gt;&gt;&gt;&gt; what you want to do if we tackle that as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s a good idea that can help to make CoW easy to implement; I have<br>&gt;&gt;&gt;&gt;&gt; advocated for it (not in public) in the past.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Glad to hear this.  Maybe in Swift 4?  (I know it&#39;s too early to say)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; People should be aware<br>&gt;&gt;&gt;&gt;&gt; that the resulting automatic CoW will be suboptimal in many cases,<br>&gt;&gt;&gt;&gt;&gt; because when you discover you need new storage it&#39;s usually better to<br>&gt;&gt;&gt;&gt;&gt; build a new value than to copy the old one and overwrite it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How big a difference does that usually make, especially when compared<br>&gt;&gt;&gt;&gt; to the reasons you would use indirect in the first place?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Usually a big difference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Wouldn&#39;t the compiler be able to do this in the automatic<br>&gt;&gt;&gt;&gt; implementation in some cases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not in any interesting cases I know of.  If you&#39;re inserting into an<br>&gt;&gt;&gt; array and you discover you need new storage because there is more than<br>&gt;&gt;&gt; one reference, starting by copying can double the cost of the insertion<br>&gt;&gt;&gt; (on a large array when memory allocation is fast).<br>&gt;&gt; <br>&gt;&gt; Of course this is true of data structures.  I wouldn’t expect the<br>&gt;&gt; compiler to provide a reasonable implementation of CoW for data<br>&gt;&gt; structures.<br>&gt;&gt; <br>&gt;&gt; Maybe I wasn’t clear.  I was talking about domain model objects like the following:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;  var firstName: String<br>&gt;&gt;  var lastName: String<br>&gt;&gt;  // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I find it hard to believe the compiler CoW implementation would do<br>&gt;&gt; something so suboptimal as to be significant when you write to<br>&gt;&gt; firstName through an indirect instance in cases like this (which are<br>&gt;&gt; pervasive in application code).<br>&gt; <br>&gt; Oh, OK.  And you want to CoW this because...?  Reducing refcount<br>&gt; traffic?<br></p><p>Avoiding copying and refcounting.  This might be a large aggregate.  You might use indirect structs and CoW so that portions of the aggregate can be shared by more than one aggregate root (i.e. persistent data structure).<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; (such as writing to a stored var)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what you mean here.<br>&gt;&gt; <br>&gt;&gt; Continuing with the previous example, if the CoW implementation is<br>&gt;&gt; significantly better when using a memberwise initializer to construct<br>&gt;&gt; the new box rather than copy the value over from the old box and then<br>&gt;&gt; update the property that was written to it seems like the compiler<br>&gt;&gt; should be able to make that optimization in some cases.  (i.e. when<br>&gt;&gt; there exists a memberwise initializer which exposes all stored<br>&gt;&gt; properties).<br>&gt; <br>&gt; Sure.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;                 I don’t mean to imply that it is the *only* valuable<br>&gt;             property. However, it I (and many others) do believe it is an<br>&gt;             extremely valuable<br>&gt;             property in many cases. Do you disagree?<br>&gt;<br>&gt;         I think I do. What is valuable about such a protocol? What generic<br>&gt;         algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;         work just as well on Array&lt;Int&gt;?<br>&gt;<br>&gt;     class Storage {<br>&gt;     var element: Int = 0<br>&gt;     }<br>&gt;<br>&gt;     struct Value {<br>&gt;     var storage: Storage<br>&gt;     }<br>&gt;<br>&gt;     func amIPure(v: Value) -&gt; Int {<br>&gt;     v.storage.element = 3<br>&gt;     return v.storage.element<br>&gt;     }<br>&gt;<br>&gt;     I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The<br>&gt;     developer needs to tell me where the boundaries of the value lie. Does<br>&gt;     &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a<br>&gt;     &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer<br>&gt;     will need to implement CoW, or we need add some language features.<br>&gt;<br>&gt; Thank you for this clear exposition of how PureValue relates to pure functions.<br>&gt; This is the exact intuition I have about it but you have stated it much more<br>&gt; clearly.<br>&gt;<br>&gt; Language features to help automate CoW would be great. It would eliminate<br>&gt; boilerplate, but more importantly it would likely provide more information to<br>&gt; the compiler.<br></p><p>Whoa; Andy never suggested this would help automate CoW.  Are you<br>suggesting that?  How would it work?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 3:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 7, 2016, at 2:21 AM, Andrew Trick via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                I don’t mean to imply that it is the *only* valuable<br>&gt;&gt;            property. However, it I (and many others) do believe it is an<br>&gt;&gt;            extremely valuable<br>&gt;&gt;            property in many cases. Do you disagree?<br>&gt;&gt; <br>&gt;&gt;        I think I do. What is valuable about such a protocol? What generic<br>&gt;&gt;        algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;&gt;        work just as well on Array&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt;    class Storage {<br>&gt;&gt;    var element: Int = 0<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    struct Value {<br>&gt;&gt;    var storage: Storage<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func amIPure(v: Value) -&gt; Int {<br>&gt;&gt;    v.storage.element = 3<br>&gt;&gt;    return v.storage.element<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The<br>&gt;&gt;    developer needs to tell me where the boundaries of the value lie. Does<br>&gt;&gt;    &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a<br>&gt;&gt;    &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer<br>&gt;&gt;    will need to implement CoW, or we need add some language features.<br>&gt;&gt; <br>&gt;&gt; Thank you for this clear exposition of how PureValue relates to pure functions.<br>&gt;&gt; This is the exact intuition I have about it but you have stated it much more<br>&gt;&gt; clearly.<br>&gt;&gt; <br>&gt;&gt; Language features to help automate CoW would be great. It would eliminate<br>&gt;&gt; boilerplate, but more importantly it would likely provide more information to<br>&gt;&gt; the compiler.<br>&gt; <br>&gt; Whoa; Andy never suggested this would help automate CoW.  Are you<br>&gt; suggesting that?  How would it work?<br></p><p>Quoting Andy:<br></p><p>&quot;I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The developer needs to tell me where the boundaries of the value lie. Does &#39;storage&#39; lie inside the Value, or outside? If it is inside, then Value is a &#39;PureValue&#39; and &#39;amIPure&#39; is a pure function. To enforce that, the developer will need to implement CoW, or we need add some language features.&quot;<br></p><p>I was referring to new language features that eliminate the need for the developer to implement CoW manually while preserving the same semantics.  <br></p><p>I don’t know about the general case, but in simple cases I can imagine a feature such as “indirect struct” or Box&lt;T: ValueType&gt; which would contain a reference to a struct on the heap.  Any time a mutating operation was performed on a non-uniquely referenced struct it would be copied first and the internal reference updated to point to the new copy on the heap.  This is the kind of thing I had in mind when I said “automating CoW”.<br></p><p><br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/6116bb0d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;     On May 6, 2016, at 5:48 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         I don’t mean to imply that it is the *only* valuable<br>&gt;         property. However, it I (and many others) do believe it is an extremely<br>&gt;         valuable<br>&gt;         property in many cases. Do you disagree?<br>&gt;<br>&gt;     I think I do. What is valuable about such a protocol? What generic<br>&gt;     algorithms could you write that work on models of PureValue but don&#39;t<br>&gt;     work just as well on Array&lt;Int&gt;?<br>&gt;<br>&gt; class Storage {<br>&gt; var element: Int = 0<br>&gt; }<br>&gt;<br>&gt; struct Value {<br>&gt; var storage: Storage<br>&gt; }<br>&gt;<br>&gt; func amIPure(v: Value) -&gt; Int {<br>&gt; v.storage.element = 3<br>&gt; return v.storage.element<br>&gt; }<br>&gt;<br>&gt; I (the optimizer) want to know if &#39;amIPure&#39; is a pure function. The developer<br>&gt; needs to tell me where the boundaries of the value lie. Does &#39;storage&#39; lie<br>&gt; inside the Value, or outside? If it is inside, then Value is a &#39;PureValue&#39; and<br>&gt; &#39;amIPure&#39; is a pure function. To enforce that, the developer will need to<br>&gt; implement CoW, or we need add some language features.<br>&gt;<br>&gt; If I know about every operation inside &#39;amIPure&#39;, and know where the value&#39;s<br>&gt; boundary is, then I don&#39;t really need to know that &#39;Value&#39; is a &#39;PureValue&#39;. For<br>&gt; example, I know that this function is pure without caring about &#39;PureValue&#39;.<br>&gt;<br>&gt; func IAmPure(v: Value, s: Storage) -&gt; Int {<br>&gt; var t = v<br>&gt; t.storage = s<br>&gt; return t.storage.element<br>&gt; }<br></p><p>How do you know this?  t.storage can be a computed property.  I think<br>you&#39;re assuming a lot of information is being communicated to me and to<br>the compiler from the types in the signature (e.g. can Value be a<br>reference type?)<br></p><p>&gt; However, I might only have summary information. I might know that the function<br>&gt; only writes to memory reachable from Value. In that case, it would be nice to<br>&gt; have summary information about the storage type. &#39;PureValue&#39; is another way of<br>&gt; saying that it does not contain references to objects outside the value&#39;s<br>&gt; boundary (I would add that it cannot have a user-defined deinit). The only thing<br>&gt; vague about that is that we don&#39;t have a general way for the developer to define<br>&gt; the value&#39;s boundary. It certainly should be consistent with &#39;==&#39;, but<br>&gt; implementing &#39;==&#39; doesn&#39;t tell the optimizer anything.<br>&gt;<br>&gt; Anyway, these are only optimizer concerns, and programming model should take<br>&gt; precedence in these discussion. <br></p><p>Indeed, I am arguing from the point of view of the programming model.  I<br>am very wary of introducing protocols that are only there for the use of<br>the optimizer.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
