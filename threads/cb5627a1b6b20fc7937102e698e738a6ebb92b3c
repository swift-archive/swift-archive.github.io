<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 19, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; 1) Do you agree about using “associatedtype”?<br>&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce<br>&gt; a new one)<br></p><p><br>There is another alternative. Rather than trying to come up with another<br>brand-new keyword, we can re-use one that has an existing and appropriate<br>meaning: required.<br></p><p>Example:<br></p><p>protocol ExampleProtocol {<br>  required typealias Element<br>  typealias MethodSignature = (arg: Element) -&gt; Bool<br></p><p>  ... etc<br>}<br></p><p>It&#39;s a little more verbose at the point of use but the declarations are<br>relatively uncommon and this usage is clearly separate from regular<br>typealias declarations.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/cb562b3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Dec 19, 2015, at 2:17 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; 1) Do you agree about using “associatedtype”?<br>&gt;&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>&gt; <br>&gt; There is another alternative. Rather than trying to come up with another brand-new keyword, we can re-use one that has an existing and appropriate meaning: required.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; protocol ExampleProtocol {<br>&gt;   required typealias Element<br>&gt;   typealias MethodSignature = (arg: Element) -&gt; Bool<br>&gt; <br>&gt;   ... etc<br>&gt; }<br>&gt; <br>&gt; It&#39;s a little more verbose at the point of use but the declarations are relatively uncommon and this usage is clearly separate from regular typealias declarations.<br>&gt; <br></p><p>I don&#39;t link this as it&#39;s not entirely accurate.  Associated types are somewhat different than typealiases and are often inferred, not declared in the conforming types.<br></p><p>&gt; Mike<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/da1d0062/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 12:17 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1) Do you agree about using “associatedtype”?<br>&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>&gt; <br>&gt; There is another alternative. Rather than trying to come up with another brand-new keyword, we can re-use one that has an existing and appropriate meaning: required.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; protocol ExampleProtocol {<br>&gt;   required typealias Element<br>&gt;   typealias MethodSignature = (arg: Element) -&gt; Bool<br>&gt; <br>&gt;   ... etc<br>&gt; }<br>&gt; <br>&gt; It&#39;s a little more verbose at the point of use but the declarations are relatively uncommon and this usage is clearly separate from regular typealias declarations.<br></p><p><br>I think this is a big improvement over associatedtype, except that the type that satisfies the requirement needn&#39;t be a typealias.  I would therefore prefer &quot;requiredtype.&quot;<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/963f9136/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 19, 2015 at 04:00:00pm</p></header><div class="content"><p>I like “requiredtype”.<br></p><p>Step Christopher<br>Big Nerd Ranch, LLC<br>schristopher at bignerdranch.com<br></p><p><br>On Sat, Dec 19, 2015 at 3:54 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 19, 2015, at 12:17 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; 1) Do you agree about using “associatedtype”?<br>&gt;&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce<br>&gt;&gt; a new one)<br>&gt;<br>&gt;<br>&gt; There is another alternative. Rather than trying to come up with another<br>&gt; brand-new keyword, we can re-use one that has an existing and appropriate<br>&gt; meaning: required.<br>&gt;<br>&gt; Example:<br>&gt;<br>&gt; protocol ExampleProtocol {<br>&gt;   required typealias Element<br>&gt;   typealias MethodSignature = (arg: Element) -&gt; Bool<br>&gt;<br>&gt;   ... etc<br>&gt; }<br>&gt;<br>&gt; It&#39;s a little more verbose at the point of use but the declarations are<br>&gt; relatively uncommon and this usage is clearly separate from regular<br>&gt; typealias declarations.<br>&gt;<br>&gt;<br>&gt; I think this is a big improvement over associatedtype, except that the<br>&gt; type that satisfies the requirement needn&#39;t be a typealias.  I would<br>&gt; therefore prefer &quot;requiredtype.&quot;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/9b259ebc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 19, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; There is another alternative. Rather than trying to come up with another brand-new keyword, we can re-use one that has an existing and appropriate meaning: required.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; protocol ExampleProtocol {<br>&gt;   required typealias Element<br>&gt;   typealias MethodSignature = (arg: Element) -&gt; Bool<br>&gt; <br>&gt;   ... etc<br>&gt; }<br>&gt; <br>&gt; It&#39;s a little more verbose at the point of use but the declarations are relatively uncommon and this usage is clearly separate from regular typealias declarations.<br></p><p>I don&#39;t think `required` captures the intended meaning *at all*. You&#39;re not required to declare the type of a &quot;required typealias&quot;—it&#39;s often, perhaps even usually, inferred. On the other hand, all types conforming to ExampleProtocol are &quot;required&quot; in some sense to have an Element, but they&#39;re also &quot;required&quot; to have a MethodSignature. (In fact, they&#39;re required to have exactly the MethodSignature specified there, but they can have any Element they want.) It&#39;s just not a good match.<br></p><p>If you wanted to analogize associated types to some existing feature, it would clearly be generics (but this is not done for very good reasons). If you wanted to reuse an existing keyword at all costs, I suspect what you should actually do is mark the non-associated type with `final` (but this doesn&#39;t match typealiases in other types, and it doesn&#39;t solve the searchability problem with using &quot;typealias&quot; for associated types).<br></p><p>The whole reason we got into this mess is because we unwisely reused a keyword for something barely related. Let&#39;s not do it again.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 5:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; There is another alternative. Rather than trying to come up with another brand-new keyword, we can re-use one that has an existing and appropriate meaning: required.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; protocol ExampleProtocol {<br>&gt;&gt;  required typealias Element<br>&gt;&gt;  typealias MethodSignature = (arg: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;  ... etc<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It&#39;s a little more verbose at the point of use but the declarations are relatively uncommon and this usage is clearly separate from regular typealias declarations.<br>&gt; <br>&gt; I don&#39;t think `required` captures the intended meaning *at all*. You&#39;re not required to declare the type of a &quot;required typealias&quot;—it&#39;s often, perhaps even usually, inferred.<br></p><p>No, but it is required to exist and can&#39;t always be inferred.  It puts a constraint on the type that is declared to conform.  This is a requirement in exactly the same sense that other protocol requirements are requirements.  Notably operator requirements may be satisfied &quot;implicitly&quot; by declarations that already exist, but they are still requirements.<br></p><p>&gt; On the other hand, all types conforming to ExampleProtocol are &quot;required&quot; in some sense to have an Element, but they&#39;re also &quot;required&quot; to have a MethodSignature. (In fact, they&#39;re required to have exactly the MethodSignature specified there, but they can have any Element they want.)<br></p><p>No, that is not a protocol requirement; it doesn&#39;t put a constraint on any type that is declared to conform.<br></p><p>&gt; It&#39;s just not a good match.<br>&gt; <br>&gt; If you wanted to analogize associated types to some existing feature, it would clearly be generics (but this is not done for very good reasons). If you wanted to reuse an existing keyword at all costs, I suspect what you should actually do is mark the non-associated type with `final` (but this doesn&#39;t match typealiases in other types, and it doesn&#39;t solve the searchability problem with using &quot;typealias&quot; for associated types).<br>&gt; <br>&gt; The whole reason we got into this mess is because we unwisely reused a keyword for something barely related. Let&#39;s not do it again.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 20, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 11:14 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 5:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think `required` captures the intended meaning *at all*. You&#39;re not required to declare the type of a &quot;required typealias&quot;—it&#39;s often, perhaps even usually, inferred.<br>&gt; <br>&gt; No, but it is required to exist and can&#39;t always be inferred.  It puts a constraint on the type that is declared to conform.  This is a requirement in exactly the same sense that other protocol requirements are requirements.  Notably operator requirements may be satisfied &quot;implicitly&quot; by declarations that already exist, but they are still requirements.<br></p><p>I think reusing &quot;required&quot; here (where &quot;typealias&quot; has already been reused) could make the concept of associated types more opaque to new users.<br></p><p>The use of &quot;typealias&quot; as a kind of &quot;typedef&quot; immediately made sense to me. When I first stumbled upon &quot;typealias&quot; in a protocol, it took me some time to fully grok its use and its connection to its &quot;typedef&quot; counterpart.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/63f0b0e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 8:27 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 11:14 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 5:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think `required` captures the intended meaning *at all*. You&#39;re not required to declare the type of a &quot;required typealias&quot;—it&#39;s often, perhaps even usually, inferred.<br>&gt;&gt; <br>&gt;&gt; No, but it is required to exist and can&#39;t always be inferred.  It puts a constraint on the type that is declared to conform.  This is a requirement in exactly the same sense that other protocol requirements are requirements.  Notably operator requirements may be satisfied &quot;implicitly&quot; by declarations that already exist, but they are still requirements.<br>&gt; <br>&gt; I think reusing &quot;required&quot; here (where &quot;typealias&quot; has already been reused) could make the concept of associated types more opaque to new users.<br></p><p>I agree.  There are a couple of potentially confusing issues here:<br></p><p>- In principle, all of the declarations in the protocol are “requirements” that a type needs to fulfill to conform to the protocol.<br>- Except for optional requirements in @objc protocols.<br>- Except for requirements with default implementations (which currently cannot be written inline in the protocol, but should be allowed some day).  Today’s typealiases can have &quot;default implementations” as well.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5496ef3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>Given that the type will/must be defined, implicitly or explicitly, by the<br>adopter of a protocol, what about &quot;adopterType&quot;?<br></p><p>Mike<br></p><p>On Mon, Dec 21, 2015 at 11:33 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 20, 2015, at 8:27 AM, Stephen Celis via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 19, 2015, at 11:14 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 19, 2015, at 5:09 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t think `required` captures the intended meaning *at all*. You&#39;re<br>&gt; not required to declare the type of a &quot;required typealias&quot;—it&#39;s often,<br>&gt; perhaps even usually, inferred.<br>&gt;<br>&gt;<br>&gt; No, but it is required to exist and can&#39;t always be inferred.  It puts a<br>&gt; constraint on the type that is declared to conform.  This is a requirement<br>&gt; in exactly the same sense that other protocol requirements are<br>&gt; requirements.  Notably operator requirements may be satisfied &quot;implicitly&quot;<br>&gt; by declarations that already exist, but they are still requirements.<br>&gt;<br>&gt;<br>&gt; I think reusing &quot;required&quot; here (where &quot;typealias&quot; has already been<br>&gt; reused) could make the concept of associated types more opaque to new users.<br>&gt;<br>&gt;<br>&gt; I agree.  There are a couple of potentially confusing issues here:<br>&gt;<br>&gt; - In principle, all of the declarations in the protocol are “requirements”<br>&gt; that a type needs to fulfill to conform to the protocol.<br>&gt; - Except for optional requirements in @objc protocols.<br>&gt; - Except for requirements with default implementations (which currently<br>&gt; cannot be written inline in the protocol, but should be allowed some day).<br>&gt; Today’s typealiases can have &quot;default implementations” as well.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/17cbc048/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
