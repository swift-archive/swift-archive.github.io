<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals proposal</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve written up a proposal for multi-line string literals. Before proposing it officially, I would like to get some informal feedback.<br></p><p>How can I propose it officially? Do I have to convert it to Markdown? I have no idea how to create a Markdown version of this, with all the quotes and funny characters in it ;)<br></p><p>-Michael<br></p><p>***<br></p><p>MULTI-LINE STRING LITERALS<br></p><p>- Proposal: SE-xxxx<br>- Author: Michael Peternell<br>- Status:<br>- Review manager:<br></p><p>INTRODUCTION<br></p><p>Multi-line string literals allow text that may be multiple lines long, to be included verbatim into a string literal. The string may even contain quote characters (&quot; or &#39;), and they don&#39;t have to be specially escaped.<br></p><p>MOTIVATION<br></p><p>Including many lines of text in a program often looks not so well, e.g. a JSON-string where ever quote needs to be escaped: &quot;{\&quot;response\&quot;:{\&quot;result\&quot;:\&quot;OK\&quot;}}&quot;. With multi-line string literals, we can write &quot;&quot;&quot;{&quot;response&quot;:{&quot;result&quot;:&quot;OK&quot;}}&quot;&quot;&quot; - note that every valid JSON can be pasted as-is into a &quot;&quot;&quot;3-quote string literal&quot;&quot;&quot;, because 3 quotes (&quot;&quot;&quot;) cannot appear in a valid JSON. (Why would you want to have a JSON-string in a program? Maybe you are writing unit tests for a JSON parser.) Another usage example is below.<br></p><p>Some people had concerns that a string block may break the indentation of the code. E.g.<br></p><p>                // some deeply indented code<br>                doSomeStuff(2, 33.1)<br>                print(&quot;&quot;&quot;Usage: \(program_name) &lt;PARAM-X&gt; &lt;PARAM-Y&gt; filename<br>Example: \(program_name) 3 1 countries.csv<br>This will print the 1st column of the 3rd non-empty non-header line from<br>countries.csv<br>&quot;&quot;&quot;             )<br>                exit(2)<br></p><p>That&#39;s the reason why there is also a HEREDOC-syntax in the proposal that can solve this problem. The example can be rewritten as:<br></p><p>                // some deeply indented code<br>                doSomeStuff(2, 33.1)<br>                print(&lt;&lt;USAGE_END)<br>                    Example: \(program_name) 3 1 countries.csv<br>                    This will print the 1st column of the 3rd non-empty<br>                    non-header line from countries.csv<br></p><p>                    USAGE_END<br>                exit(2)<br></p><p>This works unambiguously, as long as you don&#39;t mix tabs and spaces in your source code file.<br></p><p>PROPOSED SOLUTION<br></p><p>This proposal introduces three new forms of a String literal:<br></p><p>let INTERPOLATION = &quot;String interpolation&quot;<br></p><p>1. The &quot;&quot;&quot;Python-style string literal. 3 Quotes (&quot;) at the beginning, 3 Quotes at the end, and Swift \(INTERPOLATION) is possible.&quot;&quot;&quot;<br></p><p>2. The &lt;&lt;HERE_DOC, the string literal starts on the next line:<br>    A hereDoc may contain multiple lines. Leading space on each<br>    line is automatically truncated if the HERE_DOC delimiter<br>    is also indented. \(INTERPOLATION) is possible.<br>    HERE_DOC<br></p><p>3. A &lt;&lt;&#39;HERE_DOC&#39; with single quotes around them.<br>This is almost the same as a heredoc without single quotes, but text is included as-is.<br>You may include \ or &quot; or &#39; or whatever (\&quot;) is just a backslash followed by a double quote.<br>The leading space rule is the same as for the other HERE_DOC.<br>Swift String interpolation is not possible here.<br>HERE_DOC<br></p><p>DETAILED DESIGN<br></p><p>The first type of String (the &quot;&quot;&quot;Python-style multiline string&quot;&quot;&quot;) behaves exactly like the &quot;ordinary string literal&quot;, except for a few differences:<br>- a line-break doesn&#39;t result in an error, but is normally integrated into the strings value<br>- an included &quot; doesn&#39;t end the string and does not need to be quoted.<br>- If you want to include &quot;&quot;&quot; in the string, you have to write &quot;&quot;\&quot;. This is a rare use-case, and if you really need to do that, you may as well use one of the HERE_DOC-styles instead.<br></p><p>The second type of String (the &lt;&lt;HERE_DOC with string-interpolation) include all lines after the line where HERE_DOC appears, until the HERE_DOC delimiter line. The last newline before the HERE_DOC delimiter line is automatically truncated from the string; otherwise it would not be possible to create a HERE_DOC string literal that does not end with a newline character. If you want to end the string literal with a newline character, you need an empty line before the HERE_DOC delimiter line (as in the &quot;usage&quot;-example above). The HERE_DOC delimiter line contains optional whitespace at the beginning, followed by the HERE_DOC token. If the line contains leading whitespace, all lines within the literal have to contain exactly the same amount of leading whitespace. E.g. if the HERE_DOC-line contains 4 spaces, followed by &quot;HERE_DOC&quot;, each line in the string literal has to start with 4 spaces as well (using one tab instead, or less white space, would be a parse error.) Empty lines within the string literal are exempt from this requirement. They just translate to &quot;\n&quot;. (Fineprint: if the HEREDOC delimiter line is &quot;\t\tHEREDOC&quot; and one of the lines in the string literal are just &quot;    &quot; then it is not decidable wether the line should translate to &quot;\n&quot; (if &quot;\t&quot; is like &quot;  &quot; or larger) or to &quot;  \n&quot; (if &quot;\t&quot; is like &quot; &quot;), so this would also result in a parse error. The whitespace before the HERE_DOC on the HERE_DOC delimiter line must contain only spaces or only tabs, but not a mixture of both. These rules are a bit complicated for the language implementor, but for the user of the feature, they have an important advantage: if the code compiles, the string literal will behave as expected. Just don&#39;t mix tabs and spaces and you&#39;ll be fine.)<br></p><p>The third type of string is exactly the same as the second type, with the only difference that the &lt;&lt;HERE_DOC syntax is changed to &lt;&lt;&#39;HERE_DOC&#39;, and that all string interpolation and escape sequences are disabled within the literal. The end token is still HERE_DOC without single quotes, and not &#39;HERE_DOC&#39;. The rules about leading whitespace on the HERE_DOC delimiter line are the same as for the second type.<br></p><p>For the HERE_DOC token, everything that is a valid variable name is allowed, so &lt;&lt;hello, &lt;&lt;END_OF_XML are all valid, but &lt;&lt;2442 is not. Furthermore, ever token that matches /[a-zA-Z]+/ is also valid, so &lt;&lt;class should be okay as well. (The usual practice is to use SCREAMING_SNAKE_CASE tokens as delimiters.)<br></p><p>IMPACT ON EXISTING CODE<br></p><p>This is an add-on feature. Code that uses these multi-line string literals didn&#39;t even compile with previous versions of Swift, so no existing code can break because of this change.<br></p><p>ALTERNATIVES CONSIDERED<br></p><p>1. Just copy all String-handling rules from Perl ;)<br></p><p>2. String literals of the form<br></p><p>    _&quot;text text<br>    &quot;text text&quot;_<br></p><p>I don&#39;t like the continuation quote, and so it doesn&#39;t solve the problem that I am trying to solve with this proposal. The same if true for a string literal where you would have to start each line with \\ .<br></p><p>3. eXML&quot;a string literal that starts with e, followed by some token, and that ends with a quote (&quot;) followed by the same token&quot;XML. This has the advantage, that you can put anything between the start and the end, and that you can choose a delimiter. It&#39;s a flexible solution. I prefer HERE_DOC&#39;s though, because they are an already well-known programming language construct.<br></p><p>4. Do nothing, and just use string concatenation: &quot;this string\n&quot;+<br>&quot;with newlines in it\n&quot; works well. Maybe the optimizer can optimize this away anyways, so there wouldn&#39;t even be a performance cost.<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
