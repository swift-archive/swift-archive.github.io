<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab708467d1683c441f44d19ad7badb1e?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Steve Richey</string> &lt;srichey at gowithfloat.com&gt;<p>February  8, 2016 at 04:00:00am</p></header><div class="content"><p>It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br></p><p>It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br></p><p>In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br></p><p>Example:<br>```<br>func myFunction() -&gt; String {<br>return &quot;hello&quot;<br>}<br></p><p>let myValue = #run myFunction()<br>```<br></p><p>At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br></p><p>This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br></p><p>This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br></p><p>Thank you for your time!<br></p><p>Best regards,<br>Steve Richey<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/8a072b7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February  7, 2016 at 09:00:00pm</p></header><div class="content"><p>+1<br></p><p>I saw the Jai presentation that covered this feature, and it struck me as quite powerful. Simple compile-time asset processing is highly appealing to me -- that would be particularly helpful in the domain of games.<br></p><p>I think this feature has a very high value/complexity ratio.<br></p><p>Jarod<br></p><p>&gt; On Feb 7, 2016, at 20:29, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt; <br>&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt; <br>&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt; <br>&gt; Example:<br>&gt; ```<br>&gt; func myFunction() -&gt; String {<br>&gt; return &quot;hello&quot;<br>&gt; }<br>&gt; <br>&gt; let myValue = #run myFunction()<br>&gt; ```<br>&gt; <br>&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt; <br>&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt; <br>&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt; <br>&gt; Thank you for your time!<br>&gt; <br>&gt; Best regards,<br>&gt; Steve Richey<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/c3b55f17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  8, 2016 at 12:00:00am</p></header><div class="content"><p>That&#39;s actually very complex for types that can&#39;t be serialized/&quot;encoded&quot;.<br></p><p>Félix<br></p><p>&gt; Le 8 févr. 2016 à 00:12:17, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I saw the Jai presentation that covered this feature, and it struck me as quite powerful. Simple compile-time asset processing is highly appealing to me -- that would be particularly helpful in the domain of games.<br>&gt; <br>&gt; I think this feature has a very high value/complexity ratio.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt;&gt; On Feb 7, 2016, at 20:29, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt; <br>&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt; <br>&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; ```<br>&gt;&gt; func myFunction() -&gt; String {<br>&gt;&gt; return &quot;hello&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let myValue = #run myFunction()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt;&gt; <br>&gt;&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt;&gt; <br>&gt;&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt;&gt; <br>&gt;&gt; Thank you for your time!<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Steve Richey<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/bdc8ba84/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  7, 2016 at 09:00:00pm</p></header><div class="content"><p>I believe macro-ish stuff has been ruled &quot;out of scope&quot; until Swift 3 is out.<br></p><p>If not, it gets a +1 from me, and it&#39;d serve as a nice stop-gap until Swift advances to the point that its own front-end can itself be written in Swift (at which point I *think* a bunch of very meta things involving the REPL and extensions become plausible — I think).<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 7, 2016, at 20:29, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt; <br>&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt; <br>&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt; <br>&gt; Example:<br>&gt; ```<br>&gt; func myFunction() -&gt; String {<br>&gt; return &quot;hello&quot;<br>&gt; }<br>&gt; <br>&gt; let myValue = #run myFunction()<br>&gt; ```<br>&gt; <br>&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt; <br>&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt; <br>&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt; <br>&gt; Thank you for your time!<br>&gt; <br>&gt; Best regards,<br>&gt; Steve Richey<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/f1ece6ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>February  8, 2016 at 09:00:00am</p></header><div class="content"><p>What if the function you&#39;re evaluating depends on code that hasn&#39;t been compiled yet?<br></p><p>&gt; func f() -&gt; String {<br>&gt;     return g()<br>&gt; }<br>&gt; <br>&gt; let value = #run f()<br>&gt; <br>&gt; func g() -&gt; String {<br>&gt;     return &quot;foo&quot;<br>&gt; }<br></p><p>Regards,<br>Adrian Kashivskyy<br>Senior iOS Developer at Netguru<br></p><p>&gt; Wiadomość napisana przez David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 08.02.2016, o godz. 06:31:<br>&gt; <br>&gt; I believe macro-ish stuff has been ruled &quot;out of scope&quot; until Swift 3 is out.<br>&gt; <br>&gt; If not, it gets a +1 from me, and it&#39;d serve as a nice stop-gap until Swift advances to the point that its own front-end can itself be written in Swift (at which point I *think* a bunch of very meta things involving the REPL and extensions become plausible — I think).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; On Feb 7, 2016, at 20:29, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt; <br>&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt; <br>&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; ```<br>&gt;&gt; func myFunction() -&gt; String {<br>&gt;&gt; return &quot;hello&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let myValue = #run myFunction()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt;&gt; <br>&gt;&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt;&gt; <br>&gt;&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt;&gt; <br>&gt;&gt; Thank you for your time!<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Steve Richey<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/f9e09915/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 8 Feb 2016, at 04:29, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Example:<br>&gt; ```<br>&gt; func myFunction() -&gt; String {<br>&gt; return &quot;hello&quot;<br>&gt; }<br>&gt; <br>&gt; let myValue = #run myFunction()<br>&gt; ```<br>&gt; <br>&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt; <br>&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br></p><p>Do we actually need the #run attribute in this case? If the compiler can detect that myFunction() has a fixed return value, or is only ever called once etc., then could it not just optimise away the function call entirely?<br></p><p>For example:<br></p><p>	func powersOfTwo() -&gt; [UIntMax] { // Return an array of the first 64 powers of two.<br>		var steps = (sizeof(UIntMax) * 8)<br>		var powers[UIntMax] = [];<br>		repeat {<br>			steps -= 1<br>			powers.append(UIntMax(1) &lt;&lt; steps)<br>		} while (steps &gt; 0)<br>		return powers<br>	}<br></p><p>	let powersOfTwoList = powersOfTwo()<br></p><p>Since powersOfTwo() is only ever used once, it can be computed into an array constant; the compiler might already do that, I’m not sure. The main difficulty is whether the compiler can detect code that has no predictable return value, e.g- a call that returns the current time, as this would prevent a function from being precomputed into a constant in this way. There may also be cases where a function’s precomputed value could be very large in which case it might be more desirable to compute it only as needed, though if powersOfTwoList were a static value this wouldn’t matter.<br></p><p>In other words, I think we should be clear on where macros will actually offer functionality that the compiler can’t provide for us, as it seems to me that in the examples given so far we could just use regular code and the compiler can factor it out for us, or we could have an attribute that allows us to indicate which code the compiler should try to factor out. But as a general rule I think if the compiler can factor out unnecessary functions itself, then this could be better in the long run for efficiency anyway, and that’s assuming it doesn’t already do this to some degree (hopefully someone can weigh in on that).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/c309d29c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>I think this proposal follow the same principle of the Tail Call<br>Optimization keyword/attribute proposal. It&#39;s a &quot;thing&quot; with the compiler<br>can do alone, but can be &quot;improved&quot; with some user annotation.<br></p><p>The main question (for me) of this proposal, is: The idea is evaluate the<br>result of any runtime function, for the &quot;next build&quot;? Like Profile Guided<br>Optimization (PGO) do for code paths?<br></p><p>If is: How to handle with functions with call &quot;external modules&quot; functions,<br>there&#39;s no way to sure the result of this functions will be consistent; so<br>any technique to detect the need to reevaluate the result may fail. Is this<br>case, the developer need to &quot;manually&quot; clean the cache or similar to<br>recompute the result.<br></p><p>Like said, there alot of &quot;market&quot; to &quot;pre compiled&quot; things, like in games.<br></p><p>Em seg, 8 de fev de 2016 às 07:39, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; On 8 Feb 2016, at 04:29, Steve Richey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Example:<br>&gt; ```<br>&gt; func myFunction() -&gt; String {<br>&gt; return &quot;hello&quot;<br>&gt; }<br>&gt;<br>&gt; let myValue = #run myFunction()<br>&gt; ```<br>&gt;<br>&gt; At compile time, `myFunction` is evaluated and the result inlined to the<br>&gt; `myValue` definition. At run time, `myValue` is a `String` containing<br>&gt; `&quot;hello&quot;`.<br>&gt;<br>&gt; This is useful for tasks that are relatively expensive to run but only<br>&gt; need to be done once, such as lookup tables. Running the algorithm to<br>&gt; generate those tables can be handled at compile-time, and the results<br>&gt; retrieved at no cost at run time. Furthermore, this structure allows code<br>&gt; reuse between the run time and build time code, obviating the need to<br>&gt; perform similar tasks in, say, a Swift method and a Python script.<br>&gt;<br>&gt;<br>&gt; Do we actually need the #run attribute in this case? If the compiler can<br>&gt; detect that myFunction() has a fixed return value, or is only ever called<br>&gt; once etc., then could it not just optimise away the function call entirely?<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; func powersOfTwo() -&gt; [UIntMax] { // Return an array of the first 64<br>&gt; powers of two.<br>&gt; var steps = (sizeof(UIntMax) * 8)<br>&gt; var powers[UIntMax] = [];<br>&gt; repeat {<br>&gt; steps -= 1<br>&gt; powers.append(UIntMax(1) &lt;&lt; steps)<br>&gt; } while (steps &gt; 0)<br>&gt; return powers<br>&gt; }<br>&gt;<br>&gt; let powersOfTwoList = powersOfTwo()<br>&gt;<br>&gt; Since powersOfTwo() is only ever used once, it can be computed into an<br>&gt; array constant; the compiler might already do that, I’m not sure. The main<br>&gt; difficulty is whether the compiler can detect code that has no predictable<br>&gt; return value, e.g- a call that returns the current time, as this would<br>&gt; prevent a function from being precomputed into a constant in this way.<br>&gt; There may also be cases where a function’s precomputed value could be very<br>&gt; large in which case it might be more desirable to compute it only as<br>&gt; needed, though if powersOfTwoList were a static value this wouldn’t matter.<br>&gt;<br>&gt; In other words, I think we should be clear on where macros will actually<br>&gt; offer functionality that the compiler can’t provide for us, as it seems to<br>&gt; me that in the examples given so far we could just use regular code and the<br>&gt; compiler can factor it out for us, or we could have an attribute that<br>&gt; allows us to indicate which code the compiler should try to factor out. But<br>&gt; as a general rule I think if the compiler can factor out unnecessary<br>&gt; functions itself, then this could be better in the long run for efficiency<br>&gt; anyway, and that’s assuming it doesn’t already do this to some degree<br>&gt; (hopefully someone can weigh in on that).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/eb4bcb2d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt; <br>&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt; <br>&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br></p><p>Something like this would definitely be interesting to build out.  We should investigate it post-Swift 3 in the context of a hygienic macro system.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/62713773/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab708467d1683c441f44d19ad7badb1e?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Steve Richey</string> &lt;srichey at gowithfloat.com&gt;<p>February  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Based on the response, it seems like there&#39;s some interest, but the team wouldn&#39;t get to it until after Swift 3 at the earliest. Should I open a pull request to the swift-evolution repo to allow feedback and prevent duplicate proposals?<br></p><p>- Steve<br></p><p>From: &lt;clattner at apple.com&lt;mailto:clattner at apple.com&gt;&gt; on behalf of Chris Lattner &lt;clattner at apple.com&lt;mailto:clattner at apple.com&gt;&gt;<br>Date: Monday, February 8, 2016 at 1:13 PM<br>To: Steve Richey &lt;srichey at gowithfloat.com&lt;mailto:srichey at gowithfloat.com&gt;&gt;<br>Cc: &quot;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&quot; &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: Re: [swift-evolution] Proposal: allow arbitrary compile-time code execution<br></p><p><br>On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br></p><p>It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br></p><p>In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br></p><p>Something like this would definitely be interesting to build out.  We should investigate it post-Swift 3 in the context of a hygienic macro system.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/7c27070b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 12:54 PM, Steve Richey &lt;srichey at gowithfloat.com&gt; wrote:<br>&gt; <br>&gt; Based on the response, it seems like there&#39;s some interest, but the team wouldn&#39;t get to it until after Swift 3 at the earliest. Should I open a pull request to the swift-evolution repo to allow feedback and prevent duplicate proposals?<br></p><p>I don’t think that this makes sense.  The proposals in the swift-evolution repo are required to have some informed discussion and debate in the community before a proposal can be accepted for further discussion.  Until Swift 3 is out of the door, we can’t have that pre-discussion.<br></p><p>I’d suggest logging a ticket in bugs.swift.org to keep track of this, but it is also a well known area of exploration, so we probably don’t need to track it.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; - Steve<br>&gt; <br>&gt; From: &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; on behalf of Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;<br>&gt; Date: Monday, February 8, 2016 at 1:13 PM<br>&gt; To: Steve Richey &lt;srichey at gowithfloat.com &lt;mailto:srichey at gowithfloat.com&gt;&gt;<br>&gt; Cc: &quot;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Subject: Re: [swift-evolution] Proposal: allow arbitrary compile-time code execution<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt; <br>&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt; <br>&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt; <br>&gt; Something like this would definitely be interesting to build out.  We should investigate it post-Swift 3 in the context of a hygienic macro system.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/8c40da41/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>If you’re asking the mailing list as a whole, I certainly won’t complain. I’m not “on the team” or anything, though…<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 8, 2016, at 12:54, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Based on the response, it seems like there&#39;s some interest, but the team wouldn&#39;t get to it until after Swift 3 at the earliest. Should I open a pull request to the swift-evolution repo to allow feedback and prevent duplicate proposals?<br>&gt; <br>&gt; - Steve<br>&gt; <br>&gt; From: &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; on behalf of Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;<br>&gt; Date: Monday, February 8, 2016 at 1:13 PM<br>&gt; To: Steve Richey &lt;srichey at gowithfloat.com &lt;mailto:srichey at gowithfloat.com&gt;&gt;<br>&gt; Cc: &quot;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Subject: Re: [swift-evolution] Proposal: allow arbitrary compile-time code execution<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt; <br>&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt; <br>&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt; <br>&gt; Something like this would definitely be interesting to build out.  We should investigate it post-Swift 3 in the context of a hygienic macro system.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/8c2c7be0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>This would be cool, but allowing arbitrary code from the enclosing context to be executed introduces difficult dependency ordering issues. I like the design of Metalua (http://metalua.luaforge.net), which allows for pretty explicit and flexible jumping up and down &quot;meta&quot; levels, which in addition to building values, can also build arbitrary ASTs. In Swift, that might look something like this:<br></p><p><br>// Compile-time available definitions, that produce Expr nodes<br>#{<br>func myCompileTimeFunction() -&gt; Expr { ... }<br>}#<br></p><p>// Evaluate a compile-time function and expand the result expression here<br>let myValue = #(myFunction())<br></p><p>-Joe<br></p><p>&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt; <br>&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt; <br>&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt; <br>&gt; Example:<br>&gt; ```<br>&gt; func myFunction() -&gt; String {<br>&gt; return &quot;hello&quot;<br>&gt; }<br>&gt; <br>&gt; let myValue = #run myFunction()<br>&gt; ```<br>&gt; <br>&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt; <br>&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt; <br>&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt; <br>&gt; Thank you for your time!<br>&gt; <br>&gt; Best regards,<br>&gt; Steve Richey<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/99d6a353/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  9, 2016 at 09:00:00am</p></header><div class="content"><p>It seems a bit like an all new syntax though; what about an attribute that places some extra requirements on the function that throws an error if it can’t be produced at compile time? Not sure what it should be called, but I was thinking something like:<br></p><p>	@compile_time func myFunction(foo:String) -&gt; Expr { … }<br></p><p>If the function can’t be made available at compile time due to dependencies or runtime requirements or whatever, then it will generate an error, otherwise it will be compiled ahead of other functions, and will explicitly have a precomputed value.<br></p><p>The idea is that while the attribute explicitly tells the compiler to compile this function in advance, it doesn’t introduce a separate class of function or a kind of language within a language, and the function could even still be called at runtime as well with dynamic values for foo (rather than constant ones).<br></p><p>That said, I still think that ideally the compiler should do as much of this pre computation as it can, the difference here is that the attribute explicitly requires it, while another could explicitly prevent it (if you’re concerned about memory).<br></p><p>&gt; On 8 Feb 2016, at 19:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; This would be cool, but allowing arbitrary code from the enclosing context to be executed introduces difficult dependency ordering issues. I like the design of Metalua (http://metalua.luaforge.net &lt;http://metalua.luaforge.net/&gt;), which allows for pretty explicit and flexible jumping up and down &quot;meta&quot; levels, which in addition to building values, can also build arbitrary ASTs. In Swift, that might look something like this:<br>&gt; <br>&gt; <br>&gt; // Compile-time available definitions, that produce Expr nodes<br>&gt; #{<br>&gt; func myCompileTimeFunction() -&gt; Expr { ... }<br>&gt; }#<br>&gt; <br>&gt; // Evaluate a compile-time function and expand the result expression here<br>&gt; let myValue = #(myFunction())<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt; <br>&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt; <br>&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; ```<br>&gt;&gt; func myFunction() -&gt; String {<br>&gt;&gt; return &quot;hello&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let myValue = #run myFunction()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt;&gt; <br>&gt;&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt;&gt; <br>&gt;&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt;&gt; <br>&gt;&gt; Thank you for your time!<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Steve Richey<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/03437c5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Proposal: allow arbitrary compile-time code execution</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>Or maybe <br></p><p>@constexpr func myFunction(foo:String) -&gt; Expr {…}<br></p><p>Regardless of the syntax, it’s great to see that I’m not the only one interested in this.<br></p><p>-Matt<br></p><p>PS - Metalua looks fascinating.<br></p><p><br></p><p><br></p><p><br>&gt; On Feb 9, 2016, at 01:18, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems a bit like an all new syntax though; what about an attribute that places some extra requirements on the function that throws an error if it can’t be produced at compile time? Not sure what it should be called, but I was thinking something like:<br>&gt; <br>&gt; 	@compile_time func myFunction(foo:String) -&gt; Expr { … }<br>&gt; <br>&gt; If the function can’t be made available at compile time due to dependencies or runtime requirements or whatever, then it will generate an error, otherwise it will be compiled ahead of other functions, and will explicitly have a precomputed value.<br>&gt; <br>&gt; The idea is that while the attribute explicitly tells the compiler to compile this function in advance, it doesn’t introduce a separate class of function or a kind of language within a language, and the function could even still be called at runtime as well with dynamic values for foo (rather than constant ones).<br>&gt; <br>&gt; That said, I still think that ideally the compiler should do as much of this pre computation as it can, the difference here is that the attribute explicitly requires it, while another could explicitly prevent it (if you’re concerned about memory).<br>&gt; <br>&gt;&gt; On 8 Feb 2016, at 19:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This would be cool, but allowing arbitrary code from the enclosing context to be executed introduces difficult dependency ordering issues. I like the design of Metalua (http://metalua.luaforge.net &lt;http://metalua.luaforge.net/&gt;), which allows for pretty explicit and flexible jumping up and down &quot;meta&quot; levels, which in addition to building values, can also build arbitrary ASTs. In Swift, that might look something like this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Compile-time available definitions, that produce Expr nodes<br>&gt;&gt; #{<br>&gt;&gt; func myCompileTimeFunction() -&gt; Expr { ... }<br>&gt;&gt; }#<br>&gt;&gt; <br>&gt;&gt; // Evaluate a compile-time function and expand the result expression here<br>&gt;&gt; let myValue = #(myFunction())<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 7, 2016, at 8:29 PM, Steve Richey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not uncommon to want to run code at build time. Xcode solves this need by allowing &quot;Build Phases&quot;, which are often shell scripts which handle compile-time tasks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may be beneficial to Swift developers, especially those who are not programming on platforms supported by Xcode, to handle compile-time tasks in a powerful and expressive language with which they are already familiar: Swift!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short, I propose the addition of a `#run` expression that allows the execution of code at compile time. This syntax and concept are borrowed from the programming language Jai (https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution &lt;https://sites.google.com/site/jailanguageprimer/#TOC-Arbitrary-Compile-Time-Code-Execution&gt;) but the syntax fits nicely with other special expression syntax in Swift such as `#available`, `#selector`, `#file`, and so on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; func myFunction() -&gt; String {<br>&gt;&gt;&gt; return &quot;hello&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myValue = #run myFunction()<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At compile time, `myFunction` is evaluated and the result inlined to the `myValue` definition. At run time, `myValue` is a `String` containing `&quot;hello&quot;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is useful for tasks that are relatively expensive to run but only need to be done once, such as lookup tables. Running the algorithm to generate those tables can be handled at compile-time, and the results retrieved at no cost at run time. Furthermore, this structure allows code reuse between the run time and build time code, obviating the need to perform similar tasks in, say, a Swift method and a Python script.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my first attempt at a Swift proposal, so any and all feedback is welcome! This seems like it should be easy enough to implement but I&#39;m not especially familiar with Swift&#39;s internals. If there are any hurdles or unforeseen consequences associated with this from an implementation standpoint, that would be very useful to know.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for your time!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best regards,<br>&gt;&gt;&gt; Steve Richey<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/b57d55e3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
