<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2f61fa79919d9b1dc352f4ed16724f03?s=50"></div><header><strong>Prosposal: LazyCollectionType.prefix() to return a lazy collection</strong> from <string>Mark Aron Szulyovszky</string> &lt;mark.szulyovszky at gmail.com&gt;<p>February 14, 2016 at 10:00:00am</p></header><div class="content"><p>*Problem:*<br>.prefix() works eagerly even on LazyCollectionType. This means access is<br>not O(1).<br></p><p>*Implications:*<br>There&#39;s no way to only get the first N elements of a lazy sequence without<br>a nasty for loop. If prefix() used on a lazy sequence, it&#39;ll trigger<br>computation on the whole array, just to return the first N elements.<br></p><p>*Proposal:*<br>It would be more more useful if lazy.&lt;insert methods here&gt;.prefix() returned<br>LazyPrefixCollection&lt;Generator.Element&gt;<br>instead of<br>Slice&lt;LazyCustomCollection&lt;Range&lt;Generator.Element&gt;&gt;&gt;.<br></p><p>That way prefix() could be used to chain *pure lazy operations*, like<br>lazy.filter().map().filter().prefix().map() which can be quite useful in<br>some cases.<br></p><p>I understand that this has implications, and it would make prefix() less<br>consistent in terms of return type.<br>But, this pattern seem to be used in this context already - it wouldn&#39;t be<br>a much different than how how lazy.filter() is implemented, since it also<br>returns a custom LazySequenceType instead of SequenceType.<br></p><p>Has this been considered before? Would there be any cases where this would<br>create unintended side effects?<br>As far as I see, it wouldn&#39;t change the meaning and behaviour of prefix(),<br>only would it extend its usefulness.<br></p><p>I submitted a PR to the SwiftSequence library that demonstrates the<br>implementation:<br>https://github.com/itchingpixels/SwiftSequence/commit/26101e5aec6c266048bbad4db7b44b9c453f07ca<br></p><p>Thanks a lot!<br></p><p>Mark<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/1c75978c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Prosposal: LazyCollectionType.prefix() to return a lazy collection</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 14, 2016 at 04:00:00am</p></header><div class="content"><p>On Sun, Feb 14, 2016 at 2:51 AM, Mark Aron Szulyovszky via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Problem:<br>&gt; .prefix() works eagerly even on LazyCollectionType. This means access is not<br>&gt; O(1).<br>&gt;<br>&gt; Implications:<br>&gt; There&#39;s no way to only get the first N elements of a lazy sequence without a<br>&gt; nasty for loop. If prefix() used on a lazy sequence, it&#39;ll trigger<br>&gt; computation on the whole array, just to return the first N elements.<br>&gt;<br>&gt; Proposal:<br>&gt; It would be more more useful if lazy.&lt;insert methods here&gt;.prefix() returned<br>&gt; LazyPrefixCollection&lt;Generator.Element&gt;<br>&gt; instead of<br>&gt; Slice&lt;LazyCustomCollection&lt;Range&lt;Generator.Element&gt;&gt;&gt;.<br></p><p>Thanks, Mark!<br></p><p>I think this would be a good addition for forward and bidirectional<br>collections.  You&#39;d need two separate implementations for forward and<br>bidirectional wrappers.<br></p><p>For random-access collections, the eager implementation is optimal<br>(finding the end index runs in O(1) and Slice&lt;&gt; does not introduce any<br>constant factor compared to non-trivial wrappers), and we should keep<br>that behavior by adding an overload that would return a<br>LazyCollection&lt;Slice&lt;Base&gt;&gt;.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Prosposal: LazyCollectionType.prefix() to return a lazy collection</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 21, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sun, Feb 14, 2016 at 4:12 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; On Sun, Feb 14, 2016 at 2:51 AM, Mark Aron Szulyovszky via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Problem:<br>&gt;&gt; .prefix() works eagerly even on LazyCollectionType. This means access is not<br>&gt;&gt; O(1).<br>&gt;&gt;<br>&gt;&gt; Implications:<br>&gt;&gt; There&#39;s no way to only get the first N elements of a lazy sequence without a<br>&gt;&gt; nasty for loop. If prefix() used on a lazy sequence, it&#39;ll trigger<br>&gt;&gt; computation on the whole array, just to return the first N elements.<br>&gt;&gt;<br>&gt;&gt; Proposal:<br>&gt;&gt; It would be more more useful if lazy.&lt;insert methods here&gt;.prefix() returned<br>&gt;&gt; LazyPrefixCollection&lt;Generator.Element&gt;<br>&gt;&gt; instead of<br>&gt;&gt; Slice&lt;LazyCustomCollection&lt;Range&lt;Generator.Element&gt;&gt;&gt;.<br>&gt;<br>&gt; Thanks, Mark!<br>&gt;<br>&gt; I think this would be a good addition for forward and bidirectional<br>&gt; collections.  You&#39;d need two separate implementations for forward and<br>&gt; bidirectional wrappers.<br>&gt;<br>&gt; For random-access collections, the eager implementation is optimal<br>&gt; (finding the end index runs in O(1) and Slice&lt;&gt; does not introduce any<br>&gt; constant factor compared to non-trivial wrappers), and we should keep<br>&gt; that behavior by adding an overload that would return a<br>&gt; LazyCollection&lt;Slice&lt;Base&gt;&gt;.<br></p><p>Hi Mark,<br></p><p>I think you can continue with writing a formal proposal in the<br>swift-evolution repository, presenting the full API that you are<br>proposing.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2f61fa79919d9b1dc352f4ed16724f03?s=50"></div><header><strong>Prosposal: LazyCollectionType.prefix() to return a lazy collection</strong> from <string>Mark Aron Szulyovszky</string> &lt;mark.szulyovszky at gmail.com&gt;<p>February 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Dmitri,<br></p><p>Cool, thanks, it&#39;s in the making! Sorry I was really busy this week.<br></p><p>Can you tell me why is it required to have different implementation for<br>Forward and Bidirectional LazyCollectionTypes?<br></p><p>Otherwise it&#39;s all clear!<br></p><p>Thanks a lot!<br></p><p>Cheers,<br></p><p>Mark<br></p><p>On Mon, 22 Feb 2016 at 02:55 Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Sun, Feb 14, 2016 at 4:12 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; On Sun, Feb 14, 2016 at 2:51 AM, Mark Aron Szulyovszky via<br>&gt; &gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Problem:<br>&gt; &gt;&gt; .prefix() works eagerly even on LazyCollectionType. This means access<br>&gt; is not<br>&gt; &gt;&gt; O(1).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Implications:<br>&gt; &gt;&gt; There&#39;s no way to only get the first N elements of a lazy sequence<br>&gt; without a<br>&gt; &gt;&gt; nasty for loop. If prefix() used on a lazy sequence, it&#39;ll trigger<br>&gt; &gt;&gt; computation on the whole array, just to return the first N elements.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Proposal:<br>&gt; &gt;&gt; It would be more more useful if lazy.&lt;insert methods here&gt;.prefix()<br>&gt; returned<br>&gt; &gt;&gt; LazyPrefixCollection&lt;Generator.Element&gt;<br>&gt; &gt;&gt; instead of<br>&gt; &gt;&gt; Slice&lt;LazyCustomCollection&lt;Range&lt;Generator.Element&gt;&gt;&gt;.<br>&gt; &gt;<br>&gt; &gt; Thanks, Mark!<br>&gt; &gt;<br>&gt; &gt; I think this would be a good addition for forward and bidirectional<br>&gt; &gt; collections.  You&#39;d need two separate implementations for forward and<br>&gt; &gt; bidirectional wrappers.<br>&gt; &gt;<br>&gt; &gt; For random-access collections, the eager implementation is optimal<br>&gt; &gt; (finding the end index runs in O(1) and Slice&lt;&gt; does not introduce any<br>&gt; &gt; constant factor compared to non-trivial wrappers), and we should keep<br>&gt; &gt; that behavior by adding an overload that would return a<br>&gt; &gt; LazyCollection&lt;Slice&lt;Base&gt;&gt;.<br>&gt;<br>&gt; Hi Mark,<br>&gt;<br>&gt; I think you can continue with writing a formal proposal in the<br>&gt; swift-evolution repository, presenting the full API that you are<br>&gt; proposing.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/83559eff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Prosposal: LazyCollectionType.prefix() to return a lazy collection</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sun, Feb 28, 2016 at 5:36 AM, Mark Aron Szulyovszky<br>&lt;mark.szulyovszky at gmail.com&gt; wrote:<br>&gt; Hi Dmitri,<br>&gt;<br>&gt; Cool, thanks, it&#39;s in the making! Sorry I was really busy this week.<br>&gt;<br>&gt; Can you tell me why is it required to have different implementation for<br>&gt; Forward and Bidirectional LazyCollectionTypes?<br></p><p>Hi Mark,<br></p><p>The reason to have different implementations is so that a result of<br>applying prefix() to a bidirectional collection is also a<br>bidirectional collection.  If we had just one lazy wrapper, the result<br>of prefix() would always be a forward collection.  You might also need<br>to do the same for random access, I haven&#39;t thought it through well<br>enough to say if it would certainly be needed.  But we want<br>xs.lazy.prefix() to preserve the collection category (forward,<br>bidirectional, random access) in the result.<br></p><p>Creating multiple types wouldn&#39;t be needed if we had a generics<br>feature that we don&#39;t have now -- conditional protocol conformances.<br>We want that, and will eventually have it, but for now, we have to go<br>with multiple types.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
