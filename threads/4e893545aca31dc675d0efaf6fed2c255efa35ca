<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi.<br></p><p>The solutions discussed so far have the following disadvantages:<br>  - They need a specific delimiter token, which cannot be used in the text itself.<br>  - The data cannot be used as-is, escape \ characters are needed.<br>  - Imho, they are somewhat complicated. <br></p><p>In my emails previously submitted I came up with a &quot;data line” concept,<br>a very simple solution, which tackles these disadvantages and is<br>very easy to use and understand!<br></p><p>Did you actually read it? <br>I now quote the primary description hereunder again, in case you’ve missed it,<br>imaginable, because there is a lot of text flying around.<br></p><p>Additionally, the following improvements have developed in my thinking: <br></p><p>In the mean time I consider using two tokens   \\ and \@:  <br>    \\…data…data…data…data…………..   accepts data and converts \n \t etc.<br>or data lines starting with: <br>    \@…data…data…data…data… .…….  accepts data as-is, without conversion and <br>                         respects the linefeeds of the source-file.<br></p><p>the // and /@ tokens do not have to start at the beginning of a line, <br>are allowed further to the right as long as there are only space(s) to the<br>left of it.<br></p><p>let music =<br>\\when Doves Cry\nBy Prince and<br>\\ The Revolution\nWhat music<br>\\  can be\t\t\t\tIt is \”Magic\” really.<br> <br>If you do or don’t like this solution <br>-apart from cosmetic viewpoints-<br>please tell me why. so I can improve it,<br>or try to come back with something better if i can.<br></p><p>let epilogue =<br>\@Thank you so much for reading my<br>\@ “contribution&quot;  Please tell me <br>\@what you think, I \\\\\\\\\\\\\value//////////// your opinion!<br>\@“””””””””””””””””””””” kind Regards! “”””””””””””””””&quot;<br>\@ Ted. <br></p><p><br>(the previous text following \@ data lines are accepted as-is, including <br>the source-file’s linefeeds or crlf and the double quotes) <br></p><p>Of course, other tokens are possible as well. <br></p><p>Can’t be any simpler than this, I guess.<br></p><p>TedvG<br></p><p>===================As Previously Written:=================<br></p><p>This could be a simple solution: <br></p><p>Starting each line with a special token.<br></p><p>In the example here it is the \\  double-backslash .  <br>when the \\ appears in the first two columns of a source line, <br>this tells the compiler that it is a data line and that more might follow.<br>the last line starting with \\ completes the data entry.<br></p><p>Here is an example of a string declaration with some XML<br>(no escape sequences needed for “) <br>Of course it could be anything other kind of textual data as well.<br></p><p>let  str =  <br>\\&lt;!DOCTYPE html&gt;<br>\\&lt;html&gt;<br>\\&lt;body&gt;<br>\\<br>\\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>\\&lt;div&gt;<br>\\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>\\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>\\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>\\&lt;/div&gt;<br>\\\n<br>\\&lt;script&gt;<br>\\var &lt;smb://var&gt; txt, parser, xmlDoc;<br>\\txt &lt;smb://txt&gt; = &quot;&lt;note&gt;&quot; +<br>\\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>\\etc &lt;smb://etc&gt;. this is the last data line.<br></p><p><br>Conditions: <br></p><p>- Every line starting with \\ in first and second column of the line <br>  is  treated as a data line.<br>- All characters behind the \\ are regarded as data, thus note that:<br>     - the “ is not regarded as a string delimiter<br>     - the // chars and whatever follows it are interpreted as data on such a line, not as comment.<br>     -  \\  within the data itself are treated as data e.g. this line is valid:<br>\\There &lt;smb://There&gt; \\ are three backslashes (as data) in this line \\\\ today.<br>\\<br>the above data line is empty but is allowed. <br>for \\<br>- Leading and embedded spaces are respected.<br>- Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc. <br>- trailing spaces and line terminators cr lf are ignored, filtered out.<br></p><p><br>============================================================<br></p><p><br></p><p> Wed, 27 Apr 2016 16:08:13 +0300&quot;Vladimir.S&quot; &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; On 27.04.2016 11:52, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as<br>&gt;&gt;&gt; such: I’d suggest that you provide a proposal that just tackles the<br>&gt;&gt;&gt; continuation string literals.  This seems simple, and possible to get in<br>&gt;&gt;&gt; for Swift 3.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and<br>&gt;&gt; adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed<br>&gt;&gt; and what concerns I have.<br>&gt; <br>&gt; I don&#39;t feel like this proposal(draft) solves the issue we want(?) to solve <br>&gt; with multi-line feature.<br>&gt; <br>&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source <br>&gt; file. No escaping, no interpolation, etc. I believe this should be a target <br>&gt; of the proposal.<br>&gt; Otherwise, I reject to see any reason to introduce anything new at this <br>&gt; area - we already can concatenate strings and place them on next line and <br>&gt; escape special characters.<br>&gt; <br>&gt; In your proposal, you have to escape characters in your text, you need to <br>&gt; carefully modify the copy-pasted text to be allowed as correct multi-line <br>&gt; string. Also, what if I need to have spaces *at the end of string* ? Editor <br>&gt; can just trimmed them, and we can&#39;t clearly see them.<br>&gt; <br>&gt; Personally I need to be able to have this(in some way) in my code:<br>&gt; (note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to have <br>&gt; inside my xml)<br>&gt; <br>&gt; let xml = ... // some marker to start the multi-line str<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; ... // some marker here to stop multi-line str<br>&gt; <br>&gt; It seems like we need some markers for end-of-the-line to be able to keep <br>&gt; spaces/tabs in the end of line.<br>&gt; <br>&gt; What about something like this. Two suported variants : first when we need <br>&gt; to keep spaces in the end of line, and second when we don&#39;t need <br>&gt; spaced(will be trimmed by parser)<br>&gt; <br>&gt; #1 (parser should just take the text between first and last quote *as-is*)<br>&gt; <br>&gt; let xml = &quot;\<br>&gt; &quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&gt; &quot;&lt;catalog&gt;&quot;<br>&gt; &quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&gt; &quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&gt; &quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&gt; &quot;    &lt;/book&gt;&quot;<br>&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt; &quot;<br>&gt; <br>&gt; #2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t care):<br>&gt; (parser takes all that is after | as-is but trims any trailing spaces/tabs <br>&gt; in lines to be clear in behaviour)<br>&gt; <br>&gt; let xml = &quot;\<br>&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; |&lt;catalog&gt;<br>&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt; |    &lt;/book&gt;<br>&gt; |&lt;/catalog&gt;<br>&gt; &quot;<br>&gt; <br>&gt; Or these two could be combined in one(as-is between |..|) but I&#39;m not sure:<br>&gt; <br>&gt; let xml = &quot;\<br>&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>&gt; |&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;|<br>&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>&gt; |    &lt;/book&gt;|<br>&gt; |&lt;/catalog&gt;|<br>&gt; &quot;<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  Multiline string literals<br>&gt;&gt; <br>&gt;&gt;  * Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;&gt;<br>&gt;&gt;  * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax &lt;https://github.com/brentdax&gt;&gt;<br>&gt;&gt;  * Status: First Draft<br>&gt;&gt;  * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt;&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt;&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt;&gt; punctuation which is a straightforward extension of our existing string<br>&gt;&gt; literals.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: multi-line string literals.<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;&gt;Draft<br>&gt;&gt;    Notes<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    This draft differs from the prototypes being thrown around on the list<br>&gt;&gt;    in that it specifies that comments should be treated as whitespace, and<br>&gt;&gt;    that whitespace-only lines in the middle of a multiline string should<br>&gt;&gt;    be ignored. I&#39;m not sure if this is feasible from a parsing standpoint,<br>&gt;&gt;    and I&#39;d like feedback from implementers on this point.<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    This draft also specifies diagnostics which should be included.<br>&gt;&gt;    Feedback on whether these are good choices would be welcome.<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    I am considering allowing you to put a backslash before the newline to<br>&gt;&gt;    indicate it should /not/ be included in the literal. In other words,<br>&gt;&gt;    this code:<br>&gt;&gt; <br>&gt;&gt;    print(&quot;foo\<br>&gt;&gt;    &quot;bar&quot;)<br>&gt;&gt; <br>&gt;&gt;    Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;&gt;    proposed separately, because there may be a better way to do it.<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    I&#39;ve listed only myself as an author because I don&#39;t want to put anyone<br>&gt;&gt;    else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;&gt;    deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;&gt;    think you should be included.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; As Swift begins to move into roles beyond app development, code which needs<br>&gt;&gt; to generate text becomes a more important use case. Consider, for instance,<br>&gt;&gt; generating even a small XML string:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt; <br>&gt;&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt;&gt; run-together characters; it looks like little more than line noise. We can<br>&gt;&gt; improve its readability somewhat by concatenating separate strings for each<br>&gt;&gt; line and using real tabs instead of |\t| escapes:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;          &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;          &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;          &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;          &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; <br>&gt;&gt; However, this creates a more complex expression for the type checker, and<br>&gt;&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt;&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt;&gt; far short of that goal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;&gt;Proposed<br>&gt;&gt;    solution<br>&gt;&gt; <br>&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt;&gt; end of the line without encountering an end quote, it should look at the<br>&gt;&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt;&gt; string literal contains a newline and then continues on that line.<br>&gt;&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt; <br>&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; &quot;&lt;catalog&gt;<br>&gt;&gt;          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;          &quot; &lt;/book&gt;<br>&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; <br>&gt;&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt;&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;&gt; <br>&gt;&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt;&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt;&gt; prose. As an English Stack Exchange answer illustrates<br>&gt;&gt; &lt;http://english.stackexchange.com/a/96613/64636 &lt;http://english.stackexchange.com/a/96613/64636&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;    “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt;    would there be in using quotation marks at the end of every paragraph?”<br>&gt;&gt; <br>&gt;&gt;    “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt;    quotes at the end of every paragraph, then you would need to reidentify<br>&gt;&gt;    the speaker with every subsequent paragraph.<br>&gt;&gt; <br>&gt;&gt;    “Say a narrative was describing two or three people engaged in a<br>&gt;&gt;    lengthy conversation. If you closed the quotation marks in the previous<br>&gt;&gt;    paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;&gt;    previous speaker was extending his point, or if someone else in the<br>&gt;&gt;    room had picked up the conversation. By leaving the previous<br>&gt;&gt;    paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;&gt;    is still the one talking.”<br>&gt;&gt; <br>&gt;&gt;    “Oh, that makes sense. Thanks!”<br>&gt;&gt; <br>&gt;&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and<br>&gt;&gt; compiler) that the literal continues on the next line, while including the<br>&gt;&gt; continuation quote reminds the reader (and compiler) that this line is part<br>&gt;&gt; of a string literal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes&gt;&gt;Benefits<br>&gt;&gt;      of continuation quotes<br>&gt;&gt; <br>&gt;&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt;&gt; required by this proposal? There are three reasons:<br>&gt;&gt; <br>&gt;&gt; 1.<br>&gt;&gt; <br>&gt;&gt;    *They help the compiler pinpoint errors in string literal<br>&gt;&gt;    delimiting.* If continuation quotes were not required, then a missing<br>&gt;&gt;    end quote would be interpreted as a multiline string literal. This<br>&gt;&gt;    string literal would continue until the compiler encountered either<br>&gt;&gt;    another quote mark—perhaps at the site of another string literal or in<br>&gt;&gt;    a comment—or the end of the file. In either case, the compiler could at<br>&gt;&gt;    best only indicate the start of the runaway string literal; in<br>&gt;&gt;    pathological cases (for instance, if the next string literal<br>&gt;&gt;    was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;&gt; <br>&gt;&gt;    With continuation quotes required, if you forget to include an end<br>&gt;&gt;    quote, the compiler can tell that you did not intend to create a<br>&gt;&gt;    multiline string and flag the line that actually has the problem. It<br>&gt;&gt;    can also provide immediately actionable fix-it assistance. The fact<br>&gt;&gt;    that there is a redundant indication on each line of the programmer&#39;s<br>&gt;&gt;    intent to include that line in a multiline quote allows the compiler to<br>&gt;&gt;    guess the meaning of the code.<br>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt; <br>&gt;&gt;    *They separate indentation from the string&#39;s contents.* Without<br>&gt;&gt;    continuation quotes, there would be no obvious indication of whether<br>&gt;&gt;    whitespace at the start of the line was intended to indent the string<br>&gt;&gt;    literal so it matched the surrounding code, or whether that whitespace<br>&gt;&gt;    was actually meant to be included in the resulting string. Multiline<br>&gt;&gt;    string literals would either have to put subsequent lines against the<br>&gt;&gt;    left margin, or apply error-prone heuristics to try to guess which<br>&gt;&gt;    whitespace was indentation and which was string literal content.<br>&gt;&gt; <br>&gt;&gt; 3.<br>&gt;&gt; <br>&gt;&gt;    *They improve the ability to quickly recognize the literal.* The |&quot;| on<br>&gt;&gt;    each line serves as an immediately obvious indication that the line is<br>&gt;&gt;    part of a string literal, not code, and the row of |&quot;| characters in a<br>&gt;&gt;    well-formatted file allows you to quickly scan up and down the file to<br>&gt;&gt;    see the extent of the literal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;&gt;Detailed<br>&gt;&gt;    design<br>&gt;&gt; <br>&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt; without finding a closing quote, it examines the next line, applying the<br>&gt;&gt; following rules:<br>&gt;&gt; <br>&gt;&gt; 1.<br>&gt;&gt; <br>&gt;&gt;    If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;&gt;    the line afterward, applying these rules again.<br>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt; <br>&gt;&gt;    If the next line begins with whitespace followed by a continuation<br>&gt;&gt;    quote, then the string literal contains a newline followed by the<br>&gt;&gt;    contents of the string literal starting on that line. (This line may<br>&gt;&gt;    itself have no closing quote, in which case the same rules apply to the<br>&gt;&gt;    line which follows.)<br>&gt;&gt; <br>&gt;&gt; 3.<br>&gt;&gt; <br>&gt;&gt;    If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt;    for an unterminated string literal. This syntax error should offer two<br>&gt;&gt;    fix-its: one to close the string literal at the end of the current<br>&gt;&gt;    line, and one to include the next line in the string literal by<br>&gt;&gt;    inserting a continuation quote.<br>&gt;&gt; <br>&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt;&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt;&gt; (However, commenting out the last line of the string literal will still<br>&gt;&gt; make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;&gt;Impact<br>&gt;&gt;    on existing code<br>&gt;&gt; <br>&gt;&gt; Failing to close a string literal before the end of the line is currently a<br>&gt;&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;&gt;Alternatives<br>&gt;&gt;    considered<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;&gt;Requiring<br>&gt;&gt;      no continuation character<br>&gt;&gt; <br>&gt;&gt; The main alternative is to not require a continuation quote, and simply<br>&gt;&gt; extend the string literal from the starting quote to the ending quote,<br>&gt;&gt; including all newlines between them. For example:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; <br>&gt;&gt; 1.<br>&gt;&gt; <br>&gt;&gt;    It is simpler.<br>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt; <br>&gt;&gt;    It is less offensive to programmers&#39; sensibilities (since there are no<br>&gt;&gt;    unmatched |&quot;| characters).<br>&gt;&gt; <br>&gt;&gt; 3.<br>&gt;&gt; <br>&gt;&gt;    It does not require that you edit the string literal to insert a<br>&gt;&gt;    continuation quote in each line.<br>&gt;&gt; <br>&gt;&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt;&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt;&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt; <br>&gt;&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt;&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt;&gt; continuation quotes less burdensome, while also providing other<br>&gt;&gt; conveniences like automatic escaping. We believe the other two factors are<br>&gt;&gt; outweighed by the benefits of continuation quotes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;&gt;Use<br>&gt;&gt;      a different delimiter for multiline strings<br>&gt;&gt; <br>&gt;&gt; The initial suggestion was that multiline strings should use a different<br>&gt;&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt;&gt; continuation characters between. This solution was rejected because it has<br>&gt;&gt; the same issues as the &quot;no continuation character&quot; solution, and because it<br>&gt;&gt; was mixing two orthogonal issues (multiline strings and alternate delimiters).<br>&gt;&gt; <br>&gt;&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt;&gt; to specify a placeholder string literal on one line whose content begins on<br>&gt;&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt;&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;&gt; <br>&gt;&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;        &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;    &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt; END<br>&gt;&gt; <br>&gt;&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt;&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt;&gt; current string syntax.<br>&gt;&gt; <br>&gt;&gt; Both of these suggestions address interesting issues with string literals,<br>&gt;&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt;&gt; specific issue at hand. We might consider them in the future to address<br>&gt;&gt; those problems to which they are better suited.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues&gt;&gt;Fixing<br>&gt;&gt;      other string literal readability issues<br>&gt;&gt; <br>&gt;&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt;&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    Reducing the amount of double-backslashing needed when working with<br>&gt;&gt;    regular expression libraries, Windows paths, source code generation,<br>&gt;&gt;    and other tasks where backslashes are part of the data.<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    Alternate delimiters or other strategies for writing strings<br>&gt;&gt;    with |&quot;| characters in them.<br>&gt;&gt; <br>&gt;&gt;  *<br>&gt;&gt; <br>&gt;&gt;    String literals consisting of very long pieces of text which are best<br>&gt;&gt;    represented completely verbatim.<br>&gt;&gt; <br>&gt;&gt; These are likely to be subjects of future proposals, though not necessarily<br>&gt;&gt; during Swift 3.<br>&gt;&gt; <br>&gt;&gt; This proposal also does not attempt to address regular expression literals.<br>&gt;&gt; The members of the core team who are interested in regular expression<br>&gt;&gt; support have ambitions for that feature which put it out of scope for Swift 3.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/4e8935ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 08:00:00am</p></header><div class="content"><p>Ted, please point me where in my suggestion you can find any of <br>disadvantages you point in your message?<br></p><p>let xml = &quot;\<br>|&lt;?xml version=&quot;1.0&quot;?&gt;<br>|&lt;catalog&gt;<br>|    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>|        &lt;author&gt;myAuthor&lt;/author&gt;<br>|        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>|    &lt;/book&gt;<br>|&lt;/catalog&gt;<br>&quot;<br></p><p>&quot;- They need a specific delimiter token, which cannot be used in the text<br>  itself.&quot;  - no such delimiter<br>&quot;- The data cannot be used as-is, escape \ characters are needed.&quot; - no <br>need, text is *as-is* (just with | at the start, and I believe I can prove <br>we need some start-of-line marker)<br>&quot;- Imho, they are somewhat complicated.&quot;  - ?? IMO clear and nice<br></p><p><br>On 27.04.2016 22:20, Ted F.A. van Gaalen wrote:<br>&gt; Hi.<br>&gt;<br>&gt; The solutions discussed so far have the following disadvantages:<br>&gt;   - They need a specific delimiter token, which cannot be used in the text<br>&gt; itself.<br>&gt;   - The data cannot be used as-is, escape \ characters are needed.<br>&gt;   - Imho, they are somewhat complicated.<br>&gt;<br>&gt; In my emails previously submitted I came up with a &quot;data line” concept,<br>&gt; a very simple solution, which tackles these disadvantages and is<br>&gt; very easy to use and understand!<br>&gt;<br>&gt; Did you actually read it?<br>&gt; I now quote the primary description hereunder again, in case you’ve missed it,<br>&gt; imaginable, because there is a lot of text flying around.<br>&gt;<br>&gt; Additionally, the following improvements have developed in my thinking:<br>&gt;<br>&gt; In the mean time I consider using two tokens   \\ and \@:<br>&gt;     \\…data…data…data…data<br>&gt; &lt;smb://%E2%80%A6data%E2%80%A6data%E2%80%A6data%E2%80%A6data&gt;…………..<br>&gt; accepts data and converts \n \t etc.<br>&gt; or data lines starting with:<br>&gt;     \@…data…data…data…data… .…….  accepts data as-is, without conversion and<br>&gt;                          respects the linefeeds of the source-file.<br>&gt;<br>&gt; the // and /@ tokens do not have to start at the beginning of a line,<br>&gt; are allowed further to the right as long as there are only space(s) to the<br>&gt; left of it.<br>&gt;<br>&gt; let music =<br>&gt; \\when &lt;smb://when&gt; Doves Cry\nBy Prince and<br>&gt; \\ The Revolution\nWhat music<br>&gt; \\  can be\t\t\t\tIt is \”Magic\” really.<br>&gt;<br>&gt; If you do or don’t like this solution<br>&gt; -apart from cosmetic viewpoints-<br>&gt; please tell me why. so I can improve it,<br>&gt; or try to come back with something better if i can.<br>&gt;<br>&gt; let epilogue =<br>&gt; \@Thank you so much for reading my<br>&gt; \@ “contribution&quot;  Please tell me<br>&gt; \@what you think, I \\\\\\\\\\\\\value//////////// your opinion!<br>&gt; \@“””””””””””””””””””””” kind Regards! “”””””””””””””””&quot;<br>&gt; \@ Ted.<br>&gt;<br>&gt;<br>&gt; (the previous text following \@ data lines are accepted as-is, including<br>&gt; the source-file’s linefeeds or crlf and the double quotes)<br>&gt;<br>&gt; Of course, other tokens are possible as well.<br>&gt;<br>&gt; Can’t be any simpler than this, I guess.<br>&gt;<br>&gt; TedvG<br>&gt;<br>&gt; ===================As Previously Written:=================<br>&gt;<br>&gt; This could be a simple solution:<br>&gt;<br>&gt; Starting each line with a special token.<br>&gt;<br>&gt; In the example here it is the \\  double-backslash .<br>&gt; when the \\ appears in the first two columns of a source line,<br>&gt; this tells the compiler that it is a data line and that more might follow.<br>&gt; the last line starting with \\ completes the data entry.<br>&gt;<br>&gt; Here is an example of a string declaration with some XML<br>&gt; (no escape sequences needed for “)<br>&gt; Of course it could be anything other kind of textual data as well.<br>&gt;<br>&gt; let  str =<br>&gt; \\&lt;!DOCTYPE html&gt;<br>&gt; \\&lt;html&gt;<br>&gt; \\&lt;body&gt;<br>&gt; \\<br>&gt; \\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>&gt; \\&lt;div&gt;<br>&gt; \\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt; \\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt; \\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>&gt; \\&lt;/div&gt;<br>&gt; \\\n<br>&gt; \\&lt;script&gt;<br>&gt; \\var &lt;smb://var&gt; txt, parser, xmlDoc;<br>&gt; \\txt &lt;smb://txt&gt; = &quot;&lt;note&gt;&quot; +<br>&gt; \\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>&gt; \\etc &lt;smb://etc&gt;. this is the last data line.<br>&gt;<br>&gt;<br>&gt; Conditions:<br>&gt;<br>&gt; - Every line starting with \\ in first and second column of the line<br>&gt;   is  treated as a data line.<br>&gt; - All characters behind the \\ are regarded as data, thus note that:<br>&gt;      - the “ is not regarded as a string delimiter<br>&gt;      - the // chars and whatever follows it are interpreted as data on such<br>&gt; a line, not as comment.<br>&gt;      -  \\  within the data itself are treated as data e.g. this line is valid:<br>&gt; \\There &lt;smb://There&gt; \\ are three backslashes (as data) in this line \\\\<br>&gt; today.<br>&gt; \\<br>&gt; the above data line is empty but is allowed.<br>&gt; for \\<br>&gt; - Leading and embedded spaces are respected.<br>&gt; - Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc.<br>&gt; - trailing spaces and line terminators cr lf are ignored, filtered out.<br>&gt;<br>&gt;<br>&gt; ============================================================<br>&gt;<br>&gt;<br>&gt;<br>&gt;  Wed, 27 Apr 2016 16:08:13 +0300&quot;Vladimir.S&quot; &lt;svabox at gmail.com<br>&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On 27.04.2016 11:52, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as<br>&gt;&gt;&gt;&gt; such: I’d suggest that you provide a proposal that just tackles the<br>&gt;&gt;&gt;&gt; continuation string literals.  This seems simple, and possible to get in<br>&gt;&gt;&gt;&gt; for Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and<br>&gt;&gt;&gt; adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed<br>&gt;&gt;&gt; and what concerns I have.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t feel like this proposal(draft) solves the issue we want(?) to solve<br>&gt;&gt; with multi-line feature.<br>&gt;&gt;<br>&gt;&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source<br>&gt;&gt; file. No escaping, no interpolation, etc. I believe this should be a target<br>&gt;&gt; of the proposal.<br>&gt;&gt; Otherwise, I reject to see any reason to introduce anything new at this<br>&gt;&gt; area - we already can concatenate strings and place them on next line and<br>&gt;&gt; escape special characters.<br>&gt;&gt;<br>&gt;&gt; In your proposal, you have to escape characters in your text, you need to<br>&gt;&gt; carefully modify the copy-pasted text to be allowed as correct multi-line<br>&gt;&gt; string. Also, what if I need to have spaces *at the end of string* ? Editor<br>&gt;&gt; can just trimmed them, and we can&#39;t clearly see them.<br>&gt;&gt;<br>&gt;&gt; Personally I need to be able to have this(in some way) in my code:<br>&gt;&gt; (note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to have<br>&gt;&gt; inside my xml)<br>&gt;&gt;<br>&gt;&gt; let xml = ... // some marker to start the multi-line str<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;         &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt;         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt;     &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt; ... // some marker here to stop multi-line str<br>&gt;&gt;<br>&gt;&gt; It seems like we need some markers for end-of-the-line to be able to keep<br>&gt;&gt; spaces/tabs in the end of line.<br>&gt;&gt;<br>&gt;&gt; What about something like this. Two suported variants : first when we need<br>&gt;&gt; to keep spaces in the end of line, and second when we don&#39;t need<br>&gt;&gt; spaced(will be trimmed by parser)<br>&gt;&gt;<br>&gt;&gt; #1 (parser should just take the text between first and last quote *as-is*)<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; &quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&gt;&gt; &quot;&lt;catalog&gt;&quot;<br>&gt;&gt; &quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&gt;&gt; &quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&gt;&gt; &quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&gt;&gt; &quot;    &lt;/book&gt;&quot;<br>&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt; #2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t<br>&gt;&gt; care):<br>&gt;&gt; (parser takes all that is after | as-is but trims any trailing spaces/tabs<br>&gt;&gt; in lines to be clear in behaviour)<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; |&lt;catalog&gt;<br>&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt; |    &lt;/book&gt;<br>&gt;&gt; |&lt;/catalog&gt;<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt; Or these two could be combined in one(as-is between |..|) but I&#39;m not sure:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>&gt;&gt; |&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;|<br>&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>&gt;&gt; |    &lt;/book&gt;|<br>&gt;&gt; |&lt;/catalog&gt;|<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Multiline string literals<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  * Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;  * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt;&gt;  * Status: First Draft<br>&gt;&gt;&gt;  * Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt;&gt;&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt;&gt;&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt;&gt;&gt; punctuation which is a straightforward extension of our existing string<br>&gt;&gt;&gt; literals.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: multi-line string literals.<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft<br>&gt;&gt;&gt;    Notes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    This draft differs from the prototypes being thrown around on the list<br>&gt;&gt;&gt;    in that it specifies that comments should be treated as whitespace, and<br>&gt;&gt;&gt;    that whitespace-only lines in the middle of a multiline string should<br>&gt;&gt;&gt;    be ignored. I&#39;m not sure if this is feasible from a parsing standpoint,<br>&gt;&gt;&gt;    and I&#39;d like feedback from implementers on this point.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    This draft also specifies diagnostics which should be included.<br>&gt;&gt;&gt;    Feedback on whether these are good choices would be welcome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    I am considering allowing you to put a backslash before the newline to<br>&gt;&gt;&gt;    indicate it should /not/ be included in the literal. In other words,<br>&gt;&gt;&gt;    this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    print(&quot;foo\<br>&gt;&gt;&gt;    &quot;bar&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;&gt;&gt;    proposed separately, because there may be a better way to do it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    I&#39;ve listed only myself as an author because I don&#39;t want to put anyone<br>&gt;&gt;&gt;    else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;&gt;&gt;    deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;&gt;&gt;    think you should be included.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As Swift begins to move into roles beyond app development, code which needs<br>&gt;&gt;&gt; to generate text becomes a more important use case. Consider, for instance,<br>&gt;&gt;&gt; generating even a small XML string:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt;&gt;&gt; run-together characters; it looks like little more than line noise. We can<br>&gt;&gt;&gt; improve its readability somewhat by concatenating separate strings for each<br>&gt;&gt;&gt; line and using real tabs instead of |\t| escapes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;&gt;          &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;&gt;          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;&gt;          &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;&gt;          &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;&gt;          &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this creates a more complex expression for the type checker, and<br>&gt;&gt;&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt;&gt;&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt;&gt;&gt; far short of that goal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;    solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt;&gt;&gt; end of the line without encountering an end quote, it should look at the<br>&gt;&gt;&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt;&gt;&gt; string literal contains a newline and then continues on that line.<br>&gt;&gt;&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt; &quot;&lt;catalog&gt;<br>&gt;&gt;&gt;          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;          &quot; &lt;/book&gt;<br>&gt;&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt;&gt;&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt;&gt;&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt;&gt;&gt; prose. As an English Stack Exchange answer illustrates<br>&gt;&gt;&gt; &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt;&gt;    would there be in using quotation marks at the end of every paragraph?”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt;&gt;    quotes at the end of every paragraph, then you would need to reidentify<br>&gt;&gt;&gt;    the speaker with every subsequent paragraph.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    “Say a narrative was describing two or three people engaged in a<br>&gt;&gt;&gt;    lengthy conversation. If you closed the quotation marks in the previous<br>&gt;&gt;&gt;    paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;&gt;&gt;    previous speaker was extending his point, or if someone else in the<br>&gt;&gt;&gt;    room had picked up the conversation. By leaving the previous<br>&gt;&gt;&gt;    paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;&gt;&gt;    is still the one talking.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    “Oh, that makes sense. Thanks!”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and<br>&gt;&gt;&gt; compiler) that the literal continues on the next line, while including the<br>&gt;&gt;&gt; continuation quote reminds the reader (and compiler) that this line is part<br>&gt;&gt;&gt; of a string literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes&gt;Benefits<br>&gt;&gt;&gt;      of continuation quotes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt;&gt;&gt; required by this proposal? There are three reasons:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    *They help the compiler pinpoint errors in string literal<br>&gt;&gt;&gt;    delimiting.* If continuation quotes were not required, then a missing<br>&gt;&gt;&gt;    end quote would be interpreted as a multiline string literal. This<br>&gt;&gt;&gt;    string literal would continue until the compiler encountered either<br>&gt;&gt;&gt;    another quote mark—perhaps at the site of another string literal or in<br>&gt;&gt;&gt;    a comment—or the end of the file. In either case, the compiler could at<br>&gt;&gt;&gt;    best only indicate the start of the runaway string literal; in<br>&gt;&gt;&gt;    pathological cases (for instance, if the next string literal<br>&gt;&gt;&gt;    was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    With continuation quotes required, if you forget to include an end<br>&gt;&gt;&gt;    quote, the compiler can tell that you did not intend to create a<br>&gt;&gt;&gt;    multiline string and flag the line that actually has the problem. It<br>&gt;&gt;&gt;    can also provide immediately actionable fix-it assistance. The fact<br>&gt;&gt;&gt;    that there is a redundant indication on each line of the programmer&#39;s<br>&gt;&gt;&gt;    intent to include that line in a multiline quote allows the compiler to<br>&gt;&gt;&gt;    guess the meaning of the code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    *They separate indentation from the string&#39;s contents.* Without<br>&gt;&gt;&gt;    continuation quotes, there would be no obvious indication of whether<br>&gt;&gt;&gt;    whitespace at the start of the line was intended to indent the string<br>&gt;&gt;&gt;    literal so it matched the surrounding code, or whether that whitespace<br>&gt;&gt;&gt;    was actually meant to be included in the resulting string. Multiline<br>&gt;&gt;&gt;    string literals would either have to put subsequent lines against the<br>&gt;&gt;&gt;    left margin, or apply error-prone heuristics to try to guess which<br>&gt;&gt;&gt;    whitespace was indentation and which was string literal content.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    *They improve the ability to quickly recognize the literal.* The |&quot;| on<br>&gt;&gt;&gt;    each line serves as an immediately obvious indication that the line is<br>&gt;&gt;&gt;    part of a string literal, not code, and the row of |&quot;| characters in a<br>&gt;&gt;&gt;    well-formatted file allows you to quickly scan up and down the file to<br>&gt;&gt;&gt;    see the extent of the literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed<br>&gt;&gt;&gt;    design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt;&gt; without finding a closing quote, it examines the next line, applying the<br>&gt;&gt;&gt; following rules:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;&gt;&gt;    the line afterward, applying these rules again.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    If the next line begins with whitespace followed by a continuation<br>&gt;&gt;&gt;    quote, then the string literal contains a newline followed by the<br>&gt;&gt;&gt;    contents of the string literal starting on that line. (This line may<br>&gt;&gt;&gt;    itself have no closing quote, in which case the same rules apply to the<br>&gt;&gt;&gt;    line which follows.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt;&gt;    for an unterminated string literal. This syntax error should offer two<br>&gt;&gt;&gt;    fix-its: one to close the string literal at the end of the current<br>&gt;&gt;&gt;    line, and one to include the next line in the string literal by<br>&gt;&gt;&gt;    inserting a continuation quote.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt;&gt;&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt;&gt;&gt; (However, commenting out the last line of the string literal will still<br>&gt;&gt;&gt; make it unterminated, so you don&#39;t have a completely free hand in<br>&gt;&gt;&gt; commenting.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;    on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Failing to close a string literal before the end of the line is currently a<br>&gt;&gt;&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;    considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring<br>&gt;&gt;&gt;      no continuation character<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main alternative is to not require a continuation quote, and simply<br>&gt;&gt;&gt; extend the string literal from the starting quote to the ending quote,<br>&gt;&gt;&gt; including all newlines between them. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    It is simpler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    It is less offensive to programmers&#39; sensibilities (since there are no<br>&gt;&gt;&gt;    unmatched |&quot;| characters).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    It does not require that you edit the string literal to insert a<br>&gt;&gt;&gt;    continuation quote in each line.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt;&gt;&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt;&gt;&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt;&gt;&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt;&gt;&gt; continuation quotes less burdensome, while also providing other<br>&gt;&gt;&gt; conveniences like automatic escaping. We believe the other two factors are<br>&gt;&gt;&gt; outweighed by the benefits of continuation quotes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use<br>&gt;&gt;&gt;      a different delimiter for multiline strings<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The initial suggestion was that multiline strings should use a different<br>&gt;&gt;&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt;&gt;&gt; continuation characters between. This solution was rejected because it has<br>&gt;&gt;&gt; the same issues as the &quot;no continuation character&quot; solution, and because it<br>&gt;&gt;&gt; was mixing two orthogonal issues (multiline strings and alternate<br>&gt;&gt;&gt; delimiters).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt;&gt;&gt; to specify a placeholder string literal on one line whose content begins on<br>&gt;&gt;&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt;&gt;&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;        &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;    &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt; END<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt;&gt;&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt;&gt;&gt; current string syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both of these suggestions address interesting issues with string literals,<br>&gt;&gt;&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt;&gt;&gt; specific issue at hand. We might consider them in the future to address<br>&gt;&gt;&gt; those problems to which they are better suited.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues&gt;Fixing<br>&gt;&gt;&gt;      other string literal readability issues<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt;&gt;&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Reducing the amount of double-backslashing needed when working with<br>&gt;&gt;&gt;    regular expression libraries, Windows paths, source code generation,<br>&gt;&gt;&gt;    and other tasks where backslashes are part of the data.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Alternate delimiters or other strategies for writing strings<br>&gt;&gt;&gt;    with |&quot;| characters in them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    String literals consisting of very long pieces of text which are best<br>&gt;&gt;&gt;    represented completely verbatim.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These are likely to be subjects of future proposals, though not necessarily<br>&gt;&gt;&gt; during Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal also does not attempt to address regular expression literals.<br>&gt;&gt;&gt; The members of the core team who are interested in regular expression<br>&gt;&gt;&gt; support have ambitions for that feature which put it out of scope for<br>&gt;&gt;&gt; Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
