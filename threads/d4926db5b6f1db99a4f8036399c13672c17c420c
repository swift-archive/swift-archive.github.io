<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br></p><p>Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br></p><p>The proposal drafts can be found at the following links:<br></p><p>* Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>* Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>* Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br></p><p>Matthew<br>Partial Initializers<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br></p><p>Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>Motivation<br></p><p>Partial initializers will make it much easier to factor out common initialization logic than it is today.<br></p><p>Memberwise initialization<br></p><p>Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br></p><p>The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br></p><p>Extensions with stored properties<br></p><p>Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br></p><p>John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br></p><p>Proposed solution<br></p><p>The proposed solution is to introduce a partial declaration modifier for initializers. <br></p><p>When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>Basic example<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC(i: Int = 10) {<br>    b = 10<br>    c = 20<br>  }<br>  init(i: Int) {<br>    a = i * 2<br>    d = i * 4<br>    bAndC.init()<br>  }<br>}<br>Calling multiple partial initializers<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC() {<br>    b = 10<br>    c = 20<br>  }<br>  partial init configureD(i: Int) {<br>    d = i * 4<br>  }<br>  init(i: Int) {<br>    configureD.init(i)<br>    a = i * 2<br>    bAndC.init()<br>  }<br>}<br>One partial init calling another<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC() {<br>    b = 10<br>    c = 20<br>  }<br>  partial init bcAndD(i: Int) {<br>    d = i * 4<br>    bAndC.init()<br>  }<br>  init(i: Int) {<br>    a = i * 2<br>    bcAndD.init(i)<br>  }<br>}<br>Syntactic sugar for forwarding<br></p><p>It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br></p><p>Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br></p><p>Basic forwarding sugar example<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>    b = b<br>    c = c<br>  }<br>  <br>  // user writes<br>  init(i: Int, ...bAndC) {<br>    a = i * 2<br>    d = i * 4<br>  }<br>  <br>  // compiler synthesizes<br>  init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>    bAndC.init(b: b, cLabel: cLabel)<br>    a = i * 2<br>    d = i * 4<br>  }<br>  <br>  // equivalent to writing the following under the parameter forwarding proposal:<br>  // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>  // conflict with the name of the partial initializer itself<br>  init(i: Int, ...bAndCParams) {<br>    bAndC.init(...bAndCParams)<br>    a = i * 2<br>    d = i * 4<br>  }<br>}<br>Forwarding to more than one partial initializer<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>    b = b<br>    c = c<br>  }<br>  partial init aAndD(i: Int) {<br>    a = i * 10<br>    d = i * 100<br>  }<br>  <br>  // user writes<br>  init(...aAndD, ...bAndC) {}<br>  <br>  // compiler synthesizes<br>  init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>    aAndD.init(i: Int)<br>    bAndC.init(b: b, cLabel: cLabel)<br>  }<br>  <br>  // equivalent to writing the following under the parameter forwarding proposal:<br>  // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>  // conflict with the name of the partial initializer itself<br>  init(...aAndDParams, ...bAndCParams) {<br>    aAndD.init(...aAndDParams)<br>    bAndC.init(...bAndCParams)<br>  }<br>}<br>One partial initizer forwarding to another<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>    b = b<br>    c = c<br>  }<br>  <br>  // user writes<br>  partial init abAndC(...bAndC) {<br>    a = 42<br>  }<br>  <br>  // compiler synthesizes<br>  partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>    bAndC.init(b: b, c: c)<br>    a = 42<br>  }<br>  <br>  // equivalent to writing the following under the parameter forwarding proposal:<br>  // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>  // conflict with the name of the partial initializer itself<br>  partial init abAndC(i: Int, ...bAndCParams) {<br>    bAndC.init(...bAndCParams)<br>    a = 42<br>  }<br>}<br>Forwarding to super<br></p><p>If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br></p><p>class Base {<br>  init(i: Int, s: String, f: Float) {}<br>}<br></p><p>class Derived: Base {<br>  let d: Double<br>  <br>  // user writes<br>  init(...super) {<br>    d = 42<br>  }<br>  <br>  // compiler synthesizes<br>  init(i: Int, s: String, f: Float) {<br>    d = 42<br>    super.init(i: i, s: s, f: f)<br>  }<br>  <br>  // equivalent to writing the following under the parameter forwarding proposal:<br>  init(...superParams) {<br>    d = 42<br>    super.init(...superParams)<br>  }<br>}<br>If super contains more than one initializer<br></p><p>struct S {<br>  let i: Int, s: String, f: Float<br>}<br></p><p>class Base {<br>  init(s: S) {}<br>  init(i: Int, s: String, f: Float) {}<br>}<br></p><p>class Derived: Base {<br>  let d: Double = 42<br>  // error: ambiguous forward to super<br>  init(...super) {} <br>}<br>Implicit partial initializers<br></p><p>Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br></p><p>  // flexibile memberwise initialization proposal:<br>  public memberwise init(...) {<br>    // init all private an internal props<br>  }<br>  // corresponding syntax using implicit partial init and forwarding:<br>  public init(...publicMemberwise) {<br>    // init all private an internal props<br>  }<br>  <br>  // flexibile memberwise initialization proposal:<br>  memberwise init(...) {<br>    // init all private props<br>  }<br>  // corresponding syntax using implicit partial init and forwarding:<br>  init(...internalMemberwise) {<br>    // init all private props<br>  }<br>  <br>  // flexibile memberwise initialization proposal:<br>  private memberwise init(...) {}<br>  // corresponding syntax using implicit partial init and forwarding:<br>  private init(...privateMemberwise) {}<br>Detailed design<br></p><p>TODO but should fall out pretty clearly from the proposed solution<br></p><p>Impact on existing code<br></p><p>This is a strictly additive change. It has no impact on existing code.<br></p><p>Alternatives considered<br></p><p>I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br></p><p>The syntax for declaring and invoking partial initializers is game for bikeshedding.<br></p><p>Members computed tuple property<br></p><p>Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br></p><p>There are a few problems with the members computed tuple approach:<br></p><p>It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>The question of how to expose default property values in initializer parameters was never answered.<br>The question of how to provide memberwise initialization for a subset of properties was never answered.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/d492420c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt; <br>&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt; <br>&gt; The proposal drafts can be found at the following links:<br>&gt; <br>&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt; <br>&gt; Matthew<br>&gt; Partial Initializers<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt; <br>&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt; <br>&gt; Memberwise initialization<br>&gt; <br>&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt; <br>&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt; <br>&gt; Extensions with stored properties<br>&gt; <br>&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt; <br>&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt; <br>&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br>&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br>&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br>&gt; Basic example<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC(i: Int = 10) {<br>&gt;     b = 10<br>&gt;     c = 20<br>&gt;   }<br>&gt;   init(i: Int) {<br>&gt;     a = i * 2<br>&gt;     d = i * 4<br>&gt;     bAndC.init()<br>&gt;   }<br>&gt; }<br>Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br></p><p>John.<br></p><p>&gt; Calling multiple partial initializers<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC() {<br>&gt;     b = 10<br>&gt;     c = 20<br>&gt;   }<br>&gt;   partial init configureD(i: Int) {<br>&gt;     d = i * 4<br>&gt;   }<br>&gt;   init(i: Int) {<br>&gt;     configureD.init(i)<br>&gt;     a = i * 2<br>&gt;     bAndC.init()<br>&gt;   }<br>&gt; }<br>&gt; One partial init calling another<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC() {<br>&gt;     b = 10<br>&gt;     c = 20<br>&gt;   }<br>&gt;   partial init bcAndD(i: Int) {<br>&gt;     d = i * 4<br>&gt;     bAndC.init()<br>&gt;   }<br>&gt;   init(i: Int) {<br>&gt;     a = i * 2<br>&gt;     bcAndD.init(i)<br>&gt;   }<br>&gt; }<br>&gt; Syntactic sugar for forwarding<br>&gt; <br>&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt; <br>&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt; <br>&gt; Basic forwarding sugar example<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;     b = b<br>&gt;     c = c<br>&gt;   }<br>&gt;   <br>&gt;   // user writes<br>&gt;   init(i: Int, ...bAndC) {<br>&gt;     a = i * 2<br>&gt;     d = i * 4<br>&gt;   }<br>&gt;   <br>&gt;   // compiler synthesizes<br>&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;     a = i * 2<br>&gt;     d = i * 4<br>&gt;   }<br>&gt;   <br>&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;   // conflict with the name of the partial initializer itself<br>&gt;   init(i: Int, ...bAndCParams) {<br>&gt;     bAndC.init(...bAndCParams)<br>&gt;     a = i * 2<br>&gt;     d = i * 4<br>&gt;   }<br>&gt; }<br>&gt; Forwarding to more than one partial initializer<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;     b = b<br>&gt;     c = c<br>&gt;   }<br>&gt;   partial init aAndD(i: Int) {<br>&gt;     a = i * 10<br>&gt;     d = i * 100<br>&gt;   }<br>&gt;   <br>&gt;   // user writes<br>&gt;   init(...aAndD, ...bAndC) {}<br>&gt;   <br>&gt;   // compiler synthesizes<br>&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;     aAndD.init(i: Int)<br>&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;   }<br>&gt;   <br>&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;   // conflict with the name of the partial initializer itself<br>&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;     aAndD.init(...aAndDParams)<br>&gt;     bAndC.init(...bAndCParams)<br>&gt;   }<br>&gt; }<br>&gt; One partial initizer forwarding to another<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;     b = b<br>&gt;     c = c<br>&gt;   }<br>&gt;   <br>&gt;   // user writes<br>&gt;   partial init abAndC(...bAndC) {<br>&gt;     a = 42<br>&gt;   }<br>&gt;   <br>&gt;   // compiler synthesizes<br>&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;     bAndC.init(b: b, c: c)<br>&gt;     a = 42<br>&gt;   }<br>&gt;   <br>&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;   // conflict with the name of the partial initializer itself<br>&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;     bAndC.init(...bAndCParams)<br>&gt;     a = 42<br>&gt;   }<br>&gt; }<br>&gt; Forwarding to super<br>&gt; <br>&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt; <br>&gt; class Base {<br>&gt;   init(i: Int, s: String, f: Float) {}<br>&gt; }<br>&gt; <br>&gt; class Derived: Base {<br>&gt;   let d: Double<br>&gt;   <br>&gt;   // user writes<br>&gt;   init(...super) {<br>&gt;     d = 42<br>&gt;   }<br>&gt;   <br>&gt;   // compiler synthesizes<br>&gt;   init(i: Int, s: String, f: Float) {<br>&gt;     d = 42<br>&gt;     super.init(i: i, s: s, f: f)<br>&gt;   }<br>&gt;   <br>&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;   init(...superParams) {<br>&gt;     d = 42<br>&gt;     super.init(...superParams)<br>&gt;   }<br>&gt; }<br>&gt; If super contains more than one initializer<br>&gt; <br>&gt; struct S {<br>&gt;   let i: Int, s: String, f: Float<br>&gt; }<br>&gt; <br>&gt; class Base {<br>&gt;   init(s: S) {}<br>&gt;   init(i: Int, s: String, f: Float) {}<br>&gt; }<br>&gt; <br>&gt; class Derived: Base {<br>&gt;   let d: Double = 42<br>&gt;   // error: ambiguous forward to super<br>&gt;   init(...super) {} <br>&gt; }<br>&gt; Implicit partial initializers<br>&gt; <br>&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt; <br>&gt;   // flexibile memberwise initialization proposal:<br>&gt;   public memberwise init(...) {<br>&gt;     // init all private an internal props<br>&gt;   }<br>&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;   public init(...publicMemberwise) {<br>&gt;     // init all private an internal props<br>&gt;   }<br>&gt;   <br>&gt;   // flexibile memberwise initialization proposal:<br>&gt;   memberwise init(...) {<br>&gt;     // init all private props<br>&gt;   }<br>&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;   init(...internalMemberwise) {<br>&gt;     // init all private props<br>&gt;   }<br>&gt;   <br>&gt;   // flexibile memberwise initialization proposal:<br>&gt;   private memberwise init(...) {}<br>&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;   private init(...privateMemberwise) {}<br>&gt; Detailed design<br>&gt; <br>&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt; <br>&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt; <br>&gt; Members computed tuple property<br>&gt; <br>&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt; <br>&gt; There are a few problems with the members computed tuple approach:<br>&gt; <br>&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/29c36e6b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt; <br>&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt; <br>&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt; <br>&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; Partial Initializers<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt;&gt; <br>&gt;&gt; Memberwise initialization<br>&gt;&gt; <br>&gt;&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt;&gt; <br>&gt;&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt;&gt; <br>&gt;&gt; Extensions with stored properties<br>&gt;&gt; <br>&gt;&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt;&gt; <br>&gt;&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt;&gt; <br>&gt;&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt;&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt;&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt;&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt; That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br>&gt;&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt;&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>&gt; So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br></p><p>No, this proposal is just introducing the feature into the current language.  I consider introducing the class-extension use case to be part of a new proposal.  That said, if you felt like it should be introduced in this proposal (presumably along with stored properties in extensions) we could do that.<br></p><p>&gt;&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>&gt; Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br></p><p>Agree.  Detailed design is still open.  Here’s the basic idea:<br></p><p>1. A partial initializer can initialize any subset of stored properties.<br>2. A partial initializer can only read a property it initializes itself.<br>3. If an initializer initializes a `let` property it cannot call a partial initializer that also initializes that property.<br>4. After calling a partial initializer, the properties it initialized are considered initialized in the calling initializer as well.  They can be read from, etc.<br></p><p>Partial initializers themselves are not “checked” per-se.  The compiler would keep track of the properties they initialize and use that information when checking the calling initializer (for duplicate `let` assignments, complete initialization, etc).<br>&gt;&gt; Basic example<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC(i: Int = 10) {<br>&gt;&gt;     b = 10<br>&gt;&gt;     c = 20<br>&gt;&gt;   }<br>&gt;&gt;   init(i: Int) {<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     d = i * 4<br>&gt;&gt;     bAndC.init()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br></p><p>Agree.  It is a generally useful initialization feature and also paves the way for stored properties declared outside the main body of the type.<br></p><p>It combines really well with syntactic sugar to forward parameters directly from a primary to a partial initializer as well as sugar for concise declaration of trivial partial memberwise initializers.  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; Calling multiple partial initializers<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC() {<br>&gt;&gt;     b = 10<br>&gt;&gt;     c = 20<br>&gt;&gt;   }<br>&gt;&gt;   partial init configureD(i: Int) {<br>&gt;&gt;     d = i * 4<br>&gt;&gt;   }<br>&gt;&gt;   init(i: Int) {<br>&gt;&gt;     configureD.init(i)<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     bAndC.init()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; One partial init calling another<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC() {<br>&gt;&gt;     b = 10<br>&gt;&gt;     c = 20<br>&gt;&gt;   }<br>&gt;&gt;   partial init bcAndD(i: Int) {<br>&gt;&gt;     d = i * 4<br>&gt;&gt;     bAndC.init()<br>&gt;&gt;   }<br>&gt;&gt;   init(i: Int) {<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     bcAndD.init(i)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Syntactic sugar for forwarding<br>&gt;&gt; <br>&gt;&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt;&gt; <br>&gt;&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt;&gt; <br>&gt;&gt; Basic forwarding sugar example<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;     b = b<br>&gt;&gt;     c = c<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // user writes<br>&gt;&gt;   init(i: Int, ...bAndC) {<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     d = i * 4<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes<br>&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     d = i * 4<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;   init(i: Int, ...bAndCParams) {<br>&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;     a = i * 2<br>&gt;&gt;     d = i * 4<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Forwarding to more than one partial initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;     b = b<br>&gt;&gt;     c = c<br>&gt;&gt;   }<br>&gt;&gt;   partial init aAndD(i: Int) {<br>&gt;&gt;     a = i * 10<br>&gt;&gt;     d = i * 100<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // user writes<br>&gt;&gt;   init(...aAndD, ...bAndC) {}<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes<br>&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;     aAndD.init(i: Int)<br>&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;&gt;     aAndD.init(...aAndDParams)<br>&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; One partial initizer forwarding to another<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;     b = b<br>&gt;&gt;     c = c<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // user writes<br>&gt;&gt;   partial init abAndC(...bAndC) {<br>&gt;&gt;     a = 42<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes<br>&gt;&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;     bAndC.init(b: b, c: c)<br>&gt;&gt;     a = 42<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;     a = 42<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Forwarding to super<br>&gt;&gt; <br>&gt;&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;   let d: Double<br>&gt;&gt;   <br>&gt;&gt;   // user writes<br>&gt;&gt;   init(...super) {<br>&gt;&gt;     d = 42<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes<br>&gt;&gt;   init(i: Int, s: String, f: Float) {<br>&gt;&gt;     d = 42<br>&gt;&gt;     super.init(i: i, s: s, f: f)<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;   init(...superParams) {<br>&gt;&gt;     d = 42<br>&gt;&gt;     super.init(...superParams)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; If super contains more than one initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let i: Int, s: String, f: Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;   init(s: S) {}<br>&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;   let d: Double = 42<br>&gt;&gt;   // error: ambiguous forward to super<br>&gt;&gt;   init(...super) {} <br>&gt;&gt; }<br>&gt;&gt; Implicit partial initializers<br>&gt;&gt; <br>&gt;&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt;&gt; <br>&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;     // init all private an internal props<br>&gt;&gt;   }<br>&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;   public init(...publicMemberwise) {<br>&gt;&gt;     // init all private an internal props<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;   memberwise init(...) {<br>&gt;&gt;     // init all private props<br>&gt;&gt;   }<br>&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;   init(...internalMemberwise) {<br>&gt;&gt;     // init all private props<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;   private memberwise init(...) {}<br>&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;   private init(...privateMemberwise) {}<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt;&gt; <br>&gt;&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt;&gt; <br>&gt;&gt; Members computed tuple property<br>&gt;&gt; <br>&gt;&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt;&gt; <br>&gt;&gt; There are a few problems with the members computed tuple approach:<br>&gt;&gt; <br>&gt;&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt;&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt;&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/2b05eda4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 9:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jan 11, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; Partial Initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Memberwise initialization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions with stored properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt;&gt;&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt;&gt;&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt;&gt;&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt;&gt; That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br></p><p>What are the rules on this identifier?  Does it have to be unique, or can partial initializers also be overloaded?  What do you expect to do for extensions?<br>&gt;&gt;&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt;&gt;&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>&gt;&gt; So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br>&gt; <br>&gt; No, this proposal is just introducing the feature into the current language.  I consider introducing the class-extension use case to be part of a new proposal.  That said, if you felt like it should be introduced in this proposal (presumably along with stored properties in extensions) we could do that.<br></p><p>Oh, of course, you’re absolutely right.  That’s a reasonable approach, but understand that this is basically a completely different feature, in terms of both its expected uses and its implementation, from partial initialization of class extensions.  The only similarity is syntax.  It would abstractly be reasonable to independently decide that one of these features isn’t a good idea, isn’t worth the complexity, or is simply out of scope.<br></p><p>Also, I think it wouldn’t hurt for this proposal to be more explicit about how you expect it to interact with other proposals.  You say that it combines well with memberwise initializers; okay, I think I see where you’re going with that, but spell it out, please.  Similarly, a brief section outlining how you expect this to work with stored properties in extensions would not be out of place, and this line in particular should call out the fact that it will change if stored properties are added to other contexts.<br>&gt;&gt;&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>&gt;&gt; Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br>&gt; <br>&gt; Agree.  Detailed design is still open.  Here’s the basic idea:<br>&gt; <br>&gt; 1. A partial initializer can initialize any subset of stored properties.<br>&gt; 2. A partial initializer can only read a property it initializes itself.<br>&gt; 3. If an initializer initializes a `let` property it cannot call a partial initializer that also initializes that property.<br>&gt; 4. After calling a partial initializer, the properties it initialized are considered initialized in the calling initializer as well.  They can be read from, etc.<br>&gt; <br>&gt; Partial initializers themselves are not “checked” per-se.  The compiler would keep track of the properties they initialize and use that information when checking the calling initializer (for duplicate `let` assignments, complete initialization, etc).<br></p><p>Okay.  This requires a simple dependency-ordering pass among partial initializers, but that should be straightforward to do.<br></p><p>The model will be much simpler if you ban redundant assignments to ‘var’ properties as well.<br>&gt;&gt;&gt; Basic example<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC(i: Int = 10) {<br>&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br>&gt; <br>&gt; Agree.  It is a generally useful initialization feature and also paves the way for stored properties declared outside the main body of the type.<br>&gt; <br>&gt; It combines really well with syntactic sugar to forward parameters directly from a primary to a partial initializer as well as sugar for concise declaration of trivial partial memberwise initializers.<br></p><p>Sure.  I’m just asking you to spell it out.<br></p><p>John.<br></p><p>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; Calling multiple partial initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   partial init configureD(i: Int) {<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;     configureD.init(i)<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One partial init calling another<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   partial init bcAndD(i: Int) {<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     bcAndD.init(i)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Syntactic sugar for forwarding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basic forwarding sugar example<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;   init(i: Int, ...bAndC) {<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;   init(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Forwarding to more than one partial initializer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   partial init aAndD(i: Int) {<br>&gt;&gt;&gt;     a = i * 10<br>&gt;&gt;&gt;     d = i * 100<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;   init(...aAndD, ...bAndC) {}<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;     aAndD.init(i: Int)<br>&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;&gt;&gt;     aAndD.init(...aAndDParams)<br>&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; One partial initizer forwarding to another<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;   partial init abAndC(...bAndC) {<br>&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;     bAndC.init(b: b, c: c)<br>&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Forwarding to super<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;   let d: Double<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;   init(...super) {<br>&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {<br>&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;     super.init(i: i, s: s, f: f)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;   init(...superParams) {<br>&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;     super.init(...superParams)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If super contains more than one initializer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   let i: Int, s: String, f: Float<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;   init(s: S) {}<br>&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;   let d: Double = 42<br>&gt;&gt;&gt;   // error: ambiguous forward to super<br>&gt;&gt;&gt;   init(...super) {} <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Implicit partial initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;   public init(...publicMemberwise) {<br>&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;   memberwise init(...) {<br>&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;   init(...internalMemberwise) {<br>&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;   private memberwise init(...) {}<br>&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;   private init(...privateMemberwise) {}<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Members computed tuple property<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a few problems with the members computed tuple approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt;&gt;&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt;&gt;&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/7dfd6220/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 12:52 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 9:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jan 11, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; Partial Initializers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Memberwise initialization<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions with stored properties<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt;&gt;&gt;&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt;&gt;&gt;&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt;&gt;&gt;&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt;&gt;&gt; That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br>&gt; <br>&gt; What are the rules on this identifier?  Does it have to be unique, or can partial initializers also be overloaded?  What do you expect to do for extensions?<br></p><p>Good questions.  I could go either way on allowing overloads.  I suppose it makes sense to allow them since they are allowed pretty much everywhere else.  What do you think would be best?<br></p><p>For extensions I think it makes the most sense to require an identifier for extensions that include stored properties.  I think this makes it clear in the designated initializers for the type exactly which extension is getting initialized by a specific init call.<br></p><p>Class extensions could then have 3 kinds of initializers:<br></p><p>* designated initializers for the extension (must init all stored properties introduced in the extension)<br>* partial initializers for the extension (can init some, but not necessarily all stored properties introduced in the extension and are callable only by the extension designated initializers)<br>* convenience initializers for the class (we already have these)<br></p><p>Example:<br></p><p>extension MoreStuff MyClass {<br>  let a, b: Int<br>  partial init onlyA() {<br>    a = 44<br>  }<br>  init (i: Int) {<br>    a = i<br>    b = i * 2<br>  }<br>}<br></p><p>class MyClass {<br>  let x, y: Int<br>  init() {<br>    x = 2<br>    y = 2<br>    MoreStuff.init(44)<br>  }<br>}<br></p><p>If we allowed stored properties in struct extensions they would just define normal primary, delegating, or partial initializers, of course requiring visibility to any properties they initialize.  That said, I don’t think the plan is to support stored properties in struct extensions anyway.<br></p><p>If we allow stored properties in protocols conformed to within the same module as the type definition (as Chris and Doug are discussing) a similar syntax could be used in the designated initializers of the type to initialize the protocol storage: `ProtocolName.init(arg1, arg2, etc)`.<br>&gt;&gt;&gt;&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt;&gt;&gt;&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>&gt;&gt;&gt; So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br>&gt;&gt; <br>&gt;&gt; No, this proposal is just introducing the feature into the current language.  I consider introducing the class-extension use case to be part of a new proposal.  That said, if you felt like it should be introduced in this proposal (presumably along with stored properties in extensions) we could do that.<br>&gt; <br>&gt; Oh, of course, you’re absolutely right.  That’s a reasonable approach, but understand that this is basically a completely different feature, in terms of both its expected uses and its implementation, from partial initialization of class extensions.  The only similarity is syntax.  It would abstractly be reasonable to independently decide that one of these features isn’t a good idea, isn’t worth the complexity, or is simply out of scope.<br></p><p>Yes I agree that it is different and independent.  I thought the implementation might have some overlap but you obviously know better than I do about that!<br></p><p>&gt; <br>&gt; Also, I think it wouldn’t hurt for this proposal to be more explicit about how you expect it to interact with other proposals.  You say that it combines well with memberwise initializers; okay, I think I see where you’re going with that, but spell it out, please.  Similarly, a brief section outlining how you expect this to work with stored properties in extensions would not be out of place, and this line in particular should call out the fact that it will change if stored properties are added to other contexts.<br></p><p>It’s definitely not a complete proposal yet.  I just wanted to get the discussion going while the memberwise init proposal is under consideration.  I’ll be sure to to include the items you mention here.<br></p><p>&gt;&gt;&gt;&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>&gt;&gt;&gt; Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br>&gt;&gt; <br>&gt;&gt; Agree.  Detailed design is still open.  Here’s the basic idea:<br>&gt;&gt; <br>&gt;&gt; 1. A partial initializer can initialize any subset of stored properties.<br>&gt;&gt; 2. A partial initializer can only read a property it initializes itself.<br>&gt;&gt; 3. If an initializer initializes a `let` property it cannot call a partial initializer that also initializes that property.<br>&gt;&gt; 4. After calling a partial initializer, the properties it initialized are considered initialized in the calling initializer as well.  They can be read from, etc.<br>&gt;&gt; <br>&gt;&gt; Partial initializers themselves are not “checked” per-se.  The compiler would keep track of the properties they initialize and use that information when checking the calling initializer (for duplicate `let` assignments, complete initialization, etc).<br>&gt; <br>&gt; Okay.  This requires a simple dependency-ordering pass among partial initializers, but that should be straightforward to do.<br>&gt; <br>&gt; The model will be much simpler if you ban redundant assignments to ‘var’ properties as well.<br></p><p>I will be happy to do that if it makes implementation easier!  I don’t have any specific use cases in mind that would require allowing redundant assignments to `var` properties.  That can always be added later if necessary.<br></p><p>&gt;&gt;&gt;&gt; Basic example<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC(i: Int = 10) {<br>&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br>&gt;&gt; <br>&gt;&gt; Agree.  It is a generally useful initialization feature and also paves the way for stored properties declared outside the main body of the type.<br>&gt;&gt; <br>&gt;&gt; It combines really well with syntactic sugar to forward parameters directly from a primary to a partial initializer as well as sugar for concise declaration of trivial partial memberwise initializers.<br>&gt; <br>&gt; Sure.  I’m just asking you to spell it out.<br></p><p>Yep, will do.  I’ll be continuing to work on filling it out over the next few days.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Calling multiple partial initializers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   partial init configureD(i: Int) {<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;     configureD.init(i)<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; One partial init calling another<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   partial init bcAndD(i: Int) {<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     bcAndD.init(i)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Syntactic sugar for forwarding<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basic forwarding sugar example<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;   init(i: Int, ...bAndC) {<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;   init(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Forwarding to more than one partial initializer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   partial init aAndD(i: Int) {<br>&gt;&gt;&gt;&gt;     a = i * 10<br>&gt;&gt;&gt;&gt;     d = i * 100<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;   init(...aAndD, ...bAndC) {}<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;     aAndD.init(i: Int)<br>&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;     aAndD.init(...aAndDParams)<br>&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; One partial initizer forwarding to another<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;   partial init abAndC(...bAndC) {<br>&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;     bAndC.init(b: b, c: c)<br>&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Forwarding to super<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;   let d: Double<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;   init(...super) {<br>&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {<br>&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;     super.init(i: i, s: s, f: f)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;   init(...superParams) {<br>&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;     super.init(...superParams)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; If super contains more than one initializer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let i: Int, s: String, f: Float<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;   init(s: S) {}<br>&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;   let d: Double = 42<br>&gt;&gt;&gt;&gt;   // error: ambiguous forward to super<br>&gt;&gt;&gt;&gt;   init(...super) {} <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Implicit partial initializers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;   public init(...publicMemberwise) {<br>&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;   memberwise init(...) {<br>&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;   init(...internalMemberwise) {<br>&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;   private memberwise init(...) {}<br>&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;   private init(...privateMemberwise) {}<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Members computed tuple property<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a few problems with the members computed tuple approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt;&gt;&gt;&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt;&gt;&gt;&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e482b3a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 1:37 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jan 11, 2016, at 12:52 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 9:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; Partial Initializers<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Memberwise initialization<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Extensions with stored properties<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt;&gt;&gt;&gt;&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt;&gt;&gt;&gt;&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt;&gt;&gt;&gt;&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt;&gt;&gt;&gt; That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br>&gt;&gt; <br>&gt;&gt; What are the rules on this identifier?  Does it have to be unique, or can partial initializers also be overloaded?  What do you expect to do for extensions?<br>&gt; <br>&gt; Good questions.  I could go either way on allowing overloads.  I suppose it makes sense to allow them since they are allowed pretty much everywhere else.  What do you think would be best?<br></p><p>Your examples seem to lead towards them being overloadable: you would add a partial initializer for a cluster of properties, and then maybe there are multiple ways to initialize those properties.<br></p><p>&gt; For extensions I think it makes the most sense to require an identifier for extensions that include stored properties.  I think this makes it clear in the designated initializers for the type exactly which extension is getting initialized by a specific init call.<br>&gt; <br>&gt; Class extensions could then have 3 kinds of initializers:<br>&gt; <br>&gt; * designated initializers for the extension (must init all stored properties introduced in the extension)<br>&gt; * partial initializers for the extension (can init some, but not necessarily all stored properties introduced in the extension and are callable only by the extension designated initializers)<br>&gt; * convenience initializers for the class (we already have these)<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; extension MoreStuff MyClass {<br>&gt;   let a, b: Int<br>&gt;   partial init onlyA() {<br>&gt;     a = 44<br>&gt;   }<br>&gt;   init (i: Int) {<br>&gt;     a = i<br>&gt;     b = i * 2<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class MyClass {<br>&gt;   let x, y: Int<br>&gt;   init() {<br>&gt;     x = 2<br>&gt;     y = 2<br>&gt;     MoreStuff.init(44)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If we allowed stored properties in struct extensions they would just define normal primary, delegating, or partial initializers, of course requiring visibility to any properties they initialize.  That said, I don’t think the plan is to support stored properties in struct extensions anyway.<br>&gt; <br>&gt; If we allow stored properties in protocols conformed to within the same module as the type definition (as Chris and Doug are discussing) a similar syntax could be used in the designated initializers of the type to initialize the protocol storage: `ProtocolName.init(arg1, arg2, etc)`.<br></p><p>Hmm.  I’m not really comfortable with the idea of these partial initializers in extensions not being somehow marked as partial.  Without that, they look just like a designated initializer; and designated initializers in extensions are a plausible future language direction (they would, of course, have to peer-delegate to another designated initializer).<br></p><p>Maybe a better model would be to say that they’re still partial initializers, and you can only call a partial initializer for an extension from a designated initializer if the partial initializer is complete for its extension.  That restriction could be weekend over time if we wanted to.  On the flip side, that restriction is also consistent with not allowing incomplete partial initializers at all.<br>&gt;&gt;&gt;&gt;&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt;&gt;&gt;&gt;&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>&gt;&gt;&gt;&gt; So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, this proposal is just introducing the feature into the current language.  I consider introducing the class-extension use case to be part of a new proposal.  That said, if you felt like it should be introduced in this proposal (presumably along with stored properties in extensions) we could do that.<br>&gt;&gt; <br>&gt;&gt; Oh, of course, you’re absolutely right.  That’s a reasonable approach, but understand that this is basically a completely different feature, in terms of both its expected uses and its implementation, from partial initialization of class extensions.  The only similarity is syntax.  It would abstractly be reasonable to independently decide that one of these features isn’t a good idea, isn’t worth the complexity, or is simply out of scope.<br>&gt; <br>&gt; Yes I agree that it is different and independent.  I thought the implementation might have some overlap but you obviously know better than I do about that!<br></p><p>Maybe.  With only complete partial initializers, DI just needs to track that all extensions that declare partial initializers have a partial initializer called; it doesn’t necessarily even need to allow recursive partial initialization, so the logic is basically local.  With incomplete partial initializers, and especially with delegation between them, it gets significantly more complex.<br></p><p>Oh, you should add that partial initializers should not be allowed to fail.  That’s a liftable restriction in time, I think, but it cuts down on the initial complexity quite a bit.<br></p><p>John.<br></p><p>&gt;&gt; Also, I think it wouldn’t hurt for this proposal to be more explicit about how you expect it to interact with other proposals.  You say that it combines well with memberwise initializers; okay, I think I see where you’re going with that, but spell it out, please.  Similarly, a brief section outlining how you expect this to work with stored properties in extensions would not be out of place, and this line in particular should call out the fact that it will change if stored properties are added to other contexts.<br>&gt; <br>&gt; It’s definitely not a complete proposal yet.  I just wanted to get the discussion going while the memberwise init proposal is under consideration.  I’ll be sure to to include the items you mention here.<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>&gt;&gt;&gt;&gt; Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  Detailed design is still open.  Here’s the basic idea:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A partial initializer can initialize any subset of stored properties.<br>&gt;&gt;&gt; 2. A partial initializer can only read a property it initializes itself.<br>&gt;&gt;&gt; 3. If an initializer initializes a `let` property it cannot call a partial initializer that also initializes that property.<br>&gt;&gt;&gt; 4. After calling a partial initializer, the properties it initialized are considered initialized in the calling initializer as well.  They can be read from, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers themselves are not “checked” per-se.  The compiler would keep track of the properties they initialize and use that information when checking the calling initializer (for duplicate `let` assignments, complete initialization, etc).<br>&gt;&gt; <br>&gt;&gt; Okay.  This requires a simple dependency-ordering pass among partial initializers, but that should be straightforward to do.<br>&gt;&gt; <br>&gt;&gt; The model will be much simpler if you ban redundant assignments to ‘var’ properties as well.<br>&gt; <br>&gt; I will be happy to do that if it makes implementation easier!  I don’t have any specific use cases in mind that would require allowing redundant assignments to `var` properties.  That can always be added later if necessary.<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; Basic example<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC(i: Int = 10) {<br>&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  It is a generally useful initialization feature and also paves the way for stored properties declared outside the main body of the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It combines really well with syntactic sugar to forward parameters directly from a primary to a partial initializer as well as sugar for concise declaration of trivial partial memberwise initializers.<br>&gt;&gt; <br>&gt;&gt; Sure.  I’m just asking you to spell it out.<br>&gt; <br>&gt; Yep, will do.  I’ll be continuing to work on filling it out over the next few days.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Calling multiple partial initializers<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   partial init configureD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     configureD.init(i)<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; One partial init calling another<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   partial init bcAndD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     bcAndD.init(i)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Syntactic sugar for forwarding<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Basic forwarding sugar example<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, ...bAndC) {<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Forwarding to more than one partial initializer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   partial init aAndD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;     a = i * 10<br>&gt;&gt;&gt;&gt;&gt;     d = i * 100<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;   init(...aAndD, ...bAndC) {}<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     aAndD.init(i: Int)<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;     aAndD.init(...aAndDParams)<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; One partial initizer forwarding to another<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;   partial init abAndC(...bAndC) {<br>&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, c: c)<br>&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Forwarding to super<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;&gt;   let d: Double<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;   init(...super) {<br>&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {<br>&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;     super.init(i: i, s: s, f: f)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;   init(...superParams) {<br>&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;     super.init(...superParams)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; If super contains more than one initializer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;   let i: Int, s: String, f: Float<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;   init(s: S) {}<br>&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;&gt;   let d: Double = 42<br>&gt;&gt;&gt;&gt;&gt;   // error: ambiguous forward to super<br>&gt;&gt;&gt;&gt;&gt;   init(...super) {} <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Implicit partial initializers<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;   public init(...publicMemberwise) {<br>&gt;&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;   memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;   init(...internalMemberwise) {<br>&gt;&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;   private memberwise init(...) {}<br>&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;   private init(...privateMemberwise) {}<br>&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Members computed tuple property<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are a few problems with the members computed tuple approach:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt;&gt;&gt;&gt;&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt;&gt;&gt;&gt;&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/7d810b0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 3:57 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 1:37 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jan 11, 2016, at 12:52 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 9:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; Partial Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This proposal introduces partial initializers. They perform part, but not all, of phase 1 initialization for a type. Partial initializers can only be called by designated initializers of the same type or other partial initializers of the same type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: Proposal Draft: Partial Initializers &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initializers will make it much easier to factor out common initialization logic than it is today.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Memberwise initialization<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initializers are a general feature that can work together with Parameter Forwarding &lt;https://github.com/anandabits/swift-evolution/edit/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt; and Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; to enable extremely flexible memberwise initialization. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The combination of partial initializers and parameter forwarding is sufficiently powerfule to replace the explicit memberwise initializers of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal by simply adding a three implicit partial initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Extensions with stored properties<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initialization is an enabling feature for stored properties in class extensions. Extension with stored properties would be required to have a designated initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John McCall briefly described &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004479.html&gt; how this might work in the mailing list thread discussing extensions with stored properties. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposed solution is to introduce a partial declaration modifier for initializers. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When this declaration modifier is present the entire body of the initializer must comply with phase 1 initialization. It is possible for a partial initializer to initialize all stored properties but it is not possible for a partial initializer to call a super initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initializers can only be called during phase 1 of initialization by another partial initalizer of the same type, by a designated initializer of the same type, or by another struct initializer of the same type.<br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler keeps track of the properties initialized by a call to a partial initializer and uses that knowledge when enforcing initialization rules in phase 1 in the calling initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt;&gt;&gt;&gt;&gt; That’s interesting.  This is also a syntactic for partial deinit, I suppose, although that seems pointless outside of class extensions (and even then it’s suspect).  I guess it’s clear enough what’s happening because the .init suffix is not normally writable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are the rules on this identifier?  Does it have to be unique, or can partial initializers also be overloaded?  What do you expect to do for extensions?<br>&gt;&gt; <br>&gt;&gt; Good questions.  I could go either way on allowing overloads.  I suppose it makes sense to allow them since they are allowed pretty much everywhere else.  What do you think would be best?<br>&gt; <br>&gt; Your examples seem to lead towards them being overloadable: you would add a partial initializer for a cluster of properties, and then maybe there are multiple ways to initialize those properties.<br></p><p>Actually, I just realized that they cannot be overloadable.  I think the concise syntax for forwarding to partial initializers will be extremely useful and it would be ambiguous if we allow overloading.<br></p><p>&gt; <br>&gt;&gt; For extensions I think it makes the most sense to require an identifier for extensions that include stored properties.  I think this makes it clear in the designated initializers for the type exactly which extension is getting initialized by a specific init call.<br>&gt;&gt; <br>&gt;&gt; Class extensions could then have 3 kinds of initializers:<br>&gt;&gt; <br>&gt;&gt; * designated initializers for the extension (must init all stored properties introduced in the extension)<br>&gt;&gt; * partial initializers for the extension (can init some, but not necessarily all stored properties introduced in the extension and are callable only by the extension designated initializers)<br>&gt;&gt; * convenience initializers for the class (we already have these)<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; extension MoreStuff MyClass {<br>&gt;&gt;   let a, b: Int<br>&gt;&gt;   partial init onlyA() {<br>&gt;&gt;     a = 44<br>&gt;&gt;   }<br>&gt;&gt;   init (i: Int) {<br>&gt;&gt;     a = i<br>&gt;&gt;     b = i * 2<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MyClass {<br>&gt;&gt;   let x, y: Int<br>&gt;&gt;   init() {<br>&gt;&gt;     x = 2<br>&gt;&gt;     y = 2<br>&gt;&gt;     MoreStuff.init(44)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If we allowed stored properties in struct extensions they would just define normal primary, delegating, or partial initializers, of course requiring visibility to any properties they initialize.  That said, I don’t think the plan is to support stored properties in struct extensions anyway.<br>&gt;&gt; <br>&gt;&gt; If we allow stored properties in protocols conformed to within the same module as the type definition (as Chris and Doug are discussing) a similar syntax could be used in the designated initializers of the type to initialize the protocol storage: `ProtocolName.init(arg1, arg2, etc)`.<br>&gt; <br>&gt; Hmm.  I’m not really comfortable with the idea of these partial initializers in extensions not being somehow marked as partial.  Without that, they look just like a designated initializer; and designated initializers in extensions are a plausible future language direction (they would, of course, have to peer-delegate to another designated initializer).<br></p><p>Good to know.  I didn’t realize designated inits in extensions that was something was a possible direction.  In that case I agree for sure.<br></p><p>&gt; <br>&gt; Maybe a better model would be to say that they’re still partial initializers, and you can only call a partial initializer for an extension from a designated initializer if the partial initializer is complete for its extension.  That restriction could be weekend over time if we wanted to.  On the flip side, that restriction is also consistent with not allowing incomplete partial initializers at all.<br></p><p>What do you think about marking the “complete for the extension” partial inits `extension init` rather than `partial init`.  I think the distinction is useful, both for verifying the programmers intent that the init is complete for the extension, as well as for distinguishing which are eligible to be called from the designated initializer and which are not.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt; Struct partial initializers are allowed to include an access control modifier specifying their visibility. They can be called in any initializer of the same type where they are visible.<br>&gt;&gt;&gt;&gt;&gt;&gt; Class partial initializers are always private. This is because they can only be declared in the main body of a class and can only be called by a designated initializer of the same type.<br>&gt;&gt;&gt;&gt;&gt; So you’re explicitly forbidding the class-extension use case I had described as the major motivation for this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, this proposal is just introducing the feature into the current language.  I consider introducing the class-extension use case to be part of a new proposal.  That said, if you felt like it should be introduced in this proposal (presumably along with stored properties in extensions) we could do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, of course, you’re absolutely right.  That’s a reasonable approach, but understand that this is basically a completely different feature, in terms of both its expected uses and its implementation, from partial initialization of class extensions.  The only similarity is syntax.  It would abstractly be reasonable to independently decide that one of these features isn’t a good idea, isn’t worth the complexity, or is simply out of scope.<br>&gt;&gt; <br>&gt;&gt; Yes I agree that it is different and independent.  I thought the implementation might have some overlap but you obviously know better than I do about that!<br>&gt; <br>&gt; Maybe.  With only complete partial initializers, DI just needs to track that all extensions that declare partial initializers have a partial initializer called; it doesn’t necessarily even need to allow recursive partial initialization, so the logic is basically local.  With incomplete partial initializers, and especially with delegation between them, it gets significantly more complex.<br></p><p>Makes sense.  If allowing one partial init to call another partial init is a potential obstacle to accepting this proposal I would remove that.  Please let me know if that is the case.<br></p><p>&gt; <br>&gt; Oh, you should add that partial initializers should not be allowed to fail.  That’s a liftable restriction in time, I think, but it cuts down on the initial complexity quite a bit.<br></p><p>Yes, I agree.  This makes sense as a restriction.<br></p><p>What do you think of David’s comments about sharing the init logic with post-init code?  Obviously this isn’t possible for init logic that initializes `let` properties, but for initialization logic that only touches `var` properties it makes sense.  <br></p><p>I lean towards adjusting the rules to allow a partial init that only touches `var` properties to be callable as a normal method post-initialization.  These would also be allowed to have an access control specifier for the post-init visibility.  Do you like that direction?<br></p><p>Thanks for all of your feedback and comments today!<br></p><p>Matthew<br></p><p><br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt;&gt; Also, I think it wouldn’t hurt for this proposal to be more explicit about how you expect it to interact with other proposals.  You say that it combines well with memberwise initializers; okay, I think I see where you’re going with that, but spell it out, please.  Similarly, a brief section outlining how you expect this to work with stored properties in extensions would not be out of place, and this line in particular should call out the fact that it will change if stored properties are added to other contexts.<br>&gt;&gt; <br>&gt;&gt; It’s definitely not a complete proposal yet.  I just wanted to get the discussion going while the memberwise init proposal is under consideration.  I’ll be sure to to include the items you mention here.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is no restriction on the order in which the partial initializers are called aside from the rule that the can only be called during phase 1 of initialization and the rule that a let property must be initialized once and only once during phase 1.<br>&gt;&gt;&gt;&gt;&gt; Any initialization proposal needs to be explicit about the new rules it’s proposing for definitive initialization.  How are partial initializers checked?  What properties can be accessed within them?  How do calls to them fit into other checking?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agree.  Detailed design is still open.  Here’s the basic idea:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. A partial initializer can initialize any subset of stored properties.<br>&gt;&gt;&gt;&gt; 2. A partial initializer can only read a property it initializes itself.<br>&gt;&gt;&gt;&gt; 3. If an initializer initializes a `let` property it cannot call a partial initializer that also initializes that property.<br>&gt;&gt;&gt;&gt; 4. After calling a partial initializer, the properties it initialized are considered initialized in the calling initializer as well.  They can be read from, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initializers themselves are not “checked” per-se.  The compiler would keep track of the properties they initialize and use that information when checking the calling initializer (for duplicate `let` assignments, complete initialization, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay.  This requires a simple dependency-ordering pass among partial initializers, but that should be straightforward to do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The model will be much simpler if you ban redundant assignments to ‘var’ properties as well.<br>&gt;&gt; <br>&gt;&gt; I will be happy to do that if it makes implementation easier!  I don’t have any specific use cases in mind that would require allowing redundant assignments to `var` properties.  That can always be added later if necessary.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Basic example<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC(i: Int = 10) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Interesting.  So partial initializers in the main declaration provide a way to abstract out common initializer logic from multiple initializers without creating a separate initializer.  We otherwise don&#39;t have this because (1) you cannot call methods during phase 1 of initialization and (2) we do not do the appropriate DI-checking in a method.  I think that’s potentially very useful for classes with a lot of complex initialization logic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agree.  It is a generally useful initialization feature and also paves the way for stored properties declared outside the main body of the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It combines really well with syntactic sugar to forward parameters directly from a primary to a partial initializer as well as sugar for concise declaration of trivial partial memberwise initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure.  I’m just asking you to spell it out.<br>&gt;&gt; <br>&gt;&gt; Yep, will do.  I’ll be continuing to work on filling it out over the next few days.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Calling multiple partial initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init configureD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     configureD.init(i)<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; One partial init calling another<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC() {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = 10<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = 20<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bcAndD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init()<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     bcAndD.init(i)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Syntactic sugar for forwarding<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It will be a common use case to factor out some common initialization logic using a partial initializer. Often the parameters for the partial initializer will simply be forwarded. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Syntactic sugar is provided to streamline this use case. It matches the placeholder syntax of the parameter forwarding proposal &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;, with the placeholder identifier matching the name of a partial initializer. The implementation of forwarding matches the implementation of the parameter forwarding proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Basic forwarding sugar example<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, ...bAndC) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 2<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 4<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Forwarding to more than one partial initializer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init aAndD(i: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = i * 10<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = i * 100<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...aAndD, ...bAndC) {}<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, b: Int = 10, cLabel: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     aAndD.init(i: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, cLabel: cLabel)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...aAndDParams, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     aAndD.init(...aAndDParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; One partial initizer forwarding to another<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let a, b, c, d: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init bAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     b = b<br>&gt;&gt;&gt;&gt;&gt;&gt;     c = c<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init abAndC(...bAndC) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init abAndC(b: Int = 10, cLabel c: Int = 20) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(b: b, c: c)<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   // NOTE: the placeholder identifier is changed to `bAndCParams` here to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt;   // conflict with the name of the partial initializer itself<br>&gt;&gt;&gt;&gt;&gt;&gt;   partial init abAndC(i: Int, ...bAndCParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     bAndC.init(...bAndCParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;     a = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Forwarding to super<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If super contains a single designated initializer subclasses can use the same syntax to forward parameters to the super initializer. The call to super is added at the end of the initializer body. This means that if phase 2 initialization logic is necessary it will not be possible to use the syntactic sugar.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let d: Double<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // user writes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...super) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // compiler synthesizes<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;     super.init(i: i, s: s, f: f)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // equivalent to writing the following under the parameter forwarding proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...superParams) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     d = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;     super.init(...superParams)<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; If super contains more than one initializer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let i: Int, s: String, f: Float<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(s: S) {}<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(i: Int, s: String, f: Float) {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let d: Double = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;   // error: ambiguous forward to super<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...super) {} <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Implicit partial initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Three implicit paritial initializers exist. They match the behavior of public, internal, and private memberwise intializers using the automatic property eligibility model described in the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal, thus making that proposal obsolete if this proposal is accepted. The private and internal implicit partial initializers also match the behavior of the implicit memberwise initializer if one exists for the type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;&gt;   public init(...publicMemberwise) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // init all private an internal props<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(...internalMemberwise) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // init all private props<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;   // flexibile memberwise initialization proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;   private memberwise init(...) {}<br>&gt;&gt;&gt;&gt;&gt;&gt;   // corresponding syntax using implicit partial init and forwarding:<br>&gt;&gt;&gt;&gt;&gt;&gt;   private init(...privateMemberwise) {}<br>&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe the basic structure of partial initialization falls naturally out of the current initialization rules.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The syntax for declaring and invoking partial initializers is game for bikeshedding.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Members computed tuple property<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Joe Groff posted the idea of using a members computed tuple property &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005619.html&gt; during the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal. The ensuing discussion inspired me to think more deeply about how more general features could support the memberwise initialization use case. That line of thinking eventually led me to create this proposal as well as the Property Lists &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are a few problems with the members computed tuple approach:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It uses a computed property setter to initialize let properties. This is not something you can do in manually written code and just feels wrong. Initialization, especially of let properties, but also the first set of a var property, should happen in an initilizer context. Partial initializers allow for that in a much more elegant fashion than a weird special case property with a setter that is kind of an initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; The question of how to expose default property values in initializer parameters was never answered.<br>&gt;&gt;&gt;&gt;&gt;&gt; The question of how to provide memberwise initialization for a subset of properties was never answered.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3a3862de/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; The model will be much simpler if you ban redundant assignments to ‘var’ properties as well.<br></p><p>Is this just referring to the partial init itself?  Or the entire initialization sequence?  I ask because I am wondering specifically about `var` properties with an initial value.  The compiler will insert an initialization at the beginning of the designated initializer.  Is it ok if a partial init overwrites that value?  That is the only redundant assignment that I would care about, at least for now.  But that seems important to allow.<br></p><p>Matthew<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt; <br>&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt; <br>&gt; The proposal drafts can be found at the following links:<br>&gt; <br>&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt; <br></p><p>The biggest drawback I see is that is doesn’t really address the ability to use normal functions to initialize the state of the type. For example, in order to implement a “reset” or “clear” mechanism, I still need to duplicate a bunch of init code.<br></p><p>class CFoo {<br>    private(set) var value: Int<br>    <br>    func reset() {<br>        value = 0<br>    }<br>    <br>    init() {<br>        // Really want to just call this...<br>        //reset()<br>        <br>        // But, instead, I need to duplicate the code from `reset()`<br>        value = 0<br>    }<br>    <br>    func inc() {<br>        ++value<br>    }<br>}<br></p><p>let c = CFoo()<br>c.inc()<br>c.value    // 1<br>c.reset()<br>c.value    // 0<br></p><p><br>Take the above code, the “init” functionality is really about putting the type in the correct state. I think I’d rather see a mechanism to make a non-initializer as adhering to the rules of an init() so that it could be used in multiple contexts. <br></p><p>I think this modification makes your proposal much more interesting and applicable to more use cases.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/24481f11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:33 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt; <br>&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt; <br>&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt; <br>&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt; <br>&gt; <br>&gt; The biggest drawback I see is that is doesn’t really address the ability to use normal functions to initialize the state of the type. For example, in order to implement a “reset” or “clear” mechanism, I still need to duplicate a bunch of init code.<br>&gt; <br>&gt; class CFoo {<br>&gt;     private(set) var value: Int<br>&gt;     <br>&gt;     func reset() {<br>&gt;         value = 0<br>&gt;     }<br>&gt;     <br>&gt;     init() {<br>&gt;         // Really want to just call this...<br>&gt;         //reset()<br>&gt;         <br>&gt;         // But, instead, I need to duplicate the code from `reset()`<br>&gt;         value = 0<br>&gt;     }<br>&gt;     <br>&gt;     func inc() {<br>&gt;         ++value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let c = CFoo()<br>&gt; c.inc()<br>&gt; c.value    // 1<br>&gt; c.reset()<br>&gt; c.value    // 0<br>&gt; <br>&gt; <br>&gt; Take the above code, the “init” functionality is really about putting the type in the correct state. I think I’d rather see a mechanism to make a non-initializer as adhering to the rules of an init() so that it could be used in multiple contexts. <br>&gt; <br>&gt; I think this modification makes your proposal much more interesting and applicable to more use cases.<br>&gt; <br></p><p>That is a fair point.  <br></p><p>The reason I didn’t go that route has a lot to do with `let` properties.  It would feel weird to me to be assigning to a `let` in a non-init method (that is why I didn’t like Joe’s tuple property idea).  And a method that does that couldn’t be called any other time anyway.<br></p><p>Maybe we could introduce partial inits as well as an attribute or decl modifier for methods that have similar behavior to partial inits, but are not allowed to assign to a `let` property (maybe @init).  I could add something along those lines to this proposal or it could be a separate follow-on proposal.<br></p><p>What do you think of that?  <br></p><p>Matthew<br></p><p>&gt; -David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/79c520d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:43 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 11, 2016, at 7:33 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The biggest drawback I see is that is doesn’t really address the ability to use normal functions to initialize the state of the type. For example, in order to implement a “reset” or “clear” mechanism, I still need to duplicate a bunch of init code.<br>&gt;&gt; <br>&gt;&gt; class CFoo {<br>&gt;&gt;     private(set) var value: Int<br>&gt;&gt;     <br>&gt;&gt;     func reset() {<br>&gt;&gt;         value = 0<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init() {<br>&gt;&gt;         // Really want to just call this...<br>&gt;&gt;         //reset()<br>&gt;&gt;         <br>&gt;&gt;         // But, instead, I need to duplicate the code from `reset()`<br>&gt;&gt;         value = 0<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func inc() {<br>&gt;&gt;         ++value<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let c = CFoo()<br>&gt;&gt; c.inc()<br>&gt;&gt; c.value    // 1<br>&gt;&gt; c.reset()<br>&gt;&gt; c.value    // 0<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Take the above code, the “init” functionality is really about putting the type in the correct state. I think I’d rather see a mechanism to make a non-initializer as adhering to the rules of an init() so that it could be used in multiple contexts. <br>&gt;&gt; <br>&gt;&gt; I think this modification makes your proposal much more interesting and applicable to more use cases.<br>&gt;&gt; <br>&gt; <br>&gt; That is a fair point.  <br>&gt; <br>&gt; The reason I didn’t go that route has a lot to do with `let` properties.  It would feel weird to me to be assigning to a `let` in a non-init method (that is why I didn’t like Joe’s tuple property idea).  And a method that does that couldn’t be called any other time anyway.<br>&gt; <br>&gt; Maybe we could introduce partial inits as well as an attribute or decl modifier for methods that have similar behavior to partial inits, but are not allowed to assign to a `let` property (maybe @init).  I could add something along those lines to this proposal or it could be a separate follow-on proposal.<br>&gt; <br>&gt; What do you think of that?  <br></p><p>Actually, another solution to this would be to just allow partial initializers that don’t initialize `let` properties to be called post-initialization.  They have identifiers so they could be called like a normal method after initialization completes.  <br></p><p>I kind of like this idea better because it emphasizes the fact that they are initializing state and not doing anything else.  It sets them apart from normal methods.  It also avoids the need for more syntax.<br></p><p>Attempting to call a partial init that does initialize a `let` property post-initialization would be a compiler error.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; -David<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e26cd3a8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 5:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 7:33 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The biggest drawback I see is that is doesn’t really address the ability to use normal functions to initialize the state of the type. For example, in order to implement a “reset” or “clear” mechanism, I still need to duplicate a bunch of init code.<br>&gt;&gt; <br>&gt;&gt; class CFoo {<br>&gt;&gt;     private(set) var value: Int<br>&gt;&gt;     <br>&gt;&gt;     func reset() {<br>&gt;&gt;         value = 0<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init() {<br>&gt;&gt;         // Really want to just call this...<br>&gt;&gt;         //reset()<br>&gt;&gt;         <br>&gt;&gt;         // But, instead, I need to duplicate the code from `reset()`<br>&gt;&gt;         value = 0<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func inc() {<br>&gt;&gt;         ++value<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let c = CFoo()<br>&gt;&gt; c.inc()<br>&gt;&gt; c.value    // 1<br>&gt;&gt; c.reset()<br>&gt;&gt; c.value    // 0<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Take the above code, the “init” functionality is really about putting the type in the correct state. I think I’d rather see a mechanism to make a non-initializer as adhering to the rules of an init() so that it could be used in multiple contexts. <br>&gt;&gt; <br>&gt;&gt; I think this modification makes your proposal much more interesting and applicable to more use cases.<br>&gt;&gt; <br>&gt; <br>&gt; That is a fair point.  <br>&gt; <br>&gt; The reason I didn’t go that route has a lot to do with `let` properties.  It would feel weird to me to be assigning to a `let` in a non-init method (that is why I didn’t like Joe’s tuple property idea).  And a method that does that couldn’t be called any other time anyway.<br></p><p>Well, this is a limitation (assigning to lets) that convenience inits() have as well. Also, as it’s a function that is callable, it makes little sense to have `let` assignments in it anyway. So that limitation seems fine. The annotation would only be there to allow the compiler (and code authors) know that this method is intended to be allowed in the initialization rules, so some restrictions may apply.<br></p><p>&gt; Maybe we could introduce partial inits as well as an attribute or decl modifier for methods that have similar behavior to partial inits, but are not allowed to assign to a `let` property (maybe @init).  I could add something along those lines to this proposal or it could be a separate follow-on proposal.<br>&gt; <br>&gt; What do you think of that?  <br></p><p>What I’m saying is that you don’t need the partial inits anymore, you still need some of your rules, but the actual “partial init” would be replaced by this modifier on functions.<br></p><p>Maybe something like this:<br></p><p>    initializer func reset() {<br>        value1 = 0<br>    }<br></p><p>The “initializer” modifier would be your “partial init” modifier. For this to work though, you’d basically have to take the same limitation as convenience inits() today and disallow `let` values to be set. However, most of your other rules would apply to these.<br></p><p>Well… I guess there is this too:<br></p><p>&gt;  Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br></p><p>This would still remove the ability to use `let` assignments, but those functions could be allowed to be called like normal functions.<br></p><p>struct S {<br>  let a, b, c, d: Int<br>  partial init bAndC(i: Int = 10) {<br>    b = 10<br>    c = 20<br>  }<br>  init(i: Int) {<br>    a = i * 2<br>    d = i * 4<br>    bAndC.init()<br>  }<br>}<br></p><p>var s = S(12)<br>s.bAndC(1)<br></p><p>Again, you’ve have to remove the `let` assignments… <br></p><p>Anyhow, just mostly thinking out loud at this point.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/df52c163/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What I’m saying is that you don’t need the partial inits anymore, you still need some of your rules, but the actual “partial init” would be replaced by this modifier on functions.<br>&gt; <br>&gt; Maybe something like this:<br>&gt; <br>&gt;     initializer func reset() {<br>&gt;         value1 = 0<br>&gt;     }<br>&gt; <br>&gt; The “initializer” modifier would be your “partial init” modifier.<br></p><p>I was about to post this idea (although I was going to suggest `partial func`, and possibly giving the `partial` keyword a parenthesized list of the properties that it expects to be initialized before you call it).<br></p><p>&gt; For this to work though, you’d basically have to take the same limitation as convenience inits() today and disallow `let` values to be set. However, most of your other rules would apply to these.<br></p><p>Keep in mind that it&#39;s only the assignment itself that would have to be in the initializer. You could still use a partial method to encapsulate the logic used to calculate the constant&#39;s value:<br></p><p>	let foo: Foo<br>	var bar: Bar<br>	<br>	init(bar: Bar) {<br>		self.bar = bar<br>		foo = makeFoo()<br>		super.init()<br>	}<br>	<br>	partial(bar) func makeFoo() -&gt; Foo {<br>		return Foo(bar: bar)<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 9:49 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Keep in mind that it&#39;s only the assignment itself that would have to be in the initializer. You could still use a partial method to encapsulate the logic used to calculate the constant&#39;s value:<br>&gt; <br>&gt; 	let foo: Foo<br>&gt; 	var bar: Bar<br>&gt; 	<br>&gt; 	init(bar: Bar) {<br>&gt; 		self.bar = bar<br>&gt; 		foo = makeFoo()<br>&gt; 		super.init()<br>&gt; 	}<br>&gt; 	<br>&gt; 	partial(bar) func makeFoo() -&gt; Foo {<br>&gt; 		return Foo(bar: bar)<br>&gt; 	}<br></p><p>True, but that is a bit awkward, especially if there are multiple lets you want to initialize. It could also expose implementation details in the case of being able to reset the data from the call as some of the `let` could potentially be private.<br></p><p>Also, Matthew, it would probably be good to remove the forwarding stuff from this proposal. The idea of these helper-type initializers really doesn’t need to be coupled with that to stand on its own.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/b646368f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 12, 2016, at 2:00 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 9:49 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Keep in mind that it&#39;s only the assignment itself that would have to be in the initializer. You could still use a partial method to encapsulate the logic used to calculate the constant&#39;s value:<br>&gt;&gt; <br>&gt;&gt; 	let foo: Foo<br>&gt;&gt; 	var bar: Bar<br>&gt;&gt; 	<br>&gt;&gt; 	init(bar: Bar) {<br>&gt;&gt; 		self.bar = bar<br>&gt;&gt; 		foo = makeFoo()<br>&gt;&gt; 		super.init()<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	partial(bar) func makeFoo() -&gt; Foo {<br>&gt;&gt; 		return Foo(bar: bar)<br>&gt;&gt; 	}<br>&gt; <br>&gt; True, but that is a bit awkward, especially if there are multiple lets you want to initialize. It could also expose implementation details in the case of being able to reset the data from the call as some of the `let` could potentially be private.<br>&gt; <br>&gt; Also, Matthew, it would probably be good to remove the forwarding stuff from this proposal. The idea of these helper-type initializers really doesn’t need to be coupled with that to stand on its own.<br></p><p>This could be done, but I believe it will be very common to just forward to a partial init.  Allowing that to be done concisely is important enough to be part of the core proposal.  I am removing any mention of general forwarding though so this proposal will stand on its own.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/76470ab9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jan 11, 2016, at 11:49 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; What I’m saying is that you don’t need the partial inits anymore, you still need some of your rules, but the actual “partial init” would be replaced by this modifier on functions.<br>&gt;&gt; <br>&gt;&gt; Maybe something like this:<br>&gt;&gt; <br>&gt;&gt;    initializer func reset() {<br>&gt;&gt;        value1 = 0<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The “initializer” modifier would be your “partial init” modifier.<br>&gt; <br>&gt; I was about to post this idea (although I was going to suggest `partial func`, and possibly giving the `partial` keyword a parenthesized list of the properties that it expects to be initialized before you call it).<br></p><p>How common do you think it would be for a partial init to need to require that some properties already be initialized.  Do you think that is important right away or do you think it&#39;s ok to start without it and enhance the feature later if we run into common needs for it?  I lean towards this as a possible enhancement rather than an immediate requirement.<br></p><p>Matthew<br>&gt; <br>&gt;&gt; For this to work though, you’d basically have to take the same limitation as convenience inits() today and disallow `let` values to be set. However, most of your other rules would apply to these.<br>&gt; <br>&gt; Keep in mind that it&#39;s only the assignment itself that would have to be in the initializer. You could still use a partial method to encapsulate the logic used to calculate the constant&#39;s value:<br>&gt; <br>&gt;    let foo: Foo<br>&gt;    var bar: Bar<br>&gt;    <br>&gt;    init(bar: Bar) {<br>&gt;        self.bar = bar<br>&gt;        foo = makeFoo()<br>&gt;        super.init()<br>&gt;    }<br>&gt;    <br>&gt;    partial(bar) func makeFoo() -&gt; Foo {<br>&gt;        return Foo(bar: bar)<br>&gt;    }<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;&gt; I was about to post this idea (although I was going to suggest `partial func`, and possibly giving the `partial` keyword a parenthesized list of the properties that it expects to be initialized before you call it).<br>&gt; <br>&gt; How common do you think it would be for a partial init to need to require that some properties already be initialized.  Do you think that is important right away or do you think it&#39;s ok to start without it and enhance the feature later if we run into common needs for it?  I lean towards this as a possible enhancement rather than an immediate requirement.<br></p><p>I think that many, possibly most, partial methods—especially those that are meant to be called as normal methods will need to access existing properties, and the compiler will need to make sure partial method calls are ordered such that everything needed is already initialized; it&#39;s simply a question of whether we declare what&#39;s needed or automatically detect it. I&#39;ve noticed in previous proposals that scanning the method body is disfavored, so I figure that&#39;s not our best bet here.<br></p><p>(On the other hand, if we don&#39;t declare required properties, I guess that might leave `partial(only)` to indicate a method that initializes a constant and thus can&#39;t be called except in a designated initializer.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 2:23 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I was about to post this idea (although I was going to suggest `partial func`, and possibly giving the `partial` keyword a parenthesized list of the properties that it expects to be initialized before you call it).<br>&gt;&gt; <br>&gt;&gt; How common do you think it would be for a partial init to need to require that some properties already be initialized.  Do you think that is important right away or do you think it&#39;s ok to start without it and enhance the feature later if we run into common needs for it?  I lean towards this as a possible enhancement rather than an immediate requirement.<br>&gt; <br>&gt; I think that many, possibly most, partial methods—especially those that are meant to be called as normal methods will need to access existing properties<br></p><p>Do you have some concrete examples?  I’m sure this would be useful in some cases, I’m just not sure whether we need to include it right away.  <br></p><p>If the memberwise init review is anything to go by, there will be a lot of pushback that something like this makes the proposal too complex.  People might warm to it more after using the basic feature for a while and realizing the limitation this poses in practice.<br></p><p>&gt; , and the compiler will need to make sure partial method calls are ordered such that everything needed is already initialized; it&#39;s simply a question of whether we declare what&#39;s needed or automatically detect it. I&#39;ve noticed in previous proposals that scanning the method body is disfavored, so I figure that&#39;s not our best bet here.<br></p><p>This is another reason I am not sure about this.  I think you are right that this would require a declaration.  It becomes much more verbose that way.<br></p><p>One thing I would be concerned about is that the compiler will enforce proper order during initialization, but it will not enforce anything later.  If you are resetting state you will be on your own to do things in the correct order.  If the partial inits are not able to read from a property they didn’t write that at least helps prevent mistakes during the reset sequence (of course at the cost of some flexibility in structuring your code).<br></p><p>&gt; <br>&gt; (On the other hand, if we don&#39;t declare required properties, I guess that might leave `partial(only)` to indicate a method that initializes a constant and thus can&#39;t be called except in a designated initializer.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 13, 2016 at 01:00:00am</p></header><div class="content"><p>Let&#39;s start with this:<br></p><p>&gt;&gt; , and the compiler will need to make sure partial method calls are ordered such that everything needed is already initialized; it&#39;s simply a question of whether we declare what&#39;s needed or automatically detect it. I&#39;ve noticed in previous proposals that scanning the method body is disfavored, so I figure that&#39;s not our best bet here.<br>&gt; <br>&gt; This is another reason I am not sure about this.  I think you are right that this would require a declaration.  It becomes much more verbose that way.<br></p><p>The compiler will absolutely, 100%, inescapably need to know which properties a given partial method initializes. Otherwise it can&#39;t properly perform its phase one check, and if this proposal breaks safe initialization, it&#39;s not going to be accepted.<br></p><p>We could specify that the compiler takes a peek at the implementation and figures out which fields it initializes, or we could specify that the method declares the fields it will initialize. But however we choose to do it, doing it in *some* way is not negotiable.<br></p><p>&gt;&gt; I think that many, possibly most, partial methods—especially those that are meant to be called as normal methods will need to access existing properties<br>&gt; <br>&gt; Do you have some concrete examples?  I’m sure this would be useful in some cases, I’m just not sure whether we need to include it right away.  <br></p><p>Sure. Let&#39;s extend your resetting example so that the value you can reset the property *to* is configurable:<br></p><p>	struct Resettable&lt;Value&gt; {<br>		private let initialValue: Value<br>		var value: Value<br>		<br>		partial(uses initialValue, inits value) mutating func reset() {<br>			value = initialValue<br>		}<br>		<br>		init(_ initialValue: Value) {<br>			self.initialValue = initialValue<br>			reset()<br>		}<br>	}<br></p><p>&gt; If the memberwise init review is anything to go by, there will be a lot of pushback that something like this makes the proposal too complex.  People might warm to it more after using the basic feature for a while and realizing the limitation this poses in practice.<br></p><p>You don&#39;t want to make things overly complicated, but you also don&#39;t want to ignore obvious needs. In hindsight, SE-0019 made both of those mistakes in different places.<br></p><p>&gt; One thing I would be concerned about is that the compiler will enforce proper order during initialization, but it will not enforce anything later.  If you are resetting state you will be on your own to do things in the correct order.  If the partial inits are not able to read from a property they didn’t write that at least helps prevent mistakes during the reset sequence (of course at the cost of some flexibility in structuring your code).<br></p><p>I&#39;m not really sure why this is a concern. After `init` finishes, none of the fields you access could be uninitialized. There&#39;s nothing built in to Swift that lets you ensure methods are only called when the instance is in a state that expects them; all you&#39;ve got for that is precondition(). I just don&#39;t see how this is any worse than what we&#39;ve already got.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 3:15 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Let&#39;s start with this:<br>&gt; <br>&gt;&gt;&gt; , and the compiler will need to make sure partial method calls are ordered such that everything needed is already initialized; it&#39;s simply a question of whether we declare what&#39;s needed or automatically detect it. I&#39;ve noticed in previous proposals that scanning the method body is disfavored, so I figure that&#39;s not our best bet here.<br>&gt;&gt; <br>&gt;&gt; This is another reason I am not sure about this.  I think you are right that this would require a declaration.  It becomes much more verbose that way.<br>&gt; <br>&gt; The compiler will absolutely, 100%, inescapably need to know which properties a given partial method initializes. Otherwise it can&#39;t properly perform its phase one check, and if this proposal breaks safe initialization, it&#39;s not going to be accepted.<br>&gt; <br>&gt; We could specify that the compiler takes a peek at the implementation and figures out which fields it initializes, or we could specify that the method declares the fields it will initialize. But however we choose to do it, doing it in *some* way is not negotiable.<br></p><p>Yes of course it needs to know about what properties are initialized.  It does not need to know about which properties have been initialized prior to calling the partial initializer though if we don’t allow it to read pre-initialized properties.<br></p><p>&gt; <br>&gt;&gt;&gt; I think that many, possibly most, partial methods—especially those that are meant to be called as normal methods will need to access existing properties<br>&gt;&gt; <br>&gt;&gt; Do you have some concrete examples?  I’m sure this would be useful in some cases, I’m just not sure whether we need to include it right away.  <br>&gt; <br>&gt; Sure. Let&#39;s extend your resetting example so that the value you can reset the property *to* is configurable:<br>&gt; <br>&gt; 	struct Resettable&lt;Value&gt; {<br>&gt; 		private let initialValue: Value<br>&gt; 		var value: Value<br>&gt; 		<br>&gt; 		partial(uses initialValue, inits value) mutating func reset() {<br>&gt; 			value = initialValue<br>&gt; 		}<br>&gt; 		<br>&gt; 		init(_ initialValue: Value) {<br>&gt; 			self.initialValue = initialValue<br>&gt; 			reset()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br></p><p>This is a reasonable example.  John, if you’re still following this thread does allowing reads from properties that must be initialized prior to calling a partial init seem worthwhile to include?  Or does it seem like something that would make the proposal more likely to be rejected?  <br></p><p>Also, given the comments regarding the memberwise init proposal, is a partial initializer proposal reasonable to continue pursuing right now?  Or is this something that should wait?<br></p><p>&gt;&gt; If the memberwise init review is anything to go by, there will be a lot of pushback that something like this makes the proposal too complex.  People might warm to it more after using the basic feature for a while and realizing the limitation this poses in practice.<br>&gt; <br>&gt; You don&#39;t want to make things overly complicated, but you also don&#39;t want to ignore obvious needs. In hindsight, SE-0019 made both of those mistakes in different places.<br></p><p>I think you mean SE-0018.  I learned a couple of things during that process.  <br></p><p>One is that it is really hard to tell how to strike an appropriate balance if you want to do something nontrivial.  It seems like there is a lot of pressure to keep proposals very minimal (I tried very hard to get a solution to `let` defaults into the proposal for example).  This means necessarily choosing which needs to address because addressing all “obvious&quot; needs makes the proposal too large and likely too complex.  Additionally, which needs are “obvious” is in the eye of the beholder.<br></p><p>Another thing is that it’s easy to start with the wrong premise.  In this case, the idea was to enhance the existing memberwise init feature, keeping changes as small as possible to increase chances of the proposal being accepted.  That just wasn’t the right place to start to address boilerplate in explicit / nontrivial initializers.  I realized the “automatic” model was likely too complex and the “opt-in” model was probably better just before the review began but it was too late to change the proposal.  And I didn’t give enough consideration to trying to find a more general way to solve the problem (such as partial initializers) until well into the review discussion.<br></p><p>&gt; <br>&gt;&gt; One thing I would be concerned about is that the compiler will enforce proper order during initialization, but it will not enforce anything later.  If you are resetting state you will be on your own to do things in the correct order.  If the partial inits are not able to read from a property they didn’t write that at least helps prevent mistakes during the reset sequence (of course at the cost of some flexibility in structuring your code).<br>&gt; <br>&gt; I&#39;m not really sure why this is a concern. After `init` finishes, none of the fields you access could be uninitialized. There&#39;s nothing built in to Swift that lets you ensure methods are only called when the instance is in a state that expects them; all you&#39;ve got for that is precondition(). I just don&#39;t see how this is any worse than what we&#39;ve already got.<br></p><p>Well it would have to ensure that sequencing during initialization for a partial initializer that reads from a property it does not set.  My point wasn’t that something would be uninitialized later, but rather that your code might rely on “re-initialization” to happen in a certain sequence to be correct.  It might lead to mistakes when the compiler enforces sequencing during initialization but not later.<br></p><p>Of course you are right that you can “re-initialize” vars already today without any ordering guarantee so it wouldn’t make new mistakes possible.  On balance it probably would make things better by allowing you to factor out code.<br></p><p>I’m not opposed to allowing this.  I just wouldn&#39;t want to include it only to find out later that it is a sticking point that leads to rejection of the proposal.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/86c75d0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 8:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The compiler will absolutely, 100%, inescapably need to know which properties a given partial method initializes. Otherwise it can&#39;t properly perform its phase one check, and if this proposal breaks safe initialization, it&#39;s not going to be accepted.<br>&gt;&gt; <br>&gt;&gt; We could specify that the compiler takes a peek at the implementation and figures out which fields it initializes, or we could specify that the method declares the fields it will initialize. But however we choose to do it, doing it in *some* way is not negotiable.<br>&gt; <br>&gt; Yes of course it needs to know about what properties are initialized.  It does not need to know about which properties have been initialized prior to calling the partial initializer though if we don’t allow it to read pre-initialized properties.<br></p><p>I know there&#39;s a new thread now, but this is simply incorrect. Consider a struct with a single, non-optional AnyObject field:<br></p><p>struct Ref {<br>  var referent: AnyObject<br>  init func resetTo(newReferent: AnyObject) {<br>    referent = newReferent<br>  }<br>  init(referent: AnyObject) {<br>    resetTo.init(referent)<br>  }<br>}<br></p><p>If &#39;referent&#39; has already been set, the assignment has to release the old object; if it hasn&#39;t, it must not touch that memory (which is presumably uninitialized).<br></p><p>I&#39;m not sure if this practically affects the proposal in any way, other than making it a little harder to implement. But it&#39;s an important part of the model.<br></p><p>Best,<br>Jordan<br></p><p>more comments coming on the other thread<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/98645fa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 5:29 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 8:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The compiler will absolutely, 100%, inescapably need to know which properties a given partial method initializes. Otherwise it can&#39;t properly perform its phase one check, and if this proposal breaks safe initialization, it&#39;s not going to be accepted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could specify that the compiler takes a peek at the implementation and figures out which fields it initializes, or we could specify that the method declares the fields it will initialize. But however we choose to do it, doing it in *some* way is not negotiable.<br>&gt;&gt; <br>&gt;&gt; Yes of course it needs to know about what properties are initialized.  It does not need to know about which properties have been initialized prior to calling the partial initializer though if we don’t allow it to read pre-initialized properties.<br>&gt; <br>&gt; I know there&#39;s a new thread now, but this is simply incorrect. Consider a struct with a single, non-optional AnyObject field:<br>&gt; <br>&gt; struct Ref {<br>&gt;   var referent: AnyObject<br>&gt;   init func resetTo(newReferent: AnyObject) {<br>&gt;     referent = newReferent<br>&gt;   }<br>&gt;   init(referent: AnyObject) {<br>&gt;     resetTo.init(referent)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If &#39;referent&#39; has already been set, the assignment has to release the old object; if it hasn&#39;t, it must not touch that memory (which is presumably uninitialized).<br>&gt; <br>&gt; I&#39;m not sure if this practically affects the proposal in any way, other than making it a little harder to implement. But it&#39;s an important part of the model.<br></p><p>Thanks for catching this Jordan.  I was discussing requirements imposed by the partial initializer itself but of course any cleanup necessary must also happen and I didn’t fully consider that.<br></p><p>John asked that the proposal disallow redundant assignment to make implementation easier, which is included in the new draft.  I asked him whether this should apply to initial values for `var` properties but never got an answer.  I think the point you make indicates why he made the request which also indicates disallowing writing to a `var` with an initial value, which I currently allowed for in the proposal.  <br></p><p>I am open to modifying the proposal in whatever way the compiler team thinks is best.  :)  Feel free to respond with your thoughts in either thread.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; more comments coming on the other thread<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/140bca2d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 11, 2016, at 10:33 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 5:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 7:33 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 7:44 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Partial initializers is the second in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>&gt;&gt;&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>&gt;&gt;&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The biggest drawback I see is that is doesn’t really address the ability to use normal functions to initialize the state of the type. For example, in order to implement a “reset” or “clear” mechanism, I still need to duplicate a bunch of init code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class CFoo {<br>&gt;&gt;&gt;     private(set) var value: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func reset() {<br>&gt;&gt;&gt;         value = 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init() {<br>&gt;&gt;&gt;         // Really want to just call this...<br>&gt;&gt;&gt;         //reset()<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         // But, instead, I need to duplicate the code from `reset()`<br>&gt;&gt;&gt;         value = 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func inc() {<br>&gt;&gt;&gt;         ++value<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = CFoo()<br>&gt;&gt;&gt; c.inc()<br>&gt;&gt;&gt; c.value    // 1<br>&gt;&gt;&gt; c.reset()<br>&gt;&gt;&gt; c.value    // 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Take the above code, the “init” functionality is really about putting the type in the correct state. I think I’d rather see a mechanism to make a non-initializer as adhering to the rules of an init() so that it could be used in multiple contexts. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this modification makes your proposal much more interesting and applicable to more use cases.<br>&gt;&gt; <br>&gt;&gt; That is a fair point.  <br>&gt;&gt; <br>&gt;&gt; The reason I didn’t go that route has a lot to do with `let` properties.  It would feel weird to me to be assigning to a `let` in a non-init method (that is why I didn’t like Joe’s tuple property idea).  And a method that does that couldn’t be called any other time anyway.<br>&gt; <br>&gt; Well, this is a limitation (assigning to lets) that convenience inits() have as well. Also, as it’s a function that is callable, it makes little sense to have `let` assignments in it anyway. So that limitation seems fine. The annotation would only be there to allow the compiler (and code authors) know that this method is intended to be allowed in the initialization rules, so some restrictions may apply.<br></p><p>Right, but I do want to allow partial inits to write to a &#39;let&#39;.  That&#39;s why I went down the other path.<br></p><p>&gt; <br>&gt;&gt; Maybe we could introduce partial inits as well as an attribute or decl modifier for methods that have similar behavior to partial inits, but are not allowed to assign to a `let` property (maybe @init).  I could add something along those lines to this proposal or it could be a separate follow-on proposal.<br>&gt;&gt; <br>&gt;&gt; What do you think of that?  <br>&gt; <br>&gt; What I’m saying is that you don’t need the partial inits anymore, you still need some of your rules, but the actual “partial init” would be replaced by this modifier on functions.<br>&gt; <br>&gt; Maybe something like this:<br>&gt; <br>&gt;     initializer func reset() {<br>&gt;         value1 = 0<br>&gt;     }<br>&gt; <br>&gt; The “initializer” modifier would be your “partial init” modifier. For this to work though, you’d basically have to take the same limitation as convenience inits() today and disallow `let` values to be set. However, most of your other rules would apply to these.<br></p><p>Exactly.  That &#39;let&#39; limitation is why I don&#39;t consider this approach sufficient.<br></p><p>&gt; <br>&gt; Well… I guess there is this too:<br>&gt; <br>&gt;&gt;  Partial initializers receive an identifier, which avoids the need to rely on overloading to differentiate between partial initializers.<br>&gt; <br>&gt; This would still remove the ability to use `let` assignments, but those functions could be allowed to be called like normal functions.<br>&gt; <br>&gt; struct S {<br>&gt;   let a, b, c, d: Int<br>&gt;   partial init bAndC(i: Int = 10) {<br>&gt;     b = 10<br>&gt;     c = 20<br>&gt;   }<br>&gt;   init(i: Int) {<br>&gt;     a = i * 2<br>&gt;     d = i * 4<br>&gt;     bAndC.init()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var s = S(12)<br>&gt; s.bAndC(1)<br>&gt; <br>&gt; Again, you’ve have to remove the `let` assignments… <br></p><p>Yes, I think allowing this makes sense as long as the partial init does not write to a &#39;let&#39;.  I have updated the proposal to allow for this.  I will publish a new draft soon, hopefully later today.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Anyhow, just mostly thinking out loud at this point.<br></p><p>No harm in that!  I appreciate the feedback.  That&#39;s why I shared it even though it was still an early draft.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -David<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/6102ad35/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
