<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  7, 2016 at 06:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/1a4a82cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 02:00:00am</p></header><div class="content"><p>I&#39;d like to hijack this thread to talk about what the TI Voyage 200 could do as far as &quot;type-safe calculations&quot; go.<br></p><p>The calculator supports symbolic equations (for instance, `a * 1000 / 2` results in `500a` when a isn&#39;t known). The interesting part is that you could append units to numbers. For instance, you can write `500_m`, and this means 500 meters. Numbers with a type can only be added/subtracted with numbers of the same type, but they can be multiplied or divided by pretty much anything. For instance, `500_m - 2_s` (500 meters minus 2 seconds) is an error, but `500_m / 2_s` is `250 (_m/_s)` (or _m * _s^-1).<br></p><p>I found this *extremely* useful for engineering calculations. For instance, when you multiply quantities that should end up in Teslas, you know that you&#39;ve done something wrong if the unit displayed after the number doesn&#39;t look like `V * s * m^-2`. It was also a lifesaver that you could do something like `6_ft` and end up with 1.8288_m (because _ft is defined as 0.3048_m).<br></p><p>I have no idea how you&#39;d implement that with Swift though. I&#39;m not a very powerful template wizard, but I have no idea how you&#39;d do it with C++ either.<br></p><p>Of course, it might be a few years before you&#39;re allowed to use the Swift compiler during your physics exams, and I don&#39;t think that real-world programs often need that much unit safety with numbers. But when I read &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 01:42:07, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think the name should be changed to NumberBox or something similar. A box is something very generic and should not have number related associated types.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 06. Januar 2016 um 18:15 schrieb James Campbell &lt;james at supmenow.com&gt;:<br>&gt; <br>&gt;&gt; I&#39;ve managed to implement this already in the language with a few ugly corners due to the lack of generic protocols.<br>&gt;&gt; <br>&gt;&gt; I created a protocol based on Box (https://github.com/robrix/Box/ &lt;https://github.com/robrix/Box/&gt;) which works really well. I have extended this to handle certain special protocols like Equatable so you can do SpecialType == SpecialType, and even literalConversion.<br>&gt;&gt; <br>&gt;&gt; There is however a lot of boilerplate:<br>&gt;&gt; <br>&gt;&gt; - You have to declare all of your Convertible protocols for converting from one type to another<br>&gt;&gt; - You have to define an empty init so the protocol extensions have something to chain to.<br>&gt;&gt; - You need to write the value property with type.<br>&gt;&gt; <br>&gt;&gt; Due to the lack of protocol generics, you also need to have a protocol for every type you wish to box which sets the associated type. Of course I could have done this with classes but I wanted to keep this as a value type :).<br>&gt;&gt; <br>&gt;&gt; With member-wise initializations and generic protocols this could be achievable just by adding a Box protocol to the standard library.<br>&gt;&gt; <br>&gt;&gt; Here is my implementation of Box as a protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Box: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     typealias FloatLiteralType = Double<br>&gt;&gt; <br>&gt;&gt;     typealias IntegerLiteralType = Int<br>&gt;&gt; <br>&gt;&gt;     typealias BoxType = Any<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     var value: BoxType { get set }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init()<br>&gt;&gt; <br>&gt;&gt;     init(_ value: BoxType)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Box where BoxType: CustomStringConvertible {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     var description: String {<br>&gt;&gt; <br>&gt;&gt;         return self.value.description<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     var debugDescription: String {<br>&gt;&gt; <br>&gt;&gt;         return &quot;\(self.value.description)㎭&quot;<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //MARK: FloatingPointBox<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; protocol FloatingPointBox: Box, FloatLiteralConvertible, IntegerLiteralConvertible {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     typealias BoxType = Double<br>&gt;&gt; <br>&gt;&gt;     typealias FloatLiteralConvertible = Double<br>&gt;&gt; <br>&gt;&gt;     typealias IntegerLiteralConvertible = Int<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Box where Self.BoxType == Double {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(_ value: Double) {<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; <br>&gt;&gt;         self.init()<br>&gt;&gt; <br>&gt;&gt;         self.value = value<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(_ value: Int) {<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; <br>&gt;&gt;         self.init()<br>&gt;&gt; <br>&gt;&gt;         self.value = Double(value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension FloatLiteralType {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {<br>&gt;&gt; <br>&gt;&gt;         self.init(box.value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {<br>&gt;&gt; <br>&gt;&gt;         self.init(box.value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension CGFloat {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {<br>&gt;&gt; <br>&gt;&gt;         self.init(box.value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {<br>&gt;&gt; <br>&gt;&gt;         self.init(box.value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //Adding FloatLiteralConvertible, IntegerLiteralConvertible<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension FloatingPointBox where Self.BoxType == Double, Self.FloatLiteralConvertible == Double {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(floatLiteral value: Double) {<br>&gt;&gt; <br>&gt;&gt;         self.init(value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(integerLiteral value: Int) {<br>&gt;&gt; <br>&gt;&gt;         self.init(value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init&lt;T: IntegerType&gt;(_ value: T) {<br>&gt;&gt; <br>&gt;&gt;         self.init(value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is my example of using the Box protocol:<br>&gt;&gt; struct Degree: FloatingPointBox {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     var value: Double = 0<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init()<br>&gt;&gt; <br>&gt;&gt;     {<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; protocol DegreeConvertiable {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(degreeLiteral value: Degree)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Degree: RadianConvertiable {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(radianLiteral value: Radian) {<br>&gt;&gt; <br>&gt;&gt;         self.value = Double(value) * 180.0 / M_PI<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; <br>&gt;&gt;     init(_ value: Radian) {<br>&gt;&gt; <br>&gt;&gt;         self.init(radianLiteral: value)<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What about citing the relevant protocols in the newtype definition? This should include the ability to use my own protocols to which I have made the underlying type conform to by an extension.<br>&gt;&gt; <br>&gt;&gt; This is how my forwarding proposal works.  The newtype syntax I suggested as a possible extension looks like this:<br>&gt;&gt; <br>&gt;&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;&gt; <br>&gt;&gt; The keyword could be different, but I think `forwarding` is not bad.  When I complete the second draft I think it will make even more sense.  The forwarding facility has features to handle non-trivial cases (Self and associated type requirements, etc).<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Throwing some syntax into the discussion:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere and made Double conform to them if all this is not provided by the standard library.<br>&gt;&gt; &gt; The implementation of Euro then borrows the implementation of Double for these protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Thorsten<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;  Wizard<br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt;&gt; +44 7523 279 698<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/47f652ce/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>So this is how this feature could be achieved right now with minimal<br>changes to the language.<br></p><p>- We expose some kind of protocol that allows you to Box up types, we could<br>call this `Box` or something else like `Unit`. (I have a working<br>implementation in the current language with a bit of boilerplate). This<br>protocol handles the default implementation of converting from literals and<br>to floats etc.<br>- For each type-safe unit for a calculation - you define a protocol<br>extending this `Box` type which defines the associated type of the value<br>that unit holds. For example for Degree and Radian I declared a `AngleType`<br>which set the associated type to be a double.<br>- For each unit type, you declare a struct that inherits from that protocol<br>you defined. So I have two structs `Degree` and `Radian` which implement<br>the `AngleType` protocol.<br>- You implement the functions for figuring out if your units are equal and<br>all other operators they may need i.e `Degree(360) - 30`.<br></p><p>Future improvements with language updates:<br></p><p>- `AngleType` protocol may not be needed if swift introduces generic<br>protocols.<br>- Boilerplate in your type safe unit types may be reduced if swift<br>introduces memberwise initialization.<br>- The current implementation of this system in Swift will be greatly<br>simplified once the refactoring of Swift&#39;s Number types has been completed.<br>We currently use a bunch of work arounds with the compiler.<br>- We could introduce custom user literals to create these types if swift<br>supports this in the future (As Felix states).<br></p><p>On Thu, Jan 7, 2016 at 7:06 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; I&#39;d like to hijack this thread to talk about what the TI Voyage 200 could<br>&gt; do as far as &quot;type-safe calculations&quot; go.<br>&gt;<br>&gt; The calculator supports symbolic equations (for instance, `a * 1000 / 2`<br>&gt; results in `500a` when a isn&#39;t known). The interesting part is that you<br>&gt; could append units to numbers. For instance, you can write `500_m`, and<br>&gt; this means 500 meters. Numbers with a type can only be added/subtracted<br>&gt; with numbers of the same type, but they can be multiplied or divided by<br>&gt; pretty much anything. For instance, `500_m - 2_s` (500 meters minus 2<br>&gt; seconds) is an error, but `500_m / 2_s` is `250 (_m/_s)` (or _m * _s^-1).<br>&gt;<br>&gt; I found this *extremely* useful for engineering calculations. For<br>&gt; instance, when you multiply quantities that should end up in Teslas, you<br>&gt; know that you&#39;ve done something wrong if the unit displayed after the<br>&gt; number doesn&#39;t look like `V * s * m^-2`. It was also a lifesaver that you<br>&gt; could do something like `6_ft` and end up with 1.8288_m (because _ft is<br>&gt; defined as 0.3048_m).<br>&gt;<br>&gt; I have no idea how you&#39;d implement that with Swift though. I&#39;m not a very<br>&gt; powerful template wizard, but I have no idea how you&#39;d do it with C++<br>&gt; either.<br>&gt;<br>&gt; Of course, it might be a few years before you&#39;re allowed to use the Swift<br>&gt; compiler during your physics exams, and I don&#39;t think that real-world<br>&gt; programs often need that much unit safety with numbers. But when I read<br>&gt; &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 7 janv. 2016 à 01:42:07, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I think the name should be changed to NumberBox or something similar. A<br>&gt; box is something very generic and should not have number related associated<br>&gt; types.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 06. Januar 2016 um 18:15 schrieb James Campbell &lt;james at supmenow.com&gt;:<br>&gt;<br>&gt; I&#39;ve managed to implement this already in the language with a few ugly<br>&gt; corners due to the lack of generic protocols.<br>&gt;<br>&gt; I created a protocol based on Box (https://github.com/robrix/Box/) which<br>&gt; works really well. I have extended this to handle certain special protocols<br>&gt; like Equatable so you can do SpecialType == SpecialType, and even<br>&gt; literalConversion.<br>&gt;<br>&gt; There is however a lot of boilerplate:<br>&gt;<br>&gt; - You have to declare all of your Convertible protocols for converting<br>&gt; from one type to another<br>&gt; - You have to define an empty init so the protocol extensions have<br>&gt; something to chain to.<br>&gt; - You need to write the value property with type.<br>&gt;<br>&gt; Due to the lack of protocol generics, you also need to have a protocol for<br>&gt; every type you wish to box which sets the associated type. Of course I<br>&gt; could have done this with classes but I wanted to keep this as a value type<br>&gt; :).<br>&gt;<br>&gt; With member-wise initializations and generic protocols this could be<br>&gt; achievable just by adding a Box protocol to the standard library.<br>&gt;<br>&gt; Here is my implementation of Box as a protocol:<br>&gt;<br>&gt; *protocol Box: CustomStringConvertible, CustomDebugStringConvertible {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    typealias FloatLiteralType = Double*<br>&gt;<br>&gt; *    typealias IntegerLiteralType = Int*<br>&gt;<br>&gt; *    typealias BoxType = Any*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    var value: BoxType { get set }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init()*<br>&gt;<br>&gt; *    init(_ value: BoxType)*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *extension Box where BoxType: CustomStringConvertible {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    var description: String {*<br>&gt;<br>&gt; *        return self.value.description*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    var debugDescription: String {*<br>&gt;<br>&gt; *        return &quot;\(self.value.description)㎭&quot;*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *//MARK: FloatingPointBox*<br>&gt;<br>&gt;<br>&gt; *protocol FloatingPointBox: Box, FloatLiteralConvertible,<br>&gt; IntegerLiteralConvertible {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    typealias BoxType = Double*<br>&gt;<br>&gt; *    typealias FloatLiteralConvertible = Double*<br>&gt;<br>&gt; *    typealias IntegerLiteralConvertible = Int*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *extension Box where Self.BoxType == Double {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(_ value: Double) {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *        self.init()*<br>&gt;<br>&gt; *        self.value = value*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(_ value: Int) {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *        self.init()*<br>&gt;<br>&gt; *        self.value = Double(value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *extension FloatLiteralType {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;<br>&gt; *        self.init(box.value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;<br>&gt; *        self.init(box.value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *extension CGFloat {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;<br>&gt; *        self.init(box.value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;<br>&gt; *        self.init(box.value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *//Adding FloatLiteralConvertible, IntegerLiteralConvertible*<br>&gt;<br>&gt;<br>&gt; *extension FloatingPointBox where Self.BoxType == Double,<br>&gt; Self.FloatLiteralConvertible == Double {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(floatLiteral value: Double) {*<br>&gt;<br>&gt; *        self.init(value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(integerLiteral value: Int) {*<br>&gt;<br>&gt; *        self.init(value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init&lt;T: IntegerType&gt;(_ value: T) {*<br>&gt;<br>&gt; *        self.init(value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt; Here is my example of using the Box protocol:<br>&gt;<br>&gt; *struct Degree: FloatingPointBox {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    var value: Double = 0*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init()*<br>&gt;<br>&gt; *    {*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *protocol DegreeConvertiable {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(degreeLiteral value: Degree)*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt;<br>&gt; *extension Degree: RadianConvertiable {*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(radianLiteral value: Radian) {*<br>&gt;<br>&gt; *        self.value = Double(value) * 180.0 / M_PI*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *    init(_ value: Radian) {*<br>&gt;<br>&gt; *        self.init(radianLiteral: value)*<br>&gt;<br>&gt; *    }*<br>&gt;<br>&gt; *}*<br>&gt;<br>&gt; On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via<br>&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are<br>&gt;&gt; different types, yet use their parent type at the binary level. This needs<br>&gt;&gt; a specific syntax to teach the compiler which existing methods/operations<br>&gt;&gt; are allowed on the new fake types and which aren’t. These new distinct<br>&gt;&gt; types would *borrow* previous implementations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What about citing the relevant protocols in the newtype definition?<br>&gt;&gt; This should include the ability to use my own protocols to which I have<br>&gt;&gt; made the underlying type conform to by an extension.<br>&gt;&gt;<br>&gt;&gt; This is how my forwarding proposal works.  The newtype syntax I suggested<br>&gt;&gt; as a possible extension looks like this:<br>&gt;&gt;<br>&gt;&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;&gt;<br>&gt;&gt; The keyword could be different, but I think `forwarding` is not bad.<br>&gt;&gt; When I complete the second draft I think it will make even more sense.  The<br>&gt;&gt; forwarding facility has features to handle non-trivial cases (Self and<br>&gt;&gt; associated type requirements, etc).<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Throwing some syntax into the discussion:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere<br>&gt;&gt; and made Double conform to them if all this is not provided by the standard<br>&gt;&gt; library.<br>&gt;&gt; &gt; The implementation of Euro then borrows the implementation of Double<br>&gt;&gt; for these protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Thorsten<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/d498b5f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>This is my current implementation of this pattern.<br></p><p>On Thu, Jan 7, 2016 at 12:06 PM, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; So this is how this feature could be achieved right now with minimal<br>&gt; changes to the language.<br>&gt;<br>&gt; - We expose some kind of protocol that allows you to Box up types, we<br>&gt; could call this `Box` or something else like `Unit`. (I have a working<br>&gt; implementation in the current language with a bit of boilerplate). This<br>&gt; protocol handles the default implementation of converting from literals and<br>&gt; to floats etc.<br>&gt; - For each type-safe unit for a calculation - you define a protocol<br>&gt; extending this `Box` type which defines the associated type of the value<br>&gt; that unit holds. For example for Degree and Radian I declared a `AngleType`<br>&gt; which set the associated type to be a double.<br>&gt; - For each unit type, you declare a struct that inherits from that<br>&gt; protocol you defined. So I have two structs `Degree` and `Radian` which<br>&gt; implement the `AngleType` protocol.<br>&gt; - You implement the functions for figuring out if your units are equal and<br>&gt; all other operators they may need i.e `Degree(360) - 30`.<br>&gt;<br>&gt; Future improvements with language updates:<br>&gt;<br>&gt; - `AngleType` protocol may not be needed if swift introduces generic<br>&gt; protocols.<br>&gt; - Boilerplate in your type safe unit types may be reduced if swift<br>&gt; introduces memberwise initialization.<br>&gt; - The current implementation of this system in Swift will be greatly<br>&gt; simplified once the refactoring of Swift&#39;s Number types has been completed.<br>&gt; We currently use a bunch of work arounds with the compiler.<br>&gt; - We could introduce custom user literals to create these types if swift<br>&gt; supports this in the future (As Felix states).<br>&gt;<br>&gt; On Thu, Jan 7, 2016 at 7:06 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;d like to hijack this thread to talk about what the TI Voyage 200 could<br>&gt;&gt; do as far as &quot;type-safe calculations&quot; go.<br>&gt;&gt;<br>&gt;&gt; The calculator supports symbolic equations (for instance, `a * 1000 / 2`<br>&gt;&gt; results in `500a` when a isn&#39;t known). The interesting part is that you<br>&gt;&gt; could append units to numbers. For instance, you can write `500_m`, and<br>&gt;&gt; this means 500 meters. Numbers with a type can only be added/subtracted<br>&gt;&gt; with numbers of the same type, but they can be multiplied or divided by<br>&gt;&gt; pretty much anything. For instance, `500_m - 2_s` (500 meters minus 2<br>&gt;&gt; seconds) is an error, but `500_m / 2_s` is `250 (_m/_s)` (or _m * _s^-1).<br>&gt;&gt;<br>&gt;&gt; I found this *extremely* useful for engineering calculations. For<br>&gt;&gt; instance, when you multiply quantities that should end up in Teslas, you<br>&gt;&gt; know that you&#39;ve done something wrong if the unit displayed after the<br>&gt;&gt; number doesn&#39;t look like `V * s * m^-2`. It was also a lifesaver that you<br>&gt;&gt; could do something like `6_ft` and end up with 1.8288_m (because _ft is<br>&gt;&gt; defined as 0.3048_m).<br>&gt;&gt;<br>&gt;&gt; I have no idea how you&#39;d implement that with Swift though. I&#39;m not a very<br>&gt;&gt; powerful template wizard, but I have no idea how you&#39;d do it with C++<br>&gt;&gt; either.<br>&gt;&gt;<br>&gt;&gt; Of course, it might be a few years before you&#39;re allowed to use the Swift<br>&gt;&gt; compiler during your physics exams, and I don&#39;t think that real-world<br>&gt;&gt; programs often need that much unit safety with numbers. But when I read<br>&gt;&gt; &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 7 janv. 2016 à 01:42:07, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I think the name should be changed to NumberBox or something similar. A<br>&gt;&gt; box is something very generic and should not have number related associated<br>&gt;&gt; types.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 06. Januar 2016 um 18:15 schrieb James Campbell &lt;james at supmenow.com&gt;:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve managed to implement this already in the language with a few ugly<br>&gt;&gt; corners due to the lack of generic protocols.<br>&gt;&gt;<br>&gt;&gt; I created a protocol based on Box (https://github.com/robrix/Box/) which<br>&gt;&gt; works really well. I have extended this to handle certain special protocols<br>&gt;&gt; like Equatable so you can do SpecialType == SpecialType, and even<br>&gt;&gt; literalConversion.<br>&gt;&gt;<br>&gt;&gt; There is however a lot of boilerplate:<br>&gt;&gt;<br>&gt;&gt; - You have to declare all of your Convertible protocols for converting<br>&gt;&gt; from one type to another<br>&gt;&gt; - You have to define an empty init so the protocol extensions have<br>&gt;&gt; something to chain to.<br>&gt;&gt; - You need to write the value property with type.<br>&gt;&gt;<br>&gt;&gt; Due to the lack of protocol generics, you also need to have a protocol<br>&gt;&gt; for every type you wish to box which sets the associated type. Of course I<br>&gt;&gt; could have done this with classes but I wanted to keep this as a value type<br>&gt;&gt; :).<br>&gt;&gt;<br>&gt;&gt; With member-wise initializations and generic protocols this could be<br>&gt;&gt; achievable just by adding a Box protocol to the standard library.<br>&gt;&gt;<br>&gt;&gt; Here is my implementation of Box as a protocol:<br>&gt;&gt;<br>&gt;&gt; *protocol Box: CustomStringConvertible, CustomDebugStringConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    typealias FloatLiteralType = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias IntegerLiteralType = Int*<br>&gt;&gt;<br>&gt;&gt; *    typealias BoxType = Any*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var value: BoxType { get set }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init()*<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: BoxType)*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Box where BoxType: CustomStringConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var description: String {*<br>&gt;&gt;<br>&gt;&gt; *        return self.value.description*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var debugDescription: String {*<br>&gt;&gt;<br>&gt;&gt; *        return &quot;\(self.value.description)㎭&quot;*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *//MARK: FloatingPointBox*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *protocol FloatingPointBox: Box, FloatLiteralConvertible,<br>&gt;&gt; IntegerLiteralConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    typealias BoxType = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias FloatLiteralConvertible = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias IntegerLiteralConvertible = Int*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Box where Self.BoxType == Double {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Double) {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *        self.init()*<br>&gt;&gt;<br>&gt;&gt; *        self.value = value*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Int) {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *        self.init()*<br>&gt;&gt;<br>&gt;&gt; *        self.value = Double(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension FloatLiteralType {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension CGFloat {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *//Adding FloatLiteralConvertible, IntegerLiteralConvertible*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension FloatingPointBox where Self.BoxType == Double,<br>&gt;&gt; Self.FloatLiteralConvertible == Double {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(floatLiteral value: Double) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(integerLiteral value: Int) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: IntegerType&gt;(_ value: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt; Here is my example of using the Box protocol:<br>&gt;&gt;<br>&gt;&gt; *struct Degree: FloatingPointBox {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var value: Double = 0*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init()*<br>&gt;&gt;<br>&gt;&gt; *    {*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *protocol DegreeConvertiable {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(degreeLiteral value: Degree)*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Degree: RadianConvertiable {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(radianLiteral value: Radian) {*<br>&gt;&gt;<br>&gt;&gt; *        self.value = Double(value) * 180.0 / M_PI*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Radian) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(radianLiteral: value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via<br>&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk<br>&gt;&gt;&gt; are different types, yet use their parent type at the binary level. This<br>&gt;&gt;&gt; needs a specific syntax to teach the compiler which existing<br>&gt;&gt;&gt; methods/operations are allowed on the new fake types and which aren’t.<br>&gt;&gt;&gt; These new distinct types would *borrow* previous implementations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What about citing the relevant protocols in the newtype definition?<br>&gt;&gt;&gt; This should include the ability to use my own protocols to which I have<br>&gt;&gt;&gt; made the underlying type conform to by an extension.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is how my forwarding proposal works.  The newtype syntax I<br>&gt;&gt;&gt; suggested as a possible extension looks like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The keyword could be different, but I think `forwarding` is not bad.<br>&gt;&gt;&gt; When I complete the second draft I think it will make even more sense.  The<br>&gt;&gt;&gt; forwarding facility has features to handle non-trivial cases (Self and<br>&gt;&gt;&gt; associated type requirements, etc).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Throwing some syntax into the discussion:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere<br>&gt;&gt;&gt; and made Double conform to them if all this is not provided by the standard<br>&gt;&gt;&gt; library.<br>&gt;&gt;&gt; &gt; The implementation of Euro then borrows the implementation of Double<br>&gt;&gt;&gt; for these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Thorsten<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;  Wizard<br>&gt;&gt; james at supmenow.com<br>&gt;&gt; +44 7523 279 698<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br></p><p><br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/7e1facae/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: TypeSafeUnits.zip<br>Type: application/zip<br>Size: 34042 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/7e1facae/attachment.zip&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>January  7, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 4:06 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So this is how this feature could be achieved right now with minimal changes to the language.<br>&gt; <br>&gt; - We expose some kind of protocol that allows you to Box up types, we could call this `Box` or something else like `Unit`. (I have a working implementation in the current language with a bit of boilerplate). This protocol handles the default implementation of converting from literals and to floats etc.<br>&gt; - For each type-safe unit for a calculation - you define a protocol extending this `Box` type which defines the associated type of the value that unit holds. For example for Degree and Radian I declared a `AngleType` which set the associated type to be a double. <br>&gt; - For each unit type, you declare a struct that inherits from that protocol you defined. So I have two structs `Degree` and `Radian` which implement the `AngleType` protocol.<br>&gt; - You implement the functions for figuring out if your units are equal and all other operators they may need i.e `Degree(360) - 30`.<br></p><p>I took a different approach to this, which was to typealias Angle to Double,  keep all Angles as radians (since the stdlib trig functions take radians), and add some computed setters and getters to let me access an Angle in radians, degrees, or grads.<br></p><p>I would like to see Angle, along with several other basic geometric concepts, promoted to the Swift standard library. <br></p><p>-jcr<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/00be032b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>James, that works for degrees to radians, but I&#39;m afraid that one protocol per unit simply can&#39;t scale if you want to multiply/divide quantities with different units. Just look at the different things can make up a tesla &lt;https://upload.wikimedia.org/math/d/c/1/dc1af6ed32aa3e906230cc15ea08a2a4.png&gt;. The combination of units is factorial and defining like 24 protocols each with multiplication and division operation to every other defined protocol doesn&#39;t make sense. I&#39;d rather use &quot;untyped&quot; quantities if I had to do the same thing in Swift right now.<br></p><p>(By the way: Degree(360) - 30 should probably be Degree(360) - Degree(30), no? I&#39;m not sure whether 30 is expressed in degrees or radians :-) )<br></p><p>The important parts in the outlined vision are that:<br></p><p>the unit information is available as type information to the compiler; it checks that additions and subtractions use the same units and uses the correct derived type when you multiply/divide quantities with units;<br>you can easily add new &quot;fundamental&quot; units that would be very hard or impossible to derive from other units (meters, seconds, kilograms, radians, etc);<br>you can easily derive units from fundamental units (N = kg * m^1 * s^-2).<br></p><p>Right now, we can do #1. If this is what we&#39;re going for, then newtype isn&#39;t very important because it doesn&#39;t contribute that much to anything here (though if we decide that we don&#39;t need that much power, it would be a decent crutch).<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 07:06:01, James Campbell &lt;james at supmenow.com&gt; a écrit :<br>&gt; <br>&gt; So this is how this feature could be achieved right now with minimal changes to the language.<br>&gt; <br>&gt; - We expose some kind of protocol that allows you to Box up types, we could call this `Box` or something else like `Unit`. (I have a working implementation in the current language with a bit of boilerplate). This protocol handles the default implementation of converting from literals and to floats etc.<br>&gt; - For each type-safe unit for a calculation - you define a protocol extending this `Box` type which defines the associated type of the value that unit holds. For example for Degree and Radian I declared a `AngleType` which set the associated type to be a double. <br>&gt; - For each unit type, you declare a struct that inherits from that protocol you defined. So I have two structs `Degree` and `Radian` which implement the `AngleType` protocol.<br>&gt; - You implement the functions for figuring out if your units are equal and all other operators they may need i.e `Degree(360) - 30`.<br>&gt; <br>&gt; Future improvements with language updates:<br>&gt; <br>&gt; - `AngleType` protocol may not be needed if swift introduces generic protocols.<br>&gt; - Boilerplate in your type safe unit types may be reduced if swift introduces memberwise initialization.<br>&gt; - The current implementation of this system in Swift will be greatly simplified once the refactoring of Swift&#39;s Number types has been completed. We currently use a bunch of work arounds with the compiler.<br>&gt; - We could introduce custom user literals to create these types if swift supports this in the future (As Felix states).<br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 7:06 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; I&#39;d like to hijack this thread to talk about what the TI Voyage 200 could do as far as &quot;type-safe calculations&quot; go.<br>&gt; <br>&gt; The calculator supports symbolic equations (for instance, `a * 1000 / 2` results in `500a` when a isn&#39;t known). The interesting part is that you could append units to numbers. For instance, you can write `500_m`, and this means 500 meters. Numbers with a type can only be added/subtracted with numbers of the same type, but they can be multiplied or divided by pretty much anything. For instance, `500_m - 2_s` (500 meters minus 2 seconds) is an error, but `500_m / 2_s` is `250 (_m/_s)` (or _m * _s^-1).<br>&gt; <br>&gt; I found this *extremely* useful for engineering calculations. For instance, when you multiply quantities that should end up in Teslas, you know that you&#39;ve done something wrong if the unit displayed after the number doesn&#39;t look like `V * s * m^-2`. It was also a lifesaver that you could do something like `6_ft` and end up with 1.8288_m (because _ft is defined as 0.3048_m).<br>&gt; <br>&gt; I have no idea how you&#39;d implement that with Swift though. I&#39;m not a very powerful template wizard, but I have no idea how you&#39;d do it with C++ either.<br>&gt; <br>&gt; Of course, it might be a few years before you&#39;re allowed to use the Swift compiler during your physics exams, and I don&#39;t think that real-world programs often need that much unit safety with numbers. But when I read &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 01:42:07, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I think the name should be changed to NumberBox or something similar. A box is something very generic and should not have number related associated types.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; Am 06. Januar 2016 um 18:15 schrieb James Campbell &lt;james at supmenow.com &lt;mailto:james at supmenow.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve managed to implement this already in the language with a few ugly corners due to the lack of generic protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I created a protocol based on Box (https://github.com/robrix/Box/ &lt;https://github.com/robrix/Box/&gt;) which works really well. I have extended this to handle certain special protocols like Equatable so you can do SpecialType == SpecialType, and even literalConversion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is however a lot of boilerplate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You have to declare all of your Convertible protocols for converting from one type to another<br>&gt;&gt;&gt; - You have to define an empty init so the protocol extensions have something to chain to.<br>&gt;&gt;&gt; - You need to write the value property with type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Due to the lack of protocol generics, you also need to have a protocol for every type you wish to box which sets the associated type. Of course I could have done this with classes but I wanted to keep this as a value type :).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With member-wise initializations and generic protocols this could be achievable just by adding a Box protocol to the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is my implementation of Box as a protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Box: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias FloatLiteralType = Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias IntegerLiteralType = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias BoxType = Any<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var value: BoxType { get set }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(_ value: BoxType)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Box where BoxType: CustomStringConvertible {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var description: String {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         return self.value.description<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var debugDescription: String {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         return &quot;\(self.value.description)㎭&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //MARK: FloatingPointBox<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPointBox: Box, FloatLiteralConvertible, IntegerLiteralConvertible {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias BoxType = Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias FloatLiteralConvertible = Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias IntegerLiteralConvertible = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Box where Self.BoxType == Double {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(_ value: Double) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.value = value<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(_ value: Int) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.value = Double(value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension FloatLiteralType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(box.value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(box.value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension CGFloat {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(box.value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(box.value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //Adding FloatLiteralConvertible, IntegerLiteralConvertible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension FloatingPointBox where Self.BoxType == Double, Self.FloatLiteralConvertible == Double {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(floatLiteral value: Double) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(integerLiteral value: Int) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;T: IntegerType&gt;(_ value: T) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is my example of using the Box protocol:<br>&gt;&gt;&gt; struct Degree: FloatingPointBox {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var value: Double = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol DegreeConvertiable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(degreeLiteral value: Degree)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Degree: RadianConvertiable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(radianLiteral value: Radian) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.value = Double(value) * 180.0 / M_PI<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(_ value: Radian) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         self.init(radianLiteral: value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What about citing the relevant protocols in the newtype definition? This should include the ability to use my own protocols to which I have made the underlying type conform to by an extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is how my forwarding proposal works.  The newtype syntax I suggested as a possible extension looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The keyword could be different, but I think `forwarding` is not bad.  When I complete the second draft I think it will make even more sense.  The forwarding facility has features to handle non-trivial cases (Self and associated type requirements, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Throwing some syntax into the discussion:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere and made Double conform to them if all this is not provided by the standard library.<br>&gt;&gt;&gt; &gt; The implementation of Euro then borrows the implementation of Double for these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Thorsten<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;  Wizard<br>&gt;&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt;&gt;&gt; +44 7523 279 698 &lt;tel:%2B44%207523%20279%20698&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/a6d58601/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>I understand, I want to keep prototyping this with other units to see what<br>insight I can achieve.<br></p><p>Do we have a list of units we would like to model to serve as a suite of<br>tests and also to test any implementation we may need ?<br></p><p>On Thu, Jan 7, 2016 at 5:10 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; James, that works for degrees to radians, but I&#39;m afraid that one protocol<br>&gt; per unit simply can&#39;t scale if you want to multiply/divide quantities with<br>&gt; different units. Just look at the different things can make up a tesla<br>&gt; &lt;https://upload.wikimedia.org/math/d/c/1/dc1af6ed32aa3e906230cc15ea08a2a4.png&gt;.<br>&gt; The combination of units is factorial and defining like 24 protocols each<br>&gt; with multiplication and division operation to every other defined protocol<br>&gt; doesn&#39;t make sense. I&#39;d rather use &quot;untyped&quot; quantities if I had to do the<br>&gt; same thing in Swift right now.<br>&gt;<br>&gt; (By the way: Degree(360) - 30 should probably be Degree(360) - Degree(30),<br>&gt; no? I&#39;m not sure whether 30 is expressed in degrees or radians :-) )<br>&gt;<br>&gt; The important parts in the outlined vision are that:<br>&gt;<br>&gt;<br>&gt;    1. the unit information is available as type information to the<br>&gt;    compiler; it checks that additions and subtractions use the same units and<br>&gt;    uses the correct derived type when you multiply/divide quantities with<br>&gt;    units;<br>&gt;    2. you can easily add new &quot;fundamental&quot; units that would be very hard<br>&gt;    or impossible to derive from other units (meters, seconds, kilograms,<br>&gt;    radians, etc);<br>&gt;    3. you can easily derive units from fundamental units (N = kg * m^1 *<br>&gt;    s^-2).<br>&gt;<br>&gt;<br>&gt; Right now, we can do #1. If this is what we&#39;re going for, then newtype<br>&gt; isn&#39;t very important because it doesn&#39;t contribute that much to anything<br>&gt; here (though if we decide that we don&#39;t need that much power, it would be a<br>&gt; decent crutch).<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 7 janv. 2016 à 07:06:01, James Campbell &lt;james at supmenow.com&gt; a écrit :<br>&gt;<br>&gt; So this is how this feature could be achieved right now with minimal<br>&gt; changes to the language.<br>&gt;<br>&gt; - We expose some kind of protocol that allows you to Box up types, we<br>&gt; could call this `Box` or something else like `Unit`. (I have a working<br>&gt; implementation in the current language with a bit of boilerplate). This<br>&gt; protocol handles the default implementation of converting from literals and<br>&gt; to floats etc.<br>&gt; - For each type-safe unit for a calculation - you define a protocol<br>&gt; extending this `Box` type which defines the associated type of the value<br>&gt; that unit holds. For example for Degree and Radian I declared a `AngleType`<br>&gt; which set the associated type to be a double.<br>&gt; - For each unit type, you declare a struct that inherits from that<br>&gt; protocol you defined. So I have two structs `Degree` and `Radian` which<br>&gt; implement the `AngleType` protocol.<br>&gt; - You implement the functions for figuring out if your units are equal and<br>&gt; all other operators they may need i.e `Degree(360) - 30`.<br>&gt;<br>&gt; Future improvements with language updates:<br>&gt;<br>&gt; - `AngleType` protocol may not be needed if swift introduces generic<br>&gt; protocols.<br>&gt; - Boilerplate in your type safe unit types may be reduced if swift<br>&gt; introduces memberwise initialization.<br>&gt; - The current implementation of this system in Swift will be greatly<br>&gt; simplified once the refactoring of Swift&#39;s Number types has been completed.<br>&gt; We currently use a bunch of work arounds with the compiler.<br>&gt; - We could introduce custom user literals to create these types if swift<br>&gt; supports this in the future (As Felix states).<br>&gt;<br>&gt; On Thu, Jan 7, 2016 at 7:06 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;d like to hijack this thread to talk about what the TI Voyage 200 could<br>&gt;&gt; do as far as &quot;type-safe calculations&quot; go.<br>&gt;&gt;<br>&gt;&gt; The calculator supports symbolic equations (for instance, `a * 1000 / 2`<br>&gt;&gt; results in `500a` when a isn&#39;t known). The interesting part is that you<br>&gt;&gt; could append units to numbers. For instance, you can write `500_m`, and<br>&gt;&gt; this means 500 meters. Numbers with a type can only be added/subtracted<br>&gt;&gt; with numbers of the same type, but they can be multiplied or divided by<br>&gt;&gt; pretty much anything. For instance, `500_m - 2_s` (500 meters minus 2<br>&gt;&gt; seconds) is an error, but `500_m / 2_s` is `250 (_m/_s)` (or _m * _s^-1).<br>&gt;&gt;<br>&gt;&gt; I found this *extremely* useful for engineering calculations. For<br>&gt;&gt; instance, when you multiply quantities that should end up in Teslas, you<br>&gt;&gt; know that you&#39;ve done something wrong if the unit displayed after the<br>&gt;&gt; number doesn&#39;t look like `V * s * m^-2`. It was also a lifesaver that you<br>&gt;&gt; could do something like `6_ft` and end up with 1.8288_m (because _ft is<br>&gt;&gt; defined as 0.3048_m).<br>&gt;&gt;<br>&gt;&gt; I have no idea how you&#39;d implement that with Swift though. I&#39;m not a very<br>&gt;&gt; powerful template wizard, but I have no idea how you&#39;d do it with C++<br>&gt;&gt; either.<br>&gt;&gt;<br>&gt;&gt; Of course, it might be a few years before you&#39;re allowed to use the Swift<br>&gt;&gt; compiler during your physics exams, and I don&#39;t think that real-world<br>&gt;&gt; programs often need that much unit safety with numbers. But when I read<br>&gt;&gt; &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 7 janv. 2016 à 01:42:07, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I think the name should be changed to NumberBox or something similar. A<br>&gt;&gt; box is something very generic and should not have number related associated<br>&gt;&gt; types.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 06. Januar 2016 um 18:15 schrieb James Campbell &lt;james at supmenow.com&gt;:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve managed to implement this already in the language with a few ugly<br>&gt;&gt; corners due to the lack of generic protocols.<br>&gt;&gt;<br>&gt;&gt; I created a protocol based on Box (https://github.com/robrix/Box/) which<br>&gt;&gt; works really well. I have extended this to handle certain special protocols<br>&gt;&gt; like Equatable so you can do SpecialType == SpecialType, and even<br>&gt;&gt; literalConversion.<br>&gt;&gt;<br>&gt;&gt; There is however a lot of boilerplate:<br>&gt;&gt;<br>&gt;&gt; - You have to declare all of your Convertible protocols for converting<br>&gt;&gt; from one type to another<br>&gt;&gt; - You have to define an empty init so the protocol extensions have<br>&gt;&gt; something to chain to.<br>&gt;&gt; - You need to write the value property with type.<br>&gt;&gt;<br>&gt;&gt; Due to the lack of protocol generics, you also need to have a protocol<br>&gt;&gt; for every type you wish to box which sets the associated type. Of course I<br>&gt;&gt; could have done this with classes but I wanted to keep this as a value type<br>&gt;&gt; :).<br>&gt;&gt;<br>&gt;&gt; With member-wise initializations and generic protocols this could be<br>&gt;&gt; achievable just by adding a Box protocol to the standard library.<br>&gt;&gt;<br>&gt;&gt; Here is my implementation of Box as a protocol:<br>&gt;&gt;<br>&gt;&gt; *protocol Box: CustomStringConvertible, CustomDebugStringConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    typealias FloatLiteralType = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias IntegerLiteralType = Int*<br>&gt;&gt;<br>&gt;&gt; *    typealias BoxType = Any*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var value: BoxType { get set }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init()*<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: BoxType)*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Box where BoxType: CustomStringConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var description: String {*<br>&gt;&gt;<br>&gt;&gt; *        return self.value.description*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var debugDescription: String {*<br>&gt;&gt;<br>&gt;&gt; *        return &quot;\(self.value.description)㎭&quot;*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *//MARK: FloatingPointBox*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *protocol FloatingPointBox: Box, FloatLiteralConvertible,<br>&gt;&gt; IntegerLiteralConvertible {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    typealias BoxType = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias FloatLiteralConvertible = Double*<br>&gt;&gt;<br>&gt;&gt; *    typealias IntegerLiteralConvertible = Int*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Box where Self.BoxType == Double {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Double) {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *        self.init()*<br>&gt;&gt;<br>&gt;&gt; *        self.value = value*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Int) {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *        self.init()*<br>&gt;&gt;<br>&gt;&gt; *        self.value = Double(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension FloatLiteralType {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension CGFloat {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(box.value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *//Adding FloatLiteralConvertible, IntegerLiteralConvertible*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension FloatingPointBox where Self.BoxType == Double,<br>&gt;&gt; Self.FloatLiteralConvertible == Double {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(floatLiteral value: Double) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(integerLiteral value: Int) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init&lt;T: IntegerType&gt;(_ value: T) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt; Here is my example of using the Box protocol:<br>&gt;&gt;<br>&gt;&gt; *struct Degree: FloatingPointBox {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    var value: Double = 0*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init()*<br>&gt;&gt;<br>&gt;&gt; *    {*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *protocol DegreeConvertiable {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(degreeLiteral value: Degree)*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *extension Degree: RadianConvertiable {*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(radianLiteral value: Radian) {*<br>&gt;&gt;<br>&gt;&gt; *        self.value = Double(value) * 180.0 / M_PI*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *    init(_ value: Radian) {*<br>&gt;&gt;<br>&gt;&gt; *        self.init(radianLiteral: value)*<br>&gt;&gt;<br>&gt;&gt; *    }*<br>&gt;&gt;<br>&gt;&gt; *}*<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via<br>&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk<br>&gt;&gt;&gt; are different types, yet use their parent type at the binary level. This<br>&gt;&gt;&gt; needs a specific syntax to teach the compiler which existing<br>&gt;&gt;&gt; methods/operations are allowed on the new fake types and which aren’t.<br>&gt;&gt;&gt; These new distinct types would *borrow* previous implementations.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What about citing the relevant protocols in the newtype definition?<br>&gt;&gt;&gt; This should include the ability to use my own protocols to which I have<br>&gt;&gt;&gt; made the underlying type conform to by an extension.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is how my forwarding proposal works.  The newtype syntax I<br>&gt;&gt;&gt; suggested as a possible extension looks like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The keyword could be different, but I think `forwarding` is not bad.<br>&gt;&gt;&gt; When I complete the second draft I think it will make even more sense.  The<br>&gt;&gt;&gt; forwarding facility has features to handle non-trivial cases (Self and<br>&gt;&gt;&gt; associated type requirements, etc).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Throwing some syntax into the discussion:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere<br>&gt;&gt;&gt; and made Double conform to them if all this is not provided by the standard<br>&gt;&gt;&gt; library.<br>&gt;&gt;&gt; &gt; The implementation of Euro then borrows the implementation of Double<br>&gt;&gt;&gt; for these protocols.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Thorsten<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;  Wizard<br>&gt;&gt; james at supmenow.com<br>&gt;&gt; +44 7523 279 698<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/b46a8e4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>The list of SI Units (https://en.wikipedia.org/wiki/International_System_of_Units#Units_and_prefixes) is probably a pretty good target. Might be a bit much to bite off all at once, though.<br></p><p>&gt; On Jan 7, 2016, at 09:25, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I understand, I want to keep prototyping this with other units to see what insight I can achieve.<br>&gt; <br>&gt; Do we have a list of units we would like to model to serve as a suite of tests and also to test any implementation we may need ?<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/154b79f484b74617fe0bea7b5cc5c35a?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Grzegorz Adam Hankiewicz</string> &lt;swift at gradha.imap.cc&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; El 7/1/2016, a las 8:06, Félix Cloutier &lt;felixcca at yahoo.ca&gt; escribió:<br>&gt; <br>&gt; I’d like to hijack this thread to talk about what the TI Voyage 200 could do as far as &quot;type-safe calculations&quot; go.<br></p><p>I don’t think you are hijacking it, I share your vision, but it seems drowned among all the protocol-wielding users.<br></p><p>&gt; I’m not a very powerful template wizard, but I have no idea how you&#39;d do it with C++ either.<br></p><p>See http://stackoverflow.com/questions/23726038/how-can-i-create-a-new-primitive-type-using-c11-style-strong-typedefs for that.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; that much unit safety with numbers. But when I read &quot;epic typesafe calculations&quot;, that&#39;s what I think about.<br>me to ;-) — and I want this to work with force vectors, matrices and tensors as well.<br>But I&#39;m quite sure that composed units are the hardest part, and I don&#39;t think it will be possible in Swift 3.<br></p><p>I would like to start with tiny steps, and afaics, we miss a protocol that denotes that something can be added and substracted, don&#39;t we?<br></p><p>So, I think a first tiny proposal would be to add protocols for groups, rings &amp; bodys, and add make the numeric types conform to them.<br></p><p>Meanwhile, I pushed a tiny playground to github - it is quite chaotic, but it allows you to do stuff like<br>let f0 = Force.Newton(1)<br>let f1 = Force.Kilopound(1)<br>print(10.0*f0 + f1/444.8221615255)<br></p><p>https://github.com/SwiftTypesafeCalculations/Units &lt;https://github.com/SwiftTypesafeCalculations/Units&gt;<br></p><p>I did also start an &quot;organization&quot; at github and to see how this infrastructure can be leveraged to channel the discussion without loosing track.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/5c527848/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
