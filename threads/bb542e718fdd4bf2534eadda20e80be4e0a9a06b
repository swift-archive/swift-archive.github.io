<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I have a problem with the way floating point ranges work with striding:<br>1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>(And yes, the same issue exists with tradition C-style for loops).<br></p><p>Would it be really horrible if the implementation and definition was changed to:  <br>&quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>This would offer no change for integers, and include 2.0 for floating point sequences. <br></p><p>Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>1.0.stride(through: 2.0, by: 0.1, places: 1)<br></p><p>I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br></p><p>Thanks for your thoughts,<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/bb54a06b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>February 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 27 Feb 2016, at 01:12, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a problem with the way floating point ranges work with striding:<br>&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt; (And yes, the same issue exists with tradition C-style for loops).<br></p><p>The documentation is a bit weird. &quot;It returns the sequence where last is less than or equal to `end`.” seems to tacitly assume that we’re talking about the longest possible sequence with that property. With your proposed &quot;It returns the sequence where last is greater than or equal to `end`?” we’re now talking about the shortest possible sequence with that property.<br></p><p>But what do you mean “no change for integers”? What about 1.stride(through: 10, by: 8)? Wouldn’t that return [1, 9] now and [1, 9, 17] with your change?<br></p><p>—S<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/f5302311/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; The documentation is a bit weird. &quot;It returns the sequence where last is less than or equal to `end`.” seems to tacitly assume that we’re talking about the longest possible sequence with that property. With your proposed &quot;It returns the sequence where last is greater than or equal to `end`?” we’re now talking about the shortest possible sequence with that property.<br>&gt; <br>&gt; But what do you mean “no change for integers”? What about 1.stride(through: 10, by: 8)? Wouldn’t that return [1, 9] now and [1, 9, 17] with your change?<br></p><p>It means, I&#39;m wrong about that. Fixing here, both in code and in text: https://gist.github.com/erica/03c398c06f6c47824429<br></p><p>print(Array(1.stride(through: 10, by: 8)))<br>[1, 9]<br></p><p>print(Array(1.stride(through2: 10, by: 8))) // my test implementation<br>[1, 9, 17]<br></p><p>The second progress now goes *through* 10.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/33ed9358/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Following up to myself. Thoughts and feedback are welcome. -- Erica<br></p><p>Changing the Behavior of StrideThroughGenerator<br></p><p>Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br></p><p>Current Art<br></p><p>A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>the progression that is less than end. <br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br></p><p>Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br></p><p>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>/// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br></p><p>print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>/// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>This is problematic for the following reasons: <br></p><p>The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>Floating point calls present an extremely common use-case<br>It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>Proposed Modifications<br></p><p>I recommend the following changes: <br></p><p>Change the documentation text from<br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br></p><p>to <br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br></p><p>Modify the implementation<br></p><p>Current:<br></p><p>    /// Advance to the next element and return it, or `nil` if no next<br>    /// element exists.<br>    public mutating func next() -&gt; Element? {<br>        if done {<br>            return nil<br>        }<br>        if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>            if current == end {<br>                done = true<br>                return current<br>            }<br>            return nil<br>        }<br>        let result = current<br>        current += stride<br>        return result<br>    }<br>Proposed:<br></p><p>    /// Advance to the next element and return it, or `nil` if no next<br>    /// element exists.<br>    public mutating func next() -&gt; Element? {<br>        if done {<br>            return nil<br>        }<br>        if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>            // NOTE: `current &gt;= end` and not `current == end`<br>            if current &gt;= end {<br>                done = true<br>                return current<br>            }<br>            return nil<br>        }<br>        let result = current<br>        current += stride<br>        return result<br>    }<br>}<br>Introduced Changes<br></p><p>Under these changes, the following progression ends at 2.0 not 1.9:<br></p><p>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>// prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>Integer progressions are unchanged:<br></p><p>print(Array(1.stride(through2: 10, by: 1))) <br>/// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>Floating point strides will extend up-to or past the through value:<br></p><p>// Old<br>print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>// prints [1.0, 1.25, 1.5, 1.75]<br></p><p><br>// New<br>print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>// prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>Alternates Considered<br></p><p>Other changes could include: <br></p><p>Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br></p><p><br>&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a problem with the way floating point ranges work with striding:<br>&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt; <br>&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt; <br>&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt; <br>&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt; <br>&gt; Thanks for your thoughts,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/ab94455c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 27, 2016 at 11:00:00pm</p></header><div class="content"><p>If this happened how would legacy code be handled and a migratory written. I&#39;m really nervous about small changes to semantics causing bugs. Would be more comfortable if the &#39;through&#39; argument was renamed to force people to reconsider and check their code. It shouldn&#39;t have a migratory and the error on calling the old through variant should produce a very informative warning describing the semantic change.<br></p><p>Whether the change is worthwhile at all I&#39;m not entirely sure, I haven&#39;t floating point stride much. <br></p><p>Joseph<br></p><p>&gt; On Feb 27, 2016, at 11:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt; <br>&gt; Changing the Behavior of StrideThroughGenerator<br>&gt; <br>&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt; <br>&gt; Current Art<br>&gt; <br>&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt; the progression that is less than end. <br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; This is problematic for the following reasons: <br>&gt; <br>&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt; Floating point calls present an extremely common use-case<br>&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt; Proposed Modifications<br>&gt; <br>&gt; I recommend the following changes: <br>&gt; <br>&gt; Change the documentation text from<br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; to <br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; Modify the implementation<br>&gt; <br>&gt; Current:<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Element? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;             if current == end {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         let result = current<br>&gt;         current += stride<br>&gt;         return result<br>&gt;     }<br>&gt; Proposed:<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Element? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;             if current &gt;= end {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         let result = current<br>&gt;         current += stride<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt; Introduced Changes<br>&gt; <br>&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; Integer progressions are unchanged:<br>&gt; <br>&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt; Floating point strides will extend up-to or past the through value:<br>&gt; <br>&gt; // Old<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt; <br>&gt; <br>&gt; // New<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt; Alternates Considered<br>&gt; <br>&gt; Other changes could include: <br>&gt; <br>&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt; <br>&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt; <br>&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt; <br>&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type?) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt; <br>&gt;&gt; Thanks for your thoughts,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/c1818230/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>This is a really good point, and while I don&#39;t have a recommended direction, am adding to the write-up because it is so important.<br></p><p>-- E<br></p><p><br>&gt; On Feb 27, 2016, at 4:59 PM, Joseph Lord &lt;joseph at human-friendly.com&gt; wrote:<br>&gt; <br>&gt; If this happened how would legacy code be handled and a migratory written. I&#39;m really nervous about small changes to semantics causing bugs. Would be more comfortable if the &#39;through&#39; argument was renamed to force people to reconsider and check their code. It shouldn&#39;t have a migratory and the error on calling the old through variant should produce a very informative warning describing the semantic change.<br>&gt; <br>&gt; Whether the change is worthwhile at all I&#39;m not entirely sure, I haven&#39;t floating point stride much. <br>&gt; <br>&gt; Joseph<br>&gt; <br>&gt; On Feb 27, 2016, at 11:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt;&gt; <br>&gt;&gt; Changing the Behavior of StrideThroughGenerator<br>&gt;&gt; <br>&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt;&gt; <br>&gt;&gt; Current Art<br>&gt;&gt; <br>&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt;&gt; the progression that is less than end. <br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; This is problematic for the following reasons: <br>&gt;&gt; <br>&gt;&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt;&gt; Floating point calls present an extremely common use-case<br>&gt;&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt;&gt; Proposed Modifications<br>&gt;&gt; <br>&gt;&gt; I recommend the following changes: <br>&gt;&gt; <br>&gt;&gt; Change the documentation text from<br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; to <br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; Modify the implementation<br>&gt;&gt; <br>&gt;&gt; Current:<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;     /// element exists.<br>&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;         if done {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;             if current == end {<br>&gt;&gt;                 done = true<br>&gt;&gt;                 return current<br>&gt;&gt;             }<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         let result = current<br>&gt;&gt;         current += stride<br>&gt;&gt;         return result<br>&gt;&gt;     }<br>&gt;&gt; Proposed:<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;     /// element exists.<br>&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;         if done {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;&gt;             if current &gt;= end {<br>&gt;&gt;                 done = true<br>&gt;&gt;                 return current<br>&gt;&gt;             }<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         let result = current<br>&gt;&gt;         current += stride<br>&gt;&gt;         return result<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Introduced Changes<br>&gt;&gt; <br>&gt;&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; Integer progressions are unchanged:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt;&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt; Floating point strides will extend up-to or past the through value:<br>&gt;&gt; <br>&gt;&gt; // Old<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // New<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt; Alternates Considered<br>&gt;&gt; <br>&gt;&gt; Other changes could include: <br>&gt;&gt; <br>&gt;&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt;&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt;&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your thoughts,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/5ce90d3c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 4:59 PM, Joseph Lord &lt;joseph at human-friendly.com&gt; wrote:<br>&gt; <br>&gt; If this happened how would legacy code be handled and a migratory written. I&#39;m really nervous about small changes to semantics causing bugs. Would be more comfortable if the &#39;through&#39; argument was renamed to force people to reconsider and check their code. It shouldn&#39;t have a migratory and the error on calling the old through variant should produce a very informative warning describing the semantic change.<br></p><p><br>Impact on Existing Code<br></p><p>If this change were adopted, it could affect legacy code semantics written under current behaviors and assumptions. A migrator would not easily identify in-place workarounds like the through: 2.01 epsilon adjustment. I&#39;d recommend adding &quot;FIXME:&quot; notes wherever through: is found to warn against continued use without a full inspection, offering links to information about the semantic changes.<br></p><p>Although renaming the through argument is another valid approach, renaming works against the proposed point that adapting through semantics better match what &quot;through&quot; actually means.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/7a2e50fc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; This is problematic for the following reasons: <br>&gt; <br>&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt; Floating point calls present an extremely common use-case<br>&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>As implemented, `stride` is broken for floating-point numbers. Instead of repeatedly adding the `by` interval, it should multiply the interval by successive integral values and add that to the base to avoid accruing error. Your proposal only papers over the problem.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/7e3551fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; As implemented, `stride` is broken for floating-point numbers. Instead of repeatedly adding the `by` interval, it should multiply the interval by successive integral values and add that to the base to avoid accruing error. Your proposal only papers over the problem.<br>&gt; <br>&gt; -Joe<br></p><p>Agreed. This is &quot;papering over the problem&quot; of accumulated floating point error.  There are two issues being addressed:<br></p><p>1. Semantics of `through` do not match their promise of going through the end point rather than stopping at it or before.<br>2. Floating point strides accumulate errors by repeatedly adding the `by` interval.<br></p><p>I mention issue 2 in the alternative implementations: https://gist.github.com/erica/03c398c06f6c47824429<br></p><p>Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br></p><p>If you were addressing issue 2, what approach would you suggest:<br></p><p>* Differentiating integer strides from floating point, and minimizing floating point errors?<br>* Leaving the tech as-is with minimal code change with a relatively high benefit?<br></p><p>In both cases, I&#39;d still prefer the semantics to *go through* the end point, not just stop at it, which is issue 1.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/b6014b84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I think you have raised a valid concern. But would suggest a simpler<br>solution, remove stride for floating point. You can always write:<br></p><p>100.stride(through: 200, by 25).map { $0 / 100.0 }<br></p><p>On Sunday, 28 February 2016, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As implemented, `stride` is broken for floating-point numbers. Instead of<br>&gt; repeatedly adding the `by` interval, it should multiply the interval by<br>&gt; successive integral values and add that to the base to avoid accruing<br>&gt; error. Your proposal only papers over the problem.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; Agreed. This is &quot;papering over the problem&quot; of accumulated floating point<br>&gt; error.  There are two issues being addressed:<br>&gt;<br>&gt; 1. Semantics of `through` do not match their promise of going through the<br>&gt; end point rather than stopping at it or before.<br>&gt; 2. Floating point strides accumulate errors by repeatedly adding the `by`<br>&gt; interval.<br>&gt;<br>&gt; I mention issue 2 in the alternative implementations:<br>&gt; https://gist.github.com/erica/03c398c06f6c47824429<br>&gt;<br>&gt;<br>&gt;    - Counting expected iterations by forming (max - min) / by, e.g. (2.0<br>&gt;    - 1.0) / 0.1, which is 10, and performing each step as a pro-rated<br>&gt;    progression along those steps, which would remove most of the accumulated<br>&gt;    floating point errors along the way.<br>&gt;<br>&gt;<br>&gt; If you were addressing issue 2, what approach would you suggest:<br>&gt;<br>&gt; * Differentiating integer strides from floating point, and minimizing<br>&gt; floating point errors?<br>&gt; * Leaving the tech as-is with minimal code change with a relatively high<br>&gt; benefit?<br>&gt;<br>&gt; In both cases, I&#39;d still prefer the semantics to *go through* the end<br>&gt; point, not just stop at it, which is issue 1.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/e7bc8da8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;d really dislike any solution that makes Swift programming worse than where it currently is. <br></p><p>-- E<br></p><p><br>&gt; On Feb 27, 2016, at 6:28 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think you have raised a valid concern. But would suggest a simpler solution, remove stride for floating point. You can always write:<br>&gt; <br>&gt; 100.stride(through: 200, by 25).map { $0 / 100.0 }<br>&gt; <br>&gt; On Sunday, 28 February 2016, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; As implemented, `stride` is broken for floating-point numbers. Instead of repeatedly adding the `by` interval, it should multiply the interval by successive integral values and add that to the base to avoid accruing error. Your proposal only papers over the problem.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Agreed. This is &quot;papering over the problem&quot; of accumulated floating point error.  There are two issues being addressed:<br>&gt; <br>&gt; 1. Semantics of `through` do not match their promise of going through the end point rather than stopping at it or before.<br>&gt; 2. Floating point strides accumulate errors by repeatedly adding the `by` interval.<br>&gt; <br>&gt; I mention issue 2 in the alternative implementations: https://gist.github.com/erica/03c398c06f6c47824429 &lt;https://gist.github.com/erica/03c398c06f6c47824429&gt;<br>&gt; <br>&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt; <br>&gt; If you were addressing issue 2, what approach would you suggest:<br>&gt; <br>&gt; * Differentiating integer strides from floating point, and minimizing floating point errors?<br>&gt; * Leaving the tech as-is with minimal code change with a relatively high benefit?<br>&gt; <br>&gt; In both cases, I&#39;d still prefer the semantics to *go through* the end point, not just stop at it, which is issue 1.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/98d83e5b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>I hope I’m not missing something, but I think Erica’s point on #1 is really important. When I originally learned about stride I assumed that the meaning of though was entirely different than what it really was. Erica’s idea brings it inline with my expectation based on its name.<br></p><p>Ignoring floating point entirely (which is still problematic):<br></p><p>print(Array(1.stride(through: 16, by: 7)))   <br>// prints [1, 8, 15]<br>// I would expect [1, 8, 15, 22]<br>print(Array(1.stride(to: 16, by: 7)))        <br>// prints [1, 8, 15]<br>The only cases where through behaves as I expect in the integer case is when the stride is a factor of through.<br></p><p>I do understand why someone would want to have a stride that ends on the terminal number if it equal, and not go over, but it feels like a label such as including, or something similar, would be more appropriate.<br></p><p>- Will<br></p><p><br></p><p><br></p><p>On February 27, 2016 at 5:06:36 PM, Erica Sadun via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>As implemented, `stride` is broken for floating-point numbers. Instead of repeatedly adding the `by` interval, it should multiply the interval by successive integral values and add that to the base to avoid accruing error. Your proposal only papers over the problem.<br></p><p>-Joe<br></p><p>Agreed. This is &quot;papering over the problem&quot; of accumulated floating point error.  There are two issues being addressed:<br></p><p>1. Semantics of `through` do not match their promise of going through the end point rather than stopping at it or before.<br>2. Floating point strides accumulate errors by repeatedly adding the `by` interval.<br></p><p>I mention issue 2 in the alternative implementations: https://gist.github.com/erica/03c398c06f6c47824429<br></p><p>Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br></p><p>If you were addressing issue 2, what approach would you suggest:<br></p><p>* Differentiating integer strides from floating point, and minimizing floating point errors?<br>* Leaving the tech as-is with minimal code change with a relatively high benefit?<br></p><p>In both cases, I&#39;d still prefer the semantics to *go through* the end point, not just stop at it, which is issue 1.<br></p><p>-- E<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/9a3d153c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 6:41 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt; <br>&gt; I hope I’m not missing something, but I think Erica’s point on #1 is really important. When I originally learned about stride I assumed that the meaning of though was entirely different than what it really was. Erica’s idea brings it inline with my expectation based on its name.<br>&gt; <br>&gt; <br></p><p>The English definition of through is &quot;expressing the position or location of something beyond or at the far end of (an opening or an obstacle)&quot;.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/95fc67e6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Erica,<br></p><p>With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br></p><p>In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br></p><p>—CK<br></p><p>&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt; <br>&gt; Changing the Behavior of StrideThroughGenerator<br>&gt; <br>&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt; <br>&gt; Current Art<br>&gt; <br>&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt; the progression that is less than end. <br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; This is problematic for the following reasons: <br>&gt; <br>&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt; Floating point calls present an extremely common use-case<br>&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt; Proposed Modifications<br>&gt; <br>&gt; I recommend the following changes: <br>&gt; <br>&gt; Change the documentation text from<br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; to <br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt; <br>&gt; Modify the implementation<br>&gt; <br>&gt; Current:<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Element? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;             if current == end {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         let result = current<br>&gt;         current += stride<br>&gt;         return result<br>&gt;     }<br>&gt; Proposed:<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Element? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;             if current &gt;= end {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         let result = current<br>&gt;         current += stride<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt; Introduced Changes<br>&gt; <br>&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; Integer progressions are unchanged:<br>&gt; <br>&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt; Floating point strides will extend up-to or past the through value:<br>&gt; <br>&gt; // Old<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt; <br>&gt; <br>&gt; // New<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt; Alternates Considered<br>&gt; <br>&gt; Other changes could include: <br>&gt; <br>&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt; <br>&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt; <br>&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt; <br>&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt; <br>&gt;&gt; Thanks for your thoughts,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/8ea296af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 06:00:00pm</p></header><div class="content"><p>Would you accept a third version then? towards (to, `[a, b)`), to (through, `[a, b]`), and through (new, `[a, &gt;=b]` &lt;-- not sure that even has a representation)?<br></p><p>-- E<br></p><p><br>&gt; On Feb 27, 2016, at 6:25 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br>&gt; <br>&gt; In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt;&gt; <br>&gt;&gt; Changing the Behavior of StrideThroughGenerator<br>&gt;&gt; <br>&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt;&gt; <br>&gt;&gt; Current Art<br>&gt;&gt; <br>&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt;&gt; the progression that is less than end. <br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; This is problematic for the following reasons: <br>&gt;&gt; <br>&gt;&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt;&gt; Floating point calls present an extremely common use-case<br>&gt;&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt;&gt; Proposed Modifications<br>&gt;&gt; <br>&gt;&gt; I recommend the following changes: <br>&gt;&gt; <br>&gt;&gt; Change the documentation text from<br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; to <br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt; <br>&gt;&gt; Modify the implementation<br>&gt;&gt; <br>&gt;&gt; Current:<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;     /// element exists.<br>&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;         if done {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;             if current == end {<br>&gt;&gt;                 done = true<br>&gt;&gt;                 return current<br>&gt;&gt;             }<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         let result = current<br>&gt;&gt;         current += stride<br>&gt;&gt;         return result<br>&gt;&gt;     }<br>&gt;&gt; Proposed:<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;     /// element exists.<br>&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;         if done {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;&gt;             if current &gt;= end {<br>&gt;&gt;                 done = true<br>&gt;&gt;                 return current<br>&gt;&gt;             }<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         let result = current<br>&gt;&gt;         current += stride<br>&gt;&gt;         return result<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Introduced Changes<br>&gt;&gt; <br>&gt;&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; Integer progressions are unchanged:<br>&gt;&gt; <br>&gt;&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt;&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt; Floating point strides will extend up-to or past the through value:<br>&gt;&gt; <br>&gt;&gt; // Old<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // New<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt; Alternates Considered<br>&gt;&gt; <br>&gt;&gt; Other changes could include: <br>&gt;&gt; <br>&gt;&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt;&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt;&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your thoughts,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/483b73fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 5:38 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Would you accept a third version then? towards (to, `[a, b)`), to (through, `[a, b]`), and through (new, `[a, &gt;=b]` &lt;-- not sure that even has a representation)?<br></p><p>No objection here. It’s a really interesting problem you’ve pointed out. I’m not sure yet the best way to minimize it.<br></p><p>—CK<br></p><p>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 6:25 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br>&gt;&gt; <br>&gt;&gt; In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br>&gt;&gt; <br>&gt;&gt; —CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Changing the Behavior of StrideThroughGenerator<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Current Art<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt;&gt;&gt; the progression that is less than end. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt;&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt; This is problematic for the following reasons: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt;&gt;&gt; Floating point calls present an extremely common use-case<br>&gt;&gt;&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt;&gt;&gt; Proposed Modifications<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I recommend the following changes: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Change the documentation text from<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modify the implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Current:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;             if current == end {<br>&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; Proposed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;&gt;&gt;             if current &gt;= end {<br>&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Introduced Changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt; Integer progressions are unchanged:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt;&gt;&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt;&gt; Floating point strides will extend up-to or past the through value:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt;&gt; Alternates Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other changes could include: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt;&gt;&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt;&gt;&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt;&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt;&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt;&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt;&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for your thoughts,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/390ea0d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve updated the proposal to take this into account: https://gist.github.com/erica/03c398c06f6c47824429<br></p><p>It makes two core recommendations:<br></p><p>1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>2. Break floating point strides away from Strideable to provide their own stride method implementations.<br></p><p>-- E<br></p><p><br>&gt; On Feb 27, 2016, at 8:07 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 5:38 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would you accept a third version then? towards (to, `[a, b)`), to (through, `[a, b]`), and through (new, `[a, &gt;=b]` &lt;-- not sure that even has a representation)?<br>&gt; <br>&gt; No objection here. It’s a really interesting problem you’ve pointed out. I’m not sure yet the best way to minimize it.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 27, 2016, at 6:25 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —CK<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Changing the Behavior of StrideThroughGenerator<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Current Art<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt;&gt;&gt;&gt; the progression that is less than end. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt;&gt;&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt;&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt;&gt; This is problematic for the following reasons: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt;&gt;&gt;&gt; Floating point calls present an extremely common use-case<br>&gt;&gt;&gt;&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt;&gt;&gt;&gt; Proposed Modifications<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I recommend the following changes: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Change the documentation text from<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Modify the implementation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Current:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;&gt;             if current == end {<br>&gt;&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; Proposed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;&gt;&gt;&gt;             if current &gt;= end {<br>&gt;&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Introduced Changes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt;&gt; Integer progressions are unchanged:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt;&gt;&gt;&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt;&gt;&gt; Floating point strides will extend up-to or past the through value:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt;&gt;&gt; Alternates Considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other changes could include: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt;&gt;&gt;&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt;&gt;&gt;&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt;&gt;&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt;&gt;&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt;&gt;&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt;&gt;&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for your thoughts,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/705036e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>Cheers,<br></p><p>Curt<br></p><p>&gt; On Feb 27, 2016, at 10:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve updated the proposal to take this into account: https://gist.github.com/erica/03c398c06f6c47824429<br>&gt; <br>&gt; It makes two core recommendations:<br>&gt; <br>&gt; 1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>&gt; 2. Break floating point strides away from Strideable to provide their own stride method implementations.<br></p><p>I don&#39;t have a strong opinion on the proposal. These sorts of strides are rare in the problem domains I work in. I would like to nitpick the proposed documentation for the new stride(through:,by:). The revised proposal gives the new documentation as:<br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence.<br></p><p><br>That should read “where last is the **first** value in the progression that is greater than or  equal to end.“ As proposed, last would be the largest number representable in self’s type that is a multiple of stride greater than self. That’s not the intent.<br></p><p>Cheers, <br></p><p>Curt<br></p><p>-------------------------<br>Curt Clifton, PhD <br>Software Developer <br>The Omni Group <br>www.curtclifton.net <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/a1e09703/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 28, 2016 at 10:00:00am</p></header><div class="content"><p>Reload and check please. https://gist.github.com/erica/03c398c06f6c47824429 &lt;https://gist.github.com/erica/03c398c06f6c47824429&gt;<br></p><p>-- E<br></p><p>&gt; On Feb 28, 2016, at 9:55 AM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; On Feb 27, 2016, at 10:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve updated the proposal to take this into account: https://gist.github.com/erica/03c398c06f6c47824429 &lt;https://gist.github.com/erica/03c398c06f6c47824429&gt;<br>&gt;&gt; <br>&gt;&gt; It makes two core recommendations:<br>&gt;&gt; <br>&gt;&gt; 1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>&gt;&gt; 2. Break floating point strides away from Strideable to provide their own stride method implementations.<br>&gt; <br>&gt; I don&#39;t have a strong opinion on the proposal. These sorts of strides are rare in the problem domains I work in. I would like to nitpick the proposed documentation for the new stride(through:,by:). The revised proposal gives the new documentation as:<br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence.<br>&gt; <br>&gt; <br>&gt; That should read “where last is the **first** value in the progression that is greater than or  equal to end.“ As proposed, last would be the largest number representable in self’s type that is a multiple of stride greater than self. That’s not the intent.<br>&gt; <br>&gt; Cheers, <br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; -------------------------<br>&gt; Curt Clifton, PhD <br>&gt; Software Developer <br>&gt; The Omni Group <br>&gt; www.curtclifton.net &lt;http://www.curtclifton.net/&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/046e5e79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>February 28, 2016 at 09:00:00am</p></header><div class="content"><p>Looks good!<br></p><p>Cheers,<br></p><p>Curt<br></p><p><br>&gt; On Feb 28, 2016, at 9:18 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Reload and check please. https://gist.github.com/erica/03c398c06f6c47824429<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Feb 28, 2016, at 9:55 AM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Curt<br>&gt;&gt; <br>&gt;&gt; On Feb 27, 2016, at 10:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve updated the proposal to take this into account: https://gist.github.com/erica/03c398c06f6c47824429<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It makes two core recommendations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>&gt;&gt;&gt; 2. Break floating point strides away from Strideable to provide their own stride method implementations.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t have a strong opinion on the proposal. These sorts of strides are rare in the problem domains I work in. I would like to nitpick the proposed documentation for the new stride(through:,by:). The revised proposal gives the new documentation as:<br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That should read “where last is the **first** value in the progression that is greater than or  equal to end.“ As proposed, last would be the largest number representable in self’s type that is a multiple of stride greater than self. That’s not the intent.<br>&gt;&gt; <br>&gt;&gt; Cheers, <br>&gt;&gt; <br>&gt;&gt; Curt<br>&gt;&gt; <br>&gt;&gt; -------------------------<br>&gt;&gt; Curt Clifton, PhD <br>&gt;&gt; Software Developer <br>&gt;&gt; The Omni Group <br>&gt;&gt; www.curtclifton.net <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/6cf0a97a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>February 28, 2016 at 02:00:00pm</p></header><div class="content"><p>On 2/28/16 03:03, Erica Sadun via swift-evolution wrote:<br>&gt; I&#39;ve updated the proposal to take this into account: https://gist.github.com/erica/03c398c06f6c47824429<br>&gt; <br>&gt; It makes two core recommendations:<br>&gt; <br>&gt; 1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>&gt; 2. Break floating point strides away from Strideable to provide their own stride method implementations.<br></p><p>I&#39;m just a humble superannuated practitioner, but I&#39;ve lost count of the<br>many times that I&#39;ve alerted people to the problems of binary floating<br>point.<br></p><p>I would argue that one of the issues to be fixed in<br>	print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>is that the compiler should, at least, emit a warning when seeing 0.1<br>(or 0.01 etc.) along the lines of &quot;not a valid floating point constant&quot;.<br></p><p>No doubt the appropriate xyzLiteralConvertible type could be made to<br>complain strenuously.<br></p><p>The safety aims of Swift are very commendable but I submit tolerating a<br>0.1 constant to be assigned to a binary floating point type is extremely<br>unsafe!<br></p><p>Of course requiring floating point constants to be always written in<br>binary/hex is too much to ask of the &quot;forloopians&quot; (LOVE this word!),<br>but isn&#39;t having a warning reasonable?<br></p><p>Perhaps, even, we could have a notation like ~0.1 to turn the warning<br>off and to tell the compiler to use the &quot;binary value most close to&quot;<br>that constant.<br></p><p>I probably lack the qualifications to write this up according to the<br>required formalities but will be glad to assist anyone to do so, if<br>necessary.<br></p><p><br>&gt;&gt; On Feb 27, 2016, at 8:07 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Feb 27, 2016, at 5:38 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would you accept a third version then? towards (to, `[a, b)`), to (through, `[a, b]`), and through (new, `[a, &gt;=b]` &lt;-- not sure that even has a representation)?<br>&gt;&gt;<br>&gt;&gt; No objection here. It’s a really interesting problem you’ve pointed out. I’m not sure yet the best way to minimize it.<br>&gt;&gt;<br>&gt;&gt; —CK<br>&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Feb 27, 2016, at 6:25 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; —CK<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Changing the Behavior of StrideThroughGenerator<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). I propose to change the way the through variation works. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Current Art<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in<br>&gt;&gt;&gt;&gt;&gt; the progression that is less than end. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt;&gt;&gt;&gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.01, by: 0.1)))<br>&gt;&gt;&gt;&gt;&gt; /// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt;&gt;&gt; This is problematic for the following reasons: <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The name of the calling function “through” suggests the progression will pass through the end point before stopping<br>&gt;&gt;&gt;&gt;&gt; Floating point calls present an extremely common use-case<br>&gt;&gt;&gt;&gt;&gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by using through rather than to”<br>&gt;&gt;&gt;&gt;&gt; Proposed Modifications<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I recommend the following changes: <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Change the documentation text from<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; to <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression greater than or equal to end. There is no guarantee that end is an element of the sequence. <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Modify the implementation<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Current:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;&gt;&gt;             if current == end {<br>&gt;&gt;&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; Proposed:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt;&gt;&gt;     /// element exists.<br>&gt;&gt;&gt;&gt;&gt;     public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;         if done {<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt;&gt;&gt;             // NOTE: `current &gt;= end` and not `current == end`<br>&gt;&gt;&gt;&gt;&gt;             if current &gt;= end {<br>&gt;&gt;&gt;&gt;&gt;                 done = true<br>&gt;&gt;&gt;&gt;&gt;                 return current<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         let result = current<br>&gt;&gt;&gt;&gt;&gt;         current += stride<br>&gt;&gt;&gt;&gt;&gt;         return result<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Introduced Changes<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt;&gt;&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt;&gt;&gt;&gt; Integer progressions are unchanged:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.stride(through2: 10, by: 1))) <br>&gt;&gt;&gt;&gt;&gt; /// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt;&gt;&gt;&gt; Floating point strides will extend up-to or past the through value:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt;&gt;&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt;&gt;&gt;&gt; Alternates Considered<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Other changes could include: <br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Introducing a digitalStride function with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt;&gt;&gt;&gt;&gt; Counting expected iterations by forming (max - min) / by, e.g. (2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt;&gt;&gt;&gt;&gt; Introducing a DecimalNumber type, with its own stride methods, e.g. DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I have a problem with the way floating point ranges work with striding:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1) returns the sequence [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].  <br>&gt;&gt;&gt;&gt;&gt;&gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Would it be really horrible if the implementation and definition was changed to:  <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; This would offer no change for integers, and include 2.0 for floating point sequences. <br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatively, could there be decimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type? &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal&gt;) as well, but this could fix an ongoing annoyance without a major change.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for your thoughts,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p><br>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
