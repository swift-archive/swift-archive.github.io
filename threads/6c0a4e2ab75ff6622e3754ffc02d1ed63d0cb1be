<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>@noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br></p><p>What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 20, 2015 at 11:00:00am</p></header><div class="content"><p>:+1: if it is more common, perhaps even if it isn&#39;t. Although I don&#39;t think<br>the standard library is the right place to look. I&#39;m pretty sure if you did<br>the same check in Dispatch you&#39;d find the opposite case.<br></p><p>I think production app code is probably a better place to look, although<br>I&#39;m not sure of any good examples of open source swift 2 app code. It would<br>be nice for a lot of these proposals if there was a common reference list<br>of libraries and apps which are popular, mature, swift2 and open source so<br>we could gauge the impact.<br></p><p><br>On Sun, Dec 20, 2015 at 7:10 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; @noescape is safer because it does not require thinking about lifetime<br>&gt; issues for captured objects.  My hunch was that @noescape (or @autoclosure<br>&gt; with implies @noescape) is also more common.  I had a look through the<br>&gt; standard library and this is definitely the case there.<br>&gt;<br>&gt; What does everyone think about making @noescape the default and<br>&gt; introducing @escaping (or something similar) to annotate function arguments<br>&gt; that do escape the call stack?<br>&gt;<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/35fd78db/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 19, 2015 at 04:00:00pm</p></header><div class="content"><p>On Sat, Dec 19, 2015 at 12:10 PM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;<br>&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br></p><p>@noescape provides additional guarantees and the optimizer can learn<br>to rely on it in future.  Thus, it effectively becomes ABI, and you<br>can&#39;t remove in future versions of the library without breaking the<br>ABI.  I think adding it should be an explicit decision because of<br>that.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 19, 2015, at 6:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 12:10 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;&gt; <br>&gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt; <br>&gt; @noescape provides additional guarantees and the optimizer can learn<br>&gt; to rely on it in future.  Thus, it effectively becomes ABI, and you<br>&gt; can&#39;t remove in future versions of the library without breaking the<br>&gt; ABI.  I think adding it should be an explicit decision because of<br>&gt; that.<br>&gt; <br></p><p>That makes sense.  Still, it would be a shame to have to add it manually if it is actually the right thing a significant majority of the time (Andrew has a good point about looking at app level code to assess this).<br></p><p>One thing to consider - the compiler already detects when function arguments escape the call stack already and provides an error if they are marked @noescape.  Because of this it also detects when they do not escape the call stack.  I don&#39;t think it would be possible to forget @escaping when that is your purpose as you would get an error.  <br></p><p>Changing the escaping behavior of a function argument seems like a major change in functionality and thus breaking ABI is probably more acceptable in that case (I&#39;m trying to think of a time when this would even happen - maybe making an synchronous operation asynchronous?).<br></p><p>As the compiler already detects whether the argument escapes or not it seems like the annotation primarily serves a documentation purpose - if you can accept the idea that a change in escaping behavior is significant enough to warrant potentially breaking ABI.<br></p><p><br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 4:38 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 12:10 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;&gt; <br>&gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt; <br>&gt; @noescape provides additional guarantees and the optimizer can learn<br>&gt; to rely on it in future.  Thus, it effectively becomes ABI, and you<br>&gt; can&#39;t remove in future versions of the library without breaking the<br>&gt; ABI.  I think adding it should be an explicit decision because of<br>&gt; that.<br></p><p>I agree.  This is a very significant API restriction that should be opted-into intentionally.  It affects subtyping relationships in protocol conformances and overrides as well.<br></p><p>A different objection to @noescape-by-default is that it makes closures second citizens by default, which makes teaching and learning higher-order functional programming significantly less awesome.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 19, 2015 at 05:00:00pm</p></header><div class="content"><p>-1<br></p><p>The standard library is not representative of how closures are commonly used. Notably, the standard library never executes anything asynchronously (an extremely common use of closures in apps), doesn&#39;t ever hold closures that are triggered later by a separate event (e.g. NSNotificationCenter observing, or UIAlertView handlers, or any third-party solution for block-based target/action replacement), no timers, no completion handlers, etc. The only constructs in the standard library that come to mind that would need escaping closures are lazy sequence operations and AnySequence (I haven&#39;t actually looked to see if there are any others). But nearly all uses of closures in UIKit require escaping, nearly all uses of closures in libdispatch require escaping, and I wager that nearly all uses of closures in application code require escaping.<br></p><p>-Kevin Ballard<br></p><p>On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution wrote:<br>&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt; <br>&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 20, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 7:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; The standard library is not representative of how closures are commonly used. Notably, the standard library never executes anything asynchronously (an extremely common use of closures in apps), doesn&#39;t ever hold closures that are triggered later by a separate event (e.g. NSNotificationCenter observing, or UIAlertView handlers, or any third-party solution for block-based target/action replacement), no timers, no completion handlers, etc. The only constructs in the standard library that come to mind that would need escaping closures are lazy sequence operations and AnySequence (I haven&#39;t actually looked to see if there are any others). But nearly all uses of closures in UIKit require escaping, nearly all uses of closures in libdispatch require escaping, and I wager that nearly all uses of closures in application code require escaping.<br></p><p>Those are fair points.  The right place to look is in application code so my skimming of the library was probably not that relevant.<br></p><p>The fact that the compiler would tell you when you need @escaping but doesn’t tell you when you could add @noescape is part of what prompted my pitch.  If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br></p><p>It would be interesting to look at function arguments in application code written in different styles (OO vs mixed vs functional-leaning) and see what the split is for escaping vs non-escaping function arguments.<br></p><p>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;&gt; <br>&gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 20, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; If we don’t change the default maybe we should at least add a warning<br>when you *could* add @noescape but didn’t.  A lot of folks are likely to<br>leave it off when they should really be adding it.<br></p><p>I like this idea. We have a warning for variables that can be made into<br>let, so why not this?<br></p><p>On Sun, Dec 20, 2015 at 18:50 Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 19, 2015, at 7:51 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; -1<br>&gt; &gt;<br>&gt; &gt; The standard library is not representative of how closures are commonly<br>&gt; used. Notably, the standard library never executes anything asynchronously<br>&gt; (an extremely common use of closures in apps), doesn&#39;t ever hold closures<br>&gt; that are triggered later by a separate event (e.g. NSNotificationCenter<br>&gt; observing, or UIAlertView handlers, or any third-party solution for<br>&gt; block-based target/action replacement), no timers, no completion handlers,<br>&gt; etc. The only constructs in the standard library that come to mind that<br>&gt; would need escaping closures are lazy sequence operations and AnySequence<br>&gt; (I haven&#39;t actually looked to see if there are any others). But nearly all<br>&gt; uses of closures in UIKit require escaping, nearly all uses of closures in<br>&gt; libdispatch require escaping, and I wager that nearly all uses of closures<br>&gt; in application code require escaping.<br>&gt;<br>&gt; Those are fair points.  The right place to look is in application code so<br>&gt; my skimming of the library was probably not that relevant.<br>&gt;<br>&gt; The fact that the compiler would tell you when you need @escaping but<br>&gt; doesn’t tell you when you could add @noescape is part of what prompted my<br>&gt; pitch.  If we don’t change the default maybe we should at least add a<br>&gt; warning when you *could* add @noescape but didn’t.  A lot of folks are<br>&gt; likely to leave it off when they should really be adding it.<br>&gt;<br>&gt; It would be interesting to look at function arguments in application code<br>&gt; written in different styles (OO vs mixed vs functional-leaning) and see<br>&gt; what the split is for escaping vs non-escaping function arguments.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt;<br>&gt; &gt; On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution<br>&gt; wrote:<br>&gt; &gt;&gt; @noescape is safer because it does not require thinking about lifetime<br>&gt; issues for captured objects.  My hunch was that @noescape (or @autoclosure<br>&gt; with implies @noescape) is also more common.  I had a look through the<br>&gt; standard library and this is definitely the case there.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What does everyone think about making @noescape the default and<br>&gt; introducing @escaping (or something similar) to annotate function arguments<br>&gt; that do escape the call stack?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Matthew<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/9f7e1860/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 20, 2015 at 11:00:00am</p></header><div class="content"><p>@noescape is part of the interface&#39;s contract. If you have it for a while (because you had a warning more than because of thoughtful design) then remove it, you&#39;re forcing code changes on your clients. I&#39;m not sure it&#39;s an appropriate default/warning, at least for public interfaces.<br></p><p>Félix<br></p><p>&gt; Le 20 déc. 2015 à 11:14:51, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &gt; If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt; <br>&gt; I like this idea. We have a warning for variables that can be made into let, so why not this? <br>&gt; <br>&gt; On Sun, Dec 20, 2015 at 18:50 Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 19, 2015, at 7:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; -1<br>&gt; &gt;<br>&gt; &gt; The standard library is not representative of how closures are commonly used. Notably, the standard library never executes anything asynchronously (an extremely common use of closures in apps), doesn&#39;t ever hold closures that are triggered later by a separate event (e.g. NSNotificationCenter observing, or UIAlertView handlers, or any third-party solution for block-based target/action replacement), no timers, no completion handlers, etc. The only constructs in the standard library that come to mind that would need escaping closures are lazy sequence operations and AnySequence (I haven&#39;t actually looked to see if there are any others). But nearly all uses of closures in UIKit require escaping, nearly all uses of closures in libdispatch require escaping, and I wager that nearly all uses of closures in application code require escaping.<br>&gt; <br>&gt; Those are fair points.  The right place to look is in application code so my skimming of the library was probably not that relevant.<br>&gt; <br>&gt; The fact that the compiler would tell you when you need @escaping but doesn’t tell you when you could add @noescape is part of what prompted my pitch.  If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt; <br>&gt; It would be interesting to look at function arguments in application code written in different styles (OO vs mixed vs functional-leaning) and see what the split is for escaping vs non-escaping function arguments.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt;<br>&gt; &gt; On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution wrote:<br>&gt; &gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Matthew<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/11900cd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 20, 2015, at 10:21 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; @noescape is part of the interface&#39;s contract. If you have it for a while (because you had a warning more than because of thoughtful design) then remove it, you&#39;re forcing code changes on your clients. I&#39;m not sure it&#39;s an appropriate default/warning, at least for public interfaces.<br>&gt; <br></p><p>I&#39;m trying to think of examples where you would change this in scenarios that don&#39;t already impact clients.  A change from synchronous to asynchronous or vice versa is the main example I can think of and that definitely impacts clients (at least when going from sync to async).<br></p><p>Do you have any examples of where you would reasonably change the escaping behavior without an impact to client code other than the escaping change?<br></p><p><br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 20 déc. 2015 à 11:14:51, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &gt; If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt;&gt; <br>&gt;&gt; I like this idea. We have a warning for variables that can be made into let, so why not this? <br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 20, 2015 at 18:50 Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 19, 2015, at 7:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The standard library is not representative of how closures are commonly used. Notably, the standard library never executes anything asynchronously (an extremely common use of closures in apps), doesn&#39;t ever hold closures that are triggered later by a separate event (e.g. NSNotificationCenter observing, or UIAlertView handlers, or any third-party solution for block-based target/action replacement), no timers, no completion handlers, etc. The only constructs in the standard library that come to mind that would need escaping closures are lazy sequence operations and AnySequence (I haven&#39;t actually looked to see if there are any others). But nearly all uses of closures in UIKit require escaping, nearly all uses of closures in libdispatch require escaping, and I wager that nearly all uses of closures in application code require escaping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those are fair points.  The right place to look is in application code so my skimming of the library was probably not that relevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that the compiler would tell you when you need @escaping but doesn’t tell you when you could add @noescape is part of what prompted my pitch.  If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be interesting to look at function arguments in application code written in different styles (OO vs mixed vs functional-leaning) and see what the split is for escaping vs non-escaping function arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt;&gt; &gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Matthew<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/8ac6b9f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>In general, any case where you go from immediate evaluation to lazy/delayed evaluation. That change might not be the most frequent, but in my opinion, public interfaces should be as forward compatible as possible.<br></p><p>Assuming that the closure escapes is always safe and the only difference that I know of is that you need to prefix member accesses with self. I&#39;m not part of it, but there&#39;s also a non-negligible group of people who apparently always use self and who would not find any benefit, but still get the forward compatibility downsides, if closures were @noescape by default.<br></p><p>Félix<br></p><p>&gt; Le 20 déc. 2015 à 13:05:40, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 20, 2015, at 10:21 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; @noescape is part of the interface&#39;s contract. If you have it for a while (because you had a warning more than because of thoughtful design) then remove it, you&#39;re forcing code changes on your clients. I&#39;m not sure it&#39;s an appropriate default/warning, at least for public interfaces.<br>&gt;&gt; <br>&gt; <br>&gt; I&#39;m trying to think of examples where you would change this in scenarios that don&#39;t already impact clients.  A change from synchronous to asynchronous or vice versa is the main example I can think of and that definitely impacts clients (at least when going from sync to async).<br>&gt; <br>&gt; Do you have any examples of where you would reasonably change the escaping behavior without an impact to client code other than the escaping change?<br>&gt; <br>&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 20 déc. 2015 à 11:14:51, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this idea. We have a warning for variables that can be made into let, so why not this? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 20, 2015 at 18:50 Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 19, 2015, at 7:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The standard library is not representative of how closures are commonly used. Notably, the standard library never executes anything asynchronously (an extremely common use of closures in apps), doesn&#39;t ever hold closures that are triggered later by a separate event (e.g. NSNotificationCenter observing, or UIAlertView handlers, or any third-party solution for block-based target/action replacement), no timers, no completion handlers, etc. The only constructs in the standard library that come to mind that would need escaping closures are lazy sequence operations and AnySequence (I haven&#39;t actually looked to see if there are any others). But nearly all uses of closures in UIKit require escaping, nearly all uses of closures in libdispatch require escaping, and I wager that nearly all uses of closures in application code require escaping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those are fair points.  The right place to look is in application code so my skimming of the library was probably not that relevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that the compiler would tell you when you need @escaping but doesn’t tell you when you could add @noescape is part of what prompted my pitch.  If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be interesting to look at function arguments in application code written in different styles (OO vs mixed vs functional-leaning) and see what the split is for escaping vs non-escaping function arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Sat, Dec 19, 2015, at 12:10 PM, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt;&gt; &gt;&gt; @noescape is safer because it does not require thinking about lifetime issues for captured objects.  My hunch was that @noescape (or @autoclosure with implies @noescape) is also more common.  I had a look through the standard library and this is definitely the case there.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; What does everyone think about making @noescape the default and introducing @escaping (or something similar) to annotate function arguments that do escape the call stack?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Matthew<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/7a7a63d9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 8:14 AM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt; <br>&gt; I like this idea. We have a warning for variables that can be made into let, so why not this? <br></p><p>An opt-in -Woptimization sort of warning (or static analyzer like feature) would be great for suggesting performance hints like this.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] make @noescape the default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 21, 2015, at 6:44 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 20, 2015, at 8:14 AM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we don’t change the default maybe we should at least add a warning when you *could* add @noescape but didn’t.  A lot of folks are likely to leave it off when they should really be adding it.<br>&gt;&gt; <br>&gt;&gt; I like this idea. We have a warning for variables that can be made into let, so why not this?<br>&gt; <br>&gt; An opt-in -Woptimization sort of warning (or static analyzer like feature) would be great for suggesting performance hints like this.<br></p><p>So this turned out to be a bad idea, but at least it turned up a good one during discussion! :)   I would love -Woptimization.<br></p><p>&gt; <br>&gt; -Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
