<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Mar 09 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; I would like to propose making `.self` After a Type optional when referencing Types in expressions.<br>&gt;<br>&gt;&gt; This has been confirmed as a bug, and the report can be seen here &lt;https://bugs.swift.org/browse/SR-899&gt;.<br>&gt;&gt; <br>&gt;&gt; After a Twitter conversation with Joe Groff on the Swift team<br>&gt;&gt; (https://twitter.com/jckarter/status/707287663586324481) it is<br>&gt;&gt; determined that this requirement is due to difficulty disambiguating<br>&gt;&gt; generics `Foo&lt;T&gt;` vs infix less-than operations `Foo &lt; T`.<br>&gt;<br>&gt; My understanding from previous Twitter discussions is that the primary<br>&gt; reason for this feature is to keep you from writing `Foo` where you<br>&gt; meant `Foo()`. That is, it&#39;s a deliberate design, meant to keep you<br>&gt; from making mistakes. I suspect that you will have to overcome *that*<br>&gt; impulse, not just any narrow parsing issue.<br></p><p>That is correct.  Before 1.0, Swift used to work without &quot;.self&quot;; we<br>started requiring &quot;.self&quot; because one of the Swift designers<br>with experience in other languages that didn&#39;t require &quot;.self&quot; said that<br>it was a persistent source of confusion for users.<br></p><p>Personally, I&#39;ve always disliked what &quot;.self&quot; did to my source code, but I<br>have no basis on which to argue with that other designer&#39;s experience.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 2:28 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Mar 09 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I would like to propose making `.self` After a Type optional when referencing Types in expressions.<br>&gt;&gt; <br>&gt;&gt;&gt; This has been confirmed as a bug, and the report can be seen here &lt;https://bugs.swift.org/browse/SR-899&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After a Twitter conversation with Joe Groff on the Swift team<br>&gt;&gt;&gt; (https://twitter.com/jckarter/status/707287663586324481) it is<br>&gt;&gt;&gt; determined that this requirement is due to difficulty disambiguating<br>&gt;&gt;&gt; generics `Foo&lt;T&gt;` vs infix less-than operations `Foo &lt; T`.<br>&gt;&gt; <br>&gt;&gt; My understanding from previous Twitter discussions is that the primary<br>&gt;&gt; reason for this feature is to keep you from writing `Foo` where you<br>&gt;&gt; meant `Foo()`. That is, it&#39;s a deliberate design, meant to keep you<br>&gt;&gt; from making mistakes. I suspect that you will have to overcome *that*<br>&gt;&gt; impulse, not just any narrow parsing issue.<br>&gt; <br>&gt; That is correct.  Before 1.0, Swift used to work without &quot;.self&quot;; we<br>&gt; started requiring &quot;.self&quot; because one of the Swift designers<br>&gt; with experience in other languages that didn&#39;t require &quot;.self&quot; said that<br>&gt; it was a persistent source of confusion for users.<br>&gt; <br>&gt; Personally, I&#39;ve always disliked what &quot;.self&quot; did to my source code, but I<br>&gt; have no basis on which to argue with that other designer&#39;s experience.<br></p><p>As the designer in question, I&#39;ve come around to this as well; our type system is sufficiently stronger than that other language that I think the consequences of accidentally typing `let x = Int` when you meant `let x = Int()` are far easier to understand. However, `.self` is also a bit of load-bearing duct-tape that currently supports some other parsing aspects of Swift&#39;s syntax. We have a bunch of type sugar syntax that&#39;s overloaded with expression syntax, such as Int?, [Int], [String: Int], and (String, Int); we currently handle this by special-casing the sugar forms when they appear as the LHS of a member lookup or function call. We could address that problem by treating it more like an overload resolution problem, and say that applying `[]`, `[:]`, `?`, or `(,)` to type references always favors building a type reference over forming an array/dictionary/optional/tuple. There&#39;s also the lower-level parsing problem with generic parameter brackets that Tanner mentioned in his leading email. We stole the same trick that C# uses to disambiguate `Foo&lt;T, U&gt;(x)` from `(Foo &lt; T), (U &gt; (x))` without relying on name lookup; we assume that a type reference in an expression is always the root of a member lookup or constructor call, and that &#39;x &gt; (y)&#39; is sufficiently unlikely given the low relative precedence of &gt;, that we can look ahead after we see a &#39;&lt;&#39; to find a &#39;&gt;.&#39; or &#39;&gt;(&#39; token pair and favor the parse as a generic parameter list in those cases. If we&#39;re going to break the invariant that type references in expressions are always followed by a member lookup or constructor call, we&#39;ll need an alternative disambiguation scheme.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5e393bcde3a003bb7c1525c8e9877f2a?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Tanner Nelson</string> &lt;me at tanner.xyz&gt;<p>March  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&quot;our type system is sufficiently stronger than that other language...&quot;<br></p><p>I was just writing a response that said exactly this. It&#39;s really impossible in Swift to be unknowingly sending the wrong types around. <br></p><p>If the agreement seems to be leaning toward figuring out a way to remove `.self`, what would the next steps be to start concretely seeing which implementations might work / be realistic?<br></p><p>&gt; On Mar 9, 2016, at 5:57 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 9, 2016, at 2:28 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Mar 09 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to propose making `.self` After a Type optional when referencing Types in expressions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This has been confirmed as a bug, and the report can be seen here &lt;https://bugs.swift.org/browse/SR-899&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After a Twitter conversation with Joe Groff on the Swift team<br>&gt;&gt;&gt;&gt; (https://twitter.com/jckarter/status/707287663586324481) it is<br>&gt;&gt;&gt;&gt; determined that this requirement is due to difficulty disambiguating<br>&gt;&gt;&gt;&gt; generics `Foo&lt;T&gt;` vs infix less-than operations `Foo &lt; T`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding from previous Twitter discussions is that the primary<br>&gt;&gt;&gt; reason for this feature is to keep you from writing `Foo` where you<br>&gt;&gt;&gt; meant `Foo()`. That is, it&#39;s a deliberate design, meant to keep you<br>&gt;&gt;&gt; from making mistakes. I suspect that you will have to overcome *that*<br>&gt;&gt;&gt; impulse, not just any narrow parsing issue.<br>&gt;&gt; <br>&gt;&gt; That is correct.  Before 1.0, Swift used to work without &quot;.self&quot;; we<br>&gt;&gt; started requiring &quot;.self&quot; because one of the Swift designers<br>&gt;&gt; with experience in other languages that didn&#39;t require &quot;.self&quot; said that<br>&gt;&gt; it was a persistent source of confusion for users.<br>&gt;&gt; <br>&gt;&gt; Personally, I&#39;ve always disliked what &quot;.self&quot; did to my source code, but I<br>&gt;&gt; have no basis on which to argue with that other designer&#39;s experience.<br>&gt; <br>&gt; As the designer in question, I&#39;ve come around to this as well; our type system is sufficiently stronger than that other language that I think the consequences of accidentally typing `let x = Int` when you meant `let x = Int()` are far easier to understand. However, `.self` is also a bit of load-bearing duct-tape that currently supports some other parsing aspects of Swift&#39;s syntax. We have a bunch of type sugar syntax that&#39;s overloaded with expression syntax, such as Int?, [Int], [String: Int], and (String, Int); we currently handle this by special-casing the sugar forms when they appear as the LHS of a member lookup or function call. We could address that problem by treating it more like an overload resolution problem, and say that applying `[]`, `[:]`, `?`, or `(,)` to type references always favors building a type reference over forming an array/dictionary/optional/tuple. There&#39;s also the lower-level parsing problem with generic parameter brackets that Tanner mentioned in his leading email. We stole the same trick that C# uses to disambiguate `Foo&lt;T, U&gt;(x)` from `(Foo &lt; T), (U &gt; (x))` without relying on name lookup; we assume that a type reference in an expression is always the root of a member lookup or constructor call, and that &#39;x &gt; (y)&#39; is sufficiently unlikely given the low relative precedence of &gt;, that we can look ahead after we see a &#39;&lt;&#39; to find a &#39;&gt;.&#39; or &#39;&gt;(&#39; token pair and favor the parse as a generic parameter list in those cases. If we&#39;re going to break the invariant that type references in expressions are always followed by a member lookup or constructor call, we&#39;ll need an alternative disambiguation scheme.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/6a11c40c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 10, 2016 at 08:00:00am</p></header><div class="content"><p>I strongly agree for the removal of .self. I remember it being a great source of confusion when I first learned Swift.<br></p><p>&gt; On 10 Mar 2016, at 00:03, Tanner Nelson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;our type system is sufficiently stronger than that other language...&quot;<br>&gt; <br>&gt; I was just writing a response that said exactly this. It&#39;s really impossible in Swift to be unknowingly sending the wrong types around. <br>&gt; <br>&gt; If the agreement seems to be leaning toward figuring out a way to remove `.self`, what would the next steps be to start concretely seeing which implementations might work / be realistic?<br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 5:57 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 2:28 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Mar 09 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to propose making `.self` After a Type optional when referencing Types in expressions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has been confirmed as a bug, and the report can be seen here &lt;https://bugs.swift.org/browse/SR-899 &lt;https://bugs.swift.org/browse/SR-899&gt;&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After a Twitter conversation with Joe Groff on the Swift team<br>&gt;&gt;&gt;&gt;&gt; (https://twitter.com/jckarter/status/707287663586324481 &lt;https://twitter.com/jckarter/status/707287663586324481&gt;) it is<br>&gt;&gt;&gt;&gt;&gt; determined that this requirement is due to difficulty disambiguating<br>&gt;&gt;&gt;&gt;&gt; generics `Foo&lt;T&gt;` vs infix less-than operations `Foo &lt; T`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My understanding from previous Twitter discussions is that the primary<br>&gt;&gt;&gt;&gt; reason for this feature is to keep you from writing `Foo` where you<br>&gt;&gt;&gt;&gt; meant `Foo()`. That is, it&#39;s a deliberate design, meant to keep you<br>&gt;&gt;&gt;&gt; from making mistakes. I suspect that you will have to overcome *that*<br>&gt;&gt;&gt;&gt; impulse, not just any narrow parsing issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is correct.  Before 1.0, Swift used to work without &quot;.self&quot;; we<br>&gt;&gt;&gt; started requiring &quot;.self&quot; because one of the Swift designers<br>&gt;&gt;&gt; with experience in other languages that didn&#39;t require &quot;.self&quot; said that<br>&gt;&gt;&gt; it was a persistent source of confusion for users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I&#39;ve always disliked what &quot;.self&quot; did to my source code, but I<br>&gt;&gt;&gt; have no basis on which to argue with that other designer&#39;s experience.<br>&gt;&gt; <br>&gt;&gt; As the designer in question, I&#39;ve come around to this as well; our type system is sufficiently stronger than that other language that I think the consequences of accidentally typing `let x = Int` when you meant `let x = Int()` are far easier to understand. However, `.self` is also a bit of load-bearing duct-tape that currently supports some other parsing aspects of Swift&#39;s syntax. We have a bunch of type sugar syntax that&#39;s overloaded with expression syntax, such as Int?, [Int], [String: Int], and (String, Int); we currently handle this by special-casing the sugar forms when they appear as the LHS of a member lookup or function call. We could address that problem by treating it more like an overload resolution problem, and say that applying `[]`, `[:]`, `?`, or `(,)` to type references always favors building a type reference over forming an array/dictionary/optional/tuple. There&#39;s also the lower-level parsing problem with generic parameter brackets that Tanner mentioned in his leading email. We stole the same trick that C# uses to disambiguate `Foo&lt;T, U&gt;(x)` from `(Foo &lt; T), (U &gt; (x))` without relying on name lookup; we assume that a type reference in an expression is always the root of a member lookup or constructor call, and that &#39;x &gt; (y)&#39; is sufficiently unlikely given the low relative precedence of &gt;, that we can look ahead after we see a &#39;&lt;&#39; to find a &#39;&gt;.&#39; or &#39;&gt;(&#39; token pair and favor the parse as a generic parameter list in those cases. If we&#39;re going to break the invariant that type references in expressions are always followed by a member lookup or constructor call, we&#39;ll need an alternative disambiguation scheme.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/d30e6e25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>March 14, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 for junking the .self requirement<br></p><p>On Wed, Mar 9, 2016 at 11:14 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I strongly agree for the removal of .self. I remember it being a great<br>&gt; source of confusion when I first learned Swift.<br>&gt;<br>&gt;<br>I had the same experience. It was very disorienting.<br></p><p>Now that Dave and Joe have explained its origin as a safety feature, it<br>makes sense. The problem is that there&#39;s no way to convey that to the<br>end-user, so it seems like it has some deeper meaning. Then you start<br>second-guessing yourself if there&#39;s an error in your code, etc.<br></p><p>Nice to see that this might be fixed. Evolution is making me happier and<br>happier lately :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/a1b22588/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6ab7ae85b84ebb323fab427b11500742?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Keith Smiley</string> &lt;keithbsmiley at gmail.com&gt;<p>March 14, 2016 at 11:00:00pm</p></header><div class="content"><p>I personally don&#39;t mind the trailing `.self` but it does seem strange that you<br>need that, or not, based on the number of parameters. I definitely think it<br>would be nice to unify this one way or the other.<br></p><p>Another interesting consideration I ran into just today is trying to use `self`<br>as a `#selector` in Swift 2.2. Swift happily converts:<br></p><p>```<br>Selector(&quot;self&quot;)<br>```<br></p><p>To:<br></p><p>```<br>#selector(NSObjectProtocol.self)<br>```<br></p><p>In some cases. But because of `.self` referencing the type, this doesn&#39;t do what<br>you&#39;d expect. Which is an interesting edge case.<br></p><p>--<br>Keith Smiley<br></p><p>On 03/14, Charles Constant via swift-evolution wrote:<br>&gt; +1 for junking the .self requirement<br>&gt;<br>&gt; On Wed, Mar 9, 2016 at 11:14 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I strongly agree for the removal of .self. I remember it being a great<br>&gt; &gt; source of confusion when I first learned Swift.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; I had the same experience. It was very disorienting.<br>&gt;<br>&gt; Now that Dave and Joe have explained its origin as a safety feature, it<br>&gt; makes sense. The problem is that there&#39;s no way to convey that to the<br>&gt; end-user, so it seems like it has some deeper meaning. Then you start<br>&gt; second-guessing yourself if there&#39;s an error in your code, etc.<br>&gt;<br>&gt; Nice to see that this might be fixed. Evolution is making me happier and<br>&gt; happier lately :)<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5e393bcde3a003bb7c1525c8e9877f2a?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Tanner Nelson</string> &lt;me at tanner.xyz&gt;<p>March 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 1:54 AM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; +1 for junking the .self requirement<br>&gt; <br>&gt; On Wed, Mar 9, 2016 at 11:14 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I strongly agree for the removal of .self. I remember it being a great source of confusion when I first learned Swift.<br>&gt; <br>&gt; <br>&gt; I had the same experience. It was very disorienting. <br>&gt; <br>&gt; Now that Dave and Joe have explained its origin as a safety feature, it makes sense. The problem is that there&#39;s no way to convey that to the end-user, so it seems like it has some deeper meaning. Then you start second-guessing yourself if there&#39;s an error in your code, etc.<br></p><p>I agree. Swift&#39;s type-checking engine is strong enough to merit not needing the redundant `.self` safety check. It feels like I&#39;m doing something wrong when I need to use `.self`. <br></p><p>&gt; <br>&gt; Nice to see that this might be fixed. Evolution is making me happier and happier lately :)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/d3033935/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 12:32, Tanner Nelson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 1:54 AM, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 for junking the .self requirement<br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 9, 2016 at 11:14 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I strongly agree for the removal of .self. I remember it being a great source of confusion when I first learned Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I had the same experience. It was very disorienting. <br>&gt;&gt; <br>&gt;&gt; Now that Dave and Joe have explained its origin as a safety feature, it makes sense. The problem is that there&#39;s no way to convey that to the end-user, so it seems like it has some deeper meaning. Then you start second-guessing yourself if there&#39;s an error in your code, etc.<br>&gt; <br>&gt; I agree. Swift&#39;s type-checking engine is strong enough to merit not needing the redundant `.self` safety check. It feels like I&#39;m doing something wrong when I need to use `.self`.<br></p><p>I do want to note one additional case that will become ambiguous:<br></p><p>let x = [NSURL] // value of type &#39;Array&lt;NSURL.Type&gt;&#39;, or &#39;Array&lt;NSURL&gt;.Type&#39; ?<br>let y = [NSURL.self] // definitely the former<br>let z = [NSURL]() // definitely the latter<br></p><p>I think we have to treat this as the former, and I think the rule is just &quot;if the close bracket is immediately followed by an open paren, it&#39;s a type; otherwise it&#39;s a value&quot;. This definitely affects what `[NSURL].foo` means, too (is it a static or dynamic property?).<br></p><p>We could also restrict the array/dictionary shorthand syntax to type position, but it seems like it&#39;s fairly conventional to use &quot;let x = [NSURL]()&quot;.<br></p><p>Jordan<br></p><p>P.S. We actually have this problem today: does `NSURL?.self` have type &#39;Optional&lt;NSURL.Type&gt;&#39; or &#39;Optional&lt;NSURL&gt;.Type&#39; ?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/60c6dd9c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 3:03 PM, Tanner Nelson &lt;me at tanner.xyz&gt; wrote:<br>&gt; <br>&gt; &quot;our type system is sufficiently stronger than that other language...&quot;<br>&gt; <br>&gt; I was just writing a response that said exactly this. It&#39;s really impossible in Swift to be unknowingly sending the wrong types around. <br>&gt; <br>&gt; If the agreement seems to be leaning toward figuring out a way to remove `.self`, what would the next steps be to start concretely seeing which implementations might work / be realistic?<br></p><p>I see two problems to solve:<br></p><p>A) Decide a grammar rule to distinguish the operator &#39;&lt;&#39; from the generic parameter bracket, and<br>B) Decide a semantic rule to distinguish type &quot;operators&quot; like &#39;[T]&#39;, &#39;T?&#39;, etc. from value operations.<br></p><p>For (A), we should look at the new places a generic type might appear in expressions:<br></p><p>- By itself:<br></p><p>let x = Foo&lt; T &gt;<br>bar() // following statement<br></p><p>let y = Foo&lt; T, U &gt;<br>bar() // following statement<br></p><p>This doesn&#39;t strike me as a huge problem to parse as a type reference, since &#39;a &lt; b &gt; c&#39; is unlikely as an expression, and we don&#39;t have commas in the top level of the grammar, so &#39;a &lt; b, c &gt; d&#39; is impossible as a top-level expression. Extending the lookahead rule to include `&gt;;` or `&gt; *token on next line*` as disambiguators is probably OK.<br></p><p>- As a function parameter, or array or dictionary element:<br></p><p>sizeof(Foo&lt;T&gt;)<br>load(Foo&lt;T&gt;, atOffset: 8)<br>let types = [Foo&lt;T&gt;, Bar&lt;U&gt;]<br>let factories = [Foo&lt;T&gt;: makeFoo, Bar&lt;U&gt;: makeBar]<br></p><p>This is probably the most common use case for type references, and the easiest to support, since the parameters are always followed by a token that can&#39;t start an expression by itself. We could extend the current lookahead rule to ensure it includes `&gt;)`, `&gt;,` and `&gt;:`.<br></p><p>- As the parameter to an operator:<br></p><p>++Foo&lt;T&gt; // prefix<br>Foo&lt;T&gt;++ // postfix<br>Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>Foo&lt;T&gt; + Bar&lt;U&gt;<br>let foo = Bar&lt;U&gt;<br></p><p>This one&#39;s a bit interesting since `&gt;+` or `&gt;++` could be operators themselves. Applying operators to types might not be a compelling enough reason to block the other changes, though.<br></p><p>For (B), as I mentioned before, it makes the choice between [T] becoming &#39;Array&lt;T&gt;&#39; or becoming an array containing &#39;T&#39; a bit of an overload resolution problem. In most cases we can probably favor the type sugar, either by argument type context or by syntactically recognizing `T` as a static type reference and favoring the type sugar interpretation over the array literal implementation. Doug or Joe Pamer probably have opinions here.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/55265a81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 9:19 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; - As the parameter to an operator:<br>&gt; <br>&gt; ++Foo&lt;T&gt; // prefix<br>&gt; Foo&lt;T&gt;++ // postfix<br>&gt; Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>&gt; Foo&lt;T&gt; + Bar&lt;U&gt;<br>How is this case different.<br>&gt; let foo = Bar&lt;U&gt;<br></p><p>Is assignment an operator?<br>&gt; <br>&gt; This one&#39;s a bit interesting since `&gt;+` or `&gt;++` could be operators themselves. Applying operators to types might not be a compelling enough reason to block the other changes, though.<br></p><p>I’d be totally willing to say that if you want to apply an operator (other than assignment) to a type you need to put it in parentheses.<br></p><p>++(Foo&lt;T&gt;) // prefix<br>(Foo&lt;T&gt;)++ // postfix<br>(Foo&lt;T&gt;)+(Bar&lt;U&gt;) // infix<br>(Foo&lt;T&gt;) + (Bar&lt;U&gt;)<br>let foo = Bar&lt;U&gt;<br></p><p>&gt; <br>&gt; For (B), as I mentioned before, it makes the choice between [T] becoming &#39;Array&lt;T&gt;&#39; or becoming an array containing &#39;T&#39; a bit of an overload resolution problem. In most cases we can probably favor the type sugar, either by argument type context or by syntactically recognizing `T` as a static type reference and favoring the type sugar interpretation over the array literal implementation. Doug or Joe Pamer probably have opinions here.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/fa572209/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 10, 2016, at 9:19 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - As the parameter to an operator:<br>&gt;&gt; <br>&gt;&gt; ++Foo&lt;T&gt; // prefix<br>&gt;&gt; Foo&lt;T&gt;++ // postfix<br>&gt;&gt; Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>&gt;&gt; Foo&lt;T&gt; + Bar&lt;U&gt;<br>&gt; How is this case different.<br></p><p>&gt;+ might itself be an operator token without the whitespace.<br></p><p>&gt;&gt; let foo = Bar&lt;U&gt;<br>&gt; <br>&gt; Is assignment an operator?<br></p><p>It parses like one.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/a70d0ca0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 11:50 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 10, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 10, 2016, at 9:19 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - As the parameter to an operator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ++Foo&lt;T&gt; // prefix<br>&gt;&gt;&gt; Foo&lt;T&gt;++ // postfix<br>&gt;&gt;&gt; Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>&gt;&gt;&gt; Foo&lt;T&gt; + Bar&lt;U&gt;<br>&gt;&gt; How is this case different.<br>&gt; <br>&gt; &gt;+ might itself be an operator token without the whitespace.<br></p><p>Ah, thanks.<br></p><p>&gt;&gt;&gt; let foo = Bar&lt;U&gt;<br>&gt;&gt; <br>&gt;&gt; Is assignment an operator?<br>&gt; <br>&gt; It parses like one.<br></p><p>Okay, well I’d make an exception for assignment, but reasonable people can disagree.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/5cc5340c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 9:19 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For (A), we should look at the new places a generic type might appear in expressions:<br>&gt; <br>&gt; - By itself:<br>&gt; <br>&gt; let x = Foo&lt; T &gt;<br>&gt; bar() // following statement<br>&gt; <br>&gt; let y = Foo&lt; T, U &gt;<br>&gt; bar() // following statement<br>&gt; <br>&gt; This doesn&#39;t strike me as a huge problem to parse as a type reference, since &#39;a &lt; b &gt; c&#39; is unlikely as an expression, and we don&#39;t have commas in the top level of the grammar, so &#39;a &lt; b, c &gt; d&#39; is impossible as a top-level expression. Extending the lookahead rule to include `&gt;;` or `&gt; *token on next line*` as disambiguators is probably OK.<br>&gt; <br>&gt; - As a function parameter, or array or dictionary element:<br>&gt; <br>&gt; sizeof(Foo&lt;T&gt;)<br>&gt; load(Foo&lt;T&gt;, atOffset: 8)<br>&gt; let types = [Foo&lt;T&gt;, Bar&lt;U&gt;]<br>&gt; let factories = [Foo&lt;T&gt;: makeFoo, Bar&lt;U&gt;: makeBar]<br>&gt; <br>&gt; This is probably the most common use case for type references, and the easiest to support, since the parameters are always followed by a token that can&#39;t start an expression by itself. We could extend the current lookahead rule to ensure it includes `&gt;)`, `&gt;,` and `&gt;:`.<br>&gt; <br>&gt; - As the parameter to an operator:<br>&gt; <br>&gt; ++Foo&lt;T&gt; // prefix<br>&gt; Foo&lt;T&gt;++ // postfix<br>&gt; Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>&gt; Foo&lt;T&gt; + Bar&lt;U&gt;<br>&gt; let foo = Bar&lt;U&gt;<br>&gt; <br>&gt; This one&#39;s a bit interesting since `&gt;+` or `&gt;++` could be operators themselves. Applying operators to types might not be a compelling enough reason to block the other changes, though.<br></p><p>Well, comparison `&gt;` is an infix operator. Could we treat generic parameter list `&gt;` as a postfix operator? That is, require whitespace (or at least something that is neither operator nor identifier, like a parenthesis or dot) to its right but not its left? That would require looking all the way through the generic parameter list to the end, but we could bail early if we encounter something that can&#39;t be in a generic parameter list (as far as I can tell, that includes identifiers and dots, angle brackets and commas, and characters used in type shorthand).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making `.self` After `Type` Optional</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 11:05 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 10, 2016, at 9:19 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For (A), we should look at the new places a generic type might appear in expressions:<br>&gt;&gt; <br>&gt;&gt; - By itself:<br>&gt;&gt; <br>&gt;&gt; let x = Foo&lt; T &gt;<br>&gt;&gt; bar() // following statement<br>&gt;&gt; <br>&gt;&gt; let y = Foo&lt; T, U &gt;<br>&gt;&gt; bar() // following statement<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t strike me as a huge problem to parse as a type reference, since &#39;a &lt; b &gt; c&#39; is unlikely as an expression, and we don&#39;t have commas in the top level of the grammar, so &#39;a &lt; b, c &gt; d&#39; is impossible as a top-level expression. Extending the lookahead rule to include `&gt;;` or `&gt; *token on next line*` as disambiguators is probably OK.<br>&gt;&gt; <br>&gt;&gt; - As a function parameter, or array or dictionary element:<br>&gt;&gt; <br>&gt;&gt; sizeof(Foo&lt;T&gt;)<br>&gt;&gt; load(Foo&lt;T&gt;, atOffset: 8)<br>&gt;&gt; let types = [Foo&lt;T&gt;, Bar&lt;U&gt;]<br>&gt;&gt; let factories = [Foo&lt;T&gt;: makeFoo, Bar&lt;U&gt;: makeBar]<br>&gt;&gt; <br>&gt;&gt; This is probably the most common use case for type references, and the easiest to support, since the parameters are always followed by a token that can&#39;t start an expression by itself. We could extend the current lookahead rule to ensure it includes `&gt;)`, `&gt;,` and `&gt;:`.<br>&gt;&gt; <br>&gt;&gt; - As the parameter to an operator:<br>&gt;&gt; <br>&gt;&gt; ++Foo&lt;T&gt; // prefix<br>&gt;&gt; Foo&lt;T&gt;++ // postfix<br>&gt;&gt; Foo&lt;T&gt;+Bar&lt;U&gt; // infix<br>&gt;&gt; Foo&lt;T&gt; + Bar&lt;U&gt;<br>&gt;&gt; let foo = Bar&lt;U&gt;<br>&gt;&gt; <br>&gt;&gt; This one&#39;s a bit interesting since `&gt;+` or `&gt;++` could be operators themselves. Applying operators to types might not be a compelling enough reason to block the other changes, though.<br>&gt; <br>&gt; Well, comparison `&gt;` is an infix operator. Could we treat generic parameter list `&gt;` as a postfix operator? That is, require whitespace (or at least something that is neither operator nor identifier, like a parenthesis or dot) to its right but not its left? That would require looking all the way through the generic parameter list to the end, but we could bail early if we encounter something that can&#39;t be in a generic parameter list (as far as I can tell, that includes identifiers and dots, angle brackets and commas, and characters used in type shorthand).<br></p><p>Possibly. However, treating `&gt;` as a postfix operator would conflict with the current standard library formatting conventions, which prefer to split long generic parameter lists K&amp;R-style like this:<br></p><p>func foo&lt;<br>  T where...<br>&gt;(<br>  args...<br>) {<br>  code...<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/a0c936c7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
