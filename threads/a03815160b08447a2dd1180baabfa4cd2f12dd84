<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 21, 2016 at 08:00:00am</p></header><div class="content"><p>I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br></p><p>var obj: IndexPath? = IndexPath()<br>let anyValue: Any = obj<br>anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br></p><p>/// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>/// non-nil as AnyObject.<br>func isOptional(anyValue: Any) -&gt; Bool {<br>    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>    // optional type &#39;Optional&lt;_&gt;&#39;<br>    return anyValue is Optional<br>    return anyValue as? Optional != nil<br>    ...<br>}<br></p><p>Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br></p><p>However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br></p><p>My second part of the proposal introduces another function:<br></p><p>func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br></p><p>Which will:<br>- return nil if !isOptional(anyValue)<br>- return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br></p><p>Usage:<br></p><p>if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>    if let anyObj = anyObjOptional {<br>        // anyObj is now the actual content of the optional.<br>    }<br>}<br></p><p>As a sidenote, this is my current workaround:<br></p><p>private protocol _XUOptional {<br>    var objectValue: AnyObject? { get }<br>}<br></p><p>extension Optional: _XUOptional {<br>    var objectValue: AnyObject? {<br>        switch self {<br>        case .None:<br>            return nil<br>        case .Some(_):<br>            return self! as? AnyObject<br>        }<br>    }<br>}<br></p><p>if let optional = anyValue as? _XUOptional {<br>    let object = optional.objectValue<br>    /// ...<br>}<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/a038dd84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 21, 2016 at 11:00:00am</p></header><div class="content"><p>&#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br></p><p>-Joe<br></p><p>&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt; <br>&gt; var obj: IndexPath? = IndexPath()<br>&gt; let anyValue: Any = obj<br>&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt; <br>&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt; /// non-nil as AnyObject.<br>&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;     // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;     // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;     return anyValue is Optional<br>&gt;     return anyValue as? Optional != nil<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt; <br>&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt; <br>&gt; My second part of the proposal introduces another function:<br>&gt; <br>&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt; <br>&gt; Which will:<br>&gt; - return nil if !isOptional(anyValue)<br>&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt; <br>&gt; Usage:<br>&gt; <br>&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;     if let anyObj = anyObjOptional {<br>&gt;         // anyObj is now the actual content of the optional.<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; As a sidenote, this is my current workaround:<br>&gt; <br>&gt; private protocol _XUOptional {<br>&gt;     var objectValue: AnyObject? { get }<br>&gt; }<br>&gt; <br>&gt; extension Optional: _XUOptional {<br>&gt;     var objectValue: AnyObject? {<br>&gt;         switch self {<br>&gt;         case .None:<br>&gt;             return nil<br>&gt;         case .Some(_):<br>&gt;             return self! as? AnyObject<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; if let optional = anyValue as? _XUOptional {<br>&gt;     let object = optional.objectValue<br>&gt;     /// ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 22, 2016 at 07:00:00am</p></header><div class="content"><p>Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br></p><p>let myString: String? = &quot;Hello&quot;<br>let anyValue: Any = myString<br></p><p>myString as? AnyObject // _NSContiguousString<br>anyValue as? AnyObject // nil, since String is struct<br></p><p>let array: [String]? = [&quot;Hello&quot;]<br>let anyArray: Any = array<br>anyArray as? AnyObject // nil<br>anyArray as? [AnyObject] // nil<br>array as? AnyObject // [&quot;Hello&quot;]<br></p><p>And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br></p><p>Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br></p><p>Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br></p><p>let myString: String? = &quot;Hello&quot;<br>let anyValue: Any = myString<br>if let value = anyValue as? Any {<br>    value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>}<br></p><p><br></p><p>&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt; <br>&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt; let anyValue: Any = obj<br>&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt; <br>&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;    return anyValue is Optional<br>&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt; <br>&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt; <br>&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt; <br>&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt; <br>&gt;&gt; Which will:<br>&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt; <br>&gt;&gt; Usage:<br>&gt;&gt; <br>&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt; <br>&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .None:<br>&gt;&gt;            return nil<br>&gt;&gt;        case .Some(_):<br>&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;    /// ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/5d760a46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>  If let val = v as? T {<br>    Return val<br>  }<br>  Return nil<br>}<br>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt; <br>&gt; let myString: String? = &quot;Hello&quot;<br>&gt; let anyValue: Any = myString<br>&gt; <br>&gt; myString as? AnyObject // _NSContiguousString<br>&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt; <br>&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt; let anyArray: Any = array<br>&gt; anyArray as? AnyObject // nil<br>&gt; anyArray as? [AnyObject] // nil<br>&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt; <br>&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt; <br>&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt; <br>&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt; <br>&gt; let myString: String? = &quot;Hello&quot;<br>&gt; let anyValue: Any = myString<br>&gt; if let value = anyValue as? Any {<br>&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/7d9cf839/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>Ext Optional {<br> Func ifUnwraps&lt;T&gt;(_ h: T-&gt;()){<br>  Switch self<br>    Case .Some(let v):<br>      If let t=v as? T { h(t) } // invoke if T matches<br>    Def:<br>      Brk<br> }<br>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 22, 2016, at 9:15 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;   If let val = v as? T {<br>&gt;     Return val<br>&gt;   }<br>&gt;   Return nil<br>&gt; }<br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; <br>&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt; <br>&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt; let anyArray: Any = array<br>&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt; <br>&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt; <br>&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt; <br>&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/0db95fa0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 22, 2016 at 10:00:00am</p></header><div class="content"><p>Nice!<br></p><p>Would you consider this as something that should be part of the language? IMHO working this out takes much more time than it should and these two functions would definitely help out a lot.<br></p><p>&gt; On Jun 22, 2016, at 9:15 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;   If let val = v as? T {<br>&gt;     Return val<br>&gt;   }<br>&gt;   Return nil<br>&gt; }<br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; <br>&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt; <br>&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt; let anyArray: Any = array<br>&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt; <br>&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt; <br>&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt; <br>&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/1f852736/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 22, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 12:15 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;   If let val = v as? T {<br>&gt;     Return val<br>&gt;   }<br>&gt;   Return nil<br>&gt; }<br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br></p><p>This is just:<br>  return v as? T<br></p><p>John.<br></p><p>&gt; <br>&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; <br>&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt; <br>&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt; let anyArray: Any = array<br>&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt; <br>&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt; <br>&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt; <br>&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt; <br>&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt; let anyValue: Any = myString<br>&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/6445a13c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 5:51 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 12:15 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;&gt;   If let val = v as? T {<br>&gt;&gt;     Return val<br>&gt;&gt;   }<br>&gt;&gt;   Return nil<br>&gt;&gt; }<br>&gt;&gt; Regards<br>&gt;&gt; LM<br>&gt;&gt; (From mobile)<br>&gt; <br>&gt; This is just:<br>&gt;   return v as? T<br></p><p>Had more code where i took it from... I thk it is one of these simple thgs that u never forget but may not be immediate to thk abt. Maybe worth adding to doc comment for Optional&lt;&gt; (forgive if is there already)<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt;&gt; let anyArray: Any = array<br>&gt;&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/8b762267/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Please consider the following code:<br></p><p>let myString: String? = &quot;Hello&quot;<br>let anyValue: Any = myString<br>let obj: AnyObject? = anyValue as? AnyObject // nil, since it&#39;s Optional&lt;String&gt;, String being struct,<br>					 // no implicit bridge to AnyObject. (myString as AnyObject will<br>					 // create _NSContiguousString).<br></p><p>if let optionalAny: AnyObject? = anyValue as? AnyObject? { // Error - can&#39;t downcast from Any<br>    // ...<br>}<br></p><p>if let optionalAny: AnyObject? = anyValue as? AnyObject { // nil<br>    // ...<br>}<br></p><p>if let optionalAny: AnyObject? = asOpt(anyValue) { // Optional&lt;AnyObject&gt;<br>    if let value = optionalAny { // value is _NSContiguousString<br>        value.dynamicType<br>    }<br>}<br></p><p>This behavior is IMHO incosistent at best. Should this be considered correct behavior or a compiler bug?<br></p><p>&gt; On Jun 22, 2016, at 5:59 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 22, 2016, at 5:51 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 12:15 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;&gt;&gt;   If let val = v as? T {<br>&gt;&gt;&gt;     Return val<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   Return nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; LM<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt; This is just:<br>&gt;&gt;   return v as? T<br>&gt; <br>&gt; Had more code where i took it from... I thk it is one of these simple thgs that u never forget but may not be immediate to thk abt. Maybe worth adding to doc comment for Optional&lt;&gt; (forgive if is there already)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt;&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt; let anyArray: Any = array<br>&gt;&gt;&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt;&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt;&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/83feb35d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 9:12 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please consider the following code:<br>&gt; <br>&gt; let myString: String? = &quot;Hello&quot;<br>&gt; let anyValue: Any = myString<br>&gt; let obj: AnyObject? = anyValue as? AnyObject // nil, since it&#39;s Optional&lt;String&gt;, String being struct,<br>&gt; 					 // no implicit bridge to AnyObject. (myString as AnyObject will<br>&gt; 					 // create _NSContiguousString).<br>&gt; <br>&gt; if let optionalAny: AnyObject? = anyValue as? AnyObject? { // Error - can&#39;t downcast from Any<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; if let optionalAny: AnyObject? = anyValue as? AnyObject { // nil<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; if let optionalAny: AnyObject? = asOpt(anyValue) { // Optional&lt;AnyObject&gt;<br>&gt;     if let value = optionalAny { // value is _NSContiguousString<br>&gt;         value.dynamicType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This behavior is IMHO incosistent at best. Should this be considered correct behavior or a compiler bug?<br></p><p>A bug.<br></p><p>-Joe<br></p><p>&gt;&gt; On Jun 22, 2016, at 5:59 PM, L.Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 5:51 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 12:15 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   If let val = v as? T {<br>&gt;&gt;&gt;&gt;     Return val<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   Return nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt; LM<br>&gt;&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is just:<br>&gt;&gt;&gt;   return v as? T<br>&gt;&gt; <br>&gt;&gt; Had more code where i took it from... I thk it is one of these simple thgs that u never forget but may not be immediate to thk abt. Maybe worth adding to doc comment for Optional&lt;&gt; (forgive if is there already)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt;&gt;&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt;&gt; let anyArray: Any = array<br>&gt;&gt;&gt;&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt;&gt;&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt;&gt;&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;&gt;&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 9:12 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Please consider the following code:<br>&gt; <br>&gt; let myString: String? = &quot;Hello&quot;<br>&gt; let anyValue: Any = myString<br>&gt; let obj: AnyObject? = anyValue as? AnyObject // nil, since it&#39;s Optional&lt;String&gt;, String being struct,<br>&gt; 					 // no implicit bridge to AnyObject. (myString as AnyObject will<br>&gt; 					 // create _NSContiguousString).<br>&gt; <br>&gt; if let optionalAny: AnyObject? = anyValue as? AnyObject? { // Error - can&#39;t downcast from Any<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; if let optionalAny: AnyObject? = anyValue as? AnyObject { // nil<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; if let optionalAny: AnyObject? = asOpt(anyValue) { // Optional&lt;AnyObject&gt;<br>&gt;     if let value = optionalAny { // value is _NSContiguousString<br>&gt;         value.dynamicType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This behavior is IMHO incosistent at best. Should this be considered correct behavior or a compiler bug?<br></p><p>The inability to cast from Any to an optional is a bug.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; On Jun 22, 2016, at 5:59 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 5:51 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 12:15 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Func asOpt&lt;T&gt;(v:Any) -&gt; Optional&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   If let val = v as? T {<br>&gt;&gt;&gt;&gt;     Return val<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   Return nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt; LM<br>&gt;&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is just:<br>&gt;&gt;&gt;   return v as? T<br>&gt;&gt; <br>&gt;&gt; Had more code where i took it from... I thk it is one of these simple thgs that u never forget but may not be immediate to thk abt. Maybe worth adding to doc comment for Optional&lt;&gt; (forgive if is there already)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 7:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; myString as? AnyObject // _NSContiguousString<br>&gt;&gt;&gt;&gt;&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt;&gt; let anyArray: Any = array<br>&gt;&gt;&gt;&gt;&gt; anyArray as? AnyObject // nil<br>&gt;&gt;&gt;&gt;&gt; anyArray as? [AnyObject] // nil<br>&gt;&gt;&gt;&gt;&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should this then be considered compiler bug that bridging isn&#39;t taken into account?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nevertheless, I&#39;d still find it useful exposing the isOptional() function as well as the asOptional which would allow a cast from Any to Optional&lt;Any&gt; which is not possible at all at this moment since any such cast will pick up the Optional first:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let myString: String? = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt;&gt; let anyValue: Any = myString<br>&gt;&gt;&gt;&gt;&gt; if let value = anyValue as? Any {<br>&gt;&gt;&gt;&gt;&gt;     value.dynamicType // This is still Optional&lt;String&gt;, not naively just the value of the optional<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 21, 2016, at 8:18 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &#39;as?&#39; should already do this. If you have an Any that contains an Optional&lt;T&gt; and cast &#39;any as? T&#39;, you&#39;ll get the value inside the Optional if there is one, or the cast will fail if the optional is nil or the type doesn&#39;t match.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 11:00 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve recently written a CoreData editor on iOS which automatically generates UI based on the model which is described using classes such as PrimitiveProperty, etc. Since it automatically sets the value on the entity, it needs to convert the value to AnyObject in order to pass it to setValue(_:forKey:), so it needs to be able to detect whether the value is Optional and in case it is, either transform the non-nil value to AnyObject (String -&gt; NSString, Array -&gt; NSArray, ...). Which is currently really hard to achieve: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var obj: IndexPath? = IndexPath()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let anyValue: Any = obj<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyValue.dynamicType /// Optional&lt;Foundation.IndexPath&gt;.Type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Using only anyValue, determine if it&#39;s Optional and retrieve its value if <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// non-nil as AnyObject.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func isOptional(anyValue: Any) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Error: Cannot downcast from &#39;Any&#39; (aka &#39;protocol&lt;&gt;&#39;) to a more <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // optional type &#39;Optional&lt;_&gt;&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue is Optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return anyValue as? Optional != nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unless there are major reasons why it&#39;s not exposed, I&#39;d propose introducing a new function isOptional(anyValue: Any) -&gt; Bool, which would simply call Builtin.isOptional just like _isOptional does in Builtin.swift. (which pretty much is just taking the current _isOptional, removing underscore and marking it public).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, this still doesn&#39;t help with the issue of retrieving the value of the Optional. You now know the value in `anyValue` is Optional, but there is no good way to cast it to e.g. Optional&lt;AnyObject&gt;. Here we&#39;re getting into a vicious cycle that Any can be an Optional which is Any.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My second part of the proposal introduces another function:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func asOptional&lt;T&gt;(anyValue: Any) -&gt; Optional&lt;T&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Which will:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return nil if !isOptional(anyValue)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return a non-nil value only if `anyValue` contains in fact an Optional of type T.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Usage:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let anyObjOptional: AnyObject? = asOptional(anyValue: anyValue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if let anyObj = anyObjOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        // anyObj is now the actual content of the optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As a sidenote, this is my current workaround:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private protocol _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? { get }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Optional: _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var objectValue: AnyObject? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        switch self {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        case .None:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        case .Some(_):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            return self! as? AnyObject<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let optional = anyValue as? _XUOptional {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let object = optional.objectValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    /// ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/21b283ed/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 10:11 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Unfortunately, this is not as easy, because automatic bridging won&#39;t be applied:<br>&gt; <br>&gt; let myString: String? = &quot;Hello&quot;<br>&gt; let anyValue: Any = myString<br>&gt; <br>&gt; myString as? AnyObject // _NSContiguousString<br>&gt; anyValue as? AnyObject // nil, since String is struct<br>&gt; <br>&gt; let array: [String]? = [&quot;Hello&quot;]<br>&gt; let anyArray: Any = array<br>&gt; anyArray as? AnyObject // nil<br>&gt; anyArray as? [AnyObject] // nil<br>&gt; array as? AnyObject // [&quot;Hello&quot;]<br>&gt; <br>&gt; And this goes for strings, arrays, dictionaries and possibly other types. Which means that you need to handle manually all of the bridging to ObjC types, which has really grown in Swift 3, taking into account all the Foundation types that are now structs.<br></p><p>I&#39;d call that a bug, not something requiring evolution discussion. We&#39;re trying to phase this behavior out of dynamic casts, though (see https://github.com/apple/swift-evolution/blob/master/proposals/0083-remove-bridging-from-dynamic-casts.md).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Detecting and working with Optionals from Any</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I&#39;d call that a bug, not something requiring evolution discussion. We&#39;re trying to phase this behavior out of dynamic casts, though (see https://github.com/apple/swift-evolution/blob/master/proposals/0083-remove-bridging-from-dynamic-casts.md).<br></p><p>Ok, I&#39;ve filed a bug report.<br></p><p>My suggestion to expose the Builtin.isOptional function though still stands since it may be of some use nevertheless.<br></p><p>&gt; <br>&gt; -Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
