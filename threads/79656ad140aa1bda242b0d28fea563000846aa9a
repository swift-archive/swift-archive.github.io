<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>June  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; True, but the cost of being able to restore the original ordering, when<br>&gt; that restoration may not be needed at all, is prohibitive.<br></p><p>What about simply restoring the elements, in no particular order? This seems like an easy enough task, and I don’t think it requires the sorting algorithm to allocate any extra memory (in case no error is thrown, at least).<br></p><p>&gt; on Mon Jun 06 2016, Saagar Jha&lt;saagarjha28-AT-gmail.com&gt;wrote:<br>&gt; <br>&gt; &gt; Might I add that leaving an array in an arbitrary and<br>&gt; &gt; implementation-dependent state is also surprising to users as well as not<br>&gt; &gt; very useful-to the user this is nothing more than a random permutation.<br>&gt; True, but the cost of being able to restore the original ordering, when<br>&gt; that restoration may not be needed at all, is prohibitive. It&#39;s often<br>&gt; the case that the caller will be throwing away the partially-modified<br>&gt; original when an error is thrown.<br>&gt; <br>&gt; &gt; On Mon, Jun 6, 2016 at 5:31 PM Dave Abrahams via swift-evolution&lt;<br>&gt; &gt; swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; on Sun Jun 05 2016, Haravikk&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution&lt;<br>&gt; &gt; &gt; swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Most standard library functions that take a closure allow that<br>&gt; &gt; &gt; &gt; &gt; closure to throw (and those functions are subsequently marked with<br>&gt; &gt; &gt; &gt; &gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; this documented anywhere, but I assume this is because sorting can<br>&gt; &gt; &gt; &gt; &gt; happen in-place and it would be impossible to restore the array to<br>&gt; &gt; &gt; &gt; &gt; its original state without giving up performance. Correct me if I’m<br>&gt; &gt; &gt; &gt; &gt; wrong.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt; &gt; &gt; &gt; &gt; array in an intermediate state (where the elements are in an<br>&gt; &gt; &gt; &gt; &gt; arbitrary order) when an error is thrown. As long as this is<br>&gt; &gt; &gt; &gt; &gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt; &gt; &gt; &gt; &gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt; &gt; &gt; &gt; &gt; room for confusion at all because it doesn’t mutate any of the<br>&gt; &gt; &gt; &gt; &gt; user’s variables.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt; &gt; &gt; &gt; collection was sorted in one order, and is only partially sorted in a<br>&gt; &gt; &gt; &gt; new one, but the exception and your handling of it should be able to<br>&gt; &gt; &gt; &gt; account for this.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; It will require documentation to be clear that sorting methods should<br>&gt; &gt; &gt; &gt; take care not to leave anything incomplete if a closure throws; most<br>&gt; &gt; &gt; &gt; algorithms should be fine since they usually just test the closure<br>&gt; &gt; &gt; &gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt; &gt; &gt; &gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt; &gt; &gt; &gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt; &gt; &gt; &gt; elements are ever lost.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Ensuring that no elements are ever lost is not a particularly useful<br>&gt; &gt; &gt; goal, and not a constraint to which I would want to hold the standard<br>&gt; &gt; &gt; library.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; --<br>&gt; &gt; &gt; Dave<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; --<br>&gt; Dave<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 12:07 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; True, but the cost of being able to restore the original ordering, when<br>&gt;&gt; that restoration may not be needed at all, is prohibitive.<br>&gt; <br>&gt; What about simply restoring the elements, in no particular order? This seems like an easy enough task, and I don’t think it requires the sorting algorithm to allocate any extra memory (in case no error is thrown, at least).<br></p><p>What is the example that motivates this?  Is there a widely used comparison function that throws?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Is there a widely used comparison function that throws?<br></p><p>Any comparison function that examines external data related to the instance:<br></p><p>* Sorting filenames by the data in the corresponding files<br>* Instances backed by a database where actually loading the data could fail<br>* Etc.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 7:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Is there a widely used comparison function that throws?<br>&gt; <br>&gt; Any comparison function that examines external data related to the instance:<br>&gt; <br>&gt; * Sorting filenames by the data in the corresponding files<br>&gt; * Instances backed by a database where actually loading the data could fail<br>&gt; * Etc.<br></p><p>Ok, instead of using rethrows, would it be a better overall design be to define two overloads, one that takes a throwing closure and one that doesn’t?  This allows the throw-supporting implementation to be slower without punishing the normal case..<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>+1 This is straightforward and self-documenting.<br></p><p>&gt; On Jun 8, 2016, at 11:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 7:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Is there a widely used comparison function that throws?<br>&gt;&gt; <br>&gt;&gt; Any comparison function that examines external data related to the instance:<br>&gt;&gt; <br>&gt;&gt; * Sorting filenames by the data in the corresponding files<br>&gt;&gt; * Instances backed by a database where actually loading the data could fail<br>&gt;&gt; * Etc.<br>&gt; <br>&gt; Ok, instead of using rethrows, would it be a better overall design be to define two overloads, one that takes a throwing closure and one that doesn’t?  This allows the throw-supporting implementation to be slower without punishing the normal case..<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Chris Lattner &lt;clattner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 7:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Is there a widely used comparison function that throws?<br>&gt;&gt; <br>&gt;&gt; Any comparison function that examines external data related to the instance:<br>&gt;&gt; <br>&gt;&gt; * Sorting filenames by the data in the corresponding files<br>&gt;&gt; * Instances backed by a database where actually loading the data could fail<br>&gt;&gt; * Etc.<br>&gt;<br>&gt; Ok, instead of using rethrows, would it be a better overall design be<br>&gt; to define two overloads, one that takes a throwing closure and one<br>&gt; that doesn’t?  This allows the throw-supporting implementation to be<br>&gt; slower without punishing the normal case..<br></p><p>There is *no reason* to do this.<br></p><p>* Most sorting algorithms can be written so that even if the comparison<br>  throws, no elements are lost<br></p><p>* Even if elements were lost—though it might indeed be surprising—it&#39;s<br>  not actually a problem we should solve, especially not by penalizing<br>  performance.  It&#39;s *very* unlikely that a partially scrambled<br>  collection is of any use to the caller in real code.<br></p><p>* Giving commit-or-rollback semantics for every operation is not<br>  something we should do by penalizing performance. Commit-or-rollback<br>  does not compose, and therefore ends up uselessly penalizing<br>  performance in compositions.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 11:06, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Chris Lattner &lt;clattner-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 7:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a widely used comparison function that throws?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any comparison function that examines external data related to the instance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Sorting filenames by the data in the corresponding files<br>&gt;&gt;&gt; * Instances backed by a database where actually loading the data could fail<br>&gt;&gt;&gt; * Etc.<br>&gt;&gt; <br>&gt;&gt; Ok, instead of using rethrows, would it be a better overall design be<br>&gt;&gt; to define two overloads, one that takes a throwing closure and one<br>&gt;&gt; that doesn’t?  This allows the throw-supporting implementation to be<br>&gt;&gt; slower without punishing the normal case..<br>&gt; <br>&gt; There is *no reason* to do this.<br>&gt; <br>&gt; * Most sorting algorithms can be written so that even if the comparison<br>&gt;  throws, no elements are lost<br>&gt; <br>&gt; * Even if elements were lost—though it might indeed be surprising—it&#39;s<br>&gt;  not actually a problem we should solve, especially not by penalizing<br>&gt;  performance.  It&#39;s *very* unlikely that a partially scrambled<br>&gt;  collection is of any use to the caller in real code.<br>&gt; <br>&gt; * Giving commit-or-rollback semantics for every operation is not<br>&gt;  something we should do by penalizing performance. Commit-or-rollback<br>&gt;  does not compose, and therefore ends up uselessly penalizing<br>&gt;  performance in compositions.<br></p><p>FWIW Dave gave me most of the same feedback in the discussion on the proof-of-concept pull request: https://github.com/apple/swift/pull/1527#discussion_r60811569 &lt;https://github.com/apple/swift/pull/1527#discussion_r60811569&gt;<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/efd657fa/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 7:21 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 7:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a widely used comparison function that throws?<br>&gt;&gt; <br>&gt;&gt; Any comparison function that examines external data related to the instance:<br>&gt;&gt; <br>&gt;&gt; * Sorting filenames by the data in the corresponding files<br>&gt;&gt; * Instances backed by a database where actually loading the data could fail<br>&gt;&gt; * Etc.<br>&gt; <br>&gt; Ok, instead of using rethrows, would it be a better overall design be to define two overloads, one that takes a throwing closure and one that doesn’t?  This allows the throw-supporting implementation to be slower without punishing the normal case..<br>&gt; <br></p><p>Smilar solution to what java did.<br></p><p><br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; Is there a widely used comparison function that throws?<br>&gt;<br>&gt; Any comparison function that examines external data related to the instance:<br>&gt;<br>&gt; * Sorting filenames by the data in the corresponding files<br>&gt;<br>&gt; * Instances backed by a database where actually loading the data could<br>&gt;   fail<br>&gt; <br>&gt; * Etc.<br></p><p>I&#39;m not sure that these ideas are consistent with the Swift<br>error-handling philosophy, which IIUC is very consciously designed *not*<br>to support things like file- and database-backed Collections.  My<br>understanding is that if you have something like that, you&#39;re not<br>supposed to throw errors on failure, but instead find some alternative<br>means of error handling.  These cases seem very much in the same<br>ballpark.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt; to support things like file- and database-backed Collections.  My<br>&gt; understanding is that if you have something like that, you&#39;re not<br>&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt; means of error handling.  These cases seem very much in the same<br>&gt; ballpark.<br></p><p>I&#39;m not talking about the Collection itself being backed by a file, but rather the instances inside it being backed by a file. I suppose you&#39;re trying to acknowledge that distinction when you say these cases are &quot;in the same ballpark&quot;, but I don&#39;t think that&#39;s really a sustainable objection. There *are* sensible alternatives, like the early-terminating block pattern, to throwing sequences and perhaps even throwing collections:<br></p><p>	try database.withQuery(sql) { rows in<br>		for row in rows {<br>			// If fetching a row fails, this loop terminates early and `withQuery` throws<br>			…<br>		}<br>	}<br></p><p>But throwing operations on stuff-inside-a-collection? That&#39;s just part of the language, and making errors during sorting extraordinarily difficult to handle won&#39;t stop the errors from being possible.<br></p><p>* * *<br></p><p>I actually think there *is* a sensible way to define the behavior of a throwing `sort(_:)`: you treat the comparison as though it returned `false` and continue sorting. If there&#39;s any sort of stability to the errors being thrown by `isOrderedBefore`, this will end up behaving like a sort with unordered elements, much like an array of floating-point types with some NaNs in it. You not be able to rethrow all of the errors encountered during the sort—you&#39;d have to pick the first or last—but a representative error would probably cover the use cases here.<br></p><p>You could implement this with today&#39;s Swift in terms of our existing `sort(_:)`:<br></p><p>	mutating func sort(isOrderedBefore: (Element, Element) throws -&gt; Bool) throws {<br>		var lastError: Error?<br>		<br>		sort {<br>			do {<br>				return try isOrderedBefore($0, $1)<br>			}<br>			catch {<br>				lastError = error<br>				return false<br>			}<br>		}<br>			<br>		if lastError = lastError { throw lastError }<br>	}<br></p><p>I don&#39;t think you could currently do one version with `rethrows`, because any way you do this, you&#39;ll need to save an error in a variable and `throw` it later, which I don&#39;t believe `rethrows` will permit. However, I saw a suggestion in the bottom type thread that, given both a `throws` keyword that can take an error type and a bottom type to represent the error type of a non-throwing function, `rethrows` could essentially be syntactic sugar for a function with a generic error type. This would give us additional flexibility in cases like this where `rethrows` doesn&#39;t quite do what we need.<br></p><p>With the necessary features in place, we could implement a `rethrows`-ish `sort(_:)` like this:<br></p><p>	// This declaration has rethrows-like behavior: if `isOrderedBefore`&#39;s error type is `Never`, then <br>	// `sort(_:)`&#39;s error type is also `Never`, and there&#39;s no reason to require a `try` on the call to this method.<br>	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws Error {<br>		var lastError: Error?<br>		<br>		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>			do {<br>				return try isOrderedBefore(a, b)<br>			}<br>			catch {<br>				lastError = error<br>				return false<br>			}<br>		}<br>		<br>		// Do the actual sorting here.<br>			<br>		if lastError = lastError { throw lastError }<br>	 }<br></p><p>With a fair bit of work, it might even be possible to allow it to throw *all* of the errors it encountered:<br></p><p>	// This is structured slightly strangely to ensure that, if Error is Never, then MultipleErrors&lt;Never&gt; <br>	// is an empty enum (since all cases require a Never associated value), and thus (hopefully!) <br>	// is itself a synonym for Never.<br>	enum MultipleErrors&lt;Error: ErrorProtocol&gt;: ErrorProtocol {<br>		case one (Error)<br>		indirect case many (Error, ErrorList&lt;Error&gt;)<br>		<br>		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt; {<br>			switch self {<br>			case let .one(oldError):<br>				return .many(oldError, .one(newError))<br>			case let .many(firstError, restErrors):<br>				return .many(firstError, restErrors.appending(newError))<br>			}<br>		}		<br>	}<br>	<br>	extension&lt;Error: ErrorProtocol&gt; Optional where Wrapped == MultipleErrors&lt;Error&gt; {<br>		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt;? {<br>			switch self {<br>			case .none:<br>				return .some(.one(newError))<br>			case .some(let errors):<br>				return .some(errors.appending(newError))<br>			}<br>		}<br>	}<br>	<br>	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws MultipleErrors&lt;Error&gt; {<br>		var errors: MultipleErrors&lt;Error&gt;?<br>		<br>		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>			do {<br>				return try isOrderedBefore(a, b)<br>			}<br>			catch {<br>				errors = errors.appending(error)<br>				return false<br>			}<br>		}<br>		<br>		// Do the actual sorting here.<br>			<br>		if errors = errors { throw errors }<br>	 }<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June  9, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, Jun 8, 2016 at 11:25 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I actually think there *is* a sensible way to define the behavior of a throwing `sort(_:)`: you treat the comparison as though it returned `false` and continue sorting.<br></p><p>This can create inconsistent sorting predicates, which we would want<br>to catch as issues with the code and trap.<br></p><p>For example, your predicate can establish that a &lt; b and b &lt; c, but a<br>&lt; c is throwing which is treated as returning false -- clearly, a<br>contradiction.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt; ballpark.<br>&gt;<br>&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt; but rather the instances inside it being backed by a file. <br></p><p>Those amount to the same thing.  If instances can be backed by a file,<br>subscripting needs to be able to throw, and therefore practically every<br>generic function (or protocol extension method) on Collection would also<br>need to be marked as throwing.  When Swift error handling was designed,<br>it was decided that these cases were out-of-scope.<br></p><p>&gt; I suppose you&#39;re trying to acknowledge that distinction when you say<br>&gt; these cases are &quot;in the same ballpark&quot;, but I don&#39;t think that&#39;s<br>&gt; really a sustainable objection.<br></p><p>Why not?<br></p><p>&gt; There *are* sensible alternatives, like the early-terminating block<br>&gt; pattern, to throwing sequences and perhaps even throwing collections:<br>&gt;<br>&gt; 	try database.withQuery(sql) { rows in<br>&gt; 		for row in rows {<br>&gt; 			// If fetching a row fails, this loop terminates early and `withQuery` throws<br>&gt; 			…<br>&gt; 		}<br>&gt; 	}<br></p><p>That strategy doesn&#39;t begin to cover the use cases for collections.<br></p><p>Also, how is it supposed to work? You need a way to report a failure to<br>fetch the row—a way that doesn&#39;t involve throwing.  Who terminates the<br>loop, and how?  How does withQuery detect that the loop exited early?<br></p><p>&gt; But throwing operations on stuff-inside-a-collection? That&#39;s just part<br>&gt; of the language, and making errors during sorting extraordinarily<br>&gt; difficult to handle won&#39;t stop the errors from being possible.<br></p><p>There&#39;s basically no distinction.  If it&#39;s reasonable to have sort with<br>a throwing predicate, it&#39;s also reasonable to have a Comparable type<br>whose &lt; operator throws, and it&#39;s reasonable to use the sort overload<br>that takes no explicit predicate, and now you have a Collection protocol<br>method that throws directly, rather than rethrowing.  IIUC from the<br>people who designed Swift error handling, if you find yourself doing<br>that, you&#39;ve done something wrong.<br></p><p>&gt; * * *<br>&gt;<br>&gt; I actually think there *is* a sensible way to define the behavior of a<br>&gt; throwing `sort(_:)`: you treat the comparison as though it returned<br>&gt; `false` and continue sorting. <br>&gt; If there&#39;s any sort of stability to the errors being thrown by<br>&gt; `isOrderedBefore`, this will end up behaving like a sort with<br>&gt; unordered elements, much like an array of floating-point types with<br>&gt; some NaNs in it. You not be able to rethrow all of the errors<br>&gt; encountered during the sort—you&#39;d have to pick the first or last—but a<br>&gt; representative error would probably cover the use cases here.<br></p><p>As Dmitri pointed out, that predicate doesn&#39;t satisfy the requirements<br>for sorting.  It&#39;s quite possible that a predicate that doesn&#39;t satisfy<br>an algorithm&#39;s requirements causes the algorithm to do invalid indexing<br>or some other evil nonsense.<br></p><p>&gt; You could implement this with today&#39;s Swift in terms of our existing `sort(_:)`:<br>&gt;<br>&gt; 	mutating func sort(isOrderedBefore: (Element, Element) throws -&gt; Bool) throws {<br>&gt; 		var lastError: Error?<br>&gt;<br>&gt; 		sort {<br>&gt; 			do {<br>&gt; 				return try isOrderedBefore($0, $1)<br>&gt; 			}<br>&gt; 			catch {<br>&gt; 				lastError = error<br>&gt; 				return false<br>&gt; 			}<br>&gt; 		}<br>&gt;<br>&gt; 		if lastError = lastError { throw lastError }<br>&gt; 	}<br></p><p>Aside from the problems mentioned above, this is extremely inefficient<br>if the collection is large and backed a resource that fails slowly, such<br>as a network connection with retry and timeout.<br></p><p>&gt; I don&#39;t think you could currently do one version with `rethrows`,<br>&gt; because any way you do this, you&#39;ll need to save an error in a<br>&gt; variable and `throw` it later, which I don&#39;t believe `rethrows` will<br>&gt; permit. <br></p><p>Right.  That&#39;s a problem with the error-handling model.<br></p><p>&gt; However, I saw a suggestion in the bottom type thread that, given both<br>&gt; a `throws` keyword that can take an error type and a bottom type to<br>&gt; represent the error type of a non-throwing function, `rethrows` could<br>&gt; essentially be syntactic sugar for a function with a generic error<br>&gt; type. This would give us additional flexibility in cases like this<br>&gt; where `rethrows` doesn&#39;t quite do what we need.<br>&gt;<br>&gt; With the necessary features in place, we could implement a `rethrows`-ish `sort(_:)` like this:<br>&gt;<br>&gt; 	// This declaration has rethrows-like behavior: if `isOrderedBefore`&#39;s error type is `Never`, then <br>&gt; 	// `sort(_:)`&#39;s error type is also `Never`, and there&#39;s no reason to require a `try` on the call to this method.<br>&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws Error {<br>&gt; 		var lastError: Error?<br>&gt;<br>&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt; 			do {<br>&gt; 				return try isOrderedBefore(a, b)<br>&gt; 			}<br>&gt; 			catch {<br>&gt; 				lastError = error<br>&gt; 				return false<br>&gt; 			}<br>&gt; 		}<br>&gt;<br>&gt; 		// Do the actual sorting here.<br>&gt;<br>&gt; 		if lastError = lastError { throw lastError }<br>&gt; 	 }<br></p><p>That&#39;s cute, but IIUC the designers of the error handling model<br>explicitly did *not* want to thread throwing-ness through generics in<br>this way.  This is roughly the same mechanism as would be required to<br>accomplish other things I&#39;d like to see, like the<br>sorting-throwing-Comparables thing I mentioned above, but that were<br>designed out of the model.<br></p><p>FWIW, it would need to be generalized further, in case there were two<br>operations that throw different Error types.  Also, I know some will<br>disagree, but IMO you really don&#39;t want to get into a situation where<br>people are annotating most throwing functions with the exact Error types<br>that can be thrown.<br></p><p>You need a way to express the type<br></p><p>    if (E0, E1, ... EN).contains(Bottom) then Bottom else ErrorProtocol<br></p><p>where Ei is one of the thrown error types, and for protocol methods that<br>are not marked with an explicit throws annotation, that type should be<br>synthesized automatically from the error types that can propagate from<br>any operations in protocol dependencies... but ah, as I say, IIUC this<br>sort of thing was designed out of the model.  <br></p><p>My point isn&#39;t that what you&#39;re trying to do is wrong.  My point is that<br>it seems inconsistent with the Swift approach to error-handling, and<br>that if you want to do these things, you may need to convince someone to<br>change that approach.<br></p><p>&gt; With a fair bit of work, it might even be possible to allow it to throw *all* of the errors it encountered:<br>&gt;<br>&gt; 	// This is structured slightly strangely to ensure that, if Error is Never, then MultipleErrors&lt;Never&gt; <br>&gt; 	// is an empty enum (since all cases require a Never associated value), and thus (hopefully!) <br>&gt; 	// is itself a synonym for Never.<br>&gt; 	enum MultipleErrors&lt;Error: ErrorProtocol&gt;: ErrorProtocol {<br>&gt; 		case one (Error)<br>&gt; 		indirect case many (Error, ErrorList&lt;Error&gt;)<br>&gt;<br>&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt; {<br>&gt; 			switch self {<br>&gt; 			case let .one(oldError):<br>&gt; 				return .many(oldError, .one(newError))<br>&gt; 			case let .many(firstError, restErrors):<br>&gt; 				return .many(firstError, restErrors.appending(newError))<br>&gt; 			}<br>&gt; 		}		<br>&gt; 	}<br>&gt;<br>&gt; 	extension&lt;Error: ErrorProtocol&gt; Optional where Wrapped == MultipleErrors&lt;Error&gt; {<br>&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt;? {<br>&gt; 			switch self {<br>&gt; 			case .none:<br>&gt; 				return .some(.one(newError))<br>&gt; 			case .some(let errors):<br>&gt; 				return .some(errors.appending(newError))<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt;<br>&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws MultipleErrors&lt;Error&gt; {<br>&gt; 		var errors: MultipleErrors&lt;Error&gt;?<br>&gt;<br>&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt; 			do {<br>&gt; 				return try isOrderedBefore(a, b)<br>&gt; 			}<br>&gt; 			catch {<br>&gt; 				errors = errors.appending(error)<br>&gt; 				return false<br>&gt; 			}<br>&gt; 		}<br>&gt;<br>&gt; 		// Do the actual sorting here.<br>&gt;<br>&gt; 		if errors = errors { throw errors }<br>&gt; 	 }<br></p><p>IMO that would be a collosal waste of resources.  The only interesting<br>error is the first one.  This is notionally a sort that failed partway<br>through, and that we had no mechanism for interrupting.  The fact that<br>you have to continue sorting after that error is just an artifact of<br>language limitations.  Either we should reaffirm our current (implicit)<br>declaration that these kinds of use-cases are off the table for Swift<br>error handling, or the philosophy of Swift error-handling should change<br>to allow us to support stopping at the right time.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt; ballpark.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt; <br>&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt; generic function (or protocol extension method) on Collection would also<br>&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt; it was decided that these cases were out-of-scope.<br></p><p>Right.  It would be simple to change core library protocols to permit operations<br>to throw, but then every use of an algorithm over those protocols would throw.<br>This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>more complex to apply to protocol conformances because you need to be more<br>specific about which requirements, exactly, will cause you to rethrow.  It also<br>causes problems for generic types, which might have arbitrary methods that<br>rethrow based on the conformances of their generic arguments; and perhaps<br>the result of that decision would also need to be expressible in a rethrow constraint<br>on some other operation, etc.  We haven&#39;t been able to find a language design<br>here that isn&#39;t extremely bureaucratic.<br></p><p>In short, there are three options that we have discovered so far:<br>1) Introduce massive complexity and bureaucracy into the generics system<br>  to propagate rethrows-like dependencies on throwing conformances.<br>2) Abandon typed propagation.<br>3) Force protocols to make a choice, with the understanding that this will<br>  generally mean forbidding throwing conformances.<br></p><p>We do not consider (1) or (2) acceptable, so we chose (3).  If someone finds a way<br>to express typed propagation in generics at minimal expressive cost, we&#39;d be<br>happy to reconsider this decision.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; I suppose you&#39;re trying to acknowledge that distinction when you say<br>&gt;&gt; these cases are &quot;in the same ballpark&quot;, but I don&#39;t think that&#39;s<br>&gt;&gt; really a sustainable objection.<br>&gt; <br>&gt; Why not?<br>&gt; <br>&gt;&gt; There *are* sensible alternatives, like the early-terminating block<br>&gt;&gt; pattern, to throwing sequences and perhaps even throwing collections:<br>&gt;&gt; <br>&gt;&gt; 	try database.withQuery(sql) { rows in<br>&gt;&gt; 		for row in rows {<br>&gt;&gt; 			// If fetching a row fails, this loop terminates early and `withQuery` throws<br>&gt;&gt; 			…<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt; <br>&gt; That strategy doesn&#39;t begin to cover the use cases for collections.<br>&gt; <br>&gt; Also, how is it supposed to work? You need a way to report a failure to<br>&gt; fetch the row—a way that doesn&#39;t involve throwing.  Who terminates the<br>&gt; loop, and how?  How does withQuery detect that the loop exited early?<br>&gt; <br>&gt;&gt; But throwing operations on stuff-inside-a-collection? That&#39;s just part<br>&gt;&gt; of the language, and making errors during sorting extraordinarily<br>&gt;&gt; difficult to handle won&#39;t stop the errors from being possible.<br>&gt; <br>&gt; There&#39;s basically no distinction.  If it&#39;s reasonable to have sort with<br>&gt; a throwing predicate, it&#39;s also reasonable to have a Comparable type<br>&gt; whose &lt; operator throws, and it&#39;s reasonable to use the sort overload<br>&gt; that takes no explicit predicate, and now you have a Collection protocol<br>&gt; method that throws directly, rather than rethrowing.  IIUC from the<br>&gt; people who designed Swift error handling, if you find yourself doing<br>&gt; that, you&#39;ve done something wrong.<br>&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; I actually think there *is* a sensible way to define the behavior of a<br>&gt;&gt; throwing `sort(_:)`: you treat the comparison as though it returned<br>&gt;&gt; `false` and continue sorting. <br>&gt;&gt; If there&#39;s any sort of stability to the errors being thrown by<br>&gt;&gt; `isOrderedBefore`, this will end up behaving like a sort with<br>&gt;&gt; unordered elements, much like an array of floating-point types with<br>&gt;&gt; some NaNs in it. You not be able to rethrow all of the errors<br>&gt;&gt; encountered during the sort—you&#39;d have to pick the first or last—but a<br>&gt;&gt; representative error would probably cover the use cases here.<br>&gt; <br>&gt; As Dmitri pointed out, that predicate doesn&#39;t satisfy the requirements<br>&gt; for sorting.  It&#39;s quite possible that a predicate that doesn&#39;t satisfy<br>&gt; an algorithm&#39;s requirements causes the algorithm to do invalid indexing<br>&gt; or some other evil nonsense.<br>&gt; <br>&gt;&gt; You could implement this with today&#39;s Swift in terms of our existing `sort(_:)`:<br>&gt;&gt; <br>&gt;&gt; 	mutating func sort(isOrderedBefore: (Element, Element) throws -&gt; Bool) throws {<br>&gt;&gt; 		var lastError: Error?<br>&gt;&gt; <br>&gt;&gt; 		sort {<br>&gt;&gt; 			do {<br>&gt;&gt; 				return try isOrderedBefore($0, $1)<br>&gt;&gt; 			}<br>&gt;&gt; 			catch {<br>&gt;&gt; 				lastError = error<br>&gt;&gt; 				return false<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; <br>&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt; 	}<br>&gt; <br>&gt; Aside from the problems mentioned above, this is extremely inefficient<br>&gt; if the collection is large and backed a resource that fails slowly, such<br>&gt; as a network connection with retry and timeout.<br>&gt; <br>&gt;&gt; I don&#39;t think you could currently do one version with `rethrows`,<br>&gt;&gt; because any way you do this, you&#39;ll need to save an error in a<br>&gt;&gt; variable and `throw` it later, which I don&#39;t believe `rethrows` will<br>&gt;&gt; permit. <br>&gt; <br>&gt; Right.  That&#39;s a problem with the error-handling model.<br>&gt; <br>&gt;&gt; However, I saw a suggestion in the bottom type thread that, given both<br>&gt;&gt; a `throws` keyword that can take an error type and a bottom type to<br>&gt;&gt; represent the error type of a non-throwing function, `rethrows` could<br>&gt;&gt; essentially be syntactic sugar for a function with a generic error<br>&gt;&gt; type. This would give us additional flexibility in cases like this<br>&gt;&gt; where `rethrows` doesn&#39;t quite do what we need.<br>&gt;&gt; <br>&gt;&gt; With the necessary features in place, we could implement a `rethrows`-ish `sort(_:)` like this:<br>&gt;&gt; <br>&gt;&gt; 	// This declaration has rethrows-like behavior: if `isOrderedBefore`&#39;s error type is `Never`, then <br>&gt;&gt; 	// `sort(_:)`&#39;s error type is also `Never`, and there&#39;s no reason to require a `try` on the call to this method.<br>&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws Error {<br>&gt;&gt; 		var lastError: Error?<br>&gt;&gt; <br>&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt; 			do {<br>&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt; 			}<br>&gt;&gt; 			catch {<br>&gt;&gt; 				lastError = error<br>&gt;&gt; 				return false<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; <br>&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt; <br>&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt; 	 }<br>&gt; <br>&gt; That&#39;s cute, but IIUC the designers of the error handling model<br>&gt; explicitly did *not* want to thread throwing-ness through generics in<br>&gt; this way.  This is roughly the same mechanism as would be required to<br>&gt; accomplish other things I&#39;d like to see, like the<br>&gt; sorting-throwing-Comparables thing I mentioned above, but that were<br>&gt; designed out of the model.<br>&gt; <br>&gt; FWIW, it would need to be generalized further, in case there were two<br>&gt; operations that throw different Error types.  Also, I know some will<br>&gt; disagree, but IMO you really don&#39;t want to get into a situation where<br>&gt; people are annotating most throwing functions with the exact Error types<br>&gt; that can be thrown.<br>&gt; <br>&gt; You need a way to express the type<br>&gt; <br>&gt;    if (E0, E1, ... EN).contains(Bottom) then Bottom else ErrorProtocol<br>&gt; <br>&gt; where Ei is one of the thrown error types, and for protocol methods that<br>&gt; are not marked with an explicit throws annotation, that type should be<br>&gt; synthesized automatically from the error types that can propagate from<br>&gt; any operations in protocol dependencies... but ah, as I say, IIUC this<br>&gt; sort of thing was designed out of the model.  <br>&gt; <br>&gt; My point isn&#39;t that what you&#39;re trying to do is wrong.  My point is that<br>&gt; it seems inconsistent with the Swift approach to error-handling, and<br>&gt; that if you want to do these things, you may need to convince someone to<br>&gt; change that approach.<br>&gt; <br>&gt;&gt; With a fair bit of work, it might even be possible to allow it to throw *all* of the errors it encountered:<br>&gt;&gt; <br>&gt;&gt; 	// This is structured slightly strangely to ensure that, if Error is Never, then MultipleErrors&lt;Never&gt; <br>&gt;&gt; 	// is an empty enum (since all cases require a Never associated value), and thus (hopefully!) <br>&gt;&gt; 	// is itself a synonym for Never.<br>&gt;&gt; 	enum MultipleErrors&lt;Error: ErrorProtocol&gt;: ErrorProtocol {<br>&gt;&gt; 		case one (Error)<br>&gt;&gt; 		indirect case many (Error, ErrorList&lt;Error&gt;)<br>&gt;&gt; <br>&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt; {<br>&gt;&gt; 			switch self {<br>&gt;&gt; 			case let .one(oldError):<br>&gt;&gt; 				return .many(oldError, .one(newError))<br>&gt;&gt; 			case let .many(firstError, restErrors):<br>&gt;&gt; 				return .many(firstError, restErrors.appending(newError))<br>&gt;&gt; 			}<br>&gt;&gt; 		}		<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension&lt;Error: ErrorProtocol&gt; Optional where Wrapped == MultipleErrors&lt;Error&gt; {<br>&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt;? {<br>&gt;&gt; 			switch self {<br>&gt;&gt; 			case .none:<br>&gt;&gt; 				return .some(.one(newError))<br>&gt;&gt; 			case .some(let errors):<br>&gt;&gt; 				return .some(errors.appending(newError))<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws MultipleErrors&lt;Error&gt; {<br>&gt;&gt; 		var errors: MultipleErrors&lt;Error&gt;?<br>&gt;&gt; <br>&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt; 			do {<br>&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt; 			}<br>&gt;&gt; 			catch {<br>&gt;&gt; 				errors = errors.appending(error)<br>&gt;&gt; 				return false<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; <br>&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt; <br>&gt;&gt; 		if errors = errors { throw errors }<br>&gt;&gt; 	 }<br>&gt; <br>&gt; IMO that would be a collosal waste of resources.  The only interesting<br>&gt; error is the first one.  This is notionally a sort that failed partway<br>&gt; through, and that we had no mechanism for interrupting.  The fact that<br>&gt; you have to continue sorting after that error is just an artifact of<br>&gt; language limitations.  Either we should reaffirm our current (implicit)<br>&gt; declaration that these kinds of use-cases are off the table for Swift<br>&gt; error handling, or the philosophy of Swift error-handling should change<br>&gt; to allow us to support stopping at the right time.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/d5ea9a43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 12:00:00pm</p></header><div class="content"><p>on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;<br>&gt;&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt;&gt; ballpark.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt;&gt; <br>&gt;&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt;&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt;&gt; generic function (or protocol extension method) on Collection would also<br>&gt;&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt;&gt; it was decided that these cases were out-of-scope.<br>&gt;<br>&gt; Right.  It would be simple to change core library protocols to permit operations<br>&gt; to throw, but then every use of an algorithm over those protocols would throw.<br>&gt; This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>&gt; more complex to apply to protocol conformances because you need to be more<br>&gt; specific about which requirements, exactly, will cause you to rethrow.  <br></p><p>Can you show an example?  It seems simple to me: if you&#39;re going to<br>possibly rethrow you can use any requirements that might throw, and if<br>you&#39;re not going to rethrow then you can&#39;t.<br></p><p>&gt; It also causes problems for generic types, which might have arbitrary<br>&gt; methods that rethrow based on the conformances of their generic<br>&gt; arguments; and perhaps the result of that decision would also need to<br>&gt; be expressible in a rethrow constraint on some other operation, etc.<br>&gt; We haven&#39;t been able to find a language design here that isn&#39;t<br>&gt; extremely bureaucratic.<br></p><p>We also haven&#39;t really tried, IMO.  My understanding was that Swift<br>error handling was explicitly *not supposed* to handle these cases, as<br>though it was a design goal.  When you start with that as a basis you&#39;re<br>not going to find a good answer because you&#39;re not supposed to be<br>solving the problem in the first place.<br></p><p>&gt; In short, there are three options that we have discovered so far:<br>&gt; 1) Introduce massive complexity and bureaucracy into the generics system<br>&gt;   to propagate rethrows-like dependencies on throwing conformances.<br>&gt; 2) Abandon typed propagation.<br>&gt; 3) Force protocols to make a choice, with the understanding that this will<br>&gt;   generally mean forbidding throwing conformances.<br>&gt;<br>&gt; We do not consider (1) or (2) acceptable, so we chose (3).  If someone<br>&gt; finds a way to express typed propagation in generics at minimal<br>&gt; expressive cost, we&#39;d be happy to reconsider this decision.<br></p><p>AFAICT, this is not that hard to do.  IIUC, my original proposal for the<br>“rethrows” keyword would have solved these problems.  My understanding<br>was that it got no traction because solving them was considered an<br>anti-goal.<br></p><p>&gt;&gt;&gt; I suppose you&#39;re trying to acknowledge that distinction when you say<br>&gt;&gt;&gt; these cases are &quot;in the same ballpark&quot;, but I don&#39;t think that&#39;s<br>&gt;&gt;&gt; really a sustainable objection.<br>&gt;&gt; <br>&gt;&gt; Why not?<br>&gt;&gt; <br>&gt;&gt;&gt; There *are* sensible alternatives, like the early-terminating block<br>&gt;&gt;&gt; pattern, to throwing sequences and perhaps even throwing collections:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	try database.withQuery(sql) { rows in<br>&gt;&gt;&gt; 		for row in rows {<br>&gt;&gt;&gt; 			// If fetching a row fails, this loop terminates early and `withQuery` throws<br>&gt;&gt;&gt; 			…<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That strategy doesn&#39;t begin to cover the use cases for collections.<br>&gt;&gt; <br>&gt;&gt; Also, how is it supposed to work? You need a way to report a failure to<br>&gt;&gt; fetch the row—a way that doesn&#39;t involve throwing.  Who terminates the<br>&gt;&gt; loop, and how?  How does withQuery detect that the loop exited early?<br>&gt;&gt; <br>&gt;&gt;&gt; But throwing operations on stuff-inside-a-collection? That&#39;s just part<br>&gt;&gt;&gt; of the language, and making errors during sorting extraordinarily<br>&gt;&gt;&gt; difficult to handle won&#39;t stop the errors from being possible.<br>&gt;&gt; <br>&gt;&gt; There&#39;s basically no distinction.  If it&#39;s reasonable to have sort with<br>&gt;&gt; a throwing predicate, it&#39;s also reasonable to have a Comparable type<br>&gt;&gt; whose &lt; operator throws, and it&#39;s reasonable to use the sort overload<br>&gt;&gt; that takes no explicit predicate, and now you have a Collection protocol<br>&gt;&gt; method that throws directly, rather than rethrowing.  IIUC from the<br>&gt;&gt; people who designed Swift error handling, if you find yourself doing<br>&gt;&gt; that, you&#39;ve done something wrong.<br>&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually think there *is* a sensible way to define the behavior of a<br>&gt;&gt;&gt; throwing `sort(_:)`: you treat the comparison as though it returned<br>&gt;&gt;&gt; `false` and continue sorting. <br>&gt;&gt;&gt; If there&#39;s any sort of stability to the errors being thrown by<br>&gt;&gt;&gt; `isOrderedBefore`, this will end up behaving like a sort with<br>&gt;&gt;&gt; unordered elements, much like an array of floating-point types with<br>&gt;&gt;&gt; some NaNs in it. You not be able to rethrow all of the errors<br>&gt;&gt;&gt; encountered during the sort—you&#39;d have to pick the first or last—but a<br>&gt;&gt;&gt; representative error would probably cover the use cases here.<br>&gt;&gt; <br>&gt;&gt; As Dmitri pointed out, that predicate doesn&#39;t satisfy the requirements<br>&gt;&gt; for sorting.  It&#39;s quite possible that a predicate that doesn&#39;t satisfy<br>&gt;&gt; an algorithm&#39;s requirements causes the algorithm to do invalid indexing<br>&gt;&gt; or some other evil nonsense.<br>&gt;&gt; <br>&gt;&gt;&gt; You could implement this with today&#39;s Swift in terms of our existing `sort(_:)`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	mutating func sort(isOrderedBefore: (Element, Element) throws -&gt; Bool) throws {<br>&gt;&gt;&gt; 		var lastError: Error?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		sort {<br>&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt; 				return try isOrderedBefore($0, $1)<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt; 				lastError = error<br>&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Aside from the problems mentioned above, this is extremely inefficient<br>&gt;&gt; if the collection is large and backed a resource that fails slowly, such<br>&gt;&gt; as a network connection with retry and timeout.<br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think you could currently do one version with `rethrows`,<br>&gt;&gt;&gt; because any way you do this, you&#39;ll need to save an error in a<br>&gt;&gt;&gt; variable and `throw` it later, which I don&#39;t believe `rethrows` will<br>&gt;&gt;&gt; permit. <br>&gt;&gt; <br>&gt;&gt; Right.  That&#39;s a problem with the error-handling model.<br>&gt;&gt; <br>&gt;&gt;&gt; However, I saw a suggestion in the bottom type thread that, given both<br>&gt;&gt;&gt; a `throws` keyword that can take an error type and a bottom type to<br>&gt;&gt;&gt; represent the error type of a non-throwing function, `rethrows` could<br>&gt;&gt;&gt; essentially be syntactic sugar for a function with a generic error<br>&gt;&gt;&gt; type. This would give us additional flexibility in cases like this<br>&gt;&gt;&gt; where `rethrows` doesn&#39;t quite do what we need.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the necessary features in place, we could implement a `rethrows`-ish `sort(_:)` like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// This declaration has rethrows-like behavior: if `isOrderedBefore`&#39;s error type is `Never`, then <br>&gt;&gt;&gt; 	// `sort(_:)`&#39;s error type is also `Never`, and there&#39;s no reason to require a `try` on the call to this method.<br>&gt;&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws Error {<br>&gt;&gt;&gt; 		var lastError: Error?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt; 				lastError = error<br>&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt;&gt; 	 }<br>&gt;&gt; <br>&gt;&gt; That&#39;s cute, but IIUC the designers of the error handling model<br>&gt;&gt; explicitly did *not* want to thread throwing-ness through generics in<br>&gt;&gt; this way.  This is roughly the same mechanism as would be required to<br>&gt;&gt; accomplish other things I&#39;d like to see, like the<br>&gt;&gt; sorting-throwing-Comparables thing I mentioned above, but that were<br>&gt;&gt; designed out of the model.<br>&gt;&gt; <br>&gt;&gt; FWIW, it would need to be generalized further, in case there were two<br>&gt;&gt; operations that throw different Error types.  Also, I know some will<br>&gt;&gt; disagree, but IMO you really don&#39;t want to get into a situation where<br>&gt;&gt; people are annotating most throwing functions with the exact Error types<br>&gt;&gt; that can be thrown.<br>&gt;&gt; <br>&gt;&gt; You need a way to express the type<br>&gt;&gt; <br>&gt;&gt;    if (E0, E1, ... EN).contains(Bottom) then Bottom else ErrorProtocol<br>&gt;&gt; <br>&gt;&gt; where Ei is one of the thrown error types, and for protocol methods that<br>&gt;&gt; are not marked with an explicit throws annotation, that type should be<br>&gt;&gt; synthesized automatically from the error types that can propagate from<br>&gt;&gt; any operations in protocol dependencies... but ah, as I say, IIUC this<br>&gt;&gt; sort of thing was designed out of the model.  <br>&gt;&gt; <br>&gt;&gt; My point isn&#39;t that what you&#39;re trying to do is wrong.  My point is that<br>&gt;&gt; it seems inconsistent with the Swift approach to error-handling, and<br>&gt;&gt; that if you want to do these things, you may need to convince someone to<br>&gt;&gt; change that approach.<br>&gt;&gt; <br>&gt;&gt;&gt; With a fair bit of work, it might even be possible to allow it to throw *all* of the errors it encountered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// This is structured slightly strangely to ensure that, if Error is Never, then MultipleErrors&lt;Never&gt; <br>&gt;&gt;&gt; 	// is an empty enum (since all cases require a Never associated value), and thus (hopefully!) <br>&gt;&gt;&gt; 	// is itself a synonym for Never.<br>&gt;&gt;&gt; 	enum MultipleErrors&lt;Error: ErrorProtocol&gt;: ErrorProtocol {<br>&gt;&gt;&gt; 		case one (Error)<br>&gt;&gt;&gt; 		indirect case many (Error, ErrorList&lt;Error&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt; 			switch self {<br>&gt;&gt;&gt; 			case let .one(oldError):<br>&gt;&gt;&gt; 				return .many(oldError, .one(newError))<br>&gt;&gt;&gt; 			case let .many(firstError, restErrors):<br>&gt;&gt;&gt; 				return .many(firstError, restErrors.appending(newError))<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}		<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	extension&lt;Error: ErrorProtocol&gt; Optional where Wrapped == MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt;? {<br>&gt;&gt;&gt; 			switch self {<br>&gt;&gt;&gt; 			case .none:<br>&gt;&gt;&gt; 				return .some(.one(newError))<br>&gt;&gt;&gt; 			case .some(let errors):<br>&gt;&gt;&gt; 				return .some(errors.appending(newError))<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt; 		var errors: MultipleErrors&lt;Error&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt; 				errors = errors.appending(error)<br>&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		if errors = errors { throw errors }<br>&gt;&gt;&gt; 	 }<br>&gt;&gt; <br>&gt;&gt; IMO that would be a collosal waste of resources.  The only interesting<br>&gt;&gt; error is the first one.  This is notionally a sort that failed partway<br>&gt;&gt; through, and that we had no mechanism for interrupting.  The fact that<br>&gt;&gt; you have to continue sorting after that error is just an artifact of<br>&gt;&gt; language limitations.  Either we should reaffirm our current (implicit)<br>&gt;&gt; declaration that these kinds of use-cases are off the table for Swift<br>&gt;&gt; error handling, or the philosophy of Swift error-handling should change<br>&gt;&gt; to allow us to support stopping at the right time.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 12:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt;&gt;&gt; ballpark.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt;&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt;&gt;&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt;&gt;&gt; generic function (or protocol extension method) on Collection would also<br>&gt;&gt;&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt;&gt;&gt; it was decided that these cases were out-of-scope.<br>&gt;&gt; <br>&gt;&gt; Right.  It would be simple to change core library protocols to permit operations<br>&gt;&gt; to throw, but then every use of an algorithm over those protocols would throw.<br>&gt;&gt; This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>&gt;&gt; more complex to apply to protocol conformances because you need to be more<br>&gt;&gt; specific about which requirements, exactly, will cause you to rethrow.  <br>&gt; <br>&gt; Can you show an example?  It seems simple to me: if you&#39;re going to<br>&gt; possibly rethrow you can use any requirements that might throw, and if<br>&gt; you&#39;re not going to rethrow then you can&#39;t.<br></p><p>Right, but we don&#39;t have a way to talk about whether individual requirements or<br>even conformances might throw.  It&#39;s not obvious that something as coarse-grained<br>as &quot;a conformance is non-throwing if every throwing requirement of the protocol<br>and everything it inherits is satisfied by a non-throwing function&quot; is actually good<br>enough to express the constraints we want to express, especially if we ever want<br>to allow programmers to add additional (defaulted) requirements in protocol<br>extensions.<br></p><p>&gt;&gt; It also causes problems for generic types, which might have arbitrary<br>&gt;&gt; methods that rethrow based on the conformances of their generic<br>&gt;&gt; arguments; and perhaps the result of that decision would also need to<br>&gt;&gt; be expressible in a rethrow constraint on some other operation, etc.<br>&gt;&gt; We haven&#39;t been able to find a language design here that isn&#39;t<br>&gt;&gt; extremely bureaucratic.<br>&gt; <br>&gt; We also haven&#39;t really tried, IMO.  My understanding was that Swift<br>&gt; error handling was explicitly *not supposed* to handle these cases, as<br>&gt; though it was a design goal.  When you start with that as a basis you&#39;re<br>&gt; not going to find a good answer because you&#39;re not supposed to be<br>&gt; solving the problem in the first place.<br></p><p>I really try not write things off a priori like that.  I remember spending several weeks<br>investigating what I thought would be necessary to make conditional throws<br>propagation work in the generics model and was not very satisfied with the results.<br>IIRC, my concerns were partly around the complexity of specification, given that I<br>was very worried that a coarse-grained model was not going to prove expressive<br>enough, and partly because I didn&#39;t feel that the model applied very cleanly to<br>generic types.<br></p><p>At that point, I made the call that, as far as I was concerned, the use cases for<br>throwing conformances weren&#39;t worth complicating the initial proposal over.<br>I don&#39;t consider it a closed question; I just don&#39;t think it was feasible to solve it<br>in the first release, and it hasn&#39;t been a priority to revisit.<br></p><p>Other people may have been more summary.  I can&#39;t speak for them.<br></p><p>&gt;&gt; In short, there are three options that we have discovered so far:<br>&gt;&gt; 1) Introduce massive complexity and bureaucracy into the generics system<br>&gt;&gt;  to propagate rethrows-like dependencies on throwing conformances.<br>&gt;&gt; 2) Abandon typed propagation.<br>&gt;&gt; 3) Force protocols to make a choice, with the understanding that this will<br>&gt;&gt;  generally mean forbidding throwing conformances.<br>&gt;&gt; <br>&gt;&gt; We do not consider (1) or (2) acceptable, so we chose (3).  If someone<br>&gt;&gt; finds a way to express typed propagation in generics at minimal<br>&gt;&gt; expressive cost, we&#39;d be happy to reconsider this decision.<br>&gt; <br>&gt; AFAICT, this is not that hard to do.  IIUC, my original proposal for the<br>&gt; “rethrows” keyword would have solved these problems.  My understanding<br>&gt; was that it got no traction because solving them was considered an<br>&gt; anti-goal.<br></p><p>Like I said, I think it really depends on how coarse-grained the tracking is allowed to be,<br>and what impact that has on the rest of the language and its evolution.<br></p><p>John.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; I suppose you&#39;re trying to acknowledge that distinction when you say<br>&gt;&gt;&gt;&gt; these cases are &quot;in the same ballpark&quot;, but I don&#39;t think that&#39;s<br>&gt;&gt;&gt;&gt; really a sustainable objection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There *are* sensible alternatives, like the early-terminating block<br>&gt;&gt;&gt;&gt; pattern, to throwing sequences and perhaps even throwing collections:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	try database.withQuery(sql) { rows in<br>&gt;&gt;&gt;&gt; 		for row in rows {<br>&gt;&gt;&gt;&gt; 			// If fetching a row fails, this loop terminates early and `withQuery` throws<br>&gt;&gt;&gt;&gt; 			…<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That strategy doesn&#39;t begin to cover the use cases for collections.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, how is it supposed to work? You need a way to report a failure to<br>&gt;&gt;&gt; fetch the row—a way that doesn&#39;t involve throwing.  Who terminates the<br>&gt;&gt;&gt; loop, and how?  How does withQuery detect that the loop exited early?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But throwing operations on stuff-inside-a-collection? That&#39;s just part<br>&gt;&gt;&gt;&gt; of the language, and making errors during sorting extraordinarily<br>&gt;&gt;&gt;&gt; difficult to handle won&#39;t stop the errors from being possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s basically no distinction.  If it&#39;s reasonable to have sort with<br>&gt;&gt;&gt; a throwing predicate, it&#39;s also reasonable to have a Comparable type<br>&gt;&gt;&gt; whose &lt; operator throws, and it&#39;s reasonable to use the sort overload<br>&gt;&gt;&gt; that takes no explicit predicate, and now you have a Collection protocol<br>&gt;&gt;&gt; method that throws directly, rather than rethrowing.  IIUC from the<br>&gt;&gt;&gt; people who designed Swift error handling, if you find yourself doing<br>&gt;&gt;&gt; that, you&#39;ve done something wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I actually think there *is* a sensible way to define the behavior of a<br>&gt;&gt;&gt;&gt; throwing `sort(_:)`: you treat the comparison as though it returned<br>&gt;&gt;&gt;&gt; `false` and continue sorting. <br>&gt;&gt;&gt;&gt; If there&#39;s any sort of stability to the errors being thrown by<br>&gt;&gt;&gt;&gt; `isOrderedBefore`, this will end up behaving like a sort with<br>&gt;&gt;&gt;&gt; unordered elements, much like an array of floating-point types with<br>&gt;&gt;&gt;&gt; some NaNs in it. You not be able to rethrow all of the errors<br>&gt;&gt;&gt;&gt; encountered during the sort—you&#39;d have to pick the first or last—but a<br>&gt;&gt;&gt;&gt; representative error would probably cover the use cases here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As Dmitri pointed out, that predicate doesn&#39;t satisfy the requirements<br>&gt;&gt;&gt; for sorting.  It&#39;s quite possible that a predicate that doesn&#39;t satisfy<br>&gt;&gt;&gt; an algorithm&#39;s requirements causes the algorithm to do invalid indexing<br>&gt;&gt;&gt; or some other evil nonsense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could implement this with today&#39;s Swift in terms of our existing `sort(_:)`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	mutating func sort(isOrderedBefore: (Element, Element) throws -&gt; Bool) throws {<br>&gt;&gt;&gt;&gt; 		var lastError: Error?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		sort {<br>&gt;&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt;&gt; 				return try isOrderedBefore($0, $1)<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt;&gt; 				lastError = error<br>&gt;&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from the problems mentioned above, this is extremely inefficient<br>&gt;&gt;&gt; if the collection is large and backed a resource that fails slowly, such<br>&gt;&gt;&gt; as a network connection with retry and timeout.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think you could currently do one version with `rethrows`,<br>&gt;&gt;&gt;&gt; because any way you do this, you&#39;ll need to save an error in a<br>&gt;&gt;&gt;&gt; variable and `throw` it later, which I don&#39;t believe `rethrows` will<br>&gt;&gt;&gt;&gt; permit. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.  That&#39;s a problem with the error-handling model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, I saw a suggestion in the bottom type thread that, given both<br>&gt;&gt;&gt;&gt; a `throws` keyword that can take an error type and a bottom type to<br>&gt;&gt;&gt;&gt; represent the error type of a non-throwing function, `rethrows` could<br>&gt;&gt;&gt;&gt; essentially be syntactic sugar for a function with a generic error<br>&gt;&gt;&gt;&gt; type. This would give us additional flexibility in cases like this<br>&gt;&gt;&gt;&gt; where `rethrows` doesn&#39;t quite do what we need.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the necessary features in place, we could implement a `rethrows`-ish `sort(_:)` like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	// This declaration has rethrows-like behavior: if `isOrderedBefore`&#39;s error type is `Never`, then <br>&gt;&gt;&gt;&gt; 	// `sort(_:)`&#39;s error type is also `Never`, and there&#39;s no reason to require a `try` on the call to this method.<br>&gt;&gt;&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws Error {<br>&gt;&gt;&gt;&gt; 		var lastError: Error?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt;&gt; 				lastError = error<br>&gt;&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		if lastError = lastError { throw lastError }<br>&gt;&gt;&gt;&gt; 	 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s cute, but IIUC the designers of the error handling model<br>&gt;&gt;&gt; explicitly did *not* want to thread throwing-ness through generics in<br>&gt;&gt;&gt; this way.  This is roughly the same mechanism as would be required to<br>&gt;&gt;&gt; accomplish other things I&#39;d like to see, like the<br>&gt;&gt;&gt; sorting-throwing-Comparables thing I mentioned above, but that were<br>&gt;&gt;&gt; designed out of the model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, it would need to be generalized further, in case there were two<br>&gt;&gt;&gt; operations that throw different Error types.  Also, I know some will<br>&gt;&gt;&gt; disagree, but IMO you really don&#39;t want to get into a situation where<br>&gt;&gt;&gt; people are annotating most throwing functions with the exact Error types<br>&gt;&gt;&gt; that can be thrown.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You need a way to express the type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if (E0, E1, ... EN).contains(Bottom) then Bottom else ErrorProtocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where Ei is one of the thrown error types, and for protocol methods that<br>&gt;&gt;&gt; are not marked with an explicit throws annotation, that type should be<br>&gt;&gt;&gt; synthesized automatically from the error types that can propagate from<br>&gt;&gt;&gt; any operations in protocol dependencies... but ah, as I say, IIUC this<br>&gt;&gt;&gt; sort of thing was designed out of the model.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point isn&#39;t that what you&#39;re trying to do is wrong.  My point is that<br>&gt;&gt;&gt; it seems inconsistent with the Swift approach to error-handling, and<br>&gt;&gt;&gt; that if you want to do these things, you may need to convince someone to<br>&gt;&gt;&gt; change that approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With a fair bit of work, it might even be possible to allow it to throw *all* of the errors it encountered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	// This is structured slightly strangely to ensure that, if Error is Never, then MultipleErrors&lt;Never&gt; <br>&gt;&gt;&gt;&gt; 	// is an empty enum (since all cases require a Never associated value), and thus (hopefully!) <br>&gt;&gt;&gt;&gt; 	// is itself a synonym for Never.<br>&gt;&gt;&gt;&gt; 	enum MultipleErrors&lt;Error: ErrorProtocol&gt;: ErrorProtocol {<br>&gt;&gt;&gt;&gt; 		case one (Error)<br>&gt;&gt;&gt;&gt; 		indirect case many (Error, ErrorList&lt;Error&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt;&gt; 			switch self {<br>&gt;&gt;&gt;&gt; 			case let .one(oldError):<br>&gt;&gt;&gt;&gt; 				return .many(oldError, .one(newError))<br>&gt;&gt;&gt;&gt; 			case let .many(firstError, restErrors):<br>&gt;&gt;&gt;&gt; 				return .many(firstError, restErrors.appending(newError))<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 		}		<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	extension&lt;Error: ErrorProtocol&gt; Optional where Wrapped == MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt;&gt; 		func appending(_ newError: Error) -&gt; MultipleErrors&lt;Error&gt;? {<br>&gt;&gt;&gt;&gt; 			switch self {<br>&gt;&gt;&gt;&gt; 			case .none:<br>&gt;&gt;&gt;&gt; 				return .some(.one(newError))<br>&gt;&gt;&gt;&gt; 			case .some(let errors):<br>&gt;&gt;&gt;&gt; 				return .some(errors.appending(newError))<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	mutating func sort&lt;Error: ErrorProtocol&gt;(isOrderedBefore: (Element, Element) throws Error -&gt; Bool) throws MultipleErrors&lt;Error&gt; {<br>&gt;&gt;&gt;&gt; 		var errors: MultipleErrors&lt;Error&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		func isOrderedBeforeWithUnorderedErrors(a: Element, b: Element) -&gt; Bool {<br>&gt;&gt;&gt;&gt; 			do {<br>&gt;&gt;&gt;&gt; 				return try isOrderedBefore(a, b)<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 			catch {<br>&gt;&gt;&gt;&gt; 				errors = errors.appending(error)<br>&gt;&gt;&gt;&gt; 				return false<br>&gt;&gt;&gt;&gt; 			}<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		// Do the actual sorting here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		if errors = errors { throw errors }<br>&gt;&gt;&gt;&gt; 	 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO that would be a collosal waste of resources.  The only interesting<br>&gt;&gt;&gt; error is the first one.  This is notionally a sort that failed partway<br>&gt;&gt;&gt; through, and that we had no mechanism for interrupting.  The fact that<br>&gt;&gt;&gt; you have to continue sorting after that error is just an artifact of<br>&gt;&gt;&gt; language limitations.  Either we should reaffirm our current (implicit)<br>&gt;&gt;&gt; declaration that these kinds of use-cases are off the table for Swift<br>&gt;&gt;&gt; error handling, or the philosophy of Swift error-handling should change<br>&gt;&gt;&gt; to allow us to support stopping at the right time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 20, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 9, 2016, at 12:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt;&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt;&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt;&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt;&gt;&gt;&gt; ballpark.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt;&gt;&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt;&gt;&gt;&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt;&gt;&gt;&gt; generic function (or protocol extension method) on Collection would also<br>&gt;&gt;&gt;&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt;&gt;&gt;&gt; it was decided that these cases were out-of-scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.  It would be simple to change core library protocols to permit operations<br>&gt;&gt;&gt; to throw, but then every use of an algorithm over those protocols would throw.<br>&gt;&gt;&gt; This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>&gt;&gt;&gt; more complex to apply to protocol conformances because you need to be more<br>&gt;&gt;&gt; specific about which requirements, exactly, will cause you to rethrow.  <br>&gt;&gt; <br>&gt;&gt; Can you show an example?  It seems simple to me: if you&#39;re going to<br>&gt;&gt; possibly rethrow you can use any requirements that might throw, and if<br>&gt;&gt; you&#39;re not going to rethrow then you can&#39;t.<br>&gt;<br>&gt; Right, but we don&#39;t have a way to talk about whether individual<br>&gt; requirements or even conformances might throw.  It&#39;s not obvious that<br>&gt; something as coarse-grained as &quot;a conformance is non-throwing if every<br>&gt; throwing requirement of the protocol and everything it inherits is<br>&gt; satisfied by a non-throwing function&quot; is actually good enough to<br>&gt; express the constraints we want to express, <br></p><p>In terms of expressivity, it *seems* to me that it would work out.  What<br>use-case are you concerned about?<br></p><p>&gt; especially if we ever want to allow programmers to add additional<br>&gt; (defaulted) requirements in protocol extensions.<br></p><p>Isn&#39;t that easily handled by limiting such Post-hoc defaulted<br>requirements to be nonthrowing or rethrows?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 9:57 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 12:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt;&gt;&gt;&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt;&gt;&gt;&gt;&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt;&gt;&gt;&gt;&gt; generic function (or protocol extension method) on Collection would also<br>&gt;&gt;&gt;&gt;&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt;&gt;&gt;&gt;&gt; it was decided that these cases were out-of-scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.  It would be simple to change core library protocols to permit operations<br>&gt;&gt;&gt;&gt; to throw, but then every use of an algorithm over those protocols would throw.<br>&gt;&gt;&gt;&gt; This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>&gt;&gt;&gt;&gt; more complex to apply to protocol conformances because you need to be more<br>&gt;&gt;&gt;&gt; specific about which requirements, exactly, will cause you to rethrow.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you show an example?  It seems simple to me: if you&#39;re going to<br>&gt;&gt;&gt; possibly rethrow you can use any requirements that might throw, and if<br>&gt;&gt;&gt; you&#39;re not going to rethrow then you can&#39;t.<br>&gt;&gt; <br>&gt;&gt; Right, but we don&#39;t have a way to talk about whether individual<br>&gt;&gt; requirements or even conformances might throw.  It&#39;s not obvious that<br>&gt;&gt; something as coarse-grained as &quot;a conformance is non-throwing if every<br>&gt;&gt; throwing requirement of the protocol and everything it inherits is<br>&gt;&gt; satisfied by a non-throwing function&quot; is actually good enough to<br>&gt;&gt; express the constraints we want to express, <br>&gt; <br>&gt; In terms of expressivity, it *seems* to me that it would work out.  What<br>&gt; use-case are you concerned about?<br></p><p>In general, places where we have a &quot;large&quot; protocol and only one cluster of<br>functionality can throw for a particular conformance.  For example, maybe only<br>writes to a collection can throw.<br></p><p>&gt;&gt; especially if we ever want to allow programmers to add additional<br>&gt;&gt; (defaulted) requirements in protocol extensions.<br>&gt; <br>&gt; Isn&#39;t that easily handled by limiting such Post-hoc defaulted<br>&gt; requirements to be nonthrowing or rethrows?<br></p><p>I think the rule would be that they would have to match the throwing-ness of the<br>primary conformance.  I&#39;m just saying that it would become a restriction on the<br>expressivity of additional requirements.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 20, 2016 at 12:00:00pm</p></header><div class="content"><p>on Mon Jun 20 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 20, 2016, at 9:57 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 12:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; on Thu Jun 09 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com &lt;http://brent-at-architechies.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure that these ideas are consistent with the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; error-handling philosophy, which IIUC is very consciously designed *not*<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to support things like file- and database-backed Collections.  My<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; understanding is that if you have something like that, you&#39;re not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; supposed to throw errors on failure, but instead find some alternative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; means of error handling.  These cases seem very much in the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not talking about the Collection itself being backed by a file,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but rather the instances inside it being backed by a file. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Those amount to the same thing.  If instances can be backed by a file,<br>&gt;&gt;&gt;&gt;&gt;&gt; subscripting needs to be able to throw, and therefore practically every<br>&gt;&gt;&gt;&gt;&gt;&gt; generic function (or protocol extension method) on Collection would also<br>&gt;&gt;&gt;&gt;&gt;&gt; need to be marked as throwing.  When Swift error handling was designed,<br>&gt;&gt;&gt;&gt;&gt;&gt; it was decided that these cases were out-of-scope.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.  It would be simple to change core library protocols to permit operations<br>&gt;&gt;&gt;&gt;&gt; to throw, but then every use of an algorithm over those protocols would throw.<br>&gt;&gt;&gt;&gt;&gt; This is the sort of problem that we address with &#39;rethrows&#39;, but that&#39;s quite a bit<br>&gt;&gt;&gt;&gt;&gt; more complex to apply to protocol conformances because you need to be more<br>&gt;&gt;&gt;&gt;&gt; specific about which requirements, exactly, will cause you to rethrow.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you show an example?  It seems simple to me: if you&#39;re going to<br>&gt;&gt;&gt;&gt; possibly rethrow you can use any requirements that might throw, and if<br>&gt;&gt;&gt;&gt; you&#39;re not going to rethrow then you can&#39;t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but we don&#39;t have a way to talk about whether individual<br>&gt;&gt;&gt; requirements or even conformances might throw.  It&#39;s not obvious that<br>&gt;&gt;&gt; something as coarse-grained as &quot;a conformance is non-throwing if every<br>&gt;&gt;&gt; throwing requirement of the protocol and everything it inherits is<br>&gt;&gt;&gt; satisfied by a non-throwing function&quot; is actually good enough to<br>&gt;&gt;&gt; express the constraints we want to express, <br>&gt;&gt; <br>&gt;&gt; In terms of expressivity, it *seems* to me that it would work out.  What<br>&gt;&gt; use-case are you concerned about?<br>&gt;<br>&gt; In general, places where we have a &quot;large&quot; protocol and only one cluster of<br>&gt; functionality can throw for a particular conformance.  For example, maybe only<br>&gt; writes to a collection can throw.<br></p><p>I think when there&#39;s a significant difference in capability like that,<br>you tend to end up with a protocol refinement, such as<br>Collection/MutableCollection.  That ought to be enough to handle the<br>issue.<br></p><p>&gt;<br>&gt;<br>&gt;&gt;&gt; especially if we ever want to allow programmers to add additional<br>&gt;&gt;&gt; (defaulted) requirements in protocol extensions.<br>&gt;&gt; <br>&gt;&gt; Isn&#39;t that easily handled by limiting such Post-hoc defaulted<br>&gt;&gt; requirements to be nonthrowing or rethrows?<br>&gt;<br>&gt; I think the rule would be that they would have to match the throwing-ness of the<br>&gt; primary conformance.  I&#39;m just saying that it would become a restriction on the<br>&gt; expressivity of additional requirements.<br>&gt;<br>&gt; John.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
