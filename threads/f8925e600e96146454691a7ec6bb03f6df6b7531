<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Bool with Foundation framework, can convert to AnyObject</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>May 25, 2016 at 05:00:00pm</p></header><div class="content"><p>We were told that Bool can&#39;t downcast to AnyObject in Swift. However, with<br>Foundation framework, we can.<br></p><p>do {<br></p><p>    let a:Bool = true<br></p><p>    let object:AnyObject = a as AnyObject<br></p><p>    object.dynamicType<br></p><p>    // __NSCFBoolean.Type<br></p><p>    let b:Bool = object as! Bool<br></p><p>    b // true<br></p><p>}<br></p><p><br>This feature works in some code automatically (like in a Dictionary), but<br>in some other codes(like in a function), you have to downcast it yourself.<br></p><p><br>do {<br></p><p>    var dictionary = Dictionary&lt;String, AnyObject&gt;()<br></p><p><br></p><p>    func update&lt;T:AnyObject&gt;(value:T, key:String) {<br></p><p>        dictionary.updateValue(value, forKey: key)<br></p><p>    }<br></p><p><br></p><p>    let aBool = true<br></p><p>    let key = &quot;testBool&quot;<br></p><p><br></p><p>    dictionary.updateValue(aBool, forKey: key)<br></p><p>    // works<br></p><p><br></p><p>    update(aBool, key: key)<br></p><p>    // doesn&#39;t work. cannot invoke &#39;update&#39; with an argument list of type<br>&#39;(Bool, key: String)&#39;<br></p><p><br></p><p>    update(aBool as AnyObject, key:key)<br></p><p>    // works<br></p><p>}<br></p><p><br>My question: Is this normal? Should it all be automatic or not?<br></p><p><br>Zhaoxin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160525/f8927531/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Bool with Foundation framework, can convert to AnyObject</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 02:11, zh ao via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; We were told that Bool can&#39;t downcast to AnyObject in Swift. However, with Foundation framework, we can.<br>&gt; <br>&gt; do {<br>&gt;     let a:Bool = true<br>&gt;     let object:AnyObject = a as AnyObject<br>&gt;     object.dynamicType<br>&gt;     // __NSCFBoolean.Type<br>&gt;     let b:Bool = object as! Bool<br>&gt;     b // true<br>&gt; }<br>&gt; <br>&gt; This feature works in some code automatically (like in a Dictionary), but in some other codes(like in a function), you have to downcast it yourself.<br>&gt; <br>&gt; do {<br>&gt;     var dictionary = Dictionary&lt;String, AnyObject&gt;()<br>&gt;     <br>&gt;     func update&lt;T:AnyObject&gt;(value:T, key:String) {<br>&gt;         dictionary.updateValue(value, forKey: key)<br>&gt;     }<br>&gt;     <br>&gt;     let aBool = true<br>&gt;     let key = &quot;testBool&quot;<br>&gt;     <br>&gt;     dictionary.updateValue(aBool, forKey: key)<br>&gt;     // works<br>&gt;     <br>&gt;     update(aBool, key: key)<br>&gt;     // doesn&#39;t work. cannot invoke &#39;update&#39; with an argument list of type &#39;(Bool, key: String)&#39;<br>&gt;     <br>&gt;     update(aBool as AnyObject, key:key)<br>&gt;     // works<br>&gt; }<br>&gt; <br>&gt; My question: Is this normal? Should it all be automatic or not?<br></p><p>This is expected behavior: when you explicitly coerce (using ‘as’) or cast (using ‘as’ or ‘as!’), Bool can be converted to an NSNumber and from there up to AnyObject. Since NSNumber is part of Foundation, you need to have Foundation imported to do this.<br></p><p>We’re still deciding whether the conversion from Bool to NSNumber (and similar &quot;bridging conversions&quot;) should be implicit or explicit. The conversion from NSNumber to Bool has been explicit for a while now.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160525/69c9a4da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Bool with Foundation framework, can convert to AnyObject</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>May 26, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks, Jordan.<br></p><p>Zhaoxin<br></p><p>On Thu, May 26, 2016 at 12:33 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 25, 2016, at 02:11, zh ao via swift-users &lt;swift-users at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; We were told that Bool can&#39;t downcast to AnyObject in Swift. However, with<br>&gt; Foundation framework, we can.<br>&gt;<br>&gt; do {<br>&gt;     let a:Bool = true<br>&gt;     let object:AnyObject = a as AnyObject<br>&gt;     object.dynamicType<br>&gt;     // __NSCFBoolean.Type<br>&gt;     let b:Bool = object as! Bool<br>&gt;     b // true<br>&gt; }<br>&gt;<br>&gt; This feature works in some code automatically (like in a Dictionary), but<br>&gt; in some other codes(like in a function), you have to downcast it yourself.<br>&gt;<br>&gt; do {<br>&gt;     var dictionary = Dictionary&lt;String, AnyObject&gt;()<br>&gt;<br>&gt;<br>&gt;     func update&lt;T:AnyObject&gt;(value:T, key:String) {<br>&gt;         dictionary.updateValue(value, forKey: key)<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     let aBool = true<br>&gt;     let key = &quot;testBool&quot;<br>&gt;<br>&gt;<br>&gt;     dictionary.updateValue(aBool, forKey: key)<br>&gt;     // works<br>&gt;<br>&gt;<br>&gt;     update(aBool, key: key)<br>&gt;     // doesn&#39;t work. cannot invoke &#39;update&#39; with an argument list of type<br>&gt; &#39;(Bool, key: String)&#39;<br>&gt;<br>&gt;<br>&gt;     update(aBool as AnyObject, key:key)<br>&gt;     // works<br>&gt;<br>&gt; }<br>&gt;<br>&gt; My question: Is this normal? Should it all be automatic or not?<br>&gt;<br>&gt;<br>&gt; This is expected behavior: when you explicitly coerce (using ‘as’) or cast<br>&gt; (using ‘as’ or ‘as!’), Bool can be converted to an NSNumber and from there<br>&gt; up to AnyObject. Since NSNumber is part of Foundation, you need to have<br>&gt; Foundation imported to do this.<br>&gt;<br>&gt; We’re still deciding whether the conversion from Bool to NSNumber (and<br>&gt; similar &quot;bridging conversions&quot;) should be implicit or explicit. The<br>&gt; conversion from NSNumber to Bool has been explicit for a while now.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/697c857c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
