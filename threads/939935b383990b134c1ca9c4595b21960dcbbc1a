<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Apr 6, 2016 at 1:16 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I think a lightbulb just went on for me:<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt; You&#39;re talking about expressing something in the vein of `(0..&lt;200).striding(by:<br>&gt;&gt;&gt; -2)`, which has I&#39;m sure many use cases, and which isn&#39;t straightforward to<br>&gt;&gt;&gt; express with the current free function--I hadn&#39;t considered that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Meanwhile, I was trying to talk about something like `stride(from: 200, to: 0,<br>&gt;&gt;&gt; by: -2)`, which is easily expressed today but isn&#39;t straightforward at all to<br>&gt;&gt;&gt; preserve with only ranges. Clearly, given that this is what&#39;s on offer<br>&gt;&gt;&gt; currently, someone who designed the language thinks (or thought) it&#39;s of some<br>&gt;&gt;&gt; use.<br>&gt;&gt;<br>&gt;&gt; That someone was me, and I explained that it wasn&#39;t an extremely<br>&gt;&gt; deeply-considered decision.<br>&gt;<br>&gt; Fair enough. Though your decision may not have been deeply considered,<br>&gt; I wouldn&#39;t say it was an ill-considered one given that there wasn&#39;t<br>&gt; (to my knowledge) any great clamor against it subsequently.<br>&gt;<br>&gt;&gt;&gt; In the absence of information as to which is more in demand, couldn&#39;t<br>&gt;&gt;&gt; we have both?<br>&gt;&gt;<br>&gt;&gt; That&#39;s not how we make decisions about what should be in the language or<br>&gt;&gt; standard library.  We need to make choices based on (at least educated<br>&gt;&gt; guesses about) what people need, or we&#39;ll end up with a sprawling mess.<br>&gt;<br>&gt; Well, to elicit the kind of feedback that would help determine user<br>&gt; needs, I would suggest that (when the eventually reconsidered syntax<br>&gt; is proposed) this change should be highlighted explicitly as a feature<br>&gt; removal. IMO, it wouldn&#39;t be otherwise immediately apparent from a<br>&gt; quick glance that revising `stride(from: 0, to: 10, by: 1)` to<br>&gt; `(0..&lt;10).striding(by: 1)` necessarily entails deletion of backwards<br>&gt; strides from upper bound to-and-not-through lower bound.<br>&gt;<br>&gt;&gt;&gt; If it must be a method on a range,<br>&gt;&gt;<br>&gt;&gt; It&#39;s not that it must be, but having such a method tends to reduce API<br>&gt;&gt; surface area.  We prefer methods to free functions.<br>&gt;&gt;<br>&gt;&gt;&gt; then I would advocate for having what seems to be an utterly<br>&gt;&gt;&gt; reasonable set of options for striding backwards:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; (0...200).striding(by: -2) // [a, b]<br>&gt;&gt;&gt; (0..&lt;200).striding(by: -2) // [a, b)<br>&gt;&gt;&gt; (0&lt;..200).striding(by: -2) // (a, b]<br>&gt;&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; And I&#39;m trying to say that without a more compelling reason to introduce<br>&gt;&gt; `&lt;..`, I don&#39;t want to do it.  I&#39;d like to know that `&lt;..` is useful<br>&gt;&gt; outside the domain of striding, for example.  Use-cases, anyone?<br>&gt;<br>&gt; Well, my use case (an actual one) is supremely mundane. I&#39;m doing some<br>&gt; scientific computing and I need to deal with numeric intervals. Some<br>&gt; of them are closed, some of them are open at one end, and some at the<br>&gt; other. <br></p><p>You if you need to represent `&lt;..` intervals in scientific computing,<br>that&#39;s a pretty compelling argument for supporting them.<br></p><p>&gt; I&#39;d like to be able to represent any of those as<br>&gt; Intervals-which-are-now-Ranges. It makes sense to do so because the<br>&gt; things I want to do with them, such as clamping and testing if some<br>&gt; value is contained, are exactly what Intervals-now-Ranges provide.<br>&gt; Looking around, it seems many other languages provide only what Swift<br>&gt; currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>&gt; (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt; `&lt;.&lt;`).<br></p><p>Do we need fully-open ranges too?<br></p><p>&gt;&gt; Reasons we might not need it: the cases where it&#39;s important are much<br>&gt;&gt; more likely to be notionally continuous domains (e.g. floats), since you<br>&gt;&gt; can always write<br>&gt;&gt;<br>&gt;&gt;     ((0+1)...200).striding(by: -2)<br>&gt;&gt;<br>&gt;&gt; and if you need the floating version there&#39;s always<br>&gt;&gt;<br>&gt;&gt;    (0.0...200.0).striding(by: -2).lazy.filter { $0 != 0.0 }<br>&gt;&gt;<br>&gt;&gt; which probably optimizes down to the same code.<br>&gt;&gt;<br>&gt;&gt; One question that I *do* think we should answer, is whether the elements<br>&gt;&gt; of<br>&gt;&gt;<br>&gt;&gt;     (0..&lt;199).striding(by: -2)<br>&gt;&gt;<br>&gt;&gt; are even or odd.<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, Apr 6, 2016 at 12:10 PM Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt;&gt;&gt;     &gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt; stride(over: 0..&lt;200, by: -2)<br>&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;     &gt; This seems like a particularly good solution. The way I understand it<br>&gt;&gt;&gt;     &gt; at least, it would allow ranges to always be ordered, with the only<br>&gt;&gt;&gt;     &gt; difference being whether it went start-to-end or end-to-start,<br>&gt;&gt;&gt;     &gt; determined by the stride&#39;s sign.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This is no different in principle from<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     (0..&lt;200).striding(by: -2)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt;&gt;&gt;     The point I was making was that we don&#39;t have enough information to<br>&gt;&gt;&gt;     design more than<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     (0..&lt;200).striding(by: -2)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt; It would also avoid the need for additional range operators. The main<br>&gt;&gt;&gt;     &gt; reason you would need `&gt;..` is so you could say<br>&gt;&gt;&gt;     &gt; `array.endIndex&gt;..array.startIndex`, but by using the sign to decide<br>&gt;&gt;&gt;     &gt; which direction to stride over the range, you instead stride over<br>&gt;&gt;&gt;     &gt; `array.startIndex..&lt;array.endIndex`, which is exactly what we already<br>&gt;&gt;&gt;     &gt; have.<br>&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;     &gt; Unfortunately, moving away from `stride(from:to/through:by:)` would<br>&gt;&gt;&gt;     &gt; kind of mess up an idea I&#39;ve been developing for providing an<br>&gt;&gt;&gt;     &gt; &quot;induction sequence&quot; to replace the more complicated C-style for use<br>&gt;&gt;&gt;     &gt; cases, but I suppose that&#39;s the way it goes...<br>&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;     &gt; (Link to that:<br>&gt;&gt;&gt;     https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     --<br>&gt;&gt;&gt;     Dave<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:28 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt; that&#39;s a pretty compelling argument for supporting them.<br></p><p>From a purely numerically aesthetic point of view, I&#39;d much prefer ranges to be <br>openable and closable at both ends. <br></p><p>My primary use-case has been teaching math using playgrounds but I&#39;m sure <br>there are lots of other real-world situations more specific to common numerical<br>method tasks.<br></p><p>-- E<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/09913881/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; From a purely numerically aesthetic point of view, I&#39;d much prefer ranges to be <br>&gt; openable and closable at both ends. <br>&gt; <br>&gt; My primary use-case has been teaching math using playgrounds but I&#39;m sure <br>&gt; there are lots of other real-world situations more specific to common numerical<br>&gt; method tasks.<br></p><p>By coincidence, a Perl hacker I know commented on Twitter yesterday that he thought 1-based arrays were the way to go in the 21st century. Somebody replying to that suggestion linked to a note by Dijkstra that&#39;s relevant to this conversation: &lt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&gt;<br></p><p>I&#39;d suggest everyone in this discussion should read it—it&#39;s only about 700 words—but to summarize:<br></p><p>	1. The semantic Swift refers to as `..&lt;` is the most natural range convention.<br>	2. Relatedly, zero-based indexing is the most natural indexing convention.<br></p><p>If we agree with Dijkstra&#39;s logic, then the only reason to support `&gt;..` is for ranges where start &gt; end—that is, when we&#39;re constructing a reversed range. But if we decide to support striding backwards by using a forward range and a negative stride, then that covers the reverse use case. Thus, we would need neither additional range operators, nor reversed ranges.<br></p><p>As for the `range.striding(by:)` vs `stride(over:by:)` question, my concerns there are, to be honest, mainly aesthetic. The need for parentheses around the range operator is more or less unavoidable, but I think they make the construct very ugly. However, I also think that the `stride(over:by:)` syntax (or, for that matter `stride(from:to:by:)`) look more constructor-y (they are only *not* constructors now because of the overloading), and I think it opens us up to parallel constructs like the `induce(from:while:by:)` function I&#39;ve been working on.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>Dijkstra is talking about intervals of natural numbers, i.e. indices.<br>Range is much more general than that, including floating point ranges, so Dijkstra&#39;s arguments do not apply here.<br></p><p>-Thorsten <br></p><p>Am 06.04.2016 um 23:41 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; From a purely numerically aesthetic point of view, I&#39;d much prefer ranges to be <br>&gt;&gt; openable and closable at both ends. <br>&gt;&gt; <br>&gt;&gt; My primary use-case has been teaching math using playgrounds but I&#39;m sure <br>&gt;&gt; there are lots of other real-world situations more specific to common numerical<br>&gt;&gt; method tasks.<br>&gt; <br>&gt; By coincidence, a Perl hacker I know commented on Twitter yesterday that he thought 1-based arrays were the way to go in the 21st century. Somebody replying to that suggestion linked to a note by Dijkstra that&#39;s relevant to this conversation: &lt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&gt;<br>&gt; <br>&gt; I&#39;d suggest everyone in this discussion should read it—it&#39;s only about 700 words—but to summarize:<br>&gt; <br>&gt;    1. The semantic Swift refers to as `..&lt;` is the most natural range convention.<br>&gt;    2. Relatedly, zero-based indexing is the most natural indexing convention.<br>&gt; <br>&gt; If we agree with Dijkstra&#39;s logic, then the only reason to support `&gt;..` is for ranges where start &gt; end—that is, when we&#39;re constructing a reversed range. But if we decide to support striding backwards by using a forward range and a negative stride, then that covers the reverse use case. Thus, we would need neither additional range operators, nor reversed ranges.<br>&gt; <br>&gt; As for the `range.striding(by:)` vs `stride(over:by:)` question, my concerns there are, to be honest, mainly aesthetic. The need for parentheses around the range operator is more or less unavoidable, but I think they make the construct very ugly. However, I also think that the `stride(over:by:)` syntax (or, for that matter `stride(from:to:by:)`) look more constructor-y (they are only *not* constructors now because of the overloading), and I think it opens us up to parallel constructs like the `induce(from:while:by:)` function I&#39;ve been working on.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt; that&#39;s a pretty compelling argument for supporting them.<br>&gt;<br>&gt;&gt; I&#39;d like to be able to represent any of those as<br>&gt;&gt; Intervals-which-are-now-Ranges. It makes sense to do so because the<br>&gt;&gt; things I want to do with them, such as clamping and testing if some<br>&gt;&gt; value is contained, are exactly what Intervals-now-Ranges provide.<br>&gt;&gt; Looking around, it seems many other languages provide only what Swift<br>&gt;&gt; currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>&gt;&gt; (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt; `&lt;.&lt;`).<br>&gt;<br>&gt; Do we need fully-open ranges too?<br></p><p>I haven&#39;t encountered a need for open ranges, but I would expect that<br>other applications in scientific computing could make use of them.<br>I rather like Pyry&#39;s suggestions below. These would represent an<br>expansive fleshing out of ranges. They really start pulling their<br>weight for floating point bounds; of course, I&#39;d wager that ... and<br>..&lt; would still be the most used by far.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;&gt; that&#39;s a pretty compelling argument for supporting them.<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;d like to be able to represent any of those as<br>&gt;&gt;&gt; Intervals-which-are-now-Ranges. It makes sense to do so because the<br>&gt;&gt;&gt; things I want to do with them, such as clamping and testing if some<br>&gt;&gt;&gt; value is contained, are exactly what Intervals-now-Ranges provide.<br>&gt;&gt;&gt; Looking around, it seems many other languages provide only what Swift<br>&gt;&gt;&gt; currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>&gt;&gt;&gt; (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt;&gt; `&lt;.&lt;`).<br>&gt;&gt;<br>&gt;&gt; Do we need fully-open ranges too?<br>&gt;<br>&gt; I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt; other applications in scientific computing could make use of them.<br>&gt; I rather like Pyry&#39;s suggestions below. <br></p><p>Below?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 3:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;&gt;&gt; that&#39;s a pretty compelling argument for supporting them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to be able to represent any of those as<br>&gt;&gt;&gt;&gt; Intervals-which-are-now-Ranges. It makes sense to do so because the<br>&gt;&gt;&gt;&gt; things I want to do with them, such as clamping and testing if some<br>&gt;&gt;&gt;&gt; value is contained, are exactly what Intervals-now-Ranges provide.<br>&gt;&gt;&gt;&gt; Looking around, it seems many other languages provide only what Swift<br>&gt;&gt;&gt;&gt; currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>&gt;&gt;&gt;&gt; (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt;&gt;&gt; `&lt;.&lt;`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we need fully-open ranges too?<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt;&gt; other applications in scientific computing could make use of them.<br>&gt;&gt; I rather like Pyry&#39;s suggestions below. <br>&gt; <br>&gt; Below?<br></p><p>Logically in time below.<br></p><p>I believe the following is a valid conversion of the Xiaodi Wu below into the Dave A domain.<br></p><p>&gt; On Apr 6, 2016, at 2:29 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think a sensible specification would be that with a positive step size, the count starts from the lower bound, and with a negative one, it starts from the upper bound (inclusive or exclusive). Thus, the following examples should cover all the corner cases:<br>&gt; <br>&gt;     (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; <br>&gt;     (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;     (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;     (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt; <br>&gt;     (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;     (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; <br>&gt;     (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;     (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt;     (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt; <br>&gt; Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt; <br>&gt;     (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt; <br>&gt; — Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/03b54968/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;     On Apr 6, 2016, at 3:05 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;         On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;             that&#39;s a pretty compelling argument for supporting them.<br>&gt;<br>&gt;                         I&#39;d like to be able to represent any of those as<br>&gt;                 Intervals-which-are-now-Ranges. It makes sense to do so because<br>&gt;                 the<br>&gt;                 things I want to do with them, such as clamping and testing if<br>&gt;                 some<br>&gt;                 value is contained, are exactly what Intervals-now-Ranges<br>&gt;                 provide.<br>&gt;                 Looking around, it seems many other languages provide only what<br>&gt;                 Swift<br>&gt;                 currently does, but Perl does provide `..`, `..^`, `^..`, and<br>&gt;                 `^..^`<br>&gt;                 (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;                 `&lt;.&lt;`).<br>&gt;<br>&gt;             Do we need fully-open ranges too?<br>&gt;<br>&gt;         I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt;         other applications in scientific computing could make use of them.<br>&gt;         I rather like Pyry&#39;s suggestions below. <br>&gt;<br>&gt;     Below?<br>&gt;<br>&gt; Logically in time below.<br></p><p>Oh! In my application, time flows downward.<br></p><p>&gt;<br>&gt; I believe the following is a valid conversion of the Xiaodi Wu below into the<br>&gt; Dave A domain.<br>&gt;<br>&gt;     On Apr 6, 2016, at 2:29 PM, Pyry Jahkola via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     I think a sensible specification would be that with a positive step size,<br>&gt;     the count starts from the lower bound, and with a negative one, it starts<br>&gt;     from the upper bound (inclusive or exclusive). Thus, the following examples<br>&gt;     should cover all the corner cases:<br>&gt;<br>&gt;     (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 &lt;.. 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;<br>&gt;     (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;     (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;     (0 &lt;.. 9).striding(by: 3) == [3, 6, 9]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 3) == [3, 6]<br>&gt;<br>&gt;     (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 ..&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;     (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;<br>&gt;     (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;     (0 ..&lt; 9).striding(by: -3) == [6, 3, 0]<br>&gt;     (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -3) == [6, 3]<br></p><p>These all look reasonable to me.<br></p><p>&gt;     Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt;<br>&gt;     (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br></p><p>Also reasonable.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 6, 2016, at 3:05 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;&gt;            that&#39;s a pretty compelling argument for supporting them.<br>&gt;&gt; <br>&gt;&gt;                        I&#39;d like to be able to represent any of those as<br>&gt;&gt;                Intervals-which-are-now-Ranges. It makes sense to do so because<br>&gt;&gt;                the<br>&gt;&gt;                things I want to do with them, such as clamping and testing if<br>&gt;&gt;                some<br>&gt;&gt;                value is contained, are exactly what Intervals-now-Ranges<br>&gt;&gt;                provide.<br>&gt;&gt;                Looking around, it seems many other languages provide only what<br>&gt;&gt;                Swift<br>&gt;&gt;                currently does, but Perl does provide `..`, `..^`, `^..`, and<br>&gt;&gt;                `^..^`<br>&gt;&gt;                (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt;                `&lt;.&lt;`).<br>&gt;&gt; <br>&gt;&gt;            Do we need fully-open ranges too?<br>&gt;&gt; <br>&gt;&gt;        I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt;&gt;        other applications in scientific computing could make use of them.<br>&gt;&gt;        I rather like Pyry&#39;s suggestions below. <br>&gt;&gt; <br>&gt;&gt;    Below?<br>&gt;&gt; <br>&gt;&gt; Logically in time below.<br>&gt; <br>&gt; Oh! In my application, time flows downward.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I believe the following is a valid conversion of the Xiaodi Wu below into the<br>&gt;&gt; Dave A domain.<br>&gt;&gt; <br>&gt;&gt;    On Apr 6, 2016, at 2:29 PM, Pyry Jahkola via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    I think a sensible specification would be that with a positive step size,<br>&gt;&gt;    the count starts from the lower bound, and with a negative one, it starts<br>&gt;&gt;    from the upper bound (inclusive or exclusive). Thus, the following examples<br>&gt;&gt;    should cover all the corner cases:<br>&gt;&gt; <br>&gt;&gt;    (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt;    (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt;    (0 &lt;.. 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;&gt;    (0 &lt;.&lt; 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;&gt; <br>&gt;&gt;    (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;&gt;    (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;&gt;    (0 &lt;.. 9).striding(by: 3) == [3, 6, 9]<br>&gt;&gt;    (0 &lt;.&lt; 9).striding(by: 3) == [3, 6]<br>&gt;&gt; <br>&gt;&gt;    (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;    (0 ..&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;&gt;    (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;    (0 &lt;.&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;&gt; <br>&gt;&gt;    (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;&gt;    (0 ..&lt; 9).striding(by: -3) == [6, 3, 0]<br>&gt;&gt;    (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;&gt;    (0 &lt;.&lt; 9).striding(by: -3) == [6, 3]<br>&gt; <br>&gt; These all look reasonable to me.<br></p><p>Agreed.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 06.04.2016 um 23:26 schrieb Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 2:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   On Apr 6, 2016, at 3:05 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;   &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;       &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;&gt;&gt;           that&#39;s a pretty compelling argument for supporting them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                       I&#39;d like to be able to represent any of those as<br>&gt;&gt;&gt;               Intervals-which-are-now-Ranges. It makes sense to do so because<br>&gt;&gt;&gt;               the<br>&gt;&gt;&gt;               things I want to do with them, such as clamping and testing if<br>&gt;&gt;&gt;               some<br>&gt;&gt;&gt;               value is contained, are exactly what Intervals-now-Ranges<br>&gt;&gt;&gt;               provide.<br>&gt;&gt;&gt;               Looking around, it seems many other languages provide only what<br>&gt;&gt;&gt;               Swift<br>&gt;&gt;&gt;               currently does, but Perl does provide `..`, `..^`, `^..`, and<br>&gt;&gt;&gt;               `^..^`<br>&gt;&gt;&gt;               (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt;&gt;               `&lt;.&lt;`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;           Do we need fully-open ranges too?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt;&gt;&gt;       other applications in scientific computing could make use of them.<br>&gt;&gt;&gt;       I rather like Pyry&#39;s suggestions below. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Below?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Logically in time below.<br>&gt;&gt; <br>&gt;&gt; Oh! In my application, time flows downward.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the following is a valid conversion of the Xiaodi Wu below into the<br>&gt;&gt;&gt; Dave A domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   On Apr 6, 2016, at 2:29 PM, Pyry Jahkola via swift-evolution<br>&gt;&gt;&gt;   &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   I think a sensible specification would be that with a positive step size,<br>&gt;&gt;&gt;   the count starts from the lower bound, and with a negative one, it starts<br>&gt;&gt;&gt;   from the upper bound (inclusive or exclusive). Thus, the following examples<br>&gt;&gt;&gt;   should cover all the corner cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt;&gt;   (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt;&gt;   (0 &lt;.. 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;&gt;&gt;   (0 &lt;.&lt; 9).striding(by: 2) == [2, 4, 6, 8]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;&gt;&gt;   (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;&gt;&gt;   (0 &lt;.. 9).striding(by: 3) == [3, 6, 9]<br>&gt;&gt;&gt;   (0 &lt;.&lt; 9).striding(by: 3) == [3, 6]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;&gt;   (0 ..&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;&gt;&gt;   (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;&gt;   (0 &lt;.&lt; 9).striding(by: -2) == [7, 5, 3, 1]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;&gt;&gt;   (0 ..&lt; 9).striding(by: -3) == [6, 3, 0]<br>&gt;&gt;&gt;   (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;&gt;&gt;   (0 &lt;.&lt; 9).striding(by: -3) == [6, 3]<br>&gt;&gt; <br>&gt;&gt; These all look reasonable to me.<br>&gt; <br>&gt; Agreed.<br></p><p>I agree as well. Makes sense.<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 3:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; These all look reasonable to me.<br>&gt; <br>&gt;&gt;    Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt;&gt; <br>&gt;&gt;    (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt; <br>&gt; Also reasonable.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>Unless there&#39;s a compelling reason to fight here, it looks like the opinion against<br>where I&#39;m standing is pretty overwhelming at least in this subgroup. To simplify<br>things going forward (and to avoid compiler warnings, which as Dave A points out<br>is probably an indication of bad design more than bad users), I&#39;m willing to adopt<br>in as well.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/582c110c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;     On Apr 6, 2016, at 3:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;     These all look reasonable to me.<br>&gt;<br>&gt;         Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt;<br>&gt;         (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;<br>&gt;     Also reasonable.<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt; Unless there&#39;s a compelling reason to fight here, it looks like the<br>&gt; opinion against where I&#39;m standing is pretty overwhelming at least in<br>&gt; this subgroup. To simplify things going forward (and to avoid compiler<br>&gt; warnings, which as Dave A points out is probably an indication of bad<br>&gt; design more than bad users), I&#39;m willing to adopt in as well.<br></p><p>Thanks.  In that case, I suggest that we entertain two separate<br>proposals:<br></p><p>1. add the .striding(by: n) method.<br>2. add the other range operators.<br></p><p>Though they both have obvious benefits, I expect #1 is a much easier<br>sell than #2, which is one good reason to separate them.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 3:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 6, 2016, at 3:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    These all look reasonable to me.<br>&gt;&gt; <br>&gt;&gt;        Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt;&gt; <br>&gt;&gt;        (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;&gt; <br>&gt;&gt;    Also reasonable.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt; Unless there&#39;s a compelling reason to fight here, it looks like the<br>&gt;&gt; opinion against where I&#39;m standing is pretty overwhelming at least in<br>&gt;&gt; this subgroup. To simplify things going forward (and to avoid compiler<br>&gt;&gt; warnings, which as Dave A points out is probably an indication of bad<br>&gt;&gt; design more than bad users), I&#39;m willing to adopt in as well.<br>&gt; <br>&gt; Thanks.  In that case, I suggest that we entertain two separate<br>&gt; proposals:<br>&gt; <br>&gt; 1. add the .striding(by: n) method.<br>&gt; 2. add the other range operators.<br>&gt; <br>&gt; Though they both have obvious benefits, I expect #1 is a much easier<br>&gt; sell than #2, which is one good reason to separate them.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>I may have misunderstood the intent so I want to clarify: Dave, you&#39;d like to push on these<br>now (starting with #1) and not wait for the rest of the Range stuff to come online, right?<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 4:05 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Apr 6, 2016 at 3:28 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; You if you need to represent `&lt;..` intervals in scientific computing,<br>&gt;&gt;&gt; that&#39;s a pretty compelling argument for supporting them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;d like to be able to represent any of those as<br>&gt;&gt;&gt;&gt; Intervals-which-are-now-Ranges. It makes sense to do so because the<br>&gt;&gt;&gt;&gt; things I want to do with them, such as clamping and testing if some<br>&gt;&gt;&gt;&gt; value is contained, are exactly what Intervals-now-Ranges provide.<br>&gt;&gt;&gt;&gt; Looking around, it seems many other languages provide only what Swift<br>&gt;&gt;&gt;&gt; currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>&gt;&gt;&gt;&gt; (which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>&gt;&gt;&gt;&gt; `&lt;.&lt;`).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do we need fully-open ranges too?<br>&gt;&gt;<br>&gt;&gt; I haven&#39;t encountered a need for open ranges, but I would expect that<br>&gt;&gt; other applications in scientific computing could make use of them.<br>&gt;&gt; I rather like Pyry&#39;s suggestions below.<br>&gt;<br>&gt; Below?<br></p><p>Sorry, chronologically, above; in terms of relative positions in the<br>thread, I think, below, since Pyry&#39;s suggests followed on from the<br>time I started writing. Ha, and Erica (above/below) just filled in<br>what I meant to say.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
