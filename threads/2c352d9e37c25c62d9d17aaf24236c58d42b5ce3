<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>In CollectionType, a `Range` is accepted as the argument in a version of `subscript`, which returns a subsequence.<br></p><p>    [1,2,3,4][2...3] // [3, 4]<br></p><p>`subscript` raises a fatal error if the range is out of bound, which is really a side-effect from accessing an element with an out of bound index. This behavior forces users to check bounds beforehand. It has been serving us well.<br></p><p>I propose adding a new interface where user can recover from/defer out of bound error in this context. Here are two potential approaches.<br></p><p>Approach #1 is more conservative, we add a throwing version of `subscript`. It throws an error if the range is out of bound. We can give the range parameter a name for distinction, resulting usage would look like:<br></p><p>    do {<br>       let gimme = [1,2,3,4][safe: 2...4]<br>    } catch {<br>        recover()<br>    }<br></p><p>As an alternative, we can replace the original `subscript` with this version, breaking backward compatibilty.<br></p><p>Apporoach #2 is a really sweet syntax sugar. We add a new subscript that accepts 2 arugments:<br></p><p>    extension CollectionType where Self.Index: RandomAccessIndexType {<br>        public subscript(start:Int?, end:Int?) -&gt; Self.SubSequence { ... }<br>    }<br></p><p>This version would make ANY combination of arugment safe by enabling a sematic similar to Python&#39;s slicing mechanism. Explanations come after these examples:<br></p><p>    [0,1,2,3][1, -1]                    // [1, 2]<br>    [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;][-1000, nil]   // [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>    [1,2,3,4,5,6,7,8][1,5][2,3]         // [4]<br></p><p>This should look familiar to Python users:<br></p><p>* the access is always clamped in-bound. Interpret out-of-bound number as the boundary.  [1,2,3][0: 100] means [1,2,3][0: 2].<br>* nil indicate the boundary itself. [1,2,3][0: nil] means [1,2,3][0: 2]<br>* negative index counts from the end of the sequence. [1,2,3][-2, -1] means [1,2,3][(3-2), (3-1)]<br></p><p>Admittedly, this syntax suger seems a little out-of-place in Swift :P<br></p><p>Both approaches require just a little of work. As an example, here&#39;s one implementation of the 2nd: https://github.com/dduan/Lic/blob/master/Lic/Lic.swift (please ignore the extension for String, that&#39;d be in a separate proposal, if any).<br></p><p><br>What do you think?<br></p><p>- Daniel Duan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi, Daniel. Thanks for bringing this up. May I ask where you would use a &quot;safe&quot; subscript? When are you performing a subscript where the bounds being…um, out-of-bound…is not a programmer error?<br></p><p>As for the second half of this, we deliberately decided to not make the subscript operator &quot;smart&quot; (handling negative indexes and such) because extra branches can do very bad things to performance, and because allowing negative indexes sometimes hide bugs. It&#39;s also not meaningful for collections whose indexes are not integers.<br></p><p>Best,<br>Jordan<br></p><p>&gt; On Dec 14, 2015, at 12:52, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; In CollectionType, a `Range` is accepted as the argument in a version of `subscript`, which returns a subsequence.<br>&gt; <br>&gt;    [1,2,3,4][2...3] // [3, 4]<br>&gt; <br>&gt; `subscript` raises a fatal error if the range is out of bound, which is really a side-effect from accessing an element with an out of bound index. This behavior forces users to check bounds beforehand. It has been serving us well.<br>&gt; <br>&gt; I propose adding a new interface where user can recover from/defer out of bound error in this context. Here are two potential approaches.<br>&gt; <br>&gt; Approach #1 is more conservative, we add a throwing version of `subscript`. It throws an error if the range is out of bound. We can give the range parameter a name for distinction, resulting usage would look like:<br>&gt; <br>&gt;    do {<br>&gt;       let gimme = [1,2,3,4][safe: 2...4]<br>&gt;    } catch {<br>&gt;        recover()<br>&gt;    }<br>&gt; <br>&gt; As an alternative, we can replace the original `subscript` with this version, breaking backward compatibilty.<br>&gt; <br>&gt; Apporoach #2 is a really sweet syntax sugar. We add a new subscript that accepts 2 arugments:<br>&gt; <br>&gt;    extension CollectionType where Self.Index: RandomAccessIndexType {<br>&gt;        public subscript(start:Int?, end:Int?) -&gt; Self.SubSequence { ... }<br>&gt;    }<br>&gt; <br>&gt; This version would make ANY combination of arugment safe by enabling a sematic similar to Python&#39;s slicing mechanism. Explanations come after these examples:<br>&gt; <br>&gt;    [0,1,2,3][1, -1]                    // [1, 2]<br>&gt;    [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;][-1000, nil]   // [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>&gt;    [1,2,3,4,5,6,7,8][1,5][2,3]         // [4]<br>&gt; <br>&gt; This should look familiar to Python users:<br>&gt; <br>&gt; * the access is always clamped in-bound. Interpret out-of-bound number as the boundary.  [1,2,3][0: 100] means [1,2,3][0: 2].<br>&gt; * nil indicate the boundary itself. [1,2,3][0: nil] means [1,2,3][0: 2]<br>&gt; * negative index counts from the end of the sequence. [1,2,3][-2, -1] means [1,2,3][(3-2), (3-1)]<br>&gt; <br>&gt; Admittedly, this syntax suger seems a little out-of-place in Swift :P<br>&gt; <br>&gt; Both approaches require just a little of work. As an example, here&#39;s one implementation of the 2nd: https://github.com/dduan/Lic/blob/master/Lic/Lic.swift (please ignore the extension for String, that&#39;d be in a separate proposal, if any).<br>&gt; <br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; - Daniel Duan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>Jordan, I think the inspiration here might come from Ruby. I must admit<br>that seeing that `Array.first` returns an optional, but Array#subscript<br>raises a runtime error when the index is out of bounds threw me for a loop.<br>In Ruby, both Array#first and Array.subscript return an optional.<br></p><p>If one of the original tenets of swift was to provide greater compile-time<br>null-safety, which it definitely seems it was given the commendable<br>emphasis on optionals being easy to use, then returning an optional would<br>be a solid way to go about subscripting. Think of it this way: when I call<br>a method with nullable return value, I am forced to deal with the fact that<br>the method can fail at compile time. When I subscript an array, I am not<br>forced to deal with it at compile time, and it will fail at runtime instead.<br></p><p>Nullable subscripting is a big departure from the way most modern languages<br>do things and that is why I don&#39;t blame you for rejecting it. That said, it<br>is a pleasant change in the way you think about subscripting.<br></p><p>As a closing thought, subscripting hashes returns an optional value. You<br>might consider this a pretty big inconsistency with arrays. Let me flip<br>your argument against optional array subscripting, for dictionaries: *When<br>you are performing a subscript where the key is out of the key set, is it<br>not a programmer error?*<br></p><p>On Mon, Dec 14, 2015 at 4:54 PM Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi, Daniel. Thanks for bringing this up. May I ask where you would use a<br>&gt; &quot;safe&quot; subscript? When are you performing a subscript where the bounds<br>&gt; being…um, out-of-bound…is not a programmer error?<br>&gt;<br>&gt; As for the second half of this, we deliberately decided to not make the<br>&gt; subscript operator &quot;smart&quot; (handling negative indexes and such) because<br>&gt; extra branches can do very bad things to performance, and because allowing<br>&gt; negative indexes sometimes hide bugs. It&#39;s also not meaningful for<br>&gt; collections whose indexes are not integers.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt; &gt; On Dec 14, 2015, at 12:52, Daniel Duan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; In CollectionType, a `Range` is accepted as the argument in a version of<br>&gt; `subscript`, which returns a subsequence.<br>&gt; &gt;<br>&gt; &gt;    [1,2,3,4][2...3] // [3, 4]<br>&gt; &gt;<br>&gt; &gt; `subscript` raises a fatal error if the range is out of bound, which is<br>&gt; really a side-effect from accessing an element with an out of bound index.<br>&gt; This behavior forces users to check bounds beforehand. It has been serving<br>&gt; us well.<br>&gt; &gt;<br>&gt; &gt; I propose adding a new interface where user can recover from/defer out<br>&gt; of bound error in this context. Here are two potential approaches.<br>&gt; &gt;<br>&gt; &gt; Approach #1 is more conservative, we add a throwing version of<br>&gt; `subscript`. It throws an error if the range is out of bound. We can give<br>&gt; the range parameter a name for distinction, resulting usage would look like:<br>&gt; &gt;<br>&gt; &gt;    do {<br>&gt; &gt;       let gimme = [1,2,3,4][safe: 2...4]<br>&gt; &gt;    } catch {<br>&gt; &gt;        recover()<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; As an alternative, we can replace the original `subscript` with this<br>&gt; version, breaking backward compatibilty.<br>&gt; &gt;<br>&gt; &gt; Apporoach #2 is a really sweet syntax sugar. We add a new subscript that<br>&gt; accepts 2 arugments:<br>&gt; &gt;<br>&gt; &gt;    extension CollectionType where Self.Index: RandomAccessIndexType {<br>&gt; &gt;        public subscript(start:Int?, end:Int?) -&gt; Self.SubSequence { ... }<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; This version would make ANY combination of arugment safe by enabling a<br>&gt; sematic similar to Python&#39;s slicing mechanism. Explanations come after<br>&gt; these examples:<br>&gt; &gt;<br>&gt; &gt;    [0,1,2,3][1, -1]                    // [1, 2]<br>&gt; &gt;    [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;][-1000, nil]   // [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>&gt; &gt;    [1,2,3,4,5,6,7,8][1,5][2,3]         // [4]<br>&gt; &gt;<br>&gt; &gt; This should look familiar to Python users:<br>&gt; &gt;<br>&gt; &gt; * the access is always clamped in-bound. Interpret out-of-bound number<br>&gt; as the boundary.  [1,2,3][0: 100] means [1,2,3][0: 2].<br>&gt; &gt; * nil indicate the boundary itself. [1,2,3][0: nil] means [1,2,3][0: 2]<br>&gt; &gt; * negative index counts from the end of the sequence. [1,2,3][-2, -1]<br>&gt; means [1,2,3][(3-2), (3-1)]<br>&gt; &gt;<br>&gt; &gt; Admittedly, this syntax suger seems a little out-of-place in Swift :P<br>&gt; &gt;<br>&gt; &gt; Both approaches require just a little of work. As an example, here&#39;s one<br>&gt; implementation of the 2nd:<br>&gt; https://github.com/dduan/Lic/blob/master/Lic/Lic.swift (please ignore the<br>&gt; extension for String, that&#39;d be in a separate proposal, if any).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; What do you think?<br>&gt; &gt;<br>&gt; &gt; - Daniel Duan<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/3af895f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>Sorry, looks like I conflated a few different terms in that message. Just<br>pretend I said &quot;optional&quot; anywhere I said &quot;nullable&quot;, and &quot;dictionary&quot;<br>anywhere I said &quot;hash&quot;. Been context switching among Swift, Java, Ruby and<br>Kotlin all day.<br></p><p>On Mon, Dec 14, 2015 at 6:40 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Jordan, I think the inspiration here might come from Ruby. I must admit<br>&gt; that seeing that `Array.first` returns an optional, but Array#subscript<br>&gt; raises a runtime error when the index is out of bounds threw me for a loop.<br>&gt; In Ruby, both Array#first and Array.subscript return an optional.<br>&gt;<br>&gt; If one of the original tenets of swift was to provide greater compile-time<br>&gt; null-safety, which it definitely seems it was given the commendable<br>&gt; emphasis on optionals being easy to use, then returning an optional would<br>&gt; be a solid way to go about subscripting. Think of it this way: when I call<br>&gt; a method with nullable return value, I am forced to deal with the fact that<br>&gt; the method can fail at compile time. When I subscript an array, I am not<br>&gt; forced to deal with it at compile time, and it will fail at runtime instead.<br>&gt;<br>&gt; Nullable subscripting is a big departure from the way most modern<br>&gt; languages do things and that is why I don&#39;t blame you for rejecting it.<br>&gt; That said, it is a pleasant change in the way you think about subscripting.<br>&gt;<br>&gt; As a closing thought, subscripting hashes returns an optional value. You<br>&gt; might consider this a pretty big inconsistency with arrays. Let me flip<br>&gt; your argument against optional array subscripting, for dictionaries: *When<br>&gt; you are performing a subscript where the key is out of the key set, is it<br>&gt; not a programmer error?*<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 4:54 PM Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi, Daniel. Thanks for bringing this up. May I ask where you would use a<br>&gt;&gt; &quot;safe&quot; subscript? When are you performing a subscript where the bounds<br>&gt;&gt; being…um, out-of-bound…is not a programmer error?<br>&gt;&gt;<br>&gt;&gt; As for the second half of this, we deliberately decided to not make the<br>&gt;&gt; subscript operator &quot;smart&quot; (handling negative indexes and such) because<br>&gt;&gt; extra branches can do very bad things to performance, and because allowing<br>&gt;&gt; negative indexes sometimes hide bugs. It&#39;s also not meaningful for<br>&gt;&gt; collections whose indexes are not integers.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 14, 2015, at 12:52, Daniel Duan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In CollectionType, a `Range` is accepted as the argument in a version<br>&gt;&gt; of `subscript`, which returns a subsequence.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    [1,2,3,4][2...3] // [3, 4]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; `subscript` raises a fatal error if the range is out of bound, which is<br>&gt;&gt; really a side-effect from accessing an element with an out of bound index.<br>&gt;&gt; This behavior forces users to check bounds beforehand. It has been serving<br>&gt;&gt; us well.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I propose adding a new interface where user can recover from/defer out<br>&gt;&gt; of bound error in this context. Here are two potential approaches.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Approach #1 is more conservative, we add a throwing version of<br>&gt;&gt; `subscript`. It throws an error if the range is out of bound. We can give<br>&gt;&gt; the range parameter a name for distinction, resulting usage would look like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    do {<br>&gt;&gt; &gt;       let gimme = [1,2,3,4][safe: 2...4]<br>&gt;&gt; &gt;    } catch {<br>&gt;&gt; &gt;        recover()<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As an alternative, we can replace the original `subscript` with this<br>&gt;&gt; version, breaking backward compatibilty.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Apporoach #2 is a really sweet syntax sugar. We add a new subscript<br>&gt;&gt; that accepts 2 arugments:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    extension CollectionType where Self.Index: RandomAccessIndexType {<br>&gt;&gt; &gt;        public subscript(start:Int?, end:Int?) -&gt; Self.SubSequence { ...<br>&gt;&gt; }<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This version would make ANY combination of arugment safe by enabling a<br>&gt;&gt; sematic similar to Python&#39;s slicing mechanism. Explanations come after<br>&gt;&gt; these examples:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    [0,1,2,3][1, -1]                    // [1, 2]<br>&gt;&gt; &gt;    [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;][-1000, nil]   // [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>&gt;&gt; &gt;    [1,2,3,4,5,6,7,8][1,5][2,3]         // [4]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This should look familiar to Python users:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * the access is always clamped in-bound. Interpret out-of-bound number<br>&gt;&gt; as the boundary.  [1,2,3][0: 100] means [1,2,3][0: 2].<br>&gt;&gt; &gt; * nil indicate the boundary itself. [1,2,3][0: nil] means [1,2,3][0: 2]<br>&gt;&gt; &gt; * negative index counts from the end of the sequence. [1,2,3][-2, -1]<br>&gt;&gt; means [1,2,3][(3-2), (3-1)]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Admittedly, this syntax suger seems a little out-of-place in Swift :P<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Both approaches require just a little of work. As an example, here&#39;s<br>&gt;&gt; one implementation of the 2nd:<br>&gt;&gt; https://github.com/dduan/Lic/blob/master/Lic/Lic.swift (please ignore<br>&gt;&gt; the extension for String, that&#39;d be in a separate proposal, if any).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do you think?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Daniel Duan<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/8968e6f8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>These are good points to bring up, Dennis. I&#39;m not one of the standard library authors, so I might not get this exactly right, but I&#39;ll try to address each point.<br></p><p>&gt; On Dec 14, 2015, at 15:40, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Jordan, I think the inspiration here might come from Ruby. I must admit that seeing that `Array.first` returns an optional, but Array#subscript raises a runtime error when the index is out of bounds threw me for a loop. In Ruby, both Array#first and Array.subscript return an optional.<br></p><p>I do remember there being a discussion about this. One of the arguments in favor of the current behavior was &quot;seq.first ?? defaultValue&quot;, which isn&#39;t too uncommon. The equivalent with an arbitrary subscript comes up much less often.<br></p><p>&gt; If one of the original tenets of swift was to provide greater compile-time null-safety, which it definitely seems it was given the commendable emphasis on optionals being easy to use, then returning an optional would be a solid way to go about subscripting. Think of it this way: when I call a method with nullable return value, I am forced to deal with the fact that the method can fail at compile time. When I subscript an array, I am not forced to deal with it at compile time, and it will fail at runtime instead.<br></p><p>From my perspective, array subscripting is not &quot;an operation that can fail&quot;. It just has a precondition on its input parameter. Optional return values force you to deal with dynamic failures, but array subscripting should never get to that point.<br></p><p>I think the equivalent would be forcing the user to check the input rather than the output, just as you are forced to check whether an optional is nil before using it rather than after. If you ignore a method return value you&#39;re not actually dealing with its failure.<br></p><p><br>&gt; Nullable subscripting is a big departure from the way most modern languages do things and that is why I don&#39;t blame you for rejecting it. That said, it is a pleasant change in the way you think about subscripting.<br>&gt; <br>&gt; As a closing thought, subscripting hashes returns an optional value. You might consider this a pretty big inconsistency with arrays. Let me flip your argument against optional array subscripting, for dictionaries: When you are performing a subscript where the key is out of the key set, is it not a programmer error?<br></p><p>No, it is not; it is the canonical way to tell if a key has an entry in the dictionary, and the canonical way to insert a new entry into the dictionary. The same is not true for Array.<br></p><p>(Note also that Dictionary&#39;s subscript that takes an Index does not return an optional result.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/58e2434d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 15, 2015 at 12:00:00am</p></header><div class="content"><p>Jordan, thanks for the clarification. It is pretty easy to check if your<br>index is in-bounds before subscripting. Just unexpected as most things<br>causing a runtime crash tend to be marked with a &#39;!&#39; (try!, unwrapping an<br>optional with !, implicitly unwrapped optionals...)<br></p><p>On Mon, Dec 14, 2015 at 6:52 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; These are good points to bring up, Dennis. I&#39;m not one of the standard<br>&gt; library authors, so I might not get this exactly right, but I&#39;ll try to<br>&gt; address each point.<br>&gt;<br>&gt; On Dec 14, 2015, at 15:40, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Jordan, I think the inspiration here might come from Ruby. I must admit<br>&gt; that seeing that `Array.first` returns an optional, but Array#subscript<br>&gt; raises a runtime error when the index is out of bounds threw me for a loop.<br>&gt; In Ruby, both Array#first and Array.subscript return an optional.<br>&gt;<br>&gt;<br>&gt; I do remember there being a discussion about this. One of the arguments in<br>&gt; favor of the current behavior was &quot;seq.first ?? defaultValue&quot;, which isn&#39;t<br>&gt; too uncommon. The equivalent with an arbitrary subscript comes up much less<br>&gt; often.<br>&gt;<br>&gt; If one of the original tenets of swift was to provide greater compile-time<br>&gt; null-safety, which it definitely seems it was given the commendable<br>&gt; emphasis on optionals being easy to use, then returning an optional would<br>&gt; be a solid way to go about subscripting. Think of it this way: when I call<br>&gt; a method with nullable return value, I am forced to deal with the fact that<br>&gt; the method can fail at compile time. When I subscript an array, I am not<br>&gt; forced to deal with it at compile time, and it will fail at runtime instead.<br>&gt;<br>&gt;<br>&gt; From my perspective, array subscripting is not &quot;an operation that can<br>&gt; fail&quot;. It just has a precondition on its input parameter. Optional return<br>&gt; values force you to deal with *dynamic* failures, but array subscripting<br>&gt; should never get to that point.<br>&gt;<br>&gt; I think the equivalent would be forcing the user to check the *input* rather<br>&gt; than the *output,* just as you are forced to check whether an optional is<br>&gt; nil *before* using it rather than *after.* If you ignore a method return<br>&gt; value you&#39;re not actually dealing with its failure.<br>&gt;<br>&gt;<br>&gt; Nullable subscripting is a big departure from the way most modern<br>&gt; languages do things and that is why I don&#39;t blame you for rejecting it.<br>&gt; That said, it is a pleasant change in the way you think about subscripting.<br>&gt;<br>&gt; As a closing thought, subscripting hashes returns an optional value. You<br>&gt; might consider this a pretty big inconsistency with arrays. Let me flip<br>&gt; your argument against optional array subscripting, for dictionaries: *When<br>&gt; you are performing a subscript where the key is out of the key set, is it<br>&gt; not a programmer error?*<br>&gt;<br>&gt;<br>&gt; No, it is not; it is the canonical way to tell if a key has an entry in<br>&gt; the dictionary, and the canonical way to insert a new entry into the<br>&gt; dictionary. The same is not true for Array.<br>&gt;<br>&gt; (Note also that Dictionary&#39;s subscript that takes an Index does not return<br>&gt; an optional result.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/d608429d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; As a closing thought, subscripting hashes returns an optional value. You might consider this a pretty big inconsistency with arrays. Let me flip your argument against optional array subscripting, for dictionaries: When you are performing a subscript where the key is out of the key set, is it not a programmer error?<br></p><p>The use cases for arrays and dictionaries are different, though.<br></p><p>I’d say about 80% of the time you subscript an array, you’re using an index that was somehow derived *from* the array—for instance, a range like `0..&lt;array.count`, or `array.indices`, or `array[indexPath.row]` where `tableView(_:numberOfRowsInSection:)` returns `array.count`. This is very different from dictionaries, where the key is usually some piece of data from somewhere *else* and you’re trying to look up the value corresponding to it. You rarely say, for instance, `array[2]` or `array[someRandomNumberFromSomewhere]`, but `dictionary[“myKey”]` or `dictionary[someRandomValueFromSomewhere]` are pretty common.<br></p><p>Because the use cases are different, arrays have a non-optional subscriptor which fails a precondition when the index is invalid, while dictionaries have an optional subscriptor which returns nil when the index is invalid.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 6:13 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; As a closing thought, subscripting hashes returns an optional value. You might consider this a pretty big inconsistency with arrays. Let me flip your argument against optional array subscripting, for dictionaries: When you are performing a subscript where the key is out of the key set, is it not a programmer error?<br>&gt; <br>&gt; The use cases for arrays and dictionaries are different, though.<br>&gt; <br>&gt; I’d say about 80% of the time you subscript an array, you’re using an index that was somehow derived *from* the array—for instance, a range like `0..&lt;array.count`, or `array.indices`, or `array[indexPath.row]` where `tableView(_:numberOfRowsInSection:)` returns `array.count`. This is very different from dictionaries, where the key is usually some piece of data from somewhere *else* and you’re trying to look up the value corresponding to it. You rarely say, for instance, `array[2]` or `array[someRandomNumberFromSomewhere]`, but `dictionary[“myKey”]` or `dictionary[someRandomValueFromSomewhere]` are pretty common.<br>&gt; <br>&gt; Because the use cases are different, arrays have a non-optional subscriptor which fails a precondition when the index is invalid, while dictionaries have an optional subscriptor which returns nil when the index is invalid.<br></p><p>Thank you, Brent; that captures the rationale exactly.  The one thing missing is the performance piece: allowing arrays to do anything other than abort on out-of-range accesses would make them non-competitive with C arrays.<br></p><p>HTH,<br>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Proposal: Add Safe Subquence Access Via subscript For ColloctionType</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>IMHO, Swift could give users more help to reduce boundary related errors. Perhaps a more practical thing to have is  `array[clamp: x…y]`, which always returns a Subsequence.<br></p><p>Along that line, I realize “safe” may be conveying the wrong idea.<br></p><p>Right now, a user have to remember that `someArray[3]` may crash while they don’t need to worry about `someDictionary[3]` crashing, I guess what’s really missing is a throwing version of `subscript`, or one such that nil is returned for invalid indexes. <br></p><p>As for negative index, I accept the performance argument. “sometimes hide bugs” is less convincing as “crash early in production”, depending on context, is not necessarily the best way a programmer error to manifest. (example: crashing is the worst user experience on iOS. Wrong set of data *sometimes* gets along with the view layer just fine). From personal experience with Python, most of the time it’s a really useful feature. <br></p><p>Regardless, this proposal doesn’t change any existing behavior, negative index is allowed only for retrieve subsequence (where Self.index: RandomAccessIndexType, so that `count` is accessible at O(1)). But I understand the the idea as a whole is a bit out there :P<br></p><p>Best,<br>Daniel<br></p><p><br>&gt; On Dec 14, 2015, at 1:54 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi, Daniel. Thanks for bringing this up. May I ask where you would use a &quot;safe&quot; subscript? When are you performing a subscript where the bounds being…um, out-of-bound…is not a programmer error?<br>&gt; <br>&gt; As for the second half of this, we deliberately decided to not make the subscript operator &quot;smart&quot; (handling negative indexes and such) because extra branches can do very bad things to performance, and because allowing negative indexes sometimes hide bugs. It&#39;s also not meaningful for collections whose indexes are not integers.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 12:52, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In CollectionType, a `Range` is accepted as the argument in a version of `subscript`, which returns a subsequence.<br>&gt;&gt; <br>&gt;&gt;   [1,2,3,4][2...3] // [3, 4]<br>&gt;&gt; <br>&gt;&gt; `subscript` raises a fatal error if the range is out of bound, which is really a side-effect from accessing an element with an out of bound index. This behavior forces users to check bounds beforehand. It has been serving us well.<br>&gt;&gt; <br>&gt;&gt; I propose adding a new interface where user can recover from/defer out of bound error in this context. Here are two potential approaches.<br>&gt;&gt; <br>&gt;&gt; Approach #1 is more conservative, we add a throwing version of `subscript`. It throws an error if the range is out of bound. We can give the range parameter a name for distinction, resulting usage would look like:<br>&gt;&gt; <br>&gt;&gt;   do {<br>&gt;&gt;      let gimme = [1,2,3,4][safe: 2...4]<br>&gt;&gt;   } catch {<br>&gt;&gt;       recover()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; As an alternative, we can replace the original `subscript` with this version, breaking backward compatibilty.<br>&gt;&gt; <br>&gt;&gt; Apporoach #2 is a really sweet syntax sugar. We add a new subscript that accepts 2 arugments:<br>&gt;&gt; <br>&gt;&gt;   extension CollectionType where Self.Index: RandomAccessIndexType {<br>&gt;&gt;       public subscript(start:Int?, end:Int?) -&gt; Self.SubSequence { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; This version would make ANY combination of arugment safe by enabling a sematic similar to Python&#39;s slicing mechanism. Explanations come after these examples:<br>&gt;&gt; <br>&gt;&gt;   [0,1,2,3][1, -1]                    // [1, 2]<br>&gt;&gt;   [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;][-1000, nil]   // [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>&gt;&gt;   [1,2,3,4,5,6,7,8][1,5][2,3]         // [4]<br>&gt;&gt; <br>&gt;&gt; This should look familiar to Python users:<br>&gt;&gt; <br>&gt;&gt; * the access is always clamped in-bound. Interpret out-of-bound number as the boundary.  [1,2,3][0: 100] means [1,2,3][0: 2].<br>&gt;&gt; * nil indicate the boundary itself. [1,2,3][0: nil] means [1,2,3][0: 2]<br>&gt;&gt; * negative index counts from the end of the sequence. [1,2,3][-2, -1] means [1,2,3][(3-2), (3-1)]<br>&gt;&gt; <br>&gt;&gt; Admittedly, this syntax suger seems a little out-of-place in Swift :P<br>&gt;&gt; <br>&gt;&gt; Both approaches require just a little of work. As an example, here&#39;s one implementation of the 2nd: https://github.com/dduan/Lic/blob/master/Lic/Lic.swift (please ignore the extension for String, that&#39;d be in a separate proposal, if any).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; - Daniel Duan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
