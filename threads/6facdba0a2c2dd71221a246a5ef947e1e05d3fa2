<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Use of angle bracket type generics with protocols</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>One of the big things that bugs me about working with protocols and generics is that they have a fundamentally different style to working with generics on structs and classes. While has some minor benefits on differentiating them, I think that overall it results in inconsistency that makes them harder to work with.<br></p><p>I’d like to propose two fairly minor changes that allow protocols to be defined using angle brackets for generics to make things much easier. <br></p><p>First is allowing a protocol to be defined using angle brackets for its generic type(s) like so:<br></p><p>	protocol FooType&lt;Element, Index:ForwardIndexType&gt; {<br>		func getElement(atIndex:Index) -&gt; Element?<br>	}<br></p><p>In this example the protocol Foo has implicit type aliases for Element and Index, which can be fulfilled like so:<br></p><p>	struct Foo&lt;Element&gt; : FooType&lt;Element, Int&gt; {<br>		func getElement(atIndex:Index) -&gt; Element? { … }<br>	}<br></p><p>The other important case is defining type constraints with protocol generics, currently we have to do stuff like this:<br></p><p>	func append&lt;S:SequenceType where S.Generator.Element == Element&gt;(contentsOf theSequence:S) { … }<br></p><p>However, while definition with a where clause is powerful, in the majority of cases it’s much more complex than it needs to be. So I’d like to propose that we can have the following:<br></p><p>	protocol SequenceType&lt;Element&gt; { … }<br>	func append(contentsOf theSequence:SequenceType&lt;Element&gt;) { … }<br></p><p>Behind the scenes these may be unwrapped into type aliases and where clauses like we have now, but for the developers this is much, much simpler to work with, especially when most generic constraints are pretty simple.<br></p><p>I’m not proposing the removal of where clauses as they can be really useful in more unusual cases, so will still have utility there. I’m not so sure about explicit type alias declaration like we have now though; using the angle brackets to declare these seems just as capable to me unless there are some cases I haven’t considered.<br></p><p><br>This seems like something that may have been discussed in the past, but I’m not that great on specific terminology for features (I’m not as well versed as others are on the correct names for language features) so I haven’t found anything, but fully expect that I may have missed it somehow, in which case a link would be appreciated.<br></p><p>But if no proposal currently exists then I’d love to know, as I could try to create a more formal proposal for this if necessary, as I know that I for one would benefit greatly from simplified protocol generics, as they’re currently one of my least favourite features to use syntactically, but one I need to use a lot.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/6fac3fa2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Pre-proposal] Use of angle bracket type generics with protocols</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve been using generics a fair amount recently. The Swift 3 notes declare<br>an intention for &#39;complete generics&#39;, but there isn&#39;t much information on<br>what this consists of.<br></p><p>I think there are three key elements to the terminology here. In a<br>declaration of a generic type, you have associated types, generic<br>parameters, and generic constraints. I imagine the Swift for a Set type<br>looks like this:<br></p><p>struct Set&lt;Element where Element : Hashable&gt; : CollectionType<br></p><p>{<br></p><p>typealias Index = SetIndex&lt;Element&gt;<br></p><p>}<br></p><p><br>Element is a generic parameter. Element : Hashable is a generic constraint.<br>Index is an associated type and it&#39;s required to conform to CollectionType.<br>The distinction is important; we could create a non-generic type IntSet<br>like this:<br></p><p>struct IntSet : CollectionType<br></p><p>{<br></p><p>typealias Index = SetIndex&lt;Int&gt;<br></p><p>}<br></p><p>I think it should be possible to declare a property which conforms to<br>CollectionType, constrained such that its Index is a SetIndex&lt;Int&gt; type (as<br>opposed to, say, SetIndex&lt;String&gt;). Or, I think it should be possible to<br>declare a property which conforms to GeneratorType, constrained that its<br>Element conforms to IntegerArithmeticType, so I can generate random numbers<br>and add them together and not yet decide whether they&#39;re Ints or Doubles or<br>whether the generation was by dice or playing cards.<br></p><p>I think I should be able to declare a Graph generic data structure with<br>values for its nodes and edges - e.g. a Travelling Salesman Problem graph<br>of Graph&lt;City, Route&gt; - and have a matching generic GraphTraverser type<br>which takes a graph and a starting node, and traverses the graph reporting<br>to a matching GraphTraversalDelegate type when it traverses an edge,<br>reaches a node, or needs a decision making on which of the available edges<br>it should traverse next. For this, the GraphTraverser should have a<br>matching &#39;generic parameter signature&#39; to the Graph, but the<br>GraphTraversalDelegate will be context specific and should dictate<br>type-safe decisions based on City nodes and Route edges.<br></p><p>At the moment, this traversal pattern isn&#39;t possible because protocols<br>can&#39;t have generic parameters. I&#39;ve seen programmers develop &#39;thunk&#39; types<br>to work around this, but this should be neater.<br></p><p>So, I think it&#39;s important that we keep generic parameters and associated<br>types distinct - but, protocols should be able to handle generics, perhaps<br>with some implicit typealiasing.<br></p><p>The OP&#39;s examples; the developer would write this:<br></p><p>protocol FooType&lt;Element, Index where Index : ForwardIndexType&gt; {<br></p><p>func getElement(atIndex:Index) -&gt; Element?<br></p><p>}<br></p><p><br>struct Foo&lt;Element&gt; : FooType&lt;Element, Int&gt; {<br></p><p>func getElement(atIndex:Index) -&gt; Element? { ... }<br></p><p>}<br></p><p>But what would result would be this:<br></p><p>protocol FooType&lt;Element, Index where Index : ForwardIndexType&gt; {<br></p><p>typealias Element // implicitly generated associatedtypes and typealiases<br></p><p>typealias Index // implicit<br></p><p><br>func getElement(atIndex:Index) -&gt; Element?<br></p><p>}<br></p><p><br>struct Foo&lt;Element&gt; : FooType {<br></p><p>typealias Element = Element // implicitly generated associatedtypes and<br>typealiases<br></p><p>typealias Index = Int // implicit<br></p><p>func getElement(atIndex:Index) -&gt; Element? { return nil }<br></p><p>}<br></p><p><br>I&#39;m not sure what I&#39;d prefer for the syntax of a type which e.g. conformed<br>to FooType and whose Index was an Int. One of these two?<br>1) generic parameters matched by position in sequence<br></p><p>let foo : FooType&lt;_, Int&gt; = Foo&lt;String&gt;<br></p><p>2) associated type matched to type.<br></p><p>let foo : FooType&lt;Index:Int&gt; = Foo&lt;String&gt;<br></p><p>Here&#39;s a further code example - the graph traverser from before might look<br>like this:<br></p><p>struct GraphTraverser&lt;NodeType, EdgeType&gt;<br></p><p>{<br></p><p>let graph : Graph&lt;NodeType, EdgeType&gt;<br></p><p>var currentNode : NodeType<br></p><p>weak var delegate : GraphTraversalDelegate&lt;NodeType, EdgeType&gt;?<br></p><p><br>func move()<br></p><p>{<br></p><p>let options = graph.edgesFromNode(currentNode)<br></p><p>if let decision = delegate?.graphTraverser(self,<br>chooseEdgeFromOptions:options)<br></p><p>{<br></p><p>currentNode = decision.destination<br></p><p>delegate?.graphTraverser(self, didTraverseEdge:decision)<br></p><p>delegate?.graphTraverser(self, didReachNode:currentNode)<br></p><p>}<br></p><p>}<br></p><p>}<br></p><p><br>protocol GraphTraversalDelegate&lt;NodeType, EdgeType&gt;<br></p><p>{<br></p><p>// implicit typealiasing<br></p><p>func graphTraverser(graphTraverser:GraphTraverser&lt;NodeType, EdgeType&gt;,<br>didTraverseEdge edge:EdgeType)<br></p><p>func graphTraverser(graphTraverser:GraphTraverser&lt;NodeType, EdgeType&gt;,<br>didReachNode node:NodeType)<br></p><p>func graphTraverser(graphTraverser:GraphTraverser&lt;NodeType, EdgeType&gt;,<br>chooseEdgeFromOptions options:[EdgeType]) -&gt; EdgeType?<br></p><p>}<br></p><p><br>struct TravellingSalesman : GraphTraversalDelegate&lt;City, Route&gt;<br></p><p>{<br></p><p>// implicit typealiasing; all NodeTypes are City, all EdgeType are Route<br></p><p>var citiesVisited : Set&lt;City&gt;<br></p><p>var distanceTravelled : Int<br></p><p><br>mutating func graphTraverser(graphTraverser:GraphTraverser&lt;City, Route&gt;,<br>didTraverseEdge edge:Route)<br></p><p>{<br></p><p>distanceTravelled += edge.distance<br></p><p>}<br></p><p>mutating func graphTraverser(graphTraverser:GraphTraverser&lt;City, Route&gt;,<br>didReachNode node:City)<br></p><p>{<br></p><p>citiesVisited.insert(node)<br></p><p>graphTraverser.move()<br></p><p>}<br></p><p><br>func graphTraverser(graphTraverser:GraphTraverser&lt;City, Route&gt;,<br>chooseEdgeFromOptions options:[Route]) -&gt; Route?<br></p><p>{<br></p><p>return Random(options.filter{ route in<br>!citiesVisited.contains(route.destination) })<br></p><p>}<br></p><p>}<br></p><p>Comments?<br></p><p>On Fri, Feb 26, 2016 at 11:22 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One of the big things that bugs me about working with protocols and<br>&gt; generics is that they have a fundamentally different style to working with<br>&gt; generics on structs and classes. While has some minor benefits on<br>&gt; differentiating them, I think that overall it results in inconsistency that<br>&gt; makes them harder to work with.<br>&gt;<br>&gt; I’d like to propose two fairly minor changes that allow protocols to be<br>&gt; defined using angle brackets for generics to make things much easier.<br>&gt;<br>&gt; First is allowing a protocol to be defined using angle brackets for its<br>&gt; generic type(s) like so:<br>&gt;<br>&gt; protocol FooType&lt;Element, Index:ForwardIndexType&gt; {<br>&gt; func getElement(atIndex:Index) -&gt; Element?<br>&gt; }<br>&gt;<br>&gt; In this example the protocol Foo has implicit type aliases for Element and<br>&gt; Index, which can be fulfilled like so:<br>&gt;<br>&gt; struct Foo&lt;Element&gt; : FooType&lt;Element, Int&gt; {<br>&gt; func getElement(atIndex:Index) -&gt; Element? { … }<br>&gt; }<br>&gt;<br>&gt; The other important case is defining type constraints with protocol<br>&gt; generics, currently we have to do stuff like this:<br>&gt;<br>&gt; func append&lt;S:SequenceType where S.Generator.Element ==<br>&gt; Element&gt;(contentsOf theSequence:S) { … }<br>&gt;<br>&gt; However, while definition with a where clause is powerful, in the majority<br>&gt; of cases it’s much more complex than it needs to be. So I’d like to propose<br>&gt; that we can have the following:<br>&gt;<br>&gt; protocol SequenceType&lt;Element&gt; { … }<br>&gt; func append(contentsOf theSequence:SequenceType&lt;Element&gt;) { … }<br>&gt;<br>&gt; Behind the scenes these may be unwrapped into type aliases and where<br>&gt; clauses like we have now, but for the developers this is much, much simpler<br>&gt; to work with, especially when most generic constraints are pretty simple.<br>&gt;<br>&gt; I’m not proposing the removal of where clauses as they can be really<br>&gt; useful in more unusual cases, so will still have utility there. I’m not so<br>&gt; sure about explicit type alias declaration like we have now though; using<br>&gt; the angle brackets to declare these seems just as capable to me unless<br>&gt; there are some cases I haven’t considered.<br>&gt;<br>&gt;<br>&gt; This seems like something that may have been discussed in the past, but<br>&gt; I’m not that great on specific terminology for features (I’m not as well<br>&gt; versed as others are on the correct names for language features) so I<br>&gt; haven’t found anything, but fully expect that I may have missed it somehow,<br>&gt; in which case a link would be appreciated.<br>&gt;<br>&gt; But if no proposal currently exists then I’d love to know, as I could try<br>&gt; to create a more formal proposal for this if necessary, as I know that I<br>&gt; for one would benefit greatly from simplified protocol generics, as they’re<br>&gt; currently one of my least favourite features to use syntactically, but one<br>&gt; I need to use a lot.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/a73c0d5d/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
