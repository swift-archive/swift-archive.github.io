<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Currently, one has to deal with explicit conversion between numerical types,<br>which in many cases is unnecessary and costing time to code <br>for things that are quite obvious,<br>and cluttering the source, making it less readable.<br></p><p>Especially dealing all the time with often unavoidable intermixing <br>of floating point types CGFloat, Float, and Double <br>is really very annoying. <br></p><p>Conversion beween floating point types is always harmless as <br>floating point types are essentially the same. <br>They differ only in precision.<br></p><p>Therefore, I would recommend allowing the following implicit type conversions:<br></p><p>-between all floating point types e.g. Double, Float, CGFloat  <br></p><p>-from any integer type to floating point types<br></p><p>-Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>because I know what I am doing: that the fraction is lost <br>and that assigning a too large float to an Integer would then cause <br>a run time error, which I can try/catch, of course. <br></p><p>-from unsigned integer to signed integer   <br>(nothing is lost here, but overflow should cause a run time error) <br></p><p>but no implicit conversion for:<br>- from integer to unsigned integer   (loosing sign here)<br>- from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br></p><p>Note however, that the compiler should issue warnings <br>when you do implicit conversions, but these warnings <br>are for most programmers of the “Yeah I know, don’t bug me.”<br>type, so one should be able to switch off these type of warnings.<br></p><p>Even a programmer with little experience simply knows <br>that bringing integers into the floating point domain <br>causes precision loss. <br>He/she also knows that assigning a Double to a smaller floating<br>point type also cause precision loss.  <br>the reverse is not true.<br></p><p><br>Very much interested in your opinion!<br></p><p>----<br>N.B. the above does not yet include <br>the fixed decimal numerical type as this type is not yet<br>available in Swift.  However, it should be  implemented <br>*as soon as possible*  because the fixed decimal type <br>is really needed for applications working with financial data!<br>E.g. <br>var depositPromille: Decimal(10,3)<br>typealias  Money = Decimal(20,2) <br>  <br>For more info on how this could be implemented<br>in Swift. please read a PL/1 manual, ( i grew up in this world)<br>like this one: <br></p><p>http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br></p><p>especially under sub-topic “Data elements” <br></p><p>(however, don’t take everything for granted, PL/1 is still a very young language :o) <br>Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br></p><p>Should I make a new swift-evolution topic for fixed decimal?<br></p><p>Kind Regards<br>TedvG<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/acde13d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>Sometimes, it&#39;s definitely desirable to have implicit conversion… but sometimes, it&#39;s not, so I think the current behavior is good.<br>I guess most of us have a zero tolerance policy for warnings, so those would be treated like the current errors.<br></p><p>It is possible to define operators that take numerics with different types as a workaround, and imho it wouldn&#39;t hurt to have a module that implements those operations.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Tino<br></p><p>&gt; On 30.03.2016, at 15:07, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Sometimes, it&#39;s definitely desirable to have implicit conversion… but sometimes, it&#39;s not, so I think the current behavior is good.<br>&gt; I guess most of us have a zero tolerance policy for warnings, so those would be treated like the current errors.<br>&gt; <br></p><p><br>e.g. this should never be a problem at run time:<br>       aFloat = anInteger            <br>neither is this: <br>       aCGFloat = aDouble   <br></p><p>A warning is just that: a warning. simply notify the programmer, just in case he/she does not fully understand the implications..<br></p><p>Eg. in PL/1 these are not warnings but Information type messages.<br></p><p>  <br>&gt; It is possible to define operators that take numerics with different types as a workaround, and imho it wouldn&#39;t hurt to have a module that implements those operations.<br>Imho, that would add to much noise to Swift <br></p><p>You could of course handle conversion errors with a try/catch.<br></p><p><br>There is also extensive info how implicit data type conversion could be handled here:<br></p><p>http://odl.sysworks.biz/disk$vaxdocsep953/decw$book/d3ndaa10.p77.decw$book<br>(it is relatively new, from 1992, conversion rules of ca. 1970, but don’t let that bother you) <br></p><p>I’ve worked with many other languages too, but most of my reference <br>material is from PL/1,the parent of all procedural programming languages. <br></p><p>However writing a proposal with <br>“Replace Swift by PL/1 and add OOP features”   <br>goes perhaps a bit to far :o) <br></p><p>TedvG<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March 30, 2016 at 09:00:00am</p></header><div class="content"><p>What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules and little guard rails you have to cling to lest you slip and hit the next pitfall.  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts and serve as yet another hindrance to novices trying to adopt the language. <br></p><p>So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int, and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br></p><p>Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism). Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br></p><p>~Robert Widmann<br></p><p>2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt; which in many cases is unnecessary and costing time to code <br>&gt; for things that are quite obvious,<br>&gt; and cluttering the source, making it less readable.<br>&gt; <br>&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt; of floating point types CGFloat, Float, and Double <br>&gt; is really very annoying. <br>&gt; <br>&gt; Conversion beween floating point types is always harmless as <br>&gt; floating point types are essentially the same. <br>&gt; They differ only in precision.<br>&gt; <br>&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt; <br>&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt; <br>&gt; -from any integer type to floating point types<br>&gt; <br>&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt; because I know what I am doing: that the fraction is lost <br>&gt; and that assigning a too large float to an Integer would then cause <br>&gt; a run time error, which I can try/catch, of course. <br>&gt; <br>&gt; -from unsigned integer to signed integer   <br>&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt; <br>&gt; but no implicit conversion for:<br>&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt; <br>&gt; Note however, that the compiler should issue warnings <br>&gt; when you do implicit conversions, but these warnings <br>&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt; type, so one should be able to switch off these type of warnings.<br>&gt; <br>&gt; Even a programmer with little experience simply knows <br>&gt; that bringing integers into the floating point domain <br>&gt; causes precision loss. <br>&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt; point type also cause precision loss.  <br>&gt; the reverse is not true.<br>&gt; <br>&gt; <br>&gt; Very much interested in your opinion!<br>&gt; <br>&gt; ----<br>&gt; N.B. the above does not yet include <br>&gt; the fixed decimal numerical type as this type is not yet<br>&gt; available in Swift.  However, it should be  implemented <br>&gt; *as soon as possible*  because the fixed decimal type <br>&gt; is really needed for applications working with financial data!<br>&gt; E.g. <br>&gt; var depositPromille: Decimal(10,3)<br>&gt; typealias  Money = Decimal(20,2) <br>&gt;   <br>&gt; For more info on how this could be implemented<br>&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt; like this one: <br>&gt; <br>&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm<br>&gt; <br>&gt; especially under sub-topic “Data elements” <br>&gt; <br>&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt; <br>&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt; <br>&gt; Kind Regards<br>&gt; TedvG<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/9f9bd628/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br></p><p>I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type, so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br></p><p>&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules and little guard rails you have to cling to lest you slip and hit the next pitfall.  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts and serve as yet another hindrance to novices trying to adopt the language. <br>&gt; <br>&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int, and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt; <br>&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism). Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt; for things that are quite obvious,<br>&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt; <br>&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt; is really very annoying. <br>&gt;&gt; <br>&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt; floating point types are essentially the same. <br>&gt;&gt; They differ only in precision.<br>&gt;&gt; <br>&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt; <br>&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt; <br>&gt;&gt; -from any integer type to floating point types<br>&gt;&gt; <br>&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt; <br>&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt; <br>&gt;&gt; but no implicit conversion for:<br>&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt; <br>&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt; <br>&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt; causes precision loss. <br>&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt; point type also cause precision loss.  <br>&gt;&gt; the reverse is not true.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Very much interested in your opinion!<br>&gt;&gt; <br>&gt;&gt; ----<br>&gt;&gt; N.B. the above does not yet include <br>&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt; E.g. <br>&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;   <br>&gt;&gt; For more info on how this could be implemented<br>&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt; like this one: <br>&gt;&gt; <br>&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br>&gt;&gt; <br>&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt; <br>&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt; <br>&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt; <br>&gt;&gt; Kind Regards<br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/4fa0ed35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you, Robert &amp; Haravikk<br>Please allow me to respond in-line hereunder, thanks.<br>Ted.<br>&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt; <br>&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>Why?  and   What cannot be guaranteed? <br></p><p>&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>awful, didn’t know that<br>&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>It simply would cause a float with less precision as an integer like <br>10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>but that is normal in a floating point domain; E.g.  also with: <br>     var v:Double  = 10000.0       //   Double to Double <br></p><p>v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>(rough estimation, depending on magnitude and the floating point type used) <br></p><p>&gt; <br>&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br></p><p>E.g. if I assign an Int to a Double, then I know very well what I am doing.<br> often occurring simple example here:<br>	for i in 0..&lt;10<br>        {<br>                dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>               foo(dTemperature)  <br>         }<br> <br>      Here I still have to write:     <br>                   dTemperature = dInterval * Double(i)       <br></p><p>      However, Swift will accept: <br>                   dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br></p><p>      <br></p><p>&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>Could you please explain these “unspoken rules” you mention more in detail?  <br></p><p>&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>I am counting on the average intelligence of programmers.<br></p><p>&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>In practice, the implications/effects/behavior of a programming language <br>cannot be fully predicted and understood, there are simply too many possibilities, <br>Functional Programming attempts to solve this, trying to make/do everything mathematically <br>correct but fails for the aforementioned reason.<br></p><p>&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>I don’t agree here. Even novices should have a good understanding <br>of the basic data types of a programming language,<br>Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>is very basic mathematics as learned in high school. <br>or your country’s equivalent education. <br></p><p><br>So aDouble = anInt  should -in the programmer’s mind- <br>appear as an explicit conversion, that is, he/she should realize the consequences. <br>The same applies also doing it explicitly like so:<br>       <br>     aDouble = Double(anInt)    <br>Same effect: even a fool can use this as well and not knowing the implications.<br></p><p><br>&gt;&gt; <br>&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt; <br>Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br></p><p>&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>Please spare me from this kind of contraptions.<br></p><p>  -=side note: =-<br>Thanks for bringing Idris to my attention. Investigating... <br>Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>I doubt if I will ever use it.  <br>I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>  -= end side note =- <br> <br></p><p><br>&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br></p><p>TedvG<br></p><p>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ----<br>&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/dee4fd92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March 30, 2016 at 02:00:00pm</p></header><div class="content"><p>I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules&quot;.<br></p><p>As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br></p><p>~Robert Widmann<br></p><p>2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; のメッセージ:<br></p><p>&gt; Thank you, Robert &amp; Haravikk<br>&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt; Ted.<br>&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt; <br>&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt; Why?  and   What cannot be guaranteed? <br>&gt; <br>&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt; awful, didn’t know that<br>&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt; It simply would cause a float with less precision as an integer like <br>&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt; <br>&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt; <br>&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;  often occurring simple example here:<br>&gt; 	for i in 0..&lt;10<br>&gt;         {<br>&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;                foo(dTemperature)  <br>&gt;          }<br>&gt;  <br>&gt;       Here I still have to write:     <br>&gt;                    dTemperature = dInterval * Double(i)       <br>&gt; <br>&gt;       However, Swift will accept: <br>&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt; <br>&gt;       <br>&gt; <br>&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt; <br>&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt; I am counting on the average intelligence of programmers.<br>&gt; <br>&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt; In practice, the implications/effects/behavior of a programming language <br>&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt; correct but fails for the aforementioned reason.<br>&gt; <br>&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt; I don’t agree here. Even novices should have a good understanding <br>&gt; of the basic data types of a programming language,<br>&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt; is very basic mathematics as learned in high school. <br>&gt; or your country’s equivalent education. <br>&gt; <br>&gt; <br>&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt; The same applies also doing it explicitly like so:<br>&gt;        <br>&gt;      aDouble = Double(anInt)    <br>&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt; <br>&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt; Please spare me from this kind of contraptions.<br>&gt; <br>&gt;   -=side note: =-<br>&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt; I doubt if I will ever use it.  <br>&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;   -= end side note =- <br>&gt;  <br>&gt; <br>&gt; <br>&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt; <br>&gt; TedvG<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/e1f4e084/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules”.<br>Although ISO compliance makes sense in a lot of cases, for programming languages, <br>these rules are extremely bureaucratic, restricting and always far behind fast developments in <br>IT.   Would you like to see Swift to be ISO compliant? <br>Then you could throw away perhaps more than half the language constructs<br>currently present in Swift?<br></p><p>@Chris:  <br></p><p>is there a desire/requirement to make Swift ISO compliant? <br>and thus therewith restricting Swift’s flexibility? If so, to what extent? <br></p><p>&gt; <br>&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>and I am telling the compiler implicitly: <br>aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>Again, in the cases I mentioned there is no data loss. (precision excluded) <br> <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Thank you, Robert &amp; Haravikk<br>&gt;&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt;&gt; Ted.<br>&gt;&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt;&gt; Why?  and   What cannot be guaranteed? <br>&gt;&gt; <br>&gt;&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt;&gt; awful, didn’t know that<br>&gt;&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt;&gt; It simply would cause a float with less precision as an integer like <br>&gt;&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt;&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt;&gt; <br>&gt;&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt;&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt;&gt; <br>&gt;&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;&gt;  often occurring simple example here:<br>&gt;&gt; 	for i in 0..&lt;10<br>&gt;&gt;         {<br>&gt;&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;&gt;                foo(dTemperature)  <br>&gt;&gt;          }<br>&gt;&gt;  <br>&gt;&gt;       Here I still have to write:     <br>&gt;&gt;                    dTemperature = dInterval * Double(i)       <br>&gt;&gt; <br>&gt;&gt;       However, Swift will accept: <br>&gt;&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt;&gt; <br>&gt;&gt;       <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt;&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt;&gt; I am counting on the average intelligence of programmers.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt;&gt; In practice, the implications/effects/behavior of a programming language <br>&gt;&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt;&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt;&gt; correct but fails for the aforementioned reason.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt;&gt; I don’t agree here. Even novices should have a good understanding <br>&gt;&gt; of the basic data types of a programming language,<br>&gt;&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt;&gt; is very basic mathematics as learned in high school. <br>&gt;&gt; or your country’s equivalent education. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt;&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt;&gt; The same applies also doing it explicitly like so:<br>&gt;&gt;        <br>&gt;&gt;      aDouble = Double(anInt)    <br>&gt;&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt;&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;&gt; Please spare me from this kind of contraptions.<br>&gt;&gt; <br>&gt;&gt;   -=side note: =-<br>&gt;&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt;&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt;&gt; I doubt if I will ever use it.  <br>&gt;&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt;&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;&gt;   -= end side note =- <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt;&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt;&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt;&gt; <br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/00a9b907/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 4:35 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules”.<br>&gt; Although ISO compliance makes sense in a lot of cases, for programming languages, <br>&gt; these rules are extremely bureaucratic, restricting and always far behind fast developments in <br>&gt; IT.   Would you like to see Swift to be ISO compliant? <br>&gt; Then you could throw away perhaps more than half the language constructs<br>&gt; currently present in Swift?<br>&gt; <br>&gt; @Chris:  <br>&gt; <br>&gt; is there a desire/requirement to make Swift ISO compliant? <br>&gt; and thus therewith restricting Swift’s flexibility? If so, to what extent? <br>&gt; <br></p><p>This is orthogonal to the discussion at hand.<br></p><p>&gt;&gt; <br>&gt;&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>&gt; With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>&gt; and I am telling the compiler implicitly: <br>&gt; aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>&gt; Again, in the cases I mentioned there is no data loss. (precision excluded) <br></p><p>An example of “data loss”, then (adapted from the wonderful example given by Felix Cloutier here &lt;http://stackoverflow.com/a/2658736/945847&gt;).  Be judicious running this, it will spin for quite a while if you don’t kill it first.<br></p><p>import Darwin<br></p><p>for i in Int(INT_MAX).stride(to: 0, by: -1) {<br>	let value : Float = Float(i)<br>	let ivalue : Int = Int(value)<br>	if (i != ivalue) {<br>		print(&quot;Integer \(i) is represented as \(ivalue) in a float\n&quot;)<br>	}<br>}<br></p><p><br>You may still argue, however, that loss of precision is not as egregious as full-on truncation, but it is still data loss all the same.  If it is too technical and bureaucratic to insert casts to make your intent clear in either language (rather than what I assume is just silencing -Wconversion), I’ll take bureaucracy and safety over convenience please.<br></p><p>~Robert Widmann<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Thank you, Robert &amp; Haravikk<br>&gt;&gt;&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt;&gt;&gt; Ted.<br>&gt;&gt;&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt;&gt;&gt; Why?  and   What cannot be guaranteed? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt;&gt;&gt; awful, didn’t know that<br>&gt;&gt;&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt;&gt;&gt; It simply would cause a float with less precision as an integer like <br>&gt;&gt;&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt;&gt;&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;&gt;&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt;&gt;&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;&gt;&gt;  often occurring simple example here:<br>&gt;&gt;&gt; 	for i in 0..&lt;10<br>&gt;&gt;&gt;         {<br>&gt;&gt;&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;&gt;&gt;                foo(dTemperature)  <br>&gt;&gt;&gt;          }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;       Here I still have to write:     <br>&gt;&gt;&gt;                    dTemperature = dInterval * Double(i)       <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       However, Swift will accept: <br>&gt;&gt;&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt;&gt;&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt;&gt;&gt; I am counting on the average intelligence of programmers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt;&gt;&gt; In practice, the implications/effects/behavior of a programming language <br>&gt;&gt;&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt;&gt;&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt;&gt;&gt; correct but fails for the aforementioned reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt;&gt;&gt; I don’t agree here. Even novices should have a good understanding <br>&gt;&gt;&gt; of the basic data types of a programming language,<br>&gt;&gt;&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt;&gt;&gt; is very basic mathematics as learned in high school. <br>&gt;&gt;&gt; or your country’s equivalent education. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt;&gt;&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt;&gt;&gt; The same applies also doing it explicitly like so:<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt;      aDouble = Double(anInt)    <br>&gt;&gt;&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt;&gt;&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;&gt;&gt; Please spare me from this kind of contraptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   -=side note: =-<br>&gt;&gt;&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt;&gt;&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt;&gt;&gt; I doubt if I will ever use it.  <br>&gt;&gt;&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt;&gt;&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;&gt;&gt;   -= end side note =- <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt;&gt;&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt;&gt;&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/c4cc0027/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 11:00:00pm</p></header><div class="content"><p>Ok, Dave, Developer, Steven, Howard<br>Very interesting, thank you for the in depth responses!<br>I see the points, I am still learning everyday.<br>I drop my case, as they say. <br>Kind Regards.<br>TedvG<br></p><p><br>&gt; On 30.03.2016, at 23:38, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 4:35 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules”.<br>&gt;&gt; Although ISO compliance makes sense in a lot of cases, for programming languages, <br>&gt;&gt; these rules are extremely bureaucratic, restricting and always far behind fast developments in <br>&gt;&gt; IT.   Would you like to see Swift to be ISO compliant? <br>&gt;&gt; Then you could throw away perhaps more than half the language constructs<br>&gt;&gt; currently present in Swift?<br>&gt;&gt; <br>&gt;&gt; @Chris:  <br>&gt;&gt; <br>&gt;&gt; is there a desire/requirement to make Swift ISO compliant? <br>&gt;&gt; and thus therewith restricting Swift’s flexibility? If so, to what extent? <br>&gt;&gt; <br>&gt; <br>&gt; This is orthogonal to the discussion at hand.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>&gt;&gt; With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>&gt;&gt; and I am telling the compiler implicitly: <br>&gt;&gt; aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>&gt;&gt; Again, in the cases I mentioned there is no data loss. (precision excluded) <br>&gt; <br>&gt; An example of “data loss”, then (adapted from the wonderful example given by Felix Cloutier here &lt;http://stackoverflow.com/a/2658736/945847&gt;).  Be judicious running this, it will spin for quite a while if you don’t kill it first.<br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; for i in Int(INT_MAX).stride(to: 0, by: -1) {<br>&gt; 	let value : Float = Float(i)<br>&gt; 	let ivalue : Int = Int(value)<br>&gt; 	if (i != ivalue) {<br>&gt; 		print(&quot;Integer \(i) is represented as \(ivalue) in a float\n&quot;)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; You may still argue, however, that loss of precision is not as egregious as full-on truncation, but it is still data loss all the same.  If it is too technical and bureaucratic to insert casts to make your intent clear in either language (rather than what I assume is just silencing -Wconversion), I’ll take bureaucracy and safety over convenience please.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you, Robert &amp; Haravikk<br>&gt;&gt;&gt;&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt;&gt;&gt;&gt; Ted.<br>&gt;&gt;&gt;&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt;&gt;&gt;&gt; Why?  and   What cannot be guaranteed? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt;&gt;&gt;&gt; awful, didn’t know that<br>&gt;&gt;&gt;&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt;&gt;&gt;&gt; It simply would cause a float with less precision as an integer like <br>&gt;&gt;&gt;&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt;&gt;&gt;&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;&gt;&gt;&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt;&gt;&gt;&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;&gt;&gt;&gt;  often occurring simple example here:<br>&gt;&gt;&gt;&gt; 	for i in 0..&lt;10<br>&gt;&gt;&gt;&gt;         {<br>&gt;&gt;&gt;&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;&gt;&gt;&gt;                foo(dTemperature)  <br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;       Here I still have to write:     <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * Double(i)       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       However, Swift will accept: <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt;&gt;&gt;&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt;&gt;&gt;&gt; I am counting on the average intelligence of programmers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt;&gt;&gt;&gt; In practice, the implications/effects/behavior of a programming language <br>&gt;&gt;&gt;&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt;&gt;&gt;&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt;&gt;&gt;&gt; correct but fails for the aforementioned reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt;&gt;&gt;&gt; I don’t agree here. Even novices should have a good understanding <br>&gt;&gt;&gt;&gt; of the basic data types of a programming language,<br>&gt;&gt;&gt;&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt;&gt;&gt;&gt; is very basic mathematics as learned in high school. <br>&gt;&gt;&gt;&gt; or your country’s equivalent education. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt;&gt;&gt;&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt;&gt;&gt;&gt; The same applies also doing it explicitly like so:<br>&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt;      aDouble = Double(anInt)    <br>&gt;&gt;&gt;&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt;&gt;&gt;&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt;&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;&gt;&gt;&gt; Please spare me from this kind of contraptions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   -=side note: =-<br>&gt;&gt;&gt;&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt;&gt;&gt;&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt;&gt;&gt;&gt; I doubt if I will ever use it.  <br>&gt;&gt;&gt;&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt;&gt;&gt;&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;&gt;&gt;&gt;   -= end side note =- <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt;&gt;&gt;&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt;&gt;&gt;&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm &lt;http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/ea43ced3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 07:00:00am</p></header><div class="content"><p>+1<br></p><p>I am strictly against implicit conversions where data loss may happen.<br>I am even against implicit conversions which are just expensive.<br></p><p>With regards to the argument of counting on the developers intelligence I think that is a task for compilers just like type checking. <br>  <br>-Thorsten <br></p><p><br>&gt; Am 30.03.2016 um 23:38 schrieb Developer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 4:35 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules”.<br>&gt;&gt; Although ISO compliance makes sense in a lot of cases, for programming languages, <br>&gt;&gt; these rules are extremely bureaucratic, restricting and always far behind fast developments in <br>&gt;&gt; IT.   Would you like to see Swift to be ISO compliant? <br>&gt;&gt; Then you could throw away perhaps more than half the language constructs<br>&gt;&gt; currently present in Swift?<br>&gt;&gt; <br>&gt;&gt; @Chris:  <br>&gt;&gt; <br>&gt;&gt; is there a desire/requirement to make Swift ISO compliant? <br>&gt;&gt; and thus therewith restricting Swift’s flexibility? If so, to what extent? <br>&gt; <br>&gt; This is orthogonal to the discussion at hand.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>&gt;&gt; With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>&gt;&gt; and I am telling the compiler implicitly: <br>&gt;&gt; aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>&gt;&gt; Again, in the cases I mentioned there is no data loss. (precision excluded) <br>&gt; <br>&gt; An example of “data loss”, then (adapted from the wonderful example given by Felix Cloutier here).  Be judicious running this, it will spin for quite a while if you don’t kill it first.<br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; for i in Int(INT_MAX).stride(to: 0, by: -1) {<br>&gt; 	let value : Float = Float(i)<br>&gt; 	let ivalue : Int = Int(value)<br>&gt; 	if (i != ivalue) {<br>&gt; 		print(&quot;Integer \(i) is represented as \(ivalue) in a float\n&quot;)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; You may still argue, however, that loss of precision is not as egregious as full-on truncation, but it is still data loss all the same.  If it is too technical and bureaucratic to insert casts to make your intent clear in either language (rather than what I assume is just silencing -Wconversion), I’ll take bureaucracy and safety over convenience please.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you, Robert &amp; Haravikk<br>&gt;&gt;&gt;&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt;&gt;&gt;&gt; Ted.<br>&gt;&gt;&gt;&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt;&gt;&gt;&gt; Why?  and   What cannot be guaranteed? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt;&gt;&gt;&gt; awful, didn’t know that<br>&gt;&gt;&gt;&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt;&gt;&gt;&gt; It simply would cause a float with less precision as an integer like <br>&gt;&gt;&gt;&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt;&gt;&gt;&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;&gt;&gt;&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt;&gt;&gt;&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;&gt;&gt;&gt;  often occurring simple example here:<br>&gt;&gt;&gt;&gt; 	for i in 0..&lt;10<br>&gt;&gt;&gt;&gt;         {<br>&gt;&gt;&gt;&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;&gt;&gt;&gt;                foo(dTemperature)  <br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;       Here I still have to write:     <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * Double(i)       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       However, Swift will accept: <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt;&gt;&gt;&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt;&gt;&gt;&gt; I am counting on the average intelligence of programmers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt;&gt;&gt;&gt; In practice, the implications/effects/behavior of a programming language <br>&gt;&gt;&gt;&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt;&gt;&gt;&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt;&gt;&gt;&gt; correct but fails for the aforementioned reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt;&gt;&gt;&gt; I don’t agree here. Even novices should have a good understanding <br>&gt;&gt;&gt;&gt; of the basic data types of a programming language,<br>&gt;&gt;&gt;&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt;&gt;&gt;&gt; is very basic mathematics as learned in high school. <br>&gt;&gt;&gt;&gt; or your country’s equivalent education. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt;&gt;&gt;&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt;&gt;&gt;&gt; The same applies also doing it explicitly like so:<br>&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt;      aDouble = Double(anInt)    <br>&gt;&gt;&gt;&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt;&gt;&gt;&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt;&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt;&gt;&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;&gt;&gt;&gt; Please spare me from this kind of contraptions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   -=side note: =-<br>&gt;&gt;&gt;&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt;&gt;&gt;&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt;&gt;&gt;&gt; I doubt if I will ever use it.  <br>&gt;&gt;&gt;&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt;&gt;&gt;&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;&gt;&gt;&gt;   -= end side note =- <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt;&gt;&gt;&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt;&gt;&gt;&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/c51db92e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>Implicit conversion complicates method overloading, e. g. if you have both<br>m(Int) and m(Double) which does m(0) call? Sure there are rules in other<br>languages that deal with this but they are complicated. So my call is that<br>it is not worth the trouble.<br></p><p>On Thursday, 31 March 2016, Ted F.A. van Gaalen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;devteam.codafi at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I believe section 6.3 of the ISO/C99 specification describes its integer<br>&gt; promotion rules and Appendix J describes undefined behavior as a<br>&gt; consequence of integer and floating point coercion.  I refer to these when<br>&gt; I speak of &quot;rules”.<br>&gt;<br>&gt; Although ISO compliance makes sense in a lot of cases, for programming<br>&gt; languages,<br>&gt; these rules are extremely bureaucratic, restricting and always far behind<br>&gt; fast developments in<br>&gt; IT.   Would you like to see Swift to be ISO compliant?<br>&gt; Then you could throw away perhaps more than half the language constructs<br>&gt; currently present in Swift?<br>&gt;<br>&gt; @Chris:<br>&gt;<br>&gt; is there a desire/requirement to make Swift ISO compliant?<br>&gt; and thus therewith restricting Swift’s flexibility? If so, to what extent?<br>&gt;<br>&gt;<br>&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of<br>&gt; coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what<br>&gt; you&#39;re doing&quot;, the preference so far has been to tell the compiler that and<br>&gt; use the constructors provided in the Swift Standard Library to perform<br>&gt; explicit truncation.  Even in C, if you can be more specific with a cast in<br>&gt; cases where you intend data loss, you probably should be.<br>&gt;<br>&gt; With all due respect, Robert, Imho, I find this all too theoretical and<br>&gt; bureaucratic and tons of unnecessary overhead.<br>&gt; and I am telling the compiler implicitly:<br>&gt; aFloat = anInt  // The compiler will use a builtin function to do the<br>&gt; conversion. what can be wrong with that?<br>&gt; Again, in the cases I mentioned there is no data loss. (precision<br>&gt; excluded)<br>&gt;<br>&gt;<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;tedvgiosdev at gmail.com&#39;);&gt;&gt; のメッセージ:<br>&gt;<br>&gt; Thank you, Robert &amp; Haravikk<br>&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt; Ted.<br>&gt;<br>&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at haravikk.me&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I’m in favour of implicit conversion for integers where no data can be<br>&gt; lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar<br>&gt; thread a little while ago but can’t find it; there’s something being done<br>&gt; with numbers so this may be partly in the works.<br>&gt;<br>&gt; I definitely think that implicit conversion for floating point should be<br>&gt; avoided, as it can’t be guaranteed<br>&gt;<br>&gt; Why?  and   What cannot be guaranteed?<br>&gt;<br>&gt; except in certain edge cases; for example, Javascript actually technically<br>&gt; uses a double for all of its numeric types, effectively giving it a 52-bit<br>&gt; (iirc) integer type,<br>&gt;<br>&gt; awful, didn’t know that<br>&gt;<br>&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float<br>&gt; might be as well, but I’m not certain if it’s a good idea or not, as it’s<br>&gt; not quite the same as just extending the value.<br>&gt;<br>&gt; It simply would cause a float with less precision as an integer like<br>&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course)<br>&gt; but that is normal in a floating point domain; E.g.  also with:<br>&gt;      var v:Double  = 10000.0       //   Double to Double<br>&gt;<br>&gt; v would have the same imprecision… and could be anywhere between<br>&gt; 9999.9998…10000.00001<br>&gt; (rough estimation, depending on magnitude and the floating point type<br>&gt; used)<br>&gt;<br>&gt;<br>&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; What you describe, all those cases where one fixes losing precision by<br>&gt; simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing<br>&gt; in C-like promotion rules into any language.<br>&gt;<br>&gt;<br>&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;  often occurring simple example here:<br>&gt; for i in 0..&lt;10<br>&gt;         {<br>&gt;                 dTemperature = dInterval * i         / /   Double = Double<br>&gt; * Int  (not possible yet in Swift)<br>&gt;                foo(dTemperature)<br>&gt;          }<br>&gt;<br>&gt;       Here I still have to write:<br>&gt;                    dTemperature = dInterval * Double(i)<br>&gt;<br>&gt;       However, Swift will accept:<br>&gt;                    dTemperature = dInterval * 3        // 3 inferred to<br>&gt; Double. could be regarded as an implicit conversion?<br>&gt;<br>&gt;<br>&gt;<br>&gt;  Once you add implicit type coercions, even just between integer or<br>&gt; floating point types, your language gains a hundred unspoken rules<br>&gt;<br>&gt; Could you please explain these “unspoken rules” you mention more in<br>&gt; detail?<br>&gt;<br>&gt; and little guard rails you have to cling to lest you slip and hit the next<br>&gt; pitfall.<br>&gt;<br>&gt; I am counting on the average intelligence of programmers.<br>&gt;<br>&gt;  Though you may be dismissive of information loss, it is a serious issue<br>&gt; in coercions, and one with implications that are never completely grokked<br>&gt; by experts<br>&gt;<br>&gt; In practice, the implications/effects/behavior of a programming language<br>&gt; cannot be fully predicted and understood, there are simply too many<br>&gt; possibilities,<br>&gt; Functional Programming attempts to solve this, trying to make/do<br>&gt; everything mathematically<br>&gt; correct but fails for the aforementioned reason.<br>&gt;<br>&gt; and serve as yet another hindrance to novices trying to adopt the<br>&gt; language.<br>&gt;<br>&gt; I don’t agree here. Even novices should have a good understanding<br>&gt; of the basic data types of a programming language,<br>&gt; Also note that  concepts of integer, natural, rational, irrational numbers<br>&gt; etc.<br>&gt; is very basic mathematics as learned in high school.<br>&gt; or your country’s equivalent education.<br>&gt;<br>&gt;<br>&gt; So aDouble = anInt  should -in the programmer’s mind-<br>&gt; appear as an explicit conversion, that is, he/she should realize the<br>&gt; consequences.<br>&gt; The same applies also doing it explicitly like so:<br>&gt;<br>&gt;      aDouble = Double(anInt)<br>&gt; Same effect: even a fool can use this as well and not knowing the<br>&gt; implications.<br>&gt;<br>&gt;<br>&gt;<br>&gt; So, I don&#39;t think coercion under this scheme is the complete<br>&gt; end-all-be-all solution to this problem, [though it may certainly *feel*<br>&gt; right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a<br>&gt; lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float,<br>&gt; Float -&gt; Int,<br>&gt;<br>&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int.<br>&gt;<br>&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t<br>&gt; want enshrined in the language&#39;s type system.<br>&gt;<br>&gt; Could you give me an example where Double -&gt; Float is problematic (apart<br>&gt; from loosing precision) ?<br>&gt;<br>&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a<br>&gt; special kind of protocol declaring safe implicit convertibility (see:<br>&gt; Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;<br>&gt; Please spare me from this kind of contraptions.<br>&gt;<br>&gt;   -=side note: =-<br>&gt; Thanks for bringing Idris to my attention. Investigating...<br>&gt; Idris is a FP language. I am not against it, but to me, FP is almost<br>&gt; unreadable.<br>&gt; I doubt if I will ever use it.<br>&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt; For now, the only reason I use protocols in Swift are to accommodate<br>&gt;  delegating/callbacks.<br>&gt;   -= end side note =-<br>&gt;<br>&gt;<br>&gt;<br>&gt; Or perhaps a good first step may be to not deal with information loss at<br>&gt; all, and only keep the parts of this proposal that are always defined<br>&gt; behavior.<br>&gt;<br>&gt; To me, there is no unintended information loss, because I know what I am<br>&gt; doing regarding implicit conversion.<br>&gt; Then again, in all the cases for which I suggested implicit data type<br>&gt; conversion, there is no data loss (apart from precision)<br>&gt;<br>&gt; TedvG<br>&gt;<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; のメッセージ:<br>&gt;<br>&gt; Currently, one has to deal with explicit conversion between numerical<br>&gt; types,<br>&gt; which in many cases is unnecessary and costing time to code<br>&gt; for things that are quite obvious,<br>&gt; and cluttering the source, making it less readable.<br>&gt;<br>&gt; Especially dealing all the time with often unavoidable intermixing<br>&gt; of floating point types CGFloat, Float, and Double<br>&gt; is really very annoying.<br>&gt;<br>&gt; Conversion beween floating point types is always harmless as<br>&gt; floating point types are essentially the same.<br>&gt; They differ only in precision.<br>&gt;<br>&gt; Therefore, I would recommend allowing the following implicit type<br>&gt; conversions:<br>&gt;<br>&gt; -between all floating point types e.g. Double, Float, CGFloat<br>&gt;<br>&gt; -from any integer type to floating point types<br>&gt;<br>&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed)<br>&gt; integer<br>&gt; because I know what I am doing: that the fraction is lost<br>&gt; and that assigning a too large float to an Integer would then cause<br>&gt; a run time error, which I can try/catch, of course.<br>&gt;<br>&gt; -from unsigned integer to signed integer<br>&gt; (nothing is lost here, but overflow should cause a run time error)<br>&gt;<br>&gt; but no implicit conversion for:<br>&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64<br>&gt; (truncation)<br>&gt;<br>&gt; Note however, that the compiler should issue warnings<br>&gt; when you do implicit conversions, but these warnings<br>&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt; type, so one should be able to switch off these type of warnings.<br>&gt;<br>&gt; Even a programmer with little experience simply knows<br>&gt; that bringing integers into the floating point domain<br>&gt; causes precision loss.<br>&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt; point type also cause precision loss.<br>&gt; the reverse is not true.<br>&gt;<br>&gt;<br>&gt; Very much interested in your opinion!<br>&gt;<br>&gt; ----<br>&gt; N.B. the above does not yet include<br>&gt; the fixed decimal numerical type as this type is not yet<br>&gt; available in Swift.  However, it should be  implemented<br>&gt; *as soon as possible*  because the fixed decimal type<br>&gt; is really needed for applications working with financial data!<br>&gt; E.g.<br>&gt; var depositPromille: Decimal(10,3)<br>&gt; typealias  Money = Decimal(20,2)<br>&gt;<br>&gt; For more info on how this could be implemented<br>&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt; like this one:<br>&gt;<br>&gt;<br>&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm<br>&gt;<br>&gt; especially under sub-topic “Data elements”<br>&gt;<br>&gt; (however, don’t take everything for granted, PL/1 is still a very young<br>&gt; language :o)<br>&gt; Unfortunately OOP never made it into PL/1 because with it, it would be<br>&gt; nearly perfect.)<br>&gt;<br>&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;<br>&gt; Kind Regards<br>&gt; TedvG<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/15830844/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 07:00:00am</p></header><div class="content"><p>Good point!<br></p><p>-Thorsten <br></p><p>&gt; Am 30.03.2016 um 23:40 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Implicit conversion complicates method overloading, e. g. if you have both m(Int) and m(Double) which does m(0) call? Sure there are rules in other languages that deal with this but they are complicated. So my call is that it is not worth the trouble. <br>&gt; <br>&gt;&gt; On Thursday, 31 March 2016, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 30.03.2016, at 20:29, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe section 6.3 of the ISO/C99 specification describes its integer promotion rules and Appendix J describes undefined behavior as a consequence of integer and floating point coercion.  I refer to these when I speak of &quot;rules”.<br>&gt;&gt; Although ISO compliance makes sense in a lot of cases, for programming languages, <br>&gt;&gt; these rules are extremely bureaucratic, restricting and always far behind fast developments in <br>&gt;&gt; IT.   Would you like to see Swift to be ISO compliant? <br>&gt;&gt; Then you could throw away perhaps more than half the language constructs<br>&gt;&gt; currently present in Swift?<br>&gt;&gt; <br>&gt;&gt; @Chris:  <br>&gt;&gt; <br>&gt;&gt; is there a desire/requirement to make Swift ISO compliant? <br>&gt;&gt; and thus therewith restricting Swift’s flexibility? If so, to what extent? <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>&gt;&gt; With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>&gt;&gt; and I am telling the compiler implicitly: <br>&gt;&gt; aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>&gt;&gt; Again, in the cases I mentioned there is no data loss. (precision excluded) <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/03/30 13:57、Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you, Robert &amp; Haravikk<br>&gt;&gt;&gt;&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt;&gt;&gt;&gt; Ted.<br>&gt;&gt;&gt;&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt;&gt;&gt;&gt; Why?  and   What cannot be guaranteed? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; except in certain edge cases; for example, Javascript actually technically uses a double for all of its numeric types, effectively giving it a 52-bit (iirc) integer type,<br>&gt;&gt;&gt;&gt; awful, didn’t know that<br>&gt;&gt;&gt;&gt;&gt; so in theory conversion of Int32 to Double is fine, and Int16 to Float might be as well, but I’m not certain if it’s a good idea or not, as it’s not quite the same as just extending the value.<br>&gt;&gt;&gt;&gt; It simply would cause a float with less precision as an integer like <br>&gt;&gt;&gt;&gt; 10000 -becomes e.g - 9999.999999, (depending on magnitude, of course) <br>&gt;&gt;&gt;&gt; but that is normal in a floating point domain; E.g.  also with: <br>&gt;&gt;&gt;&gt;      var v:Double  = 10000.0       //   Double to Double <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; v would have the same imprecision… and could be anywhere between 9999.9998…10000.00001  <br>&gt;&gt;&gt;&gt; (rough estimation, depending on magnitude and the floating point type used) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 30 Mar 2016, at 14:57, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What you describe, all those cases where one fixes losing precision by simply &quot;ignoring it&quot;, that&#39;s part of why I&#39;m hesitant about simply throwing in C-like promotion rules into any language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.g. if I assign an Int to a Double, then I know very well what I am doing.<br>&gt;&gt;&gt;&gt;  often occurring simple example here:<br>&gt;&gt;&gt;&gt; 	for i in 0..&lt;10<br>&gt;&gt;&gt;&gt;         {<br>&gt;&gt;&gt;&gt;                 dTemperature = dInterval * i         / /   Double = Double * Int  (not possible yet in Swift)<br>&gt;&gt;&gt;&gt;                foo(dTemperature)  <br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;       Here I still have to write:     <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * Double(i)       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       However, Swift will accept: <br>&gt;&gt;&gt;&gt;                    dTemperature = dInterval * 3        // 3 inferred to Double. could be regarded as an implicit conversion? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Once you add implicit type coercions, even just between integer or floating point types, your language gains a hundred unspoken rules<br>&gt;&gt;&gt;&gt; Could you please explain these “unspoken rules” you mention more in detail?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and little guard rails you have to cling to lest you slip and hit the next pitfall.<br>&gt;&gt;&gt;&gt; I am counting on the average intelligence of programmers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Though you may be dismissive of information loss, it is a serious issue in coercions, and one with implications that are never completely grokked by experts<br>&gt;&gt;&gt;&gt; In practice, the implications/effects/behavior of a programming language <br>&gt;&gt;&gt;&gt; cannot be fully predicted and understood, there are simply too many possibilities, <br>&gt;&gt;&gt;&gt; Functional Programming attempts to solve this, trying to make/do everything mathematically <br>&gt;&gt;&gt;&gt; correct but fails for the aforementioned reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and serve as yet another hindrance to novices trying to adopt the language. <br>&gt;&gt;&gt;&gt; I don’t agree here. Even novices should have a good understanding <br>&gt;&gt;&gt;&gt; of the basic data types of a programming language,<br>&gt;&gt;&gt;&gt; Also note that  concepts of integer, natural, rational, irrational numbers etc.<br>&gt;&gt;&gt;&gt; is very basic mathematics as learned in high school. <br>&gt;&gt;&gt;&gt; or your country’s equivalent education. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So aDouble = anInt  should -in the programmer’s mind- <br>&gt;&gt;&gt;&gt; appear as an explicit conversion, that is, he/she should realize the consequences. <br>&gt;&gt;&gt;&gt; The same applies also doing it explicitly like so:<br>&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt;      aDouble = Double(anInt)    <br>&gt;&gt;&gt;&gt; Same effect: even a fool can use this as well and not knowing the implications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, I don&#39;t think coercion under this scheme is the complete end-all-be-all solution to this problem, [though it may certainly feel right].  Sure, it is always defined behavior to &quot;downcast&quot; a value of a lower bitwidth to one of a higher bitwidth, but to dismiss Int -&gt; Float, Float -&gt; Int,<br>&gt;&gt;&gt;&gt; I wrote that I don’t want implicit conversion for Float -&gt; Int. <br>&gt;&gt;&gt;&gt;&gt;&gt; and Double -&gt; Float, etc. coercions as mere trifles is an attitude I don&#39;t want enshrined in the language&#39;s type system.<br>&gt;&gt;&gt;&gt; Could you give me an example where Double -&gt; Float is problematic (apart from loosing precision) ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps there is a middle ground.  Say, one could declare conformance to a special kind of protocol declaring safe implicit convertibility (see: Idris&#39; solution of having an `implicit` conversion mechanism).<br>&gt;&gt;&gt;&gt; Please spare me from this kind of contraptions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   -=side note: =-<br>&gt;&gt;&gt;&gt; Thanks for bringing Idris to my attention. Investigating... <br>&gt;&gt;&gt;&gt; Idris is a FP language. I am not against it, but to me, FP is almost unreadable.<br>&gt;&gt;&gt;&gt; I doubt if I will ever use it.  <br>&gt;&gt;&gt;&gt; I use strictly OOD/OOP. It’s natural. Like in Smalltalk. Proven. Solid.<br>&gt;&gt;&gt;&gt; For now, the only reason I use protocols in Swift are to accommodate  delegating/callbacks.<br>&gt;&gt;&gt;&gt;   -= end side note =- <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps a good first step may be to not deal with information loss at all, and only keep the parts of this proposal that are always defined behavior.<br>&gt;&gt;&gt;&gt; To me, there is no unintended information loss, because I know what I am doing regarding implicit conversion.<br>&gt;&gt;&gt;&gt; Then again, in all the cases for which I suggested implicit data type conversion, there is no data loss (apart from precision)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/03/30 8:01、Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for things that are quite obvious,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and cluttering the source, making it less readable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Especially dealing all the time with often unavoidable intermixing <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of floating point types CGFloat, Float, and Double <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really very annoying. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversion beween floating point types is always harmless as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; floating point types are essentially the same. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; They differ only in precision.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I would recommend allowing the following implicit type conversions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -between all floating point types e.g. Double, Float, CGFloat  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from any integer type to floating point types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Also, personally, I wouldn’t mind assigning from a float to a (signed) integer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because I know what I am doing: that the fraction is lost <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and that assigning a too large float to an Integer would then cause <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a run time error, which I can try/catch, of course. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -from unsigned integer to signed integer   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (nothing is lost here, but overflow should cause a run time error) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but no implicit conversion for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from integer to unsigned integer   (loosing sign here)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - from a larger integer type to a smaller one e.g.   Int32 &lt;- Int64   (truncation)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note however, that the compiler should issue warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you do implicit conversions, but these warnings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are for most programmers of the “Yeah I know, don’t bug me.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type, so one should be able to switch off these type of warnings.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even a programmer with little experience simply knows <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that bringing integers into the floating point domain <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; causes precision loss. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; He/she also knows that assigning a Double to a smaller floating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point type also cause precision loss.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the reverse is not true.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much interested in your opinion!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; N.B. the above does not yet include <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fixed decimal numerical type as this type is not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; available in Swift.  However, it should be  implemented <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *as soon as possible*  because the fixed decimal type <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is really needed for applications working with financial data!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var depositPromille: Decimal(10,3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias  Money = Decimal(20,2) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For more info on how this could be implemented<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in Swift. please read a PL/1 manual, ( i grew up in this world)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this one: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://www.ibm.com/support/knowledgecenter/#!/SSY2V3_4.3.0/com.ibm.entpli.doc_4.3/lr/preface_plugin.htm<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially under sub-topic “Data elements” <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (however, don’t take everything for granted, PL/1 is still a very young language :o) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately OOP never made it into PL/1 because with it, it would be nearly perfect.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should I make a new swift-evolution topic for fixed decimal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/64aa567e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>March 30, 2016 at 02:00:00pm</p></header><div class="content"><p>On Mar 30, 2016, at 1:35 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; As long as data loss is an &quot;unintended&quot; effect of a certain class of coercions, I don&#39;t believe it deserves to be implicit.  If you &quot;know what you&#39;re doing&quot;, the preference so far has been to tell the compiler that and use the constructors provided in the Swift Standard Library to perform explicit truncation.  Even in C, if you can be more specific with a cast in cases where you intend data loss, you probably should be.<br>&gt; <br>&gt; With all due respect, Robert, Imho, I find this all too theoretical and bureaucratic and tons of unnecessary overhead. <br>&gt; and I am telling the compiler implicitly: <br>&gt; aFloat = anInt  // The compiler will use a builtin function to do the conversion. what can be wrong with that? <br>&gt; Again, in the cases I mentioned there is no data loss. (precision excluded) <br></p><p>Rounding in a conversion is data loss, full stop.  It will be extremely difficult (impossible, really) to convince folks that explicit conversion should not be required when the value might be changed.<br></p><p>If you restrict to cases where it is exact, implicit conversion is much more palatable, but you’re then left with a system in which Int32 can implicitly convert to Double, but not to Float.  The added confusion of such a system is significant, but I can at least imagine that one could make a case for it.<br></p><p>What you’re much more likely to get traction with is reducing the need for conversions at all, implicit or explicit.  The Integers prototype that Dave and Max have been working on (test/Prototypes/Integers.swift.gyb) starts to move in this direction by allowing heterogeneous integer types in shifts and comparisons.  This is a great approach because it eliminates the need for conversion entirely, rather than making them implicit.  Shifts and comparisons cover a large portion of the cases where the need for conversions is most painful, and this doesn’t introduce risk because the result type and value are clearly and unambiguously defined by the values involved (and the lhs type for shifts).<br></p><p>– Steve<br></p><p>PS: personally as someone who has a firm grasp of low-level numerics, I find the need for explicit conversions annoying, but it’s only a very minor annoyance, and I appreciate the safety that it provides for users who wisely don’t want to waste mental capacity on the precise details of numeric ranges and conversions.  On balance I think requiring them to be explicit is a significant win.<br></p><p>I would also be remiss if I didn’t observe that excessive conversions, implicit or explicit, are a significant performance hazard.  Even in the best-case scenario, they often require a sign- or zero-extension instruction.  They may also involve testing for out-of-range values and trapping, or (as with unsigned integer to floating-point on x86) a sequence of several instructions.  To some extent, this is a case of “if it hurts, don’t do it”.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 12:57 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you, Robert &amp; Haravikk<br>&gt; Please allow me to respond in-line hereunder, thanks.<br>&gt; Ted.<br>&gt;&gt; On 30.03.2016, at 16:15, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m in favour of implicit conversion for integers where no data can be lost (UInt32 to Int64, Int32 to Int64 etc.), in fact I posted a similar thread a little while ago but can’t find it; there’s something being done with numbers so this may be partly in the works.<br>&gt;&gt; <br>&gt;&gt; I definitely think that implicit conversion for floating point should be avoided, as it can’t be guaranteed<br>&gt; Why?  and   What cannot be guaranteed? <br></p><p><br>These all fail with a runtime error (&quot;Playground execution aborted: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)”, if you’re curious):<br>Int(Double.infinity)<br>Int(Double.NaN)<br>Int(Double.quietNaN)<br></p><p>And this loop runs for 1024 iterations before finding just one instance where the conversion from Int to Double and back to Int actually gives the right answer:<br>var i = UInt(Int.max) + 1<br>var remainder = UInt()<br>repeat {<br>    i -= 1<br>    let DoubleI = UInt(Double(i))<br>    remainder = DoubleI &gt; i ? DoubleI - i : i - DoubleI<br>} while remainder != 0<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f8af9ce9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 5:01 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt; which in many cases is unnecessary and costing time to code <br>&gt; for things that are quite obvious,<br>&gt; and cluttering the source, making it less readable.<br></p><p>Yes, I would also like to get to a model where “smaller things” can implicitly promote to “larger things”, when there is no loss of data (and in the case of CGFloat, we can be more loose with precision IMO).<br></p><p>This is covered under the guise of being able to define a subtype relationship between structs, which is something that I and many other people would love to have, but it is outside the scope of Swift 3.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 31, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 31.03.2016, at 00:12, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 5:01 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, one has to deal with explicit conversion between numerical types,<br>&gt;&gt; which in many cases is unnecessary and costing time to code <br>&gt;&gt; for things that are quite obvious,<br>&gt;&gt; and cluttering the source, making it less readable.<br>&gt; <br>&gt; Yes, I would also like to get to a model where “smaller things” can implicitly promote to “larger things”, when there is no loss of data (and in the case of CGFloat, we can be more loose with precision IMO).<br>Yes, I think so too.<br>&gt; <br>&gt; This is covered under the guise of being able to define a subtype relationship between structs, which is something that I and many other people would love to have, but it is outside the scope of Swift 3.<br>Technically, I don’t quite comprehend this yet, but will look it up :o)<br></p><p><br>&gt; <br>&gt; -Chris<br>&gt; <br>Thanks, Chris, I will now clear my head’s contents clean by listening to Led Zeppelin<br> (definitely not ISO conform) through my headphones at ca. 110 dB…<br>this of course blows right through all scope terminators known to man :o)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; This is covered under the guise of being able to define a subtype relationship between structs, which is something that I and many other people would love to have, but it is outside the scope of Swift 3.<br></p><p>Should this be on the &quot;Commonly Proposed&quot; list or in the &quot;Out of Scope&quot; list in the Github repo? This topic keeps coming up.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Implicit Type Conversion For Numerics Where Possible.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 4:41 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is covered under the guise of being able to define a subtype relationship between structs, which is something that I and many other people would love to have, but it is outside the scope of Swift 3.<br>&gt; <br>&gt; Should this be on the &quot;Commonly Proposed&quot; list or in the &quot;Out of Scope&quot; list in the Github repo? This topic keeps coming up.<br></p><p>You’re right!  Feel free to send a PR for the swift-evolution repo, I’d be happy to merge it.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
