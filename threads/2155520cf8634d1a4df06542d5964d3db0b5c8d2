<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>( Originally proposed here: https://forums.developer.apple.com/thread/13806 )<br></p><p>Often, frameworks will wish to provide a domain specific language for configuring or composition. Web frameworks for instance may define methods like<br></p><p>get(?/?) { request, result in ? }<br></p><p>Testing frameworks (such as Quick/Nimble) may wish to define a terse and expressive syntax for defining behavioral tests:<br></p><p>describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>      it(&quot;has everything you need to get started&quot;) {<br>            let sections = Directory(&quot;Documentation&quot;).sections<br>            expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>      }<br>}<br></p><p>While expressive, this has a big problem - describe, it, expect and contain are now defined as either global functions (which cause namespace pollution and mandate global state) or instance methods on a class (which requires the use of class inheritance, and is limited by single class inheritance)<br></p><p>You could have some sort of context object passed into the closure instead:<br></p><p>protocol SpecBuilder {<br>      func describe(description:String, inner:(QuickSpecContext)-&gt;())<br>}<br></p><p>protocol QuickSpecContext {<br>      func it(description:String, inner:(QuickSpecContext)-&gt;()) <br>      func expect&lt;T&gt;(statement:@autoclosure ()-&gt;T, file: StaticString = __FILE__, line: UWord = __LINE__ ) -&gt; Expectation&lt;T&gt;<br>}<br></p><p>var spec = QuickSpecBuilder(config)<br>spec.describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>      context in<br>      context.it(&quot;has everything you need to get started&quot;) {<br>            context in<br>            let sections = Directory(&quot;Documentation&quot;).sections<br>            context.expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>      }<br>}<br></p><p>But this has significantly more noise. So my proposal is to allow for a closure argument to be used as the current type instance- to be able to redefine ?self? within a block.<br></p><p>var spec = QuickSpecBuilder(config)<br>spec.describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>      self in<br>      it(&quot;has everything you need to get started&quot;) {<br>            self in<br>            let sections = Directory(&quot;Documentation&quot;).sections<br>            expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>      }<br>}<br></p><p>resolution remains the same (lexical scope shadowing the type), this is merely shorthand to allow expressive grammars without requiring class inheritance or global functions. It also remains optional to use - the last two examples are based around the same protocols and should compile to the same code.<br></p><p>I considered alternate syntaxes to express this, mostly alternatives on the bracketing of the closure itself to indicate binding a parameter to self. In the end, I decided:<br>1. When a block has multiple parameters, you would still need syntax decide which, if any, is bound to self<br>2. The language complexity in having another syntax for expressing closures with different behavior may not be worth it<br>3. Code would be confusing for those not knowing the new syntax. ?self in? is (comparatively) straightforward and descriptive<br></p><p><br>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/2155c8d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 10:28 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; ( Originally proposed here: https://forums.developer.apple.com/thread/13806 &lt;https://forums.developer.apple.com/thread/13806&gt; )<br>&gt; <br>&gt; Often, frameworks will wish to provide a domain specific language for configuring or composition. Web frameworks for instance may define methods like<br>&gt; <br>&gt; get(?/?) { request, result in ? }<br>&gt; <br>&gt; Testing frameworks (such as Quick/Nimble) may wish to define a terse and expressive syntax for defining behavioral tests:<br>&gt; <br>&gt; describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>&gt;       it(&quot;has everything you need to get started&quot;) {<br>&gt;             let sections = Directory(&quot;Documentation&quot;).sections<br>&gt;             expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; While expressive, this has a big problem - describe, it, expect and contain are now defined as either global functions (which cause namespace pollution and mandate global state) or instance methods on a class (which requires the use of class inheritance, and is limited by single class inheritance)<br>&gt; <br>&gt; You could have some sort of context object passed into the closure instead:<br>&gt; <br>&gt; protocol SpecBuilder {<br>&gt;       func describe(description:String, inner:(QuickSpecContext)-&gt;())<br>&gt; }<br>&gt; <br>&gt; protocol QuickSpecContext {<br>&gt;       func it(description:String, inner:(QuickSpecContext)-&gt;()) <br>&gt;       func expect&lt;T&gt;(statement:@autoclosure ()-&gt;T, file: StaticString = __FILE__, line: UWord = __LINE__ ) -&gt; Expectation&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; var spec = QuickSpecBuilder(config)<br>&gt; spec.describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>&gt;       context in<br>&gt;       context.it &lt;http://context.it/&gt;(&quot;has everything you need to get started&quot;) {<br>&gt;             context in<br>&gt;             let sections = Directory(&quot;Documentation&quot;).sections<br>&gt;             context.expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; But this has significantly more noise. So my proposal is to allow for a closure argument to be used as the current type instance- to be able to redefine ?self? within a block.<br>&gt; <br>&gt; var spec = QuickSpecBuilder(config)<br>&gt; spec.describe(&quot;the &#39;Documentation&#39; directory&quot;) {<br>&gt;       self in<br>&gt;       it(&quot;has everything you need to get started&quot;) {<br>&gt;             self in<br>&gt;             let sections = Directory(&quot;Documentation&quot;).sections<br>&gt;             expect(sections).to(contain(&quot;Organized Tests with Quick Examples and Example Groups?))<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; resolution remains the same (lexical scope shadowing the type), this is merely shorthand to allow expressive grammars without requiring class inheritance or global functions. It also remains optional to use - the last two examples are based around the same protocols and should compile to the same code.<br>&gt; <br>&gt; I considered alternate syntaxes to express this, mostly alternatives on the bracketing of the closure itself to indicate binding a parameter to self. In the end, I decided:<br>&gt; 1. When a block has multiple parameters, you would still need syntax decide which, if any, is bound to self<br>&gt; 2. The language complexity in having another syntax for expressing closures with different behavior may not be worth it<br>&gt; 3. Code would be confusing for those not knowing the new syntax. ?self in? is (comparatively) straightforward and descriptive<br></p><p>Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:<br></p><p>{<br>  import func QuickSpecBuilder.expect<br></p><p>  expect(sections).to(....)<br>}<br></p><p>Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change &#39;self&#39; has the potential to be even more confusing. In Javascript, it&#39;s my understanding the ability to arbitrarily rebind &#39;this&#39; is seen as a design flaw rather than a feature people regularly take advantage of.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/843b5d38/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 10:36 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:<br>&gt; <br>&gt; {<br>&gt;   import func QuickSpecBuilder.expect<br>&gt; <br>&gt;   expect(sections).to(....)<br>&gt; }<br></p><p>All of the matching methods (such as equal, contains, raiseError, raiseException) are also module functions, so you would likely just pull them all in. The Hamcrest Java project is very similar to Nimble, and they have a utility class generator (static methods calling other class static methods) specifically for reducing the number of static imports you have to put at the top of your test files.<br> <br>The most common use of DSLs is to give an expressive grammar to builder patterns. The Ruby on Rails router has perhaps had more man hours put into it than any other DSL on the platform, and its primary purpose is to build<br>  - a dispatch table to match and parse parameters out of incoming URLs, and stuff them into methods on controller instances<br>  - a method (actually methods) for the reverse behavior of taking parameters and building the appropriate path, e.g. user_path(current_user)<br></p><p>These are often hierarchal via closures. The use of closures both allows specific context to be made available based on the outer configuration, and for the actual use of a function to be deferred until it is needed. <br></p><p>Another example would be a DSL providing inversion of control. This might define methods to resolve objects by name, with the closures defining the construction behavior. The closure would get as a parameter the context of the DSL lookup, to allow it to lazily retrieve its own dependencies. However, this can’t be the global reference to the DSL object, because you want to fail on circular dependencies. Instead, you get a state object representing the particular request which was made of the system.<br></p><p>Yet another example is Quick itself - the ‘it’ and ‘expect’ functions are inheriting the ‘describe’ to aid in better error reporting, as well as any per-test invocation behavior (such as clearing out an in-memory database). This state can be passed in as an object, captured in lexical scope by the nested closure, or (in these cases) set and modified globally as needed. My concern is in people using global state to get the expressiveness they desire for their APIs.<br></p><p>With Nimble in particular, expect has state which currently (because it is a global function) has to be globally defined. This state also can’t be thread local, as your actual tests might involve multiple threads or callbacks.<br></p><p>&gt; <br>&gt; Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change &#39;self&#39; has the potential to be even more confusing. In Javascript, it&#39;s my understanding the ability to arbitrarily rebind &#39;this&#39; is seen as a design flaw rather than a feature people regularly take advantage of.<br>&gt; <br></p><p>Ruby has it as well, and while it perhaps a bit more ‘magic’ than some would desire, you will not find Ruby developers lamenting its existence. Javascript’s inconsistent historical behaviors greatly contribute to the perception that rebinding is a design flaw.<br></p><p>However, the behavior I’m describing is different than either Ruby or Javascript:<br>- both Ruby and Javascript are late bound, which allows the JIT implementations to adapt to whatever type instance is given. Swift is not a late bound language, so it must know the types it is working with beforehand<br>- Ruby and Javascript allow the caller to set self/this. The choice to consider one of the parameters to have ‘self’ behavior in my proposal is entirely in the hands of the person writing the block of code being called, by choosing to name one of the passed in parameters ‘self&#39;<br>- Due to late binding, it may be very difficult to determine what type your self/this is bound to in Ruby/Javascript. This is explicit in the signature of the closure in my proposal.<br>- Ruby and Javascript have no visual indicator that a block of code may be called with some other object as self/this. This is explicit in my proposal by naming one of the parameters in your closure ‘self&#39;<br>- Finally, as a side-effect you can choose to bind a parameter to self independent of the API designer if you feel that makes your code more readable. Admittedly, I removed my example as the code was simplistic enough that $0 was more concise<br></p><p>That said, as proposed this is an expressiveness feature. I proposed it because I found I was uncomfortable with the number of global functions and amount of global state I was seeing in Swift modules - but could not come up with a way to make said code more robust/safe without negatively affecting expressiveness.  <br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6d9610b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 4:44 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; All of the matching methods (such as equal, contains, raiseError,<br>&gt; raiseException) are also module functions, so you would likely just pull<br>&gt; them all in. The Hamcrest Java project is very similar to Nimble, and they<br>&gt; have a utility class generator (static methods calling other class static<br>&gt; methods) specifically for reducing the number of static imports you have to<br>&gt; put at the top of your test files.<br>&gt;<br></p><p>They don&#39;t need to be, though. Protocol extensions offer an improved way of<br>handling this. I put together a proof-of-concept PR a short while ago:<br></p><p>https://github.com/Quick/Nimble/pull/218<br></p><p><br>&gt; Ruby has it as well, and while it perhaps a bit more ‘magic’ than some<br>&gt; would desire, you will not find Ruby developers lamenting its existence.<br>&gt; Javascript’s inconsistent historical behaviors greatly contribute to the<br>&gt; perception that rebinding is a design flaw.<br>&gt;<br></p><p>The Ruby community in the past has been somewhat divided on the use of<br>instance_eval/exec vs. yielding block arguments for clarity, though there<br>are many popular DSL-like libraries that take advantage of<br>instance_eval/exec and are expressive and easy to read at the cost of<br>opaqueness.<br></p><p><br>&gt; However, the behavior I’m describing is different than either Ruby or<br>&gt; Javascript:<br>&gt; - both Ruby and Javascript are late bound, which allows the JIT<br>&gt; implementations to adapt to whatever type instance is given. Swift is not a<br>&gt; late bound language, so it must know the types it is working with beforehand<br>&gt; ...<br>&gt;<br></p><p>Perhaps a bracketed annotation could assign an unbound type to a closure:<br></p><p>    let builder: [MyType] () -&gt; Void = { ... }<br>    builder.bind(instance)() // or builder[instance](), or some other syntax<br></p><p>I agree that such a mechanism would allow for very expressive, type-safe<br>APIs. IDEs could take the guesswork out of &quot;what is &#39;self&#39;?&quot;. At the same<br>time, I understand apprehensions and aversions to both the complexity and<br>ambiguities associated with such a feature, and they may go against Swift&#39;s<br>principles at the moment.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/881363e1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015, at 09:36 AM, Joe Groff wrote:<br>&gt; Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:<br>&gt;<br>&gt; {  import func QuickSpecBuilder.expect<br>&gt;<br>&gt; expect(sections).to(....) }<br>&gt;<br>&gt; Being able to elide self is already somewhat controversial, and a<br>&gt; number of people find it makes code harder to read. I worry that<br>&gt; allowing closures to change &#39;self&#39; has the potential to be even more<br>&gt; confusing. In Javascript, it&#39;s my understanding the ability to<br>&gt; arbitrarily rebind &#39;this&#39; is seen as a design flaw rather than a<br>&gt; feature people regularly take advantage of.<br></p><p>I like this idea. I&#39;m very much against rebinding `self` because it<br>seems like an excellent source for confusion. Not only that, but the<br>actual underlying desire here isn&#39;t to remove `self` at all, but just to<br>introduce new functions into function resolution within a scope. And<br>this is precisely what adding imports in arbitrary scopes does (the only<br>downside being you need a line of code to add them, but that&#39;s not a big<br>deal). I know Rust allows this and it&#39;s pretty handy. I&#39;d love to have<br>this feature even when not using a DSL.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/506870b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Idea for enabling DSLs: bind to self in closures</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:51 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 4, 2015, at 09:36 AM, Joe Groff wrote:<br>&gt;&gt; Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:<br>&gt;&gt;  <br>&gt;&gt; {<br>&gt;&gt;   import func QuickSpecBuilder.expect<br>&gt;&gt;  <br>&gt;&gt;   expect(sections).to(....)<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change &#39;self&#39; has the potential to be even more confusing. In Javascript, it&#39;s my understanding the ability to arbitrarily rebind &#39;this&#39; is seen as a design flaw rather than a feature people regularly take advantage of.<br>&gt;  <br>&gt; I like this idea. I&#39;m very much against rebinding `self` because it seems like an excellent source for confusion. Not only that, but the actual underlying desire here isn&#39;t to remove `self` at all, but just to introduce new functions into function resolution within a scope. And this is precisely what adding imports in arbitrary scopes does (the only downside being you need a line of code to add them, but that&#39;s not a big deal). I know Rust allows this and it&#39;s pretty handy. I&#39;d love to have this feature even when not using a DSL.<br>&gt;  <br>&gt; -Kevin Ballard<br></p><p>A few thoughts:<br></p><p>1. In a lot of situations they are not pure functions - they have state associated across them determined by the context in which your closure was called. So the import would not be of a static function, but of an input parameter, aka:<br>	it(“…”) {<br>		builder in<br>		import builder<br>		expect(sections).to{…}<br>         }<br></p><p>Assuming expect is the only function, this may very well be equivalent to<br></p><p>	it(“…”) {<br>		builder in<br>		let expect = builder.expect<br>		expect(sections).to{…}<br>         }<br></p><p>2. expect, in the case of Nimble, is an overloaded function. I assume import would bring in all overloads?<br>3. I like the idea of providing additional scope rather than overriding self, as you would likely need to bind self to a new name per my proposal (aka [my = self] self in…)<br>4. I like the idea of this having lexical scope, and import being usable outside of closures<br>5. Imports likely should generate conflicts at compile-time if they shadow defined functions if you can do wildcard imports. No need to have syntax to alias names - one should either change the code to not conflict or use the longer-form names<br>6. import could be an attribute:<br>	it(“…”) {<br>		@import builder in<br>		expect(sections).to{…}<br>         }<br></p><p><br>-DW<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
