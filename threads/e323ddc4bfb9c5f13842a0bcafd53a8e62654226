<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi everyone. After implementing SE-0072, disabling the implicit bridging conversions from Swift value types to classes (https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md), we immediately observed a severe negative impact on Cocoa interop as our users at Apple adapted to the change, forcing us to roll it back. `id`-based interfaces are still all over the place in the Cocoa SDKs, but it&#39;s our goal that Swift programmers should be able to use the value type versions of things without being constantly confronted with marshalling in and out of their `NS` versions, and this change failed that test for Cocoa users. Furthermore, the Foundation corelibs team is interested in continuing to adopt more value types and improving the experience of using Foundation from Swift without being hamstrung by the limitations of ObjC interop. We can address the problem of value-type-to-id interfacing in a different way—instead of making it a special case in the type system, we can handle it in the Objective-C bridge instead, by bridging Objective-C&#39;s `id` type to `Any` instead of `AnyObject`. This is a big change, but I think it leads to an overall Swiftier and more flexible model. I&#39;m working on a proposal to this effect and would like to start getting feedback on it. Thanks for taking a look!<br></p><p>https://github.com/jckarter/swift-evolution/blob/1316004246e45296f81582477d70c22f95ec106c/proposals/XXXX-id-as-any.md<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  1, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 from me<br></p><p>I think that it makes sense since there exists now a possibility for Obj-C<br>types to come in as types with value semantics.<br></p><p>TJ<br></p><p>On Fri, Jul 1, 2016 at 7:37 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone. After implementing SE-0072, disabling the implicit bridging<br>&gt; conversions from Swift value types to classes (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md),<br>&gt; we immediately observed a severe negative impact on Cocoa interop as our<br>&gt; users at Apple adapted to the change, forcing us to roll it back.<br>&gt; `id`-based interfaces are still all over the place in the Cocoa SDKs, but<br>&gt; it&#39;s our goal that Swift programmers should be able to use the value type<br>&gt; versions of things without being constantly confronted with marshalling in<br>&gt; and out of their `NS` versions, and this change failed that test for Cocoa<br>&gt; users. Furthermore, the Foundation corelibs team is interested in<br>&gt; continuing to adopt more value types and improving the experience of using<br>&gt; Foundation from Swift without being hamstrung by the limitations of ObjC<br>&gt; interop. We can address the problem of value-type-to-id interfacing in a<br>&gt; different way—instead of making it a special case in the type system, we<br>&gt; can handle it in the Objective-C bridge instead, by bridging Objective-C&#39;s<br>&gt; `id` type to `Any` instead of `AnyObject`. This is a big change, but I<br>&gt; think it leads to an overall Swiftier and more flexible model. I&#39;m working<br>&gt; on a proposal to this effect and would like to start getting feedback on<br>&gt; it. Thanks for taking a look!<br>&gt;<br>&gt;<br>&gt; https://github.com/jckarter/swift-evolution/blob/1316004246e45296f81582477d70c22f95ec106c/proposals/XXXX-id-as-any.md<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/bb0541e8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m really happy to see this.  It cleans things up and enables some really important things such as more idiomatic bridging (NSNumber to native numeric types is amazing!).  The ideas mentioned will really help to make Cocoa feel as Swifty as possible.<br></p><p>Sent from my iPad<br></p><p>&gt; On Jul 1, 2016, at 6:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone. After implementing SE-0072, disabling the implicit bridging conversions from Swift value types to classes (https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md), we immediately observed a severe negative impact on Cocoa interop as our users at Apple adapted to the change, forcing us to roll it back. `id`-based interfaces are still all over the place in the Cocoa SDKs, but it&#39;s our goal that Swift programmers should be able to use the value type versions of things without being constantly confronted with marshalling in and out of their `NS` versions, and this change failed that test for Cocoa users. Furthermore, the Foundation corelibs team is interested in continuing to adopt more value types and improving the experience of using Foundation from Swift without being hamstrung by the limitations of ObjC interop. We can address the problem of value-type-to-id interfacing in a different way—instead of making it a special case in the type system, we can handle it in the Objective-C bridge instead, by bridging Objective-C&#39;s `id` type to `Any` instead of `AnyObject`. This is a big change, but I think it leads to an overall Swiftier and more flexible model. I&#39;m working on a proposal to this effect and would like to start getting feedback on it. Thanks for taking a look!<br>&gt; <br>&gt; https://github.com/jckarter/swift-evolution/blob/1316004246e45296f81582477d70c22f95ec106c/proposals/XXXX-id-as-any.md<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July  1, 2016 at 10:00:00pm</p></header><div class="content"><p>+1!<br></p><p>To me, it feels like the ambivalent dynamic casting is a temporary complexity, and that at some point in the future the need to expose legacy reference types like NSString outside swift-supplied or user-created bridging code will disappear completely.<br></p><p>This also will get rid of some of the rough edges in the various corelibs where value types cannot be supported because some platforms have a backing library written in Objective-C. Swiftier indeed!<br></p><p>Is this something you are pushing for in Swift 3? It seems appropriate but ambitious.<br></p><p>Just to cement my own understanding of the ambivalent dynamic casting - would the behavior be similar if the clang importer took id references and embedded them into a Bridgeable wrapper to defer bridging, and this Bridgeable wrapper (as well as Array, Dictionary and Set) was understood by the language to participate in as‽ behavior?<br></p><p>-DW<br></p><p>&gt; On Jul 1, 2016, at 5:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone. After implementing SE-0072, disabling the implicit bridging conversions from Swift value types to classes (https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md), we immediately observed a severe negative impact on Cocoa interop as our users at Apple adapted to the change, forcing us to roll it back. `id`-based interfaces are still all over the place in the Cocoa SDKs, but it&#39;s our goal that Swift programmers should be able to use the value type versions of things without being constantly confronted with marshalling in and out of their `NS` versions, and this change failed that test for Cocoa users. Furthermore, the Foundation corelibs team is interested in continuing to adopt more value types and improving the experience of using Foundation from Swift without being hamstrung by the limitations of ObjC interop. We can address the problem of value-type-to-id interfacing in a different way—instead of making it a special case in the type system, we can handle it in the Objective-C bridge instead, by bridging Objective-C&#39;s `id` type to `Any` instead of `AnyObject`. This is a big change, but I think it leads to an overall Swiftier and more flexible model. I&#39;m working on a proposal to this effect and would like to start getting feedback on it. Thanks for taking a look!<br>&gt; <br>&gt; https://github.com/jckarter/swift-evolution/blob/1316004246e45296f81582477d70c22f95ec106c/proposals/XXXX-id-as-any.md<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/111c5450/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 9:11 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1!<br>&gt; <br>&gt; To me, it feels like the ambivalent dynamic casting is a temporary complexity, and that at some point in the future the need to expose legacy reference types like NSString outside swift-supplied or user-created bridging code will disappear completely.<br>&gt; <br>&gt; This also will get rid of some of the rough edges in the various corelibs where value types cannot be supported because some platforms have a backing library written in Objective-C. Swiftier indeed!<br>&gt; <br>&gt; Is this something you are pushing for in Swift 3? It seems appropriate but ambitious.<br></p><p>Yes, we’re trying for it.  “Appropriate but ambitious” is an accurate assessment - this is a huge stretch by the entire team but Swift 3 is the right time for it.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  2, 2016 at 09:00:00am</p></header><div class="content"><p>Hey Chris,<br></p><p>Do you have plans to allow people to update Swift outside Xcode 8 point updates and still be able to submit to the App Store and benefit from the IDE&#39;s features? This could allow bug fixes to be delivered on a swifter way and take advantage of the fact that iOS is not including the runtime yet.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 2 Jul 2016, at 06:21, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 9:11 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1!<br>&gt;&gt; <br>&gt;&gt; To me, it feels like the ambivalent dynamic casting is a temporary complexity, and that at some point in the future the need to expose legacy reference types like NSString outside swift-supplied or user-created bridging code will disappear completely.<br>&gt;&gt; <br>&gt;&gt; This also will get rid of some of the rough edges in the various corelibs where value types cannot be supported because some platforms have a backing library written in Objective-C. Swiftier indeed!<br>&gt;&gt; <br>&gt;&gt; Is this something you are pushing for in Swift 3? It seems appropriate but ambitious.<br>&gt; <br>&gt; Yes, we’re trying for it.  “Appropriate but ambitious” is an accurate assessment - this is a huge stretch by the entire team but Swift 3 is the right time for it.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 1:20 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey Chris,<br>&gt; <br>&gt; Do you have plans to allow people to update Swift outside Xcode 8 point updates and still be able to submit to the App Store and benefit from the IDE&#39;s features? This could allow bug fixes to be delivered on a swifter way and take advantage of the fact that iOS is not including the runtime yet.<br></p><p>We don’t discuss Xcode future direction on the Swift lists, even though there is often overlap with the future of Swift.  OTOH, the future and direction of Swift is totally on topic for these lists.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 2 Jul 2016, at 06:21, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 9:11 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, it feels like the ambivalent dynamic casting is a temporary complexity, and that at some point in the future the need to expose legacy reference types like NSString outside swift-supplied or user-created bridging code will disappear completely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also will get rid of some of the rough edges in the various corelibs where value types cannot be supported because some platforms have a backing library written in Objective-C. Swiftier indeed!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this something you are pushing for in Swift 3? It seems appropriate but ambitious.<br>&gt;&gt; <br>&gt;&gt; Yes, we’re trying for it.  “Appropriate but ambitious” is an accurate assessment - this is a huge stretch by the entire team but Swift 3 is the right time for it.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  2, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 2, 2016, at 12:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 9:11 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1!<br>&gt;&gt; <br>&gt;&gt; To me, it feels like the ambivalent dynamic casting is a temporary complexity, and that at some point in the future the need to expose legacy reference types like NSString outside swift-supplied or user-created bridging code will disappear completely.<br>&gt;&gt; <br>&gt;&gt; This also will get rid of some of the rough edges in the various corelibs where value types cannot be supported because some platforms have a backing library written in Objective-C. Swiftier indeed!<br>&gt;&gt; <br>&gt;&gt; Is this something you are pushing for in Swift 3? It seems appropriate but ambitious.<br>&gt; <br>&gt; Yes, we’re trying for it.  “Appropriate but ambitious” is an accurate assessment - this is a huge stretch by the entire team but Swift 3 is the right time for it.<br></p><p>It looks that way for sure - I was surprised to see this so late in the cycle.  I really appreciate the team devoting the effort to try and get it done now.  It will make a big difference.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July  2, 2016 at 01:00:00pm</p></header><div class="content"><p>It does look like a huge benefit for many many current swift users. Thanks<br>to the whole team trying to make this happen in Swift 3.<br></p><p>On Fri, Jul 1, 2016 at 10:21 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 1, 2016, at 9:11 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1!<br>&gt; &gt;<br>&gt; &gt; To me, it feels like the ambivalent dynamic casting is a temporary<br>&gt; complexity, and that at some point in the future the need to expose legacy<br>&gt; reference types like NSString outside swift-supplied or user-created<br>&gt; bridging code will disappear completely.<br>&gt; &gt;<br>&gt; &gt; This also will get rid of some of the rough edges in the various<br>&gt; corelibs where value types cannot be supported because some platforms have<br>&gt; a backing library written in Objective-C. Swiftier indeed!<br>&gt; &gt;<br>&gt; &gt; Is this something you are pushing for in Swift 3? It seems appropriate<br>&gt; but ambitious.<br>&gt;<br>&gt; Yes, we’re trying for it.  “Appropriate but ambitious” is an accurate<br>&gt; assessment - this is a huge stretch by the entire team but Swift 3 is the<br>&gt; right time for it.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/356639b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Pitch] Importing Objective-C &#39;id&#39; as Swift &#39;Any&#39;</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>July  3, 2016 at 01:00:00am</p></header><div class="content"><p>+1, as long as the weird dynamic @objc method lookup behavior on<br>AnyObject isn&#39;t also carried over to Any as part of this proposal.  This<br>behavior is a source of frustration for me as it reduces how much I can<br>reason about code i work with when it creeps in unknowingly, and I don&#39;t<br>even like properties being exposed (which option 3 suggests), since<br>that&#39;s where I see it come up most often day to day. I&#39;d personally like<br>to see it go away completely.<br></p><p>I brought this up on the list a few months ago but I ended up not being<br>able to pursue a proposal at the time. However, my idea was that if we<br>need to keep dynamic lookup around, a dedicated protocol could have this<br>behavior applied to it, so that API consumers who need it could<br>explicitly opt into using the dynamic method lookup:<br></p><p>@objc protocol ObjcObject {} // defined in the stdlib/overlay/wherever<br>it makes the most sense<br></p><p>(Foo.foo() as ObjcObject).someDynamicallyDiscoveredMethod()<br></p><p>This has the added benefit of notifying readers of the code that it<br>isn&#39;t portable, since the type of the value is made explicit as one that<br>only is allowed in obj-c. Would this be a satisfactory solution to the<br>problem if this behavior needs to stay in place?<br></p><p>- Kevin<br></p><p>On 7/1/2016 7:37 PM, Joe Groff via swift-evolution wrote:<br>&gt; Hi everyone. After implementing SE-0072, disabling the implicit bridging conversions from Swift value types to classes (https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md), we immediately observed a severe negative impact on Cocoa interop as our users at Apple adapted to the change, forcing us to roll it back. `id`-based interfaces are still all over the place in the Cocoa SDKs, but it&#39;s our goal that Swift programmers should be able to use the value type versions of things without being constantly confronted with marshalling in and out of their `NS` versions, and this change failed that test for Cocoa users. Furthermore, the Foundation corelibs team is interested in continuing to adopt more value types and improving the experience of using Foundation from Swift without being hamstrung by the limitations of ObjC interop. We can address the problem of value-type-to-id interfacing in a different way—instead of making it a special case in the type system, we can handle it in the Objective-C bridge instead, by bridging Objective-C&#39;s `id` type to `Any` instead of `AnyObject`. This is a big change, but I think it leads to an overall Swiftier and more flexible model. I&#39;m working on a proposal to this effect and would like to start getting feedback on it. Thanks for taking a look!<br>&gt;<br>&gt; https://github.com/jckarter/swift-evolution/blob/1316004246e45296f81582477d70c22f95ec106c/proposals/XXXX-id-as-any.md<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
